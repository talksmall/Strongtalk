
"October 17, 2006 -> 14:36:48"!

! (Delta mirrorFor: #DefinitionWriter) methodsFor: 'Unclassified' !
fileOutBodyOn: stream <WriteStream> ^ <Int>

	| pos <Int> sortedCategories <Cltn[Str]> |
	pos := stream position.
	sortedCategories := self mirror sourceInfo categories asSortedCollection: 
			[ :s <Str> :s2 <Str> | s  <= s2  ]
	 do: [ :cat <Str> | 
		self fileOutCategory: cat on: stream ].
	^pos! !

"October 17, 2006 -> 14:37:7"!

! (Delta mirrorFor: #DefinitionWriter) methodsFor: 'Unclassified' !
fileOutBodyOn: stream <WriteStream> ^ <Int>

	| pos <Int> sortedCategories <Cltn[Str]> |
	pos := stream position.
	sortedCategories := self mirror sourceInfo categories asSortedCollection: 
			[ :s <Str> :s2 <Str> | s  <= s2  ].
	sortedCategories do: [ :cat <Str> | 
		self fileOutCategory: cat on: stream ].
	^pos! !

"October 17, 2006 -> 14:40:57"!

"System saved" !
"June 2, 2007 -> 20:46:56"!

"System saved" !
"June 4, 2007 -> 1:26:52"!

Delta define: #InstanceVariableOutliner as: (
(Class subclassOf: 'DefinitionItemOutliner' instanceVariables: '')) !


"June 4, 2007 -> 1:26:54"!

Delta define: #InstanceVariableOutliner as: (
(Class subclassOf: 'DefinitionItemOutliner' instanceVariables: '')) !


"June 4, 2007 -> 1:26:54"!

Delta define: #InstanceVariableOutliner as: (
(Class subclassOf: 'DefinitionItemOutliner' instanceVariables: '')) !


"June 4, 2007 -> 1:26:54"!

Delta define: #InstanceVariableOutliner as: (
(Class subclassOf: 'DefinitionItemOutliner' instanceVariables: '')) !


"June 4, 2007 -> 1:26:54"!

Delta define: #InstanceVariableOutliner as: (
(Class subclassOf: 'DefinitionItemOutliner' instanceVariables: '')) !


"June 4, 2007 -> 1:26:54"!

Delta define: #InstanceVariableOutliner as: (
(Class subclassOf: 'DefinitionItemOutliner' instanceVariables: '')) !


"June 4, 2007 -> 1:26:54"!

Delta define: #InstanceVariableOutliner as: (
(Class subclassOf: 'DefinitionItemOutliner' instanceVariables: '')) !


"June 4, 2007 -> 1:26:54"!

Delta define: #InstanceVariableOutliner as: (
(Class subclassOf: 'DefinitionItemOutliner' instanceVariables: '')) !


"June 4, 2007 -> 1:26:54"!

Delta define: #InstanceVariableOutliner as: (
(Class subclassOf: 'DefinitionItemOutliner' instanceVariables: '')) !


"June 4, 2007 -> 1:26:54"!

Delta define: #InstanceVariableOutliner as: (
(Class subclassOf: 'DefinitionItemOutliner' instanceVariables: '')) !


"June 4, 2007 -> 1:26:54"!

Delta define: #InstanceVariableOutliner as: (
(Class subclassOf: 'DefinitionItemOutliner' instanceVariables: '')) !


"June 4, 2007 -> 1:26:54"!

(Delta mirrorFor: #InstanceVariableOutliner)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"June 4, 2007 -> 1:26:55"!

! (Delta mirrorFor: #InstanceVariableOutliner) methodsFor: 'private' !
aspectForUpdate ^ <Symbol>

	^#instanceVariables
! !

"June 4, 2007 -> 1:26:56"!

! (Delta mirrorFor: #InstanceVariableOutliner) methodsFor: 'private' !
header ^ <Str>

	^'Instance variables'! !

"June 4, 2007 -> 1:26:57"!

! (Delta mirrorFor: #InstanceVariableOutliner) methodsFor: 'private' !
modelAsCharGlyphs ^ <CharGlyphs>

	| tool <ASTtoRichTextTool[CharGlyph]> pts <Cltn[ParseTree]> |
	self useRichTextForSources
		ifTrue: [
			pts := DeltaParser new
							parseInstVarList: self mirror instanceVariableString 
							within: (DeltaScope within: nil)
							ifError: [ :msg <Str> :pos <Int> | self shouldNotHappen ].
			^pts isEmpty
				ifTrue: [ 		OrderedCollection[CharGlyphs] new ]
				ifFalse: [ 	self richTextForParseTrees: pts ] ]
		ifFalse: [
			^self standardTextForString: self mirror instanceVariableString painter: self codePainter ]

! !

"June 4, 2007 -> 1:26:58"!

! (Delta mirrorFor: #InstanceVariableOutliner) methodsFor: 'private' !
storeAndOnSuccess: blk <[]>

	"The right way to do this is to have a #instanceVariables:ifFail: in ClassMirror and MixinDeclMirror
		that will parse and	update accordingly.
		
		In the meantime, we parse an extra time here to check for errors and call #instanceVariables: afterwards.
		This should be changed shortly."
		
	| ivs <Str> eval <Str> constructor <Mirror> |
	self deltaHack.
	ivs := self charGlyphModelAsString: self codeView.
	DeltaParser new 
		parseInstVarList: ivs
		within: (DeltaScope within: nil)
		ifError: [ :msg <Str> :pos <Int> | ^self showParseError: msg at: pos in: self codeView ].
	self mirror instanceVariables: ivs.
	blk value.
! !

"June 4, 2007 -> 1:26:59"!

! (Delta mirrorFor: #InstanceVariableOutliner) methodsFor: 'typechecking' !
typecheck

self typecheckAction:[self mirror typecheckInstVars]
		title: 'Typechecking ', self mirror name, ' instance variables'.! !

"June 4, 2007 -> 1:27:0"!

! (Delta mirrorFor: #InstanceVariableOutliner) methodsFor: 'accessing' !
locator ^ <ClassVarLocator>

^InstVarLocator ofDefinition: self mirror basicLocator! !

"June 4, 2007 -> 1:27:1"!

! (Delta mirrorFor: #InstanceVariableOutliner) methodsFor: 'menus' !
hasMenu ^<Boolean>

	^true! !

"June 4, 2007 -> 1:27:2"!

! (Delta mirrorFor: #InstanceVariableOutliner) methodsFor: 'menus' !
menuBar ^<Menu>

	^Menu new
		add: (MenuAction new
					name: 'References...';
					action: [ self referencesToInstVar ])
! !

"June 4, 2007 -> 1:27:3"!

! (Delta mirrorFor: #InstanceVariableOutliner) methodsFor: 'control' !
referencesToInstVar
! !

"June 4, 2007 -> 1:28:33"!

"System saved" !
"June 4, 2007 -> 1:31:2"!

"System saved" !
"June 4, 2007 -> 1:37:50"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"June 4, 2007 -> 1:37:50"!

(Delta mirrorFor: #Win32Platform)
comment: 
'The class side holds platform dependent constants and utilities.  Is also used
to get command line args, and other things like that.

Keywords: %machdep  %User

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.4 $
'!


"June 4, 2007 -> 1:37:52"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'platform classes' !
pathClass ^<FilePath class>

    ^Win32FilePath! !

"June 4, 2007 -> 1:37:53"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'platform classes' !
patternClass ^<FilePattern class>

    ^Win32FilePattern! !

"June 4, 2007 -> 1:37:54"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'testing' !
usesCrLfConvention ^<Boolean>

    ^true! !

"June 4, 2007 -> 1:37:55"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'constants' !
multipleMatchWildcardCharacter ^<Character>

    ^$*! !

"June 4, 2007 -> 1:37:55"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'constants' !
singleMatchWildcardCharacter ^<Character>

    ^$?! !

"June 4, 2007 -> 1:37:56"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'constants' !
wordSize ^<Int>
    ^4! !

"June 4, 2007 -> 1:37:57"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'command line' !
getArguments ^<OrdCltn[Str]>

    | line <Str> args <VarOrdCltn[Str]> strm <CharInputStream> |
    line := self getCommandLine.
    args := OrderedCollection[Str] new.
    strm := line readStream.

    [   "skip whitespace"
        [ strm atEnd not and: [ strm peekFor: Character space] ] whileTrue.
        strm atEnd ] whileFalse: [
            args addLast: (self parseArgFrom: strm).        ].
    ^args! !

"June 4, 2007 -> 1:37:58"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'command line' !
getCommandLine
    | p size result |
    p := {{<kernel ExternalProxy GetCommandLineA>getCommandLine}}.
    size := 0.
    [(p byteAt: size) == 0] whileFalse: [ size := size + 1 ].
    result := String new: size.
    1 to: size do: [:index |
       result at: index put: (Character value: (p byteAt: index - 1))
    ].
    ^result! !

"June 4, 2007 -> 1:37:59"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLInitialize
    DLLDict := Dictionary new.
    {{primitiveDLLSetupLookup: self selector: #DLLLookup:in: ifFail: [:err | self error: err]}}! !

"June 4, 2007 -> 1:38:0"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLLibrary: name
    ^DLLDict at: name ifAbsent: [
        DLLDict at: name put: (self DLLLoad: name)
    ]! !

"June 4, 2007 -> 1:38:1"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLLoad: name
    | r n |
    r := ExternalProxy new.
    n := (self DLLMapName: name) asSymbol.
    ^{{primitiveDLLLoad: n result: r ifFail: [ :err | self error: err]}}! !

"June 4, 2007 -> 1:38:2"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLLookup: name <Str> in: library <Str>
    "Convert library into proxy"
    | p r |
    p := self DLLLibrary: library.
    r := ExternalProxy new.
    {{primitiveDLLLookup: name asSymbol in: p result: r ifFail: [:err | self error: err]}}.
    ^r! !

"June 4, 2007 -> 1:38:3"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLMapName: name <Str> ^<Str>
    name = 'user'       ifTrue: [^'USER32.DLL'].
    name = 'gdi'            ifTrue: [^'GDI32.DLL'].
    name = 'kernel'     ifTrue: [^'KERNEL32.DLL'].
    name = 'comdlg'     ifTrue: [^'COMDLG32.DLL'].
    self error: 'Mapping ', name, ' not found'! !

"June 4, 2007 -> 1:38:4"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'initialization' !
initialize

    self DLLInitialize! !

"June 4, 2007 -> 1:38:5"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'os streams' !
errorStream ^<CharOutputStream>

    ErrorStream isNil
        ifTrue: [   ErrorStream := TempTranscript new ].
    ^ErrorStream! !

"June 4, 2007 -> 1:38:6"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'environment' !
environmentVariableAt: key <Str> ifAbsent: blk <[^X def]> ^ <Str | X>

    | cKey <CString> cValue <CString> size <Int> cSize <ExternalProxy> result <Str> done <Boolean> found <Boolean> |
    size := 1024.
    cKey := CString for: key.
    done := false.
    [ done ] whileFalse: [
        cValue := CString for: (String new: size).
        cSize := {{<kernel ExternalProxy GetEnvironmentVariableA> key: cKey buffer: cValue bufSize: size}}.
        cSize asSmallInteger > size
            ifTrue: [   cValue free.                                                    "Buffer size too small for value of variable"
                            size := cSize asSmallInteger ]
            ifFalse: [  done := true.                                                   "Buffer size ok, check if variable was found"
                            (found := cSize asSmallInteger ~= 0)
                                ifTrue: [ result := cValue asString ] ] ].
    cKey free. 
    cValue free.
    ^found
        ifTrue: [ result ]
        ifFalse: blk ! !

"June 4, 2007 -> 1:38:7"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'private-clipboard access' !
closeClipboard

    {{<user ExternalProxy CloseClipboard> call}}! !

"June 4, 2007 -> 1:38:8"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'private-clipboard access' !
emptyClipboard

    {{<user ExternalProxy EmptyClipboard> call}} asBoolean
        ifFalse: [ Win32 handleError ].
! !

"June 4, 2007 -> 1:38:9"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'private-clipboard access' !
openClipboard

    {{<user ExternalProxy OpenClipboard> hnd: Win32 NULL}} asBoolean
        ifFalse: [ Win32 handleError ].
! !

"June 4, 2007 -> 1:38:10"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'clipboard access' !
clipboardText: str <Str>

    self openClipboard.
    [   | glob <HGLOBAL> strm <ReadWriteStream[Character]> xstr <Str> |
        self emptyClipboard.

        "transform string into a form with lfs inserted"
        strm := (String new: str size) readWriteStream.
        str do:
            [ :c <Character> |
                strm put: c.
                c = Character cr
                    ifTrue: [ strm put: Character lf ].
            ].
        xstr := String withAll: strm contentsWritten.

        glob := HGLOBAL new
                        allocate: xstr size + 1
                        attributes: (Win32 GMEM_MOVEABLE
                                            externalBitOr: Win32 GMEM_DDESHARE).
        glob withPointer: CString new
                do: [ :cs <CString> |
                            cs value: xstr   ].

        {{<user ExternalProxy SetClipboardData>
                format: Win32 CF_TEXT
                data: glob
        }} isNull
            ifTrue: [ Win32 handleError ].
    ] ensure:
        [ self closeClipboard ]! !

"June 4, 2007 -> 1:38:11"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'clipboard access' !
clipboardTextIfAbsent: blk <[^X def]> ^<Str | X>

    self openClipboard.
    [   | glob <HGLOBAL> strm <CharWriteStream> |

        {{<user ExternalProxy IsClipboardFormatAvailable> format: Win32 CF_TEXT}} asBoolean
            ifFalse: [ ^blk value ].
        glob := {{<user HGLOBAL GetClipboardData> format: Win32 CF_TEXT}}.
        glob isNull
            ifTrue: [ Win32 handleError ].
        strm := (String new: 100) writeStream.
        glob withPointer: CString new
                do: [ :cs <CString> |
                            cs asString do:
                                [ :c <Character> |
                                    c = Character lf
                                        ifFalse: [ strm put: c ]
                                ].
                            ^strm contentsWritten
                      ].
    ] ensure:
        [ self closeClipboard ]! !

"June 4, 2007 -> 1:38:12"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'private' !
parseArgFrom: strm <CharInputStream>  ^<Str>

    ^strm peek = $"
        ifTrue: [       strm next.
                        strm upTo: $"   ]
        ifFalse: [  strm upTo: Character space ]! !

"June 4, 2007 -> 1:48:31"!

"System saved" !
"June 4, 2007 -> 2:36:39"!

Delta define: #UnixPlatform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"June 4, 2007 -> 2:36:39"!

(Delta mirrorFor: #UnixPlatform)
comment: 
'The class side holds platform dependent constants and utilities.  Is also used
to get command line args, and other things like that.

Keywords: %machdep  %User

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.4 $
'!


"June 4, 2007 -> 2:36:40"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'platform classes' !
pathClass ^<FilePath class>

    ^Win32FilePath! !

"June 4, 2007 -> 2:36:41"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'platform classes' !
patternClass ^<FilePattern class>

    ^Win32FilePattern! !

"June 4, 2007 -> 2:36:42"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'testing' !
usesCrLfConvention ^<Boolean>

    ^true! !

"June 4, 2007 -> 2:36:42"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'constants' !
multipleMatchWildcardCharacter ^<Character>

    ^$*! !

"June 4, 2007 -> 2:36:43"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'constants' !
singleMatchWildcardCharacter ^<Character>

    ^$?! !

"June 4, 2007 -> 2:36:44"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'constants' !
wordSize ^<Int>
    ^4! !

"June 4, 2007 -> 2:36:45"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'command line' !
getArguments ^<OrdCltn[Str]>

    | line <Str> args <VarOrdCltn[Str]> strm <CharInputStream> |
    line := self getCommandLine.
    args := OrderedCollection[Str] new.
    strm := line readStream.

    [   "skip whitespace"
        [ strm atEnd not and: [ strm peekFor: Character space] ] whileTrue.
        strm atEnd ] whileFalse: [
            args addLast: (self parseArgFrom: strm).        ].
    ^args! !

"June 4, 2007 -> 2:36:46"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'command line' !
getCommandLine
    | p size result |
    p := {{<kernel ExternalProxy GetCommandLineA>getCommandLine}}.
    size := 0.
    [(p byteAt: size) == 0] whileFalse: [ size := size + 1 ].
    result := String new: size.
    1 to: size do: [:index |
       result at: index put: (Character value: (p byteAt: index - 1))
    ].
    ^result! !

"June 4, 2007 -> 2:36:47"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLInitialize
    DLLDict := Dictionary new.
    {{primitiveDLLSetupLookup: self selector: #DLLLookup:in: ifFail: [:err | self error: err]}}! !

"June 4, 2007 -> 2:36:47"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLLibrary: name
    ^DLLDict at: name ifAbsent: [
        DLLDict at: name put: (self DLLLoad: name)
    ]! !

"June 4, 2007 -> 2:36:48"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLLoad: name
    | r n |
    r := ExternalProxy new.
    n := (self DLLMapName: name) asSymbol.
    ^{{primitiveDLLLoad: n result: r ifFail: [ :err | self error: err]}}! !

"June 4, 2007 -> 2:36:49"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLLookup: name <Str> in: library <Str>
    "Convert library into proxy"
    | p r |
    p := self DLLLibrary: library.
    r := ExternalProxy new.
    {{primitiveDLLLookup: name asSymbol in: p result: r ifFail: [:err | self error: err]}}.
    ^r! !

"June 4, 2007 -> 2:36:50"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLMapName: name <Str> ^<Str>
    name = 'user'       ifTrue: [^'USER32.DLL'].
    name = 'gdi'            ifTrue: [^'GDI32.DLL'].
    name = 'kernel'     ifTrue: [^'KERNEL32.DLL'].
    name = 'comdlg'     ifTrue: [^'COMDLG32.DLL'].
    self error: 'Mapping ', name, ' not found'! !

"June 4, 2007 -> 2:36:51"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'initialization' !
initialize

    self DLLInitialize! !

"June 4, 2007 -> 2:36:52"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'os streams' !
errorStream ^<CharOutputStream>

    ErrorStream isNil
        ifTrue: [   ErrorStream := TempTranscript new ].
    ^ErrorStream! !

"June 4, 2007 -> 2:36:53"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'environment' !
environmentVariableAt: key <Str> ifAbsent: blk <[^X def]> ^ <Str | X>

    | cKey <CString> cValue <CString> size <Int> cSize <ExternalProxy> result <Str> done <Boolean> found <Boolean> |
    size := 1024.
    cKey := CString for: key.
    done := false.
    [ done ] whileFalse: [
        cValue := CString for: (String new: size).
        cSize := {{<kernel ExternalProxy GetEnvironmentVariableA> key: cKey buffer: cValue bufSize: size}}.
        cSize asSmallInteger > size
            ifTrue: [   cValue free.                                                    "Buffer size too small for value of variable"
                            size := cSize asSmallInteger ]
            ifFalse: [  done := true.                                                   "Buffer size ok, check if variable was found"
                            (found := cSize asSmallInteger ~= 0)
                                ifTrue: [ result := cValue asString ] ] ].
    cKey free. 
    cValue free.
    ^found
        ifTrue: [ result ]
        ifFalse: blk ! !

"June 4, 2007 -> 2:36:54"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'private-clipboard access' !
closeClipboard

    {{<user ExternalProxy CloseClipboard> call}}! !

"June 4, 2007 -> 2:36:55"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'private-clipboard access' !
emptyClipboard

    {{<user ExternalProxy EmptyClipboard> call}} asBoolean
        ifFalse: [ Win32 handleError ].
! !

"June 4, 2007 -> 2:36:55"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'private-clipboard access' !
openClipboard

    {{<user ExternalProxy OpenClipboard> hnd: Win32 NULL}} asBoolean
        ifFalse: [ Win32 handleError ].
! !

"June 4, 2007 -> 2:36:57"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'clipboard access' !
clipboardText: str <Str>

    self openClipboard.
    [   | glob <HGLOBAL> strm <ReadWriteStream[Character]> xstr <Str> |
        self emptyClipboard.

        "transform string into a form with lfs inserted"
        strm := (String new: str size) readWriteStream.
        str do:
            [ :c <Character> |
                strm put: c.
                c = Character cr
                    ifTrue: [ strm put: Character lf ].
            ].
        xstr := String withAll: strm contentsWritten.

        glob := HGLOBAL new
                        allocate: xstr size + 1
                        attributes: (Win32 GMEM_MOVEABLE
                                            externalBitOr: Win32 GMEM_DDESHARE).
        glob withPointer: CString new
                do: [ :cs <CString> |
                            cs value: xstr   ].

        {{<user ExternalProxy SetClipboardData>
                format: Win32 CF_TEXT
                data: glob
        }} isNull
            ifTrue: [ Win32 handleError ].
    ] ensure:
        [ self closeClipboard ]! !

"June 4, 2007 -> 2:36:58"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'clipboard access' !
clipboardTextIfAbsent: blk <[^X def]> ^<Str | X>

    self openClipboard.
    [   | glob <HGLOBAL> strm <CharWriteStream> |

        {{<user ExternalProxy IsClipboardFormatAvailable> format: Win32 CF_TEXT}} asBoolean
            ifFalse: [ ^blk value ].
        glob := {{<user HGLOBAL GetClipboardData> format: Win32 CF_TEXT}}.
        glob isNull
            ifTrue: [ Win32 handleError ].
        strm := (String new: 100) writeStream.
        glob withPointer: CString new
                do: [ :cs <CString> |
                            cs asString do:
                                [ :c <Character> |
                                    c = Character lf
                                        ifFalse: [ strm put: c ]
                                ].
                            ^strm contentsWritten
                      ].
    ] ensure:
        [ self closeClipboard ]! !

"June 4, 2007 -> 2:36:59"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'private' !
parseArgFrom: strm <CharInputStream>  ^<Str>

    ^strm peek = $"
        ifTrue: [       strm next.
                        strm upTo: $"   ]
        ifFalse: [  strm upTo: Character space ]! !

"June 4, 2007 -> 2:38:38"!

"System saved" !
"June 4, 2007 -> 19:11:14"!

"System saved" !
"June 5, 2007 -> 2:15:5"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'command line' !
getArguments ^<OrdCltn[Str]>

    ^ {{ primitiveCommandLineArgs }}! !

"June 5, 2007 -> 2:16:16"!

"System saved" !
"June 5, 2007 -> 2:21:43"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'command line' !
getArguments ^<OrdCltn[Str]>

    ^ {{ primitiveCommandLineArgs }} asOrderedCollection
    	collect: [:bytes| bytes asString]! !

"June 5, 2007 -> 2:25:28"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'command line' !
getCommandLine
    | stream |
    stream := WriteStream on: ''.
    self getArguments do: [:arg| stream nextPutAll: arg]
    	separatedBy: [stream nextPut: $ ].
    ^stream contents! !

"June 5, 2007 -> 2:33:27"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'command line' !
getCommandLine
    | stream |
    stream := CharacterReadWriteStream on: ''.
    self getArguments do: [:arg| stream nextPutAll: arg]
    	separatedBy: [stream nextPut: $ ].
    ^stream contents! !

"June 5, 2007 -> 2:41:14"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'command line' !
getCommandLine
    | stream |
    stream := CharacterReadWriteStream on: ''.
    self getArguments do: [:arg| stream nextPutAll: arg; space].
    stream isEmpty ifTrue: [^''].
    ^stream copyFrom: 1 to stream size - 1! !

"June 5, 2007 -> 2:42:28"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'command line' !
getCommandLine
    | stream |
    stream := CharacterReadWriteStream on: ''.
    self getArguments do: [:arg| stream nextPutAll: arg; space].
    stream isEmpty ifTrue: [^''].
    ^stream copyFrom: 1 to: stream size - 1! !

"June 5, 2007 -> 2:44:40"!

"System saved" !
"June 5, 2007 -> 21:6:39"!

Delta define: #WinPOINT as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:6:39"!

(Delta mirrorFor: #WinPOINT)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.1 $
'!


"June 5, 2007 -> 21:6:40"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
asPoint ^<Point>
	^self x @ self y! !

"June 5, 2007 -> 21:6:41"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
structureSize ^<Int>
	^8! !

"June 5, 2007 -> 21:6:42"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
x ^<SmallInteger>

	^self smallIntegerAt: self xOffset! !

"June 5, 2007 -> 21:6:42"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
x: v <SmallInteger>

	self smallIntegerAt: self xOffset put: v! !

"June 5, 2007 -> 21:6:43"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
y ^<SmallInteger>

	^self smallIntegerAt: self yOffset! !

"June 5, 2007 -> 21:6:44"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
y: v <SmallInteger>

	self smallIntegerAt: self yOffset put: v! !

"June 5, 2007 -> 21:6:45"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'offsets' !
xOffset ^<Int>
	^0! !

"June 5, 2007 -> 21:6:46"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'offsets' !
yOffset ^<Int>
	^4! !

"June 5, 2007 -> 21:7:0"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:7:2"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:7:2"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:7:2"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:7:2"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:7:2"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:7:2"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:7:2"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:7:2"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:7:2"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:7:2"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:7:3"!

(Delta mirrorFor: #MINMAXINFO)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"June 5, 2007 -> 21:7:3"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'accessing' !
ptMaxSize ^<WinPOINT>

	^self subProxyAt: self ptMaxSizeOffset result: WinPOINT new! !

"June 5, 2007 -> 21:7:4"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'accessing' !
ptMaxTrackSize ^<WinPOINT>

	^self subProxyAt: self ptMaxTrackSizeOffset result: WinPOINT new! !

"June 5, 2007 -> 21:7:5"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'accessing' !
ptMinTrackSize ^<WinPOINT>

	^self subProxyAt: self ptMinTrackSizeOffset result: WinPOINT new! !

"June 5, 2007 -> 21:7:6"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'accessing' !
structureSize ^<Int>

	^40! !

"June 5, 2007 -> 21:7:6"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'offsets' !
ptMaxPositionOffset ^<Int>

	^16! !

"June 5, 2007 -> 21:7:7"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'offsets' !
ptMaxSizeOffset ^<Int>

	^8! !

"June 5, 2007 -> 21:7:8"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'offsets' !
ptMaxTrackSizeOffset ^<Int>

	^32! !

"June 5, 2007 -> 21:7:9"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'offsets' !
ptMinTrackSizeOffset ^<Int>

	^24! !

"June 5, 2007 -> 21:7:10"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'offsets' !
ptReservedOffset ^<Int>

	^0! !

"June 5, 2007 -> 21:7:25"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:7:28"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:7:28"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:7:28"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:7:29"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:7:29"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:7:30"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:7:30"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:7:31"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:7:31"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:7:31"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:7:32"!

(Delta mirrorFor: #Win32Control)
comment: 
'A Visual that has a corresponding native Win32 window.

%optional #commandWith: - should override to process any WM_COMMAND messages needed

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.5 $
'!


"June 5, 2007 -> 21:7:34"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'private' !
controlForHandle: hwnd <ExternalProxy> ifAbsent: b <[^X def]> ^<Win32Control | X>

	^self controlFor: (self controlIdFor: hwnd) ifAbsent: b! !

"June 5, 2007 -> 21:7:35"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'private' !
controls ^<VarDict[Int, Win32Control]>

	"Assumption: allers must be in a critical region for self"

	Controls isNil
		ifTrue: [ Controls := Dictionary[Int, Win32Control] new ].
	^Controls! !

"June 5, 2007 -> 21:7:36"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'private' !
dispatchMsgFor: hwnd <ExternalProxy>
msg: msg <SmallInteger>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^(self controlForHandle: hwnd ifAbsent: [ ^0 ])
		message: msg for: hwnd wParam: wParam lParam: lParam! !

"June 5, 2007 -> 21:7:37"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
assignId ^<Int>
	"Assign and return a unique control id number.  It is assumed that we are already in a
		critical region on the Win32Control."

	MaxControlId isNil
				ifTrue: [ MaxControlId := 1 ]
				ifFalse: [ MaxControlId := MaxControlId + 1].
	^MaxControlId! !

"June 5, 2007 -> 21:7:38"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
buttonColorMsg: hdc <ExternalProxy> for: control <Int> ^<ExternalData>

	^(self controlFor: control  ifAbsent: [ ^0 ]) buttonColorMsg: hdc! !

"June 5, 2007 -> 21:7:39"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
controlFor: id <Int> ifAbsent: b <[^X def]> ^<Win32Control | X>

	^Win32Control
		critical: [	self controls at: id ifAbsent: b ]! !

"June 5, 2007 -> 21:7:40"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
controlIdFor: hwnd <HWND> ^<Int>

	^{{<user ExternalProxy GetWindowLongA> hwnd: hwnd value: Win32 GWL_ID}} asSmallInteger.
! !

"June 5, 2007 -> 21:7:41"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
customWndProc ^<APICallback>

	"Don't need a critical region"
	CustomWndProc isNil
		ifTrue: [	CustomWndProc := APICallBack
							register:
								[ :hwnd <ExternalProxy> :msg <SmallInteger> :wParam <ExternalData> :lParam <ExternalData> |
									self dispatchMsgFor: hwnd msg: msg wParam: wParam lParam: lParam ]
							parameters: (OrderedCollection[Class]
								with: ExternalProxy with: SmallInteger with: ExternalProxy with: ExternalProxy).	].
	^CustomWndProc! !

"June 5, 2007 -> 21:7:42"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
drawItemMsg: data <DRAWITEMSTRUCT> for: control <Int> ^<ExternalData>

	^(self controlFor: control ifAbsent: [ ^0 ]) drawItemMsg: data! !

"June 5, 2007 -> 21:7:43"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
measureItemMsg: data <MEASUREITEMSTRUCT> for: control <Int> ^<ExternalData>

	^(self controlFor: control ifAbsent: [ ^0 ]) measureItemMsg: data! !

"June 5, 2007 -> 21:7:44"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
notificationMsg: notifyCode <ExternalData> for: control <Int>

	(self controlFor: control ifAbsent: [ ^0 ]) notificationMsg: notifyCode! !

"June 5, 2007 -> 21:7:44"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
registerControl: id <Int> for: inst <Win32Control>

	Win32Control critical: 
		[ self controls at: id put: inst	]! !

"June 5, 2007 -> 21:7:45"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
unregisterControl: id <Int>

	Win32Control critical: [ self controls removeKey: id ]! !

"June 5, 2007 -> 21:7:46"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'testing' !
debugEvents ^<Boolean>

	^Session debugEvents! !

"June 5, 2007 -> 21:7:47"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'testing' !
debugNotifications ^<Boolean>

	^false! !

"June 5, 2007 -> 21:7:48"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
backgroundPainter ^<Painter>

	backgroundPainter isNil
		ifTrue: [ ^super backgroundPainter ].
	^backgroundPainter! !

"June 5, 2007 -> 21:7:49"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
enabled ^<Boolean>

	^enabled! !

"June 5, 2007 -> 21:7:50"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
enabled: flag <Boolean>

	self enabled = flag
		ifFalse: [	self setEnabled: flag ].! !

"June 5, 2007 -> 21:7:51"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
fullyEnabled ^<Boolean>

	"is true if we are enabled and all parents are enabled"
	^self enabled and: [ super enabled ]! !

"June 5, 2007 -> 21:7:52"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
nativeWindow ^<Window | Win32Control>

	^self! !

"June 5, 2007 -> 21:7:53"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
redraw ^<Boolean>

	^redraw! !

"June 5, 2007 -> 21:7:54"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'control' !
changing

	"flush the cached background painter so that it updates"
	backgroundPainter := nil.
	
	super changing! !

"June 5, 2007 -> 21:7:55"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'control' !
deferringRedrawDo: blk <[^Object]>
	"defer redrawing during evaluation of blk.  If these calls are nested recursively,
	   redrawing is deferred until the outermost returns, at which point the entire control
	   is invalidated.  This can be used to surround a large number of changes to the receiver
	   that would otherwise cause redundant redrawing."

	| oldFlag <Boolean> |
	oldFlag := self redraw.
	self redraw: false.
	blk value.
	self redraw: oldFlag.
	oldFlag
		ifTrue: [ self invalidate ]! !

"June 5, 2007 -> 21:7:56"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'control' !
ignoreNextFocusSet: flag <Boolean>

	ignoreNextFocusSet := flag! !

"June 5, 2007 -> 21:7:57"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'control' !
release

	self hasWin32Handle
		ifTrue: [ self destroyWin32Handle ].
	super release.! !

"June 5, 2007 -> 21:7:58"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'control' !
visible: flag <Boolean>

	| data <ExternalData> |
	self assert: [ self hasWin32Handle ].

	data := flag ifTrue: [ Win32 SW_SHOW ] ifFalse: [ Win32 SW_HIDE ].
	{{<user ExternalProxy ShowWindow> hwnd: self win32Handle flag: data}}.! !

"June 5, 2007 -> 21:7:59"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'debugging' !
printAllocOn: strm <CharOutputStream>

	super printAllocOn: strm.
	self hasWin32Handle
		ifTrue: [	strm show: ' hwnd: '; print: self win32Handle ]
		ifFalse: [ strm show: ' (no hwnd)' ]! !

"June 5, 2007 -> 21:8:1"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'displaying' !
localDisplayOn: can <Canvas>

	can subwindowsToDisplay add: self! !

"June 5, 2007 -> 21:8:2"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'event handling' !
character: c <Character> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	^(self callOrigWndProcFor: ev msg) = 0! !

"June 5, 2007 -> 21:8:3"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'event handling' !
keyDown: key <Symbol> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	^(self callOrigWndProcFor: ev msg) = 0! !

"June 5, 2007 -> 21:8:4"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'event handling' !
keyUp: key <Symbol> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	^(self callOrigWndProcFor: ev msg) = 0! !

"June 5, 2007 -> 21:8:5"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'event handling' !
mouseEvent: type <Symbol> at: loc <Point> event: ev <UIEvent> ^<Boolean>

	| orig <Point> |

	"Translate location back into native window coordinates"
	orig := self allocation enclosingRect origin.
	^(self callOrigWndProcFor: ev msg withLParam: (ExternalProxy forHigh: loc y - orig y low: loc x - orig x)) = 0! !

"June 5, 2007 -> 21:8:6"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'geometry-local' !
allocation: r <Region> at: pos <Point>

	| oldAlloc <Region> alloc <Rect> oldLayoutStatus <Int> |
	oldLayoutStatus := self layoutStatus.
	oldAlloc := allocation.
	alloc := r enclosingRect.
	super allocation: r at: pos.

	oldAlloc isNil
		ifTrue: [ self win32Handle.		"Make sure window is created with the current allocation & position" ]
		ifFalse: [	| oldNativePos <Point> old <Rect> | 
						"We need to use a variable since pos...Window changes nativePos"
						old := oldAlloc enclosingRect.
						oldNativePos := nativePosition.
						self hasWin32Handle
							ifTrue: [	(old width ~= alloc width
													or: [ old height ~= alloc height
													or: [ oldNativePos ~= self nativePosition ]  ] )
												ifTrue: [  self updateWindowDimensions  ]	 ]
							ifFalse: [	self isAttached
												ifTrue: [ self win32Handle ]	] ].
	"Invalidate if we are relaying out as a %hack to solve the problems that a higher level
		relayoutAndInvalidate doesn't invalidate contained native windows like this one"
	oldLayoutStatus = Visual needsRelayout
		ifTrue: [ self invalidate ]! !

"June 5, 2007 -> 21:8:7"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'geometry-nonlocal' !
moveBy: positionDelta <Point>

	"We override this since moving a native visual will generate any needed invalidations
	  automatically."

	self adjustPositionBy: positionDelta! !

"June 5, 2007 -> 21:8:8"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'initialization' !
initialize

	super initialize.
	redraw := true.
	enabled := true.
	isFocus := false.
	self addNonLocalCount: 1.		"Receiver is non-local"
	ignoreNextFocusSet := false.

	self refreshInterval: self defaultRefreshInterval.
	self paintPending: false.
	self useDisplayBuffering: true.
	controls := IdentitySet[Win32Control] new.! !

"June 5, 2007 -> 21:8:10"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
checkPaintTime: t <Float>
	"If we have reached our refresh time, paint"

	(self hasWin32Handle and: [ self paintPending ])
		ifTrue: [ self nextPaintTime <= t
						ifTrue: [ self display ]
						ifFalse: [ self session needPaintAtTime: self nextPaintTime ]	 ]! !

"June 5, 2007 -> 21:8:11"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
controls ^<Extensible[Win32Control]>

	^controls! !

"June 5, 2007 -> 21:8:12"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
cursor ^<Cursor>

	^cursor! !

"June 5, 2007 -> 21:8:13"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
cursor: c <Cursor>

	cursor := c.! !

"June 5, 2007 -> 21:8:14"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
defaultRefreshInterval ^<Float>

	^0.25! !

"June 5, 2007 -> 21:8:15"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
globalFromLocalPosition: p <WinPOINT> ^<WinPOINT>

	| wp <WinPOINT> result <WinPOINT> |
	wp := WinPOINT new allocate.
	wp x: p x; y: p y.
	{{<user ExternalProxy ClientToScreen>
			handle: self win32Handle
			point: wp
	}} asBoolean
		ifFalse: [ Win32 handleError ].
	result := wp x @ wp y.
	wp free.
	^result! !

"June 5, 2007 -> 21:8:16"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
handleMouseEvent: type <Symbol> at: loc <Point> ^<Boolean>

	| ev <UIEvent> |

	"%todo: remove the dispatch block for all events; isn't needed anymore"
	ev := UIEvent
			forMsg: self session currentMsg
			dispatch:
				[ :e <UIEvent> :h <UIEventHandler> |
					h mouseEvent: type at: loc event: e ].
	Sampler notNil
		ifTrue: [ Sampler 
						in: self topWindow visual 
						sampleEvent: type 
						at: (loc translatedBy: self positionInTopWindow)
						event: ev ].
	^self mouseEvent: type at: loc event: ev! !

"June 5, 2007 -> 21:8:17"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
localFromGlobalPosition: p <WinPOINT> ^<WinPOINT>

	| wp <WinPOINT> result <WinPOINT> |
	wp := WinPOINT new allocate.
	wp x: p x; y: p y.
	{{<user ExternalProxy ScreenToClient>
			handle: self win32Handle
			point: wp
	}} asBoolean
		ifFalse: [ Win32 handleError ].
	result := wp x @ wp y.
	wp free.
	^result translatedBy: self allocation enclosingRect origin! !

"June 5, 2007 -> 21:8:18"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
nextPaintTime ^<Float>

	^nextPaintTime! !

"June 5, 2007 -> 21:8:19"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
nextPaintTime: t <Float>

	nextPaintTime := t! !

"June 5, 2007 -> 21:8:20"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
noPalette

	palette := nil! !

"June 5, 2007 -> 21:8:21"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
paintOccuring

	self nextPaintTime: Time clockValue + self refreshInterval.
	self paintPending: false.
	self session paintOccuredFor: self.! !

"June 5, 2007 -> 21:8:22"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
paintPending ^<Boolean>

	^paintPending! !

"June 5, 2007 -> 21:8:23"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
paintPending: b <Boolean>

	paintPending := b! !

"June 5, 2007 -> 21:8:24"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
palette ^<Palette>

	^palette! !

"June 5, 2007 -> 21:8:25"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
palette: p <Palette>

	p == palette
		ifTrue: [ ^self ].
	self assert: [ palette isNil ].
	palette := p! !

"June 5, 2007 -> 21:8:26"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
paletteChangedMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	wParam @= self win32Handle
		ifFalse: [ self recursiveRealizePaletteForeground: false updateColors: true.
						self palette isNil
							ifTrue: [ ^self callDefWndProcFor: hwnd
											msgCode: msg
											wParam: wParam
											lParam: lParam	].
					 ].
	^0! !

"June 5, 2007 -> 21:8:28"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
queryPaletteMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self recursiveRealizePaletteForeground: true updateColors: false.
	self palette isNil
		ifTrue: [ ^self callDefWndProcFor: hwnd
						msgCode: msg
						wParam: wParam
						lParam: lParam	].
	^0! !

"June 5, 2007 -> 21:8:29"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
recursiveRealizePaletteForeground: fore <Boolean> updateColors: update <Boolean>

	self palette isNil
		ifFalse: [	self withDCDo:
							[ :hdc <HDC> |
								| oldpal <Win32Handle> |
								oldpal := Palette select: self palette win32Handle into: hdc background: fore not.
								self palette unrealize.
								self palette realizeFor: hdc.
								Palette debugging
									ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
								Palette select: oldpal win32Handle into: hdc background: fore not.
							 ].
						self invalidate.
						].
	self controls do:
		[ :c <Win32Control> |
			c recursiveRealizePaletteForeground: fore updateColors: update ].! !

"June 5, 2007 -> 21:8:30"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
refreshInterval ^<Float>

	^refreshInterval! !

"June 5, 2007 -> 21:8:31"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
refreshInterval: d <Float>
	"Wait no longer than this amount of time (in seconds) between
		paint operations, if possible"

	refreshInterval := d! !

"June 5, 2007 -> 21:8:32"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
registerControl: c <Win32Control>

	self controls include: c! !

"June 5, 2007 -> 21:8:33"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
registerPaintTime

	self paintPending
		ifFalse: [	self paintPending: true.
						self nextPaintTime: Time clockValue + self refreshInterval.
						self session schedulePaintFor: self at: self nextPaintTime.	].! !

"June 5, 2007 -> 21:8:34"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
setCursor ^<ExternalData>

	^cursor isNil
		ifFalse: [	{{<user ExternalProxy SetCursor> handle: cursor win32Handle}}.
						1 ]
		ifTrue: [ 0 ]! !

"June 5, 2007 -> 21:8:35"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
setCursorMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^(cursor notNil
			and: [	| hitcode <Int> |
						hitcode := lParam asExternalProxy low.
						hitcode = 1 or: [ hitcode = 65534 ] "client area or disabled"  ])
		ifTrue: [ 	self setCursor.
						1 ]
		ifFalse: [ self callOrigWndProc: msg wParam: wParam lParam: lParam ]
! !

"June 5, 2007 -> 21:8:36"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
showTimes ^<Boolean>
	"Report preference, layout, and painting times on the transcript"

	^false! !

"June 5, 2007 -> 21:8:37"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
unregisterControl: c <Win32Control>

	self controls removeEvery: c! !

"June 5, 2007 -> 21:8:38"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
useDisplayBuffering ^<Boolean>

	^useDisplayBuffering! !

"June 5, 2007 -> 21:8:39"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
useDisplayBuffering: f <Boolean>

	useDisplayBuffering := f! !

"June 5, 2007 -> 21:8:41"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
withBufferedCanvasDo: drawing <[Canvas,^X def]> ^<X>

	^self withDirectCanvasDo:
		[ :directCanvas <Canvas> |
			| invalid <Rect> oldpal <Win32Handle> |
			invalid := directCanvas clippingRect.

			self session
				withBufferCanvasFor: invalid
				do: [ :bufferCanvas <Canvas> :buffer <HBITMAP> |
							self palette isNil
								ifFalse: [ oldpal := bufferCanvas win32Palette: self palette win32Handle ].

							"draw on the buffer canvas"
							drawing value: bufferCanvas.
							bufferCanvas shallowFlush.

							"Now, copy the buffer bits onto the screen"
							directCanvas atOffset: invalid origin
								do: [ bufferCanvas atOffset: invalid origin 
									do: [	directCanvas
													bitBlt: bufferCanvas
												extent: invalid extent
												op: UI ropCopy.		].	].
							oldpal notNil
								ifTrue: [ 	Palette debugging
													ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
												bufferCanvas win32Palette: oldpal ]. 
						].	
		]! !

"June 5, 2007 -> 21:8:42"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
withCanvasDo: drawing <[Canvas,^X def]> ^<X>

	^(self useDisplayBuffering and: [ Window bufferingPossible ])
		ifFalse: [	self withDirectCanvasDo: drawing ]
		ifTrue: [	self withBufferedCanvasDo: drawing ]! !

"June 5, 2007 -> 21:8:43"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
withDCDo: blk <[HDC]>
	"With the window's device context do the block (not for painting)"

	| hdc <HDC> |
	hdc := {{<user HDC GetDC> hwnd: self win32Handle}}.
	[ blk value: hdc ]
		ensure: [ hdc releaseDCFor: self win32Handle ]! !

"June 5, 2007 -> 21:8:45"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
withDirectCanvasDo: drawing <[Canvas,^X def]> ^<X>

	|	can <Canvas>
		ps <PAINTSTRUCT>
		paintBlk <[^Object]>
		result <X>
		oldpal <Win32Handle>  |

	"use a critical region to paint, since background painting might reuse the
	  same device context in the UI thread"
	^self critical:
		[	ps := PAINTSTRUCT new allocateZeroed.
			can := self beginPaint: self win32Handle paintStructure: ps.
			can isNull
				ifTrue: [ Win32 handleError ].
			can	initialize;
				toRelease: [ :dc <HDC> | "End paint will release the context" ];
				initClippingRectBeforeTranslation: ps rcPaint asRectangle;
				window: self.
			self palette isNil
				ifFalse: [ oldpal := can win32Palette: self palette win32Handle ].

			Session debugInvalidation
				ifTrue: [	can withPainter: (Painter new paint: Paint red)
									do: [ can displayFilledRectangle: ps rcPaint asRectangle; flush. ].
								Platform errorStream show: self class name, ' rendering: '; print: ps rcPaint asRectangle; cr.	].

			result := drawing value: can.
			oldpal notNil
				ifTrue: [ 	Palette debugging
									ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
								can win32Palette: oldpal ]. 
			can release. 

			self endPaint: self win32Handle paintStructure: ps.
			ps free.
			result	]! !

"June 5, 2007 -> 21:8:46"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Windows with mods' !
display

	"win32 controls do no Smalltalk level painting by default"! !

"June 5, 2007 -> 21:8:47"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'notification' !
detaching

	super detaching.
	self cleanUp! !

"June 5, 2007 -> 21:8:48"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'notification' !
isFocus: f <Boolean>

	isFocus := f.
	super isFocus: f.
! !

"June 5, 2007 -> 21:8:49"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'notification' !
nativePositionChanged

	"DON'T pass this message to super, since our children are native relative to us!!"

	(self checkForNativePositionChanging or: [ self isAttached ])
		ifTrue: [ self updateWindowDimensions ]! !

"June 5, 2007 -> 21:8:50"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
buildWin32Handle

	self subclassResponsibility! !

"June 5, 2007 -> 21:8:51"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
callOrigWndProc: msgCode <ExternalData> wParam: wParam <ExternalData> lParam: lParam <ExternalData>^<ExternalData>
	"Like callOrigWndProcFor:, but takes all args rather than using a MSG structure"

	"Note that we use the receiver's win32Handle below rather than the one in the message so
	 	 this works even when the event was generated during a grab"
	^{{<user ExternalProxy CallWindowProcA> 
		proc: self originalWndProc
		hwnd: self win32Handle
		msg: msgCode
		wparam: wParam
		lparam: lParam }}! !

"June 5, 2007 -> 21:8:52"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
callOrigWndProcFor: m <MSG> ^<ExternalData>

	"Note that we use the receiver's win32Handle below rather than the one in the message so
	 	 this works even when the event was generated during a grab"
	^{{<user ExternalProxy CallWindowProcA> 
		proc: self originalWndProc
		hwnd: self win32Handle
		msg: m message
		wparam: m wParam
		lparam: m lParam }}! !

"June 5, 2007 -> 21:8:53"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
callOrigWndProcFor: m <MSG> withLParam: lParam <ExternalData>^<ExternalData>
	"Like callOrigWndProcFor:, but overrides the lParam value from the msg"

	"Note that we use the receiver's win32Handle below rather than the one in the message so
	 	 this works even when the event was generated during a grab"
	^{{<user ExternalProxy CallWindowProcA> 
		proc: self originalWndProc
		hwnd: self win32Handle
		msg: m message
		wparam: m wParam
		lparam: lParam }}! !

"June 5, 2007 -> 21:8:54"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
canBeFocusCandidate ^<Boolean>
	"%optional: Subclasses that cannot be the input focus even when they are enabled should override this
	  to return false"

	^true! !

"June 5, 2007 -> 21:8:55"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
checkForNativePositionChanging ^<Boolean>
	"returns true if the native position has been changed"

	
	^self hasWin32Handle
			and: [	| oldpos <Point> |
						oldpos := nativePosition.
						oldpos ~= self nativePosition	]! !

"June 5, 2007 -> 21:8:56"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
cleanUp

	self isFocus
		ifTrue: [	self nativeWindow ignoreNextFocusSet: true.
						self session noInputFocus. ].
	self destroyWin32Handle.
! !

"June 5, 2007 -> 21:8:57"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
controlId ^<Int>

	^controlId! !

"June 5, 2007 -> 21:8:58"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
createNativeWindow

	"we need a critical region to protect the class variable:"
	Win32Control
		critical: [	controlId := self actualClass assignId.
							self actualClass registerControl: self controlId for: self.
							self paintPending: false.
							self buildWin32Handle.
							self palette notNil
								ifTrue: [ self recursiveRealizePaletteForeground: true updateColors: true. ].
							self nativeWindow registerControl: self.
	
							self originalWndProc: (self wndProc).
							self wndProc: self customWndProc.
							self isFocus
								ifTrue: [ self setFocus ].
						].! !

"June 5, 2007 -> 21:8:59"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
createVisible ^<Boolean>

	^true! !

"June 5, 2007 -> 21:9:0"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
customWndProc ^<APICallback>

	^self actualClass customWndProc! !

"June 5, 2007 -> 21:9:1"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
debugTest: msgCode <ExternalData> for: hwnd <ExternalData>

	Win32Control debugEvents
			ifTrue: [	Platform errorStream
									show: 'control winproc event: ';
									show: (MSG descriptionOf: msgCode asExternalProxy);
									show: ' window: ';
									print: hwnd;
									cr. 	].! !

"June 5, 2007 -> 21:9:2"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
destroyWin32Handle

	win32Handle notNil
		ifTrue: [	| hand <ExternalProxy> |
						self actualClass unregisterControl: self controlId.
						self nativeWindow unregisterControl: self.
						hand := self win32Handle.
						win32Handle := nil.		"We nil the handle before destroying so that we can tell
																we are dead if there is a focus shift caused by destroy"
						{{<user ExternalProxy DestroyWindow>
							handle: hand }}.		]! !

"June 5, 2007 -> 21:9:3"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
displayUpwardPopUpMenuAt: loc <Point> ^<Boolean>
	"Look up the parent chain for a popUp menu and display it, if there is one.
		Return true if one was found"

	| m <Menu> t <Timer> |
	m := self parent popUpMenuIfAbsent: [ ^false ].
	self	displayPopUpMenu: m
			at: loc
			forButton: #secondary.
	t := self session atIntervals: 1.0 do:
			[	m release.
				t release. ].
	^true! !

"June 5, 2007 -> 21:9:4"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
extendedWin32Style ^<ExternalData>

	^Win32 WS_EX_NOPARENTNOTIFY! !

"June 5, 2007 -> 21:9:6"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
handleMouseEvent: type <Symbol>
message: msgCode <ExternalData>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>

	| loc <Point> |
	"Translate to be relative to our origin"
	loc := (lParam low @ lParam high) + self allocation enclosingRect origin.
	self handleMouseEvent: type at: loc! !

"June 5, 2007 -> 21:9:7"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
hasWin32Handle ^<Boolean>

	^win32Handle notNil! !

"June 5, 2007 -> 21:9:8"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
invalidate: r <Region>

	self registerPaintTime.
	(self layoutStatus = Visual valid and: [ self hasWin32Handle ])
		ifTrue: [	| rect <Rect> nativerect <RECT> |

						nativerect := RECT new allocate.
						rect := r enclosingRect relativeTo: self allocation origin.
						nativerect
							left: rect left asInteger;
							right: rect right asInteger;
							top: rect top asInteger;
							bottom: rect bottom asInteger.
						{{<user ExternalProxy InvalidateRect>
							hwnd: self win32Handle
							RECT: nativerect
							erase: true}}.
						nativerect free.	]! !

"June 5, 2007 -> 21:10:22"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
nativePosition ^<Point>

	"We have to adjust for the fact that our allocation origin might not be 0@0"
	^nativePosition := self positionInContainingNativeWindow + self allocation enclosingRect origin! !

"June 5, 2007 -> 21:10:23"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
originalWndProc ^<HWND>

	^originalWndProc! !

"June 5, 2007 -> 21:10:23"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
originalWndProc: h <HWND>

	originalWndProc := h! !

"June 5, 2007 -> 21:10:25"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
redraw: flag <Boolean>
	"Tell the widget to start or stop redrawing (temporarily) when necessary.  This is usually used
		with a true arg before a large number of changes, followed by a send with a false arg."

	flag = self redraw
		ifFalse: [	redraw := flag.
						self hasWin32Handle
							ifTrue: [	self	sendMessage: Win32 WM_SETREDRAW
													wparam: flag asExternalData
													lparam: 0	]].! !

"June 5, 2007 -> 21:10:26"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
setEnabled: flag <Boolean>

	enabled := flag.
	win32Handle notNil
		ifTrue: [	{{<user ExternalProxy EnableWindow>
								handle: self win32Handle
								state: self fullyEnabled asExternalData}}.	].
! !

"June 5, 2007 -> 21:10:27"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
setWindowText: t <Str>

	| label <CString> |
	label := CString for: t.
	{{<user ExternalProxy SetWindowText>
		handle: self win32Handle
		str: label}}.
	label free.! !

"June 5, 2007 -> 21:10:28"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
updateWindowDimensions
	"set the control's native size and position"

	| pos <Point> |

	pos := self nativePosition.
	self paintPending: false.
	{{<user ExternalProxy MoveWindow>
		handle: self win32Handle
		x: pos x asInteger
		y: pos y asInteger
		width: self allocation enclosedRect width asInteger
		height: self allocation enclosedRect height asInteger
		repaint: true asExternalData
	 }} asBoolean
			ifFalse: [ Win32 handleError ]! !

"June 5, 2007 -> 21:10:29"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
win32Style ^<ExternalData>

	| s <ExternalData> |
	s := Win32 WS_CHILDWINDOW.
	self createVisible
		ifTrue: [ s := s externalBitOr: Win32 WS_VISIBLE. ].
	self fullyEnabled
		ifFalse: [ s := s externalBitOr: Win32 WS_DISABLED ].
	^s! !

"June 5, 2007 -> 21:10:30"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
wndProc ^<ExternalProxy>

	^Window wndProcOf: self win32Handle! !

"June 5, 2007 -> 21:10:31"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
wndProc: wp <ExternalProxy>

	Window wndProcOf: self win32Handle put: wp! !

"June 5, 2007 -> 21:10:32"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private-message handling' !
beforeKillFocus

	(self session hasInputFocus and: [ self session inputFocus nativeWindow = self ])
		ifTrue: [ self session noInputFocus ].! !

"June 5, 2007 -> 21:10:33"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private-message handling' !
beforeSetFocus

	ignoreNextFocusSet
		ifTrue: [	"We requested the focus, and have already recorded it, so
							ignore this."
						ignoreNextFocusSet := false.	]
		ifFalse: [	"We didn't request this, so windows must be requesting it, so
							record it"
						"We don't use becomeFocus here because that would cause another
							windows setFocus message"
						self session inputFocus: self.		]! !

"June 5, 2007 -> 21:10:34"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private-message handling' !
contextMenuMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<Boolean>

	^self displayUpwardPopUpMenuAt:
			(self localFromGlobalPosition: lParam low @ lParam high)! !

"June 5, 2007 -> 21:10:35"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private-testing' !
isFocusCandidate ^<Boolean>

	^self canBeFocusCandidate
		and: [ self hasWin32Handle
		and: [ self enabled ] ]! !

"June 5, 2007 -> 21:10:36"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private-testing' !
isRectangularAndOpaque ^<Boolean>

	^true! !

"June 5, 2007 -> 21:10:37"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-to session' !
blinkFocus: shown <Boolean>
	
! !

"June 5, 2007 -> 21:10:39"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
buttonColorMsg: hdc <ExternalProxy> ^<ExternalData>

	"Should only get sent to buttons, which override this"
	self shouldNotHappen! !

"June 5, 2007 -> 21:10:40"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
commandWith: notifyCode <ExternalData> ^<ExternalData>

	"Subclasses should override to process command msgs"! !

"June 5, 2007 -> 21:10:41"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
drawItemMsg: data <DRAWITEMSTRUCT> ^<ExternalData>

	self shouldNotHappen! !

"June 5, 2007 -> 21:10:42"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
hInstance ^<ExternalProxy>

	^self parent nativeWindow hInstance! !

"June 5, 2007 -> 21:10:43"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
measureItemMsg: data <MEASUREITEMSTRUCT> ^<ExternalData>

	self shouldNotHappen! !

"June 5, 2007 -> 21:10:44"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
message: msgCode <ExternalData>
for: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self debugTest: msgCode for: hwnd.

	(self session handleIfFocusMsg: msgCode for: self wParam: wParam lParam: lParam) = 0
		ifTrue: [ ^0 ].

	msgCode @= Win32 WM_LBUTTONDOWN 
		ifTrue: [	self handleMouseEvent: #primaryButtonDown
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_LBUTTONUP 
		ifTrue: [	self handleMouseEvent: #primaryButtonUp
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_LBUTTONDBLCLK
		ifTrue: [	self handleMouseEvent: #primaryButtonDoubleClick
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_RBUTTONDOWN 
		ifTrue: [	self handleMouseEvent: #secondaryButtonDown
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_RBUTTONUP 
		ifTrue: [	self handleMouseEvent: #secondaryButtonUp
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_RBUTTONDBLCLK
		ifTrue: [	self handleMouseEvent: #secondaryButtonDoubleClick
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_MOUSEMOVE 
		ifTrue: [	self handleMouseEvent: #mouseMove
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].

	msgCode @= Win32 WM_CTLCOLORBTN
		ifTrue: [ ^Win32Control buttonColorMsg: wParam asExternalProxy for: (Win32Control controlIdFor: lParam) ].

	msgCode @= Win32 WM_DRAWITEM
		ifTrue: [	^Win32Control drawItemMsg: (DRAWITEMSTRUCT forProxy: lParam) for: wParam asSmallInteger ].

	msgCode @= Win32 WM_MEASUREITEM
		ifTrue: [	| data <MEASUREITEMSTRUCT> |
						data := MEASUREITEMSTRUCT forProxy: lParam.
						data CtlType @= Win32 ODT_MENU
							ifFalse: [ ^Win32Control measureItemMsg: data for: data CtlID asSmallInteger ] ].

	(msgCode @= Win32 WM_COMMAND and: [ lParam @~= Win32 NULL ])
		ifTrue: [	"Then this is a control window notification, which should be forwarded back to the
						  smalltalk control object"
						Win32Control notificationMsg: wParam asExternalProxy high for: (Win32Control controlIdFor: lParam).
						^0 ].

	msgCode @= Win32 WM_SETFOCUS
		ifTrue: [ self beforeSetFocus ].
	msgCode @= Win32 WM_KILLFOCUS
		ifTrue: [ self beforeKillFocus ].

	msgCode @= Win32 WM_CONTEXTMENU
		ifTrue: [ (self contextMenuMsg: msgCode hwnd: hwnd wParam: wParam lParam: lParam)
						ifTrue: [ ^0 ]. ].

	msgCode @= Win32 WM_QUERYNEWPALETTE 
		ifTrue: [	self queryPaletteMsg: msgCode hwnd: hwnd
								wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_PALETTECHANGED 
		ifTrue: [	self paletteChangedMsg: msgCode hwnd: hwnd
								wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_SETCURSOR 
		ifTrue: [	^self setCursorMsg: msgCode hwnd: hwnd
								wParam: wParam lParam: lParam	 ].

	^{{<user ExternalProxy CallWindowProcA> 
		proc: self originalWndProc
		hwnd: hwnd
		msg: msgCode
		wparam: wParam
		lparam: lParam }}! !

"June 5, 2007 -> 21:10:46"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
notificationMsg: notifyCode <ExternalData>

	"Subclasses can extend to process notification msgs"

	Win32Control debugNotifications
			ifTrue: [ Platform errorStream
							show: 'control notification: ';
							print: notifyCode;
							show: ' window: ';
							print: self win32Handle;
							cr ].

	notifyCode @= Win32 BN_KILLFOCUS
		ifTrue: [ "%todo" ].
	notifyCode @= Win32 BN_SETFOCUS
		ifTrue: [ "%todo" ].
! !

"June 5, 2007 -> 21:10:47"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
sendMessage: msg <ExternalData>
wparam: wp <ExternalData>
lparam: lp <ExternalData>
^<ExternalProxy>

	^{{<user ExternalProxy SendMessageA>
			handle: self win32Handle
			msg: msg
			wparam: wp
			lparam: lp}}! !

"June 5, 2007 -> 21:10:48"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
setFocus

	ignoreNextFocusSet := true.
	 self win32Handle @= {{<user ExternalProxy GetFocus> call}}
		ifFalse: [  {{<user ExternalProxy SetFocus> hwnd: self win32Handle}} ]! !

"June 5, 2007 -> 21:10:49"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
win32Handle ^<HWND>

	win32Handle isNil	
		ifTrue: [ self createNativeWindow ].
	^win32Handle! !

"June 5, 2007 -> 21:10:50"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'testing' !
isFocus ^<Boolean>

	^isFocus! !

"June 5, 2007 -> 21:14:43"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 21:14:45"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 21:14:46"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 21:14:46"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 21:14:47"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 21:14:48"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 21:14:49"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 21:14:49"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 21:14:50"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 21:14:50"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 21:14:51"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 21:14:52"!

(Delta mirrorFor: #Window)
comment: 
'Native windows, with a fairly machine independent interface
(except for methods with ''win32'' in their names).

Tags: %User %UI

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.
'!


"June 5, 2007 -> 21:14:54"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'custom messages' !
LAYOUT ^<ExternalData>
	"This is by the UI thread to tell a window's session process to layout a window.  This has
	  to be done through the message queue so that the layout code runs in the window's session
	  process.  lParam low is width, and lParam high is height."

	^16r400! !

"June 5, 2007 -> 21:14:55"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'debugging' !
bufferingPossible ^<Boolean>

	BufferingPossible isNil
		ifTrue: [ BufferingPossible := true ].
	^BufferingPossible! !

"June 5, 2007 -> 21:14:56"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'debugging' !
bufferingPossible: f <Boolean>
	"If this is set to false, all double buffering will be disabled, usually for debugging
		purposes."

	BufferingPossible := f! !

"June 5, 2007 -> 21:14:57"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
defaultWin32Cursor ^<ExternalProxy>

	^{{<user ExternalProxy LoadCursorA> arg: 0 arg: Win32 IDC_ARROW}}! !

"June 5, 2007 -> 21:14:58"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
defaultWin32Icon ^<ExternalProxy>

	^{{<user ExternalProxy LoadIconA> arg: 0 arg: Win32 IDI_APPLICATION}}! !

"June 5, 2007 -> 21:14:59"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
defaultWndProc ^<ExternalProxy>

	"Don't need a critical region because duplicate inits are no problem"
	DefaultWndProc isNil
		ifTrue: [	DefaultWndProc := Platform DLLLookup: 'DefWindowProcA' in: 'user' ].
	^DefaultWndProc! !

"June 5, 2007 -> 21:15:0"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
parentOf: w <HWND> ^<HWND>

	^{{<user ExternalProxy GetParent> wnd: w}}! !

"June 5, 2007 -> 21:15:1"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
wndProcOf: w <HWND> ^<HWND>

	^{{<user ExternalProxy GetWindowLongA> wnd: w attr: Win32 GWL_WNDPROC}}! !

"June 5, 2007 -> 21:15:2"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
wndProcOf: w <HWND> put: newWinProc <HWND> ^<HWND>

	^{{<user ExternalProxy SetWindowLongA> wnd: w attr: Win32 GWL_WNDPROC value: newWinProc}}! !

"June 5, 2007 -> 21:15:3"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
addNonLocalCount: delta <Int>
	
	! !

"June 5, 2007 -> 21:15:4"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
containerBackgroundPainter ^<Painter>

	^Painter defaultBackground! !

"June 5, 2007 -> 21:15:5"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
containsFocus: flag <Boolean>

	flag
		ifTrue: [	self session activeWindow: self.
						self mostRecentInputFocus: session inputFocus.	].
	"We don't need to remove the active window ifFalse because the session does that"! !

"June 5, 2007 -> 21:15:6"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
displayNowIfInvalid
	"Redraw any invalid areas before proceeded"

	self display! !

"June 5, 2007 -> 21:15:7"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
displayPopUpMenu: menu <Menu> at: loc <Point> forButton: button <Symbol>

	| gloc <Point> flags <ExternalData> |
	popUpMenu := menu.

	flags := Win32 TPM_LEFTALIGN.
	button = #left
		ifTrue: [ flags := flags externalBitOr: Win32 TPM_LEFTBUTTON ]
		ifFalse: [ flags := flags externalBitOr: Win32 TPM_RIGHTBUTTON ].

	gloc := self globalFromLocalPosition: loc.
	{{<user ExternalProxy TrackPopupMenu>
		handle: menu win32Handle
		flags: flags
		x: gloc x
		y: gloc y
		reserved: 0
		window: self win32Handle
		rect: Win32 NULL
	}} asBoolean
		ifFalse: [ Win32 getLastError @= Win32 ERROR_POPUP_ALREADY_ACTIVE
							ifFalse: [ Win32 handleError ].
						].

	popUpMenu := nil.
! !

"June 5, 2007 -> 21:15:9"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
invalidate: r <Region> forChild: child <Visual>

	self invalidate: (r enclosingRect translatedBy: child position)! !

"June 5, 2007 -> 21:15:10"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
isAttached ^<Boolean>

	^true! !

"June 5, 2007 -> 21:15:11"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
nativeWindow ^<Window | Win32Control>

	^self! !

"June 5, 2007 -> 21:15:12"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
parentVisualOfChild ^<Visual>

	self shouldNotHappen! !

"June 5, 2007 -> 21:15:13"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
popUpMenuIfAbsent: f <[^X def]> ^<Menu | X>

	^f value! !

"June 5, 2007 -> 21:15:15"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
positionInContainingNativeWindowOf: child <Visual> ^<Point>

	^child position! !

"June 5, 2007 -> 21:15:16"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
positionInTopWindowOf: child <Visual>

	^child position! !

"June 5, 2007 -> 21:15:17"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
scrollIfNeededToMakeVisible: area <Rect>
relativeTo: v <Visual>
minimizeMotion: minimizeMotion <Boolean>


	! !

"June 5, 2007 -> 21:15:18"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
scrollMeOrAParentBy: distance <Int> vertical: vertical <Boolean>

	"do nothing"! !

"June 5, 2007 -> 21:15:19"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
topWindow ^<Window>

	^self! !

"June 5, 2007 -> 21:15:20"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
translate: p <Point> fromChild: child <Visual> ^<Point>

	"Translate p from the child's coordinates to ours"
	^p translatedBy: child position! !

"June 5, 2007 -> 21:15:21"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
translate: p <Point> toChild: child <Visual> ^<Point>

	"Translate p from our coordinates to the child's"
	^p relativeTo: child position! !

"June 5, 2007 -> 21:15:23"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
translateRect: r <Rect> fromChild: child <Visual> ^<Rect>

	"Translate p from the child's coordinates to ours"
	^r translatedBy: child position! !

"June 5, 2007 -> 21:15:24"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
translateRect: r <Rect> toChild: child <Visual> ^<Rect>

	"Translate p from the child's coordinates to ours"
	^r relativeTo: child position! !

"June 5, 2007 -> 21:15:25"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
allocation ^<Region>

	^Point origin corner: self extent! !

"June 5, 2007 -> 21:15:27"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
backgroundPainter ^<Painter>
	"The paint for the window background.  This can be automatically derived from the
	 background painter for the visual.  It can also be set explicitly."

	^self hasBackgroundPainter
		ifTrue: [ backgroundPainter ]
		ifFalse: [ backgroundPainter := self visual backgroundPainter ]! !

"June 5, 2007 -> 21:15:28"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
backgroundPainter: p <Painter>

	backgroundPainter := p! !

"June 5, 2007 -> 21:15:29"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
cursor ^<Cursor>

	^cursor! !

"June 5, 2007 -> 21:15:30"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
cursor: c <Cursor>

	cursor := c.! !

"June 5, 2007 -> 21:15:31"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
desiredPosition: p <Point>

	desiredPosition := p! !

"June 5, 2007 -> 21:15:32"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
enabled ^<Boolean>

	^enabled! !

"June 5, 2007 -> 21:15:34"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
enabled: flag <Boolean>

	self enabled = flag
		ifFalse: [	self setEnabled: flag ].! !

"June 5, 2007 -> 21:15:35"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
extent ^<Point>

	^extent! !

"June 5, 2007 -> 21:15:36"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
hasParent ^<Boolean>

	^parent notNil! !

"June 5, 2007 -> 21:15:37"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
hasSession ^<Session>

	^session notNil! !

"June 5, 2007 -> 21:15:38"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
hasWin32Handle ^<Boolean>

	^win32Handle notNil! !

"June 5, 2007 -> 21:15:39"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
initialInputFocus: v <Visual>

	initialInputFocus := v! !

"June 5, 2007 -> 21:15:41"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
max ^<Rect>

	^max! !

"June 5, 2007 -> 21:15:42"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
medium ^<Medium>

	^medium! !

"June 5, 2007 -> 21:15:43"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
menu ^<Menu>

	^menu! !

"June 5, 2007 -> 21:15:44"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
menu: m <Menu>

	menu isNil
		ifFalse: [ menu release ].
	menu := m.
	menu window: self.
	self hasWin32Handle
		ifTrue: [ self setNativeMenu ]! !

"June 5, 2007 -> 21:15:45"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
min ^<Rect>

	^min! !

"June 5, 2007 -> 21:15:47"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
mostRecentInputFocus: v  <Visual>

	mostRecentInputFocus := v! !

"June 5, 2007 -> 21:15:48"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
name: nm <Str>

	"By default, do nothing. Subclasses with a title bar can override this"! !

"June 5, 2007 -> 21:15:49"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
natural ^<Rect>

	^natural! !

"June 5, 2007 -> 21:15:50"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
noPalette

	palette := nil! !

"June 5, 2007 -> 21:15:51"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
optimizeIncrementalLayout ^<Boolean>
^false.
	^optimizeIncrementalLayout! !

"June 5, 2007 -> 21:15:52"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
optimizeIncrementalLayout: f <Boolean>

	(f ~= optimizeIncrementalLayout and: [ self hasWin32Handle ])
		ifTrue: [ self changing ].
	optimizeIncrementalLayout := f.! !

"June 5, 2007 -> 21:15:54"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
palette ^<Palette>

	^palette! !

"June 5, 2007 -> 21:15:55"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
palette: p <Palette>

	p == palette
		ifTrue: [ ^self ].
	self assert: [ palette isNil ].
	palette := p! !

"June 5, 2007 -> 21:15:56"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
parent ^<Window>

	^parent! !

"June 5, 2007 -> 21:15:58"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
parent: p <Window>
	"This message must be sent before the window handle is created"

	parent := p! !

"June 5, 2007 -> 21:15:59"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
refreshInterval ^<Float>

	^refreshInterval! !

"June 5, 2007 -> 21:16:0"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
refreshInterval: d <Float>
	"Wait no longer than this amount of time (in seconds) between
		paint operations, if possible"

	refreshInterval := d! !

"June 5, 2007 -> 21:16:1"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
session ^<Session>

	^session! !

"June 5, 2007 -> 21:16:2"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
setNativeMenu

	{{<user ExternalProxy SetMenu>
		wnd: self win32Handle
		menu: self menu win32Handle
	}} asBoolean
		ifFalse: [ Win32 handleError ]! !

"June 5, 2007 -> 21:16:3"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
toClose ^<[Window]>

	^toClose! !

"June 5, 2007 -> 21:16:5"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
toClose: blk <[Window]>

	toClose := blk! !

"June 5, 2007 -> 21:16:6"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
useDisplayBuffering ^<Boolean>

	^useDisplayBuffering! !

"June 5, 2007 -> 21:16:7"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
useDisplayBuffering: f <Boolean>

	useDisplayBuffering := f! !

"June 5, 2007 -> 21:16:8"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
visual ^<Visual>

	^visual! !

"June 5, 2007 -> 21:16:10"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
close
	"Close and destroy the window.  This causes release to be sent to the window and its visual"

	self session aboutToDestroyWindow: self.
	{{<user ExternalProxy DestroyWindow> arg: win32Handle}}.
! !

"June 5, 2007 -> 21:16:11"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
ignoreNextFocusSet: flag <Boolean>

	ignoreNextFocusSet := flag! !

"June 5, 2007 -> 21:16:12"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
invalidate

	self visual layoutStatus > Visual invalid
		ifTrue: [ self invalidate: self allocation enclosingRect	].! !

"June 5, 2007 -> 21:16:13"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
invalidate: r <Region>

	| rect <Rect> |

	self registerPaintTime.
	rect := r enclosingRect.
	(self scratchRECT)
		left: rect left asInteger;
		right: rect right asInteger;
		top: rect top asInteger;
		bottom: rect bottom asInteger.
	{{<user ExternalProxy InvalidateRect>
		hwnd: self win32Handle
		RECT: self scratchRECT
		erase: false asExternalData}}! !

"June 5, 2007 -> 21:16:14"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
makeActive
	"Make this the active window"

	{{<user ExternalProxy SetForegroundWindow> hwnd: self win32Handle }}.! !

"June 5, 2007 -> 21:16:16"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
release

	scratchRECT free.

	self session unregisterWindow: self.

	visual notNil
		ifTrue: [	visual detaching; release.
						visual := nil.	].

	win32Handle := nil.

	self hasMenu
		ifTrue: [ self menu release ].
	mostRecentInputFocus := nil.
	menu := nil.
	popUpMenu := nil.
	toClose := nil.
	controls := nil.
! !

"June 5, 2007 -> 21:16:17"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
requestClose

	self toClose value: self.! !

"June 5, 2007 -> 21:16:18"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
show
	"Make the window visible"

	{{<user ExternalProxy ShowWindow>
			window: self win32Handle
			nCmdShow: self nCmdShow}}.
	! !

"June 5, 2007 -> 21:16:19"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
showModal
	"Make the window visible as a modal window"

	self session addModalWindow: self.
	self show.
	! !

"June 5, 2007 -> 21:16:20"!

! (Delta mirrorFor: #Window) methodsFor: 'debugging' !
dumpOn: strm <CharOutputStream>

Transcript show: self class name, ' extent: '; print: self extent; show: ' hwnd: '; print: self win32Handle; cr.
	self visual dumpOn: strm indent: 1.! !

"June 5, 2007 -> 21:16:22"!

! (Delta mirrorFor: #Window) methodsFor: 'event handling' !
character: c <Character> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	^(self visual character: c focus: focus event: ev)
		or: [	c = Character tab
					onTrue: [ self handleTabEvent: ev ] ]! !

"June 5, 2007 -> 21:16:23"!

! (Delta mirrorFor: #Window) methodsFor: 'event handling' !
keyDown: key <Symbol> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	(self visual keyDown: key focus: focus event: ev)
		ifTrue: [ ^true ].
		
	(key = #TAB and: [ ev ctrlPressed ])
		ifTrue: [ self handleTabEvent: ev.	^true ].
	key = #F1 ifTrue: [ Profiler start.	^true ].
	key = #F2 ifTrue: [ Profiler stop.	^true ].
	^false	! !

"June 5, 2007 -> 21:16:24"!

! (Delta mirrorFor: #Window) methodsFor: 'event handling' !
keyUp: key <Symbol> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	^self visual keyUp: key focus: focus event: ev
! !

"June 5, 2007 -> 21:16:26"!

! (Delta mirrorFor: #Window) methodsFor: 'event handling' !
mouseEvent: type <Symbol> at: loc <Point> event: ev <UIEvent> ^<Boolean>

	^self visual layoutStatus = Visual valid
		and: [ 	| grabGotIt <Boolean> |
						grabGotIt := self session
												mouseEvent: type
												at: loc
												event: ev.
						grabGotIt or: [	(self visual renderingRegion inParentContainsPoint: loc)
												and: [	Sampler notNil
																ifTrue: [ Sampler in: self visual sampleEvent: type at: loc - self visual position event: ev ].
															self visual
																mouseEvent: type
																at: loc - self visual position
																event: ev	] ] ]
! !

"June 5, 2007 -> 21:16:27"!

! (Delta mirrorFor: #Window) methodsFor: 'initialization' !
initSession: sess <Session>
visual: vis <Visual>

	medium := sess medium.
	session := sess.
	visual := vis.

	(self visual)
		parent: self id: 1.

	self showTimes
		ifTrue: [ Transcript show: 'prefs: '; print: [ self computePreferences ] time; cr. ]
		ifFalse: [ self computePreferences ].

	scratchRECT := RECT new allocate.
	self optimizeIncrementalLayout: true.
	ignoreNextFocusSet := false.

	self refreshInterval: self defaultRefreshInterval.
	self paintPending: false.
	self useDisplayBuffering: true.

	self toClose: [ :w <Window> | w close ].
	self enabled: true.
	controls := IdentitySet[Win32Control] new.
	self haveErased: false.! !

"June 5, 2007 -> 21:16:29"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
activeMenu ^<Menu>
	"Returns the menu that is currently active, if there is one.  It may either be the top level menu,
	  or a popup menu over the window"

	^popUpMenu notNil
		ifTrue: [ popUpMenu ]
		ifFalse: [ menu ]! !

"June 5, 2007 -> 21:16:30"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
beforeQueuedMessage

	"%remove this and calls to it"! !

"June 5, 2007 -> 21:16:35"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
beforeSetFocus

	ignoreNextFocusSet
		ifTrue: [	"We requested the focus, and have already recorded it, so
							ignore this."
						ignoreNextFocusSet := false.	]
		ifFalse: [	self visual layoutValid
							ifTrue: [	"We didn't request this, so windows must be requesting it, so
												record it"
											self findInputFocus	]	].! !

"June 5, 2007 -> 21:16:36"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
beginPaint: hwnd <HWND>  paintStructure: ps <PAINTSTRUCT>  ^<HDC>

	^{{<user HDC BeginPaint> arg: hwnd arg: ps}}! !

"June 5, 2007 -> 21:16:37"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
buildWin32Handle
	"Subclasses must implement to create the appropriate type of window handle &
	  store it in win32Handle"

	self subclassResponsibility! !

"June 5, 2007 -> 21:16:38"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
callAsyncDefWndProcFor: hwnd <HWND>
msgCode: msgCode <ExternalData>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>
	"like callDefWndProcFor:msgCode:wParam:lParam:
			but is asynchronous"

	^{{<user ExternalProxy DefWindowProcA async>
			hwnd: hwnd
			value: msgCode
			value: wParam
			value: lParam
	  }}! !

"June 5, 2007 -> 21:16:39"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
callDefWndProcFor: hwnd <HWND>
msgCode: msgCode <ExternalData>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^{{<user ExternalProxy DefWindowProcA>
			hwnd: hwnd
			value: msgCode
			value: wParam
			value: lParam
	  }}! !

"June 5, 2007 -> 21:16:41"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
computePreferences

	natural := Point origin corner: self visual natural enclosingRect extent.
	min := Point origin corner: self visual min enclosingRect extent.
	max := Point origin corner: self visual max enclosingRect extent.! !

"June 5, 2007 -> 21:16:42"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
controls ^<Extensible[Win32Control]>

	^controls! !

"June 5, 2007 -> 21:16:43"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
defaultRefreshInterval ^<Float>

	^0.25! !

"June 5, 2007 -> 21:16:44"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
defaultWndProc ^<ExternalProxy>

	^self actualClass defaultWndProc! !

"June 5, 2007 -> 21:16:45"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
deferredPaintRegion ^<Rect>

	^deferredPaintRegion! !

"June 5, 2007 -> 21:16:46"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
deferredPaintRegion: r <Rect>

	deferredPaintRegion := r! !

"June 5, 2007 -> 21:16:48"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
desiredXPos ^<ExternalData>

	^desiredPosition isNil
		ifFalse: [ desiredPosition x asInteger ]
		ifTrue: [  Win32 CW_USEDEFAULT ]! !

"June 5, 2007 -> 21:16:49"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
desiredYPos ^<ExternalData>

	^desiredPosition isNil
		ifFalse: [ desiredPosition y asInteger ]
		ifTrue: [  Win32 CW_USEDEFAULT ]! !

"June 5, 2007 -> 21:16:50"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
display

	| subs <Cltn[Win32Control]> |
	self withCanvasDo:
			[ :can <Canvas> |
				| paintBlk <[^Object]> |	
				paintBlk := 
					[	self paintBackgroundOn: can.
						self displayVisualIfCanOn: can.
						can shallowFlush.  ].
				self showTimes
					ifTrue: [  Transcript show: 'paint: '; print: paintBlk time; cr. ]
					ifFalse: [ paintBlk value ].
				can hasSubwindowsToDisplay
					ifTrue: [ subs := can takeSubwindowsToDisplay ].
			].
	subs notNil
		ifTrue: [	subs do:
							[ :sub <Win32Control> |
								"%hack: the handle test should not be 
									necessary; something is screwed up"
								sub hasWin32Handle
									ifTrue: [	sub sendMessage: Win32 WM_PAINT
														wparam: 0 lparam: 0.
												].
							].
					 ]! !

"June 5, 2007 -> 21:16:52"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
displayVisualIfCanOn: canvas <Canvas>

	self session visualCriticalWouldBlock
		ifTrue: [ self recordDeferredPaint: canvas clippingRect ]
		ifFalse: [	self paintOccuring.
						self visual displayOn: canvas.	]! !

"June 5, 2007 -> 21:16:53"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
endPaint: hwnd <HWND>  paintStructure: ps <PAINTSTRUCT>

	^{{<user ExternalProxy EndPaint> arg: hwnd arg: ps}}! !

"June 5, 2007 -> 21:17:13"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
extent: e <Point>
	"Change the window's extent.  This will cause a relayout
		to happen later, which will record the extent."

	| pos <Point> adjusted <Rect> |
	adjusted := self fitToMedium: e.
	pos := self getPosition.
	{{<user ExternalProxy MoveWindow>
		hwnd: self win32Handle
		x: pos x
		y: pos y
		width: adjusted x
		height: adjusted y
		repaint: true asExternalData
	}} asBoolean 
		ifFalse: [ Win32 handleError ].! !

"June 5, 2007 -> 21:17:14"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
findInputFocus

	"find some non-native visual
	  within us to give the input focus to."

	"If there is already a focus, and it is in this window, then we are in a callback caused
	  by our own attempt to set the focus, so do nothing."
	(self session hasInputFocus and: [ self session inputFocus nativeWindow = self ])
		ifTrue: [ ^self ].

	"If we have a valid memory of what our input focus was last time, use it"
	self purgeMostRecentFocusIfNeeded.
	(mostRecentInputFocus notNil and: [ mostRecentInputFocus topWindow = self ])
		ifTrue: [ "Search to see if the most recent one is still a reachable, valid candidate"
					 "%todo: we could optimize this by adding another call to the heirarchy called
						verifyFocusCandidate which sends verifyFocusCandidate:self up the heirarchy,
						giving pacifiers etc. a chance to deny it the focus.  This would be MUCH faster
						than the following loop."
					"Also note that we use session inputFocus: rather than becomeFocus, because this
						 thing was previously the focus, so we don't want to do things like scroll it"
					 self visual focusCandidatesDo:
						[ :cand <Visual> |
							cand = mostRecentInputFocus
								ifTrue: [	self session inputFocus: cand.

												^self		"^^^^^^^^^^^^^"		] ]. ].

	"There is no valid previous focus to reuse, so just choose the first one"
	(self visual firstFocusCandidateIfAbsent: [ ^self ])
		becomeFocus.
! !

"June 5, 2007 -> 21:17:15"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
fitToMedium: clientExtent <Point>  ^<Point>
	"takes a client extent, and returns a window extent adjusted so that it will fit on the screen"

	| normal <Point> withoutCaption <Point> captionHeight <Int> adjClient <Point> |	
	normal := (self windowSizeForClientAreaSize: clientExtent) min: self medium extent.
	withoutCaption := (self windowSizeWithoutCaptionForClientAreaSize: clientExtent) min: self medium extent.
	captionHeight := normal y - withoutCaption y.
	^self windowSizeForClientAreaSize:
			 (clientExtent x min: self medium extent x)
		@ ((clientExtent y + captionHeight min: self medium extent y) - captionHeight).! !

"June 5, 2007 -> 21:17:17"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
getPosition ^<Point>

	{{<user ExternalProxy GetWindowRect>
		hwnd: self win32Handle
		rect: self scratchRECT
	}} asBoolean
		ifFalse: [ Win32 handleError ].
	^self scratchRECT left @ self scratchRECT top! !

"June 5, 2007 -> 21:17:18"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
globalFromLocalPosition: p <WinPOINT> ^<WinPOINT>

	| wp <WinPOINT> result <WinPOINT> |
	wp := WinPOINT new allocate.
	wp x: p x; y: p y.
	{{<user ExternalProxy ClientToScreen>
			handle: self win32Handle
			point: wp
	}} asBoolean
		ifFalse: [ Win32 handleError ].
	result := wp x @ wp y.
	wp free.
	^result! !

"June 5, 2007 -> 21:17:19"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
handleTabEvent: ev <UIEvent>

	ev shiftPressed
		ifTrue: [ self moveFocusBack ]
		ifFalse: [ self moveFocusForward ]! !

"June 5, 2007 -> 21:17:21"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
hasBackgroundPainter ^<Boolean>

	^backgroundPainter notNil! !

"June 5, 2007 -> 21:17:22"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
hasMenu ^<Boolean>
	"Returns the menu that is currently active, if there is one.  It may either be the top level menu,
	  or a popup menu over the window"

	^popUpMenu notNil or: [ menu notNil ]! !

"June 5, 2007 -> 21:17:23"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
haveErased ^<Boolean>

	^haveErased! !

"June 5, 2007 -> 21:17:24"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
haveErased: f <Boolean>

	haveErased := f! !

"June 5, 2007 -> 21:17:26"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
initWindowsMessageHandlers

	WindowsMessageHandlers
		at: Win32 WM_CLOSE	put:
				[ :w <Window> :msg  <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w closeMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_SETCURSOR	put:
				[ :w <Window> :msg  <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w setCursorMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_PAINT	put:
				[ :w <Window> :msg  <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w paintMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_ERASEBKGND	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w eraseBackgroundMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_CTLCOLORBTN	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w buttonColorMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_DRAWITEM	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w drawItemMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_KEYDOWN	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w keyDownMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_KEYUP	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w keyUpMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_CHAR	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w characterMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];

		"mouse events are handled by a common event routine"
		at: Win32 WM_LBUTTONDOWN put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #primaryButtonDown at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_LBUTTONUP	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #primaryButtonUp at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_LBUTTONDBLCLK	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #primaryButtonDoubleClick at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_MBUTTONDOWN	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #middleButtonDown at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_MBUTTONUP	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #middleButtonUp at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_RBUTTONDOWN put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #secondaryButtonDown at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_RBUTTONUP put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #secondaryButtonUp at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_RBUTTONDBLCLK put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #secondaryButtonDoubleClick at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_MOUSEMOVE put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #mouseMove at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];

		at: Win32 WM_MEASUREITEM	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w measureItemMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_SETFOCUS	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w setFocusMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_KILLFOCUS	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w killFocusMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_COMMAND	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w commandMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_GETMINMAXINFO	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w getMinMaxInfoMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_SIZE	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w sizeMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_NCDESTROY	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w ncDestroyMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_DESTROY	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w destroyMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_CAPTURECHANGED	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w captureChangedMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_INITMENUPOPUP	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w initMenuPopupMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_QUERYNEWPALETTE	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w queryPaletteMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_PALETTECHANGED	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w paletteChangedMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];

		"---------- Custom messages"
		at: Window LAYOUT	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w layoutMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];

		yourself! !

"June 5, 2007 -> 21:17:28"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
initialInputFocus ^ <Visual>

	^initialInputFocus! !

"June 5, 2007 -> 21:17:29"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
layout: extent <Point>

	| firstLayout <Boolean> |

	firstLayout := self visual layoutStatus = Visual invalid.
 	self showTimes
		ifTrue: [	Transcript show: 'layout: '; print: [ 
								self visual allocationInParent: (0@0 corner: extent).
						] time; cr. ]
		ifFalse: [	self visual allocationInParent: (0@0 corner: extent). ].

	"We have to do this now because we can't set the input focus until layout is
		complete, since the containing native window must be accessed, etc."
	firstLayout
		ifTrue: [	self palette notNil
							ifTrue: [ self recursiveRealizePaletteForeground: true updateColors: true. ].
						(self initialInputFocus notNil and: [ self initialInputFocus isFocusCandidate ])
							ifTrue: [		self initialInputFocus becomeFocus.
												self initialInputFocus: nil 	"Not needed anymore, prevent memory leak"	]
							ifFalse: [	self findInputFocus ]
					  ]! !

"June 5, 2007 -> 21:17:30"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
localFromGlobalPosition: p <WinPOINT> ^<WinPOINT>

	| wp <WinPOINT> result <WinPOINT> |
	wp := WinPOINT new allocate.
	wp x: p x; y: p y.
	{{<user ExternalProxy ScreenToClient>
			handle: self win32Handle
			point: wp
	}} asBoolean
		ifFalse: [ Win32 handleError ].
	result := wp x @ wp y.
	wp free.
	^result! !

"June 5, 2007 -> 21:17:32"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
menuCommandForItem: id <Int>

	(MenuItem itemFor: id)
		execute! !

"June 5, 2007 -> 21:17:33"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
moveFocusBack

	(self visual lastFocusCandidateBefore: self session inputFocus)
		becomeFocus! !

"June 5, 2007 -> 21:17:34"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
moveFocusForward

	(self visual nextFocusCandidateAfter: self session inputFocus)
		becomeFocus! !

"June 5, 2007 -> 21:17:35"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
nCmdShow ^<ExternalProxy>

	^{{primitiveWindowsNCmdShow}}! !

"June 5, 2007 -> 21:17:36"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
nextPaintTime ^<Float>

	^nextPaintTime! !

"June 5, 2007 -> 21:17:37"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
nextPaintTime: t <Float>

	nextPaintTime := t! !

"June 5, 2007 -> 21:17:39"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
paintBackgroundOn: can <Canvas>

	can withPainter: self backgroundPainter do:
		[ can displayFilledRectangle:
			(Point origin corner: self allocation enclosingRect extent) ].! !

"June 5, 2007 -> 21:17:40"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
paintOccuring

	self nextPaintTime: Time clockValue + self refreshInterval.
	self paintPending: false.
	self session paintOccuredFor: self.! !

"June 5, 2007 -> 21:17:41"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
parentHandle ^<ExternalData>

	^parent isNil
		ifFalse: [ parent win32Handle ]
		ifTrue: [ Win32 NULL ]! !

"June 5, 2007 -> 21:17:42"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
purgeMostRecentFocusIfNeeded

	"%kludge: This should be called occasionally (in user time) to avoid memory leaks caused by
	  a pointer to a zombie visual"
	"%todo: this isn't called yet.  Set up a scanner that sends this to all windows every ten seconds or
	   so."
	(mostRecentInputFocus notNil and: [ mostRecentInputFocus isAttached not ])
		ifTrue: [ mostRecentInputFocus := nil ]! !

"June 5, 2007 -> 21:17:44"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
recordDeferredPaint: region <Rect> 

	self deferredPaintRegion:
		(self deferredPaintRegion isNil
			ifTrue: [ region ]
			ifFalse: [ self deferredPaintRegion merge: region ]
		)! !

"June 5, 2007 -> 21:17:45"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
recordExtent

		self setExtent: self trueClientAreaExtent.! !

"June 5, 2007 -> 21:17:46"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
registerPaintTime

	self paintPending
		ifFalse: [	self paintPending: true.
						self nextPaintTime: Time clockValue + self refreshInterval.
						self session schedulePaintFor: self at: self nextPaintTime.	].! !

"June 5, 2007 -> 21:17:47"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
relayoutIfNeeded

	self relayoutIfNeededForExtent: self extent! !

"June 5, 2007 -> 21:17:48"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
relayoutIfNeededForExtent: e <Point>

	self visual needsRelayout
		ifTrue: [ self layout: (self visual max enclosingRect extent min: e) ].
	self invalidate.! !

"June 5, 2007 -> 21:17:49"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
scratchRECT ^<RECT>

	^scratchRECT! !

"June 5, 2007 -> 21:17:51"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
setCursor ^<ExternalData>

	^cursor isNil
		ifFalse: [	{{<user ExternalProxy SetCursor> handle: cursor win32Handle}}.
						1 ]
		ifTrue: [ 0 ]! !

"June 5, 2007 -> 21:17:52"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
setEnabled: flag <Boolean>

	enabled := flag.
	self hasWin32Handle
		ifTrue: [	{{<user ExternalProxy EnableWindow async>
								handle: self win32Handle
								state: enabled asExternalData}}.	].! !

"June 5, 2007 -> 21:17:53"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
setExtent: e <Point>

	extent := e! !

"June 5, 2007 -> 21:17:55"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
setName: nm <Str>

	self hasWin32Handle
		ifTrue: [	| title <CString> |
						title := CString for: nm.
						[	{{<user ExternalProxy SetWindowTextA>
											hwnd: self win32Handle
											title: title
							}} asBoolean
								ifFalse: [ Win32 handleError ].
						] ensure: [ title free ]
					 ]! !

"June 5, 2007 -> 21:17:56"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
shouldCallDefaultHandlerAsynchronouslyFor: msgCode <ExternalData>  ^<Boolean>

	^msgCode @= Win32 WM_SYSCOMMAND		"so that window moves let other sessions repaint"! !

"June 5, 2007 -> 21:17:57"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
showTimes ^<Boolean>
	"Report preference, layout, and painting times on the transcript"

	^false! !

"June 5, 2007 -> 21:17:58"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
trueClientAreaExtent ^<Point>

	^self trueClientAreaExtentFor: self win32Handle! !

"June 5, 2007 -> 21:17:59"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
trueClientAreaExtentFor: hwnd <ExternalData> ^<Point>

	| extent <Point> rect <RECT> |
	rect := RECT new allocate.
	{{<user RECT GetClientRect> arg: hwnd arg: rect}}.
	extent := (rect right - rect left) @ (rect bottom - rect top).
	rect free.
	^extent! !

"June 5, 2007 -> 21:18:0"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
win32Handle: h <HWND>

	win32Handle := h! !

"June 5, 2007 -> 21:18:2"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
win32Style ^<ExternalData>

	| s <ExternalData> |
	s := 0.
	self enabled
		ifFalse: [ s := s externalBitOr: Win32 WS_DISABLED ].
	^s
! !

"June 5, 2007 -> 21:18:3"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
windowSizeForClientAreaSize: extent <Point>  ^<Point>
	"returns an integral point that is the correct window size for a desired client area size"

	^self windowSizeForClientAreaSize: extent windowStyle: self win32Style! !

"June 5, 2007 -> 21:18:4"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
windowSizeForClientAreaSize: extent <Point> windowStyle: style <ExternalData>  ^<Point>
	"returns an integral point that is the correct window size for a desired client area size"

	| r <RECT> result <Point> |
	r := RECT new allocate.
	r top: 0; left: 0; right: extent x asInteger; bottom: extent y asInteger.
	{{<user ExternalProxy AdjustWindowRect>
				 rect: r style: style hasMenu: self hasMenu asExternalData}} asBoolean
		ifFalse: [ Win32 handleError ].
	result := (r right - r left) @ (r bottom - r top).
	r free.
	^result! !

"June 5, 2007 -> 21:18:5"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
windowSizeWithoutCaptionForClientAreaSize: extent <Point>  ^<Point>
	"returns an integral point that is the correct window size for a desired client area size"

	^self windowSizeForClientAreaSize: extent
			windowStyle: (self win32Style externalBitAnd: (Win32 WS_CAPTION asSmallInteger bitInvert))! !

"June 5, 2007 -> 21:18:7"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
windowsMessageHandlers ^<Dict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>

	"Don't need critical region since duplicate inits are no problem"
	WindowsMessageHandlers isNil
		ifTrue: [	WindowsMessageHandlers :=
							CustomDictionary[ExternalData,[Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData]]
									withCompareBlock: [ :k1 <ExternalData> :k2 <ExternalData> |    k1 @= k2 ]
									hashBlock: [ :k <ExternalData> |  k hash ].
						self initWindowsMessageHandlers.
						].
	^WindowsMessageHandlers! !

"June 5, 2007 -> 21:18:8"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
withBufferedCanvasDo: drawing <[Canvas,^X def]> ^<X>

	^self withDirectCanvasDo:
		[ :directCanvas <Canvas> |
			| invalid <Rect> oldpal <Win32Handle> |
			invalid := directCanvas clippingRect.

			self session
				withBufferCanvasFor: invalid
				do: [ :bufferCanvas <Canvas> :buffer <HBITMAP> |

						self palette isNil
							ifFalse: [ oldpal := bufferCanvas win32Palette: self palette win32Handle ].

						"draw on the buffer canvas"
						drawing value: bufferCanvas.
						bufferCanvas shallowFlush.

						"Now, copy the buffer bits onto the screen"
						directCanvas atOffset: invalid origin
							do: [ bufferCanvas atOffset: invalid origin 
								do: [	directCanvas
											bitBlt: bufferCanvas
											extent: invalid extent
											op: UI ropCopy.		].	].
						 oldpal notNil
								ifTrue: [ 	Palette debugging
													ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
												bufferCanvas win32Palette: oldpal ]. 
						].	
		]! !

"June 5, 2007 -> 21:18:9"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
withCanvasDo: drawing <[Canvas,^X def]> ^<X>

	^(self useDisplayBuffering and: [ Window bufferingPossible ])
		ifFalse: [	self withDirectCanvasDo: drawing ]
		ifTrue: [	self withBufferedCanvasDo: drawing ]! !

"June 5, 2007 -> 21:18:11"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
withDCDo: blk <[HDC]>
	"With the window's device context do the block (not for painting)"

	| hdc <HDC> |
	hdc := {{<user HDC GetDC> hwnd: self win32Handle}}.
	[ blk value: hdc ]
		ensure: [ hdc releaseDCFor: self win32Handle ]! !

"June 5, 2007 -> 21:18:13"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
withDirectCanvasDo: drawing <[Canvas,^X def]> ^<X>

	|	can <Canvas>
		ps <PAINTSTRUCT>
		paintBlk <[^Object]>
		result <X>
		oldpal <Win32Handle> |

	"use a critical region to paint, since background painting might reuse the
	  same device context in the UI thread"
	^self critical:
		[	ps := PAINTSTRUCT new allocateZeroed.
			can := self beginPaint: self win32Handle paintStructure: ps.
			can isNull
				ifTrue: [ Win32 handleError ].
			can	initialize;
				toRelease: [ :dc <HDC> | "End paint will release the context" ];
				initClippingRectBeforeTranslation: ps rcPaint asRectangle;
				window: self.
			self palette isNil
				ifFalse: [ oldpal := can win32Palette: self palette win32Handle ].

			Session debugInvalidation
				ifTrue: [	can withPainter: (Painter new paint: Paint red)
									do: [ can displayFilledRectangle: ps rcPaint asRectangle; flush. ].
								Platform errorStream show: self class name, ' rendering: '; print: ps rcPaint asRectangle; cr.	].

			result := drawing value: can.
			oldpal notNil
				ifTrue: [ 	Palette debugging
									ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
								can win32Palette: oldpal ]. 
			can release. 

			self endPaint: self win32Handle paintStructure: ps.
			ps free.
			result	]! !

"June 5, 2007 -> 21:18:14"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
wndProc ^<APICallback>

	^self session wndProc! !

"June 5, 2007 -> 21:18:15"!

! (Delta mirrorFor: #Window) methodsFor: 'private-testing' !
paintPending ^<Boolean>

	^paintPending! !

"June 5, 2007 -> 21:18:16"!

! (Delta mirrorFor: #Window) methodsFor: 'private-testing' !
paintPending: b <Boolean>

	paintPending := b! !

"June 5, 2007 -> 21:18:17"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
changing

	self session changing: self.
	self session recordPrefsFor: self.
	natural := min := max := nil.! !

"June 5, 2007 -> 21:18:19"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
checkLayout: oldPrefs <SeqCltn[Region]>

	| oldNat <Rect> alloc <Rect> nat <Rect> ext <Point> |
	oldNat := (oldPrefs at: 2) enclosingRect.
	self computePreferences.
	nat := self natural enclosingRect.
	alloc := self allocation enclosingRect.

	"We have to do the relayout eagerly, even before the size message
			comes back, because the caller assumes that layout is then done."

	((alloc contains: self min enclosingRect)
			and: [ self max enclosedRect contains: alloc ]
	)	ifFalse: [	"We definitely have to change our size"
							self relayoutIfNeededForExtent: nat extent.
							self extent: nat extent.
							^self	].

	(self optimizeIncrementalLayout
			or: [ nat = oldNat
			or: [	alloc contains: nat ] ])
		ifTrue: [	self relayoutIfNeededForExtent: self extent.
						^self ].

	ext := (nat width max: alloc width) @ (nat height max: alloc height).
	self relayoutIfNeededForExtent: ext.
	self extent: ext.! !

"June 5, 2007 -> 21:18:20"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
checkPaintTime: t <Float>
	"If we have reached our refresh time, paint"
	
"%todo: figure out how to remove the following %hack
		this should not be sent after the receiver is released)"	
visual isNil ifTrue: [ ^self ].

	(self hasWin32Handle and: [ self paintPending ])
		ifTrue: [ self nextPaintTime <= t
						ifTrue: [ self display ]
						ifFalse: [ self session needPaintAtTime: self nextPaintTime ]	 ]! !

"June 5, 2007 -> 21:18:21"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
oldcheckLayout: oldPrefs <SeqCltn[Region]>

	| oldNat <Rect> alloc <Rect> nat <Rect> |
	oldNat := (oldPrefs at: 2) enclosingRect.
	self computePreferences.
	nat := self natural enclosingRect.
	alloc := self allocation enclosingRect.

	"We have to do the relayout eagerly, even before the size message
			comes back, because the caller assumes that layout is then done."
	self relayoutIfNeeded.

	((alloc contains: self min enclosingRect)
			and: [ (self max enclosedRect contains: alloc)
			and: [ self optimizeIncrementalLayout
							or: [ nat = oldNat
							or: [	alloc contains: nat ] ] ] ]
	)	ifFalse: [	"We definitely have to change our size"
						self setExtent: nat extent.	].
! !

"June 5, 2007 -> 21:18:23"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
prefs ^<SeqCltn[Region]>

	^Array[Region] with: self min with: self natural with: self max! !

"June 5, 2007 -> 21:18:24"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
prefsStatus ^<Int>

	^Visual valid! !

"June 5, 2007 -> 21:18:25"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
prerecordPrefsIfNeeded

	"nothing to do"! !

"June 5, 2007 -> 21:18:26"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
processDeferredPainting

	self deferredPaintRegion notNil
		ifTrue: [	self invalidate: self deferredPaintRegion.
						self deferredPaintRegion: nil.		]! !

"June 5, 2007 -> 21:18:28"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
removeParentsFrom: leaves <Set[RelayoutTarget]>
alreadyChecked: checked <Set[RelayoutTarget]>

	"nothing to do"! !

"June 5, 2007 -> 21:18:29"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
hInstance ^<ExternalProxy>

	^self medium hInstance! !

"June 5, 2007 -> 21:18:30"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
message: msg <MSG>
	"This is invoked in the UI thread when a new message arrives in the queue."

	"Forward messages to the session, which will execute them in its thread"
	self session message: msg! !

"June 5, 2007 -> 21:18:31"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
message: msgCode <ExternalData>
for: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	"This is where all the win32 messages get converted to our semantics.  This
	  method executes in the window's session's thread for queued messages, and
	  either the session or UI thread for unqueued messages."

	"%note/%todo: each message below must call beforeQueuedMessage before processing
	     the message IFF the message is a queued (in session thread) message"

	^(self windowsMessageHandlers at: msgCode
		ifAbsent: [ ^self handleMiscMsg: msgCode hwnd: hwnd wParam: wParam lParam: lParam ]
     )	value: self
		value: msgCode
		value: hwnd
		value: wParam
		value: lParam! !

"June 5, 2007 -> 21:18:32"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
recursiveRealizePaletteForeground: fore <Boolean> updateColors: update <Boolean>

	self palette isNil
		ifFalse: [	self withDCDo:
							[ :hdc <HDC> |
								| oldpal <Win32Handle> |
								oldpal := Palette select: self palette win32Handle into: hdc background: fore not.
								self palette unrealize.
								self palette realizeFor: hdc.
								Palette debugging
									ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
								Palette select: oldpal win32Handle into: hdc background: fore not.
							 ].
						self invalidate.
						].
	self controls do:
		[ :c <Win32Control> |
			c recursiveRealizePaletteForeground: fore updateColors: update ].! !

"June 5, 2007 -> 21:18:34"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
registerControl: c <Win32Control>

	self controls include: c! !

"June 5, 2007 -> 21:18:35"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
releaseCapture

	{{<user ExternalProxy ReleaseCapture> noArgs}}! !

"June 5, 2007 -> 21:18:36"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
sendMessage: msg <ExternalData>
wparam: wp <ExternalData>
lparam: lp <ExternalData>
^<ExternalData>

	^{{<user ExternalProxy SendMessageA>
			handle: self win32Handle
			msg: msg
			wparam: wp
			lparam: lp}}! !

"June 5, 2007 -> 21:18:37"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
setCapture

	{{<user ExternalProxy SetCapture> hwnd: self win32Handle}}.
! !

"June 5, 2007 -> 21:18:38"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
setFocus

	 self win32Handle @= {{<user ExternalProxy GetFocus> call}}
		ifFalse: [  {{<user ExternalProxy SetFocus> hwnd: self win32Handle}} ]! !

"June 5, 2007 -> 21:18:40"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
unregisterControl: c <Win32Control>

	self controls removeEvery: c! !

"June 5, 2007 -> 21:18:41"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
win32Handle ^<HWND>

	win32Handle isNil
		ifTrue: [	self session creatingWindow: self do:
							[	self buildWin32Handle; recordExtent. ].  ].
	^win32Handle! !

"June 5, 2007 -> 21:18:42"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
characterMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self beforeQueuedMessage.
	^self session handleIfFocusMsg: msg for: self wParam: wParam lParam: lParam
! !

"June 5, 2007 -> 21:18:43"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
closeMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self requestClose.
	^0! !

"June 5, 2007 -> 21:18:45"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
commandMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	
	self beforeQueuedMessage.

	^lParam @~= Win32 NULL
		ifTrue: [	"Then this is a control window notification, which should be forwarded back to the
						  smalltalk control object"
						Win32Control notificationMsg: wParam asExternalProxy high for: (Win32Control controlIdFor: lParam).
						0 ]
		ifFalse: [ wParam asExternalProxy high = 0
							ifTrue: [	self menuCommandForItem: wParam low.
											0	]
							ifFalse: [ self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam ]	]! !

"June 5, 2007 -> 21:18:46"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
handleMiscMsg: msgCode <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	"This performs the default window system handling for a message"
	
	^(self shouldCallDefaultHandlerAsynchronouslyFor: msgCode)
		ifTrue: [	"Some messages should be handled asyncronously, so that for
							example, moving a window allows other sessions to refresh"
						self callAsyncDefWndProcFor: hwnd
							msgCode: msgCode
							wParam:  wParam
							lParam: lParam ]
		ifFalse: [	self callDefWndProcFor: hwnd
								msgCode: msgCode
								wParam:  wParam
								lParam: lParam	]! !

"June 5, 2007 -> 21:18:48"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
handleMouseEvent: type <Symbol>
at: loc <Point>
msg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	| ev <UIEvent> |
	self beforeQueuedMessage.

	"%todo: remove the dispatch block for all events; isn't needed anymore"
	ev := UIEvent
			forMsg: self session currentMsg
			dispatch:
				[ :e <UIEvent> :h <UIEventHandler> |
					h mouseEvent: type at: loc event: e ].
	self mouseEvent: type at: loc event: ev.

	"Mouse events are always passed through to the default wnd proc since their may be window system specific things
	  like bringing the window to the foreground that always have to happen. (I used to pass it through only when it
	  was a left button down msg, but this is cleaner)"
	^self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam! !

"June 5, 2007 -> 21:18:49"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
initMenuPopupMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self beforeQueuedMessage.
	self hasMenu 
		ifTrue: [ self activeMenu updateMenuWithHandle: wParam ].
	^0! !

"June 5, 2007 -> 21:18:50"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
keyDownMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self beforeQueuedMessage.
	^self session handleIfFocusMsg: msg for: self wParam: wParam lParam: lParam
! !

"June 5, 2007 -> 21:18:51"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
keyUpMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self beforeQueuedMessage.
	^self session handleIfFocusMsg: msg for: self wParam: wParam lParam: lParam
! !

"June 5, 2007 -> 21:18:52"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
layoutMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	| ext <Point> |
	ext := lParam low @ lParam high.
	(self visual layoutStatus < Visual valid
			or: [ self visual allocation enclosingRect extent ~= ext ])
		ifTrue: [ self layout: ext ].
	^0! !

"June 5, 2007 -> 21:18:53"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
paintMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self display.
	^0! !

"June 5, 2007 -> 21:18:55"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
setCursorMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^(cursor notNil
			and: [	| hitcode <Int> |
						hitcode := lParam asExternalProxy low.
						hitcode = 1 or: [ hitcode = 65534 ] "client area or disabled"  ])
		ifTrue: [ 	self setCursor.
						1 ]
		ifFalse: [ self callDefWndProcFor: hwnd
								msgCode: msg
								wParam: wParam
								lParam: lParam ]
! !

"June 5, 2007 -> 21:18:56"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
buttonColorMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^Win32Control buttonColorMsg: wParam asExternalProxy for: (Win32Control controlIdFor: lParam)! !

"June 5, 2007 -> 21:18:58"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
captureChangedMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self session lostCapture.
	
	^self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam! !

"June 5, 2007 -> 21:18:59"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
destroyMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^0! !

"June 5, 2007 -> 21:19:0"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
drawItemMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^Win32Control drawItemMsg: (DRAWITEMSTRUCT forProxy: lParam) for: wParam asSmallInteger! !

"June 5, 2007 -> 21:19:1"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
eraseBackgroundMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	| can <Canvas> |

	self haveErased
		ifTrue: [ ^1 ].
	self haveErased: true.

	"Don't paint background when a paint is pending to reduce flickering"
	self paintPending
		ifTrue: [ ^0 ].

	"Use a critical region because the window's thread might be drawing"
	self critical:
		[	can := HDC forProxy: wParam asExternalProxy.
			can initialize.
			self paintBackgroundOn: can. 	].
	^1! !

"June 5, 2007 -> 21:19:3"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
getMinMaxInfoMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	| info <MINMAXINFO> adjmin <Point> adjmax <Point> |
	info := MINMAXINFO forProxy: lParam asExternalProxy.
	adjmin := (self fitToMedium: self min extent) max: info ptMinTrackSize asPoint.
	adjmax := (self fitToMedium: self max extent) min: info ptMaxSize asPoint.
	info ptMaxSize x: adjmax x; y: adjmax y.
	info ptMaxTrackSize x: adjmax x; y: adjmax y.
	info ptMinTrackSize x: adjmin x; y: adjmin y.
	^0! !

"June 5, 2007 -> 21:19:4"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
killFocusMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	"This window is losing the input focus, which means that some non-native visual
	  within us probably has the focus, so we have to discard the focus."

	(self session hasInputFocus and: [ self session inputFocus nativeWindow = self ])
		ifTrue: [ self session noInputFocus ].

	^self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam! !

"June 5, 2007 -> 21:19:5"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
measureItemMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	| data <MEASUREITEMSTRUCT> |
	data := MEASUREITEMSTRUCT forProxy: lParam.
	^data CtlType @= Win32 ODT_MENU
		ifFalse: [ Win32Control measureItemMsg: data for: data CtlID asSmallInteger ]
		ifTrue: [ self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam ]! !

"June 5, 2007 -> 21:19:6"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
ncDestroyMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self release.
	^0! !

"June 5, 2007 -> 21:19:8"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
paletteChangedMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	wParam @= self win32Handle
		ifFalse: [ self recursiveRealizePaletteForeground: false updateColors: true.
						self palette isNil
							ifTrue: [ ^self callDefWndProcFor: hwnd
											msgCode: msg
											wParam: wParam
											lParam: lParam	].
					].
	^0! !

"June 5, 2007 -> 21:19:45"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
queryPaletteMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self recursiveRealizePaletteForeground: true updateColors: false.
	self palette isNil
		ifTrue: [ ^self callDefWndProcFor: hwnd
						msgCode: msg
						wParam: wParam
						lParam: lParam	].
	^0! !

"June 5, 2007 -> 21:19:46"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
setFocusMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	"This window is getting the input focus, which means that some non-native visual
	  within us will have to be chosen if possible."

	self beforeSetFocus.

	^self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam! !

"June 5, 2007 -> 21:19:48"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
sizeMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	"%todo: do we need to check the value of wParam first?"
	self critical:
		[ wParam @= Win32 SIZE_MINIMIZED
			ifFalse: [	| m <MSG> |
								self invalidate.
								m := MSG new allocate.
								[ m	hwnd: self win32Handle;
										message: Window LAYOUT;
										wParam: 0;
										lParam: lParam.
									self recordExtent.
									self session message: m.
								] ensure: [ m free ]
							]
		 ].
	^0! !

"June 5, 2007 -> 21:19:49"!

! (Delta mirrorFor: #Window) methodsFor: 'testing' !
isActive ^<Boolean>

	^self session hasActiveWindow and: [ self session activeWindow = self ]! !

"June 5, 2007 -> 21:27:17"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 21:27:19"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 21:27:19"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 21:27:19"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 21:27:19"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 21:27:19"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 21:27:19"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 21:27:19"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 21:27:19"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 21:27:19"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 21:27:19"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 21:27:20"!

(Delta mirrorFor: #SystemInitializer)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"June 5, 2007 -> 21:27:23"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
benchmarkDictionary
	| dict |
	dict := Dictionary new.

	"Benchmarks"
	dict at: #richards			put: [ :runner :repeat :inner | runner new runRichardsBenchmarks: 		repeat ].
	dict at: #smopstones	put: [ :runner :repeat :inner | runner new runSmopstoneBenchmarks:	repeat ].
	dict at: #slopstones		put: [ :runner :repeat :inner | runner new runSlopstoneBenchmarks:		repeat ].
	dict at: #stanford			put: [ :runner :repeat :inner | runner new runStanfordBenchmarks:		repeat ].
	dict at: #deltablue			put: [ :runner :repeat :inner | runner new runDeltaBlue:							repeat ].
	dict at: #benchmarks	put: [ :runner :repeat :inner | 
		runner new runStanfordBenchmarks:			repeat.
		runner new runRichardsBenchmarks:		repeat.
		runner new runDeltaBlue:								repeat.
		runner new runSlopstoneBenchmarks:		repeat.
		runner new runSmopstoneBenchmarks:	repeat.
	].
	
	dict at: #loop			put: [ :runner :repeat :inner | runner new runStanfordLoopBenchmarks: repeat ].
	
	"Individual Stanford Benchmarks"
	dict at: #bubblesort		put: [ :runner :repeat :inner | runner new runIndividualStanford: BubbleSortBenchmark repeat: repeat inner: inner].
	dict at: #bubblesort2	put: [ :runner :repeat :inner | runner new runIndividualStanford: BubbleSort2Benchmark repeat: repeat inner: inner].
	dict at: #intmm				put: [ :runner :repeat :inner | runner new runIndividualStanford: IntMMBenchmark repeat: repeat inner: inner].
	dict at: #intmm2			put: [ :runner :repeat :inner | runner new runIndividualStanford: IntMM2Benchmark repeat: repeat inner: inner].
	dict at: #mm					put: [ :runner :repeat :inner | runner new runIndividualStanford: MMBenchmark repeat: repeat inner: inner].
	dict at: #mm2				put: [ :runner :repeat :inner | runner new runIndividualStanford: MM2Benchmark repeat: repeat inner: inner].
	dict at: #perm				put: [ :runner :repeat :inner | runner new runIndividualStanford: PermBenchmark repeat: repeat inner: inner].
	dict at: #perm2				put: [ :runner :repeat :inner | runner new runIndividualStanford: Perm2Benchmark repeat: repeat inner: inner].
	dict at: #queens			put: [ :runner :repeat :inner | runner new runIndividualStanford: QueensBenchmark repeat: repeat inner: inner].
	dict at: #queens2			put: [ :runner :repeat :inner | runner new runIndividualStanford: Queens2Benchmark repeat: repeat inner: inner].
	dict at: #quicksort		put: [ :runner :repeat :inner | runner new runIndividualStanford: QuicksortBenchmark repeat: repeat inner: inner].
	dict at: #quicksort2		put: [ :runner :repeat :inner | runner new runIndividualStanford: Quicksort2Benchmark repeat: repeat inner: inner].
	dict at: #towers			put: [ :runner :repeat :inner | runner new runIndividualStanford: TowersBenchmark repeat: repeat inner: inner].
	dict at: #towers2			put: [ :runner :repeat :inner | runner new runIndividualStanford: Towers2Benchmark repeat: repeat inner: inner].
	dict at: #treesort			put: [ :runner :repeat :inner | runner new runIndividualStanford: TreeSortBenchmark repeat: repeat inner: inner].
	dict at: #treesort2		put: [ :runner :repeat :inner | runner new runIndividualStanford: TreeSort2Benchmark repeat: repeat inner: inner].
	dict at: #puzzle				put: [ :runner :repeat :inner | runner new runIndividualStanford: PuzzleBenchmark repeat: repeat inner: inner].
	dict at: #sieve				put: [ :runner :repeat :inner | runner new runIndividualStanford: SieveBenchmark repeat: repeat inner: inner].
	dict at: #sumto				put: [ :runner :repeat :inner | runner new runIndividualStanford: SumToBenchmark repeat: repeat inner: inner].
	dict at: #recurse			put: [ :runner :repeat :inner | runner new runIndividualStanford: RecurseBenchmark repeat: repeat inner: inner].
	dict at: #atallput			put: [ :runner :repeat :inner | runner new runIndividualStanford: AtAllPutBenchmark repeat: repeat inner: inner].
	dict at: #incrementall	put: [ :runner :repeat :inner | runner new runIndividualStanford: IncrementAllBenchmark repeat: repeat inner: inner].
	dict at: #nestedloop		put: [ :runner :repeat :inner | runner new runIndividualStanford: NestedLoopBenchmark repeat: repeat inner: inner].
	dict at: #tak					put: [ :runner :repeat :inner | runner new runIndividualStanford: TakBenchmark repeat: repeat inner: inner].
	dict at: #takl					put: [ :runner :repeat :inner | runner new runIndividualStanford: TaklBenchmark repeat: repeat inner: inner].
	dict at: #ordcol				put: [ :runner :repeat :inner | runner new runIndividualStanford: OrderedCollectionBenchmark repeat: repeat inner: inner].
	dict at: #dictionary		put: [ :runner :repeat :inner | runner new runIndividualStanford: DictionaryBenchmark repeat: repeat inner: inner].
	dict at: #dictatput		put: [ :runner :repeat :inner | runner new runIndividualStanford: DictionaryAtPutBenchmark repeat: repeat inner: inner].
	dict at: #livermore		put: [ :runner :repeat :inner | runner new runIndividualStanford: LivermoreBenchmark repeat: repeat inner: inner].

	"Individual Slopstone Benchmarks"
	dict at: #addint				put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 1 repeat: repeat inner: inner].
	dict at: #addfloat			put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 2 repeat: repeat inner: inner].
	dict at: #stringaccess	put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 3 repeat: repeat inner: inner].
	dict at: #createobject	put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 4 repeat: repeat inner: inner].
	dict at: #perform			put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 5 repeat: repeat inner: inner].
	dict at: #evaluate			put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 6 repeat: repeat inner: inner].
	
	"Individual Smopstone Benchmarks"
	dict at: #fractonacci	put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 1 repeat: repeat inner: inner].
	dict at: #primes   		put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 2 repeat: repeat inner: inner].
	dict at: #streams		put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 3 repeat: repeat inner: inner].
	dict at: #strings			put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 4 repeat: repeat inner: inner].
	dict at: #sets				put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 5 repeat: repeat inner: inner].
	dict at: #sorting 			put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 6 repeat: repeat inner: inner].
	dict at: #sorcerer		put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 7 repeat: repeat inner: inner].

	"Test Suites"
	dict at: #testsuite		put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new testBasicClasses] ].

	"Individual Tests"
	dict at: #string				put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: String title: 'String' ] ].
	dict at: #number			put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: Number title: 'Number' ] ].
	dict at: #sortedcol		put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: SortedCollection title: 'SortedCollection' ] ].
	dict at: #readstream	put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: SeqCltnReadStream title: 'SeqCltnReadStream' ] ].
	dict at: #writestream	put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: SeqCltnReadWriteStream title: 'SeqCltnReadWriteStream' ] ].
	dict at: #bag				put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: Bag title: 'Bag' ] ].
	dict at: #keyedset		put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: KeyedSet title: 'KeyedSet' ] ].
	dict at: #set					put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: Set title: 'Set' ] ].
	dict at: #orderedcol	put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: OrderedCollection title: 'OrderedCollection' ] ].
	dict at: #character		put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: Character title: 'Character' ] ].
	dict at: #readwrite		put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: ExternalReadWriteStream title: 'ExternalReadWriteStream' ] ].

	"Errors"
	dict at: #break				put: [ :runner :repeat :inner | {{primitiveBreak}} ].

	"Bootstrap"
	dict at: #boot				put: [ :runner :repeat :inner | Dumper fileOut ].

	"Test Suite for the VM people"
	dict at: #vmtest				put: [ :runner :repeat :inner | VMSuite run ].
	dict at: #vminterpreted	put: [ :runner :repeat :inner | VMSuite runInterpreted ].
	dict at: #vmcompiled	put: [ :runner :repeat :inner | VMSuite runCompiled ].
	dict at: #vmvanilla			put: [ :runner :repeat :inner | VMSuite runVanilla ].
	dict at: #dump					put: [  :runner :repeat :inner | InliningDatabase dump ].
	dict at: #compileAll		put: [  :runner :repeat :inner | InliningDatabase compileAll ].
	dict at: #gc						put: [  :runner :repeat :inner | VM collectGarbage ].
	dict at: #norecomp		put: [  :runner :repeat :inner | VM booleanAt: #UseRecompilation put: false ].

	"Misc."
	dict at: #zone					put: [ :runner :repeat :inner | {{primitivePrintZone}} ].
	dict at: #decode				put: [ :runner :repeat :inner | {{primitiveDecodeAllMethods}} ].
	dict at: #mandelbrot		put: [ :runner :repeat :inner | repeat timesRepeat: [ Mandelbrot new computeImageOnly ] ].
	dict at: #mandelprof		put: [ :runner :repeat :inner | Profiler do: [ Mandelbrot new computeImageOnly ] ].
	dict at: #mandeltest		put: [ :runner :repeat :inner | Mandelbrot new computeImageOnly ].
	dict at: #typecheck		put: [ :runner :repeat :inner | runner new runTypecheckerBenchmarks: repeat ].
	dict at: #genprims			put: [ :runner :repeat :inner | DeltaPrimitiveGenerator doit].

	^dict! !

"June 5, 2007 -> 21:27:24"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
findRunner: test ifAbsent: blk
	test = 'timer'
		ifTrue: [^BenchmarkRunner].
	test = 'nmethod'
		ifTrue: [^BenchmarkNMethodInvocationRunner].
	test = 'method'
		ifTrue: [^BenchmarkMethodInvocationRunner].
	test = 'prims'
		ifTrue: [^BenchmarkPrimitiveRunner].
	test = 'lookup'
		ifTrue: [^BenchmarkLookupCacheRunner].
	test = 'blocks'
		ifTrue: [^BenchmarkBlockRunner].
	blk value.! !

"June 5, 2007 -> 21:27:25"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
lower: str
	| result |
	result := String new: str size.
	1 to: str size do: [ :index |
		result at: index put: (str at: index) asLowercase
	].
	^result! !

"June 5, 2007 -> 21:27:26"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
parseInteger: str ifFail: blk
	| result |
	result := 0.
	str do: [ :c | | val |
		val := c asciiValue.
		(val >= $0 asciiValue and: [ val <= $9 asciiValue ])  ifTrue: [
			result := (result * 10) + ( val - $0 asciiValue)
		] ifFalse: [
			^blk value
		]
	].
	^result! !

"June 5, 2007 -> 21:27:27"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
processCommandLineArguments ^<Boolean>
	"process command line args, and return boolean indicating whether the 
		default program should be run (which is normally the GUI)"

	| args <ReadStream[Str]>  runDefault <Boolean> |
	args := Platform commandLineTokens.
	args next.  "Skip command"
	runDefault := true.
	
	[ args atEnd ] whileFalse: [  | arg <Str> |
		arg := args next.
		
		arg = '-benchmark'
			ifTrue: [	self runBenchmarks: args.
						runDefault := false ].
		arg = '-script'
			ifTrue: [	args atEnd
							ifTrue: [ Transcript show: 'Command line argument error: -script option must be followed by a filename';cr. ]
							ifFalse: [ self runScript: args next ].
						runDefault := false ].		].
	^runDefault
! !

"June 5, 2007 -> 21:27:28"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
runBenchmarks: args <InputStream[Str]>

	| dict runner repeat inner print |
	dict := self benchmarkDictionary.
	runner	:= BenchmarkRunner.
	repeat	:= 1.
	inner	:= 1.
	print		:= false.

	[ args atEnd ] whileFalse: [	| arg <Str> cmd options |
		arg := args next.
		options	:= false.
		arg = 'profile'	ifTrue: [ runner := BenchMarkProfileRunner.		options := true ].
		arg = 'prims'		ifTrue: [ runner := BenchmarkPrimTraceRunner.	options := true ].
		arg = 'inner'		ifTrue: [ inner := repeat. repeat := 1.						options := true ].
		arg = 'print'		ifTrue: [ print := true.												options := true ].
		options ifFalse: [
			repeat := self parseInteger: arg ifFail: [
				Transcript show: 'Processing '; show: arg; show: ' ('; show: repeat printString; show: ' times)'; cr.
				cmd := dict at: arg ifAbsent: [nil].
				cmd isNil ifTrue:  [ Transcript show: 'Command not found'; cr ]
							   ifFalse: [ cmd value: runner value: repeat value: inner ].
				repeat
			]
		]
	].

	print ifTrue: [
		{{primitivePrintMemory}}.
	]! !

"June 5, 2007 -> 21:27:29"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
runDefaultProgram
	"This starts the 'default' program, which is the code that should run when no
	  command line options specifies something else"
	  
	[ UI start ] fork! !

"June 5, 2007 -> 21:27:30"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
runScript: filename <Str>

	[	| file <FilePath> |
		file := FilePath for: filename.
		file exists
			ifFalse: [	Transcript show: 'Error: script file ''', filename, ''' not found.'; cr.
							^self	].
		file charInputStream fileIn
	] fork! !

"June 5, 2007 -> 21:27:31"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'library class initialization' !
run
	"This is the entry point for normal execution."
	
	| commands <OrdCltn[Str]> |

	self runBaseClassInitializers.
	self runNonCriticalClassInitializers.
	(self processCommandLineArguments)
		ifTrue: [ self runDefaultProgram ].
! !

"June 5, 2007 -> 21:27:32"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'library class initialization' !
runBaseClassInitializers
	"Initialize critical base library classes (run in the process scheduler)"

	Platform initialize.
	Transcript := TempTranscript new.
	SmallInteger initialize.
	Character initialize.
	CallBack initialize.
	IdleProcess initialize.
	InliningDatabase initialize.
! !

"June 5, 2007 -> 21:27:33"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'library class initialization' !
runNonCriticalClassInitializers
	"This is the root class initializer that is called when the system starts up.
		Any class initializers that must be called should be called from
		this method."

	Session initialize.

	Rectangle initialize.
	Paint initialize.
	Painter initialize.
	HPEN initialize.
	GeometricHPEN initialize.
	HBRUSH initialize.
	InfiniteRegion initialize.

	Smalltalk initialize.

	CodeEditor initialize.
	Workspace initialize.

	HTMLElement initialize.
	HTMLParser initialize.! !

"June 5, 2007 -> 21:41:46"!

"System saved" !
"June 5, 2007 -> 21:58:16"!

Delta define: #WinPOINT as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:58:16"!

(Delta mirrorFor: #WinPOINT)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.1 $
'!


"June 5, 2007 -> 21:58:18"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
asPoint ^<Point>
	^self x @ self y! !

"June 5, 2007 -> 21:58:18"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
structureSize ^<Int>
	^8! !

"June 5, 2007 -> 21:58:19"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
x ^<SmallInteger>

	^self smallIntegerAt: self xOffset! !

"June 5, 2007 -> 21:58:20"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
x: v <SmallInteger>

	self smallIntegerAt: self xOffset put: v! !

"June 5, 2007 -> 21:58:21"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
y ^<SmallInteger>

	^self smallIntegerAt: self yOffset! !

"June 5, 2007 -> 21:58:22"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
y: v <SmallInteger>

	self smallIntegerAt: self yOffset put: v! !

"June 5, 2007 -> 21:58:23"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'offsets' !
xOffset ^<Int>
	^0! !

"June 5, 2007 -> 21:58:23"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'offsets' !
yOffset ^<Int>
	^4! !

"June 5, 2007 -> 21:58:49"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:58:51"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:58:51"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:58:51"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:58:51"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:58:51"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:58:51"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:58:51"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:58:51"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:58:51"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:58:51"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:58:52"!

(Delta mirrorFor: #MINMAXINFO)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"June 5, 2007 -> 21:58:52"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'accessing' !
ptMaxSize ^<WinPOINT>

	^self subProxyAt: self ptMaxSizeOffset result: WinPOINT new! !

"June 5, 2007 -> 21:58:53"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'accessing' !
ptMaxTrackSize ^<WinPOINT>

	^self subProxyAt: self ptMaxTrackSizeOffset result: WinPOINT new! !

"June 5, 2007 -> 21:58:54"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'accessing' !
ptMinTrackSize ^<WinPOINT>

	^self subProxyAt: self ptMinTrackSizeOffset result: WinPOINT new! !

"June 5, 2007 -> 21:58:55"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'accessing' !
structureSize ^<Int>

	^40! !

"June 5, 2007 -> 21:58:55"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'offsets' !
ptMaxPositionOffset ^<Int>

	^16! !

"June 5, 2007 -> 21:58:56"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'offsets' !
ptMaxSizeOffset ^<Int>

	^8! !

"June 5, 2007 -> 21:58:57"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'offsets' !
ptMaxTrackSizeOffset ^<Int>

	^32! !

"June 5, 2007 -> 21:58:58"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'offsets' !
ptMinTrackSizeOffset ^<Int>

	^24! !

"June 5, 2007 -> 21:58:59"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'offsets' !
ptReservedOffset ^<Int>

	^0! !

"June 5, 2007 -> 21:59:46"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:59:48"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:59:49"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:59:50"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:59:50"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:59:51"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:59:51"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:59:51"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:59:52"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:59:52"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:59:52"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:59:53"!

(Delta mirrorFor: #Win32Control)
comment: 
'A Visual that has a corresponding native Win32 window.

%optional #commandWith: - should override to process any WM_COMMAND messages needed

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.5 $
'!


"June 5, 2007 -> 21:59:55"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'private' !
controlForHandle: hwnd <ExternalProxy> ifAbsent: b <[^X def]> ^<Win32Control | X>

	^self controlFor: (self controlIdFor: hwnd) ifAbsent: b! !

"June 5, 2007 -> 21:59:56"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'private' !
controls ^<VarDict[Int, Win32Control]>

	"Assumption: allers must be in a critical region for self"

	Controls isNil
		ifTrue: [ Controls := Dictionary[Int, Win32Control] new ].
	^Controls! !

"June 5, 2007 -> 21:59:57"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'private' !
dispatchMsgFor: hwnd <ExternalProxy>
msg: msg <SmallInteger>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^(self controlForHandle: hwnd ifAbsent: [ ^0 ])
		message: msg for: hwnd wParam: wParam lParam: lParam! !

"June 5, 2007 -> 21:59:58"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
assignId ^<Int>
	"Assign and return a unique control id number.  It is assumed that we are already in a
		critical region on the Win32Control."

	MaxControlId isNil
				ifTrue: [ MaxControlId := 1 ]
				ifFalse: [ MaxControlId := MaxControlId + 1].
	^MaxControlId! !

"June 5, 2007 -> 21:59:59"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
buttonColorMsg: hdc <ExternalProxy> for: control <Int> ^<ExternalData>

	^(self controlFor: control  ifAbsent: [ ^0 ]) buttonColorMsg: hdc! !

"June 5, 2007 -> 22:0:0"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
controlFor: id <Int> ifAbsent: b <[^X def]> ^<Win32Control | X>

	^Win32Control
		critical: [	self controls at: id ifAbsent: b ]! !

"June 5, 2007 -> 22:0:1"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
controlIdFor: hwnd <HWND> ^<Int>

	^{{<user ExternalProxy GetWindowLongA> hwnd: hwnd value: Win32 GWL_ID}} asSmallInteger.
! !

"June 5, 2007 -> 22:0:2"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
customWndProc ^<APICallback>

	"Don't need a critical region"
	CustomWndProc isNil
		ifTrue: [	CustomWndProc := APICallBack
							register:
								[ :hwnd <ExternalProxy> :msg <SmallInteger> :wParam <ExternalData> :lParam <ExternalData> |
									self dispatchMsgFor: hwnd msg: msg wParam: wParam lParam: lParam ]
							parameters: (OrderedCollection[Class]
								with: ExternalProxy with: SmallInteger with: ExternalProxy with: ExternalProxy).	].
	^CustomWndProc! !

"June 5, 2007 -> 22:0:3"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
drawItemMsg: data <DRAWITEMSTRUCT> for: control <Int> ^<ExternalData>

	^(self controlFor: control ifAbsent: [ ^0 ]) drawItemMsg: data! !

"June 5, 2007 -> 22:0:6"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
measureItemMsg: data <MEASUREITEMSTRUCT> for: control <Int> ^<ExternalData>

	^(self controlFor: control ifAbsent: [ ^0 ]) measureItemMsg: data! !

"June 5, 2007 -> 22:0:9"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
notificationMsg: notifyCode <ExternalData> for: control <Int>

	(self controlFor: control ifAbsent: [ ^0 ]) notificationMsg: notifyCode! !

"June 5, 2007 -> 22:0:10"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
registerControl: id <Int> for: inst <Win32Control>

	Win32Control critical: 
		[ self controls at: id put: inst	]! !

"June 5, 2007 -> 22:0:12"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
unregisterControl: id <Int>

	Win32Control critical: [ self controls removeKey: id ]! !

"June 5, 2007 -> 22:0:14"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'testing' !
debugEvents ^<Boolean>

	^Session debugEvents! !

"June 5, 2007 -> 22:0:15"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'testing' !
debugNotifications ^<Boolean>

	^false! !

"June 5, 2007 -> 22:0:16"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
backgroundPainter ^<Painter>

	backgroundPainter isNil
		ifTrue: [ ^super backgroundPainter ].
	^backgroundPainter! !

"June 5, 2007 -> 22:0:18"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
enabled ^<Boolean>

	^enabled! !

"June 5, 2007 -> 22:0:19"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
enabled: flag <Boolean>

	self enabled = flag
		ifFalse: [	self setEnabled: flag ].! !

"June 5, 2007 -> 22:0:21"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
fullyEnabled ^<Boolean>

	"is true if we are enabled and all parents are enabled"
	^self enabled and: [ super enabled ]! !

"June 5, 2007 -> 22:0:23"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
nativeWindow ^<Window | Win32Control>

	^self! !

"June 5, 2007 -> 22:0:25"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
redraw ^<Boolean>

	^redraw! !

"June 5, 2007 -> 22:0:26"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'control' !
changing

	"flush the cached background painter so that it updates"
	backgroundPainter := nil.
	
	super changing! !

"June 5, 2007 -> 22:0:28"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'control' !
deferringRedrawDo: blk <[^Object]>
	"defer redrawing during evaluation of blk.  If these calls are nested recursively,
	   redrawing is deferred until the outermost returns, at which point the entire control
	   is invalidated.  This can be used to surround a large number of changes to the receiver
	   that would otherwise cause redundant redrawing."

	| oldFlag <Boolean> |
	oldFlag := self redraw.
	self redraw: false.
	blk value.
	self redraw: oldFlag.
	oldFlag
		ifTrue: [ self invalidate ]! !

"June 5, 2007 -> 22:0:30"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'control' !
ignoreNextFocusSet: flag <Boolean>

	ignoreNextFocusSet := flag! !

"June 5, 2007 -> 22:0:31"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'control' !
release

	self hasWin32Handle
		ifTrue: [ self destroyWin32Handle ].
	super release.! !

"June 5, 2007 -> 22:0:34"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'control' !
visible: flag <Boolean>

	| data <ExternalData> |
	self assert: [ self hasWin32Handle ].

	data := flag ifTrue: [ Win32 SW_SHOW ] ifFalse: [ Win32 SW_HIDE ].
	{{<user ExternalProxy ShowWindow> hwnd: self win32Handle flag: data}}.! !

"June 5, 2007 -> 22:0:37"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'debugging' !
printAllocOn: strm <CharOutputStream>

	super printAllocOn: strm.
	self hasWin32Handle
		ifTrue: [	strm show: ' hwnd: '; print: self win32Handle ]
		ifFalse: [ strm show: ' (no hwnd)' ]! !

"June 5, 2007 -> 22:0:39"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'displaying' !
localDisplayOn: can <Canvas>

	can subwindowsToDisplay add: self! !

"June 5, 2007 -> 22:0:41"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'event handling' !
character: c <Character> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	^(self callOrigWndProcFor: ev msg) = 0! !

"June 5, 2007 -> 22:0:43"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'event handling' !
keyDown: key <Symbol> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	^(self callOrigWndProcFor: ev msg) = 0! !

"June 5, 2007 -> 22:0:45"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'event handling' !
keyUp: key <Symbol> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	^(self callOrigWndProcFor: ev msg) = 0! !

"June 5, 2007 -> 22:0:48"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'event handling' !
mouseEvent: type <Symbol> at: loc <Point> event: ev <UIEvent> ^<Boolean>

	| orig <Point> |

	"Translate location back into native window coordinates"
	orig := self allocation enclosingRect origin.
	^(self callOrigWndProcFor: ev msg withLParam: (ExternalProxy forHigh: loc y - orig y low: loc x - orig x)) = 0! !

"June 5, 2007 -> 22:0:50"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'geometry-local' !
allocation: r <Region> at: pos <Point>

	| oldAlloc <Region> alloc <Rect> oldLayoutStatus <Int> |
	oldLayoutStatus := self layoutStatus.
	oldAlloc := allocation.
	alloc := r enclosingRect.
	super allocation: r at: pos.

	oldAlloc isNil
		ifTrue: [ self win32Handle.		"Make sure window is created with the current allocation & position" ]
		ifFalse: [	| oldNativePos <Point> old <Rect> | 
						"We need to use a variable since pos...Window changes nativePos"
						old := oldAlloc enclosingRect.
						oldNativePos := nativePosition.
						self hasWin32Handle
							ifTrue: [	(old width ~= alloc width
													or: [ old height ~= alloc height
													or: [ oldNativePos ~= self nativePosition ]  ] )
												ifTrue: [  self updateWindowDimensions  ]	 ]
							ifFalse: [	self isAttached
												ifTrue: [ self win32Handle ]	] ].
	"Invalidate if we are relaying out as a %hack to solve the problems that a higher level
		relayoutAndInvalidate doesn't invalidate contained native windows like this one"
	oldLayoutStatus = Visual needsRelayout
		ifTrue: [ self invalidate ]! !

"June 5, 2007 -> 22:0:53"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'geometry-nonlocal' !
moveBy: positionDelta <Point>

	"We override this since moving a native visual will generate any needed invalidations
	  automatically."

	self adjustPositionBy: positionDelta! !

"June 5, 2007 -> 22:0:56"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'initialization' !
initialize

	super initialize.
	redraw := true.
	enabled := true.
	isFocus := false.
	self addNonLocalCount: 1.		"Receiver is non-local"
	ignoreNextFocusSet := false.

	self refreshInterval: self defaultRefreshInterval.
	self paintPending: false.
	self useDisplayBuffering: true.
	controls := IdentitySet[Win32Control] new.! !

"June 5, 2007 -> 22:0:59"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
checkPaintTime: t <Float>
	"If we have reached our refresh time, paint"

	(self hasWin32Handle and: [ self paintPending ])
		ifTrue: [ self nextPaintTime <= t
						ifTrue: [ self display ]
						ifFalse: [ self session needPaintAtTime: self nextPaintTime ]	 ]! !

"June 5, 2007 -> 22:1:0"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
controls ^<Extensible[Win32Control]>

	^controls! !

"June 5, 2007 -> 22:1:2"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
cursor ^<Cursor>

	^cursor! !

"June 5, 2007 -> 22:1:4"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
cursor: c <Cursor>

	cursor := c.! !

"June 5, 2007 -> 22:1:6"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
defaultRefreshInterval ^<Float>

	^0.25! !

"June 5, 2007 -> 22:1:8"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
globalFromLocalPosition: p <WinPOINT> ^<WinPOINT>

	| wp <WinPOINT> result <WinPOINT> |
	wp := WinPOINT new allocate.
	wp x: p x; y: p y.
	{{<user ExternalProxy ClientToScreen>
			handle: self win32Handle
			point: wp
	}} asBoolean
		ifFalse: [ Win32 handleError ].
	result := wp x @ wp y.
	wp free.
	^result! !

"June 5, 2007 -> 22:1:11"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
handleMouseEvent: type <Symbol> at: loc <Point> ^<Boolean>

	| ev <UIEvent> |

	"%todo: remove the dispatch block for all events; isn't needed anymore"
	ev := UIEvent
			forMsg: self session currentMsg
			dispatch:
				[ :e <UIEvent> :h <UIEventHandler> |
					h mouseEvent: type at: loc event: e ].
	Sampler notNil
		ifTrue: [ Sampler 
						in: self topWindow visual 
						sampleEvent: type 
						at: (loc translatedBy: self positionInTopWindow)
						event: ev ].
	^self mouseEvent: type at: loc event: ev! !

"June 5, 2007 -> 22:1:13"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
localFromGlobalPosition: p <WinPOINT> ^<WinPOINT>

	| wp <WinPOINT> result <WinPOINT> |
	wp := WinPOINT new allocate.
	wp x: p x; y: p y.
	{{<user ExternalProxy ScreenToClient>
			handle: self win32Handle
			point: wp
	}} asBoolean
		ifFalse: [ Win32 handleError ].
	result := wp x @ wp y.
	wp free.
	^result translatedBy: self allocation enclosingRect origin! !

"June 5, 2007 -> 22:1:15"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
nextPaintTime ^<Float>

	^nextPaintTime! !

"June 5, 2007 -> 22:1:17"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
nextPaintTime: t <Float>

	nextPaintTime := t! !

"June 5, 2007 -> 22:1:19"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
noPalette

	palette := nil! !

"June 5, 2007 -> 22:1:21"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
paintOccuring

	self nextPaintTime: Time clockValue + self refreshInterval.
	self paintPending: false.
	self session paintOccuredFor: self.! !

"June 5, 2007 -> 22:1:22"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
paintPending ^<Boolean>

	^paintPending! !

"June 5, 2007 -> 22:1:23"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
paintPending: b <Boolean>

	paintPending := b! !

"June 5, 2007 -> 22:1:24"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
palette ^<Palette>

	^palette! !

"June 5, 2007 -> 22:1:25"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
palette: p <Palette>

	p == palette
		ifTrue: [ ^self ].
	self assert: [ palette isNil ].
	palette := p! !

"June 5, 2007 -> 22:1:26"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
paletteChangedMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	wParam @= self win32Handle
		ifFalse: [ self recursiveRealizePaletteForeground: false updateColors: true.
						self palette isNil
							ifTrue: [ ^self callDefWndProcFor: hwnd
											msgCode: msg
											wParam: wParam
											lParam: lParam	].
					 ].
	^0! !

"June 5, 2007 -> 22:1:27"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
queryPaletteMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self recursiveRealizePaletteForeground: true updateColors: false.
	self palette isNil
		ifTrue: [ ^self callDefWndProcFor: hwnd
						msgCode: msg
						wParam: wParam
						lParam: lParam	].
	^0! !

"June 5, 2007 -> 22:1:28"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
recursiveRealizePaletteForeground: fore <Boolean> updateColors: update <Boolean>

	self palette isNil
		ifFalse: [	self withDCDo:
							[ :hdc <HDC> |
								| oldpal <Win32Handle> |
								oldpal := Palette select: self palette win32Handle into: hdc background: fore not.
								self palette unrealize.
								self palette realizeFor: hdc.
								Palette debugging
									ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
								Palette select: oldpal win32Handle into: hdc background: fore not.
							 ].
						self invalidate.
						].
	self controls do:
		[ :c <Win32Control> |
			c recursiveRealizePaletteForeground: fore updateColors: update ].! !

"June 5, 2007 -> 22:1:29"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
refreshInterval ^<Float>

	^refreshInterval! !

"June 5, 2007 -> 22:1:30"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
refreshInterval: d <Float>
	"Wait no longer than this amount of time (in seconds) between
		paint operations, if possible"

	refreshInterval := d! !

"June 5, 2007 -> 22:1:31"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
registerControl: c <Win32Control>

	self controls include: c! !

"June 5, 2007 -> 22:1:32"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
registerPaintTime

	self paintPending
		ifFalse: [	self paintPending: true.
						self nextPaintTime: Time clockValue + self refreshInterval.
						self session schedulePaintFor: self at: self nextPaintTime.	].! !

"June 5, 2007 -> 22:1:33"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
setCursor ^<ExternalData>

	^cursor isNil
		ifFalse: [	{{<user ExternalProxy SetCursor> handle: cursor win32Handle}}.
						1 ]
		ifTrue: [ 0 ]! !

"June 5, 2007 -> 22:1:35"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
setCursorMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^(cursor notNil
			and: [	| hitcode <Int> |
						hitcode := lParam asExternalProxy low.
						hitcode = 1 or: [ hitcode = 65534 ] "client area or disabled"  ])
		ifTrue: [ 	self setCursor.
						1 ]
		ifFalse: [ self callOrigWndProc: msg wParam: wParam lParam: lParam ]
! !

"June 5, 2007 -> 22:1:36"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
showTimes ^<Boolean>
	"Report preference, layout, and painting times on the transcript"

	^false! !

"June 5, 2007 -> 22:1:37"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
unregisterControl: c <Win32Control>

	self controls removeEvery: c! !

"June 5, 2007 -> 22:1:38"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
useDisplayBuffering ^<Boolean>

	^useDisplayBuffering! !

"June 5, 2007 -> 22:1:39"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
useDisplayBuffering: f <Boolean>

	useDisplayBuffering := f! !

"June 5, 2007 -> 22:1:40"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
withBufferedCanvasDo: drawing <[Canvas,^X def]> ^<X>

	^self withDirectCanvasDo:
		[ :directCanvas <Canvas> |
			| invalid <Rect> oldpal <Win32Handle> |
			invalid := directCanvas clippingRect.

			self session
				withBufferCanvasFor: invalid
				do: [ :bufferCanvas <Canvas> :buffer <HBITMAP> |
							self palette isNil
								ifFalse: [ oldpal := bufferCanvas win32Palette: self palette win32Handle ].

							"draw on the buffer canvas"
							drawing value: bufferCanvas.
							bufferCanvas shallowFlush.

							"Now, copy the buffer bits onto the screen"
							directCanvas atOffset: invalid origin
								do: [ bufferCanvas atOffset: invalid origin 
									do: [	directCanvas
													bitBlt: bufferCanvas
												extent: invalid extent
												op: UI ropCopy.		].	].
							oldpal notNil
								ifTrue: [ 	Palette debugging
													ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
												bufferCanvas win32Palette: oldpal ]. 
						].	
		]! !

"June 5, 2007 -> 22:1:41"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
withCanvasDo: drawing <[Canvas,^X def]> ^<X>

	^(self useDisplayBuffering and: [ Window bufferingPossible ])
		ifFalse: [	self withDirectCanvasDo: drawing ]
		ifTrue: [	self withBufferedCanvasDo: drawing ]! !

"June 5, 2007 -> 22:1:42"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
withDCDo: blk <[HDC]>
	"With the window's device context do the block (not for painting)"

	| hdc <HDC> |
	hdc := {{<user HDC GetDC> hwnd: self win32Handle}}.
	[ blk value: hdc ]
		ensure: [ hdc releaseDCFor: self win32Handle ]! !

"June 5, 2007 -> 22:1:44"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
withDirectCanvasDo: drawing <[Canvas,^X def]> ^<X>

	|	can <Canvas>
		ps <PAINTSTRUCT>
		paintBlk <[^Object]>
		result <X>
		oldpal <Win32Handle>  |

	"use a critical region to paint, since background painting might reuse the
	  same device context in the UI thread"
	^self critical:
		[	ps := PAINTSTRUCT new allocateZeroed.
			can := self beginPaint: self win32Handle paintStructure: ps.
			can isNull
				ifTrue: [ Win32 handleError ].
			can	initialize;
				toRelease: [ :dc <HDC> | "End paint will release the context" ];
				initClippingRectBeforeTranslation: ps rcPaint asRectangle;
				window: self.
			self palette isNil
				ifFalse: [ oldpal := can win32Palette: self palette win32Handle ].

			Session debugInvalidation
				ifTrue: [	can withPainter: (Painter new paint: Paint red)
									do: [ can displayFilledRectangle: ps rcPaint asRectangle; flush. ].
								Platform errorStream show: self class name, ' rendering: '; print: ps rcPaint asRectangle; cr.	].

			result := drawing value: can.
			oldpal notNil
				ifTrue: [ 	Palette debugging
									ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
								can win32Palette: oldpal ]. 
			can release. 

			self endPaint: self win32Handle paintStructure: ps.
			ps free.
			result	]! !

"June 5, 2007 -> 22:1:45"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Windows with mods' !
display

	"win32 controls do no Smalltalk level painting by default"! !

"June 5, 2007 -> 22:1:46"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'notification' !
detaching

	super detaching.
	self cleanUp! !

"June 5, 2007 -> 22:1:47"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'notification' !
isFocus: f <Boolean>

	isFocus := f.
	super isFocus: f.
! !

"June 5, 2007 -> 22:1:48"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'notification' !
nativePositionChanged

	"DON'T pass this message to super, since our children are native relative to us!!"

	(self checkForNativePositionChanging or: [ self isAttached ])
		ifTrue: [ self updateWindowDimensions ]! !

"June 5, 2007 -> 22:1:49"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
buildWin32Handle

	self subclassResponsibility! !

"June 5, 2007 -> 22:1:50"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
callOrigWndProc: msgCode <ExternalData> wParam: wParam <ExternalData> lParam: lParam <ExternalData>^<ExternalData>
	"Like callOrigWndProcFor:, but takes all args rather than using a MSG structure"

	"Note that we use the receiver's win32Handle below rather than the one in the message so
	 	 this works even when the event was generated during a grab"
	^{{<user ExternalProxy CallWindowProcA> 
		proc: self originalWndProc
		hwnd: self win32Handle
		msg: msgCode
		wparam: wParam
		lparam: lParam }}! !

"June 5, 2007 -> 22:1:51"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
callOrigWndProcFor: m <MSG> ^<ExternalData>

	"Note that we use the receiver's win32Handle below rather than the one in the message so
	 	 this works even when the event was generated during a grab"
	^{{<user ExternalProxy CallWindowProcA> 
		proc: self originalWndProc
		hwnd: self win32Handle
		msg: m message
		wparam: m wParam
		lparam: m lParam }}! !

"June 5, 2007 -> 22:1:52"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
callOrigWndProcFor: m <MSG> withLParam: lParam <ExternalData>^<ExternalData>
	"Like callOrigWndProcFor:, but overrides the lParam value from the msg"

	"Note that we use the receiver's win32Handle below rather than the one in the message so
	 	 this works even when the event was generated during a grab"
	^{{<user ExternalProxy CallWindowProcA> 
		proc: self originalWndProc
		hwnd: self win32Handle
		msg: m message
		wparam: m wParam
		lparam: lParam }}! !

"June 5, 2007 -> 22:1:53"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
canBeFocusCandidate ^<Boolean>
	"%optional: Subclasses that cannot be the input focus even when they are enabled should override this
	  to return false"

	^true! !

"June 5, 2007 -> 22:1:54"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
checkForNativePositionChanging ^<Boolean>
	"returns true if the native position has been changed"

	
	^self hasWin32Handle
			and: [	| oldpos <Point> |
						oldpos := nativePosition.
						oldpos ~= self nativePosition	]! !

"June 5, 2007 -> 22:1:55"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
cleanUp

	self isFocus
		ifTrue: [	self nativeWindow ignoreNextFocusSet: true.
						self session noInputFocus. ].
	self destroyWin32Handle.
! !

"June 5, 2007 -> 22:1:56"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
controlId ^<Int>

	^controlId! !

"June 5, 2007 -> 22:1:57"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
createNativeWindow

	"we need a critical region to protect the class variable:"
	Win32Control
		critical: [	controlId := self actualClass assignId.
							self actualClass registerControl: self controlId for: self.
							self paintPending: false.
							self buildWin32Handle.
							self palette notNil
								ifTrue: [ self recursiveRealizePaletteForeground: true updateColors: true. ].
							self nativeWindow registerControl: self.
	
							self originalWndProc: (self wndProc).
							self wndProc: self customWndProc.
							self isFocus
								ifTrue: [ self setFocus ].
						].! !

"June 5, 2007 -> 22:1:58"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
createVisible ^<Boolean>

	^true! !

"June 5, 2007 -> 22:1:59"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
customWndProc ^<APICallback>

	^self actualClass customWndProc! !

"June 5, 2007 -> 22:2:0"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
debugTest: msgCode <ExternalData> for: hwnd <ExternalData>

	Win32Control debugEvents
			ifTrue: [	Platform errorStream
									show: 'control winproc event: ';
									show: (MSG descriptionOf: msgCode asExternalProxy);
									show: ' window: ';
									print: hwnd;
									cr. 	].! !

"June 5, 2007 -> 22:2:2"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
destroyWin32Handle

	win32Handle notNil
		ifTrue: [	| hand <ExternalProxy> |
						self actualClass unregisterControl: self controlId.
						self nativeWindow unregisterControl: self.
						hand := self win32Handle.
						win32Handle := nil.		"We nil the handle before destroying so that we can tell
																we are dead if there is a focus shift caused by destroy"
						{{<user ExternalProxy DestroyWindow>
							handle: hand }}.		]! !

"June 5, 2007 -> 22:2:3"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
displayUpwardPopUpMenuAt: loc <Point> ^<Boolean>
	"Look up the parent chain for a popUp menu and display it, if there is one.
		Return true if one was found"

	| m <Menu> t <Timer> |
	m := self parent popUpMenuIfAbsent: [ ^false ].
	self	displayPopUpMenu: m
			at: loc
			forButton: #secondary.
	t := self session atIntervals: 1.0 do:
			[	m release.
				t release. ].
	^true! !

"June 5, 2007 -> 22:2:4"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
extendedWin32Style ^<ExternalData>

	^Win32 WS_EX_NOPARENTNOTIFY! !

"June 5, 2007 -> 22:2:5"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
handleMouseEvent: type <Symbol>
message: msgCode <ExternalData>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>

	| loc <Point> |
	"Translate to be relative to our origin"
	loc := (lParam low @ lParam high) + self allocation enclosingRect origin.
	self handleMouseEvent: type at: loc! !

"June 5, 2007 -> 22:2:6"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
hasWin32Handle ^<Boolean>

	^win32Handle notNil! !

"June 5, 2007 -> 22:2:7"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
invalidate: r <Region>

	self registerPaintTime.
	(self layoutStatus = Visual valid and: [ self hasWin32Handle ])
		ifTrue: [	| rect <Rect> nativerect <RECT> |

						nativerect := RECT new allocate.
						rect := r enclosingRect relativeTo: self allocation origin.
						nativerect
							left: rect left asInteger;
							right: rect right asInteger;
							top: rect top asInteger;
							bottom: rect bottom asInteger.
						{{<user ExternalProxy InvalidateRect>
							hwnd: self win32Handle
							RECT: nativerect
							erase: true}}.
						nativerect free.	]! !

"June 5, 2007 -> 22:2:8"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
nativePosition ^<Point>

	"We have to adjust for the fact that our allocation origin might not be 0@0"
	^nativePosition := self positionInContainingNativeWindow + self allocation enclosingRect origin! !

"June 5, 2007 -> 22:2:9"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
originalWndProc ^<HWND>

	^originalWndProc! !

"June 5, 2007 -> 22:2:10"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
originalWndProc: h <HWND>

	originalWndProc := h! !

"June 5, 2007 -> 22:2:11"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
redraw: flag <Boolean>
	"Tell the widget to start or stop redrawing (temporarily) when necessary.  This is usually used
		with a true arg before a large number of changes, followed by a send with a false arg."

	flag = self redraw
		ifFalse: [	redraw := flag.
						self hasWin32Handle
							ifTrue: [	self	sendMessage: Win32 WM_SETREDRAW
													wparam: flag asExternalData
													lparam: 0	]].! !

"June 5, 2007 -> 22:2:12"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
setEnabled: flag <Boolean>

	enabled := flag.
	win32Handle notNil
		ifTrue: [	{{<user ExternalProxy EnableWindow>
								handle: self win32Handle
								state: self fullyEnabled asExternalData}}.	].
! !

"June 5, 2007 -> 22:2:14"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
setWindowText: t <Str>

	| label <CString> |
	label := CString for: t.
	{{<user ExternalProxy SetWindowText>
		handle: self win32Handle
		str: label}}.
	label free.! !

"June 5, 2007 -> 22:2:15"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
updateWindowDimensions
	"set the control's native size and position"

	| pos <Point> |

	pos := self nativePosition.
	self paintPending: false.
	{{<user ExternalProxy MoveWindow>
		handle: self win32Handle
		x: pos x asInteger
		y: pos y asInteger
		width: self allocation enclosedRect width asInteger
		height: self allocation enclosedRect height asInteger
		repaint: true asExternalData
	 }} asBoolean
			ifFalse: [ Win32 handleError ]! !

"June 5, 2007 -> 22:2:16"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
win32Style ^<ExternalData>

	| s <ExternalData> |
	s := Win32 WS_CHILDWINDOW.
	self createVisible
		ifTrue: [ s := s externalBitOr: Win32 WS_VISIBLE. ].
	self fullyEnabled
		ifFalse: [ s := s externalBitOr: Win32 WS_DISABLED ].
	^s! !

"June 5, 2007 -> 22:2:17"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
wndProc ^<ExternalProxy>

	^Window wndProcOf: self win32Handle! !

"June 5, 2007 -> 22:2:18"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
wndProc: wp <ExternalProxy>

	Window wndProcOf: self win32Handle put: wp! !

"June 5, 2007 -> 22:2:19"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private-message handling' !
beforeKillFocus

	(self session hasInputFocus and: [ self session inputFocus nativeWindow = self ])
		ifTrue: [ self session noInputFocus ].! !

"June 5, 2007 -> 22:2:20"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private-message handling' !
beforeSetFocus

	ignoreNextFocusSet
		ifTrue: [	"We requested the focus, and have already recorded it, so
							ignore this."
						ignoreNextFocusSet := false.	]
		ifFalse: [	"We didn't request this, so windows must be requesting it, so
							record it"
						"We don't use becomeFocus here because that would cause another
							windows setFocus message"
						self session inputFocus: self.		]! !

"June 5, 2007 -> 22:2:21"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private-message handling' !
contextMenuMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<Boolean>

	^self displayUpwardPopUpMenuAt:
			(self localFromGlobalPosition: lParam low @ lParam high)! !

"June 5, 2007 -> 22:2:22"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private-testing' !
isFocusCandidate ^<Boolean>

	^self canBeFocusCandidate
		and: [ self hasWin32Handle
		and: [ self enabled ] ]! !

"June 5, 2007 -> 22:2:23"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private-testing' !
isRectangularAndOpaque ^<Boolean>

	^true! !

"June 5, 2007 -> 22:2:24"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-to session' !
blinkFocus: shown <Boolean>
	
! !

"June 5, 2007 -> 22:2:25"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
buttonColorMsg: hdc <ExternalProxy> ^<ExternalData>

	"Should only get sent to buttons, which override this"
	self shouldNotHappen! !

"June 5, 2007 -> 22:2:26"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
commandWith: notifyCode <ExternalData> ^<ExternalData>

	"Subclasses should override to process command msgs"! !

"June 5, 2007 -> 22:2:27"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
drawItemMsg: data <DRAWITEMSTRUCT> ^<ExternalData>

	self shouldNotHappen! !

"June 5, 2007 -> 22:2:28"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
hInstance ^<ExternalProxy>

	^self parent nativeWindow hInstance! !

"June 5, 2007 -> 22:2:29"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
measureItemMsg: data <MEASUREITEMSTRUCT> ^<ExternalData>

	self shouldNotHappen! !

"June 5, 2007 -> 22:2:31"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
message: msgCode <ExternalData>
for: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self debugTest: msgCode for: hwnd.

	(self session handleIfFocusMsg: msgCode for: self wParam: wParam lParam: lParam) = 0
		ifTrue: [ ^0 ].

	msgCode @= Win32 WM_LBUTTONDOWN 
		ifTrue: [	self handleMouseEvent: #primaryButtonDown
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_LBUTTONUP 
		ifTrue: [	self handleMouseEvent: #primaryButtonUp
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_LBUTTONDBLCLK
		ifTrue: [	self handleMouseEvent: #primaryButtonDoubleClick
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_RBUTTONDOWN 
		ifTrue: [	self handleMouseEvent: #secondaryButtonDown
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_RBUTTONUP 
		ifTrue: [	self handleMouseEvent: #secondaryButtonUp
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_RBUTTONDBLCLK
		ifTrue: [	self handleMouseEvent: #secondaryButtonDoubleClick
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_MOUSEMOVE 
		ifTrue: [	self handleMouseEvent: #mouseMove
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].

	msgCode @= Win32 WM_CTLCOLORBTN
		ifTrue: [ ^Win32Control buttonColorMsg: wParam asExternalProxy for: (Win32Control controlIdFor: lParam) ].

	msgCode @= Win32 WM_DRAWITEM
		ifTrue: [	^Win32Control drawItemMsg: (DRAWITEMSTRUCT forProxy: lParam) for: wParam asSmallInteger ].

	msgCode @= Win32 WM_MEASUREITEM
		ifTrue: [	| data <MEASUREITEMSTRUCT> |
						data := MEASUREITEMSTRUCT forProxy: lParam.
						data CtlType @= Win32 ODT_MENU
							ifFalse: [ ^Win32Control measureItemMsg: data for: data CtlID asSmallInteger ] ].

	(msgCode @= Win32 WM_COMMAND and: [ lParam @~= Win32 NULL ])
		ifTrue: [	"Then this is a control window notification, which should be forwarded back to the
						  smalltalk control object"
						Win32Control notificationMsg: wParam asExternalProxy high for: (Win32Control controlIdFor: lParam).
						^0 ].

	msgCode @= Win32 WM_SETFOCUS
		ifTrue: [ self beforeSetFocus ].
	msgCode @= Win32 WM_KILLFOCUS
		ifTrue: [ self beforeKillFocus ].

	msgCode @= Win32 WM_CONTEXTMENU
		ifTrue: [ (self contextMenuMsg: msgCode hwnd: hwnd wParam: wParam lParam: lParam)
						ifTrue: [ ^0 ]. ].

	msgCode @= Win32 WM_QUERYNEWPALETTE 
		ifTrue: [	self queryPaletteMsg: msgCode hwnd: hwnd
								wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_PALETTECHANGED 
		ifTrue: [	self paletteChangedMsg: msgCode hwnd: hwnd
								wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_SETCURSOR 
		ifTrue: [	^self setCursorMsg: msgCode hwnd: hwnd
								wParam: wParam lParam: lParam	 ].

	^{{<user ExternalProxy CallWindowProcA> 
		proc: self originalWndProc
		hwnd: hwnd
		msg: msgCode
		wparam: wParam
		lparam: lParam }}! !

"June 5, 2007 -> 22:2:32"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
notificationMsg: notifyCode <ExternalData>

	"Subclasses can extend to process notification msgs"

	Win32Control debugNotifications
			ifTrue: [ Platform errorStream
							show: 'control notification: ';
							print: notifyCode;
							show: ' window: ';
							print: self win32Handle;
							cr ].

	notifyCode @= Win32 BN_KILLFOCUS
		ifTrue: [ "%todo" ].
	notifyCode @= Win32 BN_SETFOCUS
		ifTrue: [ "%todo" ].
! !

"June 5, 2007 -> 22:2:33"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
sendMessage: msg <ExternalData>
wparam: wp <ExternalData>
lparam: lp <ExternalData>
^<ExternalProxy>

	^{{<user ExternalProxy SendMessageA>
			handle: self win32Handle
			msg: msg
			wparam: wp
			lparam: lp}}! !

"June 5, 2007 -> 22:2:34"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
setFocus

	ignoreNextFocusSet := true.
	 self win32Handle @= {{<user ExternalProxy GetFocus> call}}
		ifFalse: [  {{<user ExternalProxy SetFocus> hwnd: self win32Handle}} ]! !

"June 5, 2007 -> 22:2:35"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
win32Handle ^<HWND>

	win32Handle isNil	
		ifTrue: [ self createNativeWindow ].
	^win32Handle! !

"June 5, 2007 -> 22:2:37"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'testing' !
isFocus ^<Boolean>

	^isFocus! !

"June 5, 2007 -> 22:2:51"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 22:2:53"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 22:2:54"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 22:2:55"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 22:2:55"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 22:2:56"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 22:2:57"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 22:2:57"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 22:2:58"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 22:2:58"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 22:2:59"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 22:3:0"!

(Delta mirrorFor: #Window)
comment: 
'Native windows, with a fairly machine independent interface
(except for methods with ''win32'' in their names).

Tags: %User %UI

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.
'!


"June 5, 2007 -> 22:3:2"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'custom messages' !
LAYOUT ^<ExternalData>
	"This is by the UI thread to tell a window's session process to layout a window.  This has
	  to be done through the message queue so that the layout code runs in the window's session
	  process.  lParam low is width, and lParam high is height."

	^16r400! !

"June 5, 2007 -> 22:3:3"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'debugging' !
bufferingPossible ^<Boolean>

	BufferingPossible isNil
		ifTrue: [ BufferingPossible := true ].
	^BufferingPossible! !

"June 5, 2007 -> 22:3:4"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'debugging' !
bufferingPossible: f <Boolean>
	"If this is set to false, all double buffering will be disabled, usually for debugging
		purposes."

	BufferingPossible := f! !

"June 5, 2007 -> 22:3:5"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
defaultWin32Cursor ^<ExternalProxy>

	^{{<user ExternalProxy LoadCursorA> arg: 0 arg: Win32 IDC_ARROW}}! !

"June 5, 2007 -> 22:3:6"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
defaultWin32Icon ^<ExternalProxy>

	^{{<user ExternalProxy LoadIconA> arg: 0 arg: Win32 IDI_APPLICATION}}! !

"June 5, 2007 -> 22:3:7"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
defaultWndProc ^<ExternalProxy>

	"Don't need a critical region because duplicate inits are no problem"
	DefaultWndProc isNil
		ifTrue: [	DefaultWndProc := Platform DLLLookup: 'DefWindowProcA' in: 'user' ].
	^DefaultWndProc! !

"June 5, 2007 -> 22:3:8"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
parentOf: w <HWND> ^<HWND>

	^{{<user ExternalProxy GetParent> wnd: w}}! !

"June 5, 2007 -> 22:3:9"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
wndProcOf: w <HWND> ^<HWND>

	^{{<user ExternalProxy GetWindowLongA> wnd: w attr: Win32 GWL_WNDPROC}}! !

"June 5, 2007 -> 22:3:10"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
wndProcOf: w <HWND> put: newWinProc <HWND> ^<HWND>

	^{{<user ExternalProxy SetWindowLongA> wnd: w attr: Win32 GWL_WNDPROC value: newWinProc}}! !

"June 5, 2007 -> 22:3:11"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
addNonLocalCount: delta <Int>
	
	! !

"June 5, 2007 -> 22:3:12"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
containerBackgroundPainter ^<Painter>

	^Painter defaultBackground! !

"June 5, 2007 -> 22:3:13"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
containsFocus: flag <Boolean>

	flag
		ifTrue: [	self session activeWindow: self.
						self mostRecentInputFocus: session inputFocus.	].
	"We don't need to remove the active window ifFalse because the session does that"! !

"June 5, 2007 -> 22:3:14"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
displayNowIfInvalid
	"Redraw any invalid areas before proceeded"

	self display! !

"June 5, 2007 -> 22:3:16"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
displayPopUpMenu: menu <Menu> at: loc <Point> forButton: button <Symbol>

	| gloc <Point> flags <ExternalData> |
	popUpMenu := menu.

	flags := Win32 TPM_LEFTALIGN.
	button = #left
		ifTrue: [ flags := flags externalBitOr: Win32 TPM_LEFTBUTTON ]
		ifFalse: [ flags := flags externalBitOr: Win32 TPM_RIGHTBUTTON ].

	gloc := self globalFromLocalPosition: loc.
	{{<user ExternalProxy TrackPopupMenu>
		handle: menu win32Handle
		flags: flags
		x: gloc x
		y: gloc y
		reserved: 0
		window: self win32Handle
		rect: Win32 NULL
	}} asBoolean
		ifFalse: [ Win32 getLastError @= Win32 ERROR_POPUP_ALREADY_ACTIVE
							ifFalse: [ Win32 handleError ].
						].

	popUpMenu := nil.
! !

"June 5, 2007 -> 22:3:17"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
invalidate: r <Region> forChild: child <Visual>

	self invalidate: (r enclosingRect translatedBy: child position)! !

"June 5, 2007 -> 22:3:18"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
isAttached ^<Boolean>

	^true! !

"June 5, 2007 -> 22:3:19"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
nativeWindow ^<Window | Win32Control>

	^self! !

"June 5, 2007 -> 22:3:20"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
parentVisualOfChild ^<Visual>

	self shouldNotHappen! !

"June 5, 2007 -> 22:3:22"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
popUpMenuIfAbsent: f <[^X def]> ^<Menu | X>

	^f value! !

"June 5, 2007 -> 22:3:23"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
positionInContainingNativeWindowOf: child <Visual> ^<Point>

	^child position! !

"June 5, 2007 -> 22:3:24"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
positionInTopWindowOf: child <Visual>

	^child position! !

"June 5, 2007 -> 22:3:25"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
scrollIfNeededToMakeVisible: area <Rect>
relativeTo: v <Visual>
minimizeMotion: minimizeMotion <Boolean>


	! !

"June 5, 2007 -> 22:3:26"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
scrollMeOrAParentBy: distance <Int> vertical: vertical <Boolean>

	"do nothing"! !

"June 5, 2007 -> 22:3:28"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
topWindow ^<Window>

	^self! !

"June 5, 2007 -> 22:3:29"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
translate: p <Point> fromChild: child <Visual> ^<Point>

	"Translate p from the child's coordinates to ours"
	^p translatedBy: child position! !

"June 5, 2007 -> 22:3:30"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
translate: p <Point> toChild: child <Visual> ^<Point>

	"Translate p from our coordinates to the child's"
	^p relativeTo: child position! !

"June 5, 2007 -> 22:3:31"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
translateRect: r <Rect> fromChild: child <Visual> ^<Rect>

	"Translate p from the child's coordinates to ours"
	^r translatedBy: child position! !

"June 5, 2007 -> 22:3:32"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
translateRect: r <Rect> toChild: child <Visual> ^<Rect>

	"Translate p from the child's coordinates to ours"
	^r relativeTo: child position! !

"June 5, 2007 -> 22:3:34"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
allocation ^<Region>

	^Point origin corner: self extent! !

"June 5, 2007 -> 22:3:35"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
backgroundPainter ^<Painter>
	"The paint for the window background.  This can be automatically derived from the
	 background painter for the visual.  It can also be set explicitly."

	^self hasBackgroundPainter
		ifTrue: [ backgroundPainter ]
		ifFalse: [ backgroundPainter := self visual backgroundPainter ]! !

"June 5, 2007 -> 22:3:36"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
backgroundPainter: p <Painter>

	backgroundPainter := p! !

"June 5, 2007 -> 22:3:37"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
cursor ^<Cursor>

	^cursor! !

"June 5, 2007 -> 22:3:39"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
cursor: c <Cursor>

	cursor := c.! !

"June 5, 2007 -> 22:3:40"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
desiredPosition: p <Point>

	desiredPosition := p! !

"June 5, 2007 -> 22:3:41"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
enabled ^<Boolean>

	^enabled! !

"June 5, 2007 -> 22:3:42"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
enabled: flag <Boolean>

	self enabled = flag
		ifFalse: [	self setEnabled: flag ].! !

"June 5, 2007 -> 22:3:43"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
extent ^<Point>

	^extent! !

"June 5, 2007 -> 22:3:45"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
hasParent ^<Boolean>

	^parent notNil! !

"June 5, 2007 -> 22:3:46"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
hasSession ^<Session>

	^session notNil! !

"June 5, 2007 -> 22:3:47"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
hasWin32Handle ^<Boolean>

	^win32Handle notNil! !

"June 5, 2007 -> 22:3:48"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
initialInputFocus: v <Visual>

	initialInputFocus := v! !

"June 5, 2007 -> 22:3:49"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
max ^<Rect>

	^max! !

"June 5, 2007 -> 22:3:51"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
medium ^<Medium>

	^medium! !

"June 5, 2007 -> 22:3:52"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
menu ^<Menu>

	^menu! !

"June 5, 2007 -> 22:3:53"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
menu: m <Menu>

	menu isNil
		ifFalse: [ menu release ].
	menu := m.
	menu window: self.
	self hasWin32Handle
		ifTrue: [ self setNativeMenu ]! !

"June 5, 2007 -> 22:3:54"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
min ^<Rect>

	^min! !

"June 5, 2007 -> 22:3:55"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
mostRecentInputFocus: v  <Visual>

	mostRecentInputFocus := v! !

"June 5, 2007 -> 22:3:56"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
name: nm <Str>

	"By default, do nothing. Subclasses with a title bar can override this"! !

"June 5, 2007 -> 22:3:57"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
natural ^<Rect>

	^natural! !

"June 5, 2007 -> 22:3:59"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
noPalette

	palette := nil! !

"June 5, 2007 -> 22:4:0"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
optimizeIncrementalLayout ^<Boolean>
^false.
	^optimizeIncrementalLayout! !

"June 5, 2007 -> 22:4:1"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
optimizeIncrementalLayout: f <Boolean>

	(f ~= optimizeIncrementalLayout and: [ self hasWin32Handle ])
		ifTrue: [ self changing ].
	optimizeIncrementalLayout := f.! !

"June 5, 2007 -> 22:4:2"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
palette ^<Palette>

	^palette! !

"June 5, 2007 -> 22:4:3"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
palette: p <Palette>

	p == palette
		ifTrue: [ ^self ].
	self assert: [ palette isNil ].
	palette := p! !

"June 5, 2007 -> 22:4:4"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
parent ^<Window>

	^parent! !

"June 5, 2007 -> 22:4:6"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
parent: p <Window>
	"This message must be sent before the window handle is created"

	parent := p! !

"June 5, 2007 -> 22:4:7"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
refreshInterval ^<Float>

	^refreshInterval! !

"June 5, 2007 -> 22:4:8"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
refreshInterval: d <Float>
	"Wait no longer than this amount of time (in seconds) between
		paint operations, if possible"

	refreshInterval := d! !

"June 5, 2007 -> 22:4:10"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
session ^<Session>

	^session! !

"June 5, 2007 -> 22:4:11"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
setNativeMenu

	{{<user ExternalProxy SetMenu>
		wnd: self win32Handle
		menu: self menu win32Handle
	}} asBoolean
		ifFalse: [ Win32 handleError ]! !

"June 5, 2007 -> 22:4:12"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
toClose ^<[Window]>

	^toClose! !

"June 5, 2007 -> 22:4:13"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
toClose: blk <[Window]>

	toClose := blk! !

"June 5, 2007 -> 22:4:14"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
useDisplayBuffering ^<Boolean>

	^useDisplayBuffering! !

"June 5, 2007 -> 22:4:15"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
useDisplayBuffering: f <Boolean>

	useDisplayBuffering := f! !

"June 5, 2007 -> 22:4:17"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
visual ^<Visual>

	^visual! !

"June 5, 2007 -> 22:4:18"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
close
	"Close and destroy the window.  This causes release to be sent to the window and its visual"

	self session aboutToDestroyWindow: self.
	{{<user ExternalProxy DestroyWindow> arg: win32Handle}}.
! !

"June 5, 2007 -> 22:4:19"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
ignoreNextFocusSet: flag <Boolean>

	ignoreNextFocusSet := flag! !

"June 5, 2007 -> 22:4:21"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
invalidate

	self visual layoutStatus > Visual invalid
		ifTrue: [ self invalidate: self allocation enclosingRect	].! !

"June 5, 2007 -> 22:4:22"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
invalidate: r <Region>

	| rect <Rect> |

	self registerPaintTime.
	rect := r enclosingRect.
	(self scratchRECT)
		left: rect left asInteger;
		right: rect right asInteger;
		top: rect top asInteger;
		bottom: rect bottom asInteger.
	{{<user ExternalProxy InvalidateRect>
		hwnd: self win32Handle
		RECT: self scratchRECT
		erase: false asExternalData}}! !

"June 5, 2007 -> 22:4:23"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
makeActive
	"Make this the active window"

	{{<user ExternalProxy SetForegroundWindow> hwnd: self win32Handle }}.! !

"June 5, 2007 -> 22:4:24"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
release

	scratchRECT free.

	self session unregisterWindow: self.

	visual notNil
		ifTrue: [	visual detaching; release.
						visual := nil.	].

	win32Handle := nil.

	self hasMenu
		ifTrue: [ self menu release ].
	mostRecentInputFocus := nil.
	menu := nil.
	popUpMenu := nil.
	toClose := nil.
	controls := nil.
! !

"June 5, 2007 -> 22:4:25"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
requestClose

	self toClose value: self.! !

"June 5, 2007 -> 22:4:27"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
show
	"Make the window visible"

	{{<user ExternalProxy ShowWindow>
			window: self win32Handle
			nCmdShow: self nCmdShow}}.
	! !

"June 5, 2007 -> 22:4:28"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
showModal
	"Make the window visible as a modal window"

	self session addModalWindow: self.
	self show.
	! !

"June 5, 2007 -> 22:4:29"!

! (Delta mirrorFor: #Window) methodsFor: 'debugging' !
dumpOn: strm <CharOutputStream>

Transcript show: self class name, ' extent: '; print: self extent; show: ' hwnd: '; print: self win32Handle; cr.
	self visual dumpOn: strm indent: 1.! !

"June 5, 2007 -> 22:4:31"!

! (Delta mirrorFor: #Window) methodsFor: 'event handling' !
character: c <Character> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	^(self visual character: c focus: focus event: ev)
		or: [	c = Character tab
					onTrue: [ self handleTabEvent: ev ] ]! !

"June 5, 2007 -> 22:4:32"!

! (Delta mirrorFor: #Window) methodsFor: 'event handling' !
keyDown: key <Symbol> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	(self visual keyDown: key focus: focus event: ev)
		ifTrue: [ ^true ].
		
	(key = #TAB and: [ ev ctrlPressed ])
		ifTrue: [ self handleTabEvent: ev.	^true ].
	key = #F1 ifTrue: [ Profiler start.	^true ].
	key = #F2 ifTrue: [ Profiler stop.	^true ].
	^false	! !

"June 5, 2007 -> 22:4:33"!

! (Delta mirrorFor: #Window) methodsFor: 'event handling' !
keyUp: key <Symbol> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	^self visual keyUp: key focus: focus event: ev
! !

"June 5, 2007 -> 22:4:34"!

! (Delta mirrorFor: #Window) methodsFor: 'event handling' !
mouseEvent: type <Symbol> at: loc <Point> event: ev <UIEvent> ^<Boolean>

	^self visual layoutStatus = Visual valid
		and: [ 	| grabGotIt <Boolean> |
						grabGotIt := self session
												mouseEvent: type
												at: loc
												event: ev.
						grabGotIt or: [	(self visual renderingRegion inParentContainsPoint: loc)
												and: [	Sampler notNil
																ifTrue: [ Sampler in: self visual sampleEvent: type at: loc - self visual position event: ev ].
															self visual
																mouseEvent: type
																at: loc - self visual position
																event: ev	] ] ]
! !

"June 5, 2007 -> 22:4:36"!

! (Delta mirrorFor: #Window) methodsFor: 'initialization' !
initSession: sess <Session>
visual: vis <Visual>

	medium := sess medium.
	session := sess.
	visual := vis.

	(self visual)
		parent: self id: 1.

	self showTimes
		ifTrue: [ Transcript show: 'prefs: '; print: [ self computePreferences ] time; cr. ]
		ifFalse: [ self computePreferences ].

	scratchRECT := RECT new allocate.
	self optimizeIncrementalLayout: true.
	ignoreNextFocusSet := false.

	self refreshInterval: self defaultRefreshInterval.
	self paintPending: false.
	self useDisplayBuffering: true.

	self toClose: [ :w <Window> | w close ].
	self enabled: true.
	controls := IdentitySet[Win32Control] new.
	self haveErased: false.! !

"June 5, 2007 -> 22:4:37"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
activeMenu ^<Menu>
	"Returns the menu that is currently active, if there is one.  It may either be the top level menu,
	  or a popup menu over the window"

	^popUpMenu notNil
		ifTrue: [ popUpMenu ]
		ifFalse: [ menu ]! !

"June 5, 2007 -> 22:4:38"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
beforeQueuedMessage

	"%remove this and calls to it"! !

"June 5, 2007 -> 22:4:40"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
beforeSetFocus

	ignoreNextFocusSet
		ifTrue: [	"We requested the focus, and have already recorded it, so
							ignore this."
						ignoreNextFocusSet := false.	]
		ifFalse: [	self visual layoutValid
							ifTrue: [	"We didn't request this, so windows must be requesting it, so
												record it"
											self findInputFocus	]	].! !

"June 5, 2007 -> 22:4:41"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
beginPaint: hwnd <HWND>  paintStructure: ps <PAINTSTRUCT>  ^<HDC>

	^{{<user HDC BeginPaint> arg: hwnd arg: ps}}! !

"June 5, 2007 -> 22:4:42"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
buildWin32Handle
	"Subclasses must implement to create the appropriate type of window handle &
	  store it in win32Handle"

	self subclassResponsibility! !

"June 5, 2007 -> 22:4:44"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
callAsyncDefWndProcFor: hwnd <HWND>
msgCode: msgCode <ExternalData>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>
	"like callDefWndProcFor:msgCode:wParam:lParam:
			but is asynchronous"

	^{{<user ExternalProxy DefWindowProcA async>
			hwnd: hwnd
			value: msgCode
			value: wParam
			value: lParam
	  }}! !

"June 5, 2007 -> 22:4:45"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
callDefWndProcFor: hwnd <HWND>
msgCode: msgCode <ExternalData>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^{{<user ExternalProxy DefWindowProcA>
			hwnd: hwnd
			value: msgCode
			value: wParam
			value: lParam
	  }}! !

"June 5, 2007 -> 22:4:46"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
computePreferences

	natural := Point origin corner: self visual natural enclosingRect extent.
	min := Point origin corner: self visual min enclosingRect extent.
	max := Point origin corner: self visual max enclosingRect extent.! !

"June 5, 2007 -> 22:4:47"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
controls ^<Extensible[Win32Control]>

	^controls! !

"June 5, 2007 -> 22:4:48"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
defaultRefreshInterval ^<Float>

	^0.25! !

"June 5, 2007 -> 22:4:50"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
defaultWndProc ^<ExternalProxy>

	^self actualClass defaultWndProc! !

"June 5, 2007 -> 22:4:51"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
deferredPaintRegion ^<Rect>

	^deferredPaintRegion! !

"June 5, 2007 -> 22:4:52"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
deferredPaintRegion: r <Rect>

	deferredPaintRegion := r! !

"June 5, 2007 -> 22:4:53"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
desiredXPos ^<ExternalData>

	^desiredPosition isNil
		ifFalse: [ desiredPosition x asInteger ]
		ifTrue: [  Win32 CW_USEDEFAULT ]! !

"June 5, 2007 -> 22:4:55"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
desiredYPos ^<ExternalData>

	^desiredPosition isNil
		ifFalse: [ desiredPosition y asInteger ]
		ifTrue: [  Win32 CW_USEDEFAULT ]! !

"June 5, 2007 -> 22:4:56"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
display

	| subs <Cltn[Win32Control]> |
	self withCanvasDo:
			[ :can <Canvas> |
				| paintBlk <[^Object]> |	
				paintBlk := 
					[	self paintBackgroundOn: can.
						self displayVisualIfCanOn: can.
						can shallowFlush.  ].
				self showTimes
					ifTrue: [  Transcript show: 'paint: '; print: paintBlk time; cr. ]
					ifFalse: [ paintBlk value ].
				can hasSubwindowsToDisplay
					ifTrue: [ subs := can takeSubwindowsToDisplay ].
			].
	subs notNil
		ifTrue: [	subs do:
							[ :sub <Win32Control> |
								"%hack: the handle test should not be 
									necessary; something is screwed up"
								sub hasWin32Handle
									ifTrue: [	sub sendMessage: Win32 WM_PAINT
														wparam: 0 lparam: 0.
												].
							].
					 ]! !

"June 5, 2007 -> 22:4:57"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
displayVisualIfCanOn: canvas <Canvas>

	self session visualCriticalWouldBlock
		ifTrue: [ self recordDeferredPaint: canvas clippingRect ]
		ifFalse: [	self paintOccuring.
						self visual displayOn: canvas.	]! !

"June 5, 2007 -> 22:4:58"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
endPaint: hwnd <HWND>  paintStructure: ps <PAINTSTRUCT>

	^{{<user ExternalProxy EndPaint> arg: hwnd arg: ps}}! !

"June 5, 2007 -> 22:4:59"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
extent: e <Point>
	"Change the window's extent.  This will cause a relayout
		to happen later, which will record the extent."

	| pos <Point> adjusted <Rect> |
	adjusted := self fitToMedium: e.
	pos := self getPosition.
	{{<user ExternalProxy MoveWindow>
		hwnd: self win32Handle
		x: pos x
		y: pos y
		width: adjusted x
		height: adjusted y
		repaint: true asExternalData
	}} asBoolean 
		ifFalse: [ Win32 handleError ].! !

"June 5, 2007 -> 22:5:1"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
findInputFocus

	"find some non-native visual
	  within us to give the input focus to."

	"If there is already a focus, and it is in this window, then we are in a callback caused
	  by our own attempt to set the focus, so do nothing."
	(self session hasInputFocus and: [ self session inputFocus nativeWindow = self ])
		ifTrue: [ ^self ].

	"If we have a valid memory of what our input focus was last time, use it"
	self purgeMostRecentFocusIfNeeded.
	(mostRecentInputFocus notNil and: [ mostRecentInputFocus topWindow = self ])
		ifTrue: [ "Search to see if the most recent one is still a reachable, valid candidate"
					 "%todo: we could optimize this by adding another call to the heirarchy called
						verifyFocusCandidate which sends verifyFocusCandidate:self up the heirarchy,
						giving pacifiers etc. a chance to deny it the focus.  This would be MUCH faster
						than the following loop."
					"Also note that we use session inputFocus: rather than becomeFocus, because this
						 thing was previously the focus, so we don't want to do things like scroll it"
					 self visual focusCandidatesDo:
						[ :cand <Visual> |
							cand = mostRecentInputFocus
								ifTrue: [	self session inputFocus: cand.

												^self		"^^^^^^^^^^^^^"		] ]. ].

	"There is no valid previous focus to reuse, so just choose the first one"
	(self visual firstFocusCandidateIfAbsent: [ ^self ])
		becomeFocus.
! !

"June 5, 2007 -> 22:5:2"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
fitToMedium: clientExtent <Point>  ^<Point>
	"takes a client extent, and returns a window extent adjusted so that it will fit on the screen"

	| normal <Point> withoutCaption <Point> captionHeight <Int> adjClient <Point> |	
	normal := (self windowSizeForClientAreaSize: clientExtent) min: self medium extent.
	withoutCaption := (self windowSizeWithoutCaptionForClientAreaSize: clientExtent) min: self medium extent.
	captionHeight := normal y - withoutCaption y.
	^self windowSizeForClientAreaSize:
			 (clientExtent x min: self medium extent x)
		@ ((clientExtent y + captionHeight min: self medium extent y) - captionHeight).! !

"June 5, 2007 -> 22:5:4"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
getPosition ^<Point>

	{{<user ExternalProxy GetWindowRect>
		hwnd: self win32Handle
		rect: self scratchRECT
	}} asBoolean
		ifFalse: [ Win32 handleError ].
	^self scratchRECT left @ self scratchRECT top! !

"June 5, 2007 -> 22:5:5"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
globalFromLocalPosition: p <WinPOINT> ^<WinPOINT>

	| wp <WinPOINT> result <WinPOINT> |
	wp := WinPOINT new allocate.
	wp x: p x; y: p y.
	{{<user ExternalProxy ClientToScreen>
			handle: self win32Handle
			point: wp
	}} asBoolean
		ifFalse: [ Win32 handleError ].
	result := wp x @ wp y.
	wp free.
	^result! !

"June 5, 2007 -> 22:5:6"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
handleTabEvent: ev <UIEvent>

	ev shiftPressed
		ifTrue: [ self moveFocusBack ]
		ifFalse: [ self moveFocusForward ]! !

"June 5, 2007 -> 22:5:7"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
hasBackgroundPainter ^<Boolean>

	^backgroundPainter notNil! !

"June 5, 2007 -> 22:5:9"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
hasMenu ^<Boolean>
	"Returns the menu that is currently active, if there is one.  It may either be the top level menu,
	  or a popup menu over the window"

	^popUpMenu notNil or: [ menu notNil ]! !

"June 5, 2007 -> 22:5:10"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
haveErased ^<Boolean>

	^haveErased! !

"June 5, 2007 -> 22:5:11"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
haveErased: f <Boolean>

	haveErased := f! !

"June 5, 2007 -> 22:5:13"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
initWindowsMessageHandlers

	WindowsMessageHandlers
		at: Win32 WM_CLOSE	put:
				[ :w <Window> :msg  <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w closeMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_SETCURSOR	put:
				[ :w <Window> :msg  <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w setCursorMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_PAINT	put:
				[ :w <Window> :msg  <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w paintMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_ERASEBKGND	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w eraseBackgroundMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_CTLCOLORBTN	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w buttonColorMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_DRAWITEM	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w drawItemMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_KEYDOWN	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w keyDownMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_KEYUP	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w keyUpMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_CHAR	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w characterMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];

		"mouse events are handled by a common event routine"
		at: Win32 WM_LBUTTONDOWN put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #primaryButtonDown at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_LBUTTONUP	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #primaryButtonUp at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_LBUTTONDBLCLK	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #primaryButtonDoubleClick at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_MBUTTONDOWN	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #middleButtonDown at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_MBUTTONUP	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #middleButtonUp at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_RBUTTONDOWN put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #secondaryButtonDown at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_RBUTTONUP put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #secondaryButtonUp at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_RBUTTONDBLCLK put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #secondaryButtonDoubleClick at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_MOUSEMOVE put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #mouseMove at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];

		at: Win32 WM_MEASUREITEM	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w measureItemMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_SETFOCUS	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w setFocusMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_KILLFOCUS	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w killFocusMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_COMMAND	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w commandMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_GETMINMAXINFO	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w getMinMaxInfoMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_SIZE	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w sizeMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_NCDESTROY	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w ncDestroyMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_DESTROY	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w destroyMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_CAPTURECHANGED	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w captureChangedMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_INITMENUPOPUP	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w initMenuPopupMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_QUERYNEWPALETTE	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w queryPaletteMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_PALETTECHANGED	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w paletteChangedMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];

		"---------- Custom messages"
		at: Window LAYOUT	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w layoutMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];

		yourself! !

"June 5, 2007 -> 22:5:15"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
initialInputFocus ^ <Visual>

	^initialInputFocus! !

"June 5, 2007 -> 22:5:16"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
layout: extent <Point>

	| firstLayout <Boolean> |

	firstLayout := self visual layoutStatus = Visual invalid.
 	self showTimes
		ifTrue: [	Transcript show: 'layout: '; print: [ 
								self visual allocationInParent: (0@0 corner: extent).
						] time; cr. ]
		ifFalse: [	self visual allocationInParent: (0@0 corner: extent). ].

	"We have to do this now because we can't set the input focus until layout is
		complete, since the containing native window must be accessed, etc."
	firstLayout
		ifTrue: [	self palette notNil
							ifTrue: [ self recursiveRealizePaletteForeground: true updateColors: true. ].
						(self initialInputFocus notNil and: [ self initialInputFocus isFocusCandidate ])
							ifTrue: [		self initialInputFocus becomeFocus.
												self initialInputFocus: nil 	"Not needed anymore, prevent memory leak"	]
							ifFalse: [	self findInputFocus ]
					  ]! !

"June 5, 2007 -> 22:5:18"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
localFromGlobalPosition: p <WinPOINT> ^<WinPOINT>

	| wp <WinPOINT> result <WinPOINT> |
	wp := WinPOINT new allocate.
	wp x: p x; y: p y.
	{{<user ExternalProxy ScreenToClient>
			handle: self win32Handle
			point: wp
	}} asBoolean
		ifFalse: [ Win32 handleError ].
	result := wp x @ wp y.
	wp free.
	^result! !

"June 5, 2007 -> 22:5:19"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
menuCommandForItem: id <Int>

	(MenuItem itemFor: id)
		execute! !

"June 5, 2007 -> 22:5:20"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
moveFocusBack

	(self visual lastFocusCandidateBefore: self session inputFocus)
		becomeFocus! !

"June 5, 2007 -> 22:5:22"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
moveFocusForward

	(self visual nextFocusCandidateAfter: self session inputFocus)
		becomeFocus! !

"June 5, 2007 -> 22:5:23"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
nCmdShow ^<ExternalProxy>

	^{{primitiveWindowsNCmdShow}}! !

"June 5, 2007 -> 22:5:24"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
nextPaintTime ^<Float>

	^nextPaintTime! !

"June 5, 2007 -> 22:5:25"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
nextPaintTime: t <Float>

	nextPaintTime := t! !

"June 5, 2007 -> 22:5:27"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
paintBackgroundOn: can <Canvas>

	can withPainter: self backgroundPainter do:
		[ can displayFilledRectangle:
			(Point origin corner: self allocation enclosingRect extent) ].! !

"June 5, 2007 -> 22:5:28"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
paintOccuring

	self nextPaintTime: Time clockValue + self refreshInterval.
	self paintPending: false.
	self session paintOccuredFor: self.! !

"June 5, 2007 -> 22:5:29"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
parentHandle ^<ExternalData>

	^parent isNil
		ifFalse: [ parent win32Handle ]
		ifTrue: [ Win32 NULL ]! !

"June 5, 2007 -> 22:5:30"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
purgeMostRecentFocusIfNeeded

	"%kludge: This should be called occasionally (in user time) to avoid memory leaks caused by
	  a pointer to a zombie visual"
	"%todo: this isn't called yet.  Set up a scanner that sends this to all windows every ten seconds or
	   so."
	(mostRecentInputFocus notNil and: [ mostRecentInputFocus isAttached not ])
		ifTrue: [ mostRecentInputFocus := nil ]! !

"June 5, 2007 -> 22:5:31"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
recordDeferredPaint: region <Rect> 

	self deferredPaintRegion:
		(self deferredPaintRegion isNil
			ifTrue: [ region ]
			ifFalse: [ self deferredPaintRegion merge: region ]
		)! !

"June 5, 2007 -> 22:5:32"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
recordExtent

		self setExtent: self trueClientAreaExtent.! !

"June 5, 2007 -> 22:5:34"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
registerPaintTime

	self paintPending
		ifFalse: [	self paintPending: true.
						self nextPaintTime: Time clockValue + self refreshInterval.
						self session schedulePaintFor: self at: self nextPaintTime.	].! !

"June 5, 2007 -> 22:5:35"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
relayoutIfNeeded

	self relayoutIfNeededForExtent: self extent! !

"June 5, 2007 -> 22:5:36"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
relayoutIfNeededForExtent: e <Point>

	self visual needsRelayout
		ifTrue: [ self layout: (self visual max enclosingRect extent min: e) ].
	self invalidate.! !

"June 5, 2007 -> 22:5:37"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
scratchRECT ^<RECT>

	^scratchRECT! !

"June 5, 2007 -> 22:5:39"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
setCursor ^<ExternalData>

	^cursor isNil
		ifFalse: [	{{<user ExternalProxy SetCursor> handle: cursor win32Handle}}.
						1 ]
		ifTrue: [ 0 ]! !

"June 5, 2007 -> 22:5:40"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
setEnabled: flag <Boolean>

	enabled := flag.
	self hasWin32Handle
		ifTrue: [	{{<user ExternalProxy EnableWindow async>
								handle: self win32Handle
								state: enabled asExternalData}}.	].! !

"June 5, 2007 -> 22:5:41"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
setExtent: e <Point>

	extent := e! !

"June 5, 2007 -> 22:5:42"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
setName: nm <Str>

	self hasWin32Handle
		ifTrue: [	| title <CString> |
						title := CString for: nm.
						[	{{<user ExternalProxy SetWindowTextA>
											hwnd: self win32Handle
											title: title
							}} asBoolean
								ifFalse: [ Win32 handleError ].
						] ensure: [ title free ]
					 ]! !

"June 5, 2007 -> 22:5:44"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
shouldCallDefaultHandlerAsynchronouslyFor: msgCode <ExternalData>  ^<Boolean>

	^msgCode @= Win32 WM_SYSCOMMAND		"so that window moves let other sessions repaint"! !

"June 5, 2007 -> 22:5:45"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
showTimes ^<Boolean>
	"Report preference, layout, and painting times on the transcript"

	^false! !

"June 5, 2007 -> 22:5:46"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
trueClientAreaExtent ^<Point>

	^self trueClientAreaExtentFor: self win32Handle! !

"June 5, 2007 -> 22:5:47"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
trueClientAreaExtentFor: hwnd <ExternalData> ^<Point>

	| extent <Point> rect <RECT> |
	rect := RECT new allocate.
	{{<user RECT GetClientRect> arg: hwnd arg: rect}}.
	extent := (rect right - rect left) @ (rect bottom - rect top).
	rect free.
	^extent! !

"June 5, 2007 -> 22:5:49"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
win32Handle: h <HWND>

	win32Handle := h! !

"June 5, 2007 -> 22:5:50"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
win32Style ^<ExternalData>

	| s <ExternalData> |
	s := 0.
	self enabled
		ifFalse: [ s := s externalBitOr: Win32 WS_DISABLED ].
	^s
! !

"June 5, 2007 -> 22:5:51"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
windowSizeForClientAreaSize: extent <Point>  ^<Point>
	"returns an integral point that is the correct window size for a desired client area size"

	^self windowSizeForClientAreaSize: extent windowStyle: self win32Style! !

"June 5, 2007 -> 22:5:52"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
windowSizeForClientAreaSize: extent <Point> windowStyle: style <ExternalData>  ^<Point>
	"returns an integral point that is the correct window size for a desired client area size"

	| r <RECT> result <Point> |
	r := RECT new allocate.
	r top: 0; left: 0; right: extent x asInteger; bottom: extent y asInteger.
	{{<user ExternalProxy AdjustWindowRect>
				 rect: r style: style hasMenu: self hasMenu asExternalData}} asBoolean
		ifFalse: [ Win32 handleError ].
	result := (r right - r left) @ (r bottom - r top).
	r free.
	^result! !

"June 5, 2007 -> 22:5:54"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
windowSizeWithoutCaptionForClientAreaSize: extent <Point>  ^<Point>
	"returns an integral point that is the correct window size for a desired client area size"

	^self windowSizeForClientAreaSize: extent
			windowStyle: (self win32Style externalBitAnd: (Win32 WS_CAPTION asSmallInteger bitInvert))! !

"June 5, 2007 -> 22:5:55"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
windowsMessageHandlers ^<Dict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>

	"Don't need critical region since duplicate inits are no problem"
	WindowsMessageHandlers isNil
		ifTrue: [	WindowsMessageHandlers :=
							CustomDictionary[ExternalData,[Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData]]
									withCompareBlock: [ :k1 <ExternalData> :k2 <ExternalData> |    k1 @= k2 ]
									hashBlock: [ :k <ExternalData> |  k hash ].
						self initWindowsMessageHandlers.
						].
	^WindowsMessageHandlers! !

"June 5, 2007 -> 22:5:57"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
withBufferedCanvasDo: drawing <[Canvas,^X def]> ^<X>

	^self withDirectCanvasDo:
		[ :directCanvas <Canvas> |
			| invalid <Rect> oldpal <Win32Handle> |
			invalid := directCanvas clippingRect.

			self session
				withBufferCanvasFor: invalid
				do: [ :bufferCanvas <Canvas> :buffer <HBITMAP> |

						self palette isNil
							ifFalse: [ oldpal := bufferCanvas win32Palette: self palette win32Handle ].

						"draw on the buffer canvas"
						drawing value: bufferCanvas.
						bufferCanvas shallowFlush.

						"Now, copy the buffer bits onto the screen"
						directCanvas atOffset: invalid origin
							do: [ bufferCanvas atOffset: invalid origin 
								do: [	directCanvas
											bitBlt: bufferCanvas
											extent: invalid extent
											op: UI ropCopy.		].	].
						 oldpal notNil
								ifTrue: [ 	Palette debugging
													ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
												bufferCanvas win32Palette: oldpal ]. 
						].	
		]! !

"June 5, 2007 -> 22:5:58"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
withCanvasDo: drawing <[Canvas,^X def]> ^<X>

	^(self useDisplayBuffering and: [ Window bufferingPossible ])
		ifFalse: [	self withDirectCanvasDo: drawing ]
		ifTrue: [	self withBufferedCanvasDo: drawing ]! !

"June 5, 2007 -> 22:5:59"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
withDCDo: blk <[HDC]>
	"With the window's device context do the block (not for painting)"

	| hdc <HDC> |
	hdc := {{<user HDC GetDC> hwnd: self win32Handle}}.
	[ blk value: hdc ]
		ensure: [ hdc releaseDCFor: self win32Handle ]! !

"June 5, 2007 -> 22:6:1"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
withDirectCanvasDo: drawing <[Canvas,^X def]> ^<X>

	|	can <Canvas>
		ps <PAINTSTRUCT>
		paintBlk <[^Object]>
		result <X>
		oldpal <Win32Handle> |

	"use a critical region to paint, since background painting might reuse the
	  same device context in the UI thread"
	^self critical:
		[	ps := PAINTSTRUCT new allocateZeroed.
			can := self beginPaint: self win32Handle paintStructure: ps.
			can isNull
				ifTrue: [ Win32 handleError ].
			can	initialize;
				toRelease: [ :dc <HDC> | "End paint will release the context" ];
				initClippingRectBeforeTranslation: ps rcPaint asRectangle;
				window: self.
			self palette isNil
				ifFalse: [ oldpal := can win32Palette: self palette win32Handle ].

			Session debugInvalidation
				ifTrue: [	can withPainter: (Painter new paint: Paint red)
									do: [ can displayFilledRectangle: ps rcPaint asRectangle; flush. ].
								Platform errorStream show: self class name, ' rendering: '; print: ps rcPaint asRectangle; cr.	].

			result := drawing value: can.
			oldpal notNil
				ifTrue: [ 	Palette debugging
									ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
								can win32Palette: oldpal ]. 
			can release. 

			self endPaint: self win32Handle paintStructure: ps.
			ps free.
			result	]! !

"June 5, 2007 -> 22:6:2"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
wndProc ^<APICallback>

	^self session wndProc! !

"June 5, 2007 -> 22:6:3"!

! (Delta mirrorFor: #Window) methodsFor: 'private-testing' !
paintPending ^<Boolean>

	^paintPending! !

"June 5, 2007 -> 22:6:5"!

! (Delta mirrorFor: #Window) methodsFor: 'private-testing' !
paintPending: b <Boolean>

	paintPending := b! !

"June 5, 2007 -> 22:6:6"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
changing

	self session changing: self.
	self session recordPrefsFor: self.
	natural := min := max := nil.! !

"June 5, 2007 -> 22:6:8"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
checkLayout: oldPrefs <SeqCltn[Region]>

	| oldNat <Rect> alloc <Rect> nat <Rect> ext <Point> |
	oldNat := (oldPrefs at: 2) enclosingRect.
	self computePreferences.
	nat := self natural enclosingRect.
	alloc := self allocation enclosingRect.

	"We have to do the relayout eagerly, even before the size message
			comes back, because the caller assumes that layout is then done."

	((alloc contains: self min enclosingRect)
			and: [ self max enclosedRect contains: alloc ]
	)	ifFalse: [	"We definitely have to change our size"
							self relayoutIfNeededForExtent: nat extent.
							self extent: nat extent.
							^self	].

	(self optimizeIncrementalLayout
			or: [ nat = oldNat
			or: [	alloc contains: nat ] ])
		ifTrue: [	self relayoutIfNeededForExtent: self extent.
						^self ].

	ext := (nat width max: alloc width) @ (nat height max: alloc height).
	self relayoutIfNeededForExtent: ext.
	self extent: ext.! !

"June 5, 2007 -> 22:6:9"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
checkPaintTime: t <Float>
	"If we have reached our refresh time, paint"
	
"%todo: figure out how to remove the following %hack
		this should not be sent after the receiver is released)"	
visual isNil ifTrue: [ ^self ].

	(self hasWin32Handle and: [ self paintPending ])
		ifTrue: [ self nextPaintTime <= t
						ifTrue: [ self display ]
						ifFalse: [ self session needPaintAtTime: self nextPaintTime ]	 ]! !

"June 5, 2007 -> 22:6:11"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
oldcheckLayout: oldPrefs <SeqCltn[Region]>

	| oldNat <Rect> alloc <Rect> nat <Rect> |
	oldNat := (oldPrefs at: 2) enclosingRect.
	self computePreferences.
	nat := self natural enclosingRect.
	alloc := self allocation enclosingRect.

	"We have to do the relayout eagerly, even before the size message
			comes back, because the caller assumes that layout is then done."
	self relayoutIfNeeded.

	((alloc contains: self min enclosingRect)
			and: [ (self max enclosedRect contains: alloc)
			and: [ self optimizeIncrementalLayout
							or: [ nat = oldNat
							or: [	alloc contains: nat ] ] ] ]
	)	ifFalse: [	"We definitely have to change our size"
						self setExtent: nat extent.	].
! !

"June 5, 2007 -> 22:6:12"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
prefs ^<SeqCltn[Region]>

	^Array[Region] with: self min with: self natural with: self max! !

"June 5, 2007 -> 22:6:13"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
prefsStatus ^<Int>

	^Visual valid! !

"June 5, 2007 -> 22:6:14"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
prerecordPrefsIfNeeded

	"nothing to do"! !

"June 5, 2007 -> 22:6:15"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
processDeferredPainting

	self deferredPaintRegion notNil
		ifTrue: [	self invalidate: self deferredPaintRegion.
						self deferredPaintRegion: nil.		]! !

"June 5, 2007 -> 22:6:17"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
removeParentsFrom: leaves <Set[RelayoutTarget]>
alreadyChecked: checked <Set[RelayoutTarget]>

	"nothing to do"! !

"June 5, 2007 -> 22:6:18"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
hInstance ^<ExternalProxy>

	^self medium hInstance! !

"June 5, 2007 -> 22:6:19"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
message: msg <MSG>
	"This is invoked in the UI thread when a new message arrives in the queue."

	"Forward messages to the session, which will execute them in its thread"
	self session message: msg! !

"June 5, 2007 -> 22:6:21"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
message: msgCode <ExternalData>
for: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	"This is where all the win32 messages get converted to our semantics.  This
	  method executes in the window's session's thread for queued messages, and
	  either the session or UI thread for unqueued messages."

	"%note/%todo: each message below must call beforeQueuedMessage before processing
	     the message IFF the message is a queued (in session thread) message"

	^(self windowsMessageHandlers at: msgCode
		ifAbsent: [ ^self handleMiscMsg: msgCode hwnd: hwnd wParam: wParam lParam: lParam ]
     )	value: self
		value: msgCode
		value: hwnd
		value: wParam
		value: lParam! !

"June 5, 2007 -> 22:6:22"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
recursiveRealizePaletteForeground: fore <Boolean> updateColors: update <Boolean>

	self palette isNil
		ifFalse: [	self withDCDo:
							[ :hdc <HDC> |
								| oldpal <Win32Handle> |
								oldpal := Palette select: self palette win32Handle into: hdc background: fore not.
								self palette unrealize.
								self palette realizeFor: hdc.
								Palette debugging
									ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
								Palette select: oldpal win32Handle into: hdc background: fore not.
							 ].
						self invalidate.
						].
	self controls do:
		[ :c <Win32Control> |
			c recursiveRealizePaletteForeground: fore updateColors: update ].! !

"June 5, 2007 -> 22:6:23"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
registerControl: c <Win32Control>

	self controls include: c! !

"June 5, 2007 -> 22:6:24"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
releaseCapture

	{{<user ExternalProxy ReleaseCapture> noArgs}}! !

"June 5, 2007 -> 22:6:26"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
sendMessage: msg <ExternalData>
wparam: wp <ExternalData>
lparam: lp <ExternalData>
^<ExternalData>

	^{{<user ExternalProxy SendMessageA>
			handle: self win32Handle
			msg: msg
			wparam: wp
			lparam: lp}}! !

"June 5, 2007 -> 22:6:27"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
setCapture

	{{<user ExternalProxy SetCapture> hwnd: self win32Handle}}.
! !

"June 5, 2007 -> 22:6:28"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
setFocus

	 self win32Handle @= {{<user ExternalProxy GetFocus> call}}
		ifFalse: [  {{<user ExternalProxy SetFocus> hwnd: self win32Handle}} ]! !

"June 5, 2007 -> 22:6:29"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
unregisterControl: c <Win32Control>

	self controls removeEvery: c! !

"June 5, 2007 -> 22:6:31"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
win32Handle ^<HWND>

	win32Handle isNil
		ifTrue: [	self session creatingWindow: self do:
							[	self buildWin32Handle; recordExtent. ].  ].
	^win32Handle! !

"June 5, 2007 -> 22:6:32"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
characterMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self beforeQueuedMessage.
	^self session handleIfFocusMsg: msg for: self wParam: wParam lParam: lParam
! !

"June 5, 2007 -> 22:6:33"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
closeMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self requestClose.
	^0! !

"June 5, 2007 -> 22:6:34"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
commandMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	
	self beforeQueuedMessage.

	^lParam @~= Win32 NULL
		ifTrue: [	"Then this is a control window notification, which should be forwarded back to the
						  smalltalk control object"
						Win32Control notificationMsg: wParam asExternalProxy high for: (Win32Control controlIdFor: lParam).
						0 ]
		ifFalse: [ wParam asExternalProxy high = 0
							ifTrue: [	self menuCommandForItem: wParam low.
											0	]
							ifFalse: [ self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam ]	]! !

"June 5, 2007 -> 22:6:36"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
handleMiscMsg: msgCode <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	"This performs the default window system handling for a message"
	
	^(self shouldCallDefaultHandlerAsynchronouslyFor: msgCode)
		ifTrue: [	"Some messages should be handled asyncronously, so that for
							example, moving a window allows other sessions to refresh"
						self callAsyncDefWndProcFor: hwnd
							msgCode: msgCode
							wParam:  wParam
							lParam: lParam ]
		ifFalse: [	self callDefWndProcFor: hwnd
								msgCode: msgCode
								wParam:  wParam
								lParam: lParam	]! !

"June 5, 2007 -> 22:6:37"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
handleMouseEvent: type <Symbol>
at: loc <Point>
msg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	| ev <UIEvent> |
	self beforeQueuedMessage.

	"%todo: remove the dispatch block for all events; isn't needed anymore"
	ev := UIEvent
			forMsg: self session currentMsg
			dispatch:
				[ :e <UIEvent> :h <UIEventHandler> |
					h mouseEvent: type at: loc event: e ].
	self mouseEvent: type at: loc event: ev.

	"Mouse events are always passed through to the default wnd proc since their may be window system specific things
	  like bringing the window to the foreground that always have to happen. (I used to pass it through only when it
	  was a left button down msg, but this is cleaner)"
	^self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam! !

"June 5, 2007 -> 22:6:38"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
initMenuPopupMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self beforeQueuedMessage.
	self hasMenu 
		ifTrue: [ self activeMenu updateMenuWithHandle: wParam ].
	^0! !

"June 5, 2007 -> 22:6:40"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
keyDownMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self beforeQueuedMessage.
	^self session handleIfFocusMsg: msg for: self wParam: wParam lParam: lParam
! !

"June 5, 2007 -> 22:6:41"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
keyUpMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self beforeQueuedMessage.
	^self session handleIfFocusMsg: msg for: self wParam: wParam lParam: lParam
! !

"June 5, 2007 -> 22:6:42"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
layoutMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	| ext <Point> |
	ext := lParam low @ lParam high.
	(self visual layoutStatus < Visual valid
			or: [ self visual allocation enclosingRect extent ~= ext ])
		ifTrue: [ self layout: ext ].
	^0! !

"June 5, 2007 -> 22:6:44"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
paintMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self display.
	^0! !

"June 5, 2007 -> 22:6:45"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
setCursorMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^(cursor notNil
			and: [	| hitcode <Int> |
						hitcode := lParam asExternalProxy low.
						hitcode = 1 or: [ hitcode = 65534 ] "client area or disabled"  ])
		ifTrue: [ 	self setCursor.
						1 ]
		ifFalse: [ self callDefWndProcFor: hwnd
								msgCode: msg
								wParam: wParam
								lParam: lParam ]
! !

"June 5, 2007 -> 22:6:46"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
buttonColorMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^Win32Control buttonColorMsg: wParam asExternalProxy for: (Win32Control controlIdFor: lParam)! !

"June 5, 2007 -> 22:6:47"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
captureChangedMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self session lostCapture.
	
	^self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam! !

"June 5, 2007 -> 22:6:49"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
destroyMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^0! !

"June 5, 2007 -> 22:6:50"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
drawItemMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^Win32Control drawItemMsg: (DRAWITEMSTRUCT forProxy: lParam) for: wParam asSmallInteger! !

"June 5, 2007 -> 22:6:51"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
eraseBackgroundMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	| can <Canvas> |

	self haveErased
		ifTrue: [ ^1 ].
	self haveErased: true.

	"Don't paint background when a paint is pending to reduce flickering"
	self paintPending
		ifTrue: [ ^0 ].

	"Use a critical region because the window's thread might be drawing"
	self critical:
		[	can := HDC forProxy: wParam asExternalProxy.
			can initialize.
			self paintBackgroundOn: can. 	].
	^1! !

"June 5, 2007 -> 22:6:53"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
getMinMaxInfoMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	| info <MINMAXINFO> adjmin <Point> adjmax <Point> |
	info := MINMAXINFO forProxy: lParam asExternalProxy.
	adjmin := (self fitToMedium: self min extent) max: info ptMinTrackSize asPoint.
	adjmax := (self fitToMedium: self max extent) min: info ptMaxSize asPoint.
	info ptMaxSize x: adjmax x; y: adjmax y.
	info ptMaxTrackSize x: adjmax x; y: adjmax y.
	info ptMinTrackSize x: adjmin x; y: adjmin y.
	^0! !

"June 5, 2007 -> 22:6:54"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
killFocusMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	"This window is losing the input focus, which means that some non-native visual
	  within us probably has the focus, so we have to discard the focus."

	(self session hasInputFocus and: [ self session inputFocus nativeWindow = self ])
		ifTrue: [ self session noInputFocus ].

	^self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam! !

"June 5, 2007 -> 22:6:55"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
measureItemMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	| data <MEASUREITEMSTRUCT> |
	data := MEASUREITEMSTRUCT forProxy: lParam.
	^data CtlType @= Win32 ODT_MENU
		ifFalse: [ Win32Control measureItemMsg: data for: data CtlID asSmallInteger ]
		ifTrue: [ self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam ]! !

"June 5, 2007 -> 22:6:56"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
ncDestroyMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self release.
	^0! !

"June 5, 2007 -> 22:6:58"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
paletteChangedMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	wParam @= self win32Handle
		ifFalse: [ self recursiveRealizePaletteForeground: false updateColors: true.
						self palette isNil
							ifTrue: [ ^self callDefWndProcFor: hwnd
											msgCode: msg
											wParam: wParam
											lParam: lParam	].
					].
	^0! !

"June 5, 2007 -> 22:6:59"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
queryPaletteMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self recursiveRealizePaletteForeground: true updateColors: false.
	self palette isNil
		ifTrue: [ ^self callDefWndProcFor: hwnd
						msgCode: msg
						wParam: wParam
						lParam: lParam	].
	^0! !

"June 5, 2007 -> 22:7:0"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
setFocusMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	"This window is getting the input focus, which means that some non-native visual
	  within us will have to be chosen if possible."

	self beforeSetFocus.

	^self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam! !

"June 5, 2007 -> 22:7:2"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
sizeMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	"%todo: do we need to check the value of wParam first?"
	self critical:
		[ wParam @= Win32 SIZE_MINIMIZED
			ifFalse: [	| m <MSG> |
								self invalidate.
								m := MSG new allocate.
								[ m	hwnd: self win32Handle;
										message: Window LAYOUT;
										wParam: 0;
										lParam: lParam.
									self recordExtent.
									self session message: m.
								] ensure: [ m free ]
							]
		 ].
	^0! !

"June 5, 2007 -> 22:7:3"!

! (Delta mirrorFor: #Window) methodsFor: 'testing' !
isActive ^<Boolean>

	^self session hasActiveWindow and: [ self session activeWindow = self ]! !

"June 5, 2007 -> 22:7:46"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 22:7:48"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 22:7:48"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 22:7:48"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 22:7:48"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 22:7:48"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 22:7:48"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 22:7:48"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 22:7:48"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 22:7:48"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 22:7:48"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 22:7:49"!

(Delta mirrorFor: #SystemInitializer)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"June 5, 2007 -> 22:7:51"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
benchmarkDictionary
	| dict |
	dict := Dictionary new.

	"Benchmarks"
	dict at: #richards			put: [ :runner :repeat :inner | runner new runRichardsBenchmarks: 		repeat ].
	dict at: #smopstones	put: [ :runner :repeat :inner | runner new runSmopstoneBenchmarks:	repeat ].
	dict at: #slopstones		put: [ :runner :repeat :inner | runner new runSlopstoneBenchmarks:		repeat ].
	dict at: #stanford			put: [ :runner :repeat :inner | runner new runStanfordBenchmarks:		repeat ].
	dict at: #deltablue			put: [ :runner :repeat :inner | runner new runDeltaBlue:							repeat ].
	dict at: #benchmarks	put: [ :runner :repeat :inner | 
		runner new runStanfordBenchmarks:			repeat.
		runner new runRichardsBenchmarks:		repeat.
		runner new runDeltaBlue:								repeat.
		runner new runSlopstoneBenchmarks:		repeat.
		runner new runSmopstoneBenchmarks:	repeat.
	].
	
	dict at: #loop			put: [ :runner :repeat :inner | runner new runStanfordLoopBenchmarks: repeat ].
	
	"Individual Stanford Benchmarks"
	dict at: #bubblesort		put: [ :runner :repeat :inner | runner new runIndividualStanford: BubbleSortBenchmark repeat: repeat inner: inner].
	dict at: #bubblesort2	put: [ :runner :repeat :inner | runner new runIndividualStanford: BubbleSort2Benchmark repeat: repeat inner: inner].
	dict at: #intmm				put: [ :runner :repeat :inner | runner new runIndividualStanford: IntMMBenchmark repeat: repeat inner: inner].
	dict at: #intmm2			put: [ :runner :repeat :inner | runner new runIndividualStanford: IntMM2Benchmark repeat: repeat inner: inner].
	dict at: #mm					put: [ :runner :repeat :inner | runner new runIndividualStanford: MMBenchmark repeat: repeat inner: inner].
	dict at: #mm2				put: [ :runner :repeat :inner | runner new runIndividualStanford: MM2Benchmark repeat: repeat inner: inner].
	dict at: #perm				put: [ :runner :repeat :inner | runner new runIndividualStanford: PermBenchmark repeat: repeat inner: inner].
	dict at: #perm2				put: [ :runner :repeat :inner | runner new runIndividualStanford: Perm2Benchmark repeat: repeat inner: inner].
	dict at: #queens			put: [ :runner :repeat :inner | runner new runIndividualStanford: QueensBenchmark repeat: repeat inner: inner].
	dict at: #queens2			put: [ :runner :repeat :inner | runner new runIndividualStanford: Queens2Benchmark repeat: repeat inner: inner].
	dict at: #quicksort		put: [ :runner :repeat :inner | runner new runIndividualStanford: QuicksortBenchmark repeat: repeat inner: inner].
	dict at: #quicksort2		put: [ :runner :repeat :inner | runner new runIndividualStanford: Quicksort2Benchmark repeat: repeat inner: inner].
	dict at: #towers			put: [ :runner :repeat :inner | runner new runIndividualStanford: TowersBenchmark repeat: repeat inner: inner].
	dict at: #towers2			put: [ :runner :repeat :inner | runner new runIndividualStanford: Towers2Benchmark repeat: repeat inner: inner].
	dict at: #treesort			put: [ :runner :repeat :inner | runner new runIndividualStanford: TreeSortBenchmark repeat: repeat inner: inner].
	dict at: #treesort2		put: [ :runner :repeat :inner | runner new runIndividualStanford: TreeSort2Benchmark repeat: repeat inner: inner].
	dict at: #puzzle				put: [ :runner :repeat :inner | runner new runIndividualStanford: PuzzleBenchmark repeat: repeat inner: inner].
	dict at: #sieve				put: [ :runner :repeat :inner | runner new runIndividualStanford: SieveBenchmark repeat: repeat inner: inner].
	dict at: #sumto				put: [ :runner :repeat :inner | runner new runIndividualStanford: SumToBenchmark repeat: repeat inner: inner].
	dict at: #recurse			put: [ :runner :repeat :inner | runner new runIndividualStanford: RecurseBenchmark repeat: repeat inner: inner].
	dict at: #atallput			put: [ :runner :repeat :inner | runner new runIndividualStanford: AtAllPutBenchmark repeat: repeat inner: inner].
	dict at: #incrementall	put: [ :runner :repeat :inner | runner new runIndividualStanford: IncrementAllBenchmark repeat: repeat inner: inner].
	dict at: #nestedloop		put: [ :runner :repeat :inner | runner new runIndividualStanford: NestedLoopBenchmark repeat: repeat inner: inner].
	dict at: #tak					put: [ :runner :repeat :inner | runner new runIndividualStanford: TakBenchmark repeat: repeat inner: inner].
	dict at: #takl					put: [ :runner :repeat :inner | runner new runIndividualStanford: TaklBenchmark repeat: repeat inner: inner].
	dict at: #ordcol				put: [ :runner :repeat :inner | runner new runIndividualStanford: OrderedCollectionBenchmark repeat: repeat inner: inner].
	dict at: #dictionary		put: [ :runner :repeat :inner | runner new runIndividualStanford: DictionaryBenchmark repeat: repeat inner: inner].
	dict at: #dictatput		put: [ :runner :repeat :inner | runner new runIndividualStanford: DictionaryAtPutBenchmark repeat: repeat inner: inner].
	dict at: #livermore		put: [ :runner :repeat :inner | runner new runIndividualStanford: LivermoreBenchmark repeat: repeat inner: inner].

	"Individual Slopstone Benchmarks"
	dict at: #addint				put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 1 repeat: repeat inner: inner].
	dict at: #addfloat			put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 2 repeat: repeat inner: inner].
	dict at: #stringaccess	put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 3 repeat: repeat inner: inner].
	dict at: #createobject	put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 4 repeat: repeat inner: inner].
	dict at: #perform			put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 5 repeat: repeat inner: inner].
	dict at: #evaluate			put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 6 repeat: repeat inner: inner].
	
	"Individual Smopstone Benchmarks"
	dict at: #fractonacci	put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 1 repeat: repeat inner: inner].
	dict at: #primes   		put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 2 repeat: repeat inner: inner].
	dict at: #streams		put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 3 repeat: repeat inner: inner].
	dict at: #strings			put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 4 repeat: repeat inner: inner].
	dict at: #sets				put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 5 repeat: repeat inner: inner].
	dict at: #sorting 			put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 6 repeat: repeat inner: inner].
	dict at: #sorcerer		put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 7 repeat: repeat inner: inner].

	"Test Suites"
	dict at: #testsuite		put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new testBasicClasses] ].

	"Individual Tests"
	dict at: #string				put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: String title: 'String' ] ].
	dict at: #number			put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: Number title: 'Number' ] ].
	dict at: #sortedcol		put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: SortedCollection title: 'SortedCollection' ] ].
	dict at: #readstream	put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: SeqCltnReadStream title: 'SeqCltnReadStream' ] ].
	dict at: #writestream	put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: SeqCltnReadWriteStream title: 'SeqCltnReadWriteStream' ] ].
	dict at: #bag				put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: Bag title: 'Bag' ] ].
	dict at: #keyedset		put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: KeyedSet title: 'KeyedSet' ] ].
	dict at: #set					put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: Set title: 'Set' ] ].
	dict at: #orderedcol	put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: OrderedCollection title: 'OrderedCollection' ] ].
	dict at: #character		put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: Character title: 'Character' ] ].
	dict at: #readwrite		put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: ExternalReadWriteStream title: 'ExternalReadWriteStream' ] ].

	"Errors"
	dict at: #break				put: [ :runner :repeat :inner | {{primitiveBreak}} ].

	"Bootstrap"
	dict at: #boot				put: [ :runner :repeat :inner | Dumper fileOut ].

	"Test Suite for the VM people"
	dict at: #vmtest				put: [ :runner :repeat :inner | VMSuite run ].
	dict at: #vminterpreted	put: [ :runner :repeat :inner | VMSuite runInterpreted ].
	dict at: #vmcompiled	put: [ :runner :repeat :inner | VMSuite runCompiled ].
	dict at: #vmvanilla			put: [ :runner :repeat :inner | VMSuite runVanilla ].
	dict at: #dump					put: [  :runner :repeat :inner | InliningDatabase dump ].
	dict at: #compileAll		put: [  :runner :repeat :inner | InliningDatabase compileAll ].
	dict at: #gc						put: [  :runner :repeat :inner | VM collectGarbage ].
	dict at: #norecomp		put: [  :runner :repeat :inner | VM booleanAt: #UseRecompilation put: false ].

	"Misc."
	dict at: #zone					put: [ :runner :repeat :inner | {{primitivePrintZone}} ].
	dict at: #decode				put: [ :runner :repeat :inner | {{primitiveDecodeAllMethods}} ].
	dict at: #mandelbrot		put: [ :runner :repeat :inner | repeat timesRepeat: [ Mandelbrot new computeImageOnly ] ].
	dict at: #mandelprof		put: [ :runner :repeat :inner | Profiler do: [ Mandelbrot new computeImageOnly ] ].
	dict at: #mandeltest		put: [ :runner :repeat :inner | Mandelbrot new computeImageOnly ].
	dict at: #typecheck		put: [ :runner :repeat :inner | runner new runTypecheckerBenchmarks: repeat ].
	dict at: #genprims			put: [ :runner :repeat :inner | DeltaPrimitiveGenerator doit].

	^dict! !

"June 5, 2007 -> 22:7:53"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
findRunner: test ifAbsent: blk
	test = 'timer'
		ifTrue: [^BenchmarkRunner].
	test = 'nmethod'
		ifTrue: [^BenchmarkNMethodInvocationRunner].
	test = 'method'
		ifTrue: [^BenchmarkMethodInvocationRunner].
	test = 'prims'
		ifTrue: [^BenchmarkPrimitiveRunner].
	test = 'lookup'
		ifTrue: [^BenchmarkLookupCacheRunner].
	test = 'blocks'
		ifTrue: [^BenchmarkBlockRunner].
	blk value.! !

"June 5, 2007 -> 22:7:54"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
lower: str
	| result |
	result := String new: str size.
	1 to: str size do: [ :index |
		result at: index put: (str at: index) asLowercase
	].
	^result! !

"June 5, 2007 -> 22:7:55"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
parseInteger: str ifFail: blk
	| result |
	result := 0.
	str do: [ :c | | val |
		val := c asciiValue.
		(val >= $0 asciiValue and: [ val <= $9 asciiValue ])  ifTrue: [
			result := (result * 10) + ( val - $0 asciiValue)
		] ifFalse: [
			^blk value
		]
	].
	^result! !

"June 5, 2007 -> 22:7:56"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
processCommandLineArguments ^<Boolean>
	"process command line args, and return boolean indicating whether the 
		default program should be run (which is normally the GUI)"

	| args <ReadStream[Str]>  runDefault <Boolean> |
	args := Platform commandLineTokens.
	args next.  "Skip command"
	runDefault := true.
	
	[ args atEnd ] whileFalse: [  | arg <Str> |
		arg := args next.
		
		arg = '-benchmark'
			ifTrue: [	self runBenchmarks: args.
						runDefault := false ].
		arg = '-script'
			ifTrue: [	args atEnd
							ifTrue: [ Transcript show: 'Command line argument error: -script option must be followed by a filename';cr. ]
							ifFalse: [ self runScript: args next ].
						runDefault := false ].		].
	^runDefault
! !

"June 5, 2007 -> 22:7:57"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
runBenchmarks: args <InputStream[Str]>

	| dict runner repeat inner print |
	dict := self benchmarkDictionary.
	runner	:= BenchmarkRunner.
	repeat	:= 1.
	inner	:= 1.
	print		:= false.

	[ args atEnd ] whileFalse: [	| arg <Str> cmd options |
		arg := args next.
		options	:= false.
		arg = 'profile'	ifTrue: [ runner := BenchMarkProfileRunner.		options := true ].
		arg = 'prims'		ifTrue: [ runner := BenchmarkPrimTraceRunner.	options := true ].
		arg = 'inner'		ifTrue: [ inner := repeat. repeat := 1.						options := true ].
		arg = 'print'		ifTrue: [ print := true.												options := true ].
		options ifFalse: [
			repeat := self parseInteger: arg ifFail: [
				Transcript show: 'Processing '; show: arg; show: ' ('; show: repeat printString; show: ' times)'; cr.
				cmd := dict at: arg ifAbsent: [nil].
				cmd isNil ifTrue:  [ Transcript show: 'Command not found'; cr ]
							   ifFalse: [ cmd value: runner value: repeat value: inner ].
				repeat
			]
		]
	].

	print ifTrue: [
		{{primitivePrintMemory}}.
	]! !

"June 5, 2007 -> 22:7:58"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
runDefaultProgram
	"This starts the 'default' program, which is the code that should run when no
	  command line options specifies something else"
	  
	[ UI start ] fork! !

"June 5, 2007 -> 22:7:59"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
runScript: filename <Str>

	[	| file <FilePath> |
		file := FilePath for: filename.
		file exists
			ifFalse: [	Transcript show: 'Error: script file ''', filename, ''' not found.'; cr.
							^self	].
		file charInputStream fileIn
	] fork! !

"June 5, 2007 -> 22:8:0"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'library class initialization' !
run
	"This is the entry point for normal execution."
	
	| commands <OrdCltn[Str]> |

	self runBaseClassInitializers.
	self runNonCriticalClassInitializers.
	(self processCommandLineArguments)
		ifTrue: [ self runDefaultProgram ].
! !

"June 5, 2007 -> 22:8:1"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'library class initialization' !
runBaseClassInitializers
	"Initialize critical base library classes (run in the process scheduler)"

	Platform initialize.
	Transcript := TempTranscript new.
	SmallInteger initialize.
	Character initialize.
	CallBack initialize.
	IdleProcess initialize.
	InliningDatabase initialize.
! !

"June 5, 2007 -> 22:8:2"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'library class initialization' !
runNonCriticalClassInitializers
	"This is the root class initializer that is called when the system starts up.
		Any class initializers that must be called should be called from
		this method."

	Session initialize.

	Rectangle initialize.
	Paint initialize.
	Painter initialize.
	HPEN initialize.
	GeometricHPEN initialize.
	HBRUSH initialize.
	InfiniteRegion initialize.

	Smalltalk initialize.

	CodeEditor initialize.
	Workspace initialize.

	HTMLElement initialize.
	HTMLParser initialize.! !

"June 5, 2007 -> 22:9:22"!

"System saved" !
"June 6, 2007 -> 1:38:20"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"June 6, 2007 -> 1:38:22"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"June 6, 2007 -> 1:38:22"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"June 6, 2007 -> 1:38:22"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"June 6, 2007 -> 1:38:22"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"June 6, 2007 -> 1:38:22"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"June 6, 2007 -> 1:38:22"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"June 6, 2007 -> 1:38:22"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"June 6, 2007 -> 1:38:22"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"June 6, 2007 -> 1:38:22"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"June 6, 2007 -> 1:38:22"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"June 6, 2007 -> 1:38:23"!

(Delta mirrorFor: #Win32Platform)
comment: 
'The class side holds platform dependent constants and utilities.  Is also used
to get command line args, and other things like that.

Keywords: %machdep  %User

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.4 $
'!


"June 6, 2007 -> 1:38:23"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLInitialize
    DLLDict := Dictionary new.
    {{primitiveDLLSetupLookup: self selector: #DLLLookup:in: ifFail: [:err | self error: err]}}! !

"June 6, 2007 -> 1:38:24"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLLibrary: name
    ^DLLDict at: name ifAbsent: [
        DLLDict at: name put: (self DLLLoad: name)
    ]! !

"June 6, 2007 -> 1:38:25"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLLoad: name
    | r n |
    r := ExternalProxy new.
    n := (self DLLMapName: name) asSymbol.
    ^{{primitiveDLLLoad: n result: r ifFail: [ :err | self error: err]}}! !

"June 6, 2007 -> 1:38:26"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLLookup: name <Str> in: library <Str>
    "Convert library into proxy"
    | p r |
    p := self DLLLibrary: library.
    r := ExternalProxy new.
    {{primitiveDLLLookup: name asSymbol in: p result: r ifFail: [:err | self error: err]}}.
    ^r! !

"June 6, 2007 -> 1:38:27"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLMapName: name <Str> ^<Str>
    name = 'user'       ifTrue: [^'USER32.DLL'].
    name = 'gdi'            ifTrue: [^'GDI32.DLL'].
    name = 'kernel'     ifTrue: [^'KERNEL32.DLL'].
    name = 'comdlg'     ifTrue: [^'COMDLG32.DLL'].
    self error: 'Mapping ', name, ' not found'! !

"June 6, 2007 -> 1:38:28"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'clipboard access' !
clipboardText: str <Str>

    self openClipboard.
    [   | glob <HGLOBAL> strm <ReadWriteStream[Character]> xstr <Str> |
        self emptyClipboard.

        "transform string into a form with lfs inserted"
        strm := (String new: str size) readWriteStream.
        str do:
            [ :c <Character> |
                strm put: c.
                c = Character cr
                    ifTrue: [ strm put: Character lf ].
            ].
        xstr := String withAll: strm contentsWritten.

        glob := HGLOBAL new
                        allocate: xstr size + 1
                        attributes: (Win32 GMEM_MOVEABLE
                                            externalBitOr: Win32 GMEM_DDESHARE).
        glob withPointer: CString new
                do: [ :cs <CString> |
                            cs value: xstr   ].

        {{<user ExternalProxy SetClipboardData>
                format: Win32 CF_TEXT
                data: glob
        }} isNull
            ifTrue: [ Win32 handleError ].
    ] ensure:
        [ self closeClipboard ]! !

"June 6, 2007 -> 1:38:29"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'clipboard access' !
clipboardTextIfAbsent: blk <[^X def]> ^<Str | X>

    self openClipboard.
    [   | glob <HGLOBAL> strm <CharWriteStream> |

        {{<user ExternalProxy IsClipboardFormatAvailable> format: Win32 CF_TEXT}} asBoolean
            ifFalse: [ ^blk value ].
        glob := {{<user HGLOBAL GetClipboardData> format: Win32 CF_TEXT}}.
        glob isNull
            ifTrue: [ Win32 handleError ].
        strm := (String new: 100) writeStream.
        glob withPointer: CString new
                do: [ :cs <CString> |
                            cs asString do:
                                [ :c <Character> |
                                    c = Character lf
                                        ifFalse: [ strm put: c ]
                                ].
                            ^strm contentsWritten
                      ].
    ] ensure:
        [ self closeClipboard ]! !

"June 6, 2007 -> 1:38:30"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'command line' !
commandLine ^<Str>
    | p size result |
    p := {{<kernel ExternalProxy GetCommandLineA>getCommandLine}}.
    size := 0.
    [(p byteAt: size) == 0] whileFalse: [ size := size + 1 ].
    result := String new: size.
    1 to: size do: [:index |
       result at: index put: (Character value: (p byteAt: index - 1))
    ].
    ^result! !

"June 6, 2007 -> 1:38:31"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'command line' !
commandLineTokens ^<InputStream[Str]>
    "a stream of the input line tokens.  Tokens are sequences separated by whitespace; whitespace can be 
        included in a token by double quoting the arg.  (quotes can be imbedded by doubling, as with Smalltalk strings;
        the returned token has delimiting quotes removed and internal quotes undoubled. "

    | cstrm <CharInputStream> |
    cstrm := self commandLine readStream.
    self skipSpacesIn: cstrm.
    ^CustomInputStream[Str] new
            nextBlock: [    self parseArgFrom: cstrm ];
            atEndBlock: [ cstrm atEnd ].! !

"June 6, 2007 -> 1:38:32"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'constants' !
multipleMatchWildcardCharacter ^<Character>

    ^$*! !

"June 6, 2007 -> 1:38:33"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'constants' !
singleMatchWildcardCharacter ^<Character>

    ^$?! !

"June 6, 2007 -> 1:38:34"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'constants' !
wordSize ^<Int>
    ^4! !

"June 6, 2007 -> 1:38:35"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'environment' !
environmentVariableAt: key <Str> ifAbsent: blk <[^X def]> ^ <Str | X>

    | cKey <CString> cValue <CString> size <Int> cSize <ExternalProxy> result <Str> done <Boolean> found <Boolean> |
    size := 1024.
    cKey := CString for: key.
    done := false.
    [ done ] whileFalse: [
        cValue := CString for: (String new: size).
        cSize := {{<kernel ExternalProxy GetEnvironmentVariableA> key: cKey buffer: cValue bufSize: size}}.
        cSize asSmallInteger > size
            ifTrue: [   cValue free.                                                    "Buffer size too small for value of variable"
                            size := cSize asSmallInteger ]
            ifFalse: [  done := true.                                                   "Buffer size ok, check if variable was found"
                            (found := cSize asSmallInteger ~= 0)
                                ifTrue: [ result := cValue asString ] ] ].
    cKey free. 
    cValue free.
    ^found
        ifTrue: [ result ]
        ifFalse: blk ! !

"June 6, 2007 -> 1:38:36"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'initialization' !
initialize

    self DLLInitialize! !

"June 6, 2007 -> 1:38:37"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'os streams' !
errorStream ^<CharOutputStream>

    ErrorStream isNil
        ifTrue: [   ErrorStream := TempTranscript new ].
    ^ErrorStream! !

"June 6, 2007 -> 1:38:38"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'platform classes' !
pathClass ^<FilePath class>

    ^Win32FilePath! !

"June 6, 2007 -> 1:38:38"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'platform classes' !
patternClass ^<FilePattern class>

    ^Win32FilePattern! !

"June 6, 2007 -> 1:38:40"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'private' !
parseArgFrom: strm <CharInputStream>  ^<Str>
    "Parse an argument token from the strm.  Leading whitespace is assumed to have been removed already.
      Any whitespace following the token is consumed."

    | arg <Str> |
    (strm peekFor: $")
        ifTrue: [       | c <Character> buf <CharWriteStream> |
                        buf := String new writeStream.
                        [   c := strm next.
                            c ~= $" or: [ (strm peekIfAbsent: [ self skipSpacesIn: strm.  ^buf contentsWritten ]) = $" ]
                        ] whileTrue: 
                            [   c = $" ifTrue: [ strm next ].
                                buf put: c ].
                        arg := buf contentsWritten  ]
        ifFalse: [  arg := strm upTo: Character space ].
    self skipSpacesIn: strm.
    ^arg! !

"June 6, 2007 -> 1:38:41"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'private' !
skipSpacesIn: strm <CharInputStream>

    [ strm atEnd not and: [ strm peekFor: Character space] ] whileTrue.
! !

"June 6, 2007 -> 1:38:42"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'private-clipboard access' !
closeClipboard

    {{<user ExternalProxy CloseClipboard> call}}! !

"June 6, 2007 -> 1:38:42"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'private-clipboard access' !
emptyClipboard

    {{<user ExternalProxy EmptyClipboard> call}} asBoolean
        ifFalse: [ Win32 handleError ].
! !

"June 6, 2007 -> 1:38:43"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'private-clipboard access' !
openClipboard

    {{<user ExternalProxy OpenClipboard> hnd: Win32 NULL}} asBoolean
        ifFalse: [ Win32 handleError ].
! !

"June 6, 2007 -> 1:38:44"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'testing' !
usesCrLfConvention ^<Boolean>

    ^true! !

"June 6, 2007 -> 1:39:6"!

Delta define: #Launcher as: (
(Class subclassOf: 'ClassCritical |> Application' instanceVariables: 'menuBar <Menu>
sourceConsistencyHasBeenChecked <Boolean>
') classVariables: 'MenuRegistry <OrdCltn[LookupKey[Object,Menu]]>
Launchers <IdentitySet[Launcher]>
	"All unclosed instances of launcher, so that we
		can notify them when their menus change"') !


"June 6, 2007 -> 1:39:8"!

Delta define: #Launcher as: (
(Class subclassOf: 'ClassCritical |> Application' instanceVariables: 'menuBar <Menu>
sourceConsistencyHasBeenChecked <Boolean>
') classVariables: 'MenuRegistry <OrdCltn[LookupKey[Object,Menu]]>
Launchers <IdentitySet[Launcher]>
	"All unclosed instances of launcher, so that we
		can notify them when their menus change"') !


"June 6, 2007 -> 1:39:8"!

Delta define: #Launcher as: (
(Class subclassOf: 'ClassCritical |> Application' instanceVariables: 'menuBar <Menu>
sourceConsistencyHasBeenChecked <Boolean>
') classVariables: 'MenuRegistry <OrdCltn[LookupKey[Object,Menu]]>
Launchers <IdentitySet[Launcher]>
	"All unclosed instances of launcher, so that we
		can notify them when their menus change"') !


"June 6, 2007 -> 1:39:8"!

Delta define: #Launcher as: (
(Class subclassOf: 'ClassCritical |> Application' instanceVariables: 'menuBar <Menu>
sourceConsistencyHasBeenChecked <Boolean>
') classVariables: 'MenuRegistry <OrdCltn[LookupKey[Object,Menu]]>
Launchers <IdentitySet[Launcher]>
	"All unclosed instances of launcher, so that we
		can notify them when their menus change"') !


"June 6, 2007 -> 1:39:9"!

Delta define: #Launcher as: (
(Class subclassOf: 'ClassCritical |> Application' instanceVariables: 'menuBar <Menu>
sourceConsistencyHasBeenChecked <Boolean>
') classVariables: 'MenuRegistry <OrdCltn[LookupKey[Object,Menu]]>
Launchers <IdentitySet[Launcher]>
	"All unclosed instances of launcher, so that we
		can notify them when their menus change"') !


"June 6, 2007 -> 1:39:9"!

Delta define: #Launcher as: (
(Class subclassOf: 'ClassCritical |> Application' instanceVariables: 'menuBar <Menu>
sourceConsistencyHasBeenChecked <Boolean>
') classVariables: 'MenuRegistry <OrdCltn[LookupKey[Object,Menu]]>
Launchers <IdentitySet[Launcher]>
	"All unclosed instances of launcher, so that we
		can notify them when their menus change"') !


"June 6, 2007 -> 1:39:9"!

Delta define: #Launcher as: (
(Class subclassOf: 'ClassCritical |> Application' instanceVariables: 'menuBar <Menu>
sourceConsistencyHasBeenChecked <Boolean>
') classVariables: 'MenuRegistry <OrdCltn[LookupKey[Object,Menu]]>
Launchers <IdentitySet[Launcher]>
	"All unclosed instances of launcher, so that we
		can notify them when their menus change"') !


"June 6, 2007 -> 1:39:9"!

Delta define: #Launcher as: (
(Class subclassOf: 'ClassCritical |> Application' instanceVariables: 'menuBar <Menu>
sourceConsistencyHasBeenChecked <Boolean>
') classVariables: 'MenuRegistry <OrdCltn[LookupKey[Object,Menu]]>
Launchers <IdentitySet[Launcher]>
	"All unclosed instances of launcher, so that we
		can notify them when their menus change"') !


"June 6, 2007 -> 1:39:9"!

Delta define: #Launcher as: (
(Class subclassOf: 'ClassCritical |> Application' instanceVariables: 'menuBar <Menu>
sourceConsistencyHasBeenChecked <Boolean>
') classVariables: 'MenuRegistry <OrdCltn[LookupKey[Object,Menu]]>
Launchers <IdentitySet[Launcher]>
	"All unclosed instances of launcher, so that we
		can notify them when their menus change"') !


"June 6, 2007 -> 1:39:9"!

Delta define: #Launcher as: (
(Class subclassOf: 'ClassCritical |> Application' instanceVariables: 'menuBar <Menu>
sourceConsistencyHasBeenChecked <Boolean>
') classVariables: 'MenuRegistry <OrdCltn[LookupKey[Object,Menu]]>
Launchers <IdentitySet[Launcher]>
	"All unclosed instances of launcher, so that we
		can notify them when their menus change"') !


"June 6, 2007 -> 1:39:9"!

Delta define: #Launcher as: (
(Class subclassOf: 'ClassCritical |> Application' instanceVariables: 'menuBar <Menu>
sourceConsistencyHasBeenChecked <Boolean>
') classVariables: 'MenuRegistry <OrdCltn[LookupKey[Object,Menu]]>
Launchers <IdentitySet[Launcher]>
	"All unclosed instances of launcher, so that we
		can notify them when their menus change"') !


"June 6, 2007 -> 1:39:10"!

(Delta mirrorFor: #Launcher)
comment: 
'The launcher is the entry point application for the programming environment.
(c) 1996-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license. '!


"June 6, 2007 -> 1:39:11"!

! (Delta mirrorFor: #Launcher) classSide methodsFor: 'accessing' !
launchers ^<IdentitySet[Launcher]>
	"call only from a critical region"

	Launchers isNil
		ifTrue: [ Launchers := IdentitySet[Launcher] new ].
	^Launchers! !

"June 6, 2007 -> 1:39:12"!

! (Delta mirrorFor: #Launcher) classSide methodsFor: 'control' !
createUITranscript

	"Make sure the UI isn't already running"
	self assert: [ Transcript class ~~ Workspace ].
	
	Transcript := Workspace new.! !

"June 6, 2007 -> 1:39:14"!

! (Delta mirrorFor: #Launcher) classSide methodsFor: 'control' !
startProgEnv ^<Instance>

	| launcher <Instance> |
	self createUITranscript.
	
	"Register stophandler for process scheduler"
	Processor stopHandler: [ :p <Process> | (StackTraceInspector on: p) launch ].

	launcher := (self new) launch; yourself.

	"Don't launch start page if system is inconsistent so that it won't
		obscure the error messages in the transcript"
	SourceHandler systemIsConsistent
		ifTrue: [ [ launcher browseStartPage ] fork. ]. 

	^launcher
! !

"June 6, 2007 -> 1:39:14"!

! (Delta mirrorFor: #Launcher) classSide methodsFor: 'private' !
menuRegistry ^<OrdCltn[LookupKey[Object,Menu]]>
	"call only from a critical region"

	MenuRegistry isNil
		ifTrue: [ MenuRegistry := OrderedCollection[LookupKey[Object,Menu]] new ].
	^MenuRegistry! !

"June 6, 2007 -> 1:39:16"!

! (Delta mirrorFor: #Launcher) classSide methodsFor: 'private' !
mergedMenu ^<Menu>
	"Call only from critical region"

	| newMenu <Menu> |
	newMenu := Menu new.
	self menuRegistry do:
		[ :entry <LookupKey[Object,Menu]> |
			newMenu merge: entry value copy.	].
	^newMenu! !

"June 6, 2007 -> 1:39:16"!

! (Delta mirrorFor: #Launcher) classSide methodsFor: 'private' !
rebuildMenus
	"rebuild all the menus and notify the launchers.  Must
		be in a critical region on self"

	| newMenu <Menu> |
	newMenu := self mergedMenu.
	self launchers do:
		[ :l <Launcher> |
			l menuBar: newMenu copy	].! !

"June 6, 2007 -> 1:39:17"!

! (Delta mirrorFor: #Launcher) classSide methodsFor: 'private' !
registerLauncher: l <Launcher>

	self critical:
		[ self launchers include: l ]! !

"June 6, 2007 -> 1:39:18"!

! (Delta mirrorFor: #Launcher) classSide methodsFor: 'registering menus' !
registerMenu: m <Menu> for: owner <Object>
	"Merge m into the launcher menu.  It can be unregistered later.
		Any displayed launchers will update their menus dynamically."

	self critical:
		[	self menuRegistry addLast:
						(LookupKey[Object,Menu] key: owner value: m).
			self rebuildMenus	]! !

"June 6, 2007 -> 1:39:19"!

! (Delta mirrorFor: #Launcher) classSide methodsFor: 'registering menus' !
unregisterMenuFor: owner <Object>
	"Unmerge m from the launcher menu. "

	self critical:
		[	self menuRegistry remove: (LookupKey[Object,Menu] key: owner value: nil). "value doesn't matter"
			self rebuildMenus	]! !

"June 6, 2007 -> 1:39:20"!

! (Delta mirrorFor: #Launcher) methodsFor: 'accessing' !
docPath ^<FilePath>

	^FilePath currentDirectory, (FilePath for: 'documentation\index.html')! !

"June 6, 2007 -> 1:39:21"!

! (Delta mirrorFor: #Launcher) methodsFor: 'accessing' !
windowTitle ^ <Str>

	^'Strongtalk Launcher'! !

"June 6, 2007 -> 1:39:22"!

! (Delta mirrorFor: #Launcher) methodsFor: 'accessing' !
workspace ^<Workspace>

	^Workspace coerce: Transcript! !

"June 6, 2007 -> 1:39:23"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
browseStartPage

	self startPagePath exists
		ifFalse: [  self visual promptOk: 'Can''t open ',self startPagePath name
								title: 'Error'
								type: #exclamation
								action: [].
							^self
						].

	(HTMLView new model: (URL forFilePath: self startPagePath)) launch! !

"June 6, 2007 -> 1:39:24"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
findDefinition
	
	self 
		launchSingleLineTextDialogWithPainter: Painter default
		title: 'Open definition'
		caption: 'Matching expression' 
		default: '*'
		action: [ :s <Str> | self launchDefinitionsMatching: s ]
! !

"June 6, 2007 -> 1:39:25"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
findGlobalReferences

	self 
		launchSingleLineTextDialogWithPainter: Painter default
		title: 'Find references'
		caption: 'Name of global' 
		default: ''
		action: [ :s <Str> | self launchReferencesToGlobalName: s asSymbol ]
! !

"June 6, 2007 -> 1:39:26"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
findImplementors

	self 
		launchSingleLineTextDialogWithPainter: Painter default
		title: 'Find implementors'
		caption: 'Matching expression' 
		default: '*'
		action: [ :s <Str> | self launchImplementorsMatching: s ]

! !

"June 6, 2007 -> 1:39:27"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
findSenders

	self 
		launchSingleLineTextDialogWithPainter: Painter default
		title: 'Find senders'
		caption: 'Matching expression' 
		default: '*'
		action: [ :s <Str> | self launchSendersMatching: s ]
! !

"June 6, 2007 -> 1:39:28"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
launchDefinitionsMatching: s <Str>

	"THIS IS JUST A QUICK HACK!!!!!! REMOVE LATER!!!!!!"
	
	| definitions <AddableSequenceableCollection[Symbol]> mirror <Mirror> |
	definitions := OrderedCollection[Symbol] new.
	Smalltalk keysDo: [ :key <Symbol> | 
		(s platformMatch: key)
			ifTrue: [	definitions add: key ]
	].
	definitions isEmpty
		ifTrue: [	| pattern <Str> |
					pattern := s, Platform multipleMatchWildcardCharacter asString.
					Smalltalk keysDo: [ :key <Symbol> | 
						(pattern platformMatch: key)
							ifTrue: [	definitions add: key ]
					]
	].
	definitions := definitions asSortedCollection: [ :a <Symbol> :b <Symbol> | a <= b ].
	definitions isEmpty
		ifTrue: [		(Workspace coerce: Transcript) visual
								promptOk: 'No definitions matching ''', s, ''''
								title: 'Information'
								type: #info
								action: [] ].
	definitions size = 1
		ifTrue: [		mirror := Smalltalk mirrorFor: (definitions at: 1) ifAbsent: [ ^self ].
						(DefOutliner on: mirror) launch ]
		ifFalse: [	self 
								launchListDialogWithPainter: Painter default
								title: 'Definitions matching ', s
								modal: false
								contents: definitions
								multi: true
								action: [ :indices <Cltn[Int]> |
												indices do:
													[ :index <Int> |
														mirror := Smalltalk mirrorFor: (definitions at: index)
																			ifAbsent: [ ^self ].
														(DefOutliner on: mirror) launch 	]	].
							]! !

"June 6, 2007 -> 1:39:29"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
launchDoc

	(HTMLView new model: (URL forFilePath: self docPath)) launch! !

"June 6, 2007 -> 1:39:30"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
launchImplementorsMatching: s <Str>

	| implementors <SeqCltn[Tuple[Mirror, Symbol]]> |
	(implementors := Smalltalk implementorsMatching: s) isEmpty
		ifTrue: [		(Workspace coerce: Transcript) visual
								promptOk: 'No implementors matching ''', s, ''''
								title: 'Information'
								type: #info
								action: [] ]
		ifFalse: [	self 
								launchSelectorListWithPainter: Painter default 
								title: 'Implementors matching ''', s,	 '''' 
								contents: implementors ]
! !

"June 6, 2007 -> 1:39:31"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
launchListDialogWithPainter: p <Painter>
title: t <Str>
contents: strs <SeqCltn[Str]>
multi: b <Boolean>
action: blk <[Cltn[Int]]>

	self	launchListDialogWithPainter: p 
			title: t 
			modal: true
			contents: strs
			multi: b 
			action: blk 
! !

"June 6, 2007 -> 1:39:32"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
launchListDialogWithPainter: p <Painter>
title: t <Str>
modal: modal <Boolean>
contents: strs <SeqCltn[Str]>
multi: b <Boolean>
action: blk <[Cltn[Int]]>

	"THIS IS JUST A QUICK HACK!!!!!! REMOVE LATER!!!!!!"

		| listBox <ListBox> editor <TextView[Str]> glue <Visual> dialog <Window> |
	strs size > 0
		ifFalse: [ ^self ].
	listBox := b
		ifTrue: [	ListBox forMultipleSelections
						simpleMultiple: false ]
		ifFalse: [	ListBox forSingleSelection ].
	listBox
		stringList: strs;
		selections: #(1);
		onDoubleClick: [ :lb <ListBox> | dialog close. blk value: lb selections ].
	dialog := (Workspace coerce: Transcript) visual
		launchCustomDialog: t
		for: (listBox withBorder: (Border standard3DWithColor: Paint gray raised: false))
		showApply: true
		modal: modal
		toValidate: [ :continue <[]> | continue value ]
		action: [ blk value: listBox selections ].
! !

"June 6, 2007 -> 1:39:33"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
launchReferencesToGlobalName: name <Symbol>

	| refs <SeqCltn[Tuple[Mirror, Symbol]]> |
	(refs := Smalltalk referencesToGlobalName: name) isEmpty
		ifTrue: [		(Workspace coerce: Transcript) visual
								promptOk: 'No references to global ''', name, ''''
								title: 'Information'
								type: #info
								action: [] ]
		ifFalse: [	self 
								launchSelectorListWithPainter: Painter default 
								title: 'References to global ''', name,	 '''' 
								contents: refs ]
! !

"June 6, 2007 -> 1:39:35"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
launchSelectorListWithPainter: p <Painter> title: t <Str> contents: list <SeqCltn[Tuple[Mirror, Symbol]]>

	"THIS IS JUST A QUICK HACK!!!!!! REMOVE LATER!!!!!!"

	| listBox <ListBox> action <[ListBox]> win <Window> |
	list size > 0
		ifFalse: [ ^self ].
	list size = 1
		ifTrue: [	| mirror <Mirror> sel <Symbol> |
					mirror := (list at: 1) at1.
					sel := (list at: 1) at2.
					(DefWithMsgOutliner on: mirror instanceSide) launchOpenSide: mirror isMeta selector: sel.
					^self ].
	action := [ 	:lb <ListBox> |
						| index <Int> mirror <Mirror> sel <Symbol> |
						index := lb selections anElement.				"We use single selection"
						mirror := (list at: index) at1.
						sel := (list at: index) at2.
						(DefWithMsgOutliner on: mirror instanceSide) launchOpenSide: mirror isMeta selector: sel.
						].
	listBox := ListBox forSingleSelection.
	listBox
		stringList: (list collect: [ :t <Tuple[Mirror, Symbol]> | t at1 name, '>>', t at2 ]);
		selections: #(1);
		onDoubleClick: [ :lb <ListBox> | action value: lb ].
	win := (Workspace coerce: Transcript) visual
		launchCustomDialog: t
		for: (listBox withBorder: (Border standard3DWithColor: Paint gray raised: false))
		showApply: true
		modal: false
		toValidate: [ :continue <[]> | continue value ]
		action: [ 	action value: listBox ].
! !

"June 6, 2007 -> 1:39:36"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
launchSendersMatching: s <Str>

	| senders <SeqCltn[Tuple[Mirror, Symbol]]> |
	(senders := Smalltalk sendersMatching: s) isEmpty
		ifTrue: [		(Workspace coerce: Transcript) visual
								promptOk: 'No senders matching ''', s, ''''
								title: 'Information'
								type: #info
								action: [] ]
		ifFalse: [	self 
								launchSelectorListWithPainter: Painter default 
								title: 'Senders matching ''', s,	 '''' 
								contents: senders ]
! !

"June 6, 2007 -> 1:39:37"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
launchSingleLineTextDialogWithPainter: p <Painter> title: t <Str> caption: c <Str> default: d <Str> action: blk <[Str]>

	"THIS IS JUST A QUICK HACK!!!!!! REMOVE LATER!!!!!!"

	| caption <Visual> editor <TextView[Str]> glue <Visual> |
	caption := (StringGlyph for: c painter: p) asVisual.
	glue := Glue xRigid: 10.
	editor := CommonProgEnvOutliner new buildSingleLineTextViewWithPainter: p getModel: [ d ] setModelOnSuccess: [ :blk <[]> | blk value ].
	editor desiredColumns: (c size max: d size).
	(Workspace coerce: Transcript) visual
		launchCustomDialog: t
		for: (Row[Visual] holding: (OrderedCollection[Visual] with: caption with: glue with: (CommonProgEnvOutliner new editorBorderFor: editor)))
		showApply: false
		modal: true
		toValidate: [ :continue <[]> | continue value ]
		action: [ blk value: editor model ].
! !

"June 6, 2007 -> 1:39:38"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
openClassHierarchyOutliner

	(ClassHierarchyOutliner for: (ClassMirror on: Object))
		launch.! !

"June 6, 2007 -> 1:39:39"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
openGlobalVariableListOutliner

	GlobalVariableListOutliner forWorld launch! !

"June 6, 2007 -> 1:39:40"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
openMixinListOutliner

	MixinListOutliner forWorld launch! !

"June 6, 2007 -> 1:39:41"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
openProtocolListOutliner

	ProtocolListOutliner forWorld launch! !

"June 6, 2007 -> 1:39:41"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
openTypeAliasListOutliner

	TypeAliasListOutliner forWorld launch! !

"June 6, 2007 -> 1:39:42"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
openUserClassHierarchyOutliner

	(ClassHierarchyOutliner for: (ClassMirror on: Object))
		filterOnUserClasses
		launch.! !

"June 6, 2007 -> 1:39:43"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
showUnsavedChanges
	"Launch a read-only text view on the unsaved changes that have been made
	 during this session"

	SourceHandler unsavedChangesHaveBeenMade
		ifTrue: [	| tv <TextView[InputStream[Character]]> |
					tv := TextView[InputStream[Character]]  forCharStream.
					tv scrollable: true.
					tv model: (SourceHandler currentUnsavedChanges);
						doneBlock:
							[ :saveFlag <Boolean> :action <[]> |
								self visual
									promptOk: 'You can''t change the changes here!!'
									title: 'Error'
									type: #stop
									action: [  ]	 ].
					(tv bareVisualTop: false) launchWithTitle: 'Unsaved Changes'.		]
		ifFalse: [ self visual
						promptOk: 'There are no unsaved changes.'
						title: 'System Change Status'
						type: #info
						action: [ ]		]! !

"June 6, 2007 -> 1:39:44"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
startPagePath ^<FilePath>

	^FilePath currentDirectory, (FilePath for: 'startPage.html')! !

"June 6, 2007 -> 1:39:45"!

! (Delta mirrorFor: #Launcher) methodsFor: 'control' !
closeRequest: toClose <[]>

	SourceHandler unsavedChangesHaveBeenMade
		ifTrue: [ self promptForSave: toClose ]
		ifFalse: [ self promptForQuit: toClose ]! !

"June 6, 2007 -> 1:39:46"!

! (Delta mirrorFor: #Launcher) methodsFor: 'control' !
recompileWorld

	(Workspace coerce: Transcript) visual
		promptOkCancel: 'Recompile all methods in the system?'
		title: 'Please confirm'
		type: #question
		default: 2
		action: [ : b <Boolean> | b ifTrue: [ [ Smalltalk recompileAllMethods ] fork ] ]! !

"June 6, 2007 -> 1:39:47"!

! (Delta mirrorFor: #Launcher) methodsFor: 'control' !
saveSystem

	self visual promptOkCancel: 'Save System?'
				title: 'Save System'
				type: #exclamation
				default: 1
				action: [ :ok <Boolean> |
								ok ifTrue: [	Dumper saveSystem.
														self visual
																promptOk: 'System Saved.'
																title: 'Save System'
																type: #info
																action: [ ]
													]
							]
! !

"June 6, 2007 -> 1:39:49"!

! (Delta mirrorFor: #Launcher) methodsFor: 'control' !
typecheckWorld
 
	| vis <Visual> |
	vis := 	(Workspace coerce: Transcript) visual.
	vis	promptYesNo: 'Do you really want to typecheck all the source code in the system?'
		title: 'Typecheck world'
		type: #question
		default: 2
		action:	[: b <Boolean> |
							b ifTrue: [ Smalltalk typecheckWorld ].
						]
! !

"June 6, 2007 -> 1:39:50"!

! (Delta mirrorFor: #Launcher) methodsFor: 'control-private' !
doClose: toClose <[]>

	toClose value.
	VM quit.! !

"June 6, 2007 -> 1:39:51"!

! (Delta mirrorFor: #Launcher) methodsFor: 'control-private' !
promptForQuit: toClose <[]>

	self visual
				promptYesNo: 'Are you sure you want to quit?'
				title: 'Quit'
				type: #exclamation
				default: 2
				action: [ :ok <Boolean> |
								ok = true
									ifTrue: [ self doClose: toClose ]
								]! !

"June 6, 2007 -> 1:39:52"!

! (Delta mirrorFor: #Launcher) methodsFor: 'control-private' !
promptForSave: toClose <[]>

	self visual
				promptYesNoCancel: 'The system has been changed.  Save system before exiting? (''No'' will erase any changes and add them to the restore log)'
				title: 'Quit'
				type: #exclamation
				default: 3
				action: [ :ok <Boolean | Nil> |
								ok = nil
									ifFalse: [	ok
														ifTrue: [ Dumper saveSystem ]
														ifFalse: [ SourceHandler checkSystemConsistency at1
																		ifTrue: [ SourceHandler restoreBackup ]. ].
													self doClose: toClose		]
								]! !

"June 6, 2007 -> 1:39:53"!

! (Delta mirrorFor: #Launcher) methodsFor: 'filing in/out' !
fileIn

	(Workspace coerce: Transcript) visual
		userPickOpenFileWithAction: [ :file< FilePath> :readOnly <Boolean> | [ Smalltalk fileInFromFile: file ] fork ]
		fileTypes: (Array[Tuple[Str,Str]] with: 'Delta files (*.dlt)' ,, '*.dlt' with: 'All files (*.*)' ,, '*.*')
		defaultFile: nil
		defaultDir: nil
		title: 'Install file-in into image'
		allowReadOnly: false
		mustExist: true
! !

"June 6, 2007 -> 1:39:54"!

! (Delta mirrorFor: #Launcher) methodsFor: 'filing in/out' !
fileOutWorld

	(Workspace coerce: Transcript) visual
		userPickSaveFileWithAction: [ :file< FilePath> | [ Smalltalk fileOutWorldToFile: file ] fork ]
		fileTypes: (Array[Tuple[Str,Str]] with: 'Group files (*.gr)' ,, '*.gr' with: 'All files (*.*)' ,, '*.*')
		defaultFile: (FilePath for: 'world.gr')
		defaultDir: nil
		title: 'File out world and corresponding world group file'
! !

"June 6, 2007 -> 1:39:55"!

! (Delta mirrorFor: #Launcher) methodsFor: 'menus' !
docMenu ^<Menu>

	^Menu new name: '&Documentation';
				add: (MenuAction new
							name: '&Browse';
							action: [ self launchDoc ])! !

"June 6, 2007 -> 1:39:56"!

! (Delta mirrorFor: #Launcher) methodsFor: 'menus' !
fileMenu ^<Menu>

	^Menu new name: '&File';
		add: (MenuAction new
					name: '&Save System';
					action: [ self saveSystem ] );
		addSeparator;
		add: (MenuAction new
					name: 'File &in...';
					action: [ self fileIn ] );
		add: (MenuAction new
					name: 'File &out world...';
					action: [ self fileOutWorld ] );
		add: (MenuAction new
					name: '&Recompile world...';
					action: [ self recompileWorld ] );
		add: (MenuAction new
					name: 'Typecheck world...';
					action: [ self typecheckWorld ] );
		 addSeparator;
		 add: (MenuAction new
		            name:'Meta';
		            action:[Inspector launchOn: self]);
		addSeparator;
		add: (MenuAction new
					name: 'E&xit';
					action: [ self closeRequest: []  ] )! !

"June 6, 2007 -> 1:39:57"!

! (Delta mirrorFor: #Launcher) methodsFor: 'menus' !
hasMenu ^<Boolean>

	^true! !

"June 6, 2007 -> 1:39:58"!

! (Delta mirrorFor: #Launcher) methodsFor: 'menus' !
menuBar ^<Menu>

	menuBar isNil
		ifTrue: [ menuBar := Menu new 
															add: self fileMenu;
															add: self browsingMenu;
															merge: self class mergedMenu;
															add: self docMenu
					 ].
	^menuBar! !

"June 6, 2007 -> 1:39:59"!

! (Delta mirrorFor: #Launcher) methodsFor: 'menus to move elsewhere' !
browsingMenu ^<Menu>

	^Menu new name: '&Browse';
			add: (MenuAction new
					name: 'My &Start Page';
					action: [ self browseStartPage ] );
			addSeparator;
			add: (MenuAction new
					name: '&Definition...';
					action: [ self findDefinition] );
			add: (MenuAction new
					name: '&User Classes (i.e. classes useful to users)';
					action: [ self openUserClassHierarchyOutliner ] );
			add: (MenuAction new
					name: 'All &Classes';
					action: [ self openClassHierarchyOutliner ] );
			add: (MenuAction new
					name: '&Mixins';
					action: [ self openMixinListOutliner ] );
			add: (MenuAction new
					name: '&Protocols';
					action: [ self openProtocolListOutliner ] );
			add: (MenuAction new
					name: '&Type Aliases';
					action: [ self openTypeAliasListOutliner ] );
			add: (MenuAction new
					name: '&Global Variables';
					action: [ self openGlobalVariableListOutliner ] );
			addSeparator;
			add: (MenuAction new
					name: 'Message Implementors ...';
					action: [ self findImplementors ] );
			add: (MenuAction new
					name: 'Message Senders ...';
					action: [ self findSenders ] );
			add: (MenuAction new
					name: 'Global References ...';
					action: [ self findGlobalReferences ] );
			addSeparator;
			add: (MenuAction new
					name: 'Unsaved Changes From This Session';
					active: [ SourceHandler unsavedChangesHaveBeenMade ];
					action: [ self showUnsavedChanges ] );
			add: (MenuAction new
					name: 'Restore Log';
					active: [ (FilePath forElements: #('source' 'strongtalkrestore.log')) exists ];
					action: [ (CodeEditor on: (FilePath forElements: #('source' 'strongtalkrestore.log'))) launch ] );
			add: (MenuAction new
					name: 'Save Log';
					active: [ (FilePath forElements: #('source' 'strongtalkSave.log')) exists ];
					action: [ (CodeEditor on: (FilePath forElements: #('source' 'strongtalkSave.log'))) launch ] )
! !

"June 6, 2007 -> 1:40:0"!

! (Delta mirrorFor: #Launcher) methodsFor: 'notification' !
visualAllocated

	sourceConsistencyHasBeenChecked
		ifFalse: [	sourceConsistencyHasBeenChecked := true.
						"This is a gross %hack to make sure that the launcher
							window has appeared by the time we try to print
							any warning messages.  This is because I'm using
							fancy doitButtons in the warning message, and there
							is some kind of timing problem that hangs the system
							if the message arrives too soon, and I don't have time
							to find it."
						[	(Delay forMilliseconds: 250) wait.
							SourceHandler checkSystemConsistencyAndPrintMessagesIfNeeded.
							] fork.	].
! !

"June 6, 2007 -> 1:40:1"!

! (Delta mirrorFor: #Launcher) methodsFor: 'private' !
buildBareVisualTop: top <Boolean> ^ <Visual>

	^ApplicationInterceptor
			for: self workspace imbeddedVisual with3DBorder
			application: self! !

"June 6, 2007 -> 1:40:2"!

! (Delta mirrorFor: #Launcher) methodsFor: 'private-initialization' !
initialize

	super initialize.
	self actualClass registerLauncher: self.
	sourceConsistencyHasBeenChecked := false.
! !

"June 6, 2007 -> 1:40:3"!

! (Delta mirrorFor: #Launcher) methodsFor: 'restricted' !
menuBar: m <Menu>
	"Set or change the merged application menu.  We don't actually
		store this menu, since we have to change the window's menu
		in place; we simply replace all of the current menus elements
		with m's"

	self inSessionProcessDo: [ self menuBar 
																	removeAll;
																	add: self fileMenu;
																	add: self browsingMenu;
																	merge: m
														].! !

"June 6, 2007 -> 1:40:4"!

! (Delta mirrorFor: #Launcher) methodsFor: 'toolbar' !
hasToolBar ^<Boolean>

	^true! !

"June 6, 2007 -> 1:40:5"!

! (Delta mirrorFor: #Launcher) methodsFor: 'toolbar' !
toolBar ^<ToolBar>

	^ToolBar new
			addButtonWithImageFrom: 'resources/smallHome.bmp'
					action: [ :b <Button> |	self browseStartPage ];
			addSpace;
			addButtonWithImageFrom: 'resources/open.bmp'
					action: [ :b <Button> |	self findDefinition ];
			addButtonWithImageFrom: 'resources/implementors.bmp'
					action: [ :b <Button> |	self findImplementors ];
			addButtonWithImageFrom: 'resources/senders.bmp'
					action: [ :b <Button> |	self findSenders ];
			addSpace;
			addButtonWithImageFrom: 'resources/userHierarchy.bmp'
					action: [ :b <Button> |	self openUserClassHierarchyOutliner ];
			addButtonWithImageFrom: 'resources/hierarchy.bmp'
					action: [ :b <Button> |	self openClassHierarchyOutliner ];
			addButtonWithImageFrom: 'resources/blankSheet.bmp'
					action: [ :b <Button> |	Workspace new launch ];
			addSpace;
			addButtonWithImageFrom: 'resources/texteditor.bmp'
					action: [ :b <Button> |	CodeEditor new launch ];
			addButtonWithImageFrom: 'resources/documentation.bmp'
					action: [ :b <Button> |	self launchDoc ];
			yourself! !

"June 6, 2007 -> 1:44:24"!

Delta define: #SourceHandler as: (
(Class subclassOf: 'NotifyingObject mixin |> Object' instanceVariables: 'mirror dualHandler indexFile indexDict isNewIndex ') classVariables: 'ActiveHandlers ChangeLog <CharWriteStream> RawChangeLog <ExternalReadWriteStream> SourceDirectory InitialChangeLogSize <Int>') !


"June 6, 2007 -> 1:44:25"!

Delta define: #SourceHandler as: (
(Class subclassOf: 'NotifyingObject mixin |> Object' instanceVariables: 'mirror dualHandler indexFile indexDict isNewIndex ') classVariables: 'ActiveHandlers ChangeLog <CharWriteStream> RawChangeLog <ExternalReadWriteStream> SourceDirectory InitialChangeLogSize <Int>') !


"June 6, 2007 -> 1:44:26"!

Delta define: #SourceHandler as: (
(Class subclassOf: 'NotifyingObject mixin |> Object' instanceVariables: 'mirror dualHandler indexFile indexDict isNewIndex ') classVariables: 'ActiveHandlers ChangeLog <CharWriteStream> RawChangeLog <ExternalReadWriteStream> SourceDirectory InitialChangeLogSize <Int>') !


"June 6, 2007 -> 1:44:26"!

Delta define: #SourceHandler as: (
(Class subclassOf: 'NotifyingObject mixin |> Object' instanceVariables: 'mirror dualHandler indexFile indexDict isNewIndex ') classVariables: 'ActiveHandlers ChangeLog <CharWriteStream> RawChangeLog <ExternalReadWriteStream> SourceDirectory InitialChangeLogSize <Int>') !


"June 6, 2007 -> 1:44:26"!

Delta define: #SourceHandler as: (
(Class subclassOf: 'NotifyingObject mixin |> Object' instanceVariables: 'mirror dualHandler indexFile indexDict isNewIndex ') classVariables: 'ActiveHandlers ChangeLog <CharWriteStream> RawChangeLog <ExternalReadWriteStream> SourceDirectory InitialChangeLogSize <Int>') !


"June 6, 2007 -> 1:44:26"!

Delta define: #SourceHandler as: (
(Class subclassOf: 'NotifyingObject mixin |> Object' instanceVariables: 'mirror dualHandler indexFile indexDict isNewIndex ') classVariables: 'ActiveHandlers ChangeLog <CharWriteStream> RawChangeLog <ExternalReadWriteStream> SourceDirectory InitialChangeLogSize <Int>') !


"June 6, 2007 -> 1:44:26"!

Delta define: #SourceHandler as: (
(Class subclassOf: 'NotifyingObject mixin |> Object' instanceVariables: 'mirror dualHandler indexFile indexDict isNewIndex ') classVariables: 'ActiveHandlers ChangeLog <CharWriteStream> RawChangeLog <ExternalReadWriteStream> SourceDirectory InitialChangeLogSize <Int>') !


"June 6, 2007 -> 1:44:26"!

Delta define: #SourceHandler as: (
(Class subclassOf: 'NotifyingObject mixin |> Object' instanceVariables: 'mirror dualHandler indexFile indexDict isNewIndex ') classVariables: 'ActiveHandlers ChangeLog <CharWriteStream> RawChangeLog <ExternalReadWriteStream> SourceDirectory InitialChangeLogSize <Int>') !


"June 6, 2007 -> 1:44:27"!

Delta define: #SourceHandler as: (
(Class subclassOf: 'NotifyingObject mixin |> Object' instanceVariables: 'mirror dualHandler indexFile indexDict isNewIndex ') classVariables: 'ActiveHandlers ChangeLog <CharWriteStream> RawChangeLog <ExternalReadWriteStream> SourceDirectory InitialChangeLogSize <Int>') !


"June 6, 2007 -> 1:44:27"!

Delta define: #SourceHandler as: (
(Class subclassOf: 'NotifyingObject mixin |> Object' instanceVariables: 'mirror dualHandler indexFile indexDict isNewIndex ') classVariables: 'ActiveHandlers ChangeLog <CharWriteStream> RawChangeLog <ExternalReadWriteStream> SourceDirectory InitialChangeLogSize <Int>') !


"June 6, 2007 -> 1:44:27"!

Delta define: #SourceHandler as: (
(Class subclassOf: 'NotifyingObject mixin |> Object' instanceVariables: 'mirror dualHandler indexFile indexDict isNewIndex ') classVariables: 'ActiveHandlers ChangeLog <CharWriteStream> RawChangeLog <ExternalReadWriteStream> SourceDirectory InitialChangeLogSize <Int>') !


"June 6, 2007 -> 1:44:28"!

(Delta mirrorFor: #SourceHandler)
comment: 
'This class manages the source code database. 
Subclasses are specialized for specific source constructs.
An instance of such a subclass manages the source code for a particular definition. For example,
a MixinSourceHandler handles source code for a partiular mixin.

The database usually resides in the subdirectory ''source'' of the strongtalk directory. If you wish to have
it elsewhere, set the environment variable StrongtalkSourceDir.

The database contains an identification file, strongtalksource.id. This file consists of two "chunks"
in file in format. The first chunk is a path, that specifies what binary the source database is
associated with. The second chunk is the size of the file strongtalkchange.log, which contains the
entire source code history of the system from last creation.

The source DB also includes files for every class and metaclass in the system. If the class is named X, then its
instance side is represented in the file X in the source directory, and its class side is represented in the file X.class.

Whenever a change is made to the
source code, several things happen:

0. The binary representation IN MEMORY is modified to match the changed source.
1. If this is a new definition X, then a file X.new is created in the source directory.
2. Otherwise, if this is the first change to this definition  in the current session, then:
a. The original source file for the definition X being modified is backed up as X.bak.
b.  The original source code, in file in format, is appended to the restore log, strongtalkrestore.log.
3. The source file for X is modified accordingly.
4. The change is appended to the change log, strongtalkchange.log.

When the system is saved, the binary on disk is rewritten to reflect the memory image of the program.
All the .bak files are removed, and all the .new files have their .new suffix removed, making the new source 
permanent. In addition, a save comment is written to the change log, and the restore log is deleted. 
Finally, the id file is regenerated: it will now contain the path
of the binary that was used in this session, and the size of the change log just after the save.

Using this information, the system can detect if the change log size is greater than the size listed in the id file. This 
indicates unsaved source changes. The system then generates a warning that the source DB is inconsistent with 
the binary. The user is then asked to resync the two. This is accomplished by :

a. Rolling back the change log to the index
indicated by the id file.  
b. For all files X.bak, remove the file X and then rename X.bak to X.
c. Remove all .new files.

Any lost changes can be filed in from the restore log.

Other than the logs and id file, the source DB consists of files representing the code in individual classes and
metaclasses. These rely heavily on indices into the change log, and are known as index files. Every instance
of a source handler has its own index file. The index files are represented in file in format, using chunks.

For every construct, the appropriate source handler defines a series of attributes. The index file then encodes
these attributes. Some attributes are listed directly in the index file, while others point at an index in the change
log. As a rule, if an attribute needs to be available quickly, it is encoded directly into the index file. For example,
category names and type signatures are needed by browsers that have to display this information, even if
no method bodies are being viewed. Type information is also needed by the type checker. Therefore, this
data is directly available in the index file. On the other hand, method bodies are only needed when a browser
opens a view on a method. In that case, we can afford to look it up in the change log, so the index file contains
only a number, which is a character offser into the change log where the method body can be found.

 (c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"June 6, 2007 -> 1:44:30"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
activeHandlers ^ <IdentityDictionary>

	"Contains all currently active source handlers. These are canonicalized.
	The implementation should be changed to use a weak dictionary so that unused
	source handlers can be garbage collected."

	ActiveHandlers isNil
		ifTrue: [	ActiveHandlers := IdentityDictionary[Object, SourceHandler] new ].
	^ActiveHandlers
! !

"June 6, 2007 -> 1:44:31"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
addSectionToChangeLog: blk <[WriteStream,^Int]> ^ <Int>

	| pos <Int> |
	self changeLog
		setToEnd;
		cr;
		nextPut: $";
		nextPutAll: Date dateAndTimeNow printString;
		nextPut: $";
		nextPut: $!!;        
		cr; cr.
	pos := blk value: self changeLog.
	self changeLog flush.
	^pos
! !

"June 6, 2007 -> 1:44:32"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
changeLog ^ <CharWriteStream>

	ChangeLog isNil ifTrue: [
		RawChangeLog := self changeLogFile readWriteStream.
		InitialChangeLogSize isNil
			ifTrue: [ InitialChangeLogSize := RawChangeLog size ].
		ChangeLog := BootStrapping
							ifTrue: [		CharacterInputOutputConverter on: RawChangeLog ]
							ifFalse: [ 	self changeLogFile writeStream ] ].
	^ChangeLog
! !

"June 6, 2007 -> 1:44:33"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
changeLogFile ^ <FilePath>

	^BootStrapping
		ifTrue: [ 	self sourceDirectory, (FilePath for: self changeLogFileName) ]
		ifFalse: [ 	File open: self changeLogFileName in: self sourceDirectory ]! !

"June 6, 2007 -> 1:44:34"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
changeLogFileName ^ <Str>

    ^'strongtalkchange.log'! !

"June 6, 2007 -> 1:44:35"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
checkSystemConsistency ^<Tuple[Boolean,Boolean]>
	"Check  source database consistency, and move any orphaned code to the
	  restore log, but otherwise do not restore the db to a consistent state.  A pair of booleans
	  is returned. The first indicates whether a restore is needed, and the second
	  indicates whether there was orphaned code (and thus that a the restore option
	  message should be printed."

	| 	shouldRestore <Boolean>
		hadOrphanedCode <Boolean>
		oldID <Str> 
		newID <Str> 
		oldLogSize <Int> 
		idStream <CharInputStream>
		restoreStream <CharInputStream> |

	self identificationFile exists ifTrue: [
		BootStrapping
			ifTrue: [	idStream := self identificationFile charInputStream.
							newID := Platform commandLineTokens next ]
			ifFalse: [	idStream := self identificationFile readStream.
							newID := SessionModel current commandLineTokens next ].
		[	
			oldID := idStream nextChunk.
			oldLogSize := Integer readFrom: idStream.
		] ensure: [
			idStream close
		].
		"		newID = oldID
			ifFalse: [	self printImageChangeWarningFrom: oldID to: newID ]"
			"The intent is that when the system is run, it checks to see if the current binary is the same 
			as the one listed in the source identification file and issues a warning if this is not the case. 
			This provides a crude consistency check.  However, it may issue false warnings,if the entire 
			strongtalk directory is moved to a new location. It even gets  confused if the system is run from the 
			command line or from the windows GUI, because the pathnames are not literally identical."

			"12/6/01: commented out code above; otherwise everyone downloading the system will get
			an annoying message they will not readily understand. If you've downloaded this
			code, feel free to uncomment this part."
			 ].

	shouldRestore := false.
	hadOrphanedCode := false.
	
	BootStrapping
		ifTrue: [
			(self sourceDirectory, (FilePattern for: '*.new')) pathsDo: [ :file <FilePath> |
				shouldRestore := true ].
			(self sourceDirectory, (FilePattern for: '*.bak')) pathsDo: [ :file <FilePath> |
				shouldRestore := true ] ]
		ifFalse: [
			self sourceDirectory fileNamesDo: [ :filename <Str> |
				('*.bak' match: filename) 
					ifTrue: [ shouldRestore := true ].
				('*.new' match: filename) 
					ifTrue: [ shouldRestore := true ] ] ].

	shouldRestore
		ifTrue: [	 oldLogSize notNil 
							ifTrue: [	self changeLog setToEnd.
											(oldLogSize > 0 and: [ oldLogSize < self changeLog position ]) 
												ifTrue: [	self changeLog position: oldLogSize.
																restoreStream := BootStrapping
																	ifTrue: [ 	self restoreFile charOutputStream ]
																	ifFalse: [	self restoreFile writeStream ].
																[
																	[ self changeLog atEnd ]
																		whileFalse: [	restoreStream nextPut: self changeLog next ]
																] ensure: [
																	restoreStream close
																].
																hadOrphanedCode := true. ] ] ].
	^shouldRestore,, hadOrphanedCode! !

"June 6, 2007 -> 1:44:36"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
checkSystemConsistencyAndPrintMessagesIfNeeded

	| status <Tuple[Boolean,Boolean]> |
	status := self checkSystemConsistency.
	status at1
		ifTrue: [ self printRestoreWarning ].
	status at2
		ifTrue: [ self printRestoreOption ].! !

"June 6, 2007 -> 1:44:37"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
currentChangeLogSize ^<Int>

	^self rawChangeLog size! !

"June 6, 2007 -> 1:44:38"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
currentUnsavedChanges ^<CharInputStream>
	"Return a stream over the unsaved changes that have been made, in fileout format.  This is
	 a snapshot as of when this method is called and won't reflect future changes"

	| strm <CharInputStream> logPos <Int> |
	self changeLog flush.
	logPos := self changeLog position.  "remember starting position"

	self changeLog position: self initialChangeLogSize.
	strm := self changeLog contentsRemaining readStream.
	
	"restore change log position"
	self changeLog position: logPos.
	^strm! !

"June 6, 2007 -> 1:44:39"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
dualHandlerFor: h <Instance> ^ <Instance> 

	^h isMeta
		ifTrue: [ self for: h instanceSide ]
		ifFalse: [ self for: h classSide ]
! !

"June 6, 2007 -> 1:44:40"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
errorStreams ^ <Cltn[CharOutputStream]>

	^BootStrapping
		ifTrue: [	Array[CharOutputStream] with: Transcript with: Platform errorStream ]
		ifFalse: [	Array[CharOutputStream] with: Transcript ]
! !

"June 6, 2007 -> 1:44:41"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
flush

	ChangeLog notNil
		ifTrue: [	ChangeLog close.
						ChangeLog := nil ].
	SourceDirectory := nil.
	self activeHandlers do: 
		[ :h <SourceHandler> | h flush ].

! !

"June 6, 2007 -> 1:44:42"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
for: m <Mirror> ^ <Instance> 

	| newHandler <Instance> |
	^self activeHandlers at: m reflectee ifAbsent: [ 
		newHandler := self new mirror: m.
		self activeHandlers at: m reflectee put: newHandler.
		newHandler ].
! !

"June 6, 2007 -> 1:44:43"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
identificationFile ^ <FilePath>

	^BootStrapping
		ifTrue: [ 	self sourceDirectory, (FilePath for: self identificationFileName) ]
		ifFalse: [ 	self sourceDirectory fileNamed: self identificationFileName ]! !

"June 6, 2007 -> 1:44:43"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
identificationFileName ^ <Str>

	^'strongtalksource.id'! !

"June 6, 2007 -> 1:44:44"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
initialChangeLogSize ^<Int>

	^InitialChangeLogSize! !

"June 6, 2007 -> 1:44:45"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
printImageChangeWarningFrom: old <Str> to: new <Str>

	self errorStreams do: [ :stream <CharOutputStream> |
		stream
			cr;
			show: 'WARNING !!!!!! WARNING !!!!!! WARNING !!!!!!'; cr; cr;
			show: 'The source database was last used from '; cr;
			show: '  ', old; cr;
			show: 'and is now being used from '; cr;
			show: '  ', new; cr ]! !

"June 6, 2007 -> 1:44:46"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
printRestoreOption

	self errorStreams do: [ :stream <CharOutputStream> |
		stream
			cr;
			show: 'Changes made since the last save can be found by executing'; cr;
			tab; showDoIt: '"Edit Restore File"                (CodeEditor on: (FilePath for: ''', 
										self restoreFile name,
										''')) launch'; show: '.'; cr.
			 ]! !

"June 6, 2007 -> 1:44:47"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
printRestoreWarning

	self errorStreams do: [ :stream <CharOutputStream> |
		stream
			cr;
			show: 'WARNING !!!!!! WARNING !!!!!! WARNING !!!!!!'; cr; cr;
			show: 'The source database is in an inconsistent state. This can'; cr;
			show: 'be caused by exiting without saving changes. Please execute '; cr;
			tab; showDoIt: 'SourceHandler restoreBackup'; cr;
			show: 'to restore the source database to the state when it was'; cr;
			show: 'last saved.'; cr ]
! !

"June 6, 2007 -> 1:44:48"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
rawChangeLog ^ <ExternalReadWriteStream>

	RawChangeLog isNil
		ifTrue: [	self changeLog ].
	^RawChangeLog! !

"June 6, 2007 -> 1:44:50"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
restoreBackup

	| newName <Str> newFile <FilePath> |
	self flush.
	BootStrapping
		ifFalse: [
			self sourceDirectory fileNamesDo: [ :filename <Str> |
				('*.new' match: filename) 
					ifTrue: [ (self sourceDirectory fileNamed: filename) remove ] ].
			self sourceDirectory fileNamesDo: [ :filename <Str> |
				('*.bak' match: filename)
					ifTrue: [ 	newName := filename copyFrom: 1 to: filename size - 4.
									newFile := self sourceDirectory fileNamed: newName.
									newFile exists
										ifTrue: [	newFile remove ].
									(self sourceDirectory fileNamed: filename)  renameAs: newName ] ] ]
		ifTrue: [
			(self sourceDirectory, (FilePattern for: '*.new')) pathsDo: [ :file <FilePath> |
				file delete ].
			(self sourceDirectory, (FilePattern for: '*.bak')) pathsDo: [ :file <FilePath> |
				newName := file name copyFrom: 1 to: file name size - 4.
				newFile := FilePath for: newName.
				newFile exists
					ifTrue: [	newFile delete ].
				file moveAs: newFile ].
			Transcript show: 'Source Database backup restored.';cr.	 ].		

! !

"June 6, 2007 -> 1:44:51"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
restoreFile ^ <FilePath>

	^BootStrapping
		ifTrue: [ 	self sourceDirectory, (FilePath for: self restoreFileName) ]
		ifFalse: [ 	self sourceDirectory fileNamed: self restoreFileName ]! !

"June 6, 2007 -> 1:44:52"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
restoreFileName ^ <Str>

	^'strongtalkrestore.log'! !

"June 6, 2007 -> 1:44:53"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
saveLogFile ^ <FilePath>

	^self sourceDirectory, (FilePath for: 'strongtalkSave.log')! !

"June 6, 2007 -> 1:44:54"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
sourceDirectory ^ <FilePath>

	| path <FilePath> len <Int> |
	SourceDirectory isNil ifTrue: [
		BootStrapping
			ifTrue: [ 
				path := FilePath for: 
								(Platform 
									environmentVariableAt: self sourceDirectoryEnvVar 
									ifAbsent: [ 'source' ]).		
									"Use 'source'  in current directory as default"
				path exists ifFalse: [
					path createDirectoryIfFail: [ :err <Symbol> | Win32 handleError ] ] ]
			ifFalse: [ 
				path := String new: 1024.
				len := KernelLibrary getEnvironmentVariable: self sourceDirectoryEnvVar buffer: path length: path size.
				(len = 0 or: [ len > 1024])
					ifTrue: [ self error: 'Environment variable ', self sourceDirectoryEnvVar,' undefined' ].
				path := Directory fromPath: (path copyFrom: 1 to: len).
				path exists ifFalse: [
					path create ] ].
		SourceDirectory := path ].
	^SourceDirectory
! !

"June 6, 2007 -> 1:44:55"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
sourceDirectoryEnvVar ^ <Str>

	^'StrongtalkSourceDir'! !

"June 6, 2007 -> 1:44:56"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
systemBeingSaved

	| identification <Str> idStream <CharOutputStream> logSize <Int> newName <Str> newFile <FilePath> |
	self flush.
	BootStrapping
		ifTrue: [	
			"Rename .new files and remove .bak files"
			(self sourceDirectory, (FilePattern for: '*.new')) pathsDo: [ :file <FilePath> |
				newName := file name copyFrom: 1 to: file name size - 4.
				newFile := FilePath for: newName.
				newFile exists
					ifTrue: [	self shouldNotHappen ].
				file moveAs: newFile ].
			(self sourceDirectory, (FilePattern for: '*.bak')) pathsDo: [ :file <FilePath> |
				file delete ] ]
		ifFalse: [	
			self sourceDirectory fileNamesDo: [ :filename <Str> |
				('*.new' match: filename) 
					ifTrue: [	newName := filename copyFrom: 1 to: filename size - 4.
									newFile := self sourceDirectory fileNamed: newName.
									newFile exists
										ifTrue: [	self shouldNotHappen ].
									(self sourceDirectory fileNamed: filename)  renameAs: newName ] ].
			self sourceDirectory fileNamesDo: [ :filename <Str> |
				('*.bak' match: filename)
					ifTrue: [ (self sourceDirectory fileNamed: filename) remove ] ] ].

	"Stamp change log"
	self addSectionToChangeLog: [ :log <WriteStream> |
		log nextPutAll: '"System saved" !!' ].
	logSize := self changeLog position.

	"Write new identification file"
	BootStrapping
		ifTrue: [
			identification := Platform commandLineTokens next.
			idStream := self identificationFile charOutputStream ]
		ifFalse: [
			identification := SessionModel current commandLineTokens next.
			idStream := self identificationFile writeStream ].
	[ 	idStream 
			deltaNextChunkPut: identification; cr; 
			deltaNextChunkPut: logSize printString; cr
	] ensure: [
		idStream close
	].

	self flush.
	
	self updateSaveLogFile
! !

"June 6, 2007 -> 1:44:58"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
systemIsConsistent ^<Boolean>

	| 	oldID <Str> 
		newID <Str> 
		oldLogSize <Int> 
		idStream <CharInputStream>
		restoreStream <CharInputStream> |

	self identificationFile exists ifTrue: [
		BootStrapping
			ifTrue: [	idStream := self identificationFile charInputStream.
							newID := Platform commandLineTokens next ]
			ifFalse: [	idStream := self identificationFile readStream.
							newID := SessionModel current commandLineTokens next ].
		[	
			oldID := idStream nextChunk.
			oldLogSize := Integer readFrom: idStream.
		] ensure: [
			idStream close
		].
		"		newID = oldID
			ifFalse: [	self printImageChangeWarningFrom: oldID to: newID ]"
			"The intent is that when the system is run, it checks to see if the current binary is the same 
			as the one listed in the source identification file and issues a warning if this is not the case. 
			This provides a crude consistency check.  However, it may issue false warnings,if the entire 
			strongtalk directory is moved to a new location. It even gets  confused if the system is run from the 
			command line or from the windows GUI, because the pathnames are not literally identical."

			"12/6/01: commented out code above; otherwise everyone downloading the system will get
			an annoying message they will not readily understand. If you've downloaded this
			code, feel free to uncomment this part."
			 ].

	BootStrapping
		ifTrue: [
			(self sourceDirectory, (FilePattern for: '*.new')) pathsDo: [ :file <FilePath> |
				^false ].
			(self sourceDirectory, (FilePattern for: '*.bak')) pathsDo: [ :file <FilePath> |
				^false ] ]
		ifFalse: [
			self sourceDirectory fileNamesDo: [ :filename <Str> |
				('*.bak' match: filename) 
					ifTrue: [ ^false ].
				('*.new' match: filename) 
					ifTrue: [ ^false ] ] ].
	^true! !

"June 6, 2007 -> 1:44:58"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
test

	MixinSourceHandler test.! !

"June 6, 2007 -> 1:44:59"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
unsavedChangesHaveBeenMade ^<Boolean>

	"make sure the change log etc. has been initialized"
	self changeLog.
	
	^self initialChangeLogSize ~= self currentChangeLogSize! !

"June 6, 2007 -> 1:45:1"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
updateSaveLogFile
	"Update the save log, if there is one.  This is done during a system save ONLY.  
		%bootstrapping: WARNING: there must not be a save file during the interval between when
		this save file change handling code is filed in, and when the system is restarted after 
		saving it "
	self saveLogFile exists
		ifTrue: [	| ss <ExternalReadWriteStream> logSize <Int> |
					"copy everything written to the change log in this session to the save log"
					
					ss := self saveLogFile readWriteStream.
					ss setToEnd.
					self changeLog flush.
					logSize := self changeLog position.  "remember starting position"
				
					self changeLog position: self initialChangeLogSize.
					[ self rawChangeLog atEnd ]
						whileFalse: 
								[	| byte <Int> |
									ss put: self rawChangeLog next.
									InitialChangeLogSize := InitialChangeLogSize + 1.  ].
					ss close.
					
					"restore the change log position."
					self changeLog position: logSize.	].! !

"June 6, 2007 -> 1:45:2"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
addSectionToChangeLog: blk <[WriteStream,^Int]> ^ <Int>

	^self class addSectionToChangeLog: blk! !

"June 6, 2007 -> 1:45:3"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
attributeAt: k <Str> ^ <OrdCltn[Str]>

	^self indexDict at: k ifAbsent: [ ^OrderedCollection with: String new ]! !

"June 6, 2007 -> 1:45:4"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
attributeAt: k <Str> put: e <OrdCltn[Str]>

	| removeAttribute <Boolean> |
	removeAttribute := BootStrapping
		ifTrue: [ (e isEmpty or: [ e size = 1 and: [ (e at: 1) = '' ] ] ) ]
		ifFalse: [ (e isEmpty or: [ e size = 1 and: [ (e at: 1) trimBlanks = '' ] ] ) ].
	removeAttribute
		ifTrue: [
			self indexDict removeKey: k ifAbsent: [] ]
		ifFalse: [
			self indexDict at: k put: e ].
	self isPersistent ifTrue: [ self storeIndexFile ].! !

"June 6, 2007 -> 1:45:5"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
backupExtension ^ <Str>

	^'.bak'! !

"June 6, 2007 -> 1:45:6"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
booleanAttributeAt: k <Str> ^ <Boolean>

	| list <OrdCltn[Str]> |
	list := self attributeAt: k.
	list size ~= 1 ifTrue: [ self shouldNotHappen ].
	^list first = 'true'
! !

"June 6, 2007 -> 1:45:7"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
booleanAttributeAt: k <Str> put: b <Boolean>

	self attributeAt: k put: (OrderedCollection with: b printString).
! !

"June 6, 2007 -> 1:45:7"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
changeLog ^ <FilePath>

	^self class changeLog! !

"June 6, 2007 -> 1:45:9"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
convertFromFilename: src <Str> ^ <Str>

	"Convert a file name into a Smalltalk toplevel definition by mapping the following:

		$A maps from '_a'       (uppercase letters)
		$_ maps from $_$_	"

	| rs <ReadStream> ws <WriteStream> c <Character> |
	rs := src readStream.
	ws := String new writeStream.
	[ rs atEnd ] whileFalse: [
		(c := rs next) = $_
			ifTrue: [
				rs peek = $_
					ifTrue: [
						rs next.
						ws nextPut: $_ ]
					ifFalse: [
						c := rs next.
						ws nextPut: c asUppercase ] ]
			ifFalse: [
				ws nextPut: c ] ].
	^ws contents
! !

"June 6, 2007 -> 1:45:10"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
convertToFilename: src <Str> ^ <Str>

	"Convert a Smalltalk toplevel definition name into a valid file name by mapping the following:

		$A maps to '_a'       (uppercase letters)
		$_ maps to $_$_	"

	| ws <WriteStream> |
	ws := (String new: src size * 2) writeStream.
	src do: [ :c <Character> | 
		c = $_
			ifTrue: [
				ws nextPut: $_.
				ws nextPut: $_ ]
			ifFalse: [
				c isUppercase ifTrue: [ ws nextPut: $_ ].
				ws nextPut: c asLowercase ] ].
	^ws contents
! !

"June 6, 2007 -> 1:45:11"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
dualHandler ^ <Self>

	self hasDualHandler
		ifFalse: 	[ ^nil ].
	dualHandler isNil ifTrue: [ 
		self dualHandler: (self class dualHandlerFor: self mirror).
		self dualHandler dualHandler: self ].
	^dualHandler! !

"June 6, 2007 -> 1:45:12"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
dualHandler: h ^ <Self>

	dualHandler := h! !

"June 6, 2007 -> 1:45:13"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
flush

	"Flush cached information. No store operation is needed since this is currently done eagerly."

	self indexDict: nil.
	self indexFile: nil.
	self isNewIndex: nil.
	(dualHandler notNil and: [self mirror notNil and: [self isMeta not]]) 
		ifTrue: [ self dualHandler flush ].! !

"June 6, 2007 -> 1:45:14"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
handlerId ^ <Str>

	self subclassResponsibility! !

"June 6, 2007 -> 1:45:15"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
hasDualHandler ^ <Boolean>

	^true! !

"June 6, 2007 -> 1:45:16"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
indexDict ^ <Dictionary[Symbol,Cltn[Str]]>

	indexDict isNil ifTrue: [ 
		self indexDict: Dictionary[Symbol,Cltn[String]] new.
		self isPersistent ifTrue: [
			self parseIndexFile ] ].
	^indexDict! !

"June 6, 2007 -> 1:45:17"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
indexDict: i <Dictionary[Symbol,Cltn[Str]]>

	indexDict := i! !

"June 6, 2007 -> 1:45:18"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
indexFile ^ <FilePath>

	| name <Str> |
	indexFile isNil ifTrue: [
		indexFile := BootStrapping
							ifTrue: [ 	self sourceDirectory, (FilePath for: self indexFileName) ]
							ifFalse: [ 	self sourceDirectory fileNamed: self indexFileName ].
		self isNewIndex: indexFile exists not.
		self isNewIndex
			ifTrue: [
				indexFile := BootStrapping
									ifTrue: [ 	self sourceDirectory, (FilePath for: self indexFileName, self newExtension) ]
									ifFalse: [ 	self sourceDirectory fileNamed: self indexFileName, self newExtension ] ] ].
	^indexFile
! !

"June 6, 2007 -> 1:45:19"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
indexFile: fp <FilePath>

	indexFile := fp! !

"June 6, 2007 -> 1:45:20"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
indexFileName ^ <Str>

	| s <Str> |
	s := self convertToFilename: (self mirror name readStream upTo: $ ).	"Strip meta extension"
	^self isMeta
		ifTrue: [ s, self metaExtension ]
		ifFalse: [ s ]
! !

"June 6, 2007 -> 1:45:21"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
isMeta ^ <Boolean>

	^self mirror isMeta! !

"June 6, 2007 -> 1:45:22"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
isNewIndex ^ <Boolean>

	isNewIndex isNil
		ifTrue: [	self indexFile ].		"Sets flag depending on whether index existed or not"
	^isNewIndex
! !

"June 6, 2007 -> 1:45:23"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
isNewIndex: b <Boolean>

	isNewIndex := b! !

"June 6, 2007 -> 1:45:24"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
isPersistent ^ <Boolean>

	^self mirror name notNil! !

"June 6, 2007 -> 1:45:25"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
makeBackupIndex

	| backupIndexFile <FilePath> |
	self isNewIndex ifFalse: [ 
		BootStrapping
		ifTrue: [ 	
			backupIndexFile  :=self sourceDirectory, (FilePath for: self indexFileName, self backupExtension).
			backupIndexFile exists 
				ifFalse: [ self indexFile copyAs: backupIndexFile ] ]
		ifFalse: [ 	
			(self sourceDirectory fileNamed: self indexFileName, self backupExtension) exists
				ifFalse: [ self indexFile copyTo: self sourceDirectory as: self indexFileName, self backupExtension ] ] ]
! !

"June 6, 2007 -> 1:45:26"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
metaExtension ^ <Str>

	^'.class'! !

"June 6, 2007 -> 1:45:27"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
mirror ^ <Mirror>

	^mirror! !

"June 6, 2007 -> 1:45:28"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
mirror: m <Mirror>

	mirror := m! !

"June 6, 2007 -> 1:45:28"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
newExtension ^ <Str>

	^'.new'! !

"June 6, 2007 -> 1:45:30"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
parseIndexFile

	| file <FilePath> rs <ReadStream> attr <Symbol> s <Str> value <OrdCltn[Str]> id <Str> |

	(file := self indexFile) exists ifTrue: [ 
		BootStrapping
			ifTrue: [ rs :=file charInputStream ]
			ifFalse: [ rs :=file readStream ].
		[
			rs atEnd ifFalse: [
				BootStrapping
					ifTrue: [ id := rs upTo: Character cr ]
					ifFalse: [ id := rs nextLine trimBlanks ].
				id = self handlerId
					ifFalse: [ self error: 'Source database inconsistency: Attemping to have a ', self handlerId, ' hold source for a ', id ] ].
			[ rs atEnd ] whileFalse: [
				s := rs nextChunk.
				BootStrapping ifFalse: [ s := s trimBlanks ].
				self assert: [ s size > 0].
				attr := s asSymbol.
				value := OrderedCollection [Str] new.
				[ (s := rs nextChunk) isEmpty ] whileFalse: [ 
					value add: s ].
				self indexDict at: attr put: value ].
		] ensure: [
			rs close 
		]
	]! !

"June 6, 2007 -> 1:45:31"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
printOn: aStream  <Stream> 
	aStream 
		nextPutAll: self class name;
		nextPutAll: ' on ';
		nextPutAll: self mirror name! !

"June 6, 2007 -> 1:45:32"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
removeAttributeAt: k <Str> ifAbsent: blk <[]> ^ <Cltn[Str]>

	self indexDict removeKey: k ifAbsent: blk.
	self storeIndexFile.! !

"June 6, 2007 -> 1:45:33"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
removeIndex

	self flush.
	self removeIndexFile.
	(self hasDualHandler and: [self isMeta not]) 
		ifTrue: [	self dualHandler removeIndexFile ].
	
	(self hasDualHandler and: [self isMeta]) 
		ifTrue: [ self dualHandler logRemoveDefinition ]
		ifFalse: [ self logRemoveDefinition ].

	"Done, nil out remaining entries"
	(self hasDualHandler and: [self isMeta not]) 
		ifTrue: [	self dualHandler mirror: nil.
						self dualHandler dualHandler: nil ].
	self mirror: nil.
	self dualHandler: nil
! !

"June 6, 2007 -> 1:45:34"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
removeIndexFile

	self makeBackupIndex.
	BootStrapping
		ifTrue: [ self indexFile deleteIfFail: [ :err <Symbol> | Win32 handleError ] ]
		ifFalse: [ self indexFile exists ifTrue: [ self indexFile close; remove ] ]! !

"June 6, 2007 -> 1:45:35"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
setName: n <Str>

	self storeIndexFile.
	(self hasDualHandler and: [ dualHandler notNil ])
		ifTrue: [	self dualHandler storeIndexFile ].
! !

"June 6, 2007 -> 1:45:36"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
sourceDirectory ^ <FilePath>

	^self class sourceDirectory
! !

"June 6, 2007 -> 1:45:37"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
storeIndexFile

	| ws <CharOutputStream> |
	self makeBackupIndex.
	BootStrapping
		ifTrue: [ ws := self indexFile charOutputStream ]
		ifFalse: [  ws := self indexFile writeStream ].
	[
		ws nextPutAll: self handlerId; cr.
		self indexDict associationsDo: [ :a <Association[Symbol, Cltn[Str]]> |
	 		ws deltaNextChunkPut: a key.
			a value do: [ :e <Str> | 
				ws cr; deltaNextChunkPut: e ].
			ws nextPut: $ ; nextPut: $!!; cr ].
		BootStrapping ifFalse: [ ws truncate ]
	] ensure: [
		ws close
	]
! !

"June 6, 2007 -> 1:45:38"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
uniqueAttributeAt: k <Str> ^ <Str>

	| list <OrdCltn[Str]> |
	list := self attributeAt: k.
	list size ~= 1 ifTrue: [ self shouldNotHappen ].
	^list first
! !

"June 6, 2007 -> 1:46:19"!

Delta define: #WinPOINT as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 6, 2007 -> 1:46:19"!

(Delta mirrorFor: #WinPOINT)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.1 $
'!


"June 6, 2007 -> 1:46:21"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
asPoint ^<Point>
	^self x @ self y! !

"June 6, 2007 -> 1:46:22"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
structureSize ^<Int>
	^8! !

"June 6, 2007 -> 1:46:23"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
x ^<SmallInteger>

	^self smallIntegerAt: self xOffset! !

"June 6, 2007 -> 1:46:23"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
x: v <SmallInteger>

	self smallIntegerAt: self xOffset put: v! !

"June 6, 2007 -> 1:46:24"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
y ^<SmallInteger>

	^self smallIntegerAt: self yOffset! !

"June 6, 2007 -> 1:46:25"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
y: v <SmallInteger>

	self smallIntegerAt: self yOffset put: v! !

"June 6, 2007 -> 1:46:26"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'offsets' !
xOffset ^<Int>
	^0! !

"June 6, 2007 -> 1:46:27"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'offsets' !
yOffset ^<Int>
	^4! !

"June 6, 2007 -> 1:48:29"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 6, 2007 -> 1:48:30"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 6, 2007 -> 1:48:30"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 6, 2007 -> 1:48:31"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 6, 2007 -> 1:48:31"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 6, 2007 -> 1:48:31"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 6, 2007 -> 1:48:31"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 6, 2007 -> 1:48:31"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 6, 2007 -> 1:48:31"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 6, 2007 -> 1:48:31"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 6, 2007 -> 1:48:31"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 6, 2007 -> 1:48:31"!

(Delta mirrorFor: #MINMAXINFO)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"June 6, 2007 -> 1:48:32"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'accessing' !
ptMaxSize ^<WinPOINT>

	^self subProxyAt: self ptMaxSizeOffset result: WinPOINT new! !

"June 6, 2007 -> 1:48:33"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'accessing' !
ptMaxTrackSize ^<WinPOINT>

	^self subProxyAt: self ptMaxTrackSizeOffset result: WinPOINT new! !

"June 6, 2007 -> 1:48:33"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'accessing' !
ptMinTrackSize ^<WinPOINT>

	^self subProxyAt: self ptMinTrackSizeOffset result: WinPOINT new! !

"June 6, 2007 -> 1:48:34"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'accessing' !
structureSize ^<Int>

	^40! !

"June 6, 2007 -> 1:48:35"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'offsets' !
ptMaxPositionOffset ^<Int>

	^16! !

"June 6, 2007 -> 1:48:36"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'offsets' !
ptMaxSizeOffset ^<Int>

	^8! !

"June 6, 2007 -> 1:48:37"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'offsets' !
ptMaxTrackSizeOffset ^<Int>

	^32! !

"June 6, 2007 -> 1:48:38"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'offsets' !
ptMinTrackSizeOffset ^<Int>

	^24! !

"June 6, 2007 -> 1:48:38"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'offsets' !
ptReservedOffset ^<Int>

	^0! !

"June 6, 2007 -> 1:49:13"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 6, 2007 -> 1:49:15"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 6, 2007 -> 1:49:15"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 6, 2007 -> 1:49:16"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 6, 2007 -> 1:49:16"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 6, 2007 -> 1:49:16"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 6, 2007 -> 1:49:17"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 6, 2007 -> 1:49:17"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 6, 2007 -> 1:49:18"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 6, 2007 -> 1:49:18"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 6, 2007 -> 1:49:19"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 6, 2007 -> 1:49:19"!

(Delta mirrorFor: #Win32Control)
comment: 
'A Visual that has a corresponding native Win32 window.

%optional #commandWith: - should override to process any WM_COMMAND messages needed

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.5 $
'!


"June 6, 2007 -> 1:49:21"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'private' !
controlForHandle: hwnd <ExternalProxy> ifAbsent: b <[^X def]> ^<Win32Control | X>

	^self controlFor: (self controlIdFor: hwnd) ifAbsent: b! !

"June 6, 2007 -> 1:49:22"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'private' !
controls ^<VarDict[Int, Win32Control]>

	"Assumption: allers must be in a critical region for self"

	Controls isNil
		ifTrue: [ Controls := Dictionary[Int, Win32Control] new ].
	^Controls! !

"June 6, 2007 -> 1:49:23"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'private' !
dispatchMsgFor: hwnd <ExternalProxy>
msg: msg <SmallInteger>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^(self controlForHandle: hwnd ifAbsent: [ ^0 ])
		message: msg for: hwnd wParam: wParam lParam: lParam! !

"June 6, 2007 -> 1:49:24"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
assignId ^<Int>
	"Assign and return a unique control id number.  It is assumed that we are already in a
		critical region on the Win32Control."

	MaxControlId isNil
				ifTrue: [ MaxControlId := 1 ]
				ifFalse: [ MaxControlId := MaxControlId + 1].
	^MaxControlId! !

"June 6, 2007 -> 1:49:25"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
buttonColorMsg: hdc <ExternalProxy> for: control <Int> ^<ExternalData>

	^(self controlFor: control  ifAbsent: [ ^0 ]) buttonColorMsg: hdc! !

"June 6, 2007 -> 1:49:27"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
controlFor: id <Int> ifAbsent: b <[^X def]> ^<Win32Control | X>

	^Win32Control
		critical: [	self controls at: id ifAbsent: b ]! !

"June 6, 2007 -> 1:49:27"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
controlIdFor: hwnd <HWND> ^<Int>

	^{{<user ExternalProxy GetWindowLongA> hwnd: hwnd value: Win32 GWL_ID}} asSmallInteger.
! !

"June 6, 2007 -> 1:49:29"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
customWndProc ^<APICallback>

	"Don't need a critical region"
	CustomWndProc isNil
		ifTrue: [	CustomWndProc := APICallBack
							register:
								[ :hwnd <ExternalProxy> :msg <SmallInteger> :wParam <ExternalData> :lParam <ExternalData> |
									self dispatchMsgFor: hwnd msg: msg wParam: wParam lParam: lParam ]
							parameters: (OrderedCollection[Class]
								with: ExternalProxy with: SmallInteger with: ExternalProxy with: ExternalProxy).	].
	^CustomWndProc! !

"June 6, 2007 -> 1:49:30"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
drawItemMsg: data <DRAWITEMSTRUCT> for: control <Int> ^<ExternalData>

	^(self controlFor: control ifAbsent: [ ^0 ]) drawItemMsg: data! !

"June 6, 2007 -> 1:49:31"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
measureItemMsg: data <MEASUREITEMSTRUCT> for: control <Int> ^<ExternalData>

	^(self controlFor: control ifAbsent: [ ^0 ]) measureItemMsg: data! !

"June 6, 2007 -> 1:49:31"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
notificationMsg: notifyCode <ExternalData> for: control <Int>

	(self controlFor: control ifAbsent: [ ^0 ]) notificationMsg: notifyCode! !

"June 6, 2007 -> 1:49:32"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
registerControl: id <Int> for: inst <Win32Control>

	Win32Control critical: 
		[ self controls at: id put: inst	]! !

"June 6, 2007 -> 1:49:33"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
unregisterControl: id <Int>

	Win32Control critical: [ self controls removeKey: id ]! !

"June 6, 2007 -> 1:49:34"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'testing' !
debugEvents ^<Boolean>

	^Session debugEvents! !

"June 6, 2007 -> 1:49:35"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'testing' !
debugNotifications ^<Boolean>

	^false! !

"June 6, 2007 -> 1:49:36"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
backgroundPainter ^<Painter>

	backgroundPainter isNil
		ifTrue: [ ^super backgroundPainter ].
	^backgroundPainter! !

"June 6, 2007 -> 1:49:37"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
enabled ^<Boolean>

	^enabled! !

"June 6, 2007 -> 1:49:38"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
enabled: flag <Boolean>

	self enabled = flag
		ifFalse: [	self setEnabled: flag ].! !

"June 6, 2007 -> 1:49:39"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
fullyEnabled ^<Boolean>

	"is true if we are enabled and all parents are enabled"
	^self enabled and: [ super enabled ]! !

"June 6, 2007 -> 1:49:40"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
nativeWindow ^<Window | Win32Control>

	^self! !

"June 6, 2007 -> 1:49:41"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
redraw ^<Boolean>

	^redraw! !

"June 6, 2007 -> 1:49:43"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'control' !
changing

	"flush the cached background painter so that it updates"
	backgroundPainter := nil.
	
	super changing! !

"June 6, 2007 -> 1:49:44"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'control' !
deferringRedrawDo: blk <[^Object]>
	"defer redrawing during evaluation of blk.  If these calls are nested recursively,
	   redrawing is deferred until the outermost returns, at which point the entire control
	   is invalidated.  This can be used to surround a large number of changes to the receiver
	   that would otherwise cause redundant redrawing."

	| oldFlag <Boolean> |
	oldFlag := self redraw.
	self redraw: false.
	blk value.
	self redraw: oldFlag.
	oldFlag
		ifTrue: [ self invalidate ]! !

"June 6, 2007 -> 1:49:45"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'control' !
ignoreNextFocusSet: flag <Boolean>

	ignoreNextFocusSet := flag! !

"June 6, 2007 -> 1:49:46"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'control' !
release

	self hasWin32Handle
		ifTrue: [ self destroyWin32Handle ].
	super release.! !

"June 6, 2007 -> 1:49:47"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'control' !
visible: flag <Boolean>

	| data <ExternalData> |
	self assert: [ self hasWin32Handle ].

	data := flag ifTrue: [ Win32 SW_SHOW ] ifFalse: [ Win32 SW_HIDE ].
	{{<user ExternalProxy ShowWindow> hwnd: self win32Handle flag: data}}.! !

"June 6, 2007 -> 1:49:48"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'debugging' !
printAllocOn: strm <CharOutputStream>

	super printAllocOn: strm.
	self hasWin32Handle
		ifTrue: [	strm show: ' hwnd: '; print: self win32Handle ]
		ifFalse: [ strm show: ' (no hwnd)' ]! !

"June 6, 2007 -> 1:49:50"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'displaying' !
localDisplayOn: can <Canvas>

	can subwindowsToDisplay add: self! !

"June 6, 2007 -> 1:49:51"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'event handling' !
character: c <Character> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	^(self callOrigWndProcFor: ev msg) = 0! !

"June 6, 2007 -> 1:49:52"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'event handling' !
keyDown: key <Symbol> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	^(self callOrigWndProcFor: ev msg) = 0! !

"June 6, 2007 -> 1:49:53"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'event handling' !
keyUp: key <Symbol> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	^(self callOrigWndProcFor: ev msg) = 0! !

"June 6, 2007 -> 1:49:54"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'event handling' !
mouseEvent: type <Symbol> at: loc <Point> event: ev <UIEvent> ^<Boolean>

	| orig <Point> |

	"Translate location back into native window coordinates"
	orig := self allocation enclosingRect origin.
	^(self callOrigWndProcFor: ev msg withLParam: (ExternalProxy forHigh: loc y - orig y low: loc x - orig x)) = 0! !

"June 6, 2007 -> 1:49:56"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'geometry-local' !
allocation: r <Region> at: pos <Point>

	| oldAlloc <Region> alloc <Rect> oldLayoutStatus <Int> |
	oldLayoutStatus := self layoutStatus.
	oldAlloc := allocation.
	alloc := r enclosingRect.
	super allocation: r at: pos.

	oldAlloc isNil
		ifTrue: [ self win32Handle.		"Make sure window is created with the current allocation & position" ]
		ifFalse: [	| oldNativePos <Point> old <Rect> | 
						"We need to use a variable since pos...Window changes nativePos"
						old := oldAlloc enclosingRect.
						oldNativePos := nativePosition.
						self hasWin32Handle
							ifTrue: [	(old width ~= alloc width
													or: [ old height ~= alloc height
													or: [ oldNativePos ~= self nativePosition ]  ] )
												ifTrue: [  self updateWindowDimensions  ]	 ]
							ifFalse: [	self isAttached
												ifTrue: [ self win32Handle ]	] ].
	"Invalidate if we are relaying out as a %hack to solve the problems that a higher level
		relayoutAndInvalidate doesn't invalidate contained native windows like this one"
	oldLayoutStatus = Visual needsRelayout
		ifTrue: [ self invalidate ]! !

"June 6, 2007 -> 1:49:57"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'geometry-nonlocal' !
moveBy: positionDelta <Point>

	"We override this since moving a native visual will generate any needed invalidations
	  automatically."

	self adjustPositionBy: positionDelta! !

"June 6, 2007 -> 1:49:58"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'initialization' !
initialize

	super initialize.
	redraw := true.
	enabled := true.
	isFocus := false.
	self addNonLocalCount: 1.		"Receiver is non-local"
	ignoreNextFocusSet := false.

	self refreshInterval: self defaultRefreshInterval.
	self paintPending: false.
	self useDisplayBuffering: true.
	controls := IdentitySet[Win32Control] new.! !

"June 6, 2007 -> 1:49:59"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
checkPaintTime: t <Float>
	"If we have reached our refresh time, paint"

	(self hasWin32Handle and: [ self paintPending ])
		ifTrue: [ self nextPaintTime <= t
						ifTrue: [ self display ]
						ifFalse: [ self session needPaintAtTime: self nextPaintTime ]	 ]! !

"June 6, 2007 -> 1:50:1"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
controls ^<Extensible[Win32Control]>

	^controls! !

"June 6, 2007 -> 1:50:2"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
cursor ^<Cursor>

	^cursor! !

"June 6, 2007 -> 1:50:3"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
cursor: c <Cursor>

	cursor := c.! !

"June 6, 2007 -> 1:50:4"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
defaultRefreshInterval ^<Float>

	^0.25! !

"June 6, 2007 -> 1:50:5"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
globalFromLocalPosition: p <WinPOINT> ^<WinPOINT>

	| wp <WinPOINT> result <WinPOINT> |
	wp := WinPOINT new allocate.
	wp x: p x; y: p y.
	{{<user ExternalProxy ClientToScreen>
			handle: self win32Handle
			point: wp
	}} asBoolean
		ifFalse: [ Win32 handleError ].
	result := wp x @ wp y.
	wp free.
	^result! !

"June 6, 2007 -> 1:50:6"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
handleMouseEvent: type <Symbol> at: loc <Point> ^<Boolean>

	| ev <UIEvent> |

	"%todo: remove the dispatch block for all events; isn't needed anymore"
	ev := UIEvent
			forMsg: self session currentMsg
			dispatch:
				[ :e <UIEvent> :h <UIEventHandler> |
					h mouseEvent: type at: loc event: e ].
	Sampler notNil
		ifTrue: [ Sampler 
						in: self topWindow visual 
						sampleEvent: type 
						at: (loc translatedBy: self positionInTopWindow)
						event: ev ].
	^self mouseEvent: type at: loc event: ev! !

"June 6, 2007 -> 1:50:7"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
localFromGlobalPosition: p <WinPOINT> ^<WinPOINT>

	| wp <WinPOINT> result <WinPOINT> |
	wp := WinPOINT new allocate.
	wp x: p x; y: p y.
	{{<user ExternalProxy ScreenToClient>
			handle: self win32Handle
			point: wp
	}} asBoolean
		ifFalse: [ Win32 handleError ].
	result := wp x @ wp y.
	wp free.
	^result translatedBy: self allocation enclosingRect origin! !

"June 6, 2007 -> 1:50:8"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
nextPaintTime ^<Float>

	^nextPaintTime! !

"June 6, 2007 -> 1:50:9"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
nextPaintTime: t <Float>

	nextPaintTime := t! !

"June 6, 2007 -> 1:50:10"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
noPalette

	palette := nil! !

"June 6, 2007 -> 1:50:12"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
paintOccuring

	self nextPaintTime: Time clockValue + self refreshInterval.
	self paintPending: false.
	self session paintOccuredFor: self.! !

"June 6, 2007 -> 1:50:13"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
paintPending ^<Boolean>

	^paintPending! !

"June 6, 2007 -> 1:50:14"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
paintPending: b <Boolean>

	paintPending := b! !

"June 6, 2007 -> 1:50:15"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
palette ^<Palette>

	^palette! !

"June 6, 2007 -> 1:50:16"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
palette: p <Palette>

	p == palette
		ifTrue: [ ^self ].
	self assert: [ palette isNil ].
	palette := p! !

"June 6, 2007 -> 1:50:17"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
paletteChangedMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	wParam @= self win32Handle
		ifFalse: [ self recursiveRealizePaletteForeground: false updateColors: true.
						self palette isNil
							ifTrue: [ ^self callDefWndProcFor: hwnd
											msgCode: msg
											wParam: wParam
											lParam: lParam	].
					 ].
	^0! !

"June 6, 2007 -> 1:50:18"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
queryPaletteMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self recursiveRealizePaletteForeground: true updateColors: false.
	self palette isNil
		ifTrue: [ ^self callDefWndProcFor: hwnd
						msgCode: msg
						wParam: wParam
						lParam: lParam	].
	^0! !

"June 6, 2007 -> 1:50:19"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
recursiveRealizePaletteForeground: fore <Boolean> updateColors: update <Boolean>

	self palette isNil
		ifFalse: [	self withDCDo:
							[ :hdc <HDC> |
								| oldpal <Win32Handle> |
								oldpal := Palette select: self palette win32Handle into: hdc background: fore not.
								self palette unrealize.
								self palette realizeFor: hdc.
								Palette debugging
									ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
								Palette select: oldpal win32Handle into: hdc background: fore not.
							 ].
						self invalidate.
						].
	self controls do:
		[ :c <Win32Control> |
			c recursiveRealizePaletteForeground: fore updateColors: update ].! !

"June 6, 2007 -> 1:50:20"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
refreshInterval ^<Float>

	^refreshInterval! !

"June 6, 2007 -> 1:50:21"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
refreshInterval: d <Float>
	"Wait no longer than this amount of time (in seconds) between
		paint operations, if possible"

	refreshInterval := d! !

"June 6, 2007 -> 1:50:22"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
registerControl: c <Win32Control>

	self controls include: c! !

"June 6, 2007 -> 1:50:24"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
registerPaintTime

	self paintPending
		ifFalse: [	self paintPending: true.
						self nextPaintTime: Time clockValue + self refreshInterval.
						self session schedulePaintFor: self at: self nextPaintTime.	].! !

"June 6, 2007 -> 1:50:25"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
setCursor ^<ExternalData>

	^cursor isNil
		ifFalse: [	{{<user ExternalProxy SetCursor> handle: cursor win32Handle}}.
						1 ]
		ifTrue: [ 0 ]! !

"June 6, 2007 -> 1:50:26"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
setCursorMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^(cursor notNil
			and: [	| hitcode <Int> |
						hitcode := lParam asExternalProxy low.
						hitcode = 1 or: [ hitcode = 65534 ] "client area or disabled"  ])
		ifTrue: [ 	self setCursor.
						1 ]
		ifFalse: [ self callOrigWndProc: msg wParam: wParam lParam: lParam ]
! !

"June 6, 2007 -> 1:50:27"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
showTimes ^<Boolean>
	"Report preference, layout, and painting times on the transcript"

	^false! !

"June 6, 2007 -> 1:50:28"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
unregisterControl: c <Win32Control>

	self controls removeEvery: c! !

"June 6, 2007 -> 1:50:29"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
useDisplayBuffering ^<Boolean>

	^useDisplayBuffering! !

"June 6, 2007 -> 1:50:30"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
useDisplayBuffering: f <Boolean>

	useDisplayBuffering := f! !

"June 6, 2007 -> 1:50:32"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
withBufferedCanvasDo: drawing <[Canvas,^X def]> ^<X>

	^self withDirectCanvasDo:
		[ :directCanvas <Canvas> |
			| invalid <Rect> oldpal <Win32Handle> |
			invalid := directCanvas clippingRect.

			self session
				withBufferCanvasFor: invalid
				do: [ :bufferCanvas <Canvas> :buffer <HBITMAP> |
							self palette isNil
								ifFalse: [ oldpal := bufferCanvas win32Palette: self palette win32Handle ].

							"draw on the buffer canvas"
							drawing value: bufferCanvas.
							bufferCanvas shallowFlush.

							"Now, copy the buffer bits onto the screen"
							directCanvas atOffset: invalid origin
								do: [ bufferCanvas atOffset: invalid origin 
									do: [	directCanvas
													bitBlt: bufferCanvas
												extent: invalid extent
												op: UI ropCopy.		].	].
							oldpal notNil
								ifTrue: [ 	Palette debugging
													ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
												bufferCanvas win32Palette: oldpal ]. 
						].	
		]! !

"June 6, 2007 -> 1:50:33"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
withCanvasDo: drawing <[Canvas,^X def]> ^<X>

	^(self useDisplayBuffering and: [ Window bufferingPossible ])
		ifFalse: [	self withDirectCanvasDo: drawing ]
		ifTrue: [	self withBufferedCanvasDo: drawing ]! !

"June 6, 2007 -> 1:50:34"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
withDCDo: blk <[HDC]>
	"With the window's device context do the block (not for painting)"

	| hdc <HDC> |
	hdc := {{<user HDC GetDC> hwnd: self win32Handle}}.
	[ blk value: hdc ]
		ensure: [ hdc releaseDCFor: self win32Handle ]! !

"June 6, 2007 -> 1:50:36"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
withDirectCanvasDo: drawing <[Canvas,^X def]> ^<X>

	|	can <Canvas>
		ps <PAINTSTRUCT>
		paintBlk <[^Object]>
		result <X>
		oldpal <Win32Handle>  |

	"use a critical region to paint, since background painting might reuse the
	  same device context in the UI thread"
	^self critical:
		[	ps := PAINTSTRUCT new allocateZeroed.
			can := self beginPaint: self win32Handle paintStructure: ps.
			can isNull
				ifTrue: [ Win32 handleError ].
			can	initialize;
				toRelease: [ :dc <HDC> | "End paint will release the context" ];
				initClippingRectBeforeTranslation: ps rcPaint asRectangle;
				window: self.
			self palette isNil
				ifFalse: [ oldpal := can win32Palette: self palette win32Handle ].

			Session debugInvalidation
				ifTrue: [	can withPainter: (Painter new paint: Paint red)
									do: [ can displayFilledRectangle: ps rcPaint asRectangle; flush. ].
								Platform errorStream show: self class name, ' rendering: '; print: ps rcPaint asRectangle; cr.	].

			result := drawing value: can.
			oldpal notNil
				ifTrue: [ 	Palette debugging
									ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
								can win32Palette: oldpal ]. 
			can release. 

			self endPaint: self win32Handle paintStructure: ps.
			ps free.
			result	]! !

"June 6, 2007 -> 1:50:37"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Windows with mods' !
display

	"win32 controls do no Smalltalk level painting by default"! !

"June 6, 2007 -> 1:50:38"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'notification' !
detaching

	super detaching.
	self cleanUp! !

"June 6, 2007 -> 1:50:39"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'notification' !
isFocus: f <Boolean>

	isFocus := f.
	super isFocus: f.
! !

"June 6, 2007 -> 1:50:40"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'notification' !
nativePositionChanged

	"DON'T pass this message to super, since our children are native relative to us!!"

	(self checkForNativePositionChanging or: [ self isAttached ])
		ifTrue: [ self updateWindowDimensions ]! !

"June 6, 2007 -> 1:50:41"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
buildWin32Handle

	self subclassResponsibility! !

"June 6, 2007 -> 1:50:42"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
callOrigWndProc: msgCode <ExternalData> wParam: wParam <ExternalData> lParam: lParam <ExternalData>^<ExternalData>
	"Like callOrigWndProcFor:, but takes all args rather than using a MSG structure"

	"Note that we use the receiver's win32Handle below rather than the one in the message so
	 	 this works even when the event was generated during a grab"
	^{{<user ExternalProxy CallWindowProcA> 
		proc: self originalWndProc
		hwnd: self win32Handle
		msg: msgCode
		wparam: wParam
		lparam: lParam }}! !

"June 6, 2007 -> 1:50:43"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
callOrigWndProcFor: m <MSG> ^<ExternalData>

	"Note that we use the receiver's win32Handle below rather than the one in the message so
	 	 this works even when the event was generated during a grab"
	^{{<user ExternalProxy CallWindowProcA> 
		proc: self originalWndProc
		hwnd: self win32Handle
		msg: m message
		wparam: m wParam
		lparam: m lParam }}! !

"June 6, 2007 -> 1:50:45"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
callOrigWndProcFor: m <MSG> withLParam: lParam <ExternalData>^<ExternalData>
	"Like callOrigWndProcFor:, but overrides the lParam value from the msg"

	"Note that we use the receiver's win32Handle below rather than the one in the message so
	 	 this works even when the event was generated during a grab"
	^{{<user ExternalProxy CallWindowProcA> 
		proc: self originalWndProc
		hwnd: self win32Handle
		msg: m message
		wparam: m wParam
		lparam: lParam }}! !

"June 6, 2007 -> 1:50:46"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
canBeFocusCandidate ^<Boolean>
	"%optional: Subclasses that cannot be the input focus even when they are enabled should override this
	  to return false"

	^true! !

"June 6, 2007 -> 1:50:47"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
checkForNativePositionChanging ^<Boolean>
	"returns true if the native position has been changed"

	
	^self hasWin32Handle
			and: [	| oldpos <Point> |
						oldpos := nativePosition.
						oldpos ~= self nativePosition	]! !

"June 6, 2007 -> 1:50:48"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
cleanUp

	self isFocus
		ifTrue: [	self nativeWindow ignoreNextFocusSet: true.
						self session noInputFocus. ].
	self destroyWin32Handle.
! !

"June 6, 2007 -> 1:50:49"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
controlId ^<Int>

	^controlId! !

"June 6, 2007 -> 1:50:50"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
createNativeWindow

	"we need a critical region to protect the class variable:"
	Win32Control
		critical: [	controlId := self actualClass assignId.
							self actualClass registerControl: self controlId for: self.
							self paintPending: false.
							self buildWin32Handle.
							self palette notNil
								ifTrue: [ self recursiveRealizePaletteForeground: true updateColors: true. ].
							self nativeWindow registerControl: self.
	
							self originalWndProc: (self wndProc).
							self wndProc: self customWndProc.
							self isFocus
								ifTrue: [ self setFocus ].
						].! !

"June 6, 2007 -> 1:50:51"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
createVisible ^<Boolean>

	^true! !

"June 6, 2007 -> 1:50:52"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
customWndProc ^<APICallback>

	^self actualClass customWndProc! !

"June 6, 2007 -> 1:50:53"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
debugTest: msgCode <ExternalData> for: hwnd <ExternalData>

	Win32Control debugEvents
			ifTrue: [	Platform errorStream
									show: 'control winproc event: ';
									show: (MSG descriptionOf: msgCode asExternalProxy);
									show: ' window: ';
									print: hwnd;
									cr. 	].! !

"June 6, 2007 -> 1:50:55"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
destroyWin32Handle

	win32Handle notNil
		ifTrue: [	| hand <ExternalProxy> |
						self actualClass unregisterControl: self controlId.
						self nativeWindow unregisterControl: self.
						hand := self win32Handle.
						win32Handle := nil.		"We nil the handle before destroying so that we can tell
																we are dead if there is a focus shift caused by destroy"
						{{<user ExternalProxy DestroyWindow>
							handle: hand }}.		]! !

"June 6, 2007 -> 1:50:57"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
displayUpwardPopUpMenuAt: loc <Point> ^<Boolean>
	"Look up the parent chain for a popUp menu and display it, if there is one.
		Return true if one was found"

	| m <Menu> t <Timer> |
	m := self parent popUpMenuIfAbsent: [ ^false ].
	self	displayPopUpMenu: m
			at: loc
			forButton: #secondary.
	t := self session atIntervals: 1.0 do:
			[	m release.
				t release. ].
	^true! !

"June 6, 2007 -> 1:50:58"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
extendedWin32Style ^<ExternalData>

	^Win32 WS_EX_NOPARENTNOTIFY! !

"June 6, 2007 -> 1:50:59"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
handleMouseEvent: type <Symbol>
message: msgCode <ExternalData>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>

	| loc <Point> |
	"Translate to be relative to our origin"
	loc := (lParam low @ lParam high) + self allocation enclosingRect origin.
	self handleMouseEvent: type at: loc! !

"June 6, 2007 -> 1:51:0"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
hasWin32Handle ^<Boolean>

	^win32Handle notNil! !

"June 6, 2007 -> 1:51:1"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
invalidate: r <Region>

	self registerPaintTime.
	(self layoutStatus = Visual valid and: [ self hasWin32Handle ])
		ifTrue: [	| rect <Rect> nativerect <RECT> |

						nativerect := RECT new allocate.
						rect := r enclosingRect relativeTo: self allocation origin.
						nativerect
							left: rect left asInteger;
							right: rect right asInteger;
							top: rect top asInteger;
							bottom: rect bottom asInteger.
						{{<user ExternalProxy InvalidateRect>
							hwnd: self win32Handle
							RECT: nativerect
							erase: true}}.
						nativerect free.	]! !

"June 6, 2007 -> 1:51:2"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
nativePosition ^<Point>

	"We have to adjust for the fact that our allocation origin might not be 0@0"
	^nativePosition := self positionInContainingNativeWindow + self allocation enclosingRect origin! !

"June 6, 2007 -> 1:51:3"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
originalWndProc ^<HWND>

	^originalWndProc! !

"June 6, 2007 -> 1:51:4"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
originalWndProc: h <HWND>

	originalWndProc := h! !

"June 6, 2007 -> 1:51:5"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
redraw: flag <Boolean>
	"Tell the widget to start or stop redrawing (temporarily) when necessary.  This is usually used
		with a true arg before a large number of changes, followed by a send with a false arg."

	flag = self redraw
		ifFalse: [	redraw := flag.
						self hasWin32Handle
							ifTrue: [	self	sendMessage: Win32 WM_SETREDRAW
													wparam: flag asExternalData
													lparam: 0	]].! !

"June 6, 2007 -> 1:51:7"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
setEnabled: flag <Boolean>

	enabled := flag.
	win32Handle notNil
		ifTrue: [	{{<user ExternalProxy EnableWindow>
								handle: self win32Handle
								state: self fullyEnabled asExternalData}}.	].
! !

"June 6, 2007 -> 1:51:8"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
setWindowText: t <Str>

	| label <CString> |
	label := CString for: t.
	{{<user ExternalProxy SetWindowText>
		handle: self win32Handle
		str: label}}.
	label free.! !

"June 6, 2007 -> 1:51:9"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
updateWindowDimensions
	"set the control's native size and position"

	| pos <Point> |

	pos := self nativePosition.
	self paintPending: false.
	{{<user ExternalProxy MoveWindow>
		handle: self win32Handle
		x: pos x asInteger
		y: pos y asInteger
		width: self allocation enclosedRect width asInteger
		height: self allocation enclosedRect height asInteger
		repaint: true asExternalData
	 }} asBoolean
			ifFalse: [ Win32 handleError ]! !

"June 6, 2007 -> 1:51:10"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
win32Style ^<ExternalData>

	| s <ExternalData> |
	s := Win32 WS_CHILDWINDOW.
	self createVisible
		ifTrue: [ s := s externalBitOr: Win32 WS_VISIBLE. ].
	self fullyEnabled
		ifFalse: [ s := s externalBitOr: Win32 WS_DISABLED ].
	^s! !

"June 6, 2007 -> 1:51:11"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
wndProc ^<ExternalProxy>

	^Window wndProcOf: self win32Handle! !

"June 6, 2007 -> 1:51:12"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
wndProc: wp <ExternalProxy>

	Window wndProcOf: self win32Handle put: wp! !

"June 6, 2007 -> 1:51:13"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private-message handling' !
beforeKillFocus

	(self session hasInputFocus and: [ self session inputFocus nativeWindow = self ])
		ifTrue: [ self session noInputFocus ].! !

"June 6, 2007 -> 1:51:14"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private-message handling' !
beforeSetFocus

	ignoreNextFocusSet
		ifTrue: [	"We requested the focus, and have already recorded it, so
							ignore this."
						ignoreNextFocusSet := false.	]
		ifFalse: [	"We didn't request this, so windows must be requesting it, so
							record it"
						"We don't use becomeFocus here because that would cause another
							windows setFocus message"
						self session inputFocus: self.		]! !

"June 6, 2007 -> 1:51:16"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private-message handling' !
contextMenuMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<Boolean>

	^self displayUpwardPopUpMenuAt:
			(self localFromGlobalPosition: lParam low @ lParam high)! !

"June 6, 2007 -> 1:51:17"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private-testing' !
isFocusCandidate ^<Boolean>

	^self canBeFocusCandidate
		and: [ self hasWin32Handle
		and: [ self enabled ] ]! !

"June 6, 2007 -> 1:51:18"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private-testing' !
isRectangularAndOpaque ^<Boolean>

	^true! !

"June 6, 2007 -> 1:51:19"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-to session' !
blinkFocus: shown <Boolean>
	
! !

"June 6, 2007 -> 1:51:20"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
buttonColorMsg: hdc <ExternalProxy> ^<ExternalData>

	"Should only get sent to buttons, which override this"
	self shouldNotHappen! !

"June 6, 2007 -> 1:51:21"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
commandWith: notifyCode <ExternalData> ^<ExternalData>

	"Subclasses should override to process command msgs"! !

"June 6, 2007 -> 1:51:22"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
drawItemMsg: data <DRAWITEMSTRUCT> ^<ExternalData>

	self shouldNotHappen! !

"June 6, 2007 -> 1:51:23"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
hInstance ^<ExternalProxy>

	^self parent nativeWindow hInstance! !

"June 6, 2007 -> 1:51:24"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
measureItemMsg: data <MEASUREITEMSTRUCT> ^<ExternalData>

	self shouldNotHappen! !

"June 6, 2007 -> 1:51:26"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
message: msgCode <ExternalData>
for: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self debugTest: msgCode for: hwnd.

	(self session handleIfFocusMsg: msgCode for: self wParam: wParam lParam: lParam) = 0
		ifTrue: [ ^0 ].

	msgCode @= Win32 WM_LBUTTONDOWN 
		ifTrue: [	self handleMouseEvent: #primaryButtonDown
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_LBUTTONUP 
		ifTrue: [	self handleMouseEvent: #primaryButtonUp
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_LBUTTONDBLCLK
		ifTrue: [	self handleMouseEvent: #primaryButtonDoubleClick
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_RBUTTONDOWN 
		ifTrue: [	self handleMouseEvent: #secondaryButtonDown
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_RBUTTONUP 
		ifTrue: [	self handleMouseEvent: #secondaryButtonUp
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_RBUTTONDBLCLK
		ifTrue: [	self handleMouseEvent: #secondaryButtonDoubleClick
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_MOUSEMOVE 
		ifTrue: [	self handleMouseEvent: #mouseMove
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].

	msgCode @= Win32 WM_CTLCOLORBTN
		ifTrue: [ ^Win32Control buttonColorMsg: wParam asExternalProxy for: (Win32Control controlIdFor: lParam) ].

	msgCode @= Win32 WM_DRAWITEM
		ifTrue: [	^Win32Control drawItemMsg: (DRAWITEMSTRUCT forProxy: lParam) for: wParam asSmallInteger ].

	msgCode @= Win32 WM_MEASUREITEM
		ifTrue: [	| data <MEASUREITEMSTRUCT> |
						data := MEASUREITEMSTRUCT forProxy: lParam.
						data CtlType @= Win32 ODT_MENU
							ifFalse: [ ^Win32Control measureItemMsg: data for: data CtlID asSmallInteger ] ].

	(msgCode @= Win32 WM_COMMAND and: [ lParam @~= Win32 NULL ])
		ifTrue: [	"Then this is a control window notification, which should be forwarded back to the
						  smalltalk control object"
						Win32Control notificationMsg: wParam asExternalProxy high for: (Win32Control controlIdFor: lParam).
						^0 ].

	msgCode @= Win32 WM_SETFOCUS
		ifTrue: [ self beforeSetFocus ].
	msgCode @= Win32 WM_KILLFOCUS
		ifTrue: [ self beforeKillFocus ].

	msgCode @= Win32 WM_CONTEXTMENU
		ifTrue: [ (self contextMenuMsg: msgCode hwnd: hwnd wParam: wParam lParam: lParam)
						ifTrue: [ ^0 ]. ].

	msgCode @= Win32 WM_QUERYNEWPALETTE 
		ifTrue: [	self queryPaletteMsg: msgCode hwnd: hwnd
								wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_PALETTECHANGED 
		ifTrue: [	self paletteChangedMsg: msgCode hwnd: hwnd
								wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_SETCURSOR 
		ifTrue: [	^self setCursorMsg: msgCode hwnd: hwnd
								wParam: wParam lParam: lParam	 ].

	^{{<user ExternalProxy CallWindowProcA> 
		proc: self originalWndProc
		hwnd: hwnd
		msg: msgCode
		wparam: wParam
		lparam: lParam }}! !

"June 6, 2007 -> 1:51:28"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
notificationMsg: notifyCode <ExternalData>

	"Subclasses can extend to process notification msgs"

	Win32Control debugNotifications
			ifTrue: [ Platform errorStream
							show: 'control notification: ';
							print: notifyCode;
							show: ' window: ';
							print: self win32Handle;
							cr ].

	notifyCode @= Win32 BN_KILLFOCUS
		ifTrue: [ "%todo" ].
	notifyCode @= Win32 BN_SETFOCUS
		ifTrue: [ "%todo" ].
! !

"June 6, 2007 -> 1:51:29"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
sendMessage: msg <ExternalData>
wparam: wp <ExternalData>
lparam: lp <ExternalData>
^<ExternalProxy>

	^{{<user ExternalProxy SendMessageA>
			handle: self win32Handle
			msg: msg
			wparam: wp
			lparam: lp}}! !

"June 6, 2007 -> 1:51:30"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
setFocus

	ignoreNextFocusSet := true.
	 self win32Handle @= {{<user ExternalProxy GetFocus> call}}
		ifFalse: [  {{<user ExternalProxy SetFocus> hwnd: self win32Handle}} ]! !

"June 6, 2007 -> 1:51:31"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
win32Handle ^<HWND>

	win32Handle isNil	
		ifTrue: [ self createNativeWindow ].
	^win32Handle! !

"June 6, 2007 -> 1:51:32"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'testing' !
isFocus ^<Boolean>

	^isFocus! !

"June 6, 2007 -> 1:51:52"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 6, 2007 -> 1:51:54"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 6, 2007 -> 1:51:55"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 6, 2007 -> 1:51:56"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 6, 2007 -> 1:51:57"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 6, 2007 -> 1:51:57"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 6, 2007 -> 1:51:58"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 6, 2007 -> 1:51:59"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 6, 2007 -> 1:51:59"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 6, 2007 -> 1:52:0"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 6, 2007 -> 1:52:0"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 6, 2007 -> 1:52:2"!

(Delta mirrorFor: #Window)
comment: 
'Native windows, with a fairly machine independent interface
(except for methods with ''win32'' in their names).

Tags: %User %UI

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.
'!


"June 6, 2007 -> 1:52:3"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'custom messages' !
LAYOUT ^<ExternalData>
	"This is by the UI thread to tell a window's session process to layout a window.  This has
	  to be done through the message queue so that the layout code runs in the window's session
	  process.  lParam low is width, and lParam high is height."

	^16r400! !

"June 6, 2007 -> 1:52:4"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'debugging' !
bufferingPossible ^<Boolean>

	BufferingPossible isNil
		ifTrue: [ BufferingPossible := true ].
	^BufferingPossible! !

"June 6, 2007 -> 1:52:5"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'debugging' !
bufferingPossible: f <Boolean>
	"If this is set to false, all double buffering will be disabled, usually for debugging
		purposes."

	BufferingPossible := f! !

"June 6, 2007 -> 1:52:6"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
defaultWin32Cursor ^<ExternalProxy>

	^{{<user ExternalProxy LoadCursorA> arg: 0 arg: Win32 IDC_ARROW}}! !

"June 6, 2007 -> 1:52:7"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
defaultWin32Icon ^<ExternalProxy>

	^{{<user ExternalProxy LoadIconA> arg: 0 arg: Win32 IDI_APPLICATION}}! !

"June 6, 2007 -> 1:52:8"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
defaultWndProc ^<ExternalProxy>

	"Don't need a critical region because duplicate inits are no problem"
	DefaultWndProc isNil
		ifTrue: [	DefaultWndProc := Platform DLLLookup: 'DefWindowProcA' in: 'user' ].
	^DefaultWndProc! !

"June 6, 2007 -> 1:52:10"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
parentOf: w <HWND> ^<HWND>

	^{{<user ExternalProxy GetParent> wnd: w}}! !

"June 6, 2007 -> 1:52:11"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
wndProcOf: w <HWND> ^<HWND>

	^{{<user ExternalProxy GetWindowLongA> wnd: w attr: Win32 GWL_WNDPROC}}! !

"June 6, 2007 -> 1:52:11"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
wndProcOf: w <HWND> put: newWinProc <HWND> ^<HWND>

	^{{<user ExternalProxy SetWindowLongA> wnd: w attr: Win32 GWL_WNDPROC value: newWinProc}}! !

"June 6, 2007 -> 1:52:12"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
addNonLocalCount: delta <Int>
	
	! !

"June 6, 2007 -> 1:52:14"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
containerBackgroundPainter ^<Painter>

	^Painter defaultBackground! !

"June 6, 2007 -> 1:52:15"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
containsFocus: flag <Boolean>

	flag
		ifTrue: [	self session activeWindow: self.
						self mostRecentInputFocus: session inputFocus.	].
	"We don't need to remove the active window ifFalse because the session does that"! !

"June 6, 2007 -> 1:52:16"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
displayNowIfInvalid
	"Redraw any invalid areas before proceeded"

	self display! !

"June 6, 2007 -> 1:52:18"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
displayPopUpMenu: menu <Menu> at: loc <Point> forButton: button <Symbol>

	| gloc <Point> flags <ExternalData> |
	popUpMenu := menu.

	flags := Win32 TPM_LEFTALIGN.
	button = #left
		ifTrue: [ flags := flags externalBitOr: Win32 TPM_LEFTBUTTON ]
		ifFalse: [ flags := flags externalBitOr: Win32 TPM_RIGHTBUTTON ].

	gloc := self globalFromLocalPosition: loc.
	{{<user ExternalProxy TrackPopupMenu>
		handle: menu win32Handle
		flags: flags
		x: gloc x
		y: gloc y
		reserved: 0
		window: self win32Handle
		rect: Win32 NULL
	}} asBoolean
		ifFalse: [ Win32 getLastError @= Win32 ERROR_POPUP_ALREADY_ACTIVE
							ifFalse: [ Win32 handleError ].
						].

	popUpMenu := nil.
! !

"June 6, 2007 -> 1:52:19"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
invalidate: r <Region> forChild: child <Visual>

	self invalidate: (r enclosingRect translatedBy: child position)! !

"June 6, 2007 -> 1:52:20"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
isAttached ^<Boolean>

	^true! !

"June 6, 2007 -> 1:52:21"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
nativeWindow ^<Window | Win32Control>

	^self! !

"June 6, 2007 -> 1:52:22"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
parentVisualOfChild ^<Visual>

	self shouldNotHappen! !

"June 6, 2007 -> 1:52:24"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
popUpMenuIfAbsent: f <[^X def]> ^<Menu | X>

	^f value! !

"June 6, 2007 -> 1:52:25"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
positionInContainingNativeWindowOf: child <Visual> ^<Point>

	^child position! !

"June 6, 2007 -> 1:52:26"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
positionInTopWindowOf: child <Visual>

	^child position! !

"June 6, 2007 -> 1:52:28"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
scrollIfNeededToMakeVisible: area <Rect>
relativeTo: v <Visual>
minimizeMotion: minimizeMotion <Boolean>


	! !

"June 6, 2007 -> 1:52:29"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
scrollMeOrAParentBy: distance <Int> vertical: vertical <Boolean>

	"do nothing"! !

"June 6, 2007 -> 1:52:30"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
topWindow ^<Window>

	^self! !

"June 6, 2007 -> 1:52:31"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
translate: p <Point> fromChild: child <Visual> ^<Point>

	"Translate p from the child's coordinates to ours"
	^p translatedBy: child position! !

"June 6, 2007 -> 1:52:33"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
translate: p <Point> toChild: child <Visual> ^<Point>

	"Translate p from our coordinates to the child's"
	^p relativeTo: child position! !

"June 6, 2007 -> 1:52:34"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
translateRect: r <Rect> fromChild: child <Visual> ^<Rect>

	"Translate p from the child's coordinates to ours"
	^r translatedBy: child position! !

"June 6, 2007 -> 1:52:35"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
translateRect: r <Rect> toChild: child <Visual> ^<Rect>

	"Translate p from the child's coordinates to ours"
	^r relativeTo: child position! !

"June 6, 2007 -> 1:52:36"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
allocation ^<Region>

	^Point origin corner: self extent! !

"June 6, 2007 -> 1:52:38"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
backgroundPainter ^<Painter>
	"The paint for the window background.  This can be automatically derived from the
	 background painter for the visual.  It can also be set explicitly."

	^self hasBackgroundPainter
		ifTrue: [ backgroundPainter ]
		ifFalse: [ backgroundPainter := self visual backgroundPainter ]! !

"June 6, 2007 -> 1:52:39"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
backgroundPainter: p <Painter>

	backgroundPainter := p! !

"June 6, 2007 -> 1:52:40"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
cursor ^<Cursor>

	^cursor! !

"June 6, 2007 -> 1:52:42"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
cursor: c <Cursor>

	cursor := c.! !

"June 6, 2007 -> 1:52:43"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
desiredPosition: p <Point>

	desiredPosition := p! !

"June 6, 2007 -> 1:52:44"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
enabled ^<Boolean>

	^enabled! !

"June 6, 2007 -> 1:52:45"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
enabled: flag <Boolean>

	self enabled = flag
		ifFalse: [	self setEnabled: flag ].! !

"June 6, 2007 -> 1:52:46"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
extent ^<Point>

	^extent! !

"June 6, 2007 -> 1:52:48"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
hasParent ^<Boolean>

	^parent notNil! !

"June 6, 2007 -> 1:52:49"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
hasSession ^<Session>

	^session notNil! !

"June 6, 2007 -> 1:52:50"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
hasWin32Handle ^<Boolean>

	^win32Handle notNil! !

"June 6, 2007 -> 1:52:51"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
initialInputFocus: v <Visual>

	initialInputFocus := v! !

"June 6, 2007 -> 1:52:53"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
max ^<Rect>

	^max! !

"June 6, 2007 -> 1:52:54"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
medium ^<Medium>

	^medium! !

"June 6, 2007 -> 1:52:55"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
menu ^<Menu>

	^menu! !

"June 6, 2007 -> 1:52:56"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
menu: m <Menu>

	menu isNil
		ifFalse: [ menu release ].
	menu := m.
	menu window: self.
	self hasWin32Handle
		ifTrue: [ self setNativeMenu ]! !

"June 6, 2007 -> 1:52:58"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
min ^<Rect>

	^min! !

"June 6, 2007 -> 1:52:59"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
mostRecentInputFocus: v  <Visual>

	mostRecentInputFocus := v! !

"June 6, 2007 -> 1:53:0"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
name: nm <Str>

	"By default, do nothing. Subclasses with a title bar can override this"! !

"June 6, 2007 -> 1:53:1"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
natural ^<Rect>

	^natural! !

"June 6, 2007 -> 1:53:2"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
noPalette

	palette := nil! !

"June 6, 2007 -> 1:53:4"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
optimizeIncrementalLayout ^<Boolean>
^false.
	^optimizeIncrementalLayout! !

"June 6, 2007 -> 1:53:5"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
optimizeIncrementalLayout: f <Boolean>

	(f ~= optimizeIncrementalLayout and: [ self hasWin32Handle ])
		ifTrue: [ self changing ].
	optimizeIncrementalLayout := f.! !

"June 6, 2007 -> 1:53:6"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
palette ^<Palette>

	^palette! !

"June 6, 2007 -> 1:53:7"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
palette: p <Palette>

	p == palette
		ifTrue: [ ^self ].
	self assert: [ palette isNil ].
	palette := p! !

"June 6, 2007 -> 1:53:9"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
parent ^<Window>

	^parent! !

"June 6, 2007 -> 1:53:10"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
parent: p <Window>
	"This message must be sent before the window handle is created"

	parent := p! !

"June 6, 2007 -> 1:53:11"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
refreshInterval ^<Float>

	^refreshInterval! !

"June 6, 2007 -> 1:53:12"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
refreshInterval: d <Float>
	"Wait no longer than this amount of time (in seconds) between
		paint operations, if possible"

	refreshInterval := d! !

"June 6, 2007 -> 1:53:13"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
session ^<Session>

	^session! !

"June 6, 2007 -> 1:53:15"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
setNativeMenu

	{{<user ExternalProxy SetMenu>
		wnd: self win32Handle
		menu: self menu win32Handle
	}} asBoolean
		ifFalse: [ Win32 handleError ]! !

"June 6, 2007 -> 1:53:16"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
toClose ^<[Window]>

	^toClose! !

"June 6, 2007 -> 1:53:17"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
toClose: blk <[Window]>

	toClose := blk! !

"June 6, 2007 -> 1:53:19"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
useDisplayBuffering ^<Boolean>

	^useDisplayBuffering! !

"June 6, 2007 -> 1:53:20"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
useDisplayBuffering: f <Boolean>

	useDisplayBuffering := f! !

"June 6, 2007 -> 1:53:21"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
visual ^<Visual>

	^visual! !

"June 6, 2007 -> 1:53:22"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
close
	"Close and destroy the window.  This causes release to be sent to the window and its visual"

	self session aboutToDestroyWindow: self.
	{{<user ExternalProxy DestroyWindow> arg: win32Handle}}.
! !

"June 6, 2007 -> 1:53:24"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
ignoreNextFocusSet: flag <Boolean>

	ignoreNextFocusSet := flag! !

"June 6, 2007 -> 1:53:25"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
invalidate

	self visual layoutStatus > Visual invalid
		ifTrue: [ self invalidate: self allocation enclosingRect	].! !

"June 6, 2007 -> 1:53:27"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
invalidate: r <Region>

	| rect <Rect> |

	self registerPaintTime.
	rect := r enclosingRect.
	(self scratchRECT)
		left: rect left asInteger;
		right: rect right asInteger;
		top: rect top asInteger;
		bottom: rect bottom asInteger.
	{{<user ExternalProxy InvalidateRect>
		hwnd: self win32Handle
		RECT: self scratchRECT
		erase: false asExternalData}}! !

"June 6, 2007 -> 1:53:28"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
makeActive
	"Make this the active window"

	{{<user ExternalProxy SetForegroundWindow> hwnd: self win32Handle }}.! !

"June 6, 2007 -> 1:53:29"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
release

	scratchRECT free.

	self session unregisterWindow: self.

	visual notNil
		ifTrue: [	visual detaching; release.
						visual := nil.	].

	win32Handle := nil.

	self hasMenu
		ifTrue: [ self menu release ].
	mostRecentInputFocus := nil.
	menu := nil.
	popUpMenu := nil.
	toClose := nil.
	controls := nil.
! !

"June 6, 2007 -> 1:53:30"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
requestClose

	self toClose value: self.! !

"June 6, 2007 -> 1:53:31"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
show
	"Make the window visible"

	{{<user ExternalProxy ShowWindow>
			window: self win32Handle
			nCmdShow: self nCmdShow}}.
	! !

"June 6, 2007 -> 1:53:33"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
showModal
	"Make the window visible as a modal window"

	self session addModalWindow: self.
	self show.
	! !

"June 6, 2007 -> 1:53:34"!

! (Delta mirrorFor: #Window) methodsFor: 'debugging' !
dumpOn: strm <CharOutputStream>

Transcript show: self class name, ' extent: '; print: self extent; show: ' hwnd: '; print: self win32Handle; cr.
	self visual dumpOn: strm indent: 1.! !

"June 6, 2007 -> 1:53:36"!

! (Delta mirrorFor: #Window) methodsFor: 'event handling' !
character: c <Character> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	^(self visual character: c focus: focus event: ev)
		or: [	c = Character tab
					onTrue: [ self handleTabEvent: ev ] ]! !

"June 6, 2007 -> 1:53:37"!

! (Delta mirrorFor: #Window) methodsFor: 'event handling' !
keyDown: key <Symbol> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	(self visual keyDown: key focus: focus event: ev)
		ifTrue: [ ^true ].
		
	(key = #TAB and: [ ev ctrlPressed ])
		ifTrue: [ self handleTabEvent: ev.	^true ].
	key = #F1 ifTrue: [ Profiler start.	^true ].
	key = #F2 ifTrue: [ Profiler stop.	^true ].
	^false	! !

"June 6, 2007 -> 1:53:38"!

! (Delta mirrorFor: #Window) methodsFor: 'event handling' !
keyUp: key <Symbol> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	^self visual keyUp: key focus: focus event: ev
! !

"June 6, 2007 -> 1:53:40"!

! (Delta mirrorFor: #Window) methodsFor: 'event handling' !
mouseEvent: type <Symbol> at: loc <Point> event: ev <UIEvent> ^<Boolean>

	^self visual layoutStatus = Visual valid
		and: [ 	| grabGotIt <Boolean> |
						grabGotIt := self session
												mouseEvent: type
												at: loc
												event: ev.
						grabGotIt or: [	(self visual renderingRegion inParentContainsPoint: loc)
												and: [	Sampler notNil
																ifTrue: [ Sampler in: self visual sampleEvent: type at: loc - self visual position event: ev ].
															self visual
																mouseEvent: type
																at: loc - self visual position
																event: ev	] ] ]
! !

"June 6, 2007 -> 1:53:41"!

! (Delta mirrorFor: #Window) methodsFor: 'initialization' !
initSession: sess <Session>
visual: vis <Visual>

	medium := sess medium.
	session := sess.
	visual := vis.

	(self visual)
		parent: self id: 1.

	self showTimes
		ifTrue: [ Transcript show: 'prefs: '; print: [ self computePreferences ] time; cr. ]
		ifFalse: [ self computePreferences ].

	scratchRECT := RECT new allocate.
	self optimizeIncrementalLayout: true.
	ignoreNextFocusSet := false.

	self refreshInterval: self defaultRefreshInterval.
	self paintPending: false.
	self useDisplayBuffering: true.

	self toClose: [ :w <Window> | w close ].
	self enabled: true.
	controls := IdentitySet[Win32Control] new.
	self haveErased: false.! !

"June 6, 2007 -> 1:53:42"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
activeMenu ^<Menu>
	"Returns the menu that is currently active, if there is one.  It may either be the top level menu,
	  or a popup menu over the window"

	^popUpMenu notNil
		ifTrue: [ popUpMenu ]
		ifFalse: [ menu ]! !

"June 6, 2007 -> 1:53:44"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
beforeQueuedMessage

	"%remove this and calls to it"! !

"June 6, 2007 -> 1:53:45"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
beforeSetFocus

	ignoreNextFocusSet
		ifTrue: [	"We requested the focus, and have already recorded it, so
							ignore this."
						ignoreNextFocusSet := false.	]
		ifFalse: [	self visual layoutValid
							ifTrue: [	"We didn't request this, so windows must be requesting it, so
												record it"
											self findInputFocus	]	].! !

"June 6, 2007 -> 1:53:46"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
beginPaint: hwnd <HWND>  paintStructure: ps <PAINTSTRUCT>  ^<HDC>

	^{{<user HDC BeginPaint> arg: hwnd arg: ps}}! !

"June 6, 2007 -> 1:53:47"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
buildWin32Handle
	"Subclasses must implement to create the appropriate type of window handle &
	  store it in win32Handle"

	self subclassResponsibility! !

"June 6, 2007 -> 1:53:49"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
callAsyncDefWndProcFor: hwnd <HWND>
msgCode: msgCode <ExternalData>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>
	"like callDefWndProcFor:msgCode:wParam:lParam:
			but is asynchronous"

	^{{<user ExternalProxy DefWindowProcA async>
			hwnd: hwnd
			value: msgCode
			value: wParam
			value: lParam
	  }}! !

"June 6, 2007 -> 1:53:50"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
callDefWndProcFor: hwnd <HWND>
msgCode: msgCode <ExternalData>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^{{<user ExternalProxy DefWindowProcA>
			hwnd: hwnd
			value: msgCode
			value: wParam
			value: lParam
	  }}! !

"June 6, 2007 -> 1:53:51"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
computePreferences

	natural := Point origin corner: self visual natural enclosingRect extent.
	min := Point origin corner: self visual min enclosingRect extent.
	max := Point origin corner: self visual max enclosingRect extent.! !

"June 6, 2007 -> 1:53:52"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
controls ^<Extensible[Win32Control]>

	^controls! !

"June 6, 2007 -> 1:53:53"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
defaultRefreshInterval ^<Float>

	^0.25! !

"June 6, 2007 -> 1:53:55"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
defaultWndProc ^<ExternalProxy>

	^self actualClass defaultWndProc! !

"June 6, 2007 -> 1:53:56"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
deferredPaintRegion ^<Rect>

	^deferredPaintRegion! !

"June 6, 2007 -> 1:53:57"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
deferredPaintRegion: r <Rect>

	deferredPaintRegion := r! !

"June 6, 2007 -> 1:53:58"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
desiredXPos ^<ExternalData>

	^desiredPosition isNil
		ifFalse: [ desiredPosition x asInteger ]
		ifTrue: [  Win32 CW_USEDEFAULT ]! !

"June 6, 2007 -> 1:54:0"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
desiredYPos ^<ExternalData>

	^desiredPosition isNil
		ifFalse: [ desiredPosition y asInteger ]
		ifTrue: [  Win32 CW_USEDEFAULT ]! !

"June 6, 2007 -> 1:54:1"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
display

	| subs <Cltn[Win32Control]> |
	self withCanvasDo:
			[ :can <Canvas> |
				| paintBlk <[^Object]> |	
				paintBlk := 
					[	self paintBackgroundOn: can.
						self displayVisualIfCanOn: can.
						can shallowFlush.  ].
				self showTimes
					ifTrue: [  Transcript show: 'paint: '; print: paintBlk time; cr. ]
					ifFalse: [ paintBlk value ].
				can hasSubwindowsToDisplay
					ifTrue: [ subs := can takeSubwindowsToDisplay ].
			].
	subs notNil
		ifTrue: [	subs do:
							[ :sub <Win32Control> |
								"%hack: the handle test should not be 
									necessary; something is screwed up"
								sub hasWin32Handle
									ifTrue: [	sub sendMessage: Win32 WM_PAINT
														wparam: 0 lparam: 0.
												].
							].
					 ]! !

"June 6, 2007 -> 1:54:3"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
displayVisualIfCanOn: canvas <Canvas>

	self session visualCriticalWouldBlock
		ifTrue: [ self recordDeferredPaint: canvas clippingRect ]
		ifFalse: [	self paintOccuring.
						self visual displayOn: canvas.	]! !

"June 6, 2007 -> 1:54:4"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
endPaint: hwnd <HWND>  paintStructure: ps <PAINTSTRUCT>

	^{{<user ExternalProxy EndPaint> arg: hwnd arg: ps}}! !

"June 6, 2007 -> 1:54:5"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
extent: e <Point>
	"Change the window's extent.  This will cause a relayout
		to happen later, which will record the extent."

	| pos <Point> adjusted <Rect> |
	adjusted := self fitToMedium: e.
	pos := self getPosition.
	{{<user ExternalProxy MoveWindow>
		hwnd: self win32Handle
		x: pos x
		y: pos y
		width: adjusted x
		height: adjusted y
		repaint: true asExternalData
	}} asBoolean 
		ifFalse: [ Win32 handleError ].! !

"June 6, 2007 -> 1:54:6"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
findInputFocus

	"find some non-native visual
	  within us to give the input focus to."

	"If there is already a focus, and it is in this window, then we are in a callback caused
	  by our own attempt to set the focus, so do nothing."
	(self session hasInputFocus and: [ self session inputFocus nativeWindow = self ])
		ifTrue: [ ^self ].

	"If we have a valid memory of what our input focus was last time, use it"
	self purgeMostRecentFocusIfNeeded.
	(mostRecentInputFocus notNil and: [ mostRecentInputFocus topWindow = self ])
		ifTrue: [ "Search to see if the most recent one is still a reachable, valid candidate"
					 "%todo: we could optimize this by adding another call to the heirarchy called
						verifyFocusCandidate which sends verifyFocusCandidate:self up the heirarchy,
						giving pacifiers etc. a chance to deny it the focus.  This would be MUCH faster
						than the following loop."
					"Also note that we use session inputFocus: rather than becomeFocus, because this
						 thing was previously the focus, so we don't want to do things like scroll it"
					 self visual focusCandidatesDo:
						[ :cand <Visual> |
							cand = mostRecentInputFocus
								ifTrue: [	self session inputFocus: cand.

												^self		"^^^^^^^^^^^^^"		] ]. ].

	"There is no valid previous focus to reuse, so just choose the first one"
	(self visual firstFocusCandidateIfAbsent: [ ^self ])
		becomeFocus.
! !

"June 6, 2007 -> 1:54:8"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
fitToMedium: clientExtent <Point>  ^<Point>
	"takes a client extent, and returns a window extent adjusted so that it will fit on the screen"

	| normal <Point> withoutCaption <Point> captionHeight <Int> adjClient <Point> |	
	normal := (self windowSizeForClientAreaSize: clientExtent) min: self medium extent.
	withoutCaption := (self windowSizeWithoutCaptionForClientAreaSize: clientExtent) min: self medium extent.
	captionHeight := normal y - withoutCaption y.
	^self windowSizeForClientAreaSize:
			 (clientExtent x min: self medium extent x)
		@ ((clientExtent y + captionHeight min: self medium extent y) - captionHeight).! !

"June 6, 2007 -> 1:54:9"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
getPosition ^<Point>

	{{<user ExternalProxy GetWindowRect>
		hwnd: self win32Handle
		rect: self scratchRECT
	}} asBoolean
		ifFalse: [ Win32 handleError ].
	^self scratchRECT left @ self scratchRECT top! !

"June 6, 2007 -> 1:54:11"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
globalFromLocalPosition: p <WinPOINT> ^<WinPOINT>

	| wp <WinPOINT> result <WinPOINT> |
	wp := WinPOINT new allocate.
	wp x: p x; y: p y.
	{{<user ExternalProxy ClientToScreen>
			handle: self win32Handle
			point: wp
	}} asBoolean
		ifFalse: [ Win32 handleError ].
	result := wp x @ wp y.
	wp free.
	^result! !

"June 6, 2007 -> 1:54:12"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
handleTabEvent: ev <UIEvent>

	ev shiftPressed
		ifTrue: [ self moveFocusBack ]
		ifFalse: [ self moveFocusForward ]! !

"June 6, 2007 -> 1:54:13"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
hasBackgroundPainter ^<Boolean>

	^backgroundPainter notNil! !

"June 6, 2007 -> 1:54:14"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
hasMenu ^<Boolean>
	"Returns the menu that is currently active, if there is one.  It may either be the top level menu,
	  or a popup menu over the window"

	^popUpMenu notNil or: [ menu notNil ]! !

"June 6, 2007 -> 1:54:15"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
haveErased ^<Boolean>

	^haveErased! !

"June 6, 2007 -> 1:54:17"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
haveErased: f <Boolean>

	haveErased := f! !

"June 6, 2007 -> 1:54:19"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
initWindowsMessageHandlers

	WindowsMessageHandlers
		at: Win32 WM_CLOSE	put:
				[ :w <Window> :msg  <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w closeMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_SETCURSOR	put:
				[ :w <Window> :msg  <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w setCursorMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_PAINT	put:
				[ :w <Window> :msg  <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w paintMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_ERASEBKGND	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w eraseBackgroundMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_CTLCOLORBTN	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w buttonColorMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_DRAWITEM	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w drawItemMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_KEYDOWN	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w keyDownMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_KEYUP	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w keyUpMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_CHAR	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w characterMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];

		"mouse events are handled by a common event routine"
		at: Win32 WM_LBUTTONDOWN put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #primaryButtonDown at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_LBUTTONUP	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #primaryButtonUp at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_LBUTTONDBLCLK	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #primaryButtonDoubleClick at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_MBUTTONDOWN	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #middleButtonDown at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_MBUTTONUP	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #middleButtonUp at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_RBUTTONDOWN put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #secondaryButtonDown at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_RBUTTONUP put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #secondaryButtonUp at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_RBUTTONDBLCLK put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #secondaryButtonDoubleClick at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_MOUSEMOVE put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #mouseMove at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];

		at: Win32 WM_MEASUREITEM	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w measureItemMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_SETFOCUS	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w setFocusMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_KILLFOCUS	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w killFocusMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_COMMAND	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w commandMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_GETMINMAXINFO	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w getMinMaxInfoMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_SIZE	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w sizeMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_NCDESTROY	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w ncDestroyMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_DESTROY	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w destroyMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_CAPTURECHANGED	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w captureChangedMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_INITMENUPOPUP	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w initMenuPopupMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_QUERYNEWPALETTE	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w queryPaletteMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_PALETTECHANGED	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w paletteChangedMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];

		"---------- Custom messages"
		at: Window LAYOUT	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w layoutMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];

		yourself! !

"June 6, 2007 -> 1:54:21"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
initialInputFocus ^ <Visual>

	^initialInputFocus! !

"June 6, 2007 -> 1:54:22"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
layout: extent <Point>

	| firstLayout <Boolean> |

	firstLayout := self visual layoutStatus = Visual invalid.
 	self showTimes
		ifTrue: [	Transcript show: 'layout: '; print: [ 
								self visual allocationInParent: (0@0 corner: extent).
						] time; cr. ]
		ifFalse: [	self visual allocationInParent: (0@0 corner: extent). ].

	"We have to do this now because we can't set the input focus until layout is
		complete, since the containing native window must be accessed, etc."
	firstLayout
		ifTrue: [	self palette notNil
							ifTrue: [ self recursiveRealizePaletteForeground: true updateColors: true. ].
						(self initialInputFocus notNil and: [ self initialInputFocus isFocusCandidate ])
							ifTrue: [		self initialInputFocus becomeFocus.
												self initialInputFocus: nil 	"Not needed anymore, prevent memory leak"	]
							ifFalse: [	self findInputFocus ]
					  ]! !

"June 6, 2007 -> 1:54:23"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
localFromGlobalPosition: p <WinPOINT> ^<WinPOINT>

	| wp <WinPOINT> result <WinPOINT> |
	wp := WinPOINT new allocate.
	wp x: p x; y: p y.
	{{<user ExternalProxy ScreenToClient>
			handle: self win32Handle
			point: wp
	}} asBoolean
		ifFalse: [ Win32 handleError ].
	result := wp x @ wp y.
	wp free.
	^result! !

"June 6, 2007 -> 1:54:25"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
menuCommandForItem: id <Int>

	(MenuItem itemFor: id)
		execute! !

"June 6, 2007 -> 1:54:26"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
moveFocusBack

	(self visual lastFocusCandidateBefore: self session inputFocus)
		becomeFocus! !

"June 6, 2007 -> 1:54:27"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
moveFocusForward

	(self visual nextFocusCandidateAfter: self session inputFocus)
		becomeFocus! !

"June 6, 2007 -> 1:54:28"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
nCmdShow ^<ExternalProxy>

	^{{primitiveWindowsNCmdShow}}! !

"June 6, 2007 -> 1:54:30"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
nextPaintTime ^<Float>

	^nextPaintTime! !

"June 6, 2007 -> 1:54:31"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
nextPaintTime: t <Float>

	nextPaintTime := t! !

"June 6, 2007 -> 1:54:32"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
paintBackgroundOn: can <Canvas>

	can withPainter: self backgroundPainter do:
		[ can displayFilledRectangle:
			(Point origin corner: self allocation enclosingRect extent) ].! !

"June 6, 2007 -> 1:54:34"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
paintOccuring

	self nextPaintTime: Time clockValue + self refreshInterval.
	self paintPending: false.
	self session paintOccuredFor: self.! !

"June 6, 2007 -> 1:54:35"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
parentHandle ^<ExternalData>

	^parent isNil
		ifFalse: [ parent win32Handle ]
		ifTrue: [ Win32 NULL ]! !

"June 6, 2007 -> 1:54:36"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
purgeMostRecentFocusIfNeeded

	"%kludge: This should be called occasionally (in user time) to avoid memory leaks caused by
	  a pointer to a zombie visual"
	"%todo: this isn't called yet.  Set up a scanner that sends this to all windows every ten seconds or
	   so."
	(mostRecentInputFocus notNil and: [ mostRecentInputFocus isAttached not ])
		ifTrue: [ mostRecentInputFocus := nil ]! !

"June 6, 2007 -> 1:54:37"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
recordDeferredPaint: region <Rect> 

	self deferredPaintRegion:
		(self deferredPaintRegion isNil
			ifTrue: [ region ]
			ifFalse: [ self deferredPaintRegion merge: region ]
		)! !

"June 6, 2007 -> 1:54:38"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
recordExtent

		self setExtent: self trueClientAreaExtent.! !

"June 6, 2007 -> 1:54:40"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
registerPaintTime

	self paintPending
		ifFalse: [	self paintPending: true.
						self nextPaintTime: Time clockValue + self refreshInterval.
						self session schedulePaintFor: self at: self nextPaintTime.	].! !

"June 6, 2007 -> 1:54:41"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
relayoutIfNeeded

	self relayoutIfNeededForExtent: self extent! !

"June 6, 2007 -> 1:54:42"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
relayoutIfNeededForExtent: e <Point>

	self visual needsRelayout
		ifTrue: [ self layout: (self visual max enclosingRect extent min: e) ].
	self invalidate.! !

"June 6, 2007 -> 1:54:44"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
scratchRECT ^<RECT>

	^scratchRECT! !

"June 6, 2007 -> 1:54:45"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
setCursor ^<ExternalData>

	^cursor isNil
		ifFalse: [	{{<user ExternalProxy SetCursor> handle: cursor win32Handle}}.
						1 ]
		ifTrue: [ 0 ]! !

"June 6, 2007 -> 1:54:46"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
setEnabled: flag <Boolean>

	enabled := flag.
	self hasWin32Handle
		ifTrue: [	{{<user ExternalProxy EnableWindow async>
								handle: self win32Handle
								state: enabled asExternalData}}.	].! !

"June 6, 2007 -> 1:54:47"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
setExtent: e <Point>

	extent := e! !

"June 6, 2007 -> 1:54:49"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
setName: nm <Str>

	self hasWin32Handle
		ifTrue: [	| title <CString> |
						title := CString for: nm.
						[	{{<user ExternalProxy SetWindowTextA>
											hwnd: self win32Handle
											title: title
							}} asBoolean
								ifFalse: [ Win32 handleError ].
						] ensure: [ title free ]
					 ]! !

"June 6, 2007 -> 1:54:51"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
shouldCallDefaultHandlerAsynchronouslyFor: msgCode <ExternalData>  ^<Boolean>

	^msgCode @= Win32 WM_SYSCOMMAND		"so that window moves let other sessions repaint"! !

"June 6, 2007 -> 1:54:52"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
showTimes ^<Boolean>
	"Report preference, layout, and painting times on the transcript"

	^false! !

"June 6, 2007 -> 1:54:53"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
trueClientAreaExtent ^<Point>

	^self trueClientAreaExtentFor: self win32Handle! !

"June 6, 2007 -> 1:54:54"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
trueClientAreaExtentFor: hwnd <ExternalData> ^<Point>

	| extent <Point> rect <RECT> |
	rect := RECT new allocate.
	{{<user RECT GetClientRect> arg: hwnd arg: rect}}.
	extent := (rect right - rect left) @ (rect bottom - rect top).
	rect free.
	^extent! !

"June 6, 2007 -> 1:54:55"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
win32Handle: h <HWND>

	win32Handle := h! !

"June 6, 2007 -> 1:54:56"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
win32Style ^<ExternalData>

	| s <ExternalData> |
	s := 0.
	self enabled
		ifFalse: [ s := s externalBitOr: Win32 WS_DISABLED ].
	^s
! !

"June 6, 2007 -> 1:54:58"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
windowSizeForClientAreaSize: extent <Point>  ^<Point>
	"returns an integral point that is the correct window size for a desired client area size"

	^self windowSizeForClientAreaSize: extent windowStyle: self win32Style! !

"June 6, 2007 -> 1:54:59"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
windowSizeForClientAreaSize: extent <Point> windowStyle: style <ExternalData>  ^<Point>
	"returns an integral point that is the correct window size for a desired client area size"

	| r <RECT> result <Point> |
	r := RECT new allocate.
	r top: 0; left: 0; right: extent x asInteger; bottom: extent y asInteger.
	{{<user ExternalProxy AdjustWindowRect>
				 rect: r style: style hasMenu: self hasMenu asExternalData}} asBoolean
		ifFalse: [ Win32 handleError ].
	result := (r right - r left) @ (r bottom - r top).
	r free.
	^result! !

"June 6, 2007 -> 1:55:1"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
windowSizeWithoutCaptionForClientAreaSize: extent <Point>  ^<Point>
	"returns an integral point that is the correct window size for a desired client area size"

	^self windowSizeForClientAreaSize: extent
			windowStyle: (self win32Style externalBitAnd: (Win32 WS_CAPTION asSmallInteger bitInvert))! !

"June 6, 2007 -> 1:55:2"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
windowsMessageHandlers ^<Dict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>

	"Don't need critical region since duplicate inits are no problem"
	WindowsMessageHandlers isNil
		ifTrue: [	WindowsMessageHandlers :=
							CustomDictionary[ExternalData,[Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData]]
									withCompareBlock: [ :k1 <ExternalData> :k2 <ExternalData> |    k1 @= k2 ]
									hashBlock: [ :k <ExternalData> |  k hash ].
						self initWindowsMessageHandlers.
						].
	^WindowsMessageHandlers! !

"June 6, 2007 -> 1:55:4"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
withBufferedCanvasDo: drawing <[Canvas,^X def]> ^<X>

	^self withDirectCanvasDo:
		[ :directCanvas <Canvas> |
			| invalid <Rect> oldpal <Win32Handle> |
			invalid := directCanvas clippingRect.

			self session
				withBufferCanvasFor: invalid
				do: [ :bufferCanvas <Canvas> :buffer <HBITMAP> |

						self palette isNil
							ifFalse: [ oldpal := bufferCanvas win32Palette: self palette win32Handle ].

						"draw on the buffer canvas"
						drawing value: bufferCanvas.
						bufferCanvas shallowFlush.

						"Now, copy the buffer bits onto the screen"
						directCanvas atOffset: invalid origin
							do: [ bufferCanvas atOffset: invalid origin 
								do: [	directCanvas
											bitBlt: bufferCanvas
											extent: invalid extent
											op: UI ropCopy.		].	].
						 oldpal notNil
								ifTrue: [ 	Palette debugging
													ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
												bufferCanvas win32Palette: oldpal ]. 
						].	
		]! !

"June 6, 2007 -> 1:55:5"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
withCanvasDo: drawing <[Canvas,^X def]> ^<X>

	^(self useDisplayBuffering and: [ Window bufferingPossible ])
		ifFalse: [	self withDirectCanvasDo: drawing ]
		ifTrue: [	self withBufferedCanvasDo: drawing ]! !

"June 6, 2007 -> 1:55:6"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
withDCDo: blk <[HDC]>
	"With the window's device context do the block (not for painting)"

	| hdc <HDC> |
	hdc := {{<user HDC GetDC> hwnd: self win32Handle}}.
	[ blk value: hdc ]
		ensure: [ hdc releaseDCFor: self win32Handle ]! !

"June 6, 2007 -> 1:55:8"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
withDirectCanvasDo: drawing <[Canvas,^X def]> ^<X>

	|	can <Canvas>
		ps <PAINTSTRUCT>
		paintBlk <[^Object]>
		result <X>
		oldpal <Win32Handle> |

	"use a critical region to paint, since background painting might reuse the
	  same device context in the UI thread"
	^self critical:
		[	ps := PAINTSTRUCT new allocateZeroed.
			can := self beginPaint: self win32Handle paintStructure: ps.
			can isNull
				ifTrue: [ Win32 handleError ].
			can	initialize;
				toRelease: [ :dc <HDC> | "End paint will release the context" ];
				initClippingRectBeforeTranslation: ps rcPaint asRectangle;
				window: self.
			self palette isNil
				ifFalse: [ oldpal := can win32Palette: self palette win32Handle ].

			Session debugInvalidation
				ifTrue: [	can withPainter: (Painter new paint: Paint red)
									do: [ can displayFilledRectangle: ps rcPaint asRectangle; flush. ].
								Platform errorStream show: self class name, ' rendering: '; print: ps rcPaint asRectangle; cr.	].

			result := drawing value: can.
			oldpal notNil
				ifTrue: [ 	Palette debugging
									ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
								can win32Palette: oldpal ]. 
			can release. 

			self endPaint: self win32Handle paintStructure: ps.
			ps free.
			result	]! !

"June 6, 2007 -> 1:55:9"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
wndProc ^<APICallback>

	^self session wndProc! !

"June 6, 2007 -> 1:55:11"!

! (Delta mirrorFor: #Window) methodsFor: 'private-testing' !
paintPending ^<Boolean>

	^paintPending! !

"June 6, 2007 -> 1:55:12"!

! (Delta mirrorFor: #Window) methodsFor: 'private-testing' !
paintPending: b <Boolean>

	paintPending := b! !

"June 6, 2007 -> 1:55:13"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
changing

	self session changing: self.
	self session recordPrefsFor: self.
	natural := min := max := nil.! !

"June 6, 2007 -> 1:55:15"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
checkLayout: oldPrefs <SeqCltn[Region]>

	| oldNat <Rect> alloc <Rect> nat <Rect> ext <Point> |
	oldNat := (oldPrefs at: 2) enclosingRect.
	self computePreferences.
	nat := self natural enclosingRect.
	alloc := self allocation enclosingRect.

	"We have to do the relayout eagerly, even before the size message
			comes back, because the caller assumes that layout is then done."

	((alloc contains: self min enclosingRect)
			and: [ self max enclosedRect contains: alloc ]
	)	ifFalse: [	"We definitely have to change our size"
							self relayoutIfNeededForExtent: nat extent.
							self extent: nat extent.
							^self	].

	(self optimizeIncrementalLayout
			or: [ nat = oldNat
			or: [	alloc contains: nat ] ])
		ifTrue: [	self relayoutIfNeededForExtent: self extent.
						^self ].

	ext := (nat width max: alloc width) @ (nat height max: alloc height).
	self relayoutIfNeededForExtent: ext.
	self extent: ext.! !

"June 6, 2007 -> 1:55:16"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
checkPaintTime: t <Float>
	"If we have reached our refresh time, paint"
	
"%todo: figure out how to remove the following %hack
		this should not be sent after the receiver is released)"	
visual isNil ifTrue: [ ^self ].

	(self hasWin32Handle and: [ self paintPending ])
		ifTrue: [ self nextPaintTime <= t
						ifTrue: [ self display ]
						ifFalse: [ self session needPaintAtTime: self nextPaintTime ]	 ]! !

"June 6, 2007 -> 1:55:18"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
oldcheckLayout: oldPrefs <SeqCltn[Region]>

	| oldNat <Rect> alloc <Rect> nat <Rect> |
	oldNat := (oldPrefs at: 2) enclosingRect.
	self computePreferences.
	nat := self natural enclosingRect.
	alloc := self allocation enclosingRect.

	"We have to do the relayout eagerly, even before the size message
			comes back, because the caller assumes that layout is then done."
	self relayoutIfNeeded.

	((alloc contains: self min enclosingRect)
			and: [ (self max enclosedRect contains: alloc)
			and: [ self optimizeIncrementalLayout
							or: [ nat = oldNat
							or: [	alloc contains: nat ] ] ] ]
	)	ifFalse: [	"We definitely have to change our size"
						self setExtent: nat extent.	].
! !

"June 6, 2007 -> 1:55:19"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
prefs ^<SeqCltn[Region]>

	^Array[Region] with: self min with: self natural with: self max! !

"June 6, 2007 -> 1:55:20"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
prefsStatus ^<Int>

	^Visual valid! !

"June 6, 2007 -> 1:55:21"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
prerecordPrefsIfNeeded

	"nothing to do"! !

"June 6, 2007 -> 1:55:22"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
processDeferredPainting

	self deferredPaintRegion notNil
		ifTrue: [	self invalidate: self deferredPaintRegion.
						self deferredPaintRegion: nil.		]! !

"June 6, 2007 -> 1:55:24"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
removeParentsFrom: leaves <Set[RelayoutTarget]>
alreadyChecked: checked <Set[RelayoutTarget]>

	"nothing to do"! !

"June 6, 2007 -> 1:55:25"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
hInstance ^<ExternalProxy>

	^self medium hInstance! !

"June 6, 2007 -> 1:55:26"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
message: msg <MSG>
	"This is invoked in the UI thread when a new message arrives in the queue."

	"Forward messages to the session, which will execute them in its thread"
	self session message: msg! !

"June 6, 2007 -> 1:55:27"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
message: msgCode <ExternalData>
for: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	"This is where all the win32 messages get converted to our semantics.  This
	  method executes in the window's session's thread for queued messages, and
	  either the session or UI thread for unqueued messages."

	"%note/%todo: each message below must call beforeQueuedMessage before processing
	     the message IFF the message is a queued (in session thread) message"

	^(self windowsMessageHandlers at: msgCode
		ifAbsent: [ ^self handleMiscMsg: msgCode hwnd: hwnd wParam: wParam lParam: lParam ]
     )	value: self
		value: msgCode
		value: hwnd
		value: wParam
		value: lParam! !

"June 6, 2007 -> 1:55:29"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
recursiveRealizePaletteForeground: fore <Boolean> updateColors: update <Boolean>

	self palette isNil
		ifFalse: [	self withDCDo:
							[ :hdc <HDC> |
								| oldpal <Win32Handle> |
								oldpal := Palette select: self palette win32Handle into: hdc background: fore not.
								self palette unrealize.
								self palette realizeFor: hdc.
								Palette debugging
									ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
								Palette select: oldpal win32Handle into: hdc background: fore not.
							 ].
						self invalidate.
						].
	self controls do:
		[ :c <Win32Control> |
			c recursiveRealizePaletteForeground: fore updateColors: update ].! !

"June 6, 2007 -> 1:55:30"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
registerControl: c <Win32Control>

	self controls include: c! !

"June 6, 2007 -> 1:55:31"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
releaseCapture

	{{<user ExternalProxy ReleaseCapture> noArgs}}! !

"June 6, 2007 -> 1:55:33"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
sendMessage: msg <ExternalData>
wparam: wp <ExternalData>
lparam: lp <ExternalData>
^<ExternalData>

	^{{<user ExternalProxy SendMessageA>
			handle: self win32Handle
			msg: msg
			wparam: wp
			lparam: lp}}! !

"June 6, 2007 -> 1:55:34"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
setCapture

	{{<user ExternalProxy SetCapture> hwnd: self win32Handle}}.
! !

"June 6, 2007 -> 1:55:35"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
setFocus

	 self win32Handle @= {{<user ExternalProxy GetFocus> call}}
		ifFalse: [  {{<user ExternalProxy SetFocus> hwnd: self win32Handle}} ]! !

"June 6, 2007 -> 1:55:36"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
unregisterControl: c <Win32Control>

	self controls removeEvery: c! !

"June 6, 2007 -> 1:55:37"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
win32Handle ^<HWND>

	win32Handle isNil
		ifTrue: [	self session creatingWindow: self do:
							[	self buildWin32Handle; recordExtent. ].  ].
	^win32Handle! !

"June 6, 2007 -> 1:55:39"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
characterMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self beforeQueuedMessage.
	^self session handleIfFocusMsg: msg for: self wParam: wParam lParam: lParam
! !

"June 6, 2007 -> 1:55:40"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
closeMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self requestClose.
	^0! !

"June 6, 2007 -> 1:55:41"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
commandMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	
	self beforeQueuedMessage.

	^lParam @~= Win32 NULL
		ifTrue: [	"Then this is a control window notification, which should be forwarded back to the
						  smalltalk control object"
						Win32Control notificationMsg: wParam asExternalProxy high for: (Win32Control controlIdFor: lParam).
						0 ]
		ifFalse: [ wParam asExternalProxy high = 0
							ifTrue: [	self menuCommandForItem: wParam low.
											0	]
							ifFalse: [ self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam ]	]! !

"June 6, 2007 -> 1:55:43"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
handleMiscMsg: msgCode <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	"This performs the default window system handling for a message"
	
	^(self shouldCallDefaultHandlerAsynchronouslyFor: msgCode)
		ifTrue: [	"Some messages should be handled asyncronously, so that for
							example, moving a window allows other sessions to refresh"
						self callAsyncDefWndProcFor: hwnd
							msgCode: msgCode
							wParam:  wParam
							lParam: lParam ]
		ifFalse: [	self callDefWndProcFor: hwnd
								msgCode: msgCode
								wParam:  wParam
								lParam: lParam	]! !

"June 6, 2007 -> 1:55:44"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
handleMouseEvent: type <Symbol>
at: loc <Point>
msg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	| ev <UIEvent> |
	self beforeQueuedMessage.

	"%todo: remove the dispatch block for all events; isn't needed anymore"
	ev := UIEvent
			forMsg: self session currentMsg
			dispatch:
				[ :e <UIEvent> :h <UIEventHandler> |
					h mouseEvent: type at: loc event: e ].
	self mouseEvent: type at: loc event: ev.

	"Mouse events are always passed through to the default wnd proc since their may be window system specific things
	  like bringing the window to the foreground that always have to happen. (I used to pass it through only when it
	  was a left button down msg, but this is cleaner)"
	^self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam! !

"June 6, 2007 -> 1:55:45"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
initMenuPopupMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self beforeQueuedMessage.
	self hasMenu 
		ifTrue: [ self activeMenu updateMenuWithHandle: wParam ].
	^0! !

"June 6, 2007 -> 1:55:47"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
keyDownMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self beforeQueuedMessage.
	^self session handleIfFocusMsg: msg for: self wParam: wParam lParam: lParam
! !

"June 6, 2007 -> 1:55:48"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
keyUpMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self beforeQueuedMessage.
	^self session handleIfFocusMsg: msg for: self wParam: wParam lParam: lParam
! !

"June 6, 2007 -> 1:55:49"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
layoutMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	| ext <Point> |
	ext := lParam low @ lParam high.
	(self visual layoutStatus < Visual valid
			or: [ self visual allocation enclosingRect extent ~= ext ])
		ifTrue: [ self layout: ext ].
	^0! !

"June 6, 2007 -> 1:55:51"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
paintMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self display.
	^0! !

"June 6, 2007 -> 1:55:52"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
setCursorMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^(cursor notNil
			and: [	| hitcode <Int> |
						hitcode := lParam asExternalProxy low.
						hitcode = 1 or: [ hitcode = 65534 ] "client area or disabled"  ])
		ifTrue: [ 	self setCursor.
						1 ]
		ifFalse: [ self callDefWndProcFor: hwnd
								msgCode: msg
								wParam: wParam
								lParam: lParam ]
! !

"June 6, 2007 -> 1:55:54"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
buttonColorMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^Win32Control buttonColorMsg: wParam asExternalProxy for: (Win32Control controlIdFor: lParam)! !

"June 6, 2007 -> 1:55:55"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
captureChangedMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self session lostCapture.
	
	^self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam! !

"June 6, 2007 -> 1:55:56"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
destroyMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^0! !

"June 6, 2007 -> 1:55:58"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
drawItemMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^Win32Control drawItemMsg: (DRAWITEMSTRUCT forProxy: lParam) for: wParam asSmallInteger! !

"June 6, 2007 -> 1:55:59"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
eraseBackgroundMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	| can <Canvas> |

	self haveErased
		ifTrue: [ ^1 ].
	self haveErased: true.

	"Don't paint background when a paint is pending to reduce flickering"
	self paintPending
		ifTrue: [ ^0 ].

	"Use a critical region because the window's thread might be drawing"
	self critical:
		[	can := HDC forProxy: wParam asExternalProxy.
			can initialize.
			self paintBackgroundOn: can. 	].
	^1! !

"June 6, 2007 -> 1:56:1"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
getMinMaxInfoMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	| info <MINMAXINFO> adjmin <Point> adjmax <Point> |
	info := MINMAXINFO forProxy: lParam asExternalProxy.
	adjmin := (self fitToMedium: self min extent) max: info ptMinTrackSize asPoint.
	adjmax := (self fitToMedium: self max extent) min: info ptMaxSize asPoint.
	info ptMaxSize x: adjmax x; y: adjmax y.
	info ptMaxTrackSize x: adjmax x; y: adjmax y.
	info ptMinTrackSize x: adjmin x; y: adjmin y.
	^0! !

"June 6, 2007 -> 1:56:3"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
killFocusMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	"This window is losing the input focus, which means that some non-native visual
	  within us probably has the focus, so we have to discard the focus."

	(self session hasInputFocus and: [ self session inputFocus nativeWindow = self ])
		ifTrue: [ self session noInputFocus ].

	^self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam! !

"June 6, 2007 -> 1:56:4"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
measureItemMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	| data <MEASUREITEMSTRUCT> |
	data := MEASUREITEMSTRUCT forProxy: lParam.
	^data CtlType @= Win32 ODT_MENU
		ifFalse: [ Win32Control measureItemMsg: data for: data CtlID asSmallInteger ]
		ifTrue: [ self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam ]! !

"June 6, 2007 -> 1:56:6"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
ncDestroyMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self release.
	^0! !

"June 6, 2007 -> 1:56:7"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
paletteChangedMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	wParam @= self win32Handle
		ifFalse: [ self recursiveRealizePaletteForeground: false updateColors: true.
						self palette isNil
							ifTrue: [ ^self callDefWndProcFor: hwnd
											msgCode: msg
											wParam: wParam
											lParam: lParam	].
					].
	^0! !

"June 6, 2007 -> 1:56:9"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
queryPaletteMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self recursiveRealizePaletteForeground: true updateColors: false.
	self palette isNil
		ifTrue: [ ^self callDefWndProcFor: hwnd
						msgCode: msg
						wParam: wParam
						lParam: lParam	].
	^0! !

"June 6, 2007 -> 1:56:10"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
setFocusMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	"This window is getting the input focus, which means that some non-native visual
	  within us will have to be chosen if possible."

	self beforeSetFocus.

	^self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam! !

"June 6, 2007 -> 1:56:12"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
sizeMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	"%todo: do we need to check the value of wParam first?"
	self critical:
		[ wParam @= Win32 SIZE_MINIMIZED
			ifFalse: [	| m <MSG> |
								self invalidate.
								m := MSG new allocate.
								[ m	hwnd: self win32Handle;
										message: Window LAYOUT;
										wParam: 0;
										lParam: lParam.
									self recordExtent.
									self session message: m.
								] ensure: [ m free ]
							]
		 ].
	^0! !

"June 6, 2007 -> 1:56:13"!

! (Delta mirrorFor: #Window) methodsFor: 'testing' !
isActive ^<Boolean>

	^self session hasActiveWindow and: [ self session activeWindow = self ]! !

"June 6, 2007 -> 1:56:32"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 1:56:34"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 1:56:34"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 1:56:34"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 1:56:34"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 1:56:34"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 1:56:34"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 1:56:34"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 1:56:34"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 1:56:34"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 1:56:34"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 1:56:34"!

(Delta mirrorFor: #SystemInitializer)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"June 6, 2007 -> 1:56:37"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
benchmarkDictionary
	| dict |
	dict := Dictionary new.

	"Benchmarks"
	dict at: #richards			put: [ :runner :repeat :inner | runner new runRichardsBenchmarks: 		repeat ].
	dict at: #smopstones	put: [ :runner :repeat :inner | runner new runSmopstoneBenchmarks:	repeat ].
	dict at: #slopstones		put: [ :runner :repeat :inner | runner new runSlopstoneBenchmarks:		repeat ].
	dict at: #stanford			put: [ :runner :repeat :inner | runner new runStanfordBenchmarks:		repeat ].
	dict at: #deltablue			put: [ :runner :repeat :inner | runner new runDeltaBlue:							repeat ].
	dict at: #benchmarks	put: [ :runner :repeat :inner | 
		runner new runStanfordBenchmarks:			repeat.
		runner new runRichardsBenchmarks:		repeat.
		runner new runDeltaBlue:								repeat.
		runner new runSlopstoneBenchmarks:		repeat.
		runner new runSmopstoneBenchmarks:	repeat.
	].
	
	dict at: #loop			put: [ :runner :repeat :inner | runner new runStanfordLoopBenchmarks: repeat ].
	
	"Individual Stanford Benchmarks"
	dict at: #bubblesort		put: [ :runner :repeat :inner | runner new runIndividualStanford: BubbleSortBenchmark repeat: repeat inner: inner].
	dict at: #bubblesort2	put: [ :runner :repeat :inner | runner new runIndividualStanford: BubbleSort2Benchmark repeat: repeat inner: inner].
	dict at: #intmm				put: [ :runner :repeat :inner | runner new runIndividualStanford: IntMMBenchmark repeat: repeat inner: inner].
	dict at: #intmm2			put: [ :runner :repeat :inner | runner new runIndividualStanford: IntMM2Benchmark repeat: repeat inner: inner].
	dict at: #mm					put: [ :runner :repeat :inner | runner new runIndividualStanford: MMBenchmark repeat: repeat inner: inner].
	dict at: #mm2				put: [ :runner :repeat :inner | runner new runIndividualStanford: MM2Benchmark repeat: repeat inner: inner].
	dict at: #perm				put: [ :runner :repeat :inner | runner new runIndividualStanford: PermBenchmark repeat: repeat inner: inner].
	dict at: #perm2				put: [ :runner :repeat :inner | runner new runIndividualStanford: Perm2Benchmark repeat: repeat inner: inner].
	dict at: #queens			put: [ :runner :repeat :inner | runner new runIndividualStanford: QueensBenchmark repeat: repeat inner: inner].
	dict at: #queens2			put: [ :runner :repeat :inner | runner new runIndividualStanford: Queens2Benchmark repeat: repeat inner: inner].
	dict at: #quicksort		put: [ :runner :repeat :inner | runner new runIndividualStanford: QuicksortBenchmark repeat: repeat inner: inner].
	dict at: #quicksort2		put: [ :runner :repeat :inner | runner new runIndividualStanford: Quicksort2Benchmark repeat: repeat inner: inner].
	dict at: #towers			put: [ :runner :repeat :inner | runner new runIndividualStanford: TowersBenchmark repeat: repeat inner: inner].
	dict at: #towers2			put: [ :runner :repeat :inner | runner new runIndividualStanford: Towers2Benchmark repeat: repeat inner: inner].
	dict at: #treesort			put: [ :runner :repeat :inner | runner new runIndividualStanford: TreeSortBenchmark repeat: repeat inner: inner].
	dict at: #treesort2		put: [ :runner :repeat :inner | runner new runIndividualStanford: TreeSort2Benchmark repeat: repeat inner: inner].
	dict at: #puzzle				put: [ :runner :repeat :inner | runner new runIndividualStanford: PuzzleBenchmark repeat: repeat inner: inner].
	dict at: #sieve				put: [ :runner :repeat :inner | runner new runIndividualStanford: SieveBenchmark repeat: repeat inner: inner].
	dict at: #sumto				put: [ :runner :repeat :inner | runner new runIndividualStanford: SumToBenchmark repeat: repeat inner: inner].
	dict at: #recurse			put: [ :runner :repeat :inner | runner new runIndividualStanford: RecurseBenchmark repeat: repeat inner: inner].
	dict at: #atallput			put: [ :runner :repeat :inner | runner new runIndividualStanford: AtAllPutBenchmark repeat: repeat inner: inner].
	dict at: #incrementall	put: [ :runner :repeat :inner | runner new runIndividualStanford: IncrementAllBenchmark repeat: repeat inner: inner].
	dict at: #nestedloop		put: [ :runner :repeat :inner | runner new runIndividualStanford: NestedLoopBenchmark repeat: repeat inner: inner].
	dict at: #tak					put: [ :runner :repeat :inner | runner new runIndividualStanford: TakBenchmark repeat: repeat inner: inner].
	dict at: #takl					put: [ :runner :repeat :inner | runner new runIndividualStanford: TaklBenchmark repeat: repeat inner: inner].
	dict at: #ordcol				put: [ :runner :repeat :inner | runner new runIndividualStanford: OrderedCollectionBenchmark repeat: repeat inner: inner].
	dict at: #dictionary		put: [ :runner :repeat :inner | runner new runIndividualStanford: DictionaryBenchmark repeat: repeat inner: inner].
	dict at: #dictatput		put: [ :runner :repeat :inner | runner new runIndividualStanford: DictionaryAtPutBenchmark repeat: repeat inner: inner].
	dict at: #livermore		put: [ :runner :repeat :inner | runner new runIndividualStanford: LivermoreBenchmark repeat: repeat inner: inner].

	"Individual Slopstone Benchmarks"
	dict at: #addint				put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 1 repeat: repeat inner: inner].
	dict at: #addfloat			put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 2 repeat: repeat inner: inner].
	dict at: #stringaccess	put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 3 repeat: repeat inner: inner].
	dict at: #createobject	put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 4 repeat: repeat inner: inner].
	dict at: #perform			put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 5 repeat: repeat inner: inner].
	dict at: #evaluate			put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 6 repeat: repeat inner: inner].
	
	"Individual Smopstone Benchmarks"
	dict at: #fractonacci	put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 1 repeat: repeat inner: inner].
	dict at: #primes   		put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 2 repeat: repeat inner: inner].
	dict at: #streams		put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 3 repeat: repeat inner: inner].
	dict at: #strings			put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 4 repeat: repeat inner: inner].
	dict at: #sets				put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 5 repeat: repeat inner: inner].
	dict at: #sorting 			put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 6 repeat: repeat inner: inner].
	dict at: #sorcerer		put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 7 repeat: repeat inner: inner].

	"Test Suites"
	dict at: #testsuite		put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new testBasicClasses] ].

	"Individual Tests"
	dict at: #string				put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: String title: 'String' ] ].
	dict at: #number			put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: Number title: 'Number' ] ].
	dict at: #sortedcol		put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: SortedCollection title: 'SortedCollection' ] ].
	dict at: #readstream	put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: SeqCltnReadStream title: 'SeqCltnReadStream' ] ].
	dict at: #writestream	put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: SeqCltnReadWriteStream title: 'SeqCltnReadWriteStream' ] ].
	dict at: #bag				put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: Bag title: 'Bag' ] ].
	dict at: #keyedset		put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: KeyedSet title: 'KeyedSet' ] ].
	dict at: #set					put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: Set title: 'Set' ] ].
	dict at: #orderedcol	put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: OrderedCollection title: 'OrderedCollection' ] ].
	dict at: #character		put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: Character title: 'Character' ] ].
	dict at: #readwrite		put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: ExternalReadWriteStream title: 'ExternalReadWriteStream' ] ].

	"Errors"
	dict at: #break				put: [ :runner :repeat :inner | {{primitiveBreak}} ].

	"Bootstrap"
	dict at: #boot				put: [ :runner :repeat :inner | Dumper fileOut ].

	"Test Suite for the VM people"
	dict at: #vmtest				put: [ :runner :repeat :inner | VMSuite run ].
	dict at: #vminterpreted	put: [ :runner :repeat :inner | VMSuite runInterpreted ].
	dict at: #vmcompiled	put: [ :runner :repeat :inner | VMSuite runCompiled ].
	dict at: #vmvanilla			put: [ :runner :repeat :inner | VMSuite runVanilla ].
	dict at: #dump					put: [  :runner :repeat :inner | InliningDatabase dump ].
	dict at: #compileAll		put: [  :runner :repeat :inner | InliningDatabase compileAll ].
	dict at: #gc						put: [  :runner :repeat :inner | VM collectGarbage ].
	dict at: #norecomp		put: [  :runner :repeat :inner | VM booleanAt: #UseRecompilation put: false ].

	"Misc."
	dict at: #zone					put: [ :runner :repeat :inner | {{primitivePrintZone}} ].
	dict at: #decode				put: [ :runner :repeat :inner | {{primitiveDecodeAllMethods}} ].
	dict at: #mandelbrot		put: [ :runner :repeat :inner | repeat timesRepeat: [ Mandelbrot new computeImageOnly ] ].
	dict at: #mandelprof		put: [ :runner :repeat :inner | Profiler do: [ Mandelbrot new computeImageOnly ] ].
	dict at: #mandeltest		put: [ :runner :repeat :inner | Mandelbrot new computeImageOnly ].
	dict at: #typecheck		put: [ :runner :repeat :inner | runner new runTypecheckerBenchmarks: repeat ].
	dict at: #genprims			put: [ :runner :repeat :inner | DeltaPrimitiveGenerator doit].

	^dict! !

"June 6, 2007 -> 1:56:38"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
findRunner: test ifAbsent: blk
	test = 'timer'
		ifTrue: [^BenchmarkRunner].
	test = 'nmethod'
		ifTrue: [^BenchmarkNMethodInvocationRunner].
	test = 'method'
		ifTrue: [^BenchmarkMethodInvocationRunner].
	test = 'prims'
		ifTrue: [^BenchmarkPrimitiveRunner].
	test = 'lookup'
		ifTrue: [^BenchmarkLookupCacheRunner].
	test = 'blocks'
		ifTrue: [^BenchmarkBlockRunner].
	blk value.! !

"June 6, 2007 -> 1:56:39"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
lower: str
	| result |
	result := String new: str size.
	1 to: str size do: [ :index |
		result at: index put: (str at: index) asLowercase
	].
	^result! !

"June 6, 2007 -> 1:56:41"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
parseInteger: str ifFail: blk
	| result |
	result := 0.
	str do: [ :c | | val |
		val := c asciiValue.
		(val >= $0 asciiValue and: [ val <= $9 asciiValue ])  ifTrue: [
			result := (result * 10) + ( val - $0 asciiValue)
		] ifFalse: [
			^blk value
		]
	].
	^result! !

"June 6, 2007 -> 1:56:42"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
processCommandLineArguments ^<Boolean>
	"process command line args, and return boolean indicating whether the 
		default program should be run (which is normally the GUI)"

	| args <ReadStream[Str]>  runDefault <Boolean> |
	args := Platform commandLineTokens.
	args next.  "Skip command"
	runDefault := true.
	
	[ args atEnd ] whileFalse: [  | arg <Str> |
		arg := args next.
		
		arg = '-benchmark'
			ifTrue: [	self runBenchmarks: args.
						runDefault := false ].
		arg = '-script'
			ifTrue: [	args atEnd
							ifTrue: [ Transcript show: 'Command line argument error: -script option must be followed by a filename';cr. ]
							ifFalse: [ self runScript: args next ].
						runDefault := false ].		].
	^runDefault
! !

"June 6, 2007 -> 1:56:43"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
runBenchmarks: args <InputStream[Str]>

	| dict runner repeat inner print |
	dict := self benchmarkDictionary.
	runner	:= BenchmarkRunner.
	repeat	:= 1.
	inner	:= 1.
	print		:= false.

	[ args atEnd ] whileFalse: [	| arg <Str> cmd options |
		arg := args next.
		options	:= false.
		arg = 'profile'	ifTrue: [ runner := BenchMarkProfileRunner.		options := true ].
		arg = 'prims'		ifTrue: [ runner := BenchmarkPrimTraceRunner.	options := true ].
		arg = 'inner'		ifTrue: [ inner := repeat. repeat := 1.						options := true ].
		arg = 'print'		ifTrue: [ print := true.												options := true ].
		options ifFalse: [
			repeat := self parseInteger: arg ifFail: [
				Transcript show: 'Processing '; show: arg; show: ' ('; show: repeat printString; show: ' times)'; cr.
				cmd := dict at: arg ifAbsent: [nil].
				cmd isNil ifTrue:  [ Transcript show: 'Command not found'; cr ]
							   ifFalse: [ cmd value: runner value: repeat value: inner ].
				repeat
			]
		]
	].

	print ifTrue: [
		{{primitivePrintMemory}}.
	]! !

"June 6, 2007 -> 1:56:44"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
runDefaultProgram
	"This starts the 'default' program, which is the code that should run when no
	  command line options specifies something else"
	  
	[ UI start ] fork! !

"June 6, 2007 -> 1:56:45"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
runScript: filename <Str>

	[	| file <FilePath> |
		file := FilePath for: filename.
		file exists
			ifFalse: [	Transcript show: 'Error: script file ''', filename, ''' not found.'; cr.
							^self	].
		file charInputStream fileIn
	] fork! !

"June 6, 2007 -> 1:56:46"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'library class initialization' !
run
	"This is the entry point for normal execution."
	
	| commands <OrdCltn[Str]> |

	self runBaseClassInitializers.
	self runNonCriticalClassInitializers.
	(self processCommandLineArguments)
		ifTrue: [ self runDefaultProgram ].
! !

"June 6, 2007 -> 1:56:47"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'library class initialization' !
runBaseClassInitializers
	"Initialize critical base library classes (run in the process scheduler)"

	Platform initialize.
	Transcript := TempTranscript new.
	SmallInteger initialize.
	Character initialize.
	CallBack initialize.
	IdleProcess initialize.
	InliningDatabase initialize.
! !

"June 6, 2007 -> 1:56:48"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'library class initialization' !
runNonCriticalClassInitializers
	"This is the root class initializer that is called when the system starts up.
		Any class initializers that must be called should be called from
		this method."

	Session initialize.

	Rectangle initialize.
	Paint initialize.
	Painter initialize.
	HPEN initialize.
	GeometricHPEN initialize.
	HBRUSH initialize.
	InfiniteRegion initialize.

	Smalltalk initialize.

	CodeEditor initialize.
	Workspace initialize.

	HTMLElement initialize.
	HTMLParser initialize.! !

"June 6, 2007 -> 1:59:45"!

"System saved" !
"June 6, 2007 -> 2:11:44"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'command line' !
commandLine ^<Str>
    | p size result |
    p := {{<kernel ExternalProxy GetCommandLineA>getCommandLine}}.
    size := 0.
    [(p byteAt: size) == 0] whileFalse: [ size := size + 1 ].
    result := String new: size.
    1 to: size do: [:index |
       result at: index put: (Character value: (p byteAt: index - 1))
    ].
    ^result! !

"June 6, 2007 -> 2:12:11"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'command line' !
commandLine ^<Str>
    | p size result |
    p := {{<kernel ExternalProxy GetCommandLineA>getCommandLine}}.
    size := 0.
    [(p byteAt: size) == 0] whileFalse: [ size := size + 1 ].
    result := String new: size.
    1 to: size do: [:index |
       result at: index put: (Character value: (p byteAt: index - 1))
    ].
    ^result! !

"June 6, 2007 -> 2:13:2"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'command line' !
commandLineTokens ^<InputStream[Str]>
    "a stream of the input line tokens.  Tokens are sequences separated by whitespace; whitespace can be 
        included in a token by double quoting the arg.  (quotes can be imbedded by doubling, as with Smalltalk strings;
        the returned token has delimiting quotes removed and internal quotes undoubled. "

    | cstrm <CharInputStream> |
    cstrm := self commandLine readStream.
    self skipSpacesIn: cstrm.
    ^CustomInputStream[Str] new
            nextBlock: [    self parseArgFrom: cstrm ];
            atEndBlock: [ cstrm atEnd ].! !

"June 6, 2007 -> 2:24:34"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'command line' !
commandLine ^<Str>
   ^self getCommandLine! !

"June 6, 2007 -> 2:40:18"!

"System saved" !
"June 6, 2007 -> 2:52:16"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'private' !
skipSpacesIn: strm <CharInputStream>

    [ strm atEnd not and: [ strm peekFor: Character space] ] whileTrue.
! !

"June 6, 2007 -> 2:54:14"!

"System saved" !
"June 6, 2007 -> 18:22:24"!

Delta define: #Bootstrap as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 18:22:25"!

Delta define: #Bootstrap as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 18:22:25"!

Delta define: #Bootstrap as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 18:22:25"!

Delta define: #Bootstrap as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 18:22:25"!

Delta define: #Bootstrap as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 18:22:25"!

Delta define: #Bootstrap as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 18:22:25"!

Delta define: #Bootstrap as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 18:22:25"!

Delta define: #Bootstrap as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 18:22:25"!

Delta define: #Bootstrap as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 18:22:25"!

Delta define: #Bootstrap as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 18:22:25"!

Delta define: #Bootstrap as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 18:22:26"!

(Delta mirrorFor: #Bootstrap)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.
'!


"June 6, 2007 -> 18:22:27"!

! (Delta mirrorFor: #Bootstrap) classSide methodsFor: 'notification' !
checkNotification
	[ 
		{{primitiveNotificationQueueGetIfFail: [ :err |^self]}}  notify.
	] repeat.! !

"June 6, 2007 -> 18:22:28"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'dave''s benchmarks' !
dictAtBenchmark
"	Foo isNil
		ifTrue: [ Dictionary performanceTestPrep. Foo := 1 ]."
	2 timesRepeat: [ Dictionary  atPerformanceTest ].
Transcript show: '-------------------------------------- starting Dict>>at: benchmark'; cr.
	Transcript print:
		[ Dictionary atPerformanceTest ] time; cr.! !

"June 6, 2007 -> 18:22:29"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'dave''s benchmarks' !
dictAtPutBenchmark
"	Foo isNil
		ifTrue: [ Dictionary performanceTestPrep. Foo := 1 ]."
	2 timesRepeat: [ Dictionary  atPutPerformanceTest ].
Transcript show: '-------------------------------------- starting Dict>>at:put: benchmark'; cr.
	Transcript print:
		[ Dictionary atPutPerformanceTest ] time; cr.! !

"June 6, 2007 -> 18:22:30"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'dave''s benchmarks' !
dictBenchmark
"	Foo isNil
		ifTrue: [ Dictionary performanceTestPrep. Foo := 1 ]."
	2 timesRepeat: [ Dictionary  performanceTest ].
Transcript show: '-------------------------------------- starting benchmark'; cr.
	Transcript print:
		[ Dictionary performanceTest ] time; cr.! !

"June 6, 2007 -> 18:22:31"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'dave''s benchmarks' !
hashingBenchmarks

	self dictAtBenchmark; dictAtPutBenchmark; setIncludeBenchmark; setIncludesBenchmark! !

"June 6, 2007 -> 18:22:32"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'dave''s benchmarks' !
setIncludeBenchmark

	2 timesRepeat: [ Set  includePerformanceTest ].
Transcript show: '-------------------------------------- starting Set>>include: benchmark'; cr.
	Transcript print:
		[ Set includePerformanceTest ] time; cr.! !

"June 6, 2007 -> 18:22:33"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'dave''s benchmarks' !
setIncludesBenchmark

	2 timesRepeat: [ Set  includesPerformanceTest ].
Transcript show: '-------------------------------------- starting Set>>includes: benchmark'; cr.
	Transcript print:
		[ Set includesPerformanceTest ] time; cr.! !

"June 6, 2007 -> 18:22:34"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'library testing' !
deterministicallyTestSystem
	"As many tests as we can do deterministically (i.e. without requiring UI interaction, for now)."

	self testLibrary.
	Smalltalk recompileAllMethods.
	Transcript show: 'Testing completed.'; cr.! !

"June 6, 2007 -> 18:22:35"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'library testing' !
testBlueBookCPUBoundClasses

	Number test.
    SeqCltnReadWriteStream test.
     SeqCltnReadStream  test.
    Bag test.
    KeyedSet  test.
   Set  test.
	 Dictionary test.
   SortedCollection test.
     OrderedCollection  test.
   String  test.
   Character  test.
	 Interval test.
	 Behavior test.
	 Random test.
	 BlockWithoutArguments  test.
	 Queue test.

	
! !

"June 6, 2007 -> 18:22:36"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'library testing' !
testBlueBookClasses

    self test: Number title: 'Number'.
    self test: SmallInteger title: 'SmallInteger'.
    self test: SeqCltnReadWriteStream title: 'SeqCltnReadWriteStream'.
    self test: SeqCltnReadStream   title: 'SeqCltnReadStream'.
    self test: Bag title: 'Bag'.
    self test: KeyedSet title: 'KeyedSet'.
    self test: Set title: 'Set'.
	self test: Dictionary title: 'Dictionary'.
    self test: SortedCollection title: 'SortedCollection'.
    self test: OrderedCollection title: 'OrderedCollection'.
    self test: String title: 'String'.
    self test: Character title: 'Character'.
	self test: Interval title: 'Interval'.
	self test: Behavior title: 'Behavior'.
	self test: Random title: 'Random'.
	self test: BlockWithoutArguments title: 'BlockWithoutArguments'.

    self test: ExternalReadWriteStream title: 'ExternalReadWriteStream'.
    self test: SharedQueue title: 'SharedQueue'.
	
! !

"June 6, 2007 -> 18:22:37"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'library testing' !
testLibrary
	
	| t <Int> |
	t := [	self testBlueBookClasses.
    		self test: FilePath title: 'FilePath'.
			self test: CharacterReadConverter title: 'CharacterReadConverter'.	] time.
	Transcript show: 'Time = '; print: t; cr.
! !

"June 6, 2007 -> 18:22:38"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'new menus' !
benchmarkMenu ^<Menu>

	^Menu new
		add: (Menu new name: '&Benchmarks';
					add: (MenuAction new
							name: 'Livermore &Benchmark';
							action: [ self livermoreBenchmark ] );
					add: (MenuAction new
							name: 'Livermore Benchmark (w/FloatValues)';
							action: [ self livermoreFloatValueBenchmark ] );
					add: (MenuAction new
							name: 'CPU benchmark';
							action: [ self cpuBenchmark ] );
					add: (MenuAction new
							name: 'Stream write';
							action: [ self streamWrite ] );
					add: (MenuAction new
							name: 'Stream read';
							action: [ self streamRead ] );
					add: (MenuAction new
							name: 'Stream lines write';
							action: [ self streamWrite2 ] );
					add: (MenuAction new
							name: 'Stream lines read';
							action: [ self streamRead2 ] );
					add: (MenuAction new
							name: '&Hashing Benchmarks';
							action: [ self hashingBenchmarks ] );
					add: (MenuAction new
							name: 'OrderedCollection Benchmark';
							action: [ self ocBenchmark ] );
					add: (MenuAction new
							name: 'Array Benchmark';
							action: [ self arrayBenchmark ] );
					add: (MenuAction new
							name: 'Random Benchmark';
							action: [ Transcript print: [ 10 timesRepeat: [ Random test ] ] time; cr. ] )
					)! !

"June 6, 2007 -> 18:22:39"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'new menus' !
compilationMenu ^<Menu>

	^Menu new name: '&Compiler';
					add: (MenuAction new
							name: '&Compiler Enabled';
							checked: [ VM recompilation ];
							action: [ VM recompilation: VM recompilation not ]	);
					add: (MenuAction new
							name: '&Print Compilations';
							checked: [ VM printCompilation ];
							action: [ VM printCompilation: VM printCompilation not ]	);
					add: (MenuAction new
							name: 'Print Compiled Code Space Usage (Zone)';
							action: [	VM printZone ] );
					addSeparator;
					add: (MenuAction new
							name: 'Use &Inlining Database as needed';
							checked: [ VM useInliningDatabase ];
							action: [	InliningDatabase checkLookupTable.
											VM useInliningDatabase: VM useInliningDatabase not.
										  ]	);
					add: (MenuAction new
							name: 'Compile Whole Inlining Database';
							action: [ InliningDatabase compileAll ]	);
					add: (MenuAction new
							name: 'Create &Inlining Database';
							action: [ InliningDatabase dump ]	);
					addSeparator;
					add: (MenuAction new
							name: '&Flush Inline Caches';
							action: [ {{primitiveClearInlineCaches}} ]	)! !

"June 6, 2007 -> 18:22:40"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'new menus' !
developmentMenu ^<Menu>

	^Menu new
		add: (Menu new name: '&System';
					add: self compilationMenu;
					add: self gcMenu;
					add: self uiMenu;
					add: self typeSystemMenu;
					add: self profilingMenu)! !

"June 6, 2007 -> 18:22:41"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'new menus' !
gcMenu ^<Menu>

	^Menu new name: '&Object Memory';
					add: (MenuAction new
							name: '&Collect Garbage';
							action: [ VM collectGarbage ]	);
					add: (MenuAction new
							name: '&Scavenge';
							action: [ VM scavengeGarbage ]	);
					addSeparator;
					add: (MenuAction new
							name: 'Print Scavenges';
							checked: [ VM printScavenge ];
							action: [ VM printScavenge: VM printScavenge not ]	);
					add: (MenuAction new
							name: 'Print Allocated Object &Histogram';
							action: [ {{primitivePrintObjectHistogram}} ]	)! !

"June 6, 2007 -> 18:22:42"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'new menus' !
profilingMenu ^<Menu>

	^Menu new name: '&Profiling and Debugging';
					add: (MenuAction new
							name: '&Profiling';
							checked: [ Profiler profiling ];
							action: [ Profiler profiling: Profiler profiling not ]	);
					add: (MenuAction new
							name: '&Print Profile';
							action: [ Profiler profiling: false.
										  Profiler printStats. ]	);
					add: (MenuAction new
							name: '&Reset Profile Stats';
							action: [ Profiler resetStats. ]	);
					addSeparator;
					add: (MenuAction new
							name: '&Time Menu Actions';
							checked: [ MenuAction timeActions ];
							action: [ MenuAction timeActions: MenuAction timeActions not ]	);
					addSeparator;
					add: (MenuAction new
							name: '&Temp Debug';
							checked: [ TempDebug == true ];
							action: [	TempDebug isNil ifTrue: [ TempDebug := false ].
											TempDebug := TempDebug not.	]	)
				! !

"June 6, 2007 -> 18:22:43"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'new menus' !
registerTmpMenus

	Launcher registerMenu: self developmentMenu for: #Development.! !

"June 6, 2007 -> 18:22:44"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'new menus' !
testMenu ^<Menu>

	^Menu new
		add: (Menu new name: '&Testing';
					add: (MenuAction new
							name: 'Text Editor';
							action: [ self textEditor ] );
					add: (MenuAction new
							name: 'Test Library';
							action: [ self testLibrary ] );
					add: (MenuAction new
							name: 'Test Dialog';
							action: [ self testDialog ] );
					add: (MenuAction new
							name: 'Mandelbrot';
							action: [ self mandelbrot ] );
					add: (MenuAction new
							name: 'Transcript test';
							action: [	[	1 to: 100 do: [ :i | Transcript print: i; cr. ]. ] fork
										] );
					add: (MenuAction new
							name: 'Transcript test 2';
							action: [	[	1 to: 100 do: [ :i | Transcript print: i; cr; flush. ]. ] fork
										] );
					add: (MenuAction new
							name: 'Transcript test 3';
							action: [	[	1 to: 100 do: [ :i | i = 50 ifTrue: [ TempDebug := true ]. Transcript print: i; cr; flush. ]. ] fork.
											[	100 to: 1 by: -1 do: [ :i | Transcript print: i; cr; flush. ]. ] fork.
										] )
					)! !

"June 6, 2007 -> 18:22:45"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'new menus' !
typeSystemMenu ^<Menu>

	^Menu new name: '&Type System';
					add: (MenuAction new
							name: '&Report Type Loading';
							checked: [ ReportTypeLoading == true ];
							action: [ ReportTypeLoading := ReportTypeLoading not ]	);
					add: (MenuAction new
							name: 'Zap all Type data';
							action: [ Type zapAllTypes]	)! !

"June 6, 2007 -> 18:22:47"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'new menus' !
uiMenu ^<Menu>

	^Menu new name: '&UI';
					add: (MenuAction new
							name: 'Double Buffering';
							checked: [ Window bufferingPossible ];
							action: [	Window bufferingPossible: Window bufferingPossible not]	);
					add: (MenuAction new
							name: '&Smooth Scrolling';
							checked: [ ScrollState smoothScroll ];
							action: [	ScrollState smoothScroll: ScrollState smoothScroll not]	);
					addSeparator;
					add: (MenuAction new
							name: 'Debug UI &Invalidation';
							checked: [ Session debugInvalidation ];
							action: [	Session debugInvalidation: Session debugInvalidation not	]	);
					add: (MenuAction new
							name: '&Debug Events';
							checked: [ Session debugEvents ];
							action: [ Session debugEvents: Session debugEvents not ]	);
					add: (MenuAction new
							name: '&Debug Incremental Layout';
							checked: [ Session debugIncrementalLayout ];
							action: [	Session debugIncrementalLayout: Session debugIncrementalLayout not]	)! !

"June 6, 2007 -> 18:22:48"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'private' !
cpuBenchmark

	Transcript print: [ 3 timesRepeat: [ self testBlueBookCPUBoundClasses ] ] time; cr.! !

"June 6, 2007 -> 18:22:49"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'private' !
newListBox
	| lb |
	lb := ListBox forMultipleSelections" forSingleSelection".
													lb xStretchy: true; variableItemHeight: false.
													lb stringList: #(hello goodbye atest andanotherstring 'Hi Urs' lsdfsdfsdfsdfsd sdkfljsdlkfjsdlkjf lksdfjlksdjfklsdjfklsdf lksdfj kksdlf lksdfj sdflj lsdjflksjdkfjlk ksldfjlksdfjklsjdf sdkfjl sdklfjkljlksdj lksdjfl ksdjf sdfsdfsf sdfsdfsdfsf sdfsdfsdfsf) .
													lb onSelChange: [ :lb | Transcript print: lb selections; cr. ].
													lb onDoubleClick: [ :lb | Transcript show: 'DOUBLE!!'; print: lb selections; cr. ].
													lb simpleMultiple: false.
													lb resetNaturalHeight: 10.
													lb selections: (Set withAll: #(2)).
	^lb withBorder: (Border standard3DRaised: false)
! !

"June 6, 2007 -> 18:22:50"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'private' !
newWidget

	^self newListBox! !

"June 6, 2007 -> 18:22:51"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'private' !
streamRead

	| p s c |
	p := FilePath for: 'foo.dat'.
	Transcript print: [
	s := p charInputStream.
	c := 0.
	[ s atEnd ]
		whileFalse: [ self assert: [ s next == $a ].
								c := c + 1. ].
	self assert: [ c = 1000000 ].
	s close. ] time; cr.! !

"June 6, 2007 -> 18:22:52"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'private' !
streamRead2

	| p s c v |
	p := FilePath for: 'foo.dat'.
	Transcript print: [
	s := p charInputStream.
	c := 0.
	[ s atEnd ]
		whileFalse: [ c = 10000 ifTrue: [ self halt. ].	v := s upTo: Character cr.
								self assert: [  v size = 98 ].
								c := c + 1. ].
	self assert: [ c = 10000 ].
	s close. ] time; cr.! !

"June 6, 2007 -> 18:22:53"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'private' !
streamWrite

	| p s |
	p := FilePath for: 'foo.dat'.
	Transcript print: [
	s := p charOutputStream.
	1000000 timesRepeat:
		[ s put: $a ].
	s close. ] time; cr.! !

"June 6, 2007 -> 18:22:54"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'private' !
streamWrite2

	| p s |
	p := FilePath for: 'foo.dat'.
	Transcript print: [
	s := p charOutputStream.
	10000 timesRepeat:
		[	98 timesRepeat: [ s put: $a ].
			s cr. ].
	s close. ] time; cr.! !

"June 6, 2007 -> 18:22:55"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'startup' !
arrayBenchmark

	1 timesRepeat: [ Array performanceTest ].
Transcript show: '-------------------------------------- starting benchmark'; cr.
	Transcript print:
		[ Array performanceTest ] time; cr.! !

"June 6, 2007 -> 18:22:56"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'startup' !
livermoreBenchmark

	|	n		
		size
		x		
		y		
		q 		
		r 		
		z 		
		t 		
		|

	n := 1001.
	size := n + 12.
	x := Array new: size.
	y := (Array new: size) atAllPut: 1.1234.
	z := (Array new: size) atAllPut: 1.1234.
	q := r := t := 1.234.

	Transcript show: 'Livermore seconds equivalent:', (((Time millisecondsToRun: 
		[	1000 timesRepeat:
				[	1 to: n do:
						[ :k  |
							x at: k put: 
								(q + ( (y at: k) * (r*(z at: k + 10)) + (t*(z at: k + 11)) ))
						]
				]
		]) * 10) asFloat / 1000.0) printString; cr.! !

"June 6, 2007 -> 18:22:57"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'startup' !
livermoreFloatValueBenchmark

	|	n		
		size
		x		
		y		
		q 		
		r 		
		z 		
		t 		
		|

	n := 1001.
	size := n + 12.
	x := Array new: size.
	y := (Array new: size) atAllPut: 1.1234.
	z := (Array new: size) atAllPut: 1.1234.
	q := r := t := 1.234.

	Transcript show: 'Livermore seconds equivalent:', (((Time millisecondsToRun: 
		[	1000 timesRepeat:
				[	self livermoreFloatValueInner: x y: y z: z ]
		]) * 10) asFloat / 1000.0) printString; cr.! !

"June 6, 2007 -> 18:22:58"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'startup' !
livermoreFloatValueInner: x y: y z: z

	|	n		
		size
		q 		<FloatValue>
		r 		<FloatValue>
		t 		<FloatValue>
		|

	n := 1001.
	size := n + 12.
	q := r := t := 1.234.

	1 to: n do:
		[ :k  |
			x at: k put: 
					(q + ( (y at: k) asFloatValue * (r*(z at: k + 10) asFloatValue) + (t*(z at: k + 11) asFloatValue) )) asFloat
		]! !

"June 6, 2007 -> 18:23:0"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'startup' !
ocBenchmark

	1 timesRepeat: [ OrderedCollection performanceTest ].
Transcript show: '-------------------------------------- starting benchmark'; cr.
	Transcript print:
		[ OrderedCollection performanceTest ] time; cr.! !

"June 6, 2007 -> 18:23:0"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'startup' !
test: class title: title
    Transcript show: 'Testing '; show: title; cr.
    class test.
    Transcript show: 'end'; cr
! !

"June 6, 2007 -> 18:23:2"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'test code' !
doubleOverflowCheck
	| number |
	number := 2.0.
	[ number isFinite ] whileTrue: [
		Transcript print: number; cr.
		number := number * number.
	]! !

"June 6, 2007 -> 18:23:3"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'test code' !
indexTest
	   'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1.
        'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1.
        'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1.
        'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1.
        'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1.
        'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1.
        'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1.
        'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1.
        'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1.
        'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1! !

"June 6, 2007 -> 18:23:3"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'test code' !
testContext
	self testContext: 1 and: 2 and: 3! !

"June 6, 2007 -> 18:23:4"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'test code' !
testContext: a and: b and: c
	[ (a + b) printString. self deoptimize ] value! !

"June 6, 2007 -> 18:23:5"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'test code' !
testNLR
	| f |
	f := self testNLRBlock.
	f value.
	
! !

"June 6, 2007 -> 18:23:6"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'test code' !
testNLRBlock
	^[^self]! !

"June 6, 2007 -> 18:23:7"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'typechecker tests' !
displayErrorsFromHandler: eh  <DeltaTypeErrorHandler>  

eh reportedErrors isEmpty 
   ifTrue:[Transcript  show: 'No type errors'; cr.]
   ifFalse:[eh reportedErrors do:[: e <TypeError> | Transcript show: e errorMessage; cr.]].! !

"June 6, 2007 -> 18:23:8"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'typechecker tests' !
tryNewClass! !

"June 6, 2007 -> 18:23:8"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'typechecker tests' !
tryNewMixin! !

"June 6, 2007 -> 18:23:9"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'typechecker tests' !
typecheckMinWorld! !

"June 6, 2007 -> 18:23:10"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'typechecker tests' !
typecheckMirror: m <Mirror>

m typecheck. 
m classSide typecheck
! !

"June 6, 2007 -> 18:23:11"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'utilities' !
clearLookupCache
	{{primitiveClearLookupCache}}! !

"June 6, 2007 -> 18:23:12"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'utilities' !
decodeAllMethods
	{{primitiveDecodeAllMethods}}.! !

"June 6, 2007 -> 18:23:13"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'utilities' !
printObjectHistogram
	{{primitivePrintObjectHistogram}}! !

"June 6, 2007 -> 18:23:14"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'utilities' !
setupInlining
	"Set inlining flags for helping the inlining compiler. Experimental"
	
	((Mirror on: HashedCollection) 	compiledMethodAt: #at: 					ifFail: []) neverInline.
	((Mirror on: Dictionary) 					compiledMethodAt: #at:put:				ifFail: []) neverInline.
	((Mirror on: Dictionary) 					compiledMethodAt: #at:put:ifNew:	ifFail: []) alwaysInline.
	((Mirror on: OutputStreamView) 	compiledMethodAt: #cr						ifFail: []) neverInline.
	((Mirror on: Object) 							compiledMethodAt: #assert:				ifFail: []) alwaysInline.
! !

"June 6, 2007 -> 18:24:30"!

"System saved" !
"June 6, 2007 -> 22:15:39"!

"System saved" !
"June 7, 2007 -> 1:20:56"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'library testing' !
deterministicallyTestSystem
	"As many tests as we can do deterministically (i.e. without requiring UI interaction, for now)."

	self testLibrary.
	"Smalltalk recompileAllMethods."
	Transcript show: 'Testing completed.'; cr.! !

"June 7, 2007 -> 1:22:11"!

"System saved" !
"June 8, 2007 -> 2:6:29"!

! (Delta mirrorFor: #Process) methodsFor: 'private-initialization' !
recordId

	"win32Handle := {{<kernel Win32Handle GetCurrentThreadId> call}}"! !

"June 8, 2007 -> 2:42:42"!

"System saved" !
"June 8, 2007 -> 3:4:34"!

! (Delta mirrorFor: #Process) methodsFor: 'private-initialization' !
recordId

	win32Handle := {{<kernel Win32Handle GetCurrentThreadId> call}}! !

"June 8, 2007 -> 3:7:4"!

"System saved" !
"June 8, 2007 -> 21:54:37"!

Delta define: #Win32Process as: (
(Class subclassOf: 'Process' instanceVariables: '')) !


"June 8, 2007 -> 21:55:45"!

Delta define: #Win32Process as: (
(Class subclassOf: 'Process' instanceVariables: 'win32Handle')) !


"June 8, 2007 -> 21:56:53"!

! (Delta mirrorFor: #Win32Process) methodsFor: 'private-initialization' !
recordId

	win32Handle := {{<kernel Win32Handle GetCurrentThreadId> call}}! !

"June 8, 2007 -> 21:57:8"!

Delta define: #Win32Process as: (
(Class subclassOf: 'Process' instanceVariables: 'win32Handle <Win32Handle>
	"the thread id"')) !


"June 8, 2007 -> 22:3:55"!

! (Delta mirrorFor: #Win32Process) methodsFor: 'restricted' !
win32Handle ^<Win32Handle>
	"This is valid only after the process has begun to actually execute"

	^win32Handle! !

"June 8, 2007 -> 22:8:45"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'platform classes' !
processClass
	^Win32Process! !

"June 8, 2007 -> 22:31:45"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'platform classes' !
processClass
	^Win32Process! !

"June 8, 2007 -> 22:33:49"!

Delta define: #Win32Process as: (
(Class subclassOf: 'Process' instanceVariables: '')) !


"June 8, 2007 -> 22:34:2"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'platform classes' !
processClass
	^Win32Process! !

"June 9, 2007 -> 0:29:57"!

Delta define: #Win32Process as: (
(Class subclassOf: 'Process' instanceVariables: 'win32Handle <Win32Handle>
	"the thread id"')) !


"June 9, 2007 -> 0:30:47"!

! (Delta mirrorFor: #Win32Process) methodsFor: 'private-initialization' !
recordId

	win32Handle := {{<kernel Win32Handle GetCurrentThreadId> call}}! !

"June 9, 2007 -> 0:31:37"!

! (Delta mirrorFor: #Win32Process) methodsFor: 'restricted' !
win32Handle ^<Win32Handle>
	"This is valid only after the process has begun to actually execute"

	^win32Handle! !

"June 9, 2007 -> 0:35:33"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'platform classes' !
processClass
	^Process! !

"June 9, 2007 -> 0:50:14"!

! (Delta mirrorFor: #Process) classSide methodsFor: 'instance creation' !
primitiveCreate: block

	^{{ self primitiveProcessCreate: block
				ifFail: [ :err <Symbol> | self error: err ]
		}}! !

"June 9, 2007 -> 0:52:6"!

! (Delta mirrorFor: #Process) classSide methodsFor: 'instance creation' !
for: block <[]> ^<Instance>
	"Create and return a new process that will execute the block at the
	 specified priority.  The new process is suspended."

	| i <Instance> |
	i := (guaranteed <Instance>
		(Platform processClass primitiveCreate: [ i recordId. block value ])
	  ) initFor: block.
	^i! !

"June 9, 2007 -> 0:53:30"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'platform classes' !
processClass
	^Win32Process! !

"June 9, 2007 -> 0:54:29"!

Delta define: #UnixProcess as: (
(Class subclassOf: 'Process' instanceVariables: '')) !


"June 9, 2007 -> 0:55:3"!

! (Delta mirrorFor: #UnixProcess) methodsFor: 'private-initialization' !
recordId! !

"June 9, 2007 -> 1:0:15"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'platform classes' !
processClass

	^UnixProcess! !

"June 9, 2007 -> 1:8:57"!

"System saved" !
"June 9, 2007 -> 14:1:17"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"June 9, 2007 -> 14:1:19"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"June 9, 2007 -> 14:1:19"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"June 9, 2007 -> 14:1:19"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"June 9, 2007 -> 14:1:19"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"June 9, 2007 -> 14:1:19"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"June 9, 2007 -> 14:1:19"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"June 9, 2007 -> 14:1:19"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"June 9, 2007 -> 14:1:19"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"June 9, 2007 -> 14:1:19"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"June 9, 2007 -> 14:1:19"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"June 9, 2007 -> 14:1:20"!

(Delta mirrorFor: #Process)
comment: 
'Tags: %BlueBook %User

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license
'!


"June 9, 2007 -> 14:1:21"!

! (Delta mirrorFor: #Process) classSide methodsFor: 'instance creation' !
for: block <[]> ^<Instance>
	"Create and return a new process that will execute the block at the
	 specified priority.  The new process is suspended."

	| i <Instance> |
	i := (guaranteed <Instance>
		{{self primitiveProcessCreate: [ i recordId. block value ]
				ifFail: [ :err <Symbol> | self error: err ]
		}}
	  ) initFor: block.
	^i! !

"June 9, 2007 -> 14:1:22"!

! (Delta mirrorFor: #Process) classSide methodsFor: 'file out' !
fileOutSignature ^<Integer>
    ^80! !

"June 9, 2007 -> 14:1:23"!

! (Delta mirrorFor: #Process) methodsFor: 'private-initialization' !
initFor: block <[]>

	body := block.

	self register.
	
! !

"June 9, 2007 -> 14:1:24"!

! (Delta mirrorFor: #Process) methodsFor: 'private-initialization' !
recordId

	win32Handle := {{<kernel Win32Handle GetCurrentThreadId> call}}! !

"June 9, 2007 -> 14:1:25"!

! (Delta mirrorFor: #Process) methodsFor: 'accessing' !
priority ^<Int>

	^priority! !

"June 9, 2007 -> 14:1:26"!

! (Delta mirrorFor: #Process) methodsFor: 'accessing' !
priority: prio <Int>

	priority := prio! !

"June 9, 2007 -> 14:1:27"!

! (Delta mirrorFor: #Process) methodsFor: 'accessing' !
processError ^ <ProcessError>

	^processError
! !

"June 9, 2007 -> 14:1:28"!

! (Delta mirrorFor: #Process) methodsFor: 'accessing' !
status ^<Symbol>
	"One of:
		#Initialized				- State right after creation.
		#Yielded					- Gave up control by calling yield.
		#InAsyncDLL			- Gave up control but continues to execute asynchronous DLL.
		#Stopped				- Gave up control by calling stop.
		#Preempted			- Was preempted by system.
		#Running					- Currently running
		#Completed			- Ran to completion.
		#Killed						- The process has been terminated.
		#BooleanError		- A boolean was expected at hardcoded control structure.
		#LookupError			- The receiver does not understand doesNotUnderstand:.
		#PrimitiveLookupError	- Binding a primitive failed.
		#DLLLookupError				 - Binding a DLL function failed.
		#NLRError				- Context for NLR did not exist.
		#StackOverflow		- Stack exhausted.
	"

	^{{self primitiveProcessStatus}}! !

"June 9, 2007 -> 14:1:29"!

! (Delta mirrorFor: #Process) methodsFor: 'testing' !
running ^<Boolean>
	"Not suspended, dying, or dead. (This includes processes blocked in async dll calls)"

	^Processor isRunning: self! !

"June 9, 2007 -> 14:1:30"!

! (Delta mirrorFor: #Process) methodsFor: 'testing' !
suspended ^<Boolean>
	"Not on the running list, but can be resumed"

	| s <Symbol> |
	self running
		ifTrue: [ ^false ].
	s := self status.
	^s == #Yielded
		or: [ s == #InAsyncDLL
		or: [ s == #Initialized
		or: [ s == #Preempted
		or: [ s == #Stopped ]   ]]]! !

"June 9, 2007 -> 14:1:31"!

! (Delta mirrorFor: #Process) methodsFor: 'control' !
resume

	Processor resume: self! !

"June 9, 2007 -> 14:1:32"!

! (Delta mirrorFor: #Process) methodsFor: 'control' !
suspend

	Processor suspend: self.
	Processor activeProcess = self
		ifTrue: [ self yield ]! !

"June 9, 2007 -> 14:1:34"!

! (Delta mirrorFor: #Process) methodsFor: 'control' !
terminate

	Processor terminating: self.
	self vmTerminate.	! !

"June 9, 2007 -> 14:1:35"!

! (Delta mirrorFor: #Process) methodsFor: 'control' !
waitUntilDead
	"can be called after a process has been terminated to wait until it has completed
		unwinding its stack etc, and is truly dead.  This loops currently, so it is not
		a good way for waiting for the death of a process that has not been terminated.
		This may never return if the process that has been terminated does not ever
		finish cleaning up."
	
	[ self running ]
		whileTrue: [ Processor yield ]! !

"June 9, 2007 -> 14:1:36"!

! (Delta mirrorFor: #Process) methodsFor: 'restricted' !
activationStack ^ <Array[Activation]>

	^{{self primitiveProcessStackLimit: 100 ifFail: [ :err <CompressedSymbol>  | self error: err]}}! !

"June 9, 2007 -> 14:1:37"!

! (Delta mirrorFor: #Process) methodsFor: 'restricted' !
processError: e <ProcessError>

	processError := e
! !

"June 9, 2007 -> 14:1:38"!

! (Delta mirrorFor: #Process) methodsFor: 'restricted' !
stopInEvaluator

	Processor stopInEvaluator: self! !

"June 9, 2007 -> 14:1:39"!

! (Delta mirrorFor: #Process) methodsFor: 'restricted' !
traceStack

	{{self primitiveProcessTraceStack: 20 ifFail: [ :err <Symbol> | self error: err]}}
! !

"June 9, 2007 -> 14:1:40"!

! (Delta mirrorFor: #Process) methodsFor: 'restricted' !
win32Handle ^<Win32Handle>
	"This is valid only after the process has begun to actually execute"

	^win32Handle! !

"June 9, 2007 -> 14:1:41"!

! (Delta mirrorFor: #Process) methodsFor: 'restricted' !
yield
	{{primitiveProcessYield}}! !

"June 9, 2007 -> 14:1:42"!

! (Delta mirrorFor: #Process) methodsFor: 'file out' !
fileOutSignature ^<Integer>
    ^112! !

"June 9, 2007 -> 14:1:43"!

! (Delta mirrorFor: #Process) methodsFor: 'private' !
register

	Processor register: self.! !

"June 9, 2007 -> 14:1:44"!

! (Delta mirrorFor: #Process) methodsFor: 'private' !
vmTerminate

	{{self primitiveProcessTerminateIfFail: [ :err <Symbol> | self error: err ]}}! !

"June 9, 2007 -> 14:6:45"!

! (Delta mirrorFor: #Process) classSide methodsFor: 'instance creation' !
primitiveCreate: block! !

"June 9, 2007 -> 14:31:1"!

"System saved" !
"June 9, 2007 -> 15:17:24"!

! (Delta mirrorFor: #IdleProcess) classSide methodsFor: 'accessing' !
hasIdleActions

	^self theIdleProcess hasIdleActions! !

"June 9, 2007 -> 15:17:49"!

! (Delta mirrorFor: #ProcessorScheduler) methodsFor: 'private' !
hasIdleActions ^<Boolean>

	^IdleProcess hasIdleActions! !

"June 9, 2007 -> 17:42:19"!

Delta define: #TestA as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 9, 2007 -> 17:42:50"!

Delta define: #TestA as: (
(Class subclassOf: 'Object' instanceVariables: 'one two three')) !


"June 9, 2007 -> 17:43:43"!

Delta define: #TestA as: (
(Class subclassOf: 'Object' instanceVariables: 'one three')) !


"June 9, 2007 -> 17:44:17"!

Delta define: #TestA as: (
(Class subclassOf: 'Object' instanceVariables: 'one two three')) !


"June 9, 2007 -> 17:44:48"!

! (Delta mirrorFor: #TestA) methodsFor: 'accessing' !
one: aValue

	one := aValue! !

"June 9, 2007 -> 17:45:6"!

! (Delta mirrorFor: #TestA) methodsFor: 'accessing' !
two: aValue

	two := aValue! !

"June 9, 2007 -> 17:45:18"!

! (Delta mirrorFor: #TestA) methodsFor: 'accessing' !
three: aValue

	three := aValue! !

"June 9, 2007 -> 17:47:0"!

(Delta mirrorFor: #TestA) removeMethod: #two: ifAbsent: [] !


"June 9, 2007 -> 17:47:23"!

Delta define: #TestA as: (
(Class subclassOf: 'Object' instanceVariables: 'one three')) !


"June 9, 2007 -> 17:51:37"!

(Delta mirrorFor: #TestA) removeDefinitionIfFail: [] !


"June 9, 2007 -> 18:34:20"!

! (Delta mirrorFor: #IdleProcess) methodsFor: 'private' !
process

	^self! !

"June 9, 2007 -> 21:39:47"!

(Delta mirrorFor: #IdleProcess) removeMethod: #process ifAbsent: [] !


"June 9, 2007 -> 21:42:19"!

! (Delta mirrorFor: #Process) classSide methodsFor: 'os-specific' !
processClass ! !

"June 9, 2007 -> 21:42:48"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'os-specific' !
processClass ! !

"June 9, 2007 -> 21:43:17"!

(Delta mirrorFor: #Win32Platform) classSide removeMethod: #processClass ifAbsent: [] !


"June 9, 2007 -> 21:44:8"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'os specific' !
currentThreadId

	^{{<kernel Win32Handle GetCurrentThreadId> call}}! !

"June 9, 2007 -> 21:44:31"!

! (Delta mirrorFor: #Process) methodsFor: 'private-initialization' !
recordId

	win32Handle := Platform currentThreadId! !

"June 9, 2007 -> 21:45:0"!

(Delta mirrorFor: #Process) classSide removeMethod: #processClass ifAbsent: [] !


"June 9, 2007 -> 21:45:57"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'os specific' !
currentThreadId

	^0! !

"June 9, 2007 -> 21:50:6"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'os specific' !
currentThreadId
	" stub to allow compatibility with Win32 "
	self deltaHack.
	^0! !

"June 9, 2007 -> 21:51:28"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'os specific' !
currentThreadId
	" stub to allow compatibility with Win32 specifics of process "
	self deltaHack.
	^0! !

"June 9, 2007 -> 21:52:38"!

(Delta mirrorFor: #Process) classSide removeMethod: #primitiveCreate: ifAbsent: [] !


"June 9, 2007 -> 22:6:12"!

"System saved" !
"June 10, 2007 -> 0:57:19"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLMapName: name <Str> ^<Str>
    ^name , '.so'! !

"June 10, 2007 -> 1:4:51"!

! (Delta mirrorFor: #UnixPlatform) methodsFor: 'instance creation' !
processClass! !

"June 10, 2007 -> 1:5:35"!

! (Delta mirrorFor: #UnixPlatform) methodsFor: 'instance creation' !
processClass 
! !

"June 10, 2007 -> 1:6:35"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'platform classes' !
processClass 
! !

"June 10, 2007 -> 1:6:53"!

(Delta mirrorFor: #UnixPlatform) classSide removeMethod: #processClass ifAbsent: [] !


"June 10, 2007 -> 1:6:59"!

(Delta mirrorFor: #UnixPlatform) removeMethod: #processClass ifAbsent: [] !


"June 10, 2007 -> 1:17:21"!

Delta define: #UnixFilePattern as: (
(Class subclassOf: 'FilePattern' instanceVariables: '')) !


"June 10, 2007 -> 1:17:21"!

(Delta mirrorFor: #UnixFilePattern)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"June 10, 2007 -> 1:17:23"!

! (Delta mirrorFor: #UnixFilePattern) classSide methodsFor: 'instance creation' !
for: pat <Str>  ^<FilePattern>

    self assert: [ self validPattern: pat ].
    ^self new pattern: pat! !

"June 10, 2007 -> 1:17:24"!

! (Delta mirrorFor: #UnixFilePattern) classSide methodsFor: 'testing' !
validPattern: pat <Str> ^<Boolean>

    "Make sure this is a valid syntactic pattern (should be valid even if no *s)"
    self unimplemented! !

"June 10, 2007 -> 1:17:25"!

! (Delta mirrorFor: #UnixFilePattern) classSide methodsFor: 'restricted' !
patternHasWildcards: pat <Str> ^<Boolean>

    ^(pat includes: Platform multipleMatchWildcardCharacter)
        or: [ pat includes: Platform singleMatchWildcardCharacter ]! !

"June 10, 2007 -> 1:17:26"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'private' !
firstWildElementOf: els <SeqCltn[FilePattern]> ifFail: fail <[^X def]> ^<Int | X>

    1 to: els size do:
        [ :i <Int> |
            (els at: i) isPath
                ifFalse: [ ^i ]
        ].
    ^fail value! !

"June 10, 2007 -> 1:17:27"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'private' !
patternExtending: pat <FilePattern> ^<Str>

    ^pat pattern last = $\
        ifTrue: [ pat pattern, self pattern ]
        ifFalse: [ pat pattern,'\', self pattern ]! !

"June 10, 2007 -> 1:17:29"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'private' !
terminalPathsDo: blk <[FilePath]>

    "assumes that the last element of the receiver is the only one that contains wildcards"
    | data <WIN32_FIND_DATA> hnd <Win32Handle> allpat <CString> pat <Str> els <SeqCltn[FilePattern]> prefix <Str> |
    data := WIN32_FIND_DATA new allocate.
    els := self elements.
    "%todo %opt - should check to see if the pattern is suitable for the windows call directly, so that the 
        elements are prefiltered.  Rule would be: use pattern directly if * appears only just before a dot or at the
        end, and contains no other wildcards"
    els size = 1
        ifTrue: [   allpat := CString for: '*.*'.
                        prefix := ''. ]
        ifFalse: [  allpat := CString for: self containingDirectory pattern, '\*.*'.
                            prefix := (FilePattern forAll: (els copyFrom: 1 to: els size - 1)) pattern,'\'.  ].
    pat := els last pattern.
    [   hnd := {{<kernel Win32Handle FindFirstFileA>
                        pattern: allpat
                        data: data
                    }}.
        hnd @= Win32 INVALID_HANDLE_VALUE
            ifTrue: [ Win32 getLastError @= Win32 ERROR_NO_MORE_FILES
                            ifFalse: [ Win32 handleError ]
                            ifTrue: [ ^self ]
                        ]
            ifFalse: [  [   | next <Str> |
                                next := data cFileName asString.
                                ((pat platformMatch: next) and: [ next ~= '.' and: [ next ~= '..' ]])
                                    ifTrue: [ blk value: (FilePath for: prefix,next) ].
                                [   {{<kernel Win32Handle FindNextFileA>
                                        hnd: hnd
                                        data: data
                                    }} asBoolean
                                        ifFalse: [ Win32 getLastError @= Win32 ERROR_NO_MORE_FILES
                                                            ifFalse: [ Win32 handleError ]
                                                            ifTrue: [ ^self ]
                                                     ]
                                        ifTrue: [   next := data cFileName asString.
                                                        ((pat platformMatch: next) and: [ next ~= '.' and: [ next ~= '..' ]])
                                                            ifTrue: [ blk value: (FilePath for: prefix,next) ].
                                                    ]
                                ] repeat.
                            ] ensure:
                                [   {{<kernel Win32Handle FindClose> hnd: hnd}} asBoolean
                                        ifFalse: [ Win32 handleError ].
                                ]
                        ]                                       
    ] ensure:
        [   data free.
            allpat free.        ]! !

"June 10, 2007 -> 1:17:30"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'testing' !
isAbsolute ^<Boolean>

    ^self pattern includes: $:! !

"June 10, 2007 -> 1:17:31"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'iterating' !
elementsDo: blk <[FilePattern]>

    | s <CharacterReadStream> |

    s := self pattern readStream.
    [ s atEnd ]
        whileFalse:
            [   | next <Str> |
                next := s upTo: $\.
                (next includes: $:)
                    ifTrue: [ next := next,'\' ].
                blk value: (FilePattern for: next)  ].! !

"June 10, 2007 -> 1:17:32"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'iterating' !
pathsDo: blk <[FilePath]>

    | els <SeqCltn[FilePattern]> i <Int> |
    els := self elements.
    i := self firstWildElementOf: els
                ifFail: [ ^self shouldNotHappen ].
    i = els size
        ifTrue: [ self terminalPathsDo: blk ]
        ifFalse: [  | rest <FilePattern> |
                        i + 1 = els size
                            ifTrue: [ rest := els last ]
                            ifFalse: [ rest := FilePattern forAll: (els copyFrom: i + 1 to: els size) ].
                        (FilePattern forAll: (els copyFrom: 1 to: i))
                            pathsDo:
                                [ :fp <FilePath> |
                                    fp isDirectory
                                        ifTrue: [ (fp, rest) pathsDo: blk ]     ]
                     ]! !

"June 10, 2007 -> 1:17:33"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'accessing' !
extensions ^<FilePattern>

    ^self , (FilePattern for: '*')! !

"June 10, 2007 -> 1:17:53"!

Delta define: #UnixFilePath as: (
(Class subclassOf: 'FilePath mixin |>(ExternalStreamableObject mixin |>(ExternalObject mixin |>UnixFilePattern))' instanceVariables: '')) !


"June 10, 2007 -> 1:17:53"!

(Delta mirrorFor: #UnixFilePath)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"June 10, 2007 -> 1:17:55"!

! (Delta mirrorFor: #UnixFilePath) classSide methodsFor: 'instance creation' !
currentDirectory ^<FilePath>

    | buf <CString> buflen <Int> |
    buflen := 1000.
    buf := CString new malloc: buflen.
    ^[      {{<kernel ExternalProxy GetCurrentDirectoryA>
                size: buflen
                buf: buf
            }} isNull
                ifTrue: [ Win32 handleError ]
                ifFalse: [ self new pattern: buf asString ]
      ] ensure: [ buf free ]! !

"June 10, 2007 -> 1:17:56"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
exists ^<Boolean>

    self win32FileAttributesIfFail: [ ^false ].
    ^true! !

"June 10, 2007 -> 1:17:57"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
isDirectory ^<Boolean>

    ^((self win32FileAttributesIfFail: [ ^false ])
            externalBitAnd: Win32 FILE_ATTRIBUTE_DIRECTORY
      ) @~= 0! !

"June 10, 2007 -> 1:17:58"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
isReadOnly ^<Boolean>

    ^((self win32FileAttributesIfFail: [ ^false ])
            externalBitAnd: Win32 FILE_ATTRIBUTE_READONLY
      ) @~= 0! !

"June 10, 2007 -> 1:17:59"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
isSyntaxValid ^<Boolean>

    "Extend inherited version to ensure no wildcard characters"
    ^super isSyntaxValid and: [ self unimplemented ]! !

"June 10, 2007 -> 1:18:0"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
createValueFor: mode <Symbol>  ^<ExternalData>

    mode = #read
        ifTrue: [ ^3        "OPEN_EXISTING" ].
    mode = #write
        ifTrue: [ ^2        "CREATE_ALWAYS" ].
    mode = #readWrite
        ifTrue: [ ^4        "OPEN_ALWAYS" ].
    self shouldNotHappen! !

"June 10, 2007 -> 1:18:1"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
deleteDirectoryIfFail: blk <[Symbol]>

    | name <CString> |
    name := CString for: self name.
    [   {{<kernel ExternalProxy RemoveDirectoryA>
                name: name
        }} asBoolean
            ifFalse: [ blk value: #ErrorDeletingDirectory ]
    ] ensure: [ name free ]! !

"June 10, 2007 -> 1:18:2"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
deleteFileIfFail: blk <[Symbol]>

    | name <CString> |
    name := CString for: self name.
    [   {{<kernel ExternalProxy DeleteFileA>
                name: name
        }} asBoolean
            ifFalse: [ blk value: #ErrorDeletingFile ]
    ] ensure: [ name free ]! !

"June 10, 2007 -> 1:18:3"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
fileAttributesFor: mode <Symbol>  ^<ExternalData>
    
    mode = #read
        ifTrue: [ ^ExternalProxy new
                    setHigh:    16r0800        "FILE_FLAG_SEQUENTIAL_SCAN"
                    low:            16r80        "FILE_ATTRIBUTE_NORMAL"    ].
    (mode = #write)
        ifTrue: [ ^ExternalProxy new
                    setHigh:    16r0000
                    low:            16r80        "FILE_ATTRIBUTE_NORMAL"    ].
    (mode = #readWrite)
        ifTrue: [ ^ExternalProxy new
                    setHigh:    16r0000    
                    low:            16r80        "FILE_ATTRIBUTE_NORMAL"    ].
    self shouldNotHappen.! !

"June 10, 2007 -> 1:18:4"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
fileDescriptorClass ^<FileDescriptor class>

    ^Win32FileDescriptor! !

"June 10, 2007 -> 1:18:5"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
modeProxyFor: mode <Symbol> ^<ExternalData>

    mode = #read
        ifTrue: [ ^ExternalProxy new setHigh: 16r8000 low: 0 ].
    mode = #write
        ifTrue: [ ^ExternalProxy new setHigh: (16r4000 bitOr: 16r8000) low: 0 ].
    mode = #readWrite
        ifTrue: [ ^ExternalProxy new setHigh: (16r4000 bitOr: 16r8000) low: 0 ].! !

"June 10, 2007 -> 1:18:6"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
sharingValueFor: mode <Symbol> ^<ExternalData>

    mode = #read
        ifTrue: [ ^1    "FILE_SHARE_WRITE" ].
    "in all other cases"
    ^0 "no sharing"! !

"June 10, 2007 -> 1:18:7"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
win32FileAttributesIfFail: blk <[^X def]> ^<ExternalProxy | X>

    | name <CString> |
    name := CString for: self name.
    ^[  | result <ExternalProxy> |
        result := {{<kernel ExternalProxy GetFileAttributesA>
                            name: name
                        }}.
        result @= (ExternalProxy forHigh: 16rFFFF low: 16rFFFF)
            ifTrue: [ blk value ]
            ifFalse: [ result ]
     ] ensure: [ name free ]! !

"June 10, 2007 -> 1:18:8"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'restricted' !
openInternalFor: mode <Symbol> ifFail: err <[ExternalError, ^X def]>  ^<ExternalProxy | X>

    "%todo: use overlapped io"
    |   dname <ExternalProxy>
        dmode <ExternalData>
        dsharing <ExternalData>
        dcreate <ExternalData>
        dattributes <ExternalData>
        proxy <ExternalProxy> |
    dname := self nameProxy.
    dmode := self modeProxyFor: mode.
    dsharing := self sharingValueFor: mode.
    dcreate := self createValueFor: mode.
    dattributes := self fileAttributesFor: mode.

    proxy := self win32CreateFile_name: dname
        mode: dmode
        sharing: dsharing
        security: 0
        create: dcreate
        attributes: dattributes
        template: 0.

    dname free.
    ^proxy isAllOnes
        ifFalse: [ proxy ]
        ifTrue: [ err value: #cannotOpenFile ]! !

"June 10, 2007 -> 1:18:9"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'restricted' !
win32CreateFile_name: dname    <ExternalData>
mode: dmode            <ExternalData>
sharing: dsharing        <ExternalData>
security: dsecurity        <ExternalData>
create: dcreate            <ExternalData>
attributes: dattributes    <ExternalData>
template: dtemplate        <ExternalData>
^<ExternalProxy>
    ^{{<kernel ExternalProxy CreateFileA>
        name: dname
        mode: dmode
        sharing: dsharing
        security: dsecurity
        create: dcreate
        attributes: dattributes
        template: dtemplate}}! !

"June 10, 2007 -> 1:18:11"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'control' !
createDirectoryIfFail: fail <[Symbol]>

    | name <CString> sec <SECURITY_ATTRIBUTES> |
    name := CString for: self name.
    sec := SECURITY_ATTRIBUTES new allocateZeroed.
    sec nLength: sec structureSize.

    [   {{<kernel ExternalProxy CreateDirectoryA>
            name: name
            security: sec
        }} asBoolean
            ifFalse: [ Win32 getLastError @= Win32 ERROR_ALREADY_EXISTS
                                ifFalse: [ fail value: #CannotCreateFile ] ]
    ] ensure: [ name free.
                        sec free.    ]! !

"June 10, 2007 -> 1:18:12"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'restricted-double dispatching' !
deletePathIfFail: blk <[Symbol]>

    self exists
        ifFalse: [  blk value: #NoSuchFileOrDirectory.
                        ^self       ].
    self isDirectory
        ifTrue: [ self deleteDirectoryIfFail: blk ]
        ifFalse: [ self deleteFileIfFail: blk ]! !

"June 10, 2007 -> 1:18:13"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'copying-moving' !
copyAs: newPath <FilePath> ifFail: fail <[ExternalError]>

    | csrc <CString> cdest <CString> |
    csrc := CString for: self name.
    cdest := CString for: newPath name.
    [   {{<kernel ExternalProxy CopyFileA>
                source: csrc
                dest: cdest
                failIfExists: false asExternalData
        }} asBoolean
            ifFalse: [  fail value:
                                ('Error copying file: ', Win32 getLastError printString) asSymbol ]
    ] ensure:
        [   csrc free.
            cdest free  ]! !

"June 10, 2007 -> 1:18:14"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'copying-moving' !
moveAs: newPath <FilePath> ifFail: fail <[ExternalError]>

    | csrc <CString> cdest <CString> |
    csrc := CString for: self name.
    cdest := CString for: newPath name.
    [   {{<kernel ExternalProxy MoveFileA>
                source: csrc
                dest: cdest
        }} asBoolean
            ifFalse: [  | err <ExternalData> |
                            err := Win32 getLastError.
                            err @= Win32 ERROR_ALREADY_EXISTS
                                ifTrue: [   fail value: #AlreadyExists.
                                                 ^self.  ].
                            err @= Win32 ERROR_SHARING_VIOLATION
                                ifTrue: [   fail value: #SharingViolation.
                                                 ^self.  ].
                            fail value:
                                ('Error moving file: ', Win32 getLastError printString) asSymbol ]
    ] ensure:
        [   csrc free.
            cdest free  ]! !

"June 10, 2007 -> 1:18:15"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'accessing' !
type ^<Str>
    "The file type (on most platforms this is the part after the $. at the end)"

    | indices <SeqCltn[Int]> |
    indices := self name indicesOfSubCollection: '.'.
    indices isEmpty
        ifTrue: [ ^'' ].
    ^self name
            copyFrom: indices last + 1
            to: self name size! !

"June 10, 2007 -> 1:19:17"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'platform classes' !
pathClass ^<FilePath class>

    ^UnixFilePath! !

"June 10, 2007 -> 1:19:25"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'platform classes' !
patternClass ^<FilePattern class>

    ^UnixFilePattern! !

"June 10, 2007 -> 1:51:59"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
exists ^<Boolean>
	| name result |
	name := CString for: self name.
    [ result := {{<libc ExternalProxy open>
   	 					name: name
    					flags: 0}}.
     	^result asSmallInteger >= 0]
     	ensure: [ name free.
     				{{<libc ExternalProxy close>
   	 					fd: result}} ]! !

"June 10, 2007 -> 1:53:55"!

"System saved" !
"June 11, 2007 -> 21:19:33"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
modeProxyFor: mode <Symbol> ^<ExternalData>

    mode = #read
        ifTrue: [ ^ExternalProxy new set: 0 ].
    mode = #write
        ifTrue: [ ^ExternalProxy new set: 1 ].
    mode = #readWrite
        ifTrue: [ ^ExternalProxy new set: 2 ]! !

"June 11, 2007 -> 21:20:50"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
modeProxyFor: mode <Symbol> ^<SmallInt>

    mode = #read
        ifTrue: [ ^0 ].
    mode = #write
        ifTrue: [ ^1 ].
    mode = #readWrite
        ifTrue: [ ^2 ]! !

"June 11, 2007 -> 21:21:29"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
modeFor: mode <Symbol> ^<SmallInt>

    mode = #read
        ifTrue: [ ^0 ].
    mode = #write
        ifTrue: [ ^1 ].
    mode = #readWrite
        ifTrue: [ ^2 ]! !

"June 11, 2007 -> 21:21:45"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'restricted' !
openInternalFor: mode <Symbol> ifFail: err <[ExternalError, ^X def]>  ^<ExternalProxy | X>

    "%todo: use overlapped io"
    |   dname <ExternalProxy>
        dmode <ExternalData>
        dsharing <ExternalData>
        dcreate <ExternalData>
        dattributes <ExternalData>
        proxy <ExternalProxy> |
    dname := self nameProxy.
    dmode := self modeFor: mode.

    proxy := {{<libc ExternalProxy open>
    					name: dname
    					flags: dmode }}

    dname free.
    ^proxy isAllOnes
        ifFalse: [ proxy ]
        ifTrue: [ err value: #cannotOpenFile ]! !

"June 11, 2007 -> 21:22:10"!

(Delta mirrorFor: #UnixFilePath) removeMethod: #win32CreateFile_name:mode:sharing:security:create:attributes:template: ifAbsent: [] !


"June 11, 2007 -> 21:23:10"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'restricted' !
openInternalFor: mode <Symbol> ifFail: err <[ExternalError, ^X def]>  ^<ExternalProxy | X>

    "%todo: use overlapped io"
    |   dname <ExternalProxy>
        dmode <SmallInt>
        proxy <ExternalProxy> |
    dname := self nameProxy.
    dmode := self modeFor: mode.

    proxy := {{<libc ExternalProxy open>
    					name: dname
    					flags: dmode }}

    dname free.
    ^proxy isAllOnes
        ifFalse: [ proxy ]
        ifTrue: [ err value: #cannotOpenFile ]! !

"June 11, 2007 -> 21:25:15"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'restricted' !
openInternalFor: mode <Symbol> ifFail: err <[ExternalError, ^X def]>  ^<ExternalProxy | X>

    |   dname <ExternalProxy>
        dmode <SmallInt>
        proxy <ExternalProxy> |
    dname := self nameProxy.
    dmode := self modeFor: mode.

    proxy := {{<libc ExternalProxy open>
    					name: dname
    					flags: dmode }}

    dname free.
    ^proxy isAllOnes
        ifFalse: [ proxy ]
        ifTrue: [ err value: #cannotOpenFile ]! !

"June 11, 2007 -> 21:27:42"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'restricted' !
openInternalFor: mode <Symbol> ifFail: err <[ExternalError, ^X def]>  ^<ExternalProxy | X>

    |   dname <ExternalProxy>
        dmode <SmallInt>
        proxy <ExternalProxy> |
    dname := self nameProxy.
    dmode := self modeFor: mode.

    [ proxy := {{<libc ExternalProxy open>
    					name: dname
    					flags: dmode }} ]
    		ensure: [ dname free ].

    ^proxy isAllOnes
        ifFalse: [ proxy ]
        ifTrue: [ err value: #cannotOpenFile ]! !

"June 11, 2007 -> 21:28:44"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'restricted' !
openInternalFor: mode <Symbol> ifFail: err <[ExternalError, ^X def]>  ^<ExternalProxy | X>

    |   dname <ExternalProxy>
        dmode <SmallInt>
        proxy <ExternalProxy> |
    dname := self nameProxy.

    [ dmode := self modeFor: mode.
    	proxy := {{<libc ExternalProxy open>
    					name: dname
    					flags: dmode }} ]
    		ensure: [ dname free ].

    ^proxy isAllOnes
        ifFalse: [ proxy ]
        ifTrue: [ err value: #cannotOpenFile ]! !

"June 11, 2007 -> 21:30:9"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
win32FileAttributesIfFail: blk <[^X def]> ^<ExternalProxy | X>

    | name <CString> |
    self halt.
    name := CString for: self name.
    ^[  | result <ExternalProxy> |
        result := {{<kernel ExternalProxy GetFileAttributesA>
                            name: name
                        }}.
        result @= (ExternalProxy forHigh: 16rFFFF low: 16rFFFF)
            ifTrue: [ blk value ]
            ifFalse: [ result ]
     ] ensure: [ name free ]! !

"June 11, 2007 -> 22:28:5"!

Delta define: #UnixFileDescriptor as: (
(Class subclassOf: 'FileDescriptor' instanceVariables: 'ioCount <ExternalProxy>
            "Used to hold the count of bytes read/written, & other temporary results, for speed"
        ')) !


"June 11, 2007 -> 22:28:5"!

(Delta mirrorFor: #UnixFileDescriptor)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.2 $
'!


"June 11, 2007 -> 22:28:7"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
initializeIOCount
    ioCount := ExternalProxy new.
    ioCount malloc: 4.! !

"June 11, 2007 -> 22:28:7"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
ioCount ^<ExternalProxy>

    ^ioCount! !

"June 11, 2007 -> 22:28:8"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
postCopy
    super postCopy.
    self initializeIOCount.! !

"June 11, 2007 -> 22:28:9"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
printLastError
    | result |
    "Dump the error message for the last windows call"
    "%temporary"
    result := {{<kernel ExternalProxy GetLastError>geterror}}.
    Platform errorStream show: 'Last error from windows: ', result asSmallInteger printString; cr! !

"June 11, 2007 -> 22:28:10"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
setExternalPosition: p <Int>
    "%todo: support large integer positions for extremely large files"
    {{<kernel ExternalProxy SetFilePointer>
        handle: self handle
        distanceLow: p
        distanceHigh: 0
        moveMethod: 0 }}    "FILE_BEGIN"! !

"June 11, 2007 -> 22:28:11"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'i/o' !
readAt: pos <Int> ifFail: errf <[ExternalError]> ^<Int>
    | result <ExternalProxy> count <Int> |
    self position = pos
        ifFalse: [ self position: pos ].
    self knowAtEnd
        ifTrue: [        count := 0 ]
        ifFalse: [
                    result := {{<kernel ExternalProxy ReadFile>
                        handle: self handle
                        buffer: self buffer
                        count: self bufferSize
                        numberRead: self ioCount
                        overlapped: 0    }}.
                    result isNull
                        ifTrue: [ 
                        self printLastError.
                        errf value: #IOError.
                                ^0    ].
                    count := self ioCount smallIntegerAt: 0.    ].
    self setPosition: self position + count.
    ^count! !

"June 11, 2007 -> 22:28:12"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'i/o' !
write: nBytes <Int> at: pos <Int> ifFail: errf <[ExternalError]>
    | result <ExternalProxy> count <Int> |
    self position ~= pos
        ifTrue: [ self position: pos ].
    result := {{<kernel ExternalProxy WriteFile>
        handle: self handle
        buffer: self buffer
        count: nBytes
        numberWritten: self ioCount
        overlapped: 0 }}.
    result isNull
        ifTrue: [ errf value: #IOError.
                ^0    ].
    count := self ioCount smallIntegerAt: 0.
    self setPosition: self position + count.! !

"June 11, 2007 -> 22:28:14"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'accessing' !
getBufferSize ^<Int>

    "Use the sector size"
    ^self sectorSize * 8! !

"June 11, 2007 -> 22:28:15"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'accessing' !
sectorSize ^<Int>
    "Use the sector size"
    | junk <ExternalProxy> bytesPerSector <ExternalProxy> status <ExternalProxy> result <Int> |
    junk := ExternalProxy new malloc: Platform wordSize.
    bytesPerSector := ExternalProxy new malloc: Platform wordSize.
    status := {{<kernel ExternalProxy GetDiskFreeSpaceA>
            rootPath: 0
            sectorsPerCluster: junk
            bytesPerSector: bytesPerSector
            freeClusters: junk
            clusters: junk    }}.
    status isNull
        ifTrue: [ self error: 'Cannot get disk sector size' ]
        ifFalse: [ result := bytesPerSector smallIntegerAt: 0 ].
    junk free.
    bytesPerSector free.
    ^result! !

"June 11, 2007 -> 22:28:16"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'accessing' !
size ^<Int>
    | result <ExternalProxy> |
    result := {{<kernel ExternalProxy GetFileSize>
                handle: self handle
                sizeHigh: self ioCount    }}.
    self ioCount isAllOnes
        ifTrue: [ "must check for possible error status"
                | status <ExternalProxy> |
                "status := {<kernel ExternalProxy GetLastError>}."
                status isNull    "NO_ERROR"
                    ifFalse: [ self error: 'Can''t get file size' ].    ].
    ^(ioCount smallIntegerAt: 0) = 0
        ifFalse: [    "%todo: construct a large integer from the high&low words"
                    self unimplemented    ]
        ifTrue: [ result asSmallInteger ]! !

"June 11, 2007 -> 22:28:17"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'control' !
flushIfFail: errf <[ExternalError]>

    | result <ExternalProxy> |
    "%todo: uncomment"
    "result := {<kernel ExternalProxy FlushFileBuffers async>
        handle: self handle }."
    result isNull
        ifTrue: [ errf value: 'I/O Error flushing file information' ].! !

"June 11, 2007 -> 22:28:18"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'control' !
openIfFail: err <[ExternalError]>
    super openIfFail: err.
    self ioCount malloc: Platform wordSize.! !

"June 11, 2007 -> 22:28:19"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'control' !
severExternalConnections
    | result <ExternalProxy> |
    
    super severExternalConnections.
    self ioCount free.
    result := {{<kernel ExternalProxy CloseHandle>
        handle: self handle }}.
    result isNull
        ifTrue: [ self error: 'Error closing file handle' ].! !

"June 11, 2007 -> 22:28:20"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'initialization' !
mode: m <Symbol>
    super mode: m.
    self initializeIOCount.! !

"June 11, 2007 -> 22:29:30"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
fileDescriptorClass ^<FileDescriptor class>

    ^UnixFileDescriptor! !

"June 11, 2007 -> 22:32:37"!

"System saved" !
"June 12, 2007 -> 1:35:32"!

Delta define: #StatBuffer as: (
(Class subclassOf: 'CStructure' instanceVariables: '')) !


"June 12, 2007 -> 2:14:23"!

(Delta mirrorFor: #StatBuffer)
comment: 
'Represents the buffer in which stat
returns file attributes'!


"June 12, 2007 -> 2:15:42"!

! (Delta mirrorFor: #StatBuffer) methodsFor: 'accessing' !
blockSize

	^self smallIntegerAt: self blockSizeOffset! !

"June 12, 2007 -> 2:15:59"!

! (Delta mirrorFor: #StatBuffer) methodsFor: 'accessing' !
structureSize

	^88! !

"June 12, 2007 -> 2:16:24"!

! (Delta mirrorFor: #StatBuffer) methodsFor: 'offsets' !
blockSizeOffset

	^48! !

"June 12, 2007 -> 2:38:52"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'accessing' !
blockSize ^<Int>
    "Use the sector size"
    | statBuffer <StatBuffer> 
    	status <ExternalProxy> |
    statBuffer := StatBuffer new allocate.
    [ status := {{<libc ExternalProxy fstat>
            			name: self handle
            			buffer: statBuffer    }}.
	^status asSmallInteger == -1
		ifTrue: [4096]
		ifFalse: [ statBuffer blockSize ]]
		ensure: [ statBuffer free]! !

"June 12, 2007 -> 2:39:9"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'accessing' !
getBufferSize ^<Int>

    "Use the block size"
    ^self blockSize * 8! !

"June 12, 2007 -> 2:42:57"!

"System saved" !
"June 12, 2007 -> 11:26:54"!

! (Delta mirrorFor: #StatBuffer) methodsFor: 'accessing' !
version

	^3! !

"June 12, 2007 -> 11:27:24"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'accessing' !
blockSize ^<Int>
    "Use the sector size"
    | statBuffer <StatBuffer> 
    	status <ExternalProxy> |
    statBuffer := StatBuffer new allocate.
    [ status := {{<libc ExternalProxy __fxstat>
    					version: statBuffer version
            			name: self handle
            			buffer: statBuffer    }}.
	^status asSmallInteger == -1
		ifTrue: [4096]
		ifFalse: [ statBuffer blockSize ]]
		ensure: [ statBuffer free]! !

"June 12, 2007 -> 11:28:12"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'accessing' !
blockSize ^<Int>
    "Use the sector size"
    | statBuffer <StatBuffer> 
    	status <ExternalProxy> |
    statBuffer := StatBuffer new.
    statBuffer allocate.
    [ status := {{<libc ExternalProxy __fxstat>
    					version: statBuffer version
            			name: self handle
            			buffer: statBuffer    }}.
	^status asSmallInteger == -1
		ifTrue: [4096]
		ifFalse: [ statBuffer blockSize ]]
		ensure: [ statBuffer free]! !

"June 12, 2007 -> 11:29:46"!

"System saved" !
"June 12, 2007 -> 18:29:46"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
setExternalPosition: p <Int>
    "%todo: support large integer positions for extremely large files"
    {{<libc ExternalProxy libc>
        fd: self handle
        offset: p
        whence: self SEEK_SET }}    "FILE_BEGIN"! !

"June 12, 2007 -> 18:33:18"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
SEEK_SET

	^0! !

"June 12, 2007 -> 18:52:44"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'i/o' !
readAt: pos <Int> ifFail: errf <[ExternalError]> ^<Int>
    | result <ExternalProxy> count <Int> |
    self position = pos
        ifFalse: [ self position: pos ].
    self knowAtEnd
        ifTrue: [        count := 0 ]
        ifFalse: [
                    count := {{<libc ExternalProxy read>
                        fd: self handle
                        buffer: self buffer
                        count: self bufferSize    }}.
                    count := self ioCount smallIntegerAt: 0.    ].
    self setPosition: self position + count.
    ^count! !

"June 12, 2007 -> 19:29:4"!

! (Delta mirrorFor: #StatBuffer) methodsFor: 'offsets' !
fileSizeOffset

	^44! !

"June 12, 2007 -> 19:29:18"!

! (Delta mirrorFor: #StatBuffer) methodsFor: 'accessing' !
fileSize
! !

"June 12, 2007 -> 19:29:40"!

! (Delta mirrorFor: #StatBuffer) methodsFor: 'accessing' !
fileSize

	^self smallIntegerAt: self fileSizeOffset! !

"June 12, 2007 -> 19:33:36"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'accessing' !
size ^<Int>
    "Use the sector size"
    | statBuffer <StatBuffer> 
    	status <ExternalProxy> |
    statBuffer := StatBuffer new.
    statBuffer allocate.
    [ status := {{<libc ExternalProxy __fxstat>
    					version: statBuffer version
            			name: self handle
            			buffer: statBuffer    }}.
	^status asSmallInteger == -1
		ifTrue: [0]
		ifFalse: [ statBuffer fileSize ]]
		ensure: [ statBuffer free]! !

"June 12, 2007 -> 19:43:26"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'i/o' !
readAt: pos <Int> ifFail: errf <[ExternalError]> ^<Int>
    | result <ExternalProxy> count <Int> |
    self position = pos
        ifFalse: [ self position: pos ].
    self knowAtEnd
        ifTrue: [ count := 0 ]
        ifFalse: [ count := {{<libc ExternalProxy read>
                        fd: self handle
                        buffer: self buffer
                        count: self bufferSize    }} ].
    self setPosition: self position + count.
    ^count! !

"June 12, 2007 -> 19:47:14"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'i/o' !
write: nBytes <Int> at: pos <Int> ifFail: errf <[ExternalError]>
    | result <ExternalProxy> count <Int> |
    self position = pos
        ifFalse: [ self position: pos ].
    count := {{<libc ExternalProxy write>
                        fd: self handle
                        buffer: self buffer
                        count: nBytes    }}.
    self setPosition: self position + count! !

"June 12, 2007 -> 19:53:7"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'control' !
severExternalConnections
    | result <ExternalProxy> |
    
    super severExternalConnections.
    self ioCount free.
    result := {{<libc ExternalProxy close>
        handle: self handle }}.
    result asSmallInteger == -1
        ifTrue: [ self error: 'Error closing file handle' ].! !

"June 12, 2007 -> 20:19:23"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'control' !
createDirectoryIfFail: fail <[Symbol]>

    | name <CString> |
    name := CString for: self name.

    [{{<libc ExternalProxy mkdir>
            name: name
            mode: 0
        }} asSmallInteger == -1
            ifFalse: [  fail value: #CannotCreateFile ]
    ] ensure: [ name free ]! !

"June 12, 2007 -> 20:22:33"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
deleteDirectoryIfFail: blk <[Symbol]>

    | name <CString> |
    name := CString for: self name.
    [ {{<libc ExternalProxy rmdir>
             name: name
        }} asSmallInteger == -1
            ifFalse: [ blk value: #ErrorDeletingDirectory ]
    ] ensure: [ name free ]! !

"June 12, 2007 -> 20:31:1"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
deleteFileIfFail: blk <[Symbol]>

    | name <CString> |
    name := CString for: self name.
    [   {{<libc ExternalProxy unlink>
                name: name
        }} asSmallInteger == -1
            ifFalse: [ blk value: #ErrorDeletingFile ]
    ] ensure: [ name free ]! !

"June 12, 2007 -> 20:33:38"!

"System saved" !
"June 12, 2007 -> 20:47:28"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
setExternalPosition: p <Int>
    "%todo: support large integer positions for extremely large files"
    {{<libc ExternalProxy lseek>
        fd: self handle
        offset: p
        whence: self SEEK_SET }}    "FILE_BEGIN"! !

"June 12, 2007 -> 20:49:30"!

"System saved" !
"June 12, 2007 -> 21:54:15"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'i/o' !
readAt: pos <Int> ifFail: errf <[ExternalError]> ^<Int>
    | result <ExternalProxy> count <Int> |
    self position = pos
        ifFalse: [ self position: pos ].
    self knowAtEnd
        ifTrue: [ count := 0 ]
        ifFalse: [ count := {{<libc ExternalProxy read>
        				                fd: self handle
                        				buffer: self buffer
                        				count: self bufferSize }} asSmallInteger ].
    self setPosition: self position + count.
    ^count! !

"June 12, 2007 -> 21:55:36"!

"System saved" !
"June 13, 2007 -> 0:13:15"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
O_RDONLY

	^0! !

"June 13, 2007 -> 0:13:32"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
O_WRONLY

	^1! !

"June 13, 2007 -> 0:13:49"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
O_RDWR

	^2! !

"June 13, 2007 -> 0:16:45"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
O_CREAT

	^64! !

"June 13, 2007 -> 0:18:33"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
modeFor: mode <Symbol> ^<SmallInt>

    mode = #read
        ifTrue: [ ^self O_RDONLY ].
    mode = #write
        ifTrue: [ ^self O_WRONLY bitOr: self O_CREAT ].
    mode = #readWrite
        ifTrue: [ ^self O_RDWR bitOr: self O_CREAT ]
    self error: 'Unrecognised mode: ' , mode! !

"June 13, 2007 -> 0:21:27"!

"System saved" !
"June 13, 2007 -> 0:37:58"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'i/o' !
write: nBytes <Int> at: pos <Int> ifFail: errf <[ExternalError]>
    | result <ExternalProxy> count <Int> |
    self position = pos
        ifFalse: [ self position: pos ].
    count := {{<libc ExternalProxy write>
                        fd: self handle
                        buffer: self buffer
                        count: nBytes    }} asSmallInteger.
    self setPosition: self position + count! !

"June 13, 2007 -> 0:39:18"!

"System saved" !
"June 13, 2007 -> 0:49:47"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
modeFor: mode <Symbol> ^<SmallInt>

    mode = #read
        ifTrue: [ ^self O_RDONLY ].
    mode = #write
        ifTrue: [ ^self O_WRONLY bitOr: self O_CREAT ].
    mode = #readWrite
        ifTrue: [ ^self O_RDWR bitOr: self O_CREAT ].
    self error: 'Unrecognised mode: ' , mode! !

"June 13, 2007 -> 0:51:7"!

"System saved" !
"June 13, 2007 -> 16:56:15"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'restricted' !
openInternalFor: mode <Symbol> ifFail: err <[ExternalError, ^X def]>  ^<ExternalProxy | X>

    |   dname <ExternalProxy>
        dmode <SmallInt>
        proxy <ExternalProxy> |
    dname := self nameProxy.

    [ dmode := self modeFor: mode.
    	proxy := {{<libc ExternalProxy open>
    					name: dname
    					flags: dmode
    					create: 8r777 }} ]
    		ensure: [ dname free ].

    ^proxy isAllOnes
        ifFalse: [ proxy ]
        ifTrue: [ err value: #cannotOpenFile ]! !

"June 13, 2007 -> 16:58:7"!

"System saved" !
"June 13, 2007 -> 17:9:33"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
O_CREAT

	^8r100! !

"June 13, 2007 -> 17:9:53"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
O_TRUNC

	^8r1000! !

"June 13, 2007 -> 17:10:28"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
modeFor: mode <Symbol> ^<SmallInt>

    mode = #read
        ifTrue: [ ^self O_RDONLY ].
    mode = #write
        ifTrue: [ ^(self O_WRONLY bitOr: self O_CREAT) bitOr: self O_TRUNC ].
    mode = #readWrite
        ifTrue: [ ^self O_RDWR bitOr: self O_CREAT ].
    self error: 'Unrecognised mode: ' , mode! !

"June 13, 2007 -> 17:11:49"!

"System saved" !
"June 13, 2007 -> 18:37:47"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'control' !
createDirectoryIfFail: fail <[Symbol]>

    | name <CString> |
    name := CString for: self name.

    [{{<libc ExternalProxy mkdir>
            name: name
            mode: 0
        }} asSmallInteger == -1
            ifTrue: [  fail value: #CannotCreateFile ]
    ] ensure: [ name free ]! !

"June 13, 2007 -> 18:39:4"!

"System saved" !
"June 13, 2007 -> 20:2:58"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'control' !
createDirectoryIfFail: fail <[Symbol]>

    | name <CString> |
    name := CString for: self name.

    [{{<libc ExternalProxy mkdir>
            name: name
            mode: 8r777
        }} asSmallInteger == -1
            ifTrue: [  fail value: #CannotCreateFile ]
    ] ensure: [ name free ]! !

"June 13, 2007 -> 20:4:21"!

"System saved" !
"June 13, 2007 -> 20:49:28"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
fstat: statBlock ifFail: failBlock

    | statBuffer <StatBuffer> 
    	status <ExternalProxy> |
    statBuffer := StatBuffer new.
    statBuffer allocate.
    [ status := {{<libc ExternalProxy __fxstat>
    					version: statBuffer version
            			name: self handle
            			buffer: statBuffer    }}.
	status asSmallInteger == -1
		ifTrue: [ failBlock value ]
		ifFalse: [ statBlock value: statBuffer ]]
		ensure: [ statBuffer free]! !

"June 13, 2007 -> 20:54:50"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
stat: testBlock ifFail: failBlock

    | statBuffer <StatBuffer> 
    	status <ExternalProxy>
    	name <CString> |
    statBuffer := StatBuffer new.
    statBuffer allocate.
    name := CString for: self name.
    [ status := {{<libc ExternalProxy __xstat>
    					version: statBuffer version
            			name: name
            			buffer: statBuffer    }}.
	status asSmallInteger == -1
		ifTrue: [ failBlock value ]
		ifFalse: [ ^testBlock value: statBuffer ]]
		ensure: [ statBuffer free]! !

"June 13, 2007 -> 20:55:0"!

(Delta mirrorFor: #UnixFilePath) removeMethod: #fstat:ifFail: ifAbsent: [] !


"June 13, 2007 -> 20:56:9"!

! (Delta mirrorFor: #StatBuffer) methodsFor: 'accessing' !
mode

	^self smallIntegerAt: self modeOffset! !

"June 13, 2007 -> 20:56:32"!

! (Delta mirrorFor: #StatBuffer) methodsFor: 'offsets' !
modeOffset

	^8! !

"June 13, 2007 -> 20:57:48"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
isDirectory ^<Boolean>

    ^self stat: [:stat| (stat bitAnd: self S_IFDIR) == self S_IFDIR]
    	ifFail: [ self error: 'could not stat file' ]! !

"June 13, 2007 -> 21:39:33"!

! (Delta mirrorFor: #StatBuffer) methodsFor: 'offsets' !
modeOffset

	^16! !

"June 13, 2007 -> 21:39:50"!

! (Delta mirrorFor: #StatBuffer) methodsFor: 'offsets' !
uidOffset

	^24! !

"June 13, 2007 -> 21:40:1"!

! (Delta mirrorFor: #StatBuffer) methodsFor: 'offsets' !
gidOffset

	^28! !

"June 13, 2007 -> 21:45:56"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
S_IFDIR

	^8r40000! !

"June 13, 2007 -> 21:58:0"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
S_IRUSR

	^8r4000! !

"June 13, 2007 -> 21:58:20"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
S_IWUSR

	^8r2000! !

"June 13, 2007 -> 21:58:34"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
S_IXUSR

	^8r1000! !

"June 13, 2007 -> 21:59:36"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
S_IXGRP

	^8r100! !

"June 13, 2007 -> 21:59:54"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
S_IWGRP

	^8r200! !

"June 13, 2007 -> 22:0:2"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
S_IRGRP

	^8r400! !

"June 13, 2007 -> 22:0:25"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
S_IROTH

	^8r40! !

"June 13, 2007 -> 22:0:34"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
S_IWOTH

	^8r20! !

"June 13, 2007 -> 22:0:43"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
S_IXOTH

	^8r10! !

"June 13, 2007 -> 22:6:56"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
geteuid

	^{{<libc ExternalProxy geteuid> call}} asSmallInteger! !

"June 13, 2007 -> 22:7:11"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
getguid

	^{{<libc ExternalProxy getguid> call}} asSmallInteger! !

"June 13, 2007 -> 22:7:48"!

! (Delta mirrorFor: #StatBuffer) methodsFor: 'accessing' !
uid

	^self smallIntegerAt: self uidOffset! !

"June 13, 2007 -> 22:8:3"!

! (Delta mirrorFor: #StatBuffer) methodsFor: 'accessing' !
gid

	^self smallIntegerAt: self gidOffset! !

"June 13, 2007 -> 22:15:58"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
isReadOnly ^<Boolean>

    ^self stat: [:stat| 
    				(stat uid == self geteuid and: [(stat mode bitAnd: self S_IWUSR) == 0])
    					or: [(stat gid == self getegid and: [(stat mode bitAnd: self S_IWGRP) == 0])
    					or: [(stat mode bitAnd: self S_IWOTH) == 0]]]
    	ifFail: [ self error: 'could not stat file' ]! !

"June 13, 2007 -> 22:28:23"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
stat: testBlock ifFail: failBlock

    | statBuffer <StatBuffer> 
    	status <ExternalProxy>
    	name <CString> |
    statBuffer := StatBuffer new.
    statBuffer allocate.
    name := CString for: self name.
    [ status := {{<libc ExternalProxy __xstat>
    					version: statBuffer version
            			name: name
            			buffer: statBuffer    }}.
	status asSmallInteger == -1
		ifTrue: [ failBlock value ]
		ifFalse: [ ^testBlock value: statBuffer ]]
		ensure: [ statBuffer free.
						name free]! !

"June 13, 2007 -> 22:31:18"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
exists ^<Boolean>
	| name result |
	name := self nameProxy.
    [ result := {{<libc ExternalProxy open>
   	 					name: name
    					flags: 0}}.
     	^result asSmallInteger >= 0]
     	ensure: [ name free.
     				{{<libc ExternalProxy close>
   	 					fd: result}} ]! !

"June 13, 2007 -> 22:31:23"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
isDirectory ^<Boolean>

    ^self stat: [:stat| (stat mode bitAnd: self S_IFDIR) == self S_IFDIR]
    	ifFail: [ self error: 'could not stat file' ]! !

"June 13, 2007 -> 22:39:36"!

"System saved" !
"June 13, 2007 -> 22:55:42"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'private' !
patternExtending: pat <FilePattern> ^<Str>

    ^pat pattern last = $/
        ifTrue: [ pat pattern, self pattern ]
        ifFalse: [ pat pattern,'/', self pattern ]! !

"June 13, 2007 -> 22:57:18"!

"System saved" !
"June 13, 2007 -> 23:5:33"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
verify: message
	"Evaluate the receiver, and generate an error if it does not return true.  This is different than
	  Object>>#assert: in that 1) it is a boolean block message, and 2) it ALWAYS evaluates, whereas
	  #assert: does not guarantee that it will evaluate the predicate.

	  Use verify in situations where you must ensure that the test is performed, for example when there
	  are side-effects that must take place, or if it is testing code that should always be performed.

	  Note that this message is only valid for blocks that return boolean values."

	"Note: we don't use self as the receiver for #error: below because it will currently
		prevent the block from being optimized away by the inliner"
	self value
		ifFalse: [ BlockWithoutArguments[Object] error: 'Assertion failed: ', message ].

	"%hack %todo: remove this when compiler bug fixed"
	^nil! !

"June 13, 2007 -> 23:8:45"!

! (Delta mirrorFor: #FilePath) classSide methodsFor: 'testing' !
test

	| f <FilePath> f2 <FilePath> |

	f := FilePath for: 'tmpDir'.
	[ f exists not ] verify.

	f createDirectoryIfFail: [ :err <Symbol> | Win32 handleError ].
	[ f exists ] verify: 'tmpDir exists'.
	[ f isDirectory ] verify: 'tmpDir isDirectory'.
	[ f isWriteable ] verify: 'tmpDir isWriteable'.

	f2 := f , (FilePath for: 'sub').
	[ f2 exists not ] verify: 'tmpDir/sub exists not'.

	f2 createDirectoryIfFail: [ :err <Symbol> | Win32 handleError ].
	[ f2 exists ] verify: 'tmpDir/sub exists'.
	[ f isDirectory ] verify: 'tmpDir/sub isDirectory'.
	[ f isWriteable ] verify: 'tmpDir/sub isWriteable'.

	[ (self tryToDeleteTestDir: f) not ] verify: 'delete tmpDir should fail'.
	[ self tryToDeleteTestDir: f2 ] verify: 'delete tmpDir/sub'.
	[ self tryToDeleteTestDir: f ] verify: 'delete tmpDir'.

	[ f2 exists not ] verify: 'tmpDir/sub should not exist'.
	[ f exists not ] verify: 'tmpDir should not exist'.
! !

"June 13, 2007 -> 23:10:6"!

"System saved" !
"June 14, 2007 -> 0:9:58"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
getegid

	^{{<libc ExternalProxy getegid> call}} asSmallInteger! !

"June 14, 2007 -> 0:10:13"!

(Delta mirrorFor: #UnixFilePath) removeMethod: #getguid ifAbsent: [] !


"June 14, 2007 -> 0:42:20"!

"System saved" !
"June 14, 2007 -> 20:20:37"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
isReadOnly ^<Boolean>

    ^self isWriteable not! !

"June 14, 2007 -> 20:20:40"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
isWriteable

    ^self stat: [:stat| 
    				(stat uid == self geteuid and: [(stat mode bitAnd: self S_IWUSR) == self S_IWUSR])
    					or: [(stat gid == self getegid and: [(stat mode bitAnd: self S_IWGRP) == self S_IWGRP])
    					or: [(stat mode bitAnd: self S_IWOTH) == self S_IWOTH]]]
    	ifFail: [ self error: 'could not stat file' ]! !

"June 14, 2007 -> 20:22:57"!

"System saved" !
"June 15, 2007 -> 17:41:22"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
deleteDirectoryIfFail: blk <[Symbol]>

    | name <CString> |
    name := CString for: self name.
    [ {{<libc ExternalProxy rmdir>
             name: name
        }} asSmallInteger == -1
            ifTrue: [ blk value: #ErrorDeletingDirectory ]
    ] ensure: [ name free ]! !

"June 15, 2007 -> 17:41:29"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
deleteFileIfFail: blk <[Symbol]>

    | name <CString> |
    name := CString for: self name.
    [   {{<libc ExternalProxy unlink>
                name: name
        }} asSmallInteger == -1
            ifTrue: [ blk value: #ErrorDeletingFile ]
    ] ensure: [ name free ]! !

"June 15, 2007 -> 17:43:12"!

"System saved" !
"June 17, 2007 -> 12:21:49"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLMapName: name <Str> ^<Str>
    name = 'libc' ifTrue: [^'libc.so.6']
    self error: 'Unrecognised shared library'! !

"June 18, 2007 -> 10:26:43"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'library testing' !
deterministicallyTestSystem
	"As many tests as we can do deterministically (i.e. without requiring UI interaction, for now)."

	self testLibrary.
	Smalltalk recompileAllMethods.
	Transcript show: 'Testing completed.'; cr.! !

"June 18, 2007 -> 10:27:57"!

"System saved" !
"June 18, 2007 -> 18:51:20"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLMapName: name <Str> ^<Str>
    name = 'libc' ifTrue: [^'libc.so.6'].
    self error: 'Mapping ', name, ' not found'! !

"June 18, 2007 -> 18:53:50"!

"System saved" !
"June 18, 2007 -> 19:20:57"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'environment' !
environmentVariableAt: key <Str> ifAbsent: blk <[^X def]> ^ <Str | X>

    | cKey <CString> cValue <CString> |
    cKey := CString for: key.
    [cValue := {{<libc CString getenv> key: cKey}}.
    ^cValue isNull
    	ifTrue: [blk value]
    	ifFalse: [cValue asString]]
    	ensure: [cKey free]! !

"June 18, 2007 -> 19:21:41"!

"System saved" !
"June 18, 2007 -> 21:1:8"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'library testing' !
deterministicallyTestSystem
	"As many tests as we can do deterministically (i.e. without requiring UI interaction, for now)."

	self testLibrary.
	"Smalltalk recompileAllMethods."
	Transcript show: 'Testing completed.'; cr.! !

"June 18, 2007 -> 21:1:37"!

"System saved" !
"December 2, 2007 -> 19:16:6"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'copying-moving' !
copyAs: newPath <FilePath> ifFail: fail <[ExternalError]>

    | source target	|
	source := self readStream.
	target := newPath writeStream.
	[[source atEnd]	 whileFalse: [
		target nextPut: source next]]
			ensure: [source close.
							target close]! !

"December 2, 2007 -> 19:41:10"!

"System saved" !
"December 3, 2007 -> 0:25:40"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'iterating' !
elementsDo: blk <[FilePattern]>

    | s <CharacterReadStream> |

    s := self pattern readStream.
    [ s atEnd ]
        whileFalse:
            [   | next <Str> |
                next := s upTo: $/.
                (next includes: $:)
                    ifTrue: [ next := next,'/' ].
                blk value: (FilePattern for: next)  ].! !

"December 3, 2007 -> 0:28:2"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t <SYSTEMTIME> |
	t := SYSTEMTIME new allocate.
	{{<kernel ExternalProxy GetLocalTime> struct: t}}.
	^t! !

"December 3, 2007 -> 0:28:34"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t <SYSTEMTIME> |
	t := SYSTEMTIME new allocate.
	{{<kernel ExternalProxy GetLocalTime> struct: t}}.
	^t
! !

"December 3, 2007 -> 0:29:15"!

! (Delta mirrorFor: #Time) classSide methodsFor: 'restricted-win32' !
localSYSTEMTIME ^<SYSTEMTIME>

	^Platform localSYSTEMTIME
! !

"December 3, 2007 -> 0:53:24"!

Delta define: #TimeT as: (
(Class subclassOf: 'CStructure' instanceVariables: '')) !


"December 3, 2007 -> 0:53:52"!

! (Delta mirrorFor: #TimeT) methodsFor: 'accessing' !
structureSize

	^4! !

"December 3, 2007 -> 1:11:44"!

Delta define: #TM as: (
(Class subclassOf: 'CStructure' instanceVariables: '')) !


"December 3, 2007 -> 1:32:8"!

"System saved" !
"December 3, 2007 -> 1:34:28"!

! (Delta mirrorFor: #TM) methodsFor: 'accessing' !
structureSize

	^32! !

"December 3, 2007 -> 1:37:36"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t tm st |
	t := TimeT new allocate.
	tm := TM new allocate.
	st := SYSTEMTIME new allocate.
	{{<libc ExternalProxy time> struct: t}}.
	{{<libc ExternalProxy time> struct: t}}.
	^t
! !

"December 3, 2007 -> 1:50:4"!

! (Delta mirrorFor: #TM) methodsFor: 'offsets' !
mSecondOffset

	^0! !

"December 3, 2007 -> 1:50:37"!

! (Delta mirrorFor: #TM) methodsFor: 'offsets' !
mMinuteOffset

	^2! !

"December 3, 2007 -> 1:51:3"!

! (Delta mirrorFor: #TM) methodsFor: 'offsets' !
mHourOffset

	^4! !

"December 3, 2007 -> 1:51:35"!

! (Delta mirrorFor: #TM) methodsFor: 'offsets' !
mDayOffset

	^6! !

"December 3, 2007 -> 1:51:57"!

! (Delta mirrorFor: #TM) methodsFor: 'offsets' !
mMonthOffset

	^8! !

"December 3, 2007 -> 1:52:13"!

! (Delta mirrorFor: #TM) methodsFor: 'offsets' !
mYearOffset

	^10! !

"December 3, 2007 -> 1:54:6"!

! (Delta mirrorFor: #TM) methodsFor: 'converting' !
asSYSTEMTIME

	| st |
	st := SYSTEMTIME new allocate.
	st doubleByteAt: st wSecondOffset put: self mSecond.
	st doubleByteAt: st wMinuteOffset put: self mMinute.
	st doubleByteAt: st wHourOffset put: self mHour.
	st doubleByteAt: st wDayOffset put: self mDay.
	st doubleByteAt: st wMonthOffset put: self mMonth.
	st doubleByteAt: st wYearOffset put: self mYear.
	^st! !

"December 3, 2007 -> 1:55:4"!

! (Delta mirrorFor: #TM) methodsFor: 'accessing' !
mDay

	^self doubleByteAt: self mDayOffset! !

"December 3, 2007 -> 1:55:22"!

! (Delta mirrorFor: #TM) methodsFor: 'accessing' !
mSecond

	^self doubleByteAt: self mSecondOffset! !

"December 3, 2007 -> 1:55:33"!

! (Delta mirrorFor: #TM) methodsFor: 'accessing' !
mMinute

	^self doubleByteAt: self mMinuteOffset! !

"December 3, 2007 -> 1:55:46"!

! (Delta mirrorFor: #TM) methodsFor: 'accessing' !
mHour

	^self doubleByteAt: self mHourOffset! !

"December 3, 2007 -> 1:56:2"!

! (Delta mirrorFor: #TM) methodsFor: 'accessing' !
mMonth

	^self doubleByteAt: self mMonthOffset! !

"December 3, 2007 -> 1:56:11"!

! (Delta mirrorFor: #TM) methodsFor: 'accessing' !
mYear

	^self doubleByteAt: self mYearOffset! !

"December 3, 2007 -> 1:57:43"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t tm st |
	t := TimeT new allocate.
	tm := TM new allocate.
	[{{<libc ExternalProxy time> struct: t}}.
	{{<libc ExternalProxy gmtime>
		struct: t
		result: tm}}.
	^tm asSYSTEMTIME] ensure: [t free. tm free]
! !

"December 3, 2007 -> 1:58:47"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t tm |
	t := TimeT new allocate.
	tm := TM new allocate.
	[{{<libc ExternalProxy time> struct: t}}.
	{{<libc ExternalProxy gmtime>
		struct: t
		result: tm}}.
	^tm asSYSTEMTIME] ensure: [t free. tm free]
! !

"December 3, 2007 -> 2:5:10"!

"System saved" !
"December 3, 2007 -> 2:43:59"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t tm |
	t := TimeT new allocate.
	tm := TM new allocate.
	[{{<libc ExternalProxy time> struct: t}} asInteger == -1
		ifTrue: [self error: 'Invalid time'].
	{{<libc ExternalProxy gmtime>
		struct: t
		result: tm}}.
	^tm asSYSTEMTIME] ensure: [t free. tm free]
! !

"December 3, 2007 -> 2:45:44"!

"System saved" !
"December 3, 2007 -> 2:50:59"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t tm |
	t := TimeT new allocate.
	tm := TM new allocate.
	[{{<libc ExternalProxy time> struct: t}} isAllOnes
		ifTrue: [self error: 'Invalid time'].
	{{<libc ExternalProxy gmtime>
		struct: t
		result: tm}}.
	^tm asSYSTEMTIME] ensure: [t free. tm free]
! !

"December 3, 2007 -> 2:53:25"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t tm |
	t := TimeT new allocate.
	[{{<libc ExternalProxy time> struct: t}} isAllOnes
		ifTrue: [self error: 'Invalid time'].
	tm := {{<libc ExternalProxy gmtime>
					struct: t}}.
	^tm asSYSTEMTIME] ensure: [t free. tm free]
! !

"December 3, 2007 -> 2:53:57"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t tm |
	t := TimeT new allocate.
	[{{<libc ExternalProxy time> struct: t}} isAllOnes
		ifTrue: [self error: 'Invalid time'].
	tm := {{<libc TM gmtime>
					struct: t}}.
	^tm asSYSTEMTIME] ensure: [t free. tm free]
! !

"December 3, 2007 -> 2:54:29"!

"System saved" !
"December 3, 2007 -> 3:3:30"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t tm |
	t := TimeT new allocate.
	Transcript show: 'stage1'.
	[{{<libc ExternalProxy time> struct: t}} isAllOnes
		ifTrue: [self error: 'Invalid time'].
	Transcript show: 'stage2'.
	tm := {{<libc TM gmtime>
					struct: t}}.
	Transcript show: 'stage3'.
	^tm asSYSTEMTIME] ensure: [t free. tm free]
! !

"December 3, 2007 -> 3:3:50"!

"System saved" !
"December 3, 2007 -> 3:5:34"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t tm |
	t := TimeT new allocate.
	Transcript show: 'stage1'.
	[{{<libc ExternalProxy time> struct: t}} isAllOnes
		ifTrue: [self error: 'Invalid time'].
	Transcript show: 'stage2'.
	tm := {{<libc TM gmtime>
					struct: t}}.
	Transcript show: 'stage3'.
	^tm asSYSTEMTIME] ensure: [t free]
! !

"December 3, 2007 -> 3:6:5"!

"System saved" !
"December 3, 2007 -> 3:8:54"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t tm |
	t := TimeT new allocate.
	[{{<libc ExternalProxy time> struct: t}} isAllOnes
		ifTrue: [self error: 'Invalid time'].
	tm := {{<libc TM gmtime>
					struct: t}}.
	Transcript show: tm mDay printString.
	^tm asSYSTEMTIME] ensure: [t free]
! !

"December 3, 2007 -> 3:11:51"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t tm |
	t := TimeT new allocate.
	[{{<libc ExternalProxy time> struct: t}} isAllOnes
		ifTrue: [self error: 'Invalid time'].
	tm := {{<libc TM gmtime>
					struct: t}}.
	Transcript
		show: tm mYear printString; space;
		show: tm mMonth printString; space;
		show: tm mDay printString; space;
		show: tm mHour printString; space;
		show: tm mMinute printString; space;
		show: tm mSecond printString.
	^tm asSYSTEMTIME] ensure: [t free]
! !

"December 3, 2007 -> 3:14:11"!

"System saved" !
"December 3, 2007 -> 3:16:47"!

! (Delta mirrorFor: #TM) methodsFor: 'accessing' !
structureSize

	^64! !

"December 3, 2007 -> 3:16:57"!

! (Delta mirrorFor: #TM) methodsFor: 'offsets' !
mDayOffset

	^12! !

"December 3, 2007 -> 3:17:2"!

! (Delta mirrorFor: #TM) methodsFor: 'offsets' !
mHourOffset

	^8! !

"December 3, 2007 -> 3:17:7"!

! (Delta mirrorFor: #TM) methodsFor: 'offsets' !
mMinuteOffset

	^4! !

"December 3, 2007 -> 3:17:17"!

! (Delta mirrorFor: #TM) methodsFor: 'offsets' !
mMonthOffset

	^16! !

"December 3, 2007 -> 3:17:33"!

! (Delta mirrorFor: #TM) methodsFor: 'offsets' !
mYearOffset

	^20! !

"December 3, 2007 -> 3:18:8"!

"System saved" !
"December 3, 2007 -> 3:20:15"!

! (Delta mirrorFor: #TM) methodsFor: 'converting' !
asSYSTEMTIME

	| st |
	st := SYSTEMTIME new allocate.
	st doubleByteAt: st wSecondOffset put: self mSecond.
	st doubleByteAt: st wMinuteOffset put: self mMinute.
	st doubleByteAt: st wHourOffset put: self mHour.
	st doubleByteAt: st wDayOffset put: self mDay.
	st doubleByteAt: st wMonthOffset put: self mMonth.
	st doubleByteAt: st wYearOffset put: self mYear + 1900.
	^st! !

"December 3, 2007 -> 3:20:42"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t tm |
	t := TimeT new allocate.
	[{{<libc ExternalProxy time> struct: t}} isAllOnes
		ifTrue: [self error: 'Invalid time'].
	tm := {{<libc TM gmtime>
					struct: t}}.
	^tm asSYSTEMTIME] ensure: [t free]
! !

"December 3, 2007 -> 3:21:2"!

"System saved" !
"December 3, 2007 -> 3:27:49"!

! (Delta mirrorFor: #TM) methodsFor: 'converting' !
asSYSTEMTIME

	| st |
	st := SYSTEMTIME new allocate.
	st doubleByteAt: st wSecondOffset put: self mSecond.
	st doubleByteAt: st wMinuteOffset put: self mMinute.
	st doubleByteAt: st wHourOffset put: self mHour.
	st doubleByteAt: st wDayOffset put: self mDay.
	st doubleByteAt: st wMonthOffset put: self mMonth + 1.
	st doubleByteAt: st wYearOffset put: self mYear + 1900.
	^st! !

"December 3, 2007 -> 3:28:8"!

"System saved" !
"December 3, 2007 -> 23:52:19"!

Delta define: #TestA as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"December 3, 2007 -> 23:52:37"!

Delta define: #TestA as: (
(Class subclassOf: 'Object' instanceVariables: 'one two')) !


"December 3, 2007 -> 23:53:23"!

! (Delta mirrorFor: #TestA) classSide methodsFor: 'instance creation' !
one: one two: two

	^self new
		one: one
		two: two! !

"December 3, 2007 -> 23:54:26"!

! (Delta mirrorFor: #TestA) methodsFor: 'initialization' !
one: value1 two: value2

	one := value1.
	two := value2! !

"December 3, 2007 -> 23:59:24"!

Delta define: #TestA as: (
(Class subclassOf: 'Object' instanceVariables: 'one two three')) !


"December 4, 2007 -> 0:2:49"!

(Delta mirrorFor: #TestA) removeDefinitionIfFail: [] !


"December 4, 2007 -> 2:42:29"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'private' !
terminalPathsDo: blk <[FilePath]>

    | glob |
    glob := nil! !

"December 4, 2007 -> 2:43:25"!

Delta define: #GlobT as: (
(Class subclassOf: 'CStructure' instanceVariables: '')) !


"December 4, 2007 -> 2:44:4"!

! (Delta mirrorFor: #GlobT) methodsFor: 'accessing' !
structureSize

	^36! !

"December 4, 2007 -> 2:47:20"!

! (Delta mirrorFor: #GlobT) methodsFor: 'offsets' !
glPathc

	^0! !

"December 4, 2007 -> 2:47:47"!

! (Delta mirrorFor: #GlobT) methodsFor: 'offsets' !
glPathv

	^4! !

"December 4, 2007 -> 2:48:1"!

! (Delta mirrorFor: #GlobT) methodsFor: 'offsets' !
glPathvOffset

	^4! !

"December 4, 2007 -> 2:48:13"!

! (Delta mirrorFor: #GlobT) methodsFor: 'offsets' !
glPathcOffset

	^0! !

"December 4, 2007 -> 2:54:13"!

! (Delta mirrorFor: #GlobT) methodsFor: 'accessing' !
glPathc

	^self smallIntegerAt: self glPathcOffset! !

"December 4, 2007 -> 2:56:6"!

! (Delta mirrorFor: #GlobT) methodsFor: 'accessing' !
glPathv

	^self subProxyAt: self glPathvOffset! !

"December 4, 2007 -> 3:8:30"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'private' !
terminalPathsDo: blk <[FilePath]>

    | glob pathArray strings |
    glob := GlobT new allocate.
   {{<libc ExternalProxy glob>
    	pattern: self pattern
    	flags: 0
    	ignore: 0
    	glob: glob}}.
    [pathArray := glob glPathv.
    strings := OrderedCollection new.
    1 to: glob glPathc do: [:index| |cstring|
    	cstring := (pathArray cStringAt: (index - 1) * 4).
    	blk value: cstring asString.
    	strings add: cstring]] ensure: [
   			strings do: [:string| string free].
   			pathArray free.
    		glob free]! !

"December 4, 2007 -> 3:10:10"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'private' !
terminalPathsDo: blk <[FilePath]>

    | glob pathArray strings patternString |
   glob := GlobT new allocate.
   patternString := CString for: self pattern.
   {{<libc ExternalProxy glob>
    	pattern: patternString
    	flags: 0
    	ignore: 0
    	glob: glob}}.
    [pathArray := glob glPathv.
    strings := OrderedCollection new.
    1 to: glob glPathc do: [:index| |cstring|
    	cstring := (pathArray cStringAt: (index - 1) * 4).
    	blk value: cstring asString.
    	strings add: cstring]] ensure: [
   			strings do: [:string| string free].
   			pathArray free.
    		glob free.
    		patternString free]! !

"December 4, 2007 -> 3:13:55"!

! (Delta mirrorFor: #GlobT) methodsFor: 'iterating' !
pathsDo: blk

	| pathArray |
	pathArray := self glPathv.
	1 to: self glPathc do: [:index| |cstring|
    	cstring := (pathArray cStringAt: (index - 1) * 4).
    	blk value: cstring asString]! !

"December 4, 2007 -> 3:15:39"!

! (Delta mirrorFor: #GlobT) methodsFor: 'allocating' !
free
	
	| pathArray |
	pathArray := self glPathv.
	1 to: self glPathc do: [:index| |cstring|
    	(pathArray cStringAt: (index - 1) * 4) free].
    pathArray free.
    super free! !

"December 4, 2007 -> 3:16:55"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'private' !
terminalPathsDo: blk <[FilePath]>

    | glob pathArray strings patternString |
   glob := GlobT new allocate.
   patternString := CString for: self pattern.
   {{<libc ExternalProxy glob>
    	pattern: patternString
    	flags: 0
    	ignore: 0
    	glob: glob}}.
	[glob pathsDo: blk]
		ensure: [glob free]! !

"December 4, 2007 -> 3:17:18"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'private' !
terminalPathsDo: blk <[FilePath]>

    | glob pathArray strings patternString |
   glob := GlobT new allocate.
   patternString := CString for: self pattern.
   {{<libc ExternalProxy glob>
    	pattern: patternString
    	flags: 0
    	ignore: 0
    	glob: glob}}.
	[glob pathsDo: blk]
		ensure: [
			glob free.
			patternString free.]! !

"December 4, 2007 -> 3:19:36"!

"System saved" !
"December 4, 2007 -> 3:30:24"!

! (Delta mirrorFor: #GlobT) methodsFor: 'accessing' !
glPathv

	^self proxyAt: self glPathvOffset! !

"December 4, 2007 -> 3:36:17"!

! (Delta mirrorFor: #GlobT) methodsFor: 'iterating' !
pathsDo: blk

	| pathArray |
	pathArray := self glPathv.
	1 to: self glPathc do: [:index| |cstring|
    	cstring := (pathArray
    		proxyAt: (index - 1) * 4
    		result: CString new).
    	blk value: cstring asString]! !

"December 4, 2007 -> 3:37:26"!

"System saved" !
"December 4, 2007 -> 3:43:41"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'private' !
terminalPathsDo: blk <[FilePath]>

    | glob pathArray strings patternString |
   glob := GlobT new allocate.
   patternString := CString for: self pattern.
   {{<libc ExternalProxy glob>
    	pattern: patternString
    	flags: 0
    	ignore: 0
    	glob: glob}}.
	[glob pathsDo: [:pathString| blk value: (FilePath for: pathString)]]
		ensure: [
			glob free.
			patternString free.]! !

"December 4, 2007 -> 3:44:19"!

(Delta mirrorFor: #GlobT) removeMethod: #free ifAbsent: [] !


"December 4, 2007 -> 3:44:52"!

"System saved" !
"December 4, 2007 -> 23:44:58"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'testing' !
isAbsolute ^<Boolean>

    ^self pattern first == $/! !

"December 4, 2007 -> 23:52:13"!

(Delta mirrorFor: #UnixFilePath) removeMethod: #win32FileAttributesIfFail: ifAbsent: [] !


"December 4, 2007 -> 23:58:6"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'copying-moving' !
moveAs: newPath <FilePath> ifFail: fail <[ExternalError]>

    | csrc <CString> cdest <CString> |
    csrc := CString for: self name.
    cdest := CString for: newPath name.
    [   {{<libc ExternalProxy rename>
                source: csrc
                dest: cdest
        }} isAllOnes
            ifTrue: [ fail value: 'Error moving file.' asSymbol ]
    ] ensure:
        [   csrc free.
            cdest free  ]! !

"December 4, 2007 -> 23:59:30"!

"System saved" !
"December 5, 2007 -> 0:8:45"!

(Delta mirrorFor: #UnixFileDescriptor) removeMethod: #printLastError ifAbsent: [] !


"December 5, 2007 -> 0:9:29"!

(Delta mirrorFor: #UnixFileDescriptor) removeMethod: #sectorSize ifAbsent: [] !


"December 5, 2007 -> 0:13:28"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'testing' !
usesCrLfConvention ^<Boolean>

    ^false! !

"December 5, 2007 -> 0:15:9"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLMapName: name <Str> ^<Str>
    name = 'libc' ifTrue: [^'libc.so.6'].
    ^name! !

"December 5, 2007 -> 0:37:10"!

"System saved" !
"December 6, 2007 -> 0:31:8"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'iterating' !
elementsDo: blk <[FilePattern]>

    | s <CharacterReadStream> |

    s := self pattern readStream.
    [ s atEnd ]
        whileFalse:
            [   | next <Str> |
                next := s upTo: $/.
                next isEmpty
                    ifFalse: [ blk value: (FilePattern for: next)] ]! !

"December 6, 2007 -> 0:31:10"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'iterating' !
elementsDo: blk <[FilePattern]>

    | s <CharacterReadStream> |

    s := self pattern readStream.
    [ s atEnd ]
        whileFalse:
            [   | next <Str> |
                next := s upTo: $/.
                next isEmpty
                    ifFalse: [ blk value: (FilePattern for: next)] ]! !

"December 6, 2007 -> 0:31:39"!

"System saved" !
"December 6, 2007 -> 0:42:53"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'iterating' !
pathsDo: blk <[FilePath]>

	self terminalPathsDo: blk
    "| els <SeqCltn[FilePattern]> i <Int> |
    els := self elements.
    i := self firstWildElementOf: els
                ifFail: [ ^self shouldNotHappen ].
    i = els size
        ifTrue: [ self terminalPathsDo: blk ]
        ifFalse: [  | rest <FilePattern> |
                        i + 1 = els size
                            ifTrue: [ rest := els last ]
                            ifFalse: [ rest := FilePattern forAll: (els copyFrom: i + 1 to: els size) ].
                        (FilePattern forAll: (els copyFrom: 1 to: i))
                            pathsDo:
                                [ :fp <FilePath> |
                                    fp isDirectory
                                        ifTrue: [ (fp, rest) pathsDo: blk ]     ]
                     ]"! !

"December 6, 2007 -> 0:43:35"!

"System saved" !
"December 6, 2007 -> 1:7:16"!

! (Delta mirrorFor: #BasicReadStream) methodsFor: 'smalltalk filein' !
fileIn

	(CharacterReadConverter on: self) fileIn! !

"December 6, 2007 -> 1:9:23"!

"System saved" !"December 6, 2007 -> 2:16:15"!Delta define: #SimpleTest as: ((Class subclassOf: 'Object' instanceVariables: '')) !"December 6, 2007 -> 2:16:21"!"System saved" !
"December 6, 2007 -> 2:17:32"!

(Delta mirrorFor: #SimpleTest) removeDefinitionIfFail: [] !


"December 6, 2007 -> 2:17:53"!

"System saved" !"December 6, 2007 -> 2:25:14"!Delta define: #SimpleTest as: ((Class subclassOf: 'Object' instanceVariables: '')) !"December 6, 2007 -> 2:25:20"!"System saved" !
"December 7, 2007 -> 0:33:55"!

(Delta mirrorFor: #SimpleTest) removeDefinitionIfFail: [] !


"December 7, 2007 -> 0:39:42"!

"System saved" !
"December 8, 2007 -> 17:50:0"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLMapName: name <Str> ^<Str>
    name = 'libc' ifTrue: [^'libc.so.6'].
    ^name, '.so'! !

"December 8, 2007 -> 17:50:33"!

"System saved" !
"December 8, 2007 -> 22:34:23"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'os specific' !
currentThreadId
	" stub to allow compatibility with Win32 specifics of process "
	self deltaHack.
	^ {{ primitiveCurrentThreadId }}! !

"December 8, 2007 -> 22:34:56"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'os specific' !
currentThreadId
	" stub to allow compatibility with Win32 specifics of process "
	^ {{ primitiveCurrentThreadId }}! !

"December 8, 2007 -> 22:35:5"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'os specific' !
currentThreadId

	^ {{ primitiveCurrentThreadId }}! !

"December 8, 2007 -> 22:35:23"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'os specific' !
currentThreadId

	^ {{ primitiveCurrentThreadId }}! !

"December 8, 2007 -> 22:36:14"!

"System saved" !
"December 8, 2007 -> 22:49:41"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'os specific' !
currentThreadId
	^ 0
	"^ {{ primitiveCurrentThreadId }}"! !

"December 8, 2007 -> 22:50:4"!

"System saved" !
"December 8, 2007 -> 22:57:3"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'os specific' !
currentThreadId
	"^ 0"
	^ {{ primitiveCurrentThreadId }}! !

"December 8, 2007 -> 22:57:33"!

"System saved" !
"December 9, 2007 -> 19:45:6"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLMapName: name <Str> ^<Str>
    name = 'libc' ifTrue: [^'libc.so'].
    ^name, '.so'! !

"December 9, 2007 -> 19:45:26"!

"System saved" !
"December 9, 2007 -> 20:21:22"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLMapName: name <Str> ^<Str>
    name = 'libc' ifTrue: [^'libc.so.6'].
    ^name, '.so'! !

"December 9, 2007 -> 20:23:17"!

"System saved" !
"April 29, 2008 -> 19:10:19"!

! (Delta mirrorFor: #DeltaProtocol) methodsFor: 'Unclassified' !
isRelevantSubstitution: s <Substitution> ^ <Boolean>
" In our system, substitutions are constructed in a structured fashion.
Consequently, either all the keys of a substitution are relevant, or none are.
We choose an arbitrary key, check if it is relevant, and return the result.
"
| res |

s keys do:[: k <Symbol> | 
                     ^self relevantTypeVars includes: k.
                    ].
^false! !

"April 29, 2008 -> 19:10:37"!

"System saved" !
"April 30, 2008 -> 0:16:41"!

! (Delta mirrorFor: #Set) methodsFor: 'adding' !
add: anElement

	anElement isNil ifTrue: [^self].
	super add: anElement! !

"April 30, 2008 -> 0:16:41"!

! (Delta mirrorFor: #Set) methodsFor: 'adding' !
add: anElement
"workaround for problem with adding nil to a set"
self deltaHack.
	anElement isNil ifTrue: [^self].
	super add: anElement! !

"April 30, 2008 -> 0:17:4"!

"System saved" !
"May 2, 2008 -> 2:39:7"!

! (Delta mirrorFor: #Set) methodsFor: 'adding' !
include: anElement
"workaround for problem with adding nil to a set"
self deltaHack.
	anElement isNil ifTrue: [^self].
	super include: anElement! !

"May 2, 2008 -> 9:56:38"!

"System saved" !
"May 18, 2008 -> 2:18:6"!

Delta define: #ExceptionSelector as: (
Protocol superProtocol: '<Object>') !


"May 18, 2008 -> 2:18:6"!

(Delta mirrorFor: #ExceptionSelector)
comment: 
'Defines the <exceptionSelector> protocol from the ANSI standard.'!


"May 18, 2008 -> 2:18:6"!

! (Delta mirrorFor: #ExceptionSelector) methodsFor: 'exception selector' !
handles: anException ! !

"May 18, 2008 -> 2:18:14"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 18, 2008 -> 2:18:14"!

(Delta mirrorFor: #BlockExceptionSelector)
comment: 
'Determines whether an exception can be handled by evaluating the handlesBlock.'!


"May 18, 2008 -> 2:18:14"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'test' !
test	self testShouldHandleWhenHandleBlockReturnsTrue;		testShouldPassExceptionToHandlesBlock! !

"May 18, 2008 -> 2:18:14"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'test' !
testShouldPassExceptionToHandlesBlock	|exception selector|	exception := Object new.	selector := BlockExceptionSelector handlesBlock: [:ex| [ex == exception] verify].	selector handles: exception! !

"May 18, 2008 -> 2:18:14"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'test' !
testShouldHandleWhenHandleBlockReturnsTrue	|canHandle selector|		selector := BlockExceptionSelector					handlesBlock: [:ex| canHandle].	canHandle := true.	[selector handles: nil] verify.	canHandle := false.	[(selector handles: nil) not] verify! !

"May 18, 2008 -> 2:18:14"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'instantiation' !
handlesBlock: block 	^self new		handlesBlock: block;		yourself! !

"May 18, 2008 -> 2:18:14"!

! (Delta mirrorFor: #BlockExceptionSelector) methodsFor: 'initialization' !
handlesBlock: block	handlesBlock := block ! !

"May 18, 2008 -> 2:18:14"!

! (Delta mirrorFor: #BlockExceptionSelector) methodsFor: 'exception selector' !
handles: exceptionDescriptor	^handlesBlock value: exceptionDescriptor! !

"May 18, 2008 -> 2:18:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 18, 2008 -> 2:18:22"!

(Delta mirrorFor: #BlockExceptionHandler)
comment: 
'Exception handler for an exception. Handles the exception by invoking its handleBlock.'!


"May 18, 2008 -> 2:18:22"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'tests' !
test	self testShouldInvokeHandlerBlockWithException! !

"May 18, 2008 -> 2:18:22"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'tests' !
testShouldInvokeHandlerBlockWithException	|handled exception|	handled := false.	exception = Object new.	(BlockExceptionHandler		handleBlock: [:ex| [ex == exception] verify.			handled := true])		handle: exception.	[handled] verify! !

"May 18, 2008 -> 2:18:22"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
handleBlock: block	^self new		handleBlock: block;		yourself! !

"May 18, 2008 -> 2:18:22"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
new	^super new initialize! !

"May 18, 2008 -> 2:18:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'private initialization' !
initialize	handleBlock := [:exception|].	passBlock := [:exception|].! !

"May 18, 2008 -> 2:18:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'private initialization' !
handleBlock: block	handleBlock := block! !

"May 18, 2008 -> 2:18:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
canHandleSignal: exception	^false! !

"May 18, 2008 -> 2:18:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
handle: exception return: aBlock	^aBlock value: (handleBlock value: exception)! !

"May 18, 2008 -> 2:18:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
handle: exception	^handleBlock value: exception! !

"May 18, 2008 -> 2:18:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
passBlock: block	passBlock := block! !

"May 18, 2008 -> 2:18:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
pass: exception	passBlock value: exception! !

"May 18, 2008 -> 2:18:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
nextHandler	^nil! !

"May 18, 2008 -> 2:18:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
nextHandler: ignored! !

"May 18, 2008 -> 2:18:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
returnBlock: block	returnBlock := block! !

"May 18, 2008 -> 2:18:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
return: value	returnBlock value: value! !

"May 18, 2008 -> 2:18:30"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 18, 2008 -> 2:18:30"!

(Delta mirrorFor: #BlockExceptionDescriptor)
comment: 
'Implements the <exceptionDescriptor> protocol from the ANSI standard using configurable actionsdefined as blocks. Intended to be used primarily as a testing aid.'!


"May 18, 2008 -> 2:18:30"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'instantiation' !
new	^super new		initialize;		yourself! !

"May 18, 2008 -> 2:18:30"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'test' !
test	self testDefaultActionShouldInvokeDefaultActionBlock;		testDefaultDefault;		testHandlerShouldDelegateToHandlerBlock! !

"May 18, 2008 -> 2:18:30"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'test' !
testDefaultDefault	|exception wasInvoked|	exception := BlockExceptionDescriptor new.	exception defaultAction! !

"May 18, 2008 -> 2:18:30"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'test' !
testDefaultActionShouldInvokeDefaultActionBlock	|exception wasInvoked|	exception := BlockExceptionDescriptor new.	wasInvoked := false.	exception defaultActionBlock: [wasInvoked := true].	exception defaultAction.	[wasInvoked] verify! !

"May 18, 2008 -> 2:18:30"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'test' !
testHandlerShouldDelegateToHandlerBlock	|descriptor actualHandler|		descriptor := BlockExceptionDescriptor new.	descriptor handlerBlock: [:handler| actualHandler := handler].	descriptor handler: #handler.	[actualHandler == #handler] verify! !

"May 18, 2008 -> 2:18:30"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
defaultActionBlock: block	defaultBlock := block! !

"May 18, 2008 -> 2:18:30"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
handlerBlock: block	handlerBlock := block ! !

"May 18, 2008 -> 2:18:30"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
handler: handler	handlerBlock value: handler ! !

"May 18, 2008 -> 2:18:30"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'initialization' !
initialize	defaultBlock := [].	handlerBlock := [:ignore|]! !

"May 18, 2008 -> 2:18:30"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'exception descriptor' !
defaultAction	defaultBlock value! !

"May 18, 2008 -> 2:18:37"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 18, 2008 -> 2:18:38"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 18, 2008 -> 2:18:38"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 18, 2008 -> 2:18:38"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 18, 2008 -> 2:18:38"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 18, 2008 -> 2:18:38"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 18, 2008 -> 2:18:38"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 18, 2008 -> 2:18:38"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 18, 2008 -> 2:18:38"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 18, 2008 -> 2:18:38"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 18, 2008 -> 2:18:38"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 18, 2008 -> 2:18:38"!

(Delta mirrorFor: #BlockExceptionHandler)
comment: 
'Exception handler for an exception. Handles the exception by invoking its handleBlock.'!


"May 18, 2008 -> 2:18:38"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'tests' !
test	self testShouldInvokeHandlerBlockWithException! !

"May 18, 2008 -> 2:18:38"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'tests' !
testShouldInvokeHandlerBlockWithException	|handled exception|	handled := false.	exception = Object new.	(BlockExceptionHandler		handleBlock: [:ex| [ex == exception] verify.			handled := true])		handle: exception.	[handled] verify! !

"May 18, 2008 -> 2:18:38"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
handleBlock: block	^self new		handleBlock: block;		yourself! !

"May 18, 2008 -> 2:18:38"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
new	^super new initialize! !

"May 18, 2008 -> 2:18:38"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'private initialization' !
initialize	handleBlock := [:exception|].	passBlock := [:exception|].! !

"May 18, 2008 -> 2:18:38"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'private initialization' !
handleBlock: block	handleBlock := block! !

"May 18, 2008 -> 2:18:38"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
canHandleSignal: exception	^false! !

"May 18, 2008 -> 2:18:38"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
handle: exception return: aBlock	^aBlock value: (handleBlock value: exception)! !

"May 18, 2008 -> 2:18:38"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
handle: exception	^handleBlock value: exception! !

"May 18, 2008 -> 2:18:38"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
passBlock: block	passBlock := block! !

"May 18, 2008 -> 2:18:38"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
pass: exception	passBlock value: exception! !

"May 18, 2008 -> 2:18:38"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
nextHandler	^nil! !

"May 18, 2008 -> 2:18:38"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
nextHandler: ignored! !

"May 18, 2008 -> 2:18:38"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
returnBlock: block	returnBlock := block! !

"May 18, 2008 -> 2:18:38"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
return: value	returnBlock value: value! !

"May 18, 2008 -> 2:18:43"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 18, 2008 -> 2:18:43"!

(Delta mirrorFor: #LinkedExceptionHandler)
comment: 
'Exception handler for an exception. Invokes its handleBlock when asked to handle an exceptionthat matches its exceptionSelector. If the exception does not match its exceptionSelector it passesthe exception on to the nextHandler. If the nextHandler is undefined signal an UnhandledExceptionError.This class is internal to the exception handling framework. There should be no need for code outside of thisframework to interact with instances of ExceptionHandler.'!


"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
test	self testShouldInvokeHandleBlockWhenExceptionMatches;		testShouldInvokeExceptionsDefaultActionWhenNoNextHandler;		testShouldDelegateToNextHandlerWhenNoMatch;		testHandlerShouldSetHandlerOnException;		testPassShouldDeferToNextHandler;		testReturnShouldEvaluateReturnBlock! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testShouldInvokeHandleBlockWhenExceptionMatches	|handled trueSelector exception|	handled := false.	exception := BlockExceptionDescriptor new.	trueSelector := BlockExceptionSelector handlesBlock: [:ex| true].	(LinkedExceptionHandler		on: trueSelector		do: [:ex| [ex == exception] verify.			handled := true])		handle: exception.	[handled] verify! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testShouldDelegateToNextHandlerWhenNoMatch	|handled falseSelector exception nextHandler|	handled := false.	falseSelector := BlockExceptionSelector handlesBlock: [:ex| false].	exception := BlockExceptionDescriptor new.	nextHandler := (BlockExceptionHandler						handleBlock: [:ex| [ex == exception] verify.										handled := true]).	(LinkedExceptionHandler on: falseSelector do: [:ex| self shouldNotHappen])		nextHandler: nextHandler;		handle: exception.	[handled] verify! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testShouldInvokeExceptionsDefaultActionWhenNoNextHandler	|handled falseSelector exception|	handled := false.	falseSelector := BlockExceptionSelector handlesBlock: [:ex| false].	exception := BlockExceptionDescriptor new.	exception defaultActionBlock: [handled := true].	(LinkedExceptionHandler on: falseSelector do: [:ex| self shouldNotHappen])		handle: exception.	[handled] verify! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testPassShouldDeferToNextHandler	|handler trueSelector exception wasPassed nextHandler|	trueSelector := BlockExceptionSelector handlesBlock: [:ex| true].	exception := BlockExceptionDescriptor new.		handler := LinkedExceptionHandler on: trueSelector do: [:ex| ].	nextHandler := BlockExceptionHandler handleBlock: [:ex| wasPassed := true].	handler nextHandler: nextHandler.		wasPassed := false.	handler pass: exception.	[wasPassed] verify	! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testReturnShouldEvaluateReturnBlock	|handler result |	handler := LinkedExceptionHandler					on: nil					do: [:ex| ]					return: [:returnValue| result := returnValue].	handler return: #value.	[result == #value] verify! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testHandlerShouldSetHandlerOnException	|handler trueSelector exception assignedHandler|	trueSelector := BlockExceptionSelector handlesBlock: [:ex| true].	exception := BlockExceptionDescriptor new.	exception handlerBlock: [:handler| assignedHandler := handler].	handler := LinkedExceptionHandler on: trueSelector do: [:ex| ].	[assignedHandler ~~ handler] verify.	handler handle: exception.	[assignedHandler == handler] verify! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'exceptionBuilder' !
on: anExceptionSelector do: handleBlock	^self new		on: anExceptionSelector do: handleBlock return: [:value|] outer: nil;		yourself! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'exceptionBuilder' !
on: anExceptionSelector do: handleBlock return: returnBlock	^self new		on: anExceptionSelector do: handleBlock return: returnBlock outer: nil;		yourself! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'exceptionBuilder' !
on: anExceptionSelector do: handleBlock return: returnBlock outer: outerBlock	^self new		on: anExceptionSelector do: handleBlock return: returnBlock outer: outerBlock;		yourself! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock	exceptionSelector := anExceptionSelector.	handleBlock := block.	returnBlock := aReturnBlock.	nextHandler := BlockExceptionHandler handleBlock: [:ex| ex defaultAction] ! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
nextHandler: exceptionHandler	nextHandler := exceptionHandler ! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
handle: exception	self handle: exception		return: returnBlock! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
protect: aBlock	Processor activeProcess pushHandler: self.	^[(self evaluateProtectee: aBlock) value]		ensure: [Processor activeProcess popHandler]! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock	|result|	protectee := aBlock.	retryBlock := [^[self evaluateProtectee: protectee]].	result := protectee value.	^[result]! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
retry		retryBlock value! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
retryUsing: aBlock		protectee := aBlock.	retryBlock value! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
canHandleSignal: exception	^(exceptionSelector handles: exception)		or: [nextHandler notNil 		and: [nextHandler canHandleSignal: exception]]! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
handle: exception return: aReturnBlock	exception handler: self.	^(exceptionSelector handles: exception)		ifTrue: [aReturnBlock value: (handleBlock value: exception)]		ifFalse: [nextHandler handle: exception return: aReturnBlock]! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
outer: exception return: aReturnBlock	^nextHandler handle: exception return: aReturnBlock! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
pass: exception	^nextHandler handle: exception! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
return: aValue	returnBlock value: aValue! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
nextHandler	^nextHandler! !

"May 18, 2008 -> 2:18:50"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"May 18, 2008 -> 2:18:50"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"May 18, 2008 -> 2:18:50"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"May 18, 2008 -> 2:18:50"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"May 18, 2008 -> 2:18:50"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"May 18, 2008 -> 2:18:50"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"May 18, 2008 -> 2:18:50"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"May 18, 2008 -> 2:18:50"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"May 18, 2008 -> 2:18:50"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"May 18, 2008 -> 2:18:50"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"May 18, 2008 -> 2:18:50"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"May 18, 2008 -> 2:18:50"!

(Delta mirrorFor: #Process)
comment: 
'Tags: %BlueBook %User

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license
'!


"May 18, 2008 -> 2:18:50"!

! (Delta mirrorFor: #Process) classSide methodsFor: 'file out' !
fileOutSignature ^<Integer>
    ^80! !

"May 18, 2008 -> 2:18:50"!

! (Delta mirrorFor: #Process) classSide methodsFor: 'instance creation' !
for: block <[]> ^<Instance>
	"Create and return a new process that will execute the block at the
	 specified priority.  The new process is suspended."

	| i <Instance> |
	i := (guaranteed <Instance>
		{{self primitiveProcessCreate: [ i recordId. block value ]
				ifFail: [ :err <Symbol> | self error: err ]
		}}
	  ) initFor: block.
	^i! !

"May 18, 2008 -> 2:18:50"!

! (Delta mirrorFor: #Process) classSide methodsFor: 'instance creation' !
primitiveCreate: block! !

"May 18, 2008 -> 2:18:50"!

! (Delta mirrorFor: #Process) classSide methodsFor: 'testing' !
test

	self testHandleShouldInvokeDefaultAction;
		 testPushHandlerShouldReplaceDefaultHandler;
		 testPushHandlerShouldDeferToOuterHandlerWhenExceptionDoesntMatch;
		 testPushHandlerShouldDeferToDefaultHandlerWhenExceptionDoesntMatch! !

"May 18, 2008 -> 2:18:50"!

! (Delta mirrorFor: #Process) classSide methodsFor: 'testing' !
testHandleShouldInvokeDefaultAction

	|exception wasInvoked|
	wasInvoked := false.
	exception := BlockExceptionDescriptor new.
	exception defaultActionBlock: [wasInvoked := true].
	Processor activeProcess handle: exception.
	[wasInvoked] verify.! !

"May 18, 2008 -> 2:18:50"!

! (Delta mirrorFor: #Process) classSide methodsFor: 'testing' !
testPushHandlerShouldReplaceDefaultHandler

	|process exceptionSelector wasInvoked exception|
	process := Processor activeProcess.
	exception := BlockExceptionDescriptor new.
	wasInvoked := false.
	exceptionSelector := BlockExceptionSelector handlesBlock: [:ex| true].
	[process pushHandler: (LinkedExceptionHandler
							on: exceptionSelector
							do: [:ex| wasInvoked := true]).
	process handle: exception.
	[wasInvoked] verify]
		ensure: [process popHandler]! !

"May 18, 2008 -> 2:18:50"!

! (Delta mirrorFor: #Process) classSide methodsFor: 'testing' !
testPushHandlerShouldDeferToDefaultHandlerWhenExceptionDoesntMatch

	|process exceptionSelector wasInvoked exception|
	wasInvoked := false.
	exception := BlockExceptionDescriptor new.
	exception defaultActionBlock: [wasInvoked := true].
	exceptionSelector := BlockExceptionSelector handlesBlock: [:ex| false].
	process := Processor activeProcess.
	[process pushHandler: (LinkedExceptionHandler
							on: exceptionSelector
							do: [:ex| ]).
	process handle: exception.
	[wasInvoked] verify]
		ensure: [process popHandler]! !

"May 18, 2008 -> 2:18:50"!

! (Delta mirrorFor: #Process) classSide methodsFor: 'testing' !
testPushHandlerShouldDeferToOuterHandlerWhenExceptionDoesntMatch

	|process trueSelector falseSelector wasInvoked exception outerHandler|
	wasInvoked := false.
	exception := BlockExceptionDescriptor new.
	exception defaultActionBlock: [].
	trueSelector := BlockExceptionSelector handlesBlock: [:ex| true].
	falseSelector := BlockExceptionSelector handlesBlock: [:ex| false].
	process := Processor activeProcess.
	outerHandler := (LinkedExceptionHandler
							on: trueSelector
							do: [:ex| wasInvoked := true]).
	[process pushHandler: outerHandler.
	process pushHandler: (LinkedExceptionHandler
							on: falseSelector
							do: [:ex| ]).
	process handle: exception.
	[wasInvoked] verify]
		ensure: [process popHandler.
			process popHandler]
! !

"May 18, 2008 -> 2:18:50"!

! (Delta mirrorFor: #Process) methodsFor: 'accessing' !
priority ^<Int>

	^priority! !

"May 18, 2008 -> 2:18:50"!

! (Delta mirrorFor: #Process) methodsFor: 'accessing' !
priority: prio <Int>

	priority := prio! !

"May 18, 2008 -> 2:18:50"!

! (Delta mirrorFor: #Process) methodsFor: 'accessing' !
processError ^ <ProcessError>

	^processError
! !

"May 18, 2008 -> 2:18:50"!

! (Delta mirrorFor: #Process) methodsFor: 'accessing' !
status ^<Symbol>
	"One of:
		#Initialized				- State right after creation.
		#Yielded					- Gave up control by calling yield.
		#InAsyncDLL			- Gave up control but continues to execute asynchronous DLL.
		#Stopped				- Gave up control by calling stop.
		#Preempted			- Was preempted by system.
		#Running					- Currently running
		#Completed			- Ran to completion.
		#Killed						- The process has been terminated.
		#BooleanError		- A boolean was expected at hardcoded control structure.
		#LookupError			- The receiver does not understand doesNotUnderstand:.
		#PrimitiveLookupError	- Binding a primitive failed.
		#DLLLookupError				 - Binding a DLL function failed.
		#NLRError				- Context for NLR did not exist.
		#StackOverflow		- Stack exhausted.
	"

	^{{self primitiveProcessStatus}}! !

"May 18, 2008 -> 2:18:50"!

! (Delta mirrorFor: #Process) methodsFor: 'control' !
resume

	Processor resume: self! !

"May 18, 2008 -> 2:18:50"!

! (Delta mirrorFor: #Process) methodsFor: 'control' !
suspend

	Processor suspend: self.
	Processor activeProcess = self
		ifTrue: [ self yield ]! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'control' !
terminate

	Processor terminating: self.
	self vmTerminate.	! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'control' !
waitUntilDead
	"can be called after a process has been terminated to wait until it has completed
		unwinding its stack etc, and is truly dead.  This loops currently, so it is not
		a good way for waiting for the death of a process that has not been terminated.
		This may never return if the process that has been terminated does not ever
		finish cleaning up."
	
	[ self running ]
		whileTrue: [ Processor yield ]! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handle: exception

	^self handlerChain handle: exception! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler handleBlock: [:ex| ex defaultAction]].
	^handlerChain! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
pushHandler: handler

	handler nextHandler: self handlerChain.
	handlerChain := handler ! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
popHandler

	handlerChain := self handlerChain nextHandler ! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
resetHandlers

	handlerChain := nil

! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'file out' !
fileOutSignature ^<Integer>
    ^112! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'private' !
register

	Processor register: self.! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'private' !
vmTerminate

	{{self primitiveProcessTerminateIfFail: [ :err <Symbol> | self error: err ]}}! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'private-initialization' !
initFor: block <[]>

	body := block.

	self register.
	
! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'private-initialization' !
recordId

	win32Handle := Platform currentThreadId! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'restricted' !
activationStack ^ <Array[Activation]>

	^{{self primitiveProcessStackLimit: 100 ifFail: [ :err <CompressedSymbol>  | self error: err]}}! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'restricted' !
processError: e <ProcessError>

	processError := e
! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'restricted' !
stopInEvaluator

	Processor stopInEvaluator: self! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'restricted' !
traceStack

	{{self primitiveProcessTraceStack: 20 ifFail: [ :err <Symbol> | self error: err]}}
! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'restricted' !
win32Handle ^<Win32Handle>
	"This is valid only after the process has begun to actually execute"

	^win32Handle! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'restricted' !
yield
	{{primitiveProcessYield}}! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'testing' !
running ^<Boolean>
	"Not suspended, dying, or dead. (This includes processes blocked in async dll calls)"

	^Processor isRunning: self! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'testing' !
suspended ^<Boolean>
	"Not on the running list, but can be resumed"

	| s <Symbol> |
	self running
		ifTrue: [ ^false ].
	s := self status.
	^s == #Yielded
		or: [ s == #InAsyncDLL
		or: [ s == #Initialized
		or: [ s == #Preempted
		or: [ s == #Stopped ]   ]]]! !

"May 18, 2008 -> 2:19:14"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 18, 2008 -> 2:19:14"!

Delta define: #TestException as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultActionBlock')) !


"May 18, 2008 -> 2:19:14"!

(Delta mirrorFor: #Exception)
comment: 
'Base class of the exception hierarchy. Implements the core of the ANSI exception handling protocols'!


"May 18, 2008 -> 2:19:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
test	self testSignalShouldInvokeProcessHandler;		testPassShouldDeferToOuterHandler;		testPassShouldNotReturn;		testPassShouldInvokeDefaultActionWithoutReturning;		testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable;		testOuterShouldInvokeAndReturnDefaultActionWhenResumable;		testOuterTwiceShouldInvokeSurroundingHandlerTwice;		testResumeShouldReturnAsValueOfOuter;		testResumeShouldReturnFromSignal;		testResumeWithValueShouldReturnFromSignal;		testReturnShouldDelegateToHandler;		testIsNestedShouldBeFalseWithNoHandler;		testIsNestedShouldBeTrueWhenOuterHandlerHandles;		testIsNestedShouldBeFalseWhenOuterHandlerDoesntHandle;		testIsNestedShouldBeTrueWhenOuterOuterHandlerHandles;		testResignalAsShouldRestoreSignalEnvironment;		testRetryShouldReevaluateProtectee;		testRetryUsingShouldReplaceProtectee! !

"May 18, 2008 -> 2:19:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testPassShouldDeferToOuterHandler	|wasPassed|	wasPassed := false.	[[Exception signal]		on: Exception		do: [:ex| ex pass]]			on: Exception			do: [:ex| wasPassed := true].	[wasPassed] verify! !

"May 18, 2008 -> 2:19:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testPassShouldNotReturn	[([[Exception signal]		on: Exception		do: [:ex| ex pass.			self shouldNotHappen]]			on: Exception			do: [:ex| #result]) == #result] verify! !

"May 18, 2008 -> 2:19:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testPassShouldInvokeDefaultActionWithoutReturning	[([|result|		result := (TestException defaultActionBlock: [#result])						signal.		[result == #result] verify.		result]			on: TestException			do: [:ex| ex pass.				self shouldNotHappen]) == #result] verify! !

"May 18, 2008 -> 2:19:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable	[([|result|		result := (TestException defaultActionBlock: [#result])						signal.		[result == #result] verify.		result]			on: TestException			do: [:ex| ex outer.				self shouldNotHappen]) == #result] verify! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable	|outer result|	[(TestException defaultActionBlock: [#result])		resumable: true;		signal]			on: TestException			do: [:ex| outer := ex outer.				result := #returned].	[result == #returned] verify.	[outer == #result] verify.! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testOuterTwiceShouldInvokeSurroundingHandlerTwice	|count|	count := 0.	[[(TestException defaultActionBlock: [-1])			resumable: true;			signal]		on: TestException		do: [:ex| ex outer.				ex outer]]			on: TestException			do: [:ex| count := count + 1].	[count == 2] verify! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testResumeShouldReturnAsValueOfOuter	|result|	[[Exception signal]	 	on: Exception	 	do: [:ex| result := ex outer]]	 		on: Exception	 		do: [:ex| ex resume: #result].	[result == #result] verify! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testResumeWithValueShouldReturnFromSignal	|result|	[result := Exception signal]	 	on: Exception	 	do: [:ex| ex resume: #result].	[result == #result] verify! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testResumeShouldReturnFromSignal	|wasResumed|	wasResumed := false.	[Exception signal.	 wasResumed := true]	 	on: Exception	 	do: [:ex| ex resume].	[wasResumed] verify! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testSignalShouldInvokeProcessHandler		|wasInvoked|	wasInvoked := false.	Processor activeProcess 		pushHandler: (BlockExceptionHandler 						handleBlock: [:ex| wasInvoked := true]).	Exception signal.	[[wasInvoked] verify]		ensure: [Processor activeProcess popHandler]! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testReturnShouldDelegateToHandler		|exception handler result|	exception := Exception new.	handler := BlockExceptionHandler new.	result := #invalid.	handler returnBlock: [:value| result := value].	exception handler: handler.	exception return.	[result isNil] verify! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testIsNestedShouldBeFalseWithNoHandler		|exception|	exception := Exception new.	[exception isNested not] verify! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testIsNestedShouldBeTrueWhenOuterHandlerHandles		|result|	[[Exception signal]		on: Exception		do: [:ex| result := ex isNested]]			on: Exception			do: [:ex| self shouldNotHappen]. 	[result] verify! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testRetryUsingShouldReplaceProtectee		|log count|	log := String new writeStream.	count := 0.	[[Exception signal] ensure: [log nextPutAll: 'unwind ']]		on: Exception		do: [:ex|			log nextPutAll: 'handle '.			count := count + 1.			count = 1 ifTrue: [ex retryUsing: [log nextPutAll: 'using '.												Exception signal]]].	[log contents = 'handle unwind using handle '] verify! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testRetryShouldReevaluateProtectee		|count|	count := 0.	[count := count + 1.	count == 1 ifTrue:[Exception signal]]		on: Exception		do: [:ex| ex retry].	[count == 2] verify! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testResignalAsShouldRestoreSignalEnvironment		|log|	log := String new writeStream.	[[Exception signal]		on: TestException		do: [:ex| log nextPutAll: 'resignal']]			on: Exception			do: [:ex|				[log nextPutAll: 'signal '. 				ex resignalAs: TestException new]					ifCurtailed: [log nextPutAll: 'curtail ']].	[log contents = 'signal curtail resignal'] verify! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testIsNestedShouldBeTrueWhenOuterOuterHandlerHandles		|result|	[[[Exception signal]		on: Exception		do: [:ex| result := ex isNested]]			on: TestException			do: [:ex|]]				on: Exception				do: [:ex|]. 	[result] verify! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testIsNestedShouldBeFalseWhenOuterHandlerDoesntHandle		|result|	[[Exception signal]		on: Exception		do: [:ex| result := ex isNested]]			on: TestException			do: [:ex|]. 	[result not] verify! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'exceptionBuilder' !
tag: t	"This message is not specified in the ANSI protocol, but that looks like an oversight because #tag is specified, and the spec states that the signaler may store the tag value."	tag := t! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'exceptionDescription' !
tag	"Return an exception's tag value."	^tag == nil		ifTrue: [self messageText]		ifFalse: [tag]! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
isNested	"Determine whether the current exception handler is within the scope of another handler for the same exception."	^ handler notNil and: [handler nextHandler canHandleSignal: self]! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
outer	"Evaluate the enclosing exception action and return to here instead of signal if it resumes (see #resumeUnchecked:)."	| oldHandler oldResume |	self isResumable ifFalse: [		self pass.	].		[oldResume := resumeBlock.	resumeBlock := [:value| ^value].	(oldHandler := handler) outer: self return: [:value| ^value]]		ensure: [handler := oldHandler.				resumeBlock := oldResume]! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
pass	"Yield control to the enclosing exception action for the receiver."	passBlock value! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resignalAs: replacementException	"Signal an alternative exception in place of the receiver."	resignalBlock value: replacementException! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resume	"Return from the message that signaled the receiver."	self resume: nil! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resume: resumptionValue	"Return resumptionValue as the value of the signal message."	resumeBlock value: resumptionValue! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
retry	"Abort an exception handler and re-evaluate its protected block."	handler retry! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
retryUsing: alternativeBlock	"Abort an exception handler and evaluate a new block in place of the handler's protected block."	handler retryUsing: alternativeBlock! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
return	"Return nil as the value of the block protected by the active exception handler."	self return: nil! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
return: returnValue	"Return the argument as the value of the block protected by the active exception handler."	handler return: returnValue! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
description	"Return a textual description of the exception."	| desc mt |	desc := self class name asString.	^(mt := self messageText) == nil		ifTrue: [desc]		ifFalse: [desc, ': ', mt]! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
messageText	"Return an exception's message text."	^messageText! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
printOn: stream	stream nextPutAll: self description! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
messageText: signalerText	"Set an exception's message text."	messageText := signalerText! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
signal	^self privateSignal value! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
privateSignal	"Ask ContextHandlers in the sender chain to handle this signal.  The default is to execute and return my defaultAction."		resignalBlock := [:ex| ^[ex signal]].	resumeBlock := [:result| ^[result]].	passBlock := [^[handler pass: self]].	Processor activeProcess handle: self.	^[]! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
signal: signalerText	"Signal the occurrence of an exceptional condition with a specified textual description."	self messageText: signalerText.	^ self signal! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
defaultAction	"The default action taken if the exception is signaled."	self subclassResponsibility! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
isResumable	"Determine whether an exception is resumable."	^ true! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
handler: aHandler	handler := aHandler! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionInstantiator' !
signal	"Signal the occurrence of an exceptional condition."	^ self new signal! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionInstantiator' !
signal: signalerText	"Signal the occurrence of an exceptional condition with a specified textual description."	^ self new signal: signalerText! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionSelector' !
, anotherException	"Create an exception set.""	^ExceptionSet new		add: self;		add: anotherException;		yourself"! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionSelector' !
handles: exception	"Determine whether an exception handler will accept a signaled exception."	^ exception isKindOf: self! !

"May 18, 2008 -> 2:19:21"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock')) !


"May 18, 2008 -> 2:19:21"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock')) !


"May 18, 2008 -> 2:19:21"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock')) !


"May 18, 2008 -> 2:19:21"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock')) !


"May 18, 2008 -> 2:19:21"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock')) !


"May 18, 2008 -> 2:19:21"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock')) !


"May 18, 2008 -> 2:19:21"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock')) !


"May 18, 2008 -> 2:19:21"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"May 18, 2008 -> 2:19:21"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"May 18, 2008 -> 2:19:21"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"May 18, 2008 -> 2:19:21"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"May 18, 2008 -> 2:19:21"!

(Delta mirrorFor: #TestException)
comment: 
'Concrete exception class that can be used for testing'!


"May 18, 2008 -> 2:19:21"!

! (Delta mirrorFor: #TestException) classSide methodsFor: 'test support' !
defaultActionBlock: block	^self new		defaultActionBlock: block;		yourself! !

"May 18, 2008 -> 2:19:21"!

! (Delta mirrorFor: #TestException) methodsFor: 'test support' !
defaultActionBlock: block	defaultActionBlock := block! !

"May 18, 2008 -> 2:19:21"!

! (Delta mirrorFor: #TestException) methodsFor: 'test support' !
resumable: boolean	^resumable := boolean! !

"May 18, 2008 -> 2:19:21"!

! (Delta mirrorFor: #TestException) methodsFor: 'test support' !
isResumable	^resumable isNil		ifTrue: [false]		ifFalse: [resumable]! !

"May 18, 2008 -> 2:19:21"!

! (Delta mirrorFor: #TestException) methodsFor: 'test support' !
defaultAction	^defaultActionBlock value! !

"May 18, 2008 -> 2:19:36"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"May 18, 2008 -> 2:19:36"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"May 18, 2008 -> 2:19:36"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"May 18, 2008 -> 2:19:36"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"May 18, 2008 -> 2:19:36"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"May 18, 2008 -> 2:19:36"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"May 18, 2008 -> 2:19:36"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"May 18, 2008 -> 2:19:36"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"May 18, 2008 -> 2:19:36"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"May 18, 2008 -> 2:19:36"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"May 18, 2008 -> 2:19:36"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"May 18, 2008 -> 2:19:36"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"May 18, 2008 -> 2:19:36"!

(Delta mirrorFor: #BlockWithoutArguments)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.4 $
'!


"May 18, 2008 -> 2:19:36"!

! (Delta mirrorFor: #BlockWithoutArguments) classSide methodsFor: 'testing' !
test

	| v <Boolean> |
	
	[ v := false ] ensure: [ v := true ].
	self assert: [ v ].

	[ v := false ] ifCurtailed: [ v := true ].
	self assert: [ v not ].

	self testForUnwind: [ v := false ] onUnwind: [ v := true ].
	self assert: [ v ].

	self testForEnsure: [ v := false ] onUnwind: [ v := true ].
	self assert: [ v ].
	self testOnDoShouldInvokeDoWhenExceptionSignalled;
		testOnDoShouldPopHandler;
		testOnDoShouldInvokeNestedHandler! !

"May 18, 2008 -> 2:19:36"!

! (Delta mirrorFor: #BlockWithoutArguments) classSide methodsFor: 'testing' !
testOnDoShouldInvokeDoWhenExceptionSignalled

	|wasHandled|
	wasHandled := false.
	[Exception signal]
		on: Exception
		do: [:ex| wasHandled := true].
	[wasHandled] verify
! !

"May 18, 2008 -> 2:19:36"!

! (Delta mirrorFor: #BlockWithoutArguments) classSide methodsFor: 'testing' !
testOnDoShouldPopHandler

	|handlerInvoked descriptor selector defaultInvoked|
	Processor activeProcess resetHandlers.
	descriptor := BlockExceptionDescriptor new.
	descriptor defaultActionBlock: [defaultInvoked := true].
	selector := BlockExceptionSelector handlesBlock: [:ex| true].
	[Exception signal]
		on: selector
		do: [:ex| handlerInvoked := true].
	defaultInvoked := false.
	handlerInvoked := false.
	Processor activeProcess handle: descriptor.
	[handlerInvoked not] verify.
	[defaultInvoked] verify	
! !

"May 18, 2008 -> 2:19:36"!

! (Delta mirrorFor: #BlockWithoutArguments) classSide methodsFor: 'testing' !
testOnDoShouldInvokeNestedHandler

	|innerInvoked falseSelector outerInvoked|
	falseSelector := BlockExceptionSelector handlesBlock: [:ex| false].
	innerInvoked := false.
	outerInvoked := false.
	[[[Exception signal]
		on: falseSelector
		do: [:ex| innerInvoked := true]]
			on: Exception
			do: [:ex| outerInvoked := true].
	[innerInvoked not] verify.
	[outerInvoked] verify]
		ensure: [Processor activeProcess resetHandlers]
! !

"May 18, 2008 -> 2:19:36"!

! (Delta mirrorFor: #BlockWithoutArguments) classSide methodsFor: 'testing' !
testForEnsure: b <[]> onUnwind: b2 <[]> ^<Object>

	[ ^b value ] ensure: b2! !

"May 18, 2008 -> 2:19:36"!

! (Delta mirrorFor: #BlockWithoutArguments) classSide methodsFor: 'testing' !
testForUnwind: b <[]> onUnwind: b2 <[]> ^<Object>

	[ ^b value ] ifCurtailed: b2! !

"May 18, 2008 -> 2:19:36"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
critical ^<R>
	"This is used for very short, fast critical regions where the overhead or inconvenience
	  of a semaphore is not desired.  The argument is evaluated without any process context
	  switches taking place, so that it can perform atomic operations.  WARNING: the blk MUST
	  NOT do anything that might cause the process to block, such as any kind of I/O.  This
	  method is only appropriate for very fast atomic operations that are extremely reliable, since
	  no other processes will get a chance to run while it is being evaluated, and if it crashes,
	  it will not be debuggable, since the development & debugger processes will not be able to run."

	"%todo: implement this right.  NOTE: an interesting semantic idea: we could dramatically improve
	  the usefulnes of this if it was a critical region on the receiver, not on the system as a whole."

	^self value! !

"May 18, 2008 -> 2:19:36"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
ensure: f <[]> ^<R>

	"Use the following impl when vm bug fixed"
	"[ ^self value ] ifCurtailed: f"

	| result <R> |
	[ result := self value ] ifCurtailed: f.
	f value.
	^result! !

"May 18, 2008 -> 2:19:36"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
fork ^<Process>

	^self forkAt: Processor activePriority! !

"May 18, 2008 -> 2:19:36"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
forkAt: priority <Int> ^<Process>

	^self newProcess priority: priority; resume! !

"May 18, 2008 -> 2:19:36"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
ifCurtailed: protect <[]> ^<R>

	^guaranteed <R>
		  {{self primitiveUnwindProtect: protect
				ifFail: [ :err <Symbol> |	self shouldNotHappen ]
		  }}
! !

"May 18, 2008 -> 2:19:36"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
newProcess ^<Process>

	^Process for: self! !

"May 18, 2008 -> 2:19:36"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
on: exception do: handlerBlock

	^(LinkedExceptionHandler
		on: exception
		do: handlerBlock
		return: [:value | ^ value]) protect: self
! !

"May 18, 2008 -> 2:19:36"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
profile

	Profiler do: self! !

"May 18, 2008 -> 2:19:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
repeat ^<BottomType>

	[ true ] whileTrue: [ self value ].
	self shouldNotHappen.! !

"May 18, 2008 -> 2:19:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
time ^<Int>

	^Time millisecondsToRun: self! !

"May 18, 2008 -> 2:19:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
userTime ^<Int>

	^Time userMillisecondsToRun: self! !

"May 18, 2008 -> 2:19:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
value ^<R>

    ^{{self primitiveValue}}! !

"May 18, 2008 -> 2:19:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
valueIfFail: fail <[^X def]>  ^<R | X>

	^self value! !

"May 18, 2008 -> 2:19:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
verify
	"Evaluate the receiver, and generate an error if it does not return true.  This is different than
	  Object>>#assert: in that 1) it is a boolean block message, and 2) it ALWAYS evaluates, whereas
	  #assert: does not guarantee that it will evaluate the predicate.

	  Use verify in situations where you must ensure that the test is performed, for example when there
	  are side-effects that must take place, or if it is testing code that should always be performed.

	  Note that this message is only valid for blocks that return boolean values."

	"Note: we don't use self as the receiver for #error: below because it will currently
		prevent the block from being optimized away by the inliner"
	self value
		ifFalse: [ BlockWithoutArguments[Object] error: 'Assertion failed' ].

	"%hack %todo: remove this when compiler bug fixed"
	^nil! !

"May 18, 2008 -> 2:19:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
verify: message
	"Evaluate the receiver, and generate an error if it does not return true.  This is different than
	  Object>>#assert: in that 1) it is a boolean block message, and 2) it ALWAYS evaluates, whereas
	  #assert: does not guarantee that it will evaluate the predicate.

	  Use verify in situations where you must ensure that the test is performed, for example when there
	  are side-effects that must take place, or if it is testing code that should always be performed.

	  Note that this message is only valid for blocks that return boolean values."

	"Note: we don't use self as the receiver for #error: below because it will currently
		prevent the block from being optimized away by the inliner"
	self value
		ifFalse: [ BlockWithoutArguments[Object] error: 'Assertion failed: ', message ].

	"%hack %todo: remove this when compiler bug fixed"
	^nil! !

"May 18, 2008 -> 2:19:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
whileFalse ^<Object>

	^self whileFalse: []! !

"May 18, 2008 -> 2:19:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
whileFalse: blk <[]> ^<Object>

	"We can guarantee that self value is a Boolean in typesafe programs because the typechecker removes this
		  message from the protocol of blocks that don't return Booleans"
	(guaranteed <Boolean> (self value))
		ifFalse: [	blk value.
					[ (guaranteed <Boolean> (self value)) ]
						whileFalse: [ blk value ]	].
	^nil! !

"May 18, 2008 -> 2:19:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
whileTrue ^<Object>

	^self whileTrue: []! !

"May 18, 2008 -> 2:19:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
whileTrue: blk <[]> ^<Object>

	"We can guarantee that self value is a Boolean in typesafe programs because the typechecker removes this
		  message from the protocol of blocks that don't return Booleans"


	(guaranteed <Boolean> (self value))
		ifTrue: [	blk value.
					[ (guaranteed <Boolean> (self value)) ]
						whileTrue: [ blk value ]	].

	^nil! !

"May 18, 2008 -> 2:23:36"!

! (Delta mirrorFor: #Set) methodsFor: 'adding' !
include: anElement
"workaround for problem with adding nil to a set"
self deltaHack.
	anElement isNil ifTrue: [^self].
	super include: anElement! !

"May 18, 2008 -> 2:24:59"!

! (Delta mirrorFor: #Set) methodsFor: 'adding' !
include: anElement ifNew: ifNew
"workaround for problem with adding nil to a set"
self deltaHack.
	anElement isNil ifTrue: [^self].
	super include: anElement ifNew: ifNew! !

"May 18, 2008 -> 2:25:3"!

(Delta mirrorFor: #Set) removeMethod: #include: ifAbsent: [] !


"May 18, 2008 -> 2:25:5"!

(Delta mirrorFor: #Set) removeMethod: #add: ifAbsent: [] !


"May 18, 2008 -> 2:26:4"!

! (Delta mirrorFor: #Set) methodsFor: 'adding' !
include: anElement ifNew: ifNew
"workaround for problem with adding nil to a set"
self deltaHack.
	anElement isNil ifTrue: [^anElement].
	^super include: anElement ifNew: ifNew! !

"May 18, 2008 -> 2:36:12"!

"System saved" !
"May 18, 2008 -> 6:44:16"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 18, 2008 -> 6:44:27"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 18, 2008 -> 6:44:45"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 18, 2008 -> 6:46:42"!

Delta define: #SUnitDelay as: (
(Class subclassOf: 'Delay' instanceVariables: '')) !


"May 18, 2008 -> 6:46:42"!

Delta define: #SUnitNameResolver as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 18, 2008 -> 6:46:42"!

Delta define: #TestFailure as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 18, 2008 -> 6:47:22"!

Delta define: #CommentReader as: (
(Class subclassOf: 'DefinitionReader' instanceVariables: '')) !


"May 18, 2008 -> 6:48:43"!

! (Delta mirrorFor: #CommentReader) methodsFor: 'a new category' !
fileInFrom: stream <ReadStream>

	self mirror comment: stream nextChunk! !

"May 18, 2008 -> 6:49:56"!

! (Delta mirrorFor: #Class) methodsFor: 'file-in compatibility' !
comment:  aString

	(ClassMirror on: self) comment: aString! !

"May 18, 2008 -> 6:51:25"!

! (Delta mirrorFor: #Class) methodsFor: 'file-in compatibility' !
commentStamp: ignore prior: ignore2

	^(CommentReader for: (ClassMirror on: self))! !

"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitDelay as: (
(Class subclassOf: 'Delay' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitDelay as: (
(Class subclassOf: 'Delay' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitDelay as: (
(Class subclassOf: 'Delay' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitDelay as: (
(Class subclassOf: 'Delay' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitDelay as: (
(Class subclassOf: 'Delay' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitDelay as: (
(Class subclassOf: 'Delay' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitDelay as: (
(Class subclassOf: 'Delay' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitDelay as: (
(Class subclassOf: 'Delay' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitDelay as: (
(Class subclassOf: 'Delay' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitDelay as: (
(Class subclassOf: 'Delay' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitDelay as: (
(Class subclassOf: 'Delay' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitNameResolver as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitNameResolver as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitNameResolver as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitNameResolver as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitNameResolver as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitNameResolver as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitNameResolver as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitNameResolver as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitNameResolver as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitNameResolver as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitNameResolver as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #TestFailure as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #TestFailure as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #TestFailure as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #TestFailure as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #TestFailure as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #TestFailure as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #TestFailure as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #TestFailure as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #TestFailure as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #TestFailure as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #TestFailure as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

(Delta mirrorFor: #TestFailure)
comment: 
'Signaled in case of a failed test (failure). The test framework distinguishes between failures and errors. A failure is anticipated and checked for with assertions. Errors are unanticipated problems like a division by 0 or an index out of bounds ...'!


"May 18, 2008 -> 6:52:32"!

Delta define: #ResumableTestFailure as: (
(Class subclassOf: 'TestFailure' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

(Delta mirrorFor: #ResumableTestFailure)
comment: 
'A ResumableTestFailure triggers a TestFailure, but lets execution of the TestCase continue. this is useful when iterating through collections, and #assert: ing on each element. in combination with methods like testcase>>#assert:description:, this lets you run through a whole collection and note which tests pass.

here''''s an example:

	

	(1 to: 30) do: [ :each |
		self assert: each odd description: each printString, '' is even'' resumable: true]

for each element where #odd returns <false>, the element will be printed to the Transcript. '!


"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #Object) methodsFor: 'Camp Smalltalk' !
sunitAddDependent: anObject
 
        self addDependent: anObject! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #Object) methodsFor: 'Camp Smalltalk' !
sunitChanged: anAspect
 
        self changed: anAspect! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #Object) methodsFor: 'Camp Smalltalk' !
sunitRemoveDependent: anObject
 
        self removeDependent: anObject! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #Behavior) methodsFor: 'Camp Smalltalk' !
sunitAllSelectors 

        ^self allSelectors asSortedCollection asOrderedCollection! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #Behavior) methodsFor: 'Camp Smalltalk' !
sunitSelectors
 
        ^self selectors asSortedCollection asOrderedCollection! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'Camp Smalltalk' !
sunitEnsure: aBlock
 
        ^self ensure: aBlock! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'Camp Smalltalk' !
sunitOn: anException do: aHandlerBlock
 
        ^self on: anException do: aHandlerBlock! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #Class) methodsFor: 'Camp Smalltalk' !
sunitName
 
        ^self name! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #Exception) methodsFor: 'Camp Smalltalk' !
sunitExitWith: aValue
 
        self return: aValue! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'Camp Smalltalk' !
sunitSignalWith: aString
  
        ^self signal: aString! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #SUnitNameResolver) classSide methodsFor: 'Camp Smalltalk' !
classNamed: aSymbol

        ^Smalltalk
                at: aSymbol
                ifAbsent: [nil].! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #SUnitNameResolver) classSide methodsFor: 'Camp Smalltalk' !
defaultLogDevice
	^ Transcript! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #SUnitNameResolver) classSide methodsFor: 'Camp Smalltalk' !
errorObject
	^Error! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #SUnitNameResolver) classSide methodsFor: 'Camp Smalltalk' !
mnuExceptionObject
	^MessageNotUnderstood new! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #SUnitNameResolver) classSide methodsFor: 'Camp Smalltalk' !
notificationObject
	^Notification new! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #String) methodsFor: 'Camp Smalltalk' !
sunitAsSymbol
 
        ^self asSymbol! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #String) methodsFor: 'Camp Smalltalk' !
sunitMatch: aString
 
        ^self match: aString! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #String) methodsFor: 'Camp Smalltalk' !
sunitSubStrings
 
        ^self substrings! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #Symbol) methodsFor: 'Camp Smalltalk' !
sunitAsClass
 
        ^SUnitNameResolver classNamed: self! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #TestFailure) methodsFor: 'Camp Smalltalk' !
defaultAction

self halt.
        "Debugger
                openContext: initialContext
                label: messageText
                contents: initialContext shortStack"! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #ResumableTestFailure) methodsFor: 'Camp Smalltalk' !
isResumable
	"Of course a ResumableTestFailure is resumable ;-)"

	^true! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #ResumableTestFailure) methodsFor: 'Camp Smalltalk' !
sunitExitWith: aValue
	self resume: aValue! !

"May 18, 2008 -> 7:11:18"!

! (Delta mirrorFor: #Behavior) methodsFor: 'Camp Smalltalk' !
allSelectors

	|selectors|
	selectors := Set new.
	(ClassMirror on: self)
		methodsDo: [:method| selectors add: method selector].
	^selectors! !

"May 18, 2008 -> 7:12:14"!

! (Delta mirrorFor: #Behavior) methodsFor: 'Camp Smalltalk' !
selectors

	|selectors|
	selectors := Set new.
	(ClassMirror on: self)
		methodsDo: [:method| selectors add: method selector].
	^selectors! !

"May 18, 2008 -> 7:13:3"!

"System saved" !
"May 18, 2008 -> 7:17:42"!

! (Delta mirrorFor: #Behavior) methodsFor: 'Camp Smalltalk' !
superclassesDo: block

	|current|
	current := self superclass.
	[current = nil]
		whileFalse: [
			block value: current.
			current := current superclass]! !

"May 18, 2008 -> 7:18:25"!

! (Delta mirrorFor: #Behavior) methodsFor: 'Camp Smalltalk' !
allSelectors

	|selectors|
	selectors := Set new.
	self superclassesDo: [:class| selectors add: class selectors].
	^selectors! !

"May 18, 2008 -> 7:19:37"!

! (Delta mirrorFor: #Behavior) methodsFor: 'Camp Smalltalk' !
superclassesDo: block

	|current|
	current := self superclassIfAbsent: [^self].
	[current = nil]
		whileFalse: [
			block value: current.
			current := current superclassIfAbsent: [^self]]! !

"May 18, 2008 -> 7:19:55"!

! (Delta mirrorFor: #Behavior) methodsFor: 'Camp Smalltalk' !
allSelectors

	|selectors|
	selectors := Set new.
	self superclassesDo: [:class| selectors addAll: class selectors].
	^selectors! !

"May 18, 2008 -> 7:20:40"!

"System saved" !
"May 18, 2008 -> 7:28:15"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:28:15"!

(Delta mirrorFor: #TestCase)
comment: 
'A TestCase is a Command representing the future running of a test case. Create one with the class method #selector: aSymbol, passing the name of the method to be run when the test case runs.

When you discover a new fixture, subclass TestCase, declare instance variables for the objects in the fixture, override #setUp to initialize the variables, and possibly override# tearDown to deallocate any external resources allocated in #setUp.

When you are writing a test case method, send #assert: aBoolean when you want to check for an expected value. For example, you might say "self assert: socket isOpen" to test whether or not a socket is open at a point in a test.'!


"May 18, 2008 -> 7:28:15"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description')) !


"May 18, 2008 -> 7:28:15"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:28:15"!

(Delta mirrorFor: #TestResult)
comment: 
'This is a Collecting Parameter for the running of a bunch of tests. TestResult is an interesting object to subclass or substitute. #runCase: is the external protocol you need to reproduce. Kent has seen TestResults that recorded coverage information and that sent email when they were done.'!


"May 18, 2008 -> 7:28:15"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:28:15"!

(Delta mirrorFor: #TestSuite)
comment: 
'This is a Composite of Tests, either TestCases or other TestSuites. The common protocol is #run: aTestResult and the dependencies protocol'!


"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Dependencies' !
addDependentToHierachy: anObject 
	"an empty method. for Composite compability with TestSuite"


			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
assert: aBoolean

	aBoolean ifFalse: [self signalFailure: 'Assertion failed']
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
assert: aBoolean description: aString
	aBoolean ifFalse: [
		self logFailure: aString.
		TestResult failure sunitSignalWith: aString]
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
assert: aBoolean description: aString resumable: resumableBoolean 
	| exception |
	aBoolean
		ifFalse: 
			[self logFailure: aString.
			exception := resumableBoolean
						ifTrue: [TestResult resumableFailure]
						ifFalse: [TestResult failure].
			exception sunitSignalWith: aString]
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
debug
	self resources do: [:res | 
		res isAvailable ifFalse: [^res signalInitializationError]].
	[(self class selector: testSelector) runCase] 
		sunitEnsure: [self resources do: [:each | each reset]]
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
debugAsFailure
	| semaphore |
	semaphore := Semaphore new.
	self resources do: [:res | 
		res isAvailable ifFalse: [^res signalInitializationError]].
	[semaphore wait. self resources do: [:each | each reset]] fork.
	(self class selector: testSelector) runCaseAsFailure: semaphore.

			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
deny: aBoolean

	self assert: aBoolean not
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
deny: aBoolean description: aString
	self assert: aBoolean not description: aString
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
deny: aBoolean description: aString resumable: resumableBoolean 
	self
		assert: aBoolean not
		description: aString
		resumable: resumableBoolean
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Private' !
executeShould: aBlock inScopeOf: anExceptionalEvent 
	^[aBlock value.
 	false] sunitOn: anExceptionalEvent
		do: [:ex | ex sunitExitWith: true]
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
failureLog	
	^SUnitNameResolver defaultLogDevice

			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
isLogging
	"By default, we're not logging failures. If you override this in 
	a subclass, make sure that you override #failureLog"
	^false
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
logFailure: aString
	self isLogging ifTrue: [
		self failureLog 
			cr; 
			nextPutAll: aString; 
			flush]
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
openDebuggerOnFailingTestMethod
	"SUnit has halted one step in front of the failing test method. Step over the 'self halt' and 
	 send into 'self perform: testSelector' to see the failure from the beginning"

	self
		halt;
		performTest
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Private' !
performTest

	self perform: testSelector sunitAsSymbol
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Printing' !
printOn: aStream

	aStream
		nextPutAll: self class printString;
		nextPutAll: '>>#';
		nextPutAll: testSelector
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Dependencies' !
removeDependentFromHierachy: anObject 
	"an empty method. for Composite compability with TestSuite"


			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
resources
	| allResources resourceQueue |
	allResources := Set new.
	resourceQueue := OrderedCollection new.
	resourceQueue addAll: self class resources.
	[resourceQueue isEmpty] whileFalse: [
		| next |
		next := resourceQueue removeFirst.
		allResources add: next.
		resourceQueue addAll: next resources].
	^allResources
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
run
	| result |
	result := TestResult new.
	self run: result.
	^result
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
run: aResult
	aResult runCase: self
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
runCase

	[self setUp.
	self performTest] sunitEnsure: [self tearDown]
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
runCaseAsFailure: aSemaphore
	[self setUp.
	self openDebuggerOnFailingTestMethod] sunitEnsure: [
		self tearDown.
		aSemaphore signal]
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
selector
	^testSelector
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Private' !
setTestSelector: aSymbol
	testSelector := aSymbol
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
setUp
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
should: aBlock
	self assert: aBlock value
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
should: aBlock description: aString
	self assert: aBlock value description: aString
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
should: aBlock raise: anExceptionalEvent 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent)
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
should: aBlock raise: anExceptionalEvent description: aString 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent)
		description: aString
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
shouldnt: aBlock
	self deny: aBlock value
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
shouldnt: aBlock description: aString
	self deny: aBlock value description: aString
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
shouldnt: aBlock raise: anExceptionalEvent 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent) not
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
shouldnt: aBlock raise: anExceptionalEvent description: aString 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent) not 		description: aString
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
signalFailure: aString
	TestResult failure sunitSignalWith: aString! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
tearDown
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Accessing' !
description

	description isNil
		ifTrue: [^''].

	^description
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Accessing' !
description: aString

	description := aString
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Init / Release' !
initialize
	self setUp

			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Testing' !
isAvailable
	"override to provide information on the
	readiness of the resource"
	
	^true
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Testing' !
isUnavailable
	"override to provide information on the
	readiness of the resource"
	
	^self isAvailable not
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Accessing' !
name

	name isNil
		ifTrue: [^self printString].

	^name
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Accessing' !
name: aString

	name := aString
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Printing' !
printOn: aStream

	aStream nextPutAll: self class printString
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Accessing' !
resources
	^self class resources
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Running' !
setUp
	"Does nothing. Subclasses should override this
	to initialize their resource"
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Running' !
signalInitializationError
	^self class signalInitializationError
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Running' !
tearDown
	"Does nothing. Subclasses should override this
	to tear down their resource"
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
correctCount
	"depreciated - use #passedCount"

	^self passedCount
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
defects
	^OrderedCollection new
		addAll: self errors;
		addAll: self failures; yourself
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
errorCount

	^self errors size
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
errors

	errors isNil
		ifTrue: [errors := OrderedCollection new].
	^errors
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
failureCount

	^self failures size
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
failures
	failures isNil
		ifTrue: [failures := Set new].
	^failures
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
hasErrors

	^self errors size > 0
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
hasFailures

	^self failures size > 0
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
hasPassed

	^self hasErrors not and: [self hasFailures not]
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Init / Release' !
initialize
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
isError: aTestCase

	^self errors includes: aTestCase
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
isFailure: aTestCase
	^self failures includes: aTestCase
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
isPassed: aTestCase

	^self passed includes: aTestCase
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
passed

	passed isNil
		ifTrue: [passed := OrderedCollection new].

	^passed
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
passedCount

	^self passed size
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Printing' !
printOn: aStream

	aStream
		nextPutAll: self runCount printString;
		nextPutAll: ' run, ';
		nextPutAll: self correctCount printString;
		nextPutAll: ' passed, ';
		nextPutAll: self failureCount printString;
		nextPutAll: ' failed, ';
		nextPutAll: self errorCount printString;
		nextPutAll: ' error'.

	self errorCount ~= 1
		ifTrue: [aStream nextPut: $s]
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[
			[
				aTestCase runCase.
				true]
					sunitOn: self class failure
					do: [:signal |
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
								self errors add: aTestCase.
								signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
runCount

	^self passedCount + self failureCount + self errorCount
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
tests

	^(OrderedCollection new: self runCount)
		addAll: self passed;
		addAll: self errors;
		addAll: self failures;
		yourself
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Dependencies' !
addDependentToHierachy: anObject
	self sunitAddDependent: anObject.
	self tests do: [ :each | each addDependentToHierachy: anObject]
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
addTest: aTest
	self tests add: aTest
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
addTests: aCollection 
	aCollection do: [:eachTest | self addTest: eachTest]
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
defaultResources
	^self tests 
		inject: Set new
		into: [:coll :testCase | 
			coll
				addAll: testCase resources;
				yourself]
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
name

	^name
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
name: aString

	name := aString
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Dependencies' !
removeDependentFromHierachy: anObject
	self sunitRemoveDependent: anObject.
	self tests do: [ :each | each removeDependentFromHierachy: anObject]
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
resources
	resources isNil ifTrue: [resources := self defaultResources].
	^resources
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
resources: anObject
	resources := anObject
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Running' !
run
	| result |
 	result := TestResult new.
	self resources do: [ :res |
		res isAvailable ifFalse: [^res signalInitializationError]].
	[self run: result] sunitEnsure: [self resources do: [:each | each reset]].
	^result
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Running' !
run: aResult 
	self tests do: [:each | 
		self sunitChanged: each.
		each run: aResult]
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
tests
	tests isNil ifTrue: [tests := OrderedCollection new].
	^tests
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Accessing' !
allTestSelectors

	^self sunitAllSelectors select: [:each | 'test*' sunitMatch: each]
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
buildSuite
	| suite |
	^self isAbstract
		ifTrue: 
			[suite := self suiteClass named: self name asString.
			self allSubclasses 
				do: [:each | each isAbstract ifFalse: [suite addTest: each buildSuiteFromSelectors]].
			suite]
		ifFalse: [self buildSuiteFromSelectors]
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
buildSuiteFromAllSelectors

	^self buildSuiteFromMethods: self allTestSelectors
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
buildSuiteFromLocalSelectors

	^self buildSuiteFromMethods: self testSelectors
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
buildSuiteFromMethods: testMethods

	^testMethods
		inject: (self suiteClass named: self name asString)
		into: [:suite :selector |
			suite
				addTest: (self selector: selector);
				yourself]
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
buildSuiteFromSelectors

	^self shouldInheritSelectors
		ifTrue: [self buildSuiteFromAllSelectors]
		ifFalse: [self buildSuiteFromLocalSelectors]
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Instance Creation' !
debug: aSymbol

	^(self selector: aSymbol) debug
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Testing' !
isAbstract
	"Override to true if a TestCase subclass is Abstract and should not have
	TestCase instances built from it"

	^self sunitName = #TestCase
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Accessing' !
resources

	^#()
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Instance Creation' !
run: aSymbol

	^(self selector: aSymbol) run
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Instance Creation' !
selector: aSymbol

	^self new setTestSelector: aSymbol
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Testing' !
shouldInheritSelectors
	"I should inherit from an Abstract superclass but not from a concrete one by default, unless I have no testSelectors in which case I must be expecting to inherit them from my superclass.  If a test case with selectors wants to inherit selectors from a concrete superclass, override this to true in that subclass."

	^self superclass isAbstract
		or: [self testSelectors isEmpty]

"$QA Ignore:Sends system method(superclass)$"
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Instance Creation' !
suite

	^self buildSuite
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
suiteClass
	^TestSuite
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Accessing' !
testSelectors

	^self sunitSelectors select: [:each | 'test*' sunitMatch: each]
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Accessing' !
sunitVersion
	^'3.1'
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Accessing' !
currentDictionary

	CurrentDictionary isNil
		ifTrue: [CurrentDictionary := Dictionary new].

	^CurrentDictionary
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Accessing' !
current

	^self currentDictionary
		at: self
		ifPresent: [:current|]
		ifAbsentPut: [self new].

			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Accessing' !
current: aTestResource

	self currentDictionary
		at: self
		put: aTestResource
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Testing' !
isAbstract
	"Override to true if a TestResource subclass is Abstract and should not have
	TestCase instances built from it"

	^self sunitName = #TestResource
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Testing' !
isAvailable
	^self current notNil and: [self current isAvailable]
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Testing' !
isUnavailable

	^self isAvailable not
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Creation' !
new

	^super new initialize
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Creation' !
reset
	|current|
	current := self currentDictionary
		at: self
		ifAbsent: [^nil].
	[current tearDown] ensure: [
		self current: nil]
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Accessing' !
resources
	^#()
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Creation' !
signalInitializationError
	^TestResult signalErrorWith: 'Resource ' , self name , ' could not be initialized'
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResult) classSide methodsFor: 'Exceptions' !
error
	^self exError
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResult) classSide methodsFor: 'Exceptions' !
exError
	^SUnitNameResolver errorObject
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResult) classSide methodsFor: 'Exceptions' !
failure
	^TestFailure
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResult) classSide methodsFor: 'Init / Release' !
new
	^super new initialize
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResult) classSide methodsFor: 'Exceptions' !
resumableFailure
	^ResumableTestFailure
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResult) classSide methodsFor: 'Exceptions' !
signalErrorWith: aString 
	self error sunitSignalWith: aString
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResult) classSide methodsFor: 'Exceptions' !
signalFailureWith: aString 
	self failure sunitSignalWith: aString
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestSuite) classSide methodsFor: 'Creation' !
named: aString

	^self new
		name: aString;
		yourself
			! !

"May 18, 2008 -> 7:32:49"!

! (Delta mirrorFor: #Class) methodsFor: 'file-in compatibility' !
subclass: clsName <Symbol>
instanceVariableNames: iVars <Str>
classVariableNames: cVars <Str>
poolDictionaries: pVars <Str>
category: cat <Str>
^<Class>

	| mirror <ClassMirror> |
	[ pVars isEmpty ] verify.
	mirror := Class subclassOf: self name instanceVariables: iVars.
	mirror classVariables: cVars.
	Delta define: clsName as: mirror.
	^mirror reflectee! !

"May 18, 2008 -> 7:34:24"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:24"!

(Delta mirrorFor: #TestCase)
comment: 
'A TestCase is a Command representing the future running of a test case. Create one with the class method #selector: aSymbol, passing the name of the method to be run when the test case runs.

When you discover a new fixture, subclass TestCase, declare instance variables for the objects in the fixture, override #setUp to initialize the variables, and possibly override# tearDown to deallocate any external resources allocated in #setUp.

When you are writing a test case method, send #assert: aBoolean when you want to check for an expected value. For example, you might say "self assert: socket isOpen" to test whether or not a socket is open at a point in a test.'!


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:24"!

(Delta mirrorFor: #TestResult)
comment: 
'This is a Collecting Parameter for the running of a bunch of tests. TestResult is an interesting object to subclass or substitute. #runCase: is the external protocol you need to reproduce. Kent has seen TestResults that recorded coverage information and that sent email when they were done.'!


"May 18, 2008 -> 7:34:24"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:24"!

(Delta mirrorFor: #TestSuite)
comment: 
'This is a Composite of Tests, either TestCases or other TestSuites. The common protocol is #run: aTestResult and the dependencies protocol'!


"May 18, 2008 -> 7:34:24"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Dependencies' !
addDependentToHierachy: anObject 
	"an empty method. for Composite compability with TestSuite"


			! !

"May 18, 2008 -> 7:34:24"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
assert: aBoolean

	aBoolean ifFalse: [self signalFailure: 'Assertion failed']
			! !

"May 18, 2008 -> 7:34:24"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
assert: aBoolean description: aString
	aBoolean ifFalse: [
		self logFailure: aString.
		TestResult failure sunitSignalWith: aString]
			! !

"May 18, 2008 -> 7:34:24"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
assert: aBoolean description: aString resumable: resumableBoolean 
	| exception |
	aBoolean
		ifFalse: 
			[self logFailure: aString.
			exception := resumableBoolean
						ifTrue: [TestResult resumableFailure]
						ifFalse: [TestResult failure].
			exception sunitSignalWith: aString]
			! !

"May 18, 2008 -> 7:34:24"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
debug
	self resources do: [:res | 
		res isAvailable ifFalse: [^res signalInitializationError]].
	[(self class selector: testSelector) runCase] 
		sunitEnsure: [self resources do: [:each | each reset]]
			! !

"May 18, 2008 -> 7:34:24"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
debugAsFailure
	| semaphore |
	semaphore := Semaphore new.
	self resources do: [:res | 
		res isAvailable ifFalse: [^res signalInitializationError]].
	[semaphore wait. self resources do: [:each | each reset]] fork.
	(self class selector: testSelector) runCaseAsFailure: semaphore.

			! !

"May 18, 2008 -> 7:34:24"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
deny: aBoolean

	self assert: aBoolean not
			! !

"May 18, 2008 -> 7:34:24"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
deny: aBoolean description: aString
	self assert: aBoolean not description: aString
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
deny: aBoolean description: aString resumable: resumableBoolean 
	self
		assert: aBoolean not
		description: aString
		resumable: resumableBoolean
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Private' !
executeShould: aBlock inScopeOf: anExceptionalEvent 
	^[aBlock value.
 	false] sunitOn: anExceptionalEvent
		do: [:ex | ex sunitExitWith: true]
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
failureLog	
	^SUnitNameResolver defaultLogDevice

			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
isLogging
	"By default, we're not logging failures. If you override this in 
	a subclass, make sure that you override #failureLog"
	^false
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
logFailure: aString
	self isLogging ifTrue: [
		self failureLog 
			cr; 
			nextPutAll: aString; 
			flush]
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
openDebuggerOnFailingTestMethod
	"SUnit has halted one step in front of the failing test method. Step over the 'self halt' and 
	 send into 'self perform: testSelector' to see the failure from the beginning"

	self
		halt;
		performTest
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Private' !
performTest

	self perform: testSelector sunitAsSymbol
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Printing' !
printOn: aStream

	aStream
		nextPutAll: self class printString;
		nextPutAll: '>>#';
		nextPutAll: testSelector
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Dependencies' !
removeDependentFromHierachy: anObject 
	"an empty method. for Composite compability with TestSuite"


			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
resources
	| allResources resourceQueue |
	allResources := Set new.
	resourceQueue := OrderedCollection new.
	resourceQueue addAll: self class resources.
	[resourceQueue isEmpty] whileFalse: [
		| next |
		next := resourceQueue removeFirst.
		allResources add: next.
		resourceQueue addAll: next resources].
	^allResources
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
run
	| result |
	result := TestResult new.
	self run: result.
	^result
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
run: aResult
	aResult runCase: self
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
runCase

	[self setUp.
	self performTest] sunitEnsure: [self tearDown]
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
runCaseAsFailure: aSemaphore
	[self setUp.
	self openDebuggerOnFailingTestMethod] sunitEnsure: [
		self tearDown.
		aSemaphore signal]
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
selector
	^testSelector
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Private' !
setTestSelector: aSymbol
	testSelector := aSymbol
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
setUp
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
should: aBlock
	self assert: aBlock value
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
should: aBlock description: aString
	self assert: aBlock value description: aString
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
should: aBlock raise: anExceptionalEvent 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent)
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
should: aBlock raise: anExceptionalEvent description: aString 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent)
		description: aString
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
shouldnt: aBlock
	self deny: aBlock value
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
shouldnt: aBlock description: aString
	self deny: aBlock value description: aString
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
shouldnt: aBlock raise: anExceptionalEvent 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent) not
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
shouldnt: aBlock raise: anExceptionalEvent description: aString 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent) not 		description: aString
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
signalFailure: aString
	TestResult failure sunitSignalWith: aString! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
tearDown
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Accessing' !
description

	description isNil
		ifTrue: [^''].

	^description
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Accessing' !
description: aString

	description := aString
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Init / Release' !
initialize
	self setUp

			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Testing' !
isAvailable
	"override to provide information on the
	readiness of the resource"
	
	^true
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Testing' !
isUnavailable
	"override to provide information on the
	readiness of the resource"
	
	^self isAvailable not
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Accessing' !
name

	name isNil
		ifTrue: [^self printString].

	^name
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Accessing' !
name: aString

	name := aString
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Printing' !
printOn: aStream

	aStream nextPutAll: self class printString
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Accessing' !
resources
	^self class resources
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Running' !
setUp
	"Does nothing. Subclasses should override this
	to initialize their resource"
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Running' !
signalInitializationError
	^self class signalInitializationError
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Running' !
tearDown
	"Does nothing. Subclasses should override this
	to tear down their resource"
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
correctCount
	"depreciated - use #passedCount"

	^self passedCount
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
defects
	^OrderedCollection new
		addAll: self errors;
		addAll: self failures; yourself
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
errorCount

	^self errors size
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
errors

	errors isNil
		ifTrue: [errors := OrderedCollection new].
	^errors
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
failureCount

	^self failures size
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
failures
	failures isNil
		ifTrue: [failures := Set new].
	^failures
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
hasErrors

	^self errors size > 0
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
hasFailures

	^self failures size > 0
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
hasPassed

	^self hasErrors not and: [self hasFailures not]
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Init / Release' !
initialize
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
isError: aTestCase

	^self errors includes: aTestCase
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
isFailure: aTestCase
	^self failures includes: aTestCase
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
isPassed: aTestCase

	^self passed includes: aTestCase
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
passed

	passed isNil
		ifTrue: [passed := OrderedCollection new].

	^passed
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
passedCount

	^self passed size
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Printing' !
printOn: aStream

	aStream
		nextPutAll: self runCount printString;
		nextPutAll: ' run, ';
		nextPutAll: self correctCount printString;
		nextPutAll: ' passed, ';
		nextPutAll: self failureCount printString;
		nextPutAll: ' failed, ';
		nextPutAll: self errorCount printString;
		nextPutAll: ' error'.

	self errorCount ~= 1
		ifTrue: [aStream nextPut: $s]
			! !

"May 18, 2008 -> 7:34:52"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:52"!

(Delta mirrorFor: #TestCase)
comment: 
'A TestCase is a Command representing the future running of a test case. Create one with the class method #selector: aSymbol, passing the name of the method to be run when the test case runs.

When you discover a new fixture, subclass TestCase, declare instance variables for the objects in the fixture, override #setUp to initialize the variables, and possibly override# tearDown to deallocate any external resources allocated in #setUp.

When you are writing a test case method, send #assert: aBoolean when you want to check for an expected value. For example, you might say "self assert: socket isOpen" to test whether or not a socket is open at a point in a test.'!


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:52"!

(Delta mirrorFor: #TestResult)
comment: 
'This is a Collecting Parameter for the running of a bunch of tests. TestResult is an interesting object to subclass or substitute. #runCase: is the external protocol you need to reproduce. Kent has seen TestResults that recorded coverage information and that sent email when they were done.'!


"May 18, 2008 -> 7:34:52"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:52"!

(Delta mirrorFor: #TestSuite)
comment: 
'This is a Composite of Tests, either TestCases or other TestSuites. The common protocol is #run: aTestResult and the dependencies protocol'!


"May 18, 2008 -> 7:34:52"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Dependencies' !
addDependentToHierachy: anObject 
	"an empty method. for Composite compability with TestSuite"


			! !

"May 18, 2008 -> 7:34:52"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
assert: aBoolean

	aBoolean ifFalse: [self signalFailure: 'Assertion failed']
			! !

"May 18, 2008 -> 7:34:52"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
assert: aBoolean description: aString
	aBoolean ifFalse: [
		self logFailure: aString.
		TestResult failure sunitSignalWith: aString]
			! !

"May 18, 2008 -> 7:34:52"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
assert: aBoolean description: aString resumable: resumableBoolean 
	| exception |
	aBoolean
		ifFalse: 
			[self logFailure: aString.
			exception := resumableBoolean
						ifTrue: [TestResult resumableFailure]
						ifFalse: [TestResult failure].
			exception sunitSignalWith: aString]
			! !

"May 18, 2008 -> 7:34:52"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
debug
	self resources do: [:res | 
		res isAvailable ifFalse: [^res signalInitializationError]].
	[(self class selector: testSelector) runCase] 
		sunitEnsure: [self resources do: [:each | each reset]]
			! !

"May 18, 2008 -> 7:34:52"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
debugAsFailure
	| semaphore |
	semaphore := Semaphore new.
	self resources do: [:res | 
		res isAvailable ifFalse: [^res signalInitializationError]].
	[semaphore wait. self resources do: [:each | each reset]] fork.
	(self class selector: testSelector) runCaseAsFailure: semaphore.

			! !

"May 18, 2008 -> 7:34:52"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
deny: aBoolean

	self assert: aBoolean not
			! !

"May 18, 2008 -> 7:34:52"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
deny: aBoolean description: aString
	self assert: aBoolean not description: aString
			! !

"May 18, 2008 -> 7:34:52"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
deny: aBoolean description: aString resumable: resumableBoolean 
	self
		assert: aBoolean not
		description: aString
		resumable: resumableBoolean
			! !

"May 18, 2008 -> 7:35:7"!

"System saved" !
"May 18, 2008 -> 7:35:45"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:35:45"!

(Delta mirrorFor: #TestCase)
comment: 
'A TestCase is a Command representing the future running of a test case. Create one with the class method #selector: aSymbol, passing the name of the method to be run when the test case runs.

When you discover a new fixture, subclass TestCase, declare instance variables for the objects in the fixture, override #setUp to initialize the variables, and possibly override# tearDown to deallocate any external resources allocated in #setUp.

When you are writing a test case method, send #assert: aBoolean when you want to check for an expected value. For example, you might say "self assert: socket isOpen" to test whether or not a socket is open at a point in a test.'!


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:35:45"!

(Delta mirrorFor: #TestResult)
comment: 
'This is a Collecting Parameter for the running of a bunch of tests. TestResult is an interesting object to subclass or substitute. #runCase: is the external protocol you need to reproduce. Kent has seen TestResults that recorded coverage information and that sent email when they were done.'!


"May 18, 2008 -> 7:35:46"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:35:46"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:35:46"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:35:46"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:35:46"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:35:46"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:35:46"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:35:46"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:35:46"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:35:46"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:35:46"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:35:46"!

(Delta mirrorFor: #TestSuite)
comment: 
'This is a Composite of Tests, either TestCases or other TestSuites. The common protocol is #run: aTestResult and the dependencies protocol'!


"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Dependencies' !
addDependentToHierachy: anObject 
	"an empty method. for Composite compability with TestSuite"


			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
assert: aBoolean

	aBoolean ifFalse: [self signalFailure: 'Assertion failed']
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
assert: aBoolean description: aString
	aBoolean ifFalse: [
		self logFailure: aString.
		TestResult failure sunitSignalWith: aString]
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
assert: aBoolean description: aString resumable: resumableBoolean 
	| exception |
	aBoolean
		ifFalse: 
			[self logFailure: aString.
			exception := resumableBoolean
						ifTrue: [TestResult resumableFailure]
						ifFalse: [TestResult failure].
			exception sunitSignalWith: aString]
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
debug
	self resources do: [:res | 
		res isAvailable ifFalse: [^res signalInitializationError]].
	[(self class selector: testSelector) runCase] 
		sunitEnsure: [self resources do: [:each | each reset]]
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
debugAsFailure
	| semaphore |
	semaphore := Semaphore new.
	self resources do: [:res | 
		res isAvailable ifFalse: [^res signalInitializationError]].
	[semaphore wait. self resources do: [:each | each reset]] fork.
	(self class selector: testSelector) runCaseAsFailure: semaphore.

			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
deny: aBoolean

	self assert: aBoolean not
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
deny: aBoolean description: aString
	self assert: aBoolean not description: aString
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
deny: aBoolean description: aString resumable: resumableBoolean 
	self
		assert: aBoolean not
		description: aString
		resumable: resumableBoolean
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Private' !
executeShould: aBlock inScopeOf: anExceptionalEvent 
	^[aBlock value.
 	false] sunitOn: anExceptionalEvent
		do: [:ex | ex sunitExitWith: true]
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
failureLog	
	^SUnitNameResolver defaultLogDevice

			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
isLogging
	"By default, we're not logging failures. If you override this in 
	a subclass, make sure that you override #failureLog"
	^false
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
logFailure: aString
	self isLogging ifTrue: [
		self failureLog 
			cr; 
			nextPutAll: aString; 
			flush]
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
openDebuggerOnFailingTestMethod
	"SUnit has halted one step in front of the failing test method. Step over the 'self halt' and 
	 send into 'self perform: testSelector' to see the failure from the beginning"

	self
		halt;
		performTest
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Private' !
performTest

	self perform: testSelector sunitAsSymbol
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Printing' !
printOn: aStream

	aStream
		nextPutAll: self class printString;
		nextPutAll: '>>#';
		nextPutAll: testSelector
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Dependencies' !
removeDependentFromHierachy: anObject 
	"an empty method. for Composite compability with TestSuite"


			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
resources
	| allResources resourceQueue |
	allResources := Set new.
	resourceQueue := OrderedCollection new.
	resourceQueue addAll: self class resources.
	[resourceQueue isEmpty] whileFalse: [
		| next |
		next := resourceQueue removeFirst.
		allResources add: next.
		resourceQueue addAll: next resources].
	^allResources
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
run
	| result |
	result := TestResult new.
	self run: result.
	^result
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
run: aResult
	aResult runCase: self
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
runCase

	[self setUp.
	self performTest] sunitEnsure: [self tearDown]
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
runCaseAsFailure: aSemaphore
	[self setUp.
	self openDebuggerOnFailingTestMethod] sunitEnsure: [
		self tearDown.
		aSemaphore signal]
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
selector
	^testSelector
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Private' !
setTestSelector: aSymbol
	testSelector := aSymbol
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
setUp
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
should: aBlock
	self assert: aBlock value
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
should: aBlock description: aString
	self assert: aBlock value description: aString
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
should: aBlock raise: anExceptionalEvent 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent)
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
should: aBlock raise: anExceptionalEvent description: aString 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent)
		description: aString
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
shouldnt: aBlock
	self deny: aBlock value
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
shouldnt: aBlock description: aString
	self deny: aBlock value description: aString
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
shouldnt: aBlock raise: anExceptionalEvent 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent) not
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
shouldnt: aBlock raise: anExceptionalEvent description: aString 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent) not 		description: aString
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
signalFailure: aString
	TestResult failure sunitSignalWith: aString! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
tearDown
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Accessing' !
description

	description isNil
		ifTrue: [^''].

	^description
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Accessing' !
description: aString

	description := aString
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Init / Release' !
initialize
	self setUp

			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Testing' !
isAvailable
	"override to provide information on the
	readiness of the resource"
	
	^true
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Testing' !
isUnavailable
	"override to provide information on the
	readiness of the resource"
	
	^self isAvailable not
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Accessing' !
name

	name isNil
		ifTrue: [^self printString].

	^name
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Accessing' !
name: aString

	name := aString
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Printing' !
printOn: aStream

	aStream nextPutAll: self class printString
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Accessing' !
resources
	^self class resources
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Running' !
setUp
	"Does nothing. Subclasses should override this
	to initialize their resource"
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Running' !
signalInitializationError
	^self class signalInitializationError
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Running' !
tearDown
	"Does nothing. Subclasses should override this
	to tear down their resource"
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
correctCount
	"depreciated - use #passedCount"

	^self passedCount
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
defects
	^OrderedCollection new
		addAll: self errors;
		addAll: self failures; yourself
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
errorCount

	^self errors size
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
errors

	errors isNil
		ifTrue: [errors := OrderedCollection new].
	^errors
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
failureCount

	^self failures size
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
failures
	failures isNil
		ifTrue: [failures := Set new].
	^failures
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
hasErrors

	^self errors size > 0
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
hasFailures

	^self failures size > 0
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
hasPassed

	^self hasErrors not and: [self hasFailures not]
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Init / Release' !
initialize
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
isError: aTestCase

	^self errors includes: aTestCase
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
isFailure: aTestCase
	^self failures includes: aTestCase
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
isPassed: aTestCase

	^self passed includes: aTestCase
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
passed

	passed isNil
		ifTrue: [passed := OrderedCollection new].

	^passed
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
passedCount

	^self passed size
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Printing' !
printOn: aStream

	aStream
		nextPutAll: self runCount printString;
		nextPutAll: ' run, ';
		nextPutAll: self correctCount printString;
		nextPutAll: ' passed, ';
		nextPutAll: self failureCount printString;
		nextPutAll: ' failed, ';
		nextPutAll: self errorCount printString;
		nextPutAll: ' error'.

	self errorCount ~= 1
		ifTrue: [aStream nextPut: $s]
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[
			[
				aTestCase runCase.
				true]
					sunitOn: self class failure
					do: [:signal |
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
								self errors add: aTestCase.
								signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
runCount

	^self passedCount + self failureCount + self errorCount
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
tests

	^(OrderedCollection new: self runCount)
		addAll: self passed;
		addAll: self errors;
		addAll: self failures;
		yourself
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Dependencies' !
addDependentToHierachy: anObject
	self sunitAddDependent: anObject.
	self tests do: [ :each | each addDependentToHierachy: anObject]
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
addTest: aTest
	self tests add: aTest
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
addTests: aCollection 
	aCollection do: [:eachTest | self addTest: eachTest]
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
defaultResources
	^self tests 
		inject: Set new
		into: [:coll :testCase | 
			coll
				addAll: testCase resources;
				yourself]
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
name

	^name
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
name: aString

	name := aString
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Dependencies' !
removeDependentFromHierachy: anObject
	self sunitRemoveDependent: anObject.
	self tests do: [ :each | each removeDependentFromHierachy: anObject]
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
resources
	resources isNil ifTrue: [resources := self defaultResources].
	^resources
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
resources: anObject
	resources := anObject
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Running' !
run
	| result |
 	result := TestResult new.
	self resources do: [ :res |
		res isAvailable ifFalse: [^res signalInitializationError]].
	[self run: result] sunitEnsure: [self resources do: [:each | each reset]].
	^result
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Running' !
run: aResult 
	self tests do: [:each | 
		self sunitChanged: each.
		each run: aResult]
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
tests
	tests isNil ifTrue: [tests := OrderedCollection new].
	^tests
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Accessing' !
allTestSelectors

	^self sunitAllSelectors select: [:each | 'test*' sunitMatch: each]
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
buildSuite
	| suite |
	^self isAbstract
		ifTrue: 
			[suite := self suiteClass named: self name asString.
			self allSubclasses 
				do: [:each | each isAbstract ifFalse: [suite addTest: each buildSuiteFromSelectors]].
			suite]
		ifFalse: [self buildSuiteFromSelectors]
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
buildSuiteFromAllSelectors

	^self buildSuiteFromMethods: self allTestSelectors
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
buildSuiteFromLocalSelectors

	^self buildSuiteFromMethods: self testSelectors
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
buildSuiteFromMethods: testMethods

	^testMethods
		inject: (self suiteClass named: self name asString)
		into: [:suite :selector |
			suite
				addTest: (self selector: selector);
				yourself]
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
buildSuiteFromSelectors

	^self shouldInheritSelectors
		ifTrue: [self buildSuiteFromAllSelectors]
		ifFalse: [self buildSuiteFromLocalSelectors]
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Instance Creation' !
debug: aSymbol

	^(self selector: aSymbol) debug
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Testing' !
isAbstract
	"Override to true if a TestCase subclass is Abstract and should not have
	TestCase instances built from it"

	^self sunitName = #TestCase
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Accessing' !
resources

	^#()
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Instance Creation' !
run: aSymbol

	^(self selector: aSymbol) run
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Instance Creation' !
selector: aSymbol

	^self new setTestSelector: aSymbol
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Testing' !
shouldInheritSelectors
	"I should inherit from an Abstract superclass but not from a concrete one by default, unless I have no testSelectors in which case I must be expecting to inherit them from my superclass.  If a test case with selectors wants to inherit selectors from a concrete superclass, override this to true in that subclass."

	^self superclass isAbstract
		or: [self testSelectors isEmpty]

"$QA Ignore:Sends system method(superclass)$"
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Instance Creation' !
suite

	^self buildSuite
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
suiteClass
	^TestSuite
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Accessing' !
testSelectors

	^self sunitSelectors select: [:each | 'test*' sunitMatch: each]
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Accessing' !
sunitVersion
	^'3.1'
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Accessing' !
currentDictionary

	CurrentDictionary isNil
		ifTrue: [CurrentDictionary := Dictionary new].

	^CurrentDictionary
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Accessing' !
current

	^self currentDictionary
		at: self
		ifPresent: [:current|]
		ifAbsentPut: [self new].

			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Accessing' !
current: aTestResource

	self currentDictionary
		at: self
		put: aTestResource
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Testing' !
isAbstract
	"Override to true if a TestResource subclass is Abstract and should not have
	TestCase instances built from it"

	^self sunitName = #TestResource
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Testing' !
isAvailable
	^self current notNil and: [self current isAvailable]
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Testing' !
isUnavailable

	^self isAvailable not
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Creation' !
new

	^super new initialize
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Creation' !
reset
	|current|
	current := self currentDictionary
		at: self
		ifAbsent: [^nil].
	[current tearDown] ensure: [
		self current: nil]
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Accessing' !
resources
	^#()
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Creation' !
signalInitializationError
	^TestResult signalErrorWith: 'Resource ' , self name , ' could not be initialized'
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResult) classSide methodsFor: 'Exceptions' !
error
	^self exError
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResult) classSide methodsFor: 'Exceptions' !
exError
	^SUnitNameResolver errorObject
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResult) classSide methodsFor: 'Exceptions' !
failure
	^TestFailure
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResult) classSide methodsFor: 'Init / Release' !
new
	^super new initialize
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResult) classSide methodsFor: 'Exceptions' !
resumableFailure
	^ResumableTestFailure
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResult) classSide methodsFor: 'Exceptions' !
signalErrorWith: aString 
	self error sunitSignalWith: aString
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResult) classSide methodsFor: 'Exceptions' !
signalFailureWith: aString 
	self failure sunitSignalWith: aString
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestSuite) classSide methodsFor: 'Creation' !
named: aString

	^self new
		name: aString;
		yourself
			! !

"May 18, 2008 -> 7:36:43"!

"System saved" !
"May 18, 2008 -> 7:36:56"!

Delta define: #ExampleSetTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'full empty')) !


"May 18, 2008 -> 7:36:56"!

Delta define: #ResumableTestFailureTestCase as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"May 18, 2008 -> 7:36:56"!

Delta define: #SimpleTestResourceTestCase as: (
(Class subclassOf: 'TestCase' instanceVariables: 'resource')) !


"May 18, 2008 -> 7:36:56"!

Delta define: #SUnitTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'hasRun hasSetup hasRanOnce')) !


"May 18, 2008 -> 7:36:56"!

(Delta mirrorFor: #SUnitTest)
comment: 
'This is both an example of writing tests and a self test for the SUnit. The tests 
here are pretty strange, since you want to make sure things blow up. You should 
not generally have to write tests this complicated in structure, although they 
will be far more complicated in terms of your own objects- more assertions, more 
complicated setup. Kent says: "Never forget, however, that if the tests are hard 
to write, something is probably wrong with the design".'!


"May 18, 2008 -> 7:36:56"!

Delta define: #SimpleTestResource as: (
(Class subclassOf: 'TestResource' instanceVariables: 'runningState hasRun hasSetup hasRanOnce')) !


"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #ExampleSetTest) methodsFor: 'Running' !
setUp
	empty := Set new.
	full := Set with: 5 with: #abc
			! !

"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #ExampleSetTest) methodsFor: 'Testing' !
testAdd
	empty add: 5.
	self assert: (empty includes: 5)
			! !

"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #ExampleSetTest) methodsFor: 'Testing' !
testGrow
	empty addAll: (1 to: 100).
	self assert: empty size = 100
			! !

"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #ExampleSetTest) methodsFor: 'Testing' !
testIllegal
	self 
		should: [empty at: 5] 
		raise: TestResult error.
	self 
		should: [empty at: 5 put: #abc] 
		raise: TestResult error
			! !

"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #ExampleSetTest) methodsFor: 'Testing' !
testIncludes
	self assert: (full includes: 5).
	self assert: (full includes: #abc)
			! !

"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #ExampleSetTest) methodsFor: 'Testing' !
testOccurrences
	self assert: (empty occurrencesOf: 0) = 0.
	self assert: (full occurrencesOf: 5) = 1.
	full add: 5.
	self assert: (full occurrencesOf: 5) = 1
			! !

"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #ExampleSetTest) methodsFor: 'Testing' !
testRemove
	full remove: 5.
	self assert: (full includes: #abc).
	self deny: (full includes: 5)
			! !

"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #ResumableTestFailureTestCase) methodsFor: 'Not categorized' !
errorTest
	1 zork
			! !

"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #ResumableTestFailureTestCase) methodsFor: 'Not categorized' !
failureLog
	^SUnitNameResolver defaultLogDevice
			! !

"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #ResumableTestFailureTestCase) methodsFor: 'Not categorized' !
failureTest
	self
		assert: false description: 'You should see me' resumable: true; 
		assert: false description: 'You should see me too' resumable: true; 
		assert: false description: 'You should see me last' resumable: false; 
		assert: false description: 'You should not see me' resumable: true
			! !

"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #ResumableTestFailureTestCase) methodsFor: 'Not categorized' !
isLogging
	^false
			! !

"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #ResumableTestFailureTestCase) methodsFor: 'Not categorized' !
okTest
	self assert: true
			! !

"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #ResumableTestFailureTestCase) methodsFor: 'Not categorized' !
regularTestFailureTest
	self assert: false description: 'You should see me'
			! !

"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #ResumableTestFailureTestCase) methodsFor: 'Not categorized' !
resumableTestFailureTest
	self
		assert: false description: 'You should see me' resumable: true; 
		assert: false description: 'You should see me too' resumable: true; 
		assert: false description: 'You should see me last' resumable: false; 
		assert: false description: 'You should not see me' resumable: true
			! !

"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #ResumableTestFailureTestCase) methodsFor: 'Not categorized' !
testResumable
	| result suite |
	suite := TestSuite new.
	suite addTest: (self class selector: #errorTest).
	suite addTest: (self class selector: #regularTestFailureTest).
	suite addTest: (self class selector: #resumableTestFailureTest).
	suite addTest: (self class selector: #okTest).
	result := suite run.
	self assert: result failures size = 2;
		assert: result errors size = 1
			! !

"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #SimpleTestResource) methodsFor: 'testing' !
hasRun
	^hasRun
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResource) methodsFor: 'testing' !
hasSetup
	^hasSetup
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResource) methodsFor: 'testing' !
isAvailable
	
	^self runningState == self startedStateSymbol
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResource) methodsFor: 'accessing' !
runningState

	^runningState
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResource) methodsFor: 'accessing' !
runningState: aSymbol

	runningState := aSymbol
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResource) methodsFor: 'running' !
setRun
	hasRun := true
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResource) methodsFor: 'running' !
setUp
	
	self runningState: self startedStateSymbol.
	hasSetup := true
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResource) methodsFor: 'running' !
startedStateSymbol

	^#started
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResource) methodsFor: 'running' !
stoppedStateSymbol

	^#stopped
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResource) methodsFor: 'running' !
tearDown

	self runningState: self stoppedStateSymbol
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResourceTestCase) methodsFor: 'Not categorized' !
dummy
	self assert: true
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResourceTestCase) methodsFor: 'Not categorized' !
error
	'foo' odd
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResourceTestCase) methodsFor: 'Not categorized' !
fail
	self assert: false
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResourceTestCase) methodsFor: 'Not categorized' !
setRun
	resource setRun
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResourceTestCase) methodsFor: 'Not categorized' !
setUp
	resource := SimpleTestResource current
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResourceTestCase) methodsFor: 'Not categorized' !
testRan
	| case |

	case := self class selector: #setRun.
	case run.
	self assert: resource hasSetup.
	self assert: resource hasRun
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResourceTestCase) methodsFor: 'Not categorized' !
testResourceInitRelease
	| result suite error failure |
	suite := TestSuite new.
	suite addTest: (error := self class selector: #error).
	suite addTest: (failure := self class selector: #fail).
	suite addTest: (self class selector: #dummy).
	result := suite run.
	self assert: resource hasSetup
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResourceTestCase) methodsFor: 'Not categorized' !
testResourcesCollection
	| collection |
	collection := self resources.
	self assert: collection size = 1
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Private' !
assertForTestResult: aResult runCount: aRunCount passed: aPassedCount failed: aFailureCount errors: anErrorCount

	self
		assert: aResult runCount = aRunCount;
		assert: aResult passedCount = aPassedCount;
		assert: aResult failureCount = aFailureCount;
		assert: aResult errorCount = anErrorCount
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Private' !
error
	3 zork
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Testing' !
errorShouldntRaise
	self 
		shouldnt: [self someMessageThatIsntUnderstood] 
		raise: SUnitNameResolver notificationObject
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Private' !
fail
	self assert: false
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Accessing' !
hasRun
	^hasRun
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Accessing' !
hasSetup
	^hasSetup
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Private' !
noop
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Private' !
setRun
	hasRun := true
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Running' !
setUp
	hasSetup := true
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Testing' !
testAssert
	self assert: true.
	self deny: false
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Testing' !
testDefects
	| result suite error failure |
	suite := TestSuite new.
	suite addTest: (error := self class selector: #error).
	suite addTest: (failure := self class selector: #fail).
	result := suite run.
	self assert: result defects asArray = (Array with: error with: failure).
	self
		assertForTestResult: result
		runCount: 2
		passed: 0
		failed: 1
		errors: 1
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Testing' !
testDialectLocalizedException

	self
		should: [TestResult signalFailureWith: 'Foo']
		raise: TestResult failure.
	self
		should: [TestResult signalErrorWith: 'Foo']
		raise: TestResult error.

			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Testing' !
testError

	| case result |

	case := self class selector: #error.
	result := case run.
	self
		assertForTestResult: result
		runCount: 1
		passed: 0
		failed: 0
		errors: 1.

	case := self class selector: #errorShouldntRaise.
	result := case run.
	self 
		assertForTestResult: result
		runCount: 1
		passed: 0
		failed: 0
		errors: 1
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Testing' !
testException

	self
		should: [self error: 'foo']
		raise: TestResult error
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Testing' !
testFail

	| case result |

	case := self class selector: #fail.
	result := case run.

	self
		assertForTestResult: result
		runCount: 1
		passed: 0
		failed: 1
		errors: 0
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Testing' !
testIsNotRerunOnDebug

	| case |

	case := self class selector: #testRanOnlyOnce.
	case run.
	case debug
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Testing' !
testRan

	| case |

	case := self class selector: #setRun.
	case run.
	self assert: case hasSetup.
	self assert: case hasRun
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Testing' !
testRanOnlyOnce

	self assert: hasRanOnce ~= true.
	hasRanOnce := true
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Testing' !
testResult

	| case result |

	case := self class selector: #noop.
	result := case run.

	self
		assertForTestResult: result
		runCount: 1
		passed: 1
		failed: 0
		errors: 0
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Testing' !
testRunning

	(SUnitDelay forSeconds: 2) wait
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Testing' !
testShould

	self
		should: [true];
		shouldnt: [false]
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Testing' !
testSuite

	| suite result |

	suite := TestSuite new.
	suite 
		addTest: (self class selector: #noop);
		addTest: (self class selector: #fail);
		addTest: (self class selector: #error).

	result := suite run.

	self
		assertForTestResult: result
		runCount: 3
		passed: 1
		failed: 1
		errors: 1
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResourceTestCase) classSide methodsFor: 'Not categorized' !
resources
	^Set new add: SimpleTestResource; yourself
			! !

"May 18, 2008 -> 7:37:18"!

"System saved" !
"May 18, 2008 -> 7:42:28"!

! (Delta mirrorFor: #Behavior) methodsFor: 'Camp Smalltalk' !
selectors

	|selectors|
	selectors := Set new.
	(ClassMirror on: self)
		methodsDo: [:method| selectors add: method selector asString].
	^selectors! !

"May 18, 2008 -> 7:43:55"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Accessing' !
allTestSelectors

	^self sunitAllSelectors select: [:each | 'test*' asString sunitMatch: each]
			! !

"May 18, 2008 -> 7:45:6"!

"System saved" !
"May 18, 2008 -> 14:22:54"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestSuite as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestSuite as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestSuite as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestSuite as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestSuite as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestSuite as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestSuite as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestSuite as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestSuite as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestSuite as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestSuite as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 14:23:20"!

"System saved" !
"May 18, 2008 -> 19:15:28"!

! (Delta mirrorFor: #DefinitionWriter) methodsFor: 'Unclassified' !
fileOutHeaderOn: stream <WriteStream> ^ <Int>

	self fileOutDefinition: self mirror definitionString on: stream.
	self fileOutRevision: self mirror revision on: stream.
	self fileOutGroup: self mirror group on: stream.
	self fileOutComment: self mirror comment on: stream.
! !

"May 18, 2008 -> 19:15:28"!

! (Delta mirrorFor: #DefinitionWriter) methodsFor: 'Unclassified' !
fileOutOn: stream <WriteStream> ^ <Int>

	| pos <Int> |
	self assert: [ self mirror isMeta not ].
	pos := stream position.
	self fileOutHeaderOn: stream.
	(self class for: self mirror classSide) fileOutBodyOn: stream.
	self fileOutBodyOn: stream.
	^pos
! !

"May 18, 2008 -> 19:15:28"!

! (Delta mirrorFor: #DefinitionWriter) methodsFor: 'Unclassified' !
fileOutMethodsOn: stream <WriteStream> ^ <Int>

	(self class for: self mirror classSide) fileOutBodyOn: stream.
	self fileOutBodyOn: stream! !

"May 18, 2008 -> 19:15:28"!

! (Delta mirrorFor: #DefinitionWriter) methodsFor: 'Unclassified' !
fileOutOn: stream <WriteStream> ^ <Int>

	| pos <Int> |
	self assert: [ self mirror isMeta not ].
	pos := stream position.
	self fileOutHeaderOn: stream.
	self fileOutMethodsOn: stream.
	^pos
! !

"May 18, 2008 -> 19:41:37"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Accessing' !
testSelectors

	^(self sunitSelectors 
		select: [:each | 'test*' sunitMatch: each])
		reject: [:each| each includes: $:]
			! !

"May 18, 2008 -> 19:42:10"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Accessing' !
allTestSelectors

	^(self sunitAllSelectors
		select: [:each | 'test*' asString sunitMatch: each])
		reject: [:each| each includes: $:]! !

"May 18, 2008 -> 19:44:51"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Accessing' !
allTestSelectors

	^(self sunitAllSelectors
		select: [:each | 'test*' sunitMatch: each])
		reject: [:each| each includes: $:]! !

"May 18, 2008 -> 19:46:20"!

! (Delta mirrorFor: #ReadString) methodsFor: 'Camp Smalltalk' !
sunitMatch: aString
 
        ^self match: aString! !

"May 18, 2008 -> 19:46:20"!

! (Delta mirrorFor: #ReadString) methodsFor: 'Camp Smalltalk' !
sunitSubStrings
 
        ^self substrings! !

"May 18, 2008 -> 19:59:43"!

! (Delta mirrorFor: #Class) methodsFor: 'Camp Smalltalk' !
allSubclasses

	^((ClassMirror on: self) subclasses
		collect: [:mirror| mirror reflectee])
		remove: self! !

"May 18, 2008 -> 20:0:5"!

! (Delta mirrorFor: #Class) methodsFor: 'Camp Smalltalk' !
allSubclasses

	^((ClassMirror on: self) subclasses
		collect: [:mirror| mirror reflectee])
		remove: self;
		yourself! !

"May 18, 2008 -> 20:13:18"!

Delta define: #FileOutSet as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 18, 2008 -> 20:13:47"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'adding' !
addClass: class

	! !

"May 18, 2008 -> 20:14:4"!

Delta define: #FileOutSet as: (
(Class subclassOf: 'Object' instanceVariables: 'classes
classCategories')) !


"May 18, 2008 -> 20:14:48"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'adding' !
initialize

	classes := OrderedCollection new.
	classCategories := Dictionary new! !

"May 18, 2008 -> 20:15:43"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'adding' !
addClass: class

	classes add: class! !

"May 18, 2008 -> 20:15:52"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'initialization' !
initialize

	classes := Set new.
	classCategories := Dictionary new! !

"May 18, 2008 -> 20:18:43"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'adding' !
addClass: class category: category

	(classes includes: class)
		ifTrue: [^self].
	classCategories
		at: class
		ifPresent: [:categories| categories add: category]
		ifAbsentPut: [Set with: category]! !

"May 18, 2008 -> 20:20:54"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
fileOutOn: stream

	self fileOutClassHeadersOn: stream.
	self fileOutClassMethodsOn: stream.
	self fileOutCategoriesOn: stream! !

"May 18, 2008 -> 20:21:49"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
fileOutClassHeadersOn: stream

	classes do: [:class|
		(self definitionWriterFor: class)
			fileOutHeaderOn: stream]! !

"May 18, 2008 -> 20:22:19"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
definitionWriterFor: class

	^(DefinitionWriter for: (ClassMirror on: class))! !

"May 18, 2008 -> 20:23:32"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
fileOutClassMethodsOn: stream

	classes do: [:class|
		(self definitionWriterFor: class)
			fileOutMethodsOn: stream]! !

"May 18, 2008 -> 20:24:28"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
fileOutCategoriesOn: stream

	classCategories keysAndValuesDo: [:class :category|
		(self definitionWriterFor: class)
			fileOutCategory: category on: stream]! !

"May 18, 2008 -> 20:26:59"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'adding' !
addClass: class

	classes add: class.
	classCategories remove: class! !

"May 18, 2008 -> 20:28:7"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'adding' !
addClass: class

	classes add: class.
	classCategories
		removeKey: class
		ifAbsent: []! !

"May 18, 2008 -> 20:31:16"!

! (Delta mirrorFor: #FileOutSet) classSide methodsFor: 'instance creation' !
new

	^(super new)
		initialize;
		yourself! !

"May 18, 2008 -> 20:43:39"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
fileOutCategoriesOn: stream

	classCategories keysAndValuesDo: [:class :categories|
		| definitionWriter |
		definitionWriter := self definitionWriterFor: class.
		categories do: [:category|
			Transcript show: class name, ' ', category.
			definitionWriter fileOutCategory: category on: stream]]! !

"May 18, 2008 -> 20:44:8"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
fileOutCategoriesOn: stream

	classCategories keysAndValuesDo: [:class :categories|
		| definitionWriter |
		definitionWriter := self definitionWriterFor: class.
		categories do: [:category|
			Transcript show: (class name, ' ', category); cr.
			definitionWriter fileOutCategory: category on: stream]]! !

"May 18, 2008 -> 20:45:17"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
fileOutCategoriesOn: stream

	classCategories keysAndValuesDo: [:class :categories|
		| definitionWriter |
		definitionWriter := self definitionWriterFor: class.
		categories do: [:category|
			definitionWriter fileOutCategory: category on: stream]]! !

"May 18, 2008 -> 20:51:49"!

"System saved" !
"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:20:22"!

(Delta mirrorFor: #BlockExceptionSelector)
comment: 
'Determines whether an exception can be handled by evaluating the handlesBlock.'!


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:20:22"!

(Delta mirrorFor: #BlockExceptionHandler)
comment: 
'Exception handler for an exception. Handles the exception by invoking its handleBlock.'!


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:20:22"!

(Delta mirrorFor: #BlockExceptionDescriptor)
comment: 
'Implements the <exceptionDescriptor> protocol from the ANSI standard using configurable actionsdefined as blocks. Intended to be used primarily as a testing aid.'!


"May 19, 2008 -> 4:20:22"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:20:23"!

(Delta mirrorFor: #LinkedExceptionHandler)
comment: 
'Exception handler for an exception. Invokes its handleBlock when asked to handle an exceptionthat matches its exceptionSelector. If the exception does not match its exceptionSelector it passesthe exception on to the nextHandler. If the nextHandler is undefined signal an UnhandledExceptionError.This class is internal to the exception handling framework. There should be no need for code outside of thisframework to interact with instances of ExceptionHandler.'!


"May 19, 2008 -> 4:20:23"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:20:23"!

(Delta mirrorFor: #Exception)
comment: 
'Base class of the exception hierarchy. Implements the core of the ANSI exception handling protocols'!


"May 19, 2008 -> 4:20:23"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

(Delta mirrorFor: #Error)
comment: 
''!


"May 19, 2008 -> 4:20:23"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

(Delta mirrorFor: #Notification)
comment: 
''!


"May 19, 2008 -> 4:20:23"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

(Delta mirrorFor: #MessageNotUnderstood)
comment: 
''!


"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'instantiation' !
handlesBlock: block

	^self new
		handlesBlock: block;
		yourself! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'test' !
test

	self testShouldHandleWhenHandleBlockReturnsTrue;
		testShouldPassExceptionToHandlesBlock! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'test' !
testShouldHandleWhenHandleBlockReturnsTrue

	|canHandle selector|
	selector := BlockExceptionSelector handlesBlock: [:ex| canHandle].
	canHandle := true.
	[selector handles: nil] verify.
	canHandle := false.
	[(selector handles: nil) not] verify! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'test' !
testShouldPassExceptionToHandlesBlock

	|exception selector|
	exception := Object new.
	selector := BlockExceptionSelector handlesBlock: [:ex| [ex == exception] verify].
	selector handles: exception! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionSelector) methodsFor: 'exception selector' !
handles: exceptionDescriptor

	^handlesBlock value: exceptionDescriptor! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionSelector) methodsFor: 'initialization' !
handlesBlock: block

	handlesBlock := block ! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
handleBlock: block

	^self new
		handleBlock: block;
		yourself! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
new

	^super new initialize! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'tests' !
test

	self testShouldInvokeHandlerBlockWithException! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'tests' !
testShouldInvokeHandlerBlockWithException

	|handled exception|
	handled := false.
	exception = Object new.
	(BlockExceptionHandler
		handleBlock: [:ex| [ex == exception] verify.
			handled := true])
		handle: exception.
	[handled] verify! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
canHandleSignal: exception

	^false! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
handle: exception

	^handleBlock value: exception! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
handle: exception return: aBlock

	^aBlock value: (handleBlock value: exception)! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
nextHandler

	^nil! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
nextHandler: ignored! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
pass: exception

	passBlock value: exception! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
passBlock: block

	passBlock := block! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
return: value

	returnBlock value: value! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
returnBlock: block

	returnBlock := block! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'private initialization' !
handleBlock: block

	handleBlock := block! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'private initialization' !
initialize

	handleBlock := [:exception|].
	passBlock := [:exception|].! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'instantiation' !
new

	^super new
		initialize;
		yourself! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'test' !
test

	self testDefaultActionShouldInvokeDefaultActionBlock;
		testDefaultDefault;
		testHandlerShouldDelegateToHandlerBlock! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'test' !
testDefaultActionShouldInvokeDefaultActionBlock

	|exception wasInvoked|
	exception := BlockExceptionDescriptor new.
	wasInvoked := false.
	exception defaultActionBlock: [wasInvoked := true].
	exception defaultAction.
	[wasInvoked] verify! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'test' !
testDefaultDefault

	|exception wasInvoked|
	exception := BlockExceptionDescriptor new.
	exception defaultAction! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'test' !
testHandlerShouldDelegateToHandlerBlock

	|descriptor actualHandler|
	descriptor := BlockExceptionDescriptor new.
	descriptor handlerBlock: [:handler| actualHandler := handler].
	descriptor handler: #handler.
	[actualHandler == #handler] verify! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
defaultActionBlock: block

	defaultBlock := block! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
handler: handler

	handlerBlock value: handler ! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
handlerBlock: block

	handlerBlock := block ! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'exception descriptor' !
defaultAction

	defaultBlock value! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'initialization' !
initialize

	defaultBlock := [].
	handlerBlock := [:ignore|]! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'exceptionBuilder' !
on: anExceptionSelector do: handleBlock

	^self new
		on: anExceptionSelector
		do: handleBlock
		return: [:value|]
		outer: nil;
		yourself! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'exceptionBuilder' !
on: anExceptionSelector do: handleBlock return: returnBlock

	^self new
		on: anExceptionSelector
		do: handleBlock
		return: returnBlock
		outer: nil;
		yourself! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'exceptionBuilder' !
on: anExceptionSelector do: handleBlock return: returnBlock outer: outerBlock

	^self new
		on: anExceptionSelector
		do: handleBlock
		return: returnBlock
		outer: outerBlock;
		yourself! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
test

	self testShouldInvokeHandleBlockWhenExceptionMatches;
		testShouldInvokeExceptionsDefaultActionWhenNoNextHandler;
		testShouldDelegateToNextHandlerWhenNoMatch;
		testHandlerShouldSetHandlerOnException;
		testPassShouldDeferToNextHandler;
		testReturnShouldEvaluateReturnBlock! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testHandlerShouldSetHandlerOnException

	|handler trueSelector exception assignedHandler|
	trueSelector := BlockExceptionSelector handlesBlock: [:ex| true].
	exception := BlockExceptionDescriptor new.
	exception handlerBlock: [:handler| assignedHandler := handler].
	handler := LinkedExceptionHandler on: trueSelector do: [:ex| ].
	[assignedHandler ~~ handler] verify.
	handler handle: exception.
	[assignedHandler == handler] verify! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testPassShouldDeferToNextHandler

	|handler trueSelector exception wasPassed nextHandler|
	trueSelector := BlockExceptionSelector handlesBlock: [:ex| true].
	exception := BlockExceptionDescriptor new.
	handler := LinkedExceptionHandler on: trueSelector do: [:ex| ].
	nextHandler := BlockExceptionHandler handleBlock: [:ex| wasPassed := true].
	handler nextHandler: nextHandler.
	wasPassed := false.
	handler pass: exception.
	[wasPassed] verify	! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testReturnShouldEvaluateReturnBlock

	|handler result |
	handler := LinkedExceptionHandler
			on: nil
			do: [:ex| ]
			return: [:returnValue| result := returnValue].
	handler return: #value.
	[result == #value] verify! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testShouldDelegateToNextHandlerWhenNoMatch

	|handled falseSelector exception nextHandler|
	handled := false.
	falseSelector := BlockExceptionSelector handlesBlock: [:ex| false].
	exception := BlockExceptionDescriptor new.
	nextHandler := (BlockExceptionHandler
				handleBlock: [:ex| [ex == exception] verify.
					handled := true]).
	(LinkedExceptionHandler on: falseSelector do: [:ex| self shouldNotHappen])
		nextHandler: nextHandler;
		handle: exception.
	[handled] verify! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testShouldInvokeExceptionsDefaultActionWhenNoNextHandler

	|handled falseSelector exception|
	handled := false.
	falseSelector := BlockExceptionSelector handlesBlock: [:ex| false].
	exception := BlockExceptionDescriptor new.
	exception defaultActionBlock: [handled := true].
	(LinkedExceptionHandler on: falseSelector do: [:ex| self shouldNotHappen])
		handle: exception.
	[handled] verify! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testShouldInvokeHandleBlockWhenExceptionMatches

	|handled trueSelector exception|
	handled := false.
	exception := BlockExceptionDescriptor new.
	trueSelector := BlockExceptionSelector handlesBlock: [:ex| true].
	(LinkedExceptionHandler
		on: trueSelector
		do: [:ex| [ex == exception] verify.
			handled := true])
		handle: exception.
	[handled] verify! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
canHandleSignal: exception

	^(exceptionSelector handles: exception)
		or: [nextHandler notNil
			and: [nextHandler canHandleSignal: exception]]! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]].
	result := protectee value.
	^[result]! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
handle: exception

	self handle: exception
		return: returnBlock! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
handle: exception return: aReturnBlock

	exception handler: self.
	^(exceptionSelector handles: exception)
		ifTrue: [aReturnBlock value: (handleBlock value: exception)]
		ifFalse: [nextHandler handle: exception return: aReturnBlock]! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
nextHandler

	^nextHandler! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
outer: exception return: aReturnBlock

	^nextHandler handle: exception return: aReturnBlock! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
pass: exception

	^nextHandler handle: exception! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
protect: aBlock

	Processor activeProcess pushHandler: self.
	^[(self evaluateProtectee: aBlock) value]
		ensure: [Processor activeProcess popHandler]! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
retry

	retryBlock value! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
retryUsing: aBlock

	protectee := aBlock.
	retryBlock value! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
return: aValue

	returnBlock value: aValue! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
nextHandler: exceptionHandler

	nextHandler := exceptionHandler ! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler handleBlock: [:ex| ex defaultAction] ! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionInstantiator' !
signal
"Signal the occurrence of an exceptional condition."
	^ self new signal! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionInstantiator' !
signal: signalerText
"Signal the occurrence of an exceptional condition with a specified textual description."
	^ self new signal: signalerText! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionSelector' !
, anotherException
"Create an exception set."
"
	^ExceptionSet new
		add: self;
		add: anotherException;
		yourself"! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionSelector' !
handles: exception
"Determine whether an exception handler will accept a signaled exception."
	^ exception isKindOf: self! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
test

	self testSignalShouldInvokeProcessHandler;
		testPassShouldDeferToOuterHandler;
		testPassShouldNotReturn;
		testPassShouldInvokeDefaultActionWithoutReturning;
		testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable;
		testOuterShouldInvokeAndReturnDefaultActionWhenResumable;
		testOuterTwiceShouldInvokeSurroundingHandlerTwice;
		testResumeShouldReturnAsValueOfOuter;
		testResumeShouldReturnFromSignal;
		testResumeWithValueShouldReturnFromSignal;
		testReturnShouldDelegateToHandler;
		testIsNestedShouldBeFalseWithNoHandler;
		testIsNestedShouldBeTrueWhenOuterHandlerHandles;
		testIsNestedShouldBeFalseWhenOuterHandlerDoesntHandle;
		testIsNestedShouldBeTrueWhenOuterOuterHandlerHandles;
		testResignalAsShouldRestoreSignalEnvironment;
		testRetryShouldReevaluateProtectee;
		testRetryUsingShouldReplaceProtectee! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testIsNestedShouldBeFalseWhenOuterHandlerDoesntHandle

	|result|
	[[Exception signal]
		on: Exception
		do: [:ex| result := ex isNested]]
		on: TestException
		do: [:ex|].
	[result not] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testIsNestedShouldBeFalseWithNoHandler

	|exception|
	exception := Exception new.
	[exception isNested not] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testIsNestedShouldBeTrueWhenOuterHandlerHandles

	|result|
	[[Exception signal]
		on: Exception
		do: [:ex| result := ex isNested]]
		on: Exception
		do: [:ex| self shouldNotHappen].
	[result] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testIsNestedShouldBeTrueWhenOuterOuterHandlerHandles

	|result|
	[[[Exception signal]
		on: Exception
		do: [:ex| result := ex isNested]]
		on: TestException
		do: [:ex|]]
		on: Exception
		do: [:ex|].
	[result] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable

	|outer result|
	[(TestException defaultActionBlock: [#result])
		resumable: true;
		signal]
		on: TestException
		do: [:ex| outer := ex outer.
			result := #returned].
	[result == #returned] verify.
	[outer == #result] verify.! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	[([|result|
	result := (TestException defaultActionBlock: [#result])
		signal.
	[result == #result] verify.
	result]
		on: TestException
		do: [:ex| ex outer.
			self shouldNotHappen]) == #result] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testOuterTwiceShouldInvokeSurroundingHandlerTwice

	|count|	count := 0.
	[[(TestException defaultActionBlock: [-1])
		resumable: true;
		signal]
		on: TestException
		do: [:ex| ex outer.
			ex outer]]
		on: TestException
		do: [:ex| count := count + 1].
	[count == 2] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	[wasPassed] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testPassShouldInvokeDefaultActionWithoutReturning

	[([|result|
	result := (TestException defaultActionBlock: [#result])
			signal.
	[result == #result] verify.
	result]
		on: TestException
		do: [:ex| ex pass.
			self shouldNotHappen]) == #result] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testPassShouldNotReturn

	[([[Exception signal]
		on: Exception
		do: [:ex| ex pass.
			self shouldNotHappen]]
		on: Exception
		do: [:ex| #result]) == #result] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testResignalAsShouldRestoreSignalEnvironment

	|log|
	log := String new writeStream.
	[[Exception signal]
		on: TestException
		do: [:ex| log nextPutAll: 'resignal']]
		on: Exception
		do: [:ex| [log nextPutAll: 'signal '.
			ex resignalAs: TestException new]
				ifCurtailed: [log nextPutAll: 'curtail ']].
	[log contents = 'signal curtail resignal'] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testResumeShouldReturnAsValueOfOuter

	|result|
	[[Exception signal]
		on: Exception
		do: [:ex| result := ex outer]]
		on: Exception
		do: [:ex| ex resume: #result].
	[result == #result] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testResumeShouldReturnFromSignal

	|wasResumed|
	wasResumed := false.
	[Exception signal.
	wasResumed := true]
		on: Exception
		do: [:ex| ex resume].
	[wasResumed] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testResumeWithValueShouldReturnFromSignal

	|result|
	[result := Exception signal]
		on: Exception
		do: [:ex| ex resume: #result].
	[result == #result] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testRetryShouldReevaluateProtectee

	|count|
	count := 0.
	[count := count + 1.
	count == 1 ifTrue:[Exception signal]]
		on: Exception
		do: [:ex| ex retry].
	[count == 2] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testRetryUsingShouldReplaceProtectee

	|log count|
	log := String new writeStream.
	count := 0.
	[[Exception signal] ensure: [log nextPutAll: 'unwind ']]
		on: Exception
		do: [:ex|
			log nextPutAll: 'handle '.
			count := count + 1.
			count = 1 ifTrue: [ex retryUsing: [log nextPutAll: 'using '.
								Exception signal]]].
	[log contents = 'handle unwind using handle '] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testReturnShouldDelegateToHandler

	|exception handler result|
	exception := Exception new.
	handler := BlockExceptionHandler new.
	result := #invalid.
	handler returnBlock: [:value| result := value].
	exception handler: handler.
	exception return.
	[result isNil] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testSignalShouldInvokeProcessHandler

	|wasInvoked|
	wasInvoked := false.
	Processor activeProcess
		pushHandler: (BlockExceptionHandler
				handleBlock: [:ex| wasInvoked := true]).
	Exception signal.
	[[wasInvoked] verify]
		ensure: [Processor activeProcess popHandler]! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'exceptionBuilder' !
tag: t
"This message is not specified in the ANSI protocol,
but that looks like an oversight because #tag is specified,
and the spec states that the signaler may store the tag value."
	tag := t! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'exceptionDescription' !
tag
"Return an exception's tag value."
	^tag == nil
		ifTrue: [self messageText]
		ifFalse: [tag]! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
isNested
"Determine whether the current exception handler is within 
the scope of another handler for the same exception."
	^ handler notNil and: [handler nextHandler canHandleSignal: self]! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
outer
"Evaluate the enclosing exception action and return to here 
instead of signal if it resumes (see #resumeUnchecked:)."
	| oldHandler oldResume |
	self isResumable
		ifFalse: [self pass].
	[oldResume := resumeBlock.
	resumeBlock := [:value| ^value].
	(oldHandler := handler) outer: self return: [:value| ^value]]
		ensure: [handler := oldHandler.
			resumeBlock := oldResume]! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
pass
"Yield control to the enclosing exception action for the receiver."
	passBlock value! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resignalAs: replacementException
"Signal an alternative exception in place of the receiver."
	resignalBlock value: replacementException! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resume
"Return from the message that signaled the receiver."
	self resume: nil! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resume: resumptionValue
"Return resumptionValue as the value of the signal message."
	resumeBlock value: resumptionValue! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
retry
"Abort an exception handler and re-evaluate its protected block."
	handler retry! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
retryUsing: alternativeBlock
"Abort an exception handler and evaluate a new block 
in place of the handler's protected block."
	handler retryUsing: alternativeBlock! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
return
"Return nil as the value of the block protected 
by the active exception handler."
	self return: nil! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
return: returnValue
"Return the argument as the value of the block protected 
by the active exception handler."
	handler return: returnValue! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
description
"Return a textual description of the exception."
	| desc mt |
	desc := self class name asString.
	^(mt := self messageText) == nil
		ifTrue: [desc]
		ifFalse: [desc, ': ', mt]! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
messageText
"Return an exception's message text."
	^messageText! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
printOn: stream

	stream nextPutAll: self description! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
defaultAction
"The default action taken if the exception is signaled."
	self subclassResponsibility! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
handler: aHandler

	handler := aHandler! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
isResumable
"Determine whether an exception is resumable."
	^ true! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
messageText: signalerText
"Set an exception's message text."
	messageText := signalerText! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
privateSignal
"Ask ContextHandlers in the sender chain to handle this signal.
The default is to execute and return my defaultAction."
	resignalBlock := [:ex| ^[ex signal]].
	resumeBlock := [:result| ^[result]].
	passBlock := [^[handler pass: self]].
	Processor activeProcess handle: self.
	^[]! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
signal

	^self privateSignal value! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
signal: signalerText
"Signal the occurrence of an exceptional condition with a 
specified textual description."
	self messageText: signalerText.
	^ self signal! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handle: exception

	^self handlerChain handle: exception! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler handleBlock: [:ex| ex defaultAction]].
	^handlerChain! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
popHandler

	handlerChain := self handlerChain nextHandler ! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
pushHandler: handler

	handler nextHandler: self handlerChain.
	handlerChain := handler ! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
resetHandlers

	handlerChain := nil

! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'exceptions' !
on: exception do: handlerBlock

	^(LinkedExceptionHandler
		on: exception
		do: handlerBlock
		return: [:value | ^ value]) protect: self
! !

"May 19, 2008 -> 4:23:13"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:23:13"!

(Delta mirrorFor: #BlockExceptionSelector)
comment: 
'Determines whether an exception can be handled by evaluating the handlesBlock.'!


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:23:13"!

(Delta mirrorFor: #BlockExceptionHandler)
comment: 
'Exception handler for an exception. Handles the exception by invoking its handleBlock.'!


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:23:13"!

(Delta mirrorFor: #BlockExceptionDescriptor)
comment: 
'Implements the <exceptionDescriptor> protocol from the ANSI standard using configurable actionsdefined as blocks. Intended to be used primarily as a testing aid.'!


"May 19, 2008 -> 4:23:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:23:13"!

(Delta mirrorFor: #LinkedExceptionHandler)
comment: 
'Exception handler for an exception. Invokes its handleBlock when asked to handle an exceptionthat matches its exceptionSelector. If the exception does not match its exceptionSelector it passesthe exception on to the nextHandler. If the nextHandler is undefined signal an UnhandledExceptionError.This class is internal to the exception handling framework. There should be no need for code outside of thisframework to interact with instances of ExceptionHandler.'!


"May 19, 2008 -> 4:23:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:23:13"!

(Delta mirrorFor: #Exception)
comment: 
'Base class of the exception hierarchy. Implements the core of the ANSI exception handling protocols'!


"May 19, 2008 -> 4:23:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

(Delta mirrorFor: #Error)
comment: 
''!


"May 19, 2008 -> 4:23:13"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

(Delta mirrorFor: #Notification)
comment: 
''!


"May 19, 2008 -> 4:23:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

(Delta mirrorFor: #MessageNotUnderstood)
comment: 
''!


"May 19, 2008 -> 4:23:13"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'instantiation' !
handlesBlock: block

	^self new
		handlesBlock: block;
		yourself! !

"May 19, 2008 -> 4:23:13"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'test' !
test

	self testShouldHandleWhenHandleBlockReturnsTrue;
		testShouldPassExceptionToHandlesBlock! !

"May 19, 2008 -> 4:23:13"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'test' !
testShouldHandleWhenHandleBlockReturnsTrue

	|canHandle selector|
	selector := BlockExceptionSelector handlesBlock: [:ex| canHandle].
	canHandle := true.
	[selector handles: nil] verify.
	canHandle := false.
	[(selector handles: nil) not] verify! !

"May 19, 2008 -> 4:23:13"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'test' !
testShouldPassExceptionToHandlesBlock

	|exception selector|
	exception := Object new.
	selector := BlockExceptionSelector handlesBlock: [:ex| [ex == exception] verify].
	selector handles: exception! !

"May 19, 2008 -> 4:23:13"!

! (Delta mirrorFor: #BlockExceptionSelector) methodsFor: 'exception selector' !
handles: exceptionDescriptor

	^handlesBlock value: exceptionDescriptor! !

"May 19, 2008 -> 4:23:13"!

! (Delta mirrorFor: #BlockExceptionSelector) methodsFor: 'initialization' !
handlesBlock: block

	handlesBlock := block ! !

"May 19, 2008 -> 4:23:13"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
handleBlock: block

	^self new
		handleBlock: block;
		yourself! !

"May 19, 2008 -> 4:23:13"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
new

	^super new initialize! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'tests' !
test

	self testShouldInvokeHandlerBlockWithException! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'tests' !
testShouldInvokeHandlerBlockWithException

	|handled exception|
	handled := false.
	exception = Object new.
	(BlockExceptionHandler
		handleBlock: [:ex| [ex == exception] verify.
			handled := true])
		handle: exception.
	[handled] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
canHandleSignal: exception

	^false! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
handle: exception

	^handleBlock value: exception! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
handle: exception return: aBlock

	^aBlock value: (handleBlock value: exception)! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
nextHandler

	^nil! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
nextHandler: ignored! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
pass: exception

	passBlock value: exception! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
passBlock: block

	passBlock := block! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
return: value

	returnBlock value: value! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
returnBlock: block

	returnBlock := block! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'private initialization' !
handleBlock: block

	handleBlock := block! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'private initialization' !
initialize

	handleBlock := [:exception|].
	passBlock := [:exception|].! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'instantiation' !
new

	^super new
		initialize;
		yourself! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'test' !
test

	self testDefaultActionShouldInvokeDefaultActionBlock;
		testDefaultDefault;
		testHandlerShouldDelegateToHandlerBlock! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'test' !
testDefaultActionShouldInvokeDefaultActionBlock

	|exception wasInvoked|
	exception := BlockExceptionDescriptor new.
	wasInvoked := false.
	exception defaultActionBlock: [wasInvoked := true].
	exception defaultAction.
	[wasInvoked] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'test' !
testDefaultDefault

	|exception wasInvoked|
	exception := BlockExceptionDescriptor new.
	exception defaultAction! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'test' !
testHandlerShouldDelegateToHandlerBlock

	|descriptor actualHandler|
	descriptor := BlockExceptionDescriptor new.
	descriptor handlerBlock: [:handler| actualHandler := handler].
	descriptor handler: #handler.
	[actualHandler == #handler] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
defaultActionBlock: block

	defaultBlock := block! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
handler: handler

	handlerBlock value: handler ! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
handlerBlock: block

	handlerBlock := block ! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'exception descriptor' !
defaultAction

	defaultBlock value! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'initialization' !
initialize

	defaultBlock := [].
	handlerBlock := [:ignore|]! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'exceptionBuilder' !
on: anExceptionSelector do: handleBlock

	^self new
		on: anExceptionSelector
		do: handleBlock
		return: [:value|]
		outer: nil;
		yourself! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'exceptionBuilder' !
on: anExceptionSelector do: handleBlock return: returnBlock

	^self new
		on: anExceptionSelector
		do: handleBlock
		return: returnBlock
		outer: nil;
		yourself! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'exceptionBuilder' !
on: anExceptionSelector do: handleBlock return: returnBlock outer: outerBlock

	^self new
		on: anExceptionSelector
		do: handleBlock
		return: returnBlock
		outer: outerBlock;
		yourself! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
test

	self testShouldInvokeHandleBlockWhenExceptionMatches;
		testShouldInvokeExceptionsDefaultActionWhenNoNextHandler;
		testShouldDelegateToNextHandlerWhenNoMatch;
		testHandlerShouldSetHandlerOnException;
		testPassShouldDeferToNextHandler;
		testReturnShouldEvaluateReturnBlock! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testHandlerShouldSetHandlerOnException

	|handler trueSelector exception assignedHandler|
	trueSelector := BlockExceptionSelector handlesBlock: [:ex| true].
	exception := BlockExceptionDescriptor new.
	exception handlerBlock: [:handler| assignedHandler := handler].
	handler := LinkedExceptionHandler on: trueSelector do: [:ex| ].
	[assignedHandler ~~ handler] verify.
	handler handle: exception.
	[assignedHandler == handler] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testPassShouldDeferToNextHandler

	|handler trueSelector exception wasPassed nextHandler|
	trueSelector := BlockExceptionSelector handlesBlock: [:ex| true].
	exception := BlockExceptionDescriptor new.
	handler := LinkedExceptionHandler on: trueSelector do: [:ex| ].
	nextHandler := BlockExceptionHandler handleBlock: [:ex| wasPassed := true].
	handler nextHandler: nextHandler.
	wasPassed := false.
	handler pass: exception.
	[wasPassed] verify	! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testReturnShouldEvaluateReturnBlock

	|handler result |
	handler := LinkedExceptionHandler
			on: nil
			do: [:ex| ]
			return: [:returnValue| result := returnValue].
	handler return: #value.
	[result == #value] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testShouldDelegateToNextHandlerWhenNoMatch

	|handled falseSelector exception nextHandler|
	handled := false.
	falseSelector := BlockExceptionSelector handlesBlock: [:ex| false].
	exception := BlockExceptionDescriptor new.
	nextHandler := (BlockExceptionHandler
				handleBlock: [:ex| [ex == exception] verify.
					handled := true]).
	(LinkedExceptionHandler on: falseSelector do: [:ex| self shouldNotHappen])
		nextHandler: nextHandler;
		handle: exception.
	[handled] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testShouldInvokeExceptionsDefaultActionWhenNoNextHandler

	|handled falseSelector exception|
	handled := false.
	falseSelector := BlockExceptionSelector handlesBlock: [:ex| false].
	exception := BlockExceptionDescriptor new.
	exception defaultActionBlock: [handled := true].
	(LinkedExceptionHandler on: falseSelector do: [:ex| self shouldNotHappen])
		handle: exception.
	[handled] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testShouldInvokeHandleBlockWhenExceptionMatches

	|handled trueSelector exception|
	handled := false.
	exception := BlockExceptionDescriptor new.
	trueSelector := BlockExceptionSelector handlesBlock: [:ex| true].
	(LinkedExceptionHandler
		on: trueSelector
		do: [:ex| [ex == exception] verify.
			handled := true])
		handle: exception.
	[handled] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
canHandleSignal: exception

	^(exceptionSelector handles: exception)
		or: [nextHandler notNil
			and: [nextHandler canHandleSignal: exception]]! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]].
	result := protectee value.
	^[result]! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
handle: exception

	self handle: exception
		return: returnBlock! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
handle: exception return: aReturnBlock

	exception handler: self.
	^(exceptionSelector handles: exception)
		ifTrue: [aReturnBlock value: (handleBlock value: exception)]
		ifFalse: [nextHandler handle: exception return: aReturnBlock]! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
nextHandler

	^nextHandler! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
outer: exception return: aReturnBlock

	^nextHandler handle: exception return: aReturnBlock! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
pass: exception

	^nextHandler handle: exception! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
protect: aBlock

	Processor activeProcess pushHandler: self.
	^[(self evaluateProtectee: aBlock) value]
		ensure: [Processor activeProcess popHandler]! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
retry

	retryBlock value! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
retryUsing: aBlock

	protectee := aBlock.
	retryBlock value! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
return: aValue

	returnBlock value: aValue! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
nextHandler: exceptionHandler

	nextHandler := exceptionHandler ! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler handleBlock: [:ex| ex defaultAction] ! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionInstantiator' !
signal
"Signal the occurrence of an exceptional condition."
	^ self new signal! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionInstantiator' !
signal: signalerText
"Signal the occurrence of an exceptional condition with a specified textual description."
	^ self new signal: signalerText! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionSelector' !
, anotherException
"Create an exception set."
"
	^ExceptionSet new
		add: self;
		add: anotherException;
		yourself"! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionSelector' !
handles: exception
"Determine whether an exception handler will accept a signaled exception."
	^ exception isKindOf: self! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
test

	self testSignalShouldInvokeProcessHandler;
		testPassShouldDeferToOuterHandler;
		testPassShouldNotReturn;
		testPassShouldInvokeDefaultActionWithoutReturning;
		testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable;
		testOuterShouldInvokeAndReturnDefaultActionWhenResumable;
		testOuterTwiceShouldInvokeSurroundingHandlerTwice;
		testResumeShouldReturnAsValueOfOuter;
		testResumeShouldReturnFromSignal;
		testResumeWithValueShouldReturnFromSignal;
		testReturnShouldDelegateToHandler;
		testIsNestedShouldBeFalseWithNoHandler;
		testIsNestedShouldBeTrueWhenOuterHandlerHandles;
		testIsNestedShouldBeFalseWhenOuterHandlerDoesntHandle;
		testIsNestedShouldBeTrueWhenOuterOuterHandlerHandles;
		testResignalAsShouldRestoreSignalEnvironment;
		testRetryShouldReevaluateProtectee;
		testRetryUsingShouldReplaceProtectee! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testIsNestedShouldBeFalseWhenOuterHandlerDoesntHandle

	|result|
	[[Exception signal]
		on: Exception
		do: [:ex| result := ex isNested]]
		on: TestException
		do: [:ex|].
	[result not] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testIsNestedShouldBeFalseWithNoHandler

	|exception|
	exception := Exception new.
	[exception isNested not] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testIsNestedShouldBeTrueWhenOuterHandlerHandles

	|result|
	[[Exception signal]
		on: Exception
		do: [:ex| result := ex isNested]]
		on: Exception
		do: [:ex| self shouldNotHappen].
	[result] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testIsNestedShouldBeTrueWhenOuterOuterHandlerHandles

	|result|
	[[[Exception signal]
		on: Exception
		do: [:ex| result := ex isNested]]
		on: TestException
		do: [:ex|]]
		on: Exception
		do: [:ex|].
	[result] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable

	|outer result|
	[(TestException defaultActionBlock: [#result])
		resumable: true;
		signal]
		on: TestException
		do: [:ex| outer := ex outer.
			result := #returned].
	[result == #returned] verify.
	[outer == #result] verify.! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	[([|result|
	result := (TestException defaultActionBlock: [#result])
		signal.
	[result == #result] verify.
	result]
		on: TestException
		do: [:ex| ex outer.
			self shouldNotHappen]) == #result] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testOuterTwiceShouldInvokeSurroundingHandlerTwice

	|count|	count := 0.
	[[(TestException defaultActionBlock: [-1])
		resumable: true;
		signal]
		on: TestException
		do: [:ex| ex outer.
			ex outer]]
		on: TestException
		do: [:ex| count := count + 1].
	[count == 2] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	[wasPassed] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testPassShouldInvokeDefaultActionWithoutReturning

	[([|result|
	result := (TestException defaultActionBlock: [#result])
			signal.
	[result == #result] verify.
	result]
		on: TestException
		do: [:ex| ex pass.
			self shouldNotHappen]) == #result] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testPassShouldNotReturn

	[([[Exception signal]
		on: Exception
		do: [:ex| ex pass.
			self shouldNotHappen]]
		on: Exception
		do: [:ex| #result]) == #result] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testResignalAsShouldRestoreSignalEnvironment

	|log|
	log := String new writeStream.
	[[Exception signal]
		on: TestException
		do: [:ex| log nextPutAll: 'resignal']]
		on: Exception
		do: [:ex| [log nextPutAll: 'signal '.
			ex resignalAs: TestException new]
				ifCurtailed: [log nextPutAll: 'curtail ']].
	[log contents = 'signal curtail resignal'] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testResumeShouldReturnAsValueOfOuter

	|result|
	[[Exception signal]
		on: Exception
		do: [:ex| result := ex outer]]
		on: Exception
		do: [:ex| ex resume: #result].
	[result == #result] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testResumeShouldReturnFromSignal

	|wasResumed|
	wasResumed := false.
	[Exception signal.
	wasResumed := true]
		on: Exception
		do: [:ex| ex resume].
	[wasResumed] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testResumeWithValueShouldReturnFromSignal

	|result|
	[result := Exception signal]
		on: Exception
		do: [:ex| ex resume: #result].
	[result == #result] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testRetryShouldReevaluateProtectee

	|count|
	count := 0.
	[count := count + 1.
	count == 1 ifTrue:[Exception signal]]
		on: Exception
		do: [:ex| ex retry].
	[count == 2] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testRetryUsingShouldReplaceProtectee

	|log count|
	log := String new writeStream.
	count := 0.
	[[Exception signal] ensure: [log nextPutAll: 'unwind ']]
		on: Exception
		do: [:ex|
			log nextPutAll: 'handle '.
			count := count + 1.
			count = 1 ifTrue: [ex retryUsing: [log nextPutAll: 'using '.
								Exception signal]]].
	[log contents = 'handle unwind using handle '] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testReturnShouldDelegateToHandler

	|exception handler result|
	exception := Exception new.
	handler := BlockExceptionHandler new.
	result := #invalid.
	handler returnBlock: [:value| result := value].
	exception handler: handler.
	exception return.
	[result isNil] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testSignalShouldInvokeProcessHandler

	|wasInvoked|
	wasInvoked := false.
	Processor activeProcess
		pushHandler: (BlockExceptionHandler
				handleBlock: [:ex| wasInvoked := true]).
	Exception signal.
	[[wasInvoked] verify]
		ensure: [Processor activeProcess popHandler]! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'exceptionBuilder' !
tag: t
"This message is not specified in the ANSI protocol,
but that looks like an oversight because #tag is specified,
and the spec states that the signaler may store the tag value."
	tag := t! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'exceptionDescription' !
tag
"Return an exception's tag value."
	^tag == nil
		ifTrue: [self messageText]
		ifFalse: [tag]! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
isNested
"Determine whether the current exception handler is within 
the scope of another handler for the same exception."
	^ handler notNil and: [handler nextHandler canHandleSignal: self]! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
outer
"Evaluate the enclosing exception action and return to here 
instead of signal if it resumes (see #resumeUnchecked:)."
	| oldHandler oldResume |
	self isResumable
		ifFalse: [self pass].
	[oldResume := resumeBlock.
	resumeBlock := [:value| ^value].
	(oldHandler := handler) outer: self return: [:value| ^value]]
		ensure: [handler := oldHandler.
			resumeBlock := oldResume]! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
pass
"Yield control to the enclosing exception action for the receiver."
	passBlock value! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resignalAs: replacementException
"Signal an alternative exception in place of the receiver."
	resignalBlock value: replacementException! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resume
"Return from the message that signaled the receiver."
	self resume: nil! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resume: resumptionValue
"Return resumptionValue as the value of the signal message."
	resumeBlock value: resumptionValue! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
retry
"Abort an exception handler and re-evaluate its protected block."
	handler retry! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
retryUsing: alternativeBlock
"Abort an exception handler and evaluate a new block 
in place of the handler's protected block."
	handler retryUsing: alternativeBlock! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
return
"Return nil as the value of the block protected 
by the active exception handler."
	self return: nil! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
return: returnValue
"Return the argument as the value of the block protected 
by the active exception handler."
	handler return: returnValue! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
description
"Return a textual description of the exception."
	| desc mt |
	desc := self class name asString.
	^(mt := self messageText) == nil
		ifTrue: [desc]
		ifFalse: [desc, ': ', mt]! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
messageText
"Return an exception's message text."
	^messageText! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
printOn: stream

	stream nextPutAll: self description! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
defaultAction
"The default action taken if the exception is signaled."
	self subclassResponsibility! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
handler: aHandler

	handler := aHandler! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
isResumable
"Determine whether an exception is resumable."
	^ true! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
messageText: signalerText
"Set an exception's message text."
	messageText := signalerText! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
privateSignal
"Ask ContextHandlers in the sender chain to handle this signal.
The default is to execute and return my defaultAction."
	resignalBlock := [:ex| ^[ex signal]].
	resumeBlock := [:result| ^[result]].
	passBlock := [^[handler pass: self]].
	Processor activeProcess handle: self.
	^[]! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
signal

	^self privateSignal value! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
signal: signalerText
"Signal the occurrence of an exceptional condition with a 
specified textual description."
	self messageText: signalerText.
	^ self signal! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handle: exception

	^self handlerChain handle: exception! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler handleBlock: [:ex| ex defaultAction]].
	^handlerChain! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
popHandler

	handlerChain := self handlerChain nextHandler ! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
pushHandler: handler

	handler nextHandler: self handlerChain.
	handlerChain := handler ! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
resetHandlers

	handlerChain := nil

! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'exceptions' !
on: exception do: handlerBlock

	^(LinkedExceptionHandler
		on: exception
		do: handlerBlock
		return: [:value | ^ value]) protect: self
! !

"May 19, 2008 -> 4:23:45"!

"System saved" !
"May 19, 2008 -> 18:11:13"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'control' !
continueProcess

	|topWindow|
	self process resume.
	self process: nil.		"Don't terminate process when window closes"
	"self requestCloseIfTopWindow."
	topWindow := self visual topWindow
	topWindow isNil
		ifFalse: [topWindow requestClose]! !

"May 19, 2008 -> 18:12:17"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'control' !
continueProcess

	|topWindow|
	self process resume.
	self process: nil.		"Don't terminate process when window closes"
	"self requestCloseIfTopWindow."
	topWindow := self visual topWindow.
	topWindow isNil
		ifFalse: [topWindow requestClose]! !

"May 19, 2008 -> 18:12:49"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'control' !
continueProcess

	|topWindow|
	self process resume.
	self process: nil.		"Don't terminate process when window closes"
	topWindow := self visual topWindow.
	topWindow isNil
		ifFalse: [topWindow requestClose]! !

"May 19, 2008 -> 18:13:47"!

"System saved" !
"May 24, 2008 -> 9:11:48"!

! (Delta mirrorFor: #Behavior) methodsFor: 'Camp Smalltalk' !
allSelectors

	|selectors|
	selectors := Set withAll: self selectors.
	self superclassesDo: [:class| selectors addAll: class selectors].
	^selectors! !

"May 24, 2008 -> 9:12:3"!

"System saved" !
"May 24, 2008 -> 10:13:37"!

! (Delta mirrorFor: #Error) methodsFor: 'priv handling' !
defaultAction

	Processor stopWithError: (ProcessExplicitError new msg: messageText)! !

"May 24, 2008 -> 10:13:37"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
error: msg <Str> ^<BottomType>

	"Processor stopWithError: (ProcessExplicitError new msg: msg)"
	Error signal: msg! !

"May 24, 2008 -> 10:13:37"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Accessing' !
current

	^self currentDictionary
		at: self
		ifPresent: [:current| current]
		ifAbsentPut: [self new].

			! !

"May 24, 2008 -> 10:13:37"!

! (Delta mirrorFor: #SimpleTestResourceTestCase) classSide methodsFor: 'Not categorized' !
resources
	^Set new add: SimpleTestResource current; yourself
			! !

"May 24, 2008 -> 10:13:37"!

! (Delta mirrorFor: #ReadString) methodsFor: 'Camp Smalltalk' !
sunitAsSymbol
 
        ^self asSymbol! !

"May 24, 2008 -> 10:13:57"!

"System saved" !
"May 24, 2008 -> 10:20:55"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Init / Release' !
reset

	self class reset! !

"May 24, 2008 -> 10:24:14"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Creation' !
reset
	|current|
	current := self currentDictionary
		at: self
		ifAbsent: [^nil].
	current isNil
		ifFalse: [[current tearDown] ensure: [
					self current: nil]]
			! !

"May 24, 2008 -> 10:24:59"!

"System saved" !
"May 24, 2008 -> 10:48:18"!

! (Delta mirrorFor: #MessageNotUnderstood) methodsFor: 'priv handling' !
defaultAction

	Processor stopWithError: (ProcessDoesNotUnderstandError new message: messageText)! !

"May 24, 2008 -> 10:49:34"!

! (Delta mirrorFor: #MessageNotUnderstood) classSide methodsFor: 'instance creation' !
message: aMessage

	^self new message: aMessage; yourself! !

"May 24, 2008 -> 10:49:46"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"May 24, 2008 -> 10:50:12"!

! (Delta mirrorFor: #MessageNotUnderstood) methodsFor: 'private initialization' !
message: aMessage

	message := aMessage! !

"May 24, 2008 -> 10:50:19"!

! (Delta mirrorFor: #MessageNotUnderstood) methodsFor: 'priv handling' !
defaultAction

	Processor stopWithError: (ProcessDoesNotUnderstandError new message: message)! !

"May 24, 2008 -> 10:50:58"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
doesNotUnderstand: m <Message> ^<BottomType>

	"Processor stopWithError: (ProcessDoesNotUnderstandError new message: m)"
	(MessageNotUnderstood message: m) signal
! !

"May 24, 2008 -> 10:55:41"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Accessing' !
current

	^self currentDictionary
		at: self
		ifPresent: [:current| ^current]
		ifAbsentPut: [self new].

			! !

"May 24, 2008 -> 10:57:43"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Accessing' !
current

	^self currentDictionary
		at: self
		ifPresent: [:current| ^current halt]
		ifAbsentPut: [self new].

			! !

"May 24, 2008 -> 11:3:57"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Accessing' !
current: aTestResource

	aTestResource isNil
		ifTrue: [self currentDictionary removeKey: self]
		ifFalse: [self currentDictionary
							at: self
							put: aTestResource]			! !

"May 24, 2008 -> 11:4:40"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Accessing' !
current

	^self currentDictionary
		at: self
		ifPresent: [:current| ^current]
		ifAbsentPut: [self new].

			! !

"May 24, 2008 -> 11:5:21"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Accessing' !
current

	^self currentDictionary
		at: self
		ifPresent: [:current| ^current halt]
		ifAbsentPut: [self new].

			! !

"May 24, 2008 -> 11:5:38"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Accessing' !
current

	^self currentDictionary
		at: self
		ifPresent: [:current| ^current]
		ifAbsentPut: [self new].

			! !

"May 24, 2008 -> 11:8:57"!

"System saved" !
"May 24, 2008 -> 13:9:39"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Creation' !
reset
	|current|
	current := self currentDictionary
		at: self
		ifAbsent: [^nil].
	[current isNil
		ifFalse: [current tearDown]] ensure: [
					self current: nil]
			! !

"May 24, 2008 -> 13:9:39"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
doesNotUnderstand: m <Message> ^<BottomType>

	"Processor stopWithError: (ProcessDoesNotUnderstandError new message: m)"
	self halt.
	(MessageNotUnderstood message: m) signal! !

"May 24, 2008 -> 13:16:22"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
handles: anException
"should this really be here? - required for SUnit"
	^self class handles: anException! !

"May 24, 2008 -> 13:19:29"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
doesNotUnderstand: m <Message> ^<BottomType>
	"Processor stopWithError: (ProcessDoesNotUnderstandError new message: m)"
	(MessageNotUnderstood message: m) signal! !

"May 24, 2008 -> 13:55:35"!

! (Delta mirrorFor: #SUnitNameResolver) classSide methodsFor: 'Camp Smalltalk' !
notificationObject
	^Notification" new"! !

"May 24, 2008 -> 13:55:54"!

! (Delta mirrorFor: #SUnitNameResolver) classSide methodsFor: 'Camp Smalltalk' !
mnuExceptionObject
	^MessageNotUnderstood "new"! !

"May 24, 2008 -> 13:56:20"!

! (Delta mirrorFor: #SUnitNameResolver) classSide methodsFor: 'Camp Smalltalk' !
notificationObject
	^Notification! !

"May 24, 2008 -> 13:56:21"!

! (Delta mirrorFor: #SUnitNameResolver) classSide methodsFor: 'Camp Smalltalk' !
mnuExceptionObject
	^MessageNotUnderstood! !

"May 24, 2008 -> 13:58:2"!

(Delta mirrorFor: #Exception) removeMethod: #handles: ifAbsent: [] !


"May 24, 2008 -> 14:1:16"!

"System saved" !
"May 24, 2008 -> 14:1:53"!

Delta define: #BecomeTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"May 24, 2008 -> 14:4:25"!

! (Delta mirrorFor: #BecomeTest) methodsFor: 'testing' !
testBecome

	|first second source target|
	first := Array with: 1.
	second := Array with: 2.
	source := first copy.
	target := second copy.
	
	source become: target.
	self assert: (source = second).
	self assert: (target = first)! !

"May 24, 2008 -> 14:5:53"!

! (Delta mirrorFor: #Object) methodsFor: 'private-reflective' !
become: otherObject <BottomType>
	"Replace all references to the receiver anywhere in this image with references to otherObject, instead.

	This is a very dangerous message that should only be used if you really know what you are doing. Note that ALL
	references are changed, including 'self' in any currently active method contexts for the receiver,
	which means that instance variables could be accessed incorrectly, etc.  Note that this also means that the receiver
	becomes COMPLETELY inaccessible.
	 Also, this is not typesafe, and the type of the argument has been chosen to force typed code to insert an 
	 explicit guarantee, to avoid 'accidental' type-safety holes.  "

	"self unimplemented"
	{{ self primitiveBecome: otherObject ifFail: [:error| self error: error] }}! !

"May 24, 2008 -> 14:6:45"!

! (Delta mirrorFor: #BecomeTest) methodsFor: 'testing' !
testBecome

	|first second source target|
	first := Array with: 1.
	second := Array with: 2.
	source := first copy.
	target := second copy.
	
	self assert: (source = first).
	self assert: (target = second).
	source become: target.
	self assert: (source = second).
	self assert: (target = first)! !

"May 24, 2008 -> 14:7:44"!

! (Delta mirrorFor: #BecomeTest) methodsFor: 'testing' !
testBecomeShouldReportErrorWhenReceiverIsSmallInteger! !

"May 24, 2008 -> 14:8:34"!

! (Delta mirrorFor: #BecomeTest) methodsFor: 'initialize/release' !
setUp

	super setUp! !

"May 24, 2008 -> 14:10:49"!

(Delta mirrorFor: #BecomeTest) removeMethod: #setUp ifAbsent: [] !


"May 24, 2008 -> 14:14:6"!

! (Delta mirrorFor: #BecomeTest) methodsFor: 'testing' !
testBecomeShouldReportErrorWhenReceiverIsSmallInteger

	[1 become: ''.
	TestFailure signal]
		on: Error
		do: [:error| self assert: ('FirstArgumentHasWrongType' = error messageText)]
! !

"May 24, 2008 -> 14:22:54"!

"System saved" !
"May 29, 2008 -> 22:46:34"!

(Delta mirrorFor: #FileOutSet)
comment: 
'Simple tool to help organize file outs. Acts as a collection for classes
and method categories.

Add classes using addClass: and method categories using
addClass:category:. File out the results using fileOutOn:.

Files out definitions of all classes before any methods are filed out to
ensure that there are no undefined symbols, even if there are circular
references between classes.'!


"May 29, 2008 -> 22:46:34"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'adding' !
addClass: class

	classes add: class.
	classCategories
		removeKey: class
		ifAbsent: [].
	classCategories
		removeKey: class class
		ifAbsent: []! !

"May 29, 2008 -> 22:47:41"!

(Delta mirrorFor: #FileOutSet)
comment: 
'Simple tool to help organize file outs. Acts as a collection for classes
and method categories.

Add classes using addClass: and method categories using
addClass:category:. When adding method categories, you must add those
for class and instance side separately. When adding whole classes, just add
the instance side. File out the results using fileOutOn:.

Files out definitions of all classes before any methods are filed out to
ensure that there are no undefined symbols, even if there are circular
references between classes.'!


"May 29, 2008 -> 22:59:11"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private -  filing out' !
superclassesFor: aClass

	|superclasses|
	superclasses := Set new.
	aClass superclassesDo: [:class| superclasses add: class].
	^superclasses! !

"May 29, 2008 -> 23:24:57"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private -  filing out' !
classesForFileOut

	^classes asSortedCollection: [:class1 :class2|
			(self superclassesFor: class1) includes: class2]! !

"May 29, 2008 -> 23:25:22"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
fileOutClassHeadersOn: stream

	self classesForFileOut do: [:class|
		(self definitionWriterFor: class)
			fileOutHeaderOn: stream]! !

"May 29, 2008 -> 23:45:29"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private -  filing out' !
classesForFileOut

	^classes asSortedCollection: [:class1 :class2|
			(self superclassesFor: class2) includes: class1]! !

"May 29, 2008 -> 23:48:56"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private -  filing out' !
classesForFileOut

	^classes asSortedCollection: [:class1 :class2|
			((self superclassesFor: class1) includes: class2) not]! !

"May 29, 2008 -> 23:50:17"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
fileOutClassMethodsOn: stream

	self classesForFileOut do: [:class|
		(self definitionWriterFor: class)
			fileOutMethodsOn: stream]! !

"May 29, 2008 -> 23:58:30"!

Delta define: #BlockExceptionDesciptorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"May 29, 2008 -> 23:59:51"!

! (Delta mirrorFor: #BlockExceptionDesciptorTest) methodsFor: 'testing' !
testDefaultActionShouldInvokeDefaultActionBlock

	|exception wasInvoked|
	exception := BlockExceptionDescriptor new.
	wasInvoked := false.
	exception defaultActionBlock: [wasInvoked := true].
	exception defaultAction.
	self assert: wasInvoked! !

"May 30, 2008 -> 0:3:21"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"May 30, 2008 -> 0:3:42"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'testing' !
testDefaultActionShouldInvokeDefaultActionBlock

	|exception wasInvoked|
	exception := BlockExceptionDescriptor new.
	wasInvoked := false.
	exception defaultActionBlock: [wasInvoked := true].
	exception defaultAction.
	self assert: wasInvoked! !

"May 30, 2008 -> 0:5:41"!

(Delta mirrorFor: #BlockExceptionDesciptorTest) removeDefinitionIfFail: [] !


"May 30, 2008 -> 0:6:53"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'testing' !
testDefaultDefault

	|exception wasInvoked|
	exception := BlockExceptionDescriptor new.
	exception defaultAction! !

"May 30, 2008 -> 0:7:48"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'Running' !
setUp

	super setUp! !

"May 30, 2008 -> 0:8:5"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'exception')) !


"May 30, 2008 -> 0:8:14"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'testing' !
testDefaultDefault

	|wasInvoked|
	exception := BlockExceptionDescriptor new.
	exception defaultAction! !

"May 30, 2008 -> 0:8:25"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'testing' !
testDefaultActionShouldInvokeDefaultActionBlock

	|wasInvoked|
	exception := BlockExceptionDescriptor new.
	wasInvoked := false.
	exception defaultActionBlock: [wasInvoked := true].
	exception defaultAction.
	self assert: wasInvoked! !

"May 30, 2008 -> 0:8:52"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'Running' !
setUp

	super setUp.
	exception := BlockExceptionDescriptor new! !

"May 30, 2008 -> 0:9:0"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'testing' !
testDefaultDefault

	exception defaultAction! !

"May 30, 2008 -> 0:9:46"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'testing' !
testDefaultDefault

	self assert: exception defaultAction isNil! !

"May 30, 2008 -> 0:11:13"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'initialization' !
initialize

	defaultBlock := [nil].
	handlerBlock := [:ignore|]! !

"May 30, 2008 -> 0:11:34"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'exception descriptor' !
defaultAction

	^defaultBlock value! !

"May 30, 2008 -> 0:12:36"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'testing' !
testHandlerShouldDelegateToHandlerBlock

	|descriptor actualHandler|
	descriptor := BlockExceptionDescriptor new.
	descriptor handlerBlock: [:handler| actualHandler := handler].
	descriptor handler: #handler.
	[actualHandler == #handler] verify! !

"May 30, 2008 -> 0:14:3"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'testing' !
testHandlerShouldDelegateToHandlerBlock

	|actualHandler|
	exception handlerBlock: [:handler| actualHandler := handler].
	exception handler: #handler.
	self assert: (actualHandler == #handler)! !

"May 30, 2008 -> 0:14:56"!

(Delta mirrorFor: #BlockExceptionDescriptor) classSide removeMethod: #testHandlerShouldDelegateToHandlerBlock ifAbsent: [] !


"May 30, 2008 -> 0:14:58"!

(Delta mirrorFor: #BlockExceptionDescriptor) classSide removeMethod: #testDefaultDefault ifAbsent: [] !


"May 30, 2008 -> 0:14:59"!

(Delta mirrorFor: #BlockExceptionDescriptor) classSide removeMethod: #testDefaultActionShouldInvokeDefaultActionBlock ifAbsent: [] !


"May 30, 2008 -> 0:15:1"!

(Delta mirrorFor: #BlockExceptionDescriptor) classSide removeMethod: #test ifAbsent: [] !


"May 30, 2008 -> 0:17:9"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"May 30, 2008 -> 0:17:29"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testShouldInvokeHandlerBlockWithException

	|handled exception|
	handled := false.
	exception = Object new.
	(BlockExceptionHandler
		handleBlock: [:ex| [ex == exception] verify.
			handled := true])
		handle: exception.
	[handled] verify! !

"May 30, 2008 -> 0:18:57"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testShouldInvokeHandlerBlockWithException

	|handled exception|
	handled := false.
	exception = Object new.
	(BlockExceptionHandler
		handleBlock: [:ex| self assert: (ex == exception).
									handled := true])
		handle: exception.
	self assert: handled! !

"May 30, 2008 -> 0:22:9"!

(Delta mirrorFor: #BlockExceptionHandler) classSide removeMethod: #testShouldInvokeHandlerBlockWithException ifAbsent: [] !


"May 30, 2008 -> 0:22:11"!

(Delta mirrorFor: #BlockExceptionHandler) classSide removeMethod: #test ifAbsent: [] !


"May 30, 2008 -> 0:22:39"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"May 30, 2008 -> 0:23:8"!

! (Delta mirrorFor: #BlockExceptionSelectorTest) methodsFor: 'Testing' !
testShouldHandleWhenHandleBlockReturnsTrue

	|canHandle selector|
	selector := BlockExceptionSelector handlesBlock: [:ex| canHandle].
	canHandle := true.
	[selector handles: nil] verify.
	canHandle := false.
	[(selector handles: nil) not] verify! !

"May 30, 2008 -> 0:23:59"!

! (Delta mirrorFor: #BlockExceptionSelectorTest) methodsFor: 'Testing' !
testShouldHandleWhenHandleBlockReturnsTrue

	|canHandle selector|
	selector := BlockExceptionSelector handlesBlock: [:ex| canHandle].
	canHandle := true.
	self assert: (selector handles: nil).
	canHandle := false.
	self assert: (selector handles: nil) not! !

"May 30, 2008 -> 0:24:53"!

! (Delta mirrorFor: #BlockExceptionSelectorTest) methodsFor: 'Testing' !
testShouldHandleWhenHandleBlockReturnsTrue

	|canHandle selector|
	selector := BlockExceptionSelector handlesBlock: [:ex| canHandle].
	canHandle := true.
	self assert: (selector handles: nil).
	canHandle := false.
	self deny: (selector handles: nil)! !

"May 30, 2008 -> 0:25:36"!

! (Delta mirrorFor: #BlockExceptionSelectorTest) methodsFor: 'Testing' !
testShouldPassExceptionToHandlesBlock

	|exception selector|
	exception := Object new.
	selector := BlockExceptionSelector handlesBlock: [:ex| [ex == exception] verify].
	selector handles: exception! !

"May 30, 2008 -> 0:26:2"!

! (Delta mirrorFor: #BlockExceptionSelectorTest) methodsFor: 'Testing' !
testShouldPassExceptionToHandlesBlock

	|exception selector|
	exception := Object new.
	selector := BlockExceptionSelector handlesBlock: [:ex| self assert: (ex == exception)].
	selector handles: exception! !

"May 30, 2008 -> 0:26:11"!

! (Delta mirrorFor: #BlockExceptionSelectorTest) methodsFor: 'Testing' !
testShouldPassExceptionToHandlesBlock

	|exception selector|
	exception := Object new.
	selector := BlockExceptionSelector handlesBlock: [:ex| self assert: (ex == exception). true].
	selector handles: exception! !

"May 30, 2008 -> 0:26:25"!

! (Delta mirrorFor: #BlockExceptionSelectorTest) methodsFor: 'Testing' !
testShouldPassExceptionToHandlesBlock

	|exception selector|
	exception := Object new.
	selector := BlockExceptionSelector handlesBlock: [:ex| self assert: (ex == exception). true].
	self assert: (selector handles: exception)! !

"May 30, 2008 -> 0:27:3"!

(Delta mirrorFor: #BlockExceptionSelector) classSide removeMethod: #testShouldPassExceptionToHandlesBlock ifAbsent: [] !


"May 30, 2008 -> 0:27:6"!

(Delta mirrorFor: #BlockExceptionSelector) classSide removeMethod: #testShouldHandleWhenHandleBlockReturnsTrue ifAbsent: [] !


"May 30, 2008 -> 0:27:9"!

(Delta mirrorFor: #BlockExceptionSelector) classSide removeMethod: #test ifAbsent: [] !


"May 30, 2008 -> 0:28:57"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"May 30, 2008 -> 0:29:24"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testIsNestedShouldBeFalseWhenOuterHandlerDoesntHandle

	|result|
	[[Exception signal]
		on: Exception
		do: [:ex| result := ex isNested]]
		on: TestException
		do: [:ex|].
	[result not] verify! !

"May 30, 2008 -> 0:32:11"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testIsNestedShouldBeFalseWhenOuterHandlerDoesntHandle

	|wasHandled|
	[[Exception signal]
		on: Exception
		do: [:ex| self deny: ex isNested.
				wasHandled := true]]
		on: TestException
		do: [:ex|].
	self assert: wasHandled! !

"May 30, 2008 -> 0:32:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testIsNestedShouldBeFalseWhenOuterHandlerDoesntHandle

	|wasHandled|
	wasHandled := false.
	[[Exception signal]
		on: Exception
		do: [:ex| self deny: ex isNested.
				wasHandled := true]]
		on: TestException
		do: [:ex|].
	self assert: wasHandled! !

"May 30, 2008 -> 0:32:58"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testIsNestedShouldBeFalseWhenOuterHandlerDoesntHandle ifAbsent: [] !


"May 30, 2008 -> 0:33:16"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testIsNestedShouldBeFalseWithNoHandler

	|exception|
	exception := Exception new.
	[exception isNested not] verify! !

"May 30, 2008 -> 0:33:33"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testIsNestedShouldBeFalseWithNoHandler

	|exception|
	exception := Exception new.
	self deny: exception isNested! !

"May 30, 2008 -> 0:33:44"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testIsNestedShouldBeFalseWithNoHandler ifAbsent: [] !


"May 30, 2008 -> 0:35:16"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testIsNestedShouldBeTrueWhenOuterHandlerHandles

	|wasHandled|
	wasHandled := false.
	[[Exception signal]
		on: Exception
		do: [:ex| self assert: ex isNested.
				wasHandled:= true]]
		on: Exception
		do: [:ex| self shouldNotHappen].
	self assert: wasHandled! !

"May 30, 2008 -> 0:35:26"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testIsNestedShouldBeTrueWhenOuterHandlerHandles ifAbsent: [] !


"May 30, 2008 -> 0:36:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testIsNestedShouldBeTrueWhenOuterOuterHandlerHandles

	|wasHandled|
	wasHandled := false.
	[[[Exception signal]
		on: Exception
		do: [:ex| self assert: ex isNested.
				wasHandled := true]]
			on: TestException
			do: [:ex|]]
				on: Exception
				do: [:ex|].
	self assert: wasHandled! !

"May 30, 2008 -> 0:37:6"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testIsNestedShouldBeTrueWhenOuterOuterHandlerHandles ifAbsent: [] !


"May 30, 2008 -> 0:37:19"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable

	|outer result|
	[(TestException defaultActionBlock: [#result])
		resumable: true;
		signal]
		on: TestException
		do: [:ex| outer := ex outer.
			result := #returned].
	[result == #returned] verify.
	[outer == #result] verify.! !

"May 30, 2008 -> 0:41:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable

	|outer result|
	[(TestException defaultActionBlock: [#result])
		resumable: true;
		signal]
			on: TestException
			do: [:ex| self assert: ex outer == #result.
					result := #returned].
	self assert: result == #returned! !

"May 30, 2008 -> 0:41:58"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable

	|outer result|
	[(TestException defaultActionBlock: [#result])
		resumable: true;
		signal]
			on: TestException
			do: [:ex|
					self assert: ex outer == #result.
					result := #returned].
	self assert: result == #returned! !

"May 30, 2008 -> 0:42:28"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testOuterShouldInvokeAndReturnDefaultActionWhenResumable ifAbsent: [] !


"May 30, 2008 -> 0:42:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	[([|result|
	result := (TestException defaultActionBlock: [#result])
		signal.
	[result == #result] verify.
	result]
		on: TestException
		do: [:ex| ex outer.
			self shouldNotHappen]) == #result] verify! !

"May 30, 2008 -> 0:43:35"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	[([|result|
	result := (TestException defaultActionBlock: [#result])
		signal.
	[result == #result] verify.
	result]
		on: TestException
		do: [:ex| ex outer.
			self signalFailure: 'outer should not return']) == #result] verify! !

"May 30, 2008 -> 0:53:13"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [#defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 30, 2008 -> 1:13:13"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
handle: exception return: aReturnBlock

	^(exceptionSelector handles: exception)
		ifTrue: [	exception handler: self.
						aReturnBlock value: (handleBlock value: exception)]
		ifFalse: [nextHandler handle: exception return: aReturnBlock]! !

"May 30, 2008 -> 1:22:10"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
handle: exception return: aBlock

	aBlock value: (handleBlock value: exception)! !

"May 30, 2008 -> 1:38:49"!

Delta define: #FileOutSet as: (
(Class subclassOf: 'Object' instanceVariables: 'classes
classCategories
definitions')) !


"May 30, 2008 -> 1:39:10"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'adding' !
addDefinition: class

	definitions add: class! !

"May 30, 2008 -> 1:39:28"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private - initialization' !
initialize

	classes := Set new.
	classCategories := Dictionary new.
	definitions := Set new! !

"May 30, 2008 -> 1:39:55"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'adding' !
addDefinition: class

	(classes includes: class) ifTrue: [^self].
	definitions add: class! !

"May 30, 2008 -> 1:40:30"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'adding' !
addClass: class

	classes add: class.
	classCategories
		removeKey: class
		ifAbsent: [].
	classCategories
		removeKey: class class
		ifAbsent: [].
	definitions
		remove: class ifAbsent: []! !

"May 30, 2008 -> 1:41:33"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'adding' !
addClass: class

	classes add: class.
	classCategories
		removeKey: class
		ifAbsent: [].
	classCategories
		removeKey: class class
		ifAbsent: [].
	definitions
		remove: class
		ifAbsent: []! !

"May 30, 2008 -> 1:52:49"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private -  filing out' !
definitionsForFileOut

	|allDefinitions|
	(allDefinitions := Set new)
		addAll: classes;
		addAll: definitions.
	^allDefinitions asSortedCollection: [:class1 :class2|
			((self superclassesFor: class1) includes: class2) not]! !

"May 30, 2008 -> 1:53:21"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private -  filing out' !
definitionSortBlock

	^[:class1 :class2| ((self superclassesFor: class1) includes: class2) not]! !

"May 30, 2008 -> 1:53:45"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private -  filing out' !
definitionsForFileOut

	|allDefinitions|
	(allDefinitions := Set new)
		addAll: classes;
		addAll: definitions.
	^allDefinitions asSortedCollection: self definitionSortBlock! !

"May 30, 2008 -> 1:53:53"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private -  filing out' !
classesForFileOut

	^classes asSortedCollection: self definitionSortBlock! !

"May 30, 2008 -> 1:54:52"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private -  filing out' !
allDefinitions

	^Set new
		addAll: classes;
		addAll: definitions;
		yourself! !

"May 30, 2008 -> 1:55:18"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private -  filing out' !
definitionsForFileOut

	^self allDefinitions asSortedCollection: self definitionSortBlock! !

"May 30, 2008 -> 2:0:10"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
fileOutClassHeadersOn: stream

	self definitionsForFileOut do: [:class|
		(self definitionWriterFor: class)
			fileOutHeaderOn: stream]! !

"May 30, 2008 -> 2:11:26"!

"System saved" !
"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:40"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testPassShouldDeferToOuterHandler ifAbsent: [] !


"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:40"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testPassShouldNotReturn ifAbsent: [] !


"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:40"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:40"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:41"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:41"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:41"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:41"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:41"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:41"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:42"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:42"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:42"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:42"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:42"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:42"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:43"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:43"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
isLogging
	"By default, we're not logging failures. If you override this in 
	a subclass, make sure that you override #failureLog"
	^true
			! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable

	|outer result|
	[(TestException defaultActionBlock: [#result])
		resumable: true;
		signal]
			on: TestException
			do: [:ex|
					self assert: ex outer == #result.
					result := #returned].
	self assert: result == #returned description: 'outer did not return'! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable

	|outer result|
	[(TestException defaultActionBlock: [#result])
		resumable: true;
		signal]
			on: TestException
			do: [:ex|
					self assert: ex outer == #result description: 'outer returned wrong result'.
					result := #returned].
	self assert: result == #returned description: 'outer did not return'! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[
			[
				aTestCase runCase.
				true]
					sunitOn: self class failure
					do: [:signal |
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
								self logFailure: (signal printString).
								self errors add: aTestCase.
								signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:43"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:43"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:44"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:44"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:44"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:44"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:44"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:44"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:45"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:45"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:45"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:45"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:45"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:45"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:46"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:46"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
isLogging
	"By default, we're not logging failures. If you override this in 
	a subclass, make sure that you override #failureLog"
	^true
			! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable

	|outer result|
	[(TestException defaultActionBlock: [#result])
		resumable: true;
		signal]
			on: TestException
			do: [:ex|
					self assert: ex outer == #result.
					result := #returned].
	self assert: result == #returned description: 'outer did not return'! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable

	|outer result|
	[(TestException defaultActionBlock: [#result])
		resumable: true;
		signal]
			on: TestException
			do: [:ex|
					self assert: ex outer == #result description: 'outer returned wrong result'.
					result := #returned].
	self assert: result == #returned description: 'outer did not return'! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[
			[
				aTestCase runCase.
				true]
					sunitOn: self class failure
					do: [:signal |
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
								self logFailure: (signal printString).
								self errors add: aTestCase.
								signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:46"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:46"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:46"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:46"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:47"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:47"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:47"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:47"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:47"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:47"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:48"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:48"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:48"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:48"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:48"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:48"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
isLogging
	"By default, we're not logging failures. If you override this in 
	a subclass, make sure that you override #failureLog"
	^true
			! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable

	|outer result|
	[(TestException defaultActionBlock: [#result])
		resumable: true;
		signal]
			on: TestException
			do: [:ex|
					self assert: ex outer == #result.
					result := #returned].
	self assert: result == #returned description: 'outer did not return'! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable

	|outer result|
	[(TestException defaultActionBlock: [#result])
		resumable: true;
		signal]
			on: TestException
			do: [:ex|
					self assert: ex outer == #result description: 'outer returned wrong result'.
					result := #returned].
	self assert: result == #returned description: 'outer did not return'! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[
			[
				aTestCase runCase.
				true]
					sunitOn: self class failure
					do: [:signal |
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
								self logFailure: (signal printString).
								self errors add: aTestCase.
								signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:49"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:49"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:49"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:49"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:49"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:49"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:50"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:50"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:50"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:50"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:50"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:50"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:51"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:51"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:51"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:51"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
isLogging
	"By default, we're not logging failures. If you override this in 
	a subclass, make sure that you override #failureLog"
	^true
			! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable

	|outer result|
	[(TestException defaultActionBlock: [#result])
		resumable: true;
		signal]
			on: TestException
			do: [:ex|
					self assert: ex outer == #result.
					result := #returned].
	self assert: result == #returned description: 'outer did not return'! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable

	|outer result|
	[(TestException defaultActionBlock: [#result])
		resumable: true;
		signal]
			on: TestException
			do: [:ex|
					self assert: ex outer == #result description: 'outer returned wrong result'.
					result := #returned].
	self assert: result == #returned description: 'outer did not return'! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[
			[
				aTestCase runCase.
				true]
					sunitOn: self class failure
					do: [:signal |
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
								self logFailure: (signal printString).
								self errors add: aTestCase.
								signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[
			[
				aTestCase runCase.
				true]
					sunitOn: self class failure
					do: [:signal |
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
								[self logFailure: (signal printString)]
									suniton: Exception
									do: [].
								self errors add: aTestCase.
								signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"May 31, 2008 -> 12:22:26"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[
			[
				aTestCase runCase.
				true]
					sunitOn: self class failure
					do: [:signal |
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
								self errors add: aTestCase.
								signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"May 31, 2008 -> 12:43:54"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[
			[
				aTestCase runCase.
				true]
					sunitOn: self class failure
					do: [:signal |
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
								signal class printOn: Transcript.
								self errors add: aTestCase.
								signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"May 31, 2008 -> 12:51:15"!

"System saved" !
"June 1, 2008 -> 2:45:39"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"June 1, 2008 -> 2:45:39"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"June 1, 2008 -> 2:45:39"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"June 1, 2008 -> 2:45:39"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"June 1, 2008 -> 2:45:39"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"June 1, 2008 -> 2:45:39"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"June 1, 2008 -> 2:45:39"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"June 1, 2008 -> 2:45:39"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resumeBlock
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:40"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resumeBlock
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:40"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resumeBlock
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:40"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resumeBlock
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #Exception) methodsFor: 'private signal handling' !
installContextAndDo: aBlock
	"sets up a new context used as the target of a non-local return whenever an exception
	handling action needs to return to the signalling context. The context reference is cached
	in contextBlock. Whenever this block gets evaluated, its context will be consumed, so a
	new one needs to be set up. This is the purpose of the recursive call in the innermost block"
	|result|
	contextBlock := [:action| ^[self installContextAndDo: action]].
	result := aBlock value.
	^[result]! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeShouldReturnValueAsResultOfSignal

	[|result|
	result := TestException new
						resumable: true;
						signal.
	self assert: #resume == result]
		on: TestException
		do: [:ex| ex resume: #resume]! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
privateSignal

	resignalBlock := [:ex| ^[ex signal]].
	resumeBlock := [:result| ^[result]].
	passBlock := [^[handler pass: self]].
	^self installContextAndDo: [Processor activeProcess handle: self]! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resume: resumptionValue
"Return resumptionValue as the value of the signal message."
	contextBlock value: [resumptionValue]! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[
			[
				aTestCase runCase.
				true]
					sunitOn: self class failure
					do: [:signal |
						aTestCase printOn: Transcript.
						Transcript cr; tab; show: signal messageText.
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
								signal class printOn: Transcript.
								self errors add: aTestCase.
								signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[
			[
				aTestCase runCase.
				true]
					sunitOn: self class failure
					do: [:signal |
						aTestCase printOn: (Transcript cr; yourself).
						Transcript cr; tab; show: signal messageText.
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
								signal class printOn: Transcript.
								self errors add: aTestCase.
								signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeShouldReturnValueAsResultOfSignal

	[|result|
	result := TestException new
						resumable: true;
						signal.
	self assert: #resume == result description: result printString]
		on: TestException
		do: [:ex| ex resume: #resume]! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resume: resumptionValue
"Return resumptionValue as the value of the signal message."
	(contextBlock value: [resumptionValue]) value! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resume: resumptionValue
"Return resumptionValue as the value of the signal message."
	contextBlock value: [resumptionValue]! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #Exception) methodsFor: 'private signal handling' !
installContextAndDo: aBlock
	"sets up a new context used as the target of a non-local return whenever an exception
	handling action needs to return to the signalling context. The context reference is cached
	in contextBlock. Whenever this block gets evaluated, its context will be consumed, so a
	new one needs to be set up. This is the purpose of the recursive call in the innermost block"
	|result|
	contextBlock := [:action| ^[(self installContextAndDo: action) value]].
	result := aBlock value.
	^[result]! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldReturnResumptionValueWhenResumed

"	|wasResumed|
	wasResumed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| self assert: ex outer = 'result'.
				wasResumed := true]]
					on: TestException
					do: [:ex| ex resume: 'result'.
							self signalFailure: 'Resume should not return'].
	self assert: wasResumed"! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldReturnResumptionValueWhenResumed

	|wasResumed|
	wasResumed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| self assert: ex outer = 'result'.
				wasResumed := true]]
					on: TestException
					do: [:ex| ex resume: 'result'.
							self signalFailure: 'Resume should not return'].
	self assert: wasResumed! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldReturnResumptionValueWhenResumed

	|wasResumed|
	wasResumed := false.
	[[TestException new resumable: true; signal]
		on: TestException
		do: [:ex| self assert: ex outer = 'result'.
				wasResumed := true]]
					on: TestException
					do: [:ex| ex resume: 'result'.
							self signalFailure: 'Resume should not return'].
	self assert: wasResumed! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldReturnResumptionValueWhenResumed

	|wasResumed|
	wasResumed := false.
	[[TestException new resumable: true; signal]
		on: TestException
		do: [:ex| self assert: ex outer = 'result'.
				wasResumed := true]]
					on: TestException
					do: [:ex| ex resume: 'result'.
							self signalFailure: 'Resume should not return'].
	self assert: wasResumed description: 'not resumed'! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
outer
"Evaluate the enclosing exception action and return to here 
instead of signal if it resumes (see #resumeUnchecked:)."
	| oldHandler oldContext |
	self isResumable
		ifFalse: [self pass].
	[oldContext := contextBlock.
	self installContextAndDo: [	(oldHandler := handler)
															outer: self return: [:value| ^value]]]
		ensure: [handler := oldHandler.
						contextBlock := oldContext]! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
outer
"Evaluate the enclosing exception action and return to here 
instead of signal if it resumes (see #resumeUnchecked:)."
	| oldHandler oldContext |
	self isResumable
		ifFalse: [self pass].
	[oldContext := contextBlock.
	^self installContextAndDo: [	(oldHandler := handler)
															outer: self return: [:value| ^value]]]
		ensure: [handler := oldHandler.
						contextBlock := oldContext]! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
outer
"Evaluate the enclosing exception action and return to here 
instead of signal if it resumes (see #resumeUnchecked:)."
	| oldHandler oldContext |
	self isResumable
		ifFalse: [self pass].
	[oldContext := contextBlock.
	^self installContextAndDo: [(oldHandler := handler)
															outer: self return: [:value| ^value]]]
		ensure: [handler := oldHandler.
						contextBlock := oldContext]! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldReturnResumptionValueWhenResumed

	|wasResumed|
	wasResumed := false.
	[[TestException new resumable: true; signal]
		on: TestException
		do: [:ex| |result|
				result := ex outer.
				self assert: 'result' = result description: result printString.
				wasResumed := true]]
					on: TestException
					do: [:ex| ex resume: 'result'.
							self signalFailure: 'Resume should not return'].
	self assert: wasResumed description: 'not resumed'! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
outer
"Evaluate the enclosing exception action and return to here 
instead of signal if it resumes (see #resumeUnchecked:)."
	| oldHandler oldContext |
	self isResumable
		ifFalse: [self pass].
	[oldContext := contextBlock.
	^(self installContextAndDo: [(oldHandler := handler)
															outer: self return: [:value| ^value]]) value]
		ensure: [handler := oldHandler.
						contextBlock := oldContext]! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
privateSignal

	resignalBlock := [:ex| ^[ex signal]].
	passBlock := [^[handler pass: self]].
	^self installContextAndDo: [Processor activeProcess handle: self]! !

"June 1, 2008 -> 2:45:40"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resumeBlock
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:40"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resumeBlock
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:40"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resumeBlock
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:40"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resumeBlock
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:40"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resumeBlock
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:40"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resumeBlock
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:40"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resumeBlock
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:40"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:40"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:40"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:40"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldInvokeSurroundingHandler

	| wasPassed |
	wasPassed := false.
	[[TestException new
			signal]
		on: TestException
		do: [:ex| ex pass.
			self signalFailure: 'Pass should not return']]
				on: TestException
				do: [:ex| wasPassed := true].
	self assert: wasPassed description: 'Outer handler not invoked'! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldInvokeSurroundingHandler

	| wasPassed |
	wasPassed := false.
	[[TestException new signal]
		on: TestException
		do: [:ex| ex pass.
			self signalFailure: 'Pass should not return']]
				on: TestException
				do: [:ex| wasPassed := true].
	self assert: wasPassed description: 'Outer handler not invoked'! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldInvokeSurroundingHandler

	| wasPassed |
	wasPassed := false.
	[[TestException new signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'Pass should not return']]
				on: TestException
				do: [:ex| wasPassed := true].
	self assert: wasPassed description: 'Outer handler not invoked'! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
pass
"Yield control to the enclosing exception action for the receiver."
	contextBlock value: [handler pass: self]! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
privateSignal

	resignalBlock := [:ex| ^[ex signal]].
	^self installContextAndDo: [Processor activeProcess handle: self]! !

"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeAfterPassShouldReturnFromSignal

	| wasReturned |
	wasReturned := false.
	[[|result|
	result := TestException new resumable: true; signal.
	wasReturned := true]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'Pass should not return']]
				on: TestException
				do: [:ex| ex resume].
	self assert: wasReturned description: 'Resume did not return from signal'! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeAfterPassShouldReturnResultFromSignal

	| wasReturned |
	wasReturned := false.
	[[|result|
	result := TestException new resumable: true; signal.
	self assert: 'result' = result description: result printString.
	wasReturned := true]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'Pass should not return']]
				on: TestException
				do: [:ex| ex resume: 'result'].
	self assert: wasReturned description: 'Resume did not return from signal'! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldInvokeDefaultActionWithoutReturning

	[([|result|
	result := (TestException defaultActionBlock: [#result])
					resumable: true;
					signal.
	[result == #result] verify.
	result]
		on: TestException
		do: [:ex| ex pass.
			self shouldNotHappen]) == #result] verify! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldInvokeDefaultActionWithoutReturning

	| signalReturned |
	signalReturned := false.
	[|result|
	result := (TestException defaultActionBlock: [#result])
						resumable: true;
						signal.
	signalReturned := true]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'Pass should not return'].
	self assert: signalReturned description: 'Signal did not return'! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| |result|
										result :=  ex defaultAction.
										ex isResumable ifFalse: [self halt].
										ex resume: result]! !

"June 1, 2008 -> 2:45:41"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testPassShouldInvokeDefaultActionWithoutReturning ifAbsent: [] !


"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldInvokeDefaultActionWithoutReturning

	| signalReturned |
	signalReturned := false.
	[|result|
	result := (TestException defaultActionBlock: ['result'])
						resumable: true;
						signal.
	self assert: result = 'result' description: result printString.
	signalReturned := true]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'Pass should not return'].
	self assert: signalReturned description: 'Signal did not return'! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterTwiceShouldInvokeSurroundingHandlerTwice

	|count|	count := 0.
	[[(TestException defaultActionBlock: [-1])
		resumable: true;
		signal]
		on: TestException
		do: [:ex| ex outer.
			ex outer]]
		on: TestException
		do: [:ex| count := count + 1].
	[count == 2] verify! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterTwiceShouldInvokeSurroundingHandlerTwice

	|count|	count := 0.
	[[(TestException defaultActionBlock: [-1])
		resumable: true;
		signal]
		on: TestException
		do: [:ex| ex outer.
				ex outer]]
			on: TestException
			do: [:ex| count := count + 1].
	self assert: count == 2 description: 'Count was ', count printString! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterTwiceShouldInvokeSurroundingHandlerTwice

	|count|
	count := 0.
	[[(TestException defaultActionBlock: [-1])
		resumable: true;
		signal]
		on: TestException
		do: [:ex| ex outer.
				ex outer]]
			on: TestException
			do: [:ex| count := count + 1].
	self assert: count == 2 description: 'Count was ', count printString! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterTwiceShouldInvokeSurroundingHandlerTwice

	|count|
	count := 0.
	[[TestException new
		resumable: true;
		signal]
		on: TestException
		do: [:ex| ex outer.
				ex outer]]
			on: TestException
			do: [:ex| count := count + 1].
	self assert: count == 2 description: 'Count was ', count printString! !

"June 1, 2008 -> 2:45:41"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testOuterTwiceShouldInvokeSurroundingHandlerTwice ifAbsent: [] !


"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeShouldReturnAsValueOfOuter

	|result|
	[[Exception signal]
		on: Exception
		do: [:ex| result := ex outer]]
		on: Exception
		do: [:ex| ex resume: #result].
	[result == #result] verify! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeShouldReturnAsValueOfOuter

	|result|
	[[Exception signal]
		on: Exception
		do: [:ex| result := ex outer]]
			on: Exception
			do: [:ex| ex resume: #result].
	self assert: result == #result description: result printString! !

"June 1, 2008 -> 2:45:41"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testResumeShouldReturnAsValueOfOuter ifAbsent: [] !


"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeShouldReturnValueAsResultOfSignal

	|wasResumed|
	wasResumed := false.
	[|result|
	result := TestException new
						resumable: true;
						signal.
	self assert: #resume == result description: result printString.
	wasResumed := true]
		on: TestException
		do: [:ex| ex resume: #resume]
	self assert: wasResumed description: 'Should have resumed after signal'! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeShouldReturnValueAsResultOfSignal

	[|wasResumed|
	wasResumed := false.
	[|result|
	result := TestException new
						resumable: true;
						signal.
	self assert: #resume == result description: result printString.
	wasResumed := true]
		on: TestException
		do: [:ex| ex resume: #resume]
	self assert: wasResumed description: 'Should have resumed after signal']
		on: MessageNotUnderstood
		do: [:mnu|
				Transcript cr; show: mnu message printString.
				mnu pass]! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeShouldReturnValueAsResultOfSignal

	[|wasResumed|
	wasResumed := false.
	[|result|
	result := TestException new
						resumable: true;
						signal.
	self assert: #resume == result description: result printString.
	wasResumed := true]
		on: TestException
		do: [:ex| ex resume: #resume]
	self assert: wasResumed description: 'Should have resumed after signal']
		on: MessageNotUnderstood
		do: [:mnu| | message |
				message := mnu message.
				Transcript cr;
					show: (message receiver printString);
					cr; show: (message selector).
				mnu pass]! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeShouldReturnValueAsResultOfSignal

	[|wasResumed|
	wasResumed := false.
	[|result|
	result := TestException new
						resumable: true;
						signal.
	self assert: #resume == result description: result printString.
	wasResumed := true]
		on: TestException
		do: [:ex| ex resume: #resume].
	self assert: wasResumed description: 'Should have resumed after signal']
		on: MessageNotUnderstood
		do: [:mnu| | message |
				message := mnu message.
				Transcript cr;
					show: (message receiver printString);
					cr; show: (message selector).
				mnu pass]! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeShouldReturnValueAsResultOfSignal

	|wasResumed|
	wasResumed := false.
	[|result|
	result := TestException new
						resumable: true;
						signal.
	self assert: #resume == result description: result printString.
	wasResumed := true]
		on: TestException
		do: [:ex| ex resume: #resume].
	self assert: wasResumed description: 'Should have resumed after signal'! !

"June 1, 2008 -> 2:45:41"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testResumeShouldReturnFromSignal ifAbsent: [] !


"June 1, 2008 -> 2:45:41"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testResumeWithValueShouldReturnFromSignal ifAbsent: [] !


"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResignalAsShouldRestoreSignalEnvironment

	|log|
	log := String new writeStream.
	[[Exception signal]
		on: TestException
		do: [:ex| log nextPutAll: 'resignal']]
		on: Exception
		do: [:ex| [log nextPutAll: 'signal '.
			ex resignalAs: TestException new]
				ifCurtailed: [log nextPutAll: 'curtail ']].
	[log contents = 'signal curtail resignal'] verify! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResignalAsShouldRestoreSignalEnvironment

	|log|
	log := String new writeStream.
	[[Exception signal]
		on: TestException
		do: [:ex| log nextPutAll: 'resignal']]
			on: Exception
			do: [:ex| [log nextPutAll: 'signal '.
					ex resignalAs: TestException new]
						ifCurtailed: [log nextPutAll: 'curtail ']].
	self assert: log contents = 'signal curtail resignal' description: log contents! !

"June 1, 2008 -> 2:45:41"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testResignalAsShouldRestoreSignalEnvironment ifAbsent: [] !


"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resignalAs: replacementException
"Signal an alternative exception in place of the receiver."
	contextBlock value: [replacementException signal]! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
privateSignal

	^self installContextAndDo: [Processor activeProcess handle: self]! !

"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResignalAsShouldRestoreSignalEnvironment

	|log|
	log := String new writeStream.
	[[Exception signal]
		on: TestException
		do: [:ex| log nextPutAll: 'resignal']]
			on: Exception
			do: [:ex| [log nextPutAll: 'signal '.
							ex resignalAs: TestException new]
								ifCurtailed: [log nextPutAll: 'curtail ']].
	self assert: log contents = 'signal curtail resignal' description: log contents! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable
" This is nasty (in that it replaces the stopHandler temporarily). Not safe to do in a
  multi-processing environment!! If you can think of something better, please do!!"
	| error oldStopHandler completed |
	
	completed := Semaphore new.
	oldStopHandler := Processor stopHandler.
	[Processor stopHandler: [:process| error := process processError msg.
													completed signal].
	[[(TestException defaultActionBlock: [#defaultResult])  signal.
	self shouldNotHappen]
		on: TestException
		do: [:ex| ex outer.
				self shouldNotHappen].
	error := 'handler returned'.
	completed signal] fork,
	completed wait.
	self assert: 'Default action should not return' = error description: error printString]
		ensure: [Processor stopHandler: oldStopHandler]! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable
" This is nasty (in that it replaces the stopHandler temporarily). Not safe to do in a
  multi-processing environment!! If you can think of something better, please use it!!"
	| error oldStopHandler completed |
	
	completed := Semaphore new.
	oldStopHandler := Processor stopHandler.
	[Processor stopHandler: [:process| error := process processError msg.
													completed signal].
	[[(TestException defaultActionBlock: [#defaultResult])  signal.
	self shouldNotHappen]
		on: TestException
		do: [:ex| ex outer.
				self shouldNotHappen].
	error := 'handler returned'.
	completed signal] fork,
	completed wait.
	self assert: 'Default action should not return' = error description: error printString]
		ensure: [Processor stopHandler: oldStopHandler]! !

"June 1, 2008 -> 2:46:32"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable
" This is nasty (in that it replaces the stopHandler temporarily). Not safe to do in a
  multi-processing environment!! If you can think of something better, please use it!!"
"	| error oldStopHandler completed |
	
	completed := Semaphore new.
	oldStopHandler := Processor stopHandler.
	[Processor stopHandler: [:process| error := process processError msg.
													completed signal].
	[[(TestException defaultActionBlock: [#defaultResult])  signal.
	self shouldNotHappen]
		on: TestException
		do: [:ex| ex outer.
				self shouldNotHappen].
	error := 'handler returned'.
	completed signal] fork,
	completed wait.
	self assert: 'Default action should not return' = error description: error printString]
		ensure: [Processor stopHandler: oldStopHandler]"! !

"June 1, 2008 -> 3:2:37"!

"System saved" !
"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #MessageNotUnderstood) methodsFor: 'accessing' !
message

	^message! !

"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| |result|
										result :=  ex defaultAction.
										ex isResumable ifFalse: [self defaultActionReturnError].
										ex resume: result]! !

"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
defaultActionReturnError

	self error: 'Return from non-resumable default action is not supported'! !

"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReportErrorAfterReturnFromNonResumableDefaultAction

	| handler exception wasHandled |
	handler := BlockExceptionHandler default.
	exception := TestException defaultActionBlock: [].
	exception resumable: false.
	[handler handle: exception.
	self signalFailure: 'Handler should not return']
		on: Error
		do: [:error| self assert: 'Return from non-resumable default action is not supported' = error messageText
									description: error messageText.
				wasHandled := true].
	self assert: wasHandled description: 'Handler should report error'! !

"June 1, 2008 -> 18:29:2"!

(Delta mirrorFor: #ExceptionTest) removeMethod: #testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable ifAbsent: [] !


"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[[[aTestCase runCase.
			true]
				sunitOn: self class failure
				do: [:signal |
						aTestCase printOn: (Transcript cr; yourself).
						Transcript cr; tab; show: signal messageText.
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: MessageNotUnderstood
							do: [:signal | |message|
									message := signal message.
									message receiver printOn: (Transcript cr; yourself).
									Transcript space; show: message selector.
									signal pass]]
										sunitOn: self class error
										do: [:signal |
												signal class printOn: Transcript.
												self errors add: aTestCase.
												signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"June 1, 2008 -> 18:29:2"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable ifAbsent: [] !


"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testRetryShouldReevaluateProtectee

	|count|
	count := 0.
	[count := count + 1.
	count == 1 ifTrue:[Exception signal]]
		on: Exception
		do: [:ex| ex retry].
	self assert: count == 2 description: 'Count was ' , count printString! !

"June 1, 2008 -> 18:29:2"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testRetryShouldReevaluateProtectee ifAbsent: [] !


"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testRetryUsingShouldReplaceProtectee

	|log count|
	log := String new writeStream.
	count := 0.
	[[Exception signal]
		ensure: [log nextPutAll: 'unwind ']]
			on: Exception
			do: [:ex|
					log nextPutAll: 'handle '.
					count := count + 1.
					count = 1 ifTrue: [ex retryUsing: [log nextPutAll: 'using '.
													Exception signal]]].
	self assert: log contents = 'handle unwind using handle '
			description: log contents! !

"June 1, 2008 -> 18:29:2"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testRetryUsingShouldReplaceProtectee ifAbsent: [] !


"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testReturnShouldDelegateToHandler

	|exception handler result|
	exception := Exception new.
	handler := BlockExceptionHandler new.
	result := #invalid.
	handler returnBlock: [:value| result := value].
	exception handler: handler.
	exception return.
	self assert: result isNil description: 'Return should pass back nil'! !

"June 1, 2008 -> 18:29:2"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testReturnShouldDelegateToHandler ifAbsent: [] !


"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testSignalShouldInvokeProcessHandler

	|wasInvoked|
	wasInvoked := false.
	Processor activeProcess
		pushHandler: (LinkedExceptionHandler
										on: Exception
										do: [:ex| wasInvoked := true]).
	Exception signal.
	[self assert: wasInvoked description: 'Should invoke exception handler']
		ensure: [Processor activeProcess popHandler]! !

"June 1, 2008 -> 18:29:2"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testSignalShouldInvokeProcessHandler ifAbsent: [] !


"June 1, 2008 -> 18:29:2"!

(Delta mirrorFor: #Exception) classSide removeMethod: #test ifAbsent: [] !


"June 1, 2008 -> 18:29:2"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'instantiation' !
trueSelector

	^BlockExceptionSelector handlesBlock: [:ex| true]! !

"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'instantiation' !
falseSelector

	^BlockExceptionSelector handlesBlock: [:ex| false]! !

"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testHandlerShouldSetHandlerOnException

	|handler exception assignedHandler|
	exception := BlockExceptionDescriptor new.
	exception handlerBlock: [:handler| assignedHandler := handler].
	handler := LinkedExceptionHandler
							on: BlockExceptionSelector trueSelector
							do: [:ex| ].
	self assert: assignedHandler ~~ handler
			description: 'Handler should not have been assigned yet'.
	handler handle: exception.
	self assert: assignedHandler == handler
			description: 'Handler should have been assigned'! !

"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'instantiation' !
falseSelector

	^BlockExceptionSelector handlesBlock: [:ex| false]! !

"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'instantiation' !
trueSelector

	^BlockExceptionSelector handlesBlock: [:ex| true]! !

"June 1, 2008 -> 18:29:2"!

(Delta mirrorFor: #LinkedExceptionHandler) classSide removeMethod: #testHandlerShouldSetHandlerOnException ifAbsent: [] !


"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testPassShouldDeferToNextHandler

	|handler trueSelector exception wasPassed nextHandler|
	exception := BlockExceptionDescriptor new.
	handler := LinkedExceptionHandler
							on: BlockExceptionSelector trueSelector
							do: [:ex| ].
	nextHandler := BlockExceptionHandler handleBlock: [:ex| wasPassed := true].
	handler nextHandler: nextHandler.
	wasPassed := false.
	handler pass: exception.
	self assert: wasPassed
			description: 'Handler should defer pass to nextHandler'! !

"June 1, 2008 -> 18:29:2"!

(Delta mirrorFor: #LinkedExceptionHandler) classSide removeMethod: #testPassShouldDeferToNextHandler ifAbsent: [] !


"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testReturnShouldEvaluateReturnBlock

	|handler result |
	handler := LinkedExceptionHandler
			on: nil
			do: [:ex| ]
			return: [:returnValue| result := returnValue].
	handler return: #value.
	self assert: result == #value
			description: 'Should have invoked return'! !

"June 1, 2008 -> 18:29:2"!

(Delta mirrorFor: #LinkedExceptionHandler) classSide removeMethod: #testReturnShouldEvaluateReturnBlock ifAbsent: [] !


"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testShouldDelegateToNextHandlerWhenNoMatch

	|handled exception nextHandler|
	handled := false.
	exception := BlockExceptionDescriptor new.
	nextHandler := BlockExceptionHandler
										handleBlock: [:ex| self assert: ex == exception
																					description: 'Handler invoked with wrong exception'.
																	handled := true].
	(LinkedExceptionHandler
		on: BlockExceptionSelector falseSelector
		do: [:ex| self signalFailure: 'Should not invoke hander'])
			nextHandler: nextHandler;
			handle: exception.
	self assert: handled
			description: 'Next handler not invoked'! !

"June 1, 2008 -> 18:29:2"!

(Delta mirrorFor: #LinkedExceptionHandler) classSide removeMethod: #testShouldDelegateToNextHandlerWhenNoMatch ifAbsent: [] !


"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testShouldInvokeExceptionsDefaultActionWhenNoNextHandler

	|handled exception|
	handled := false.
	exception := BlockExceptionDescriptor new.
	exception defaultActionBlock: [handled := true].
	(LinkedExceptionHandler
		on: BlockExceptionSelector falseSelector
		do: [:ex| self shouldNotHappen])
			handle: exception.
	self assert: handled
			description: 'Default action not invoked'! !

"June 1, 2008 -> 18:29:2"!

(Delta mirrorFor: #LinkedExceptionHandler) classSide removeMethod: #testShouldInvokeExceptionsDefaultActionWhenNoNextHandler ifAbsent: [] !


"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'exception descriptor' !
isResumable

	^true! !

"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'exception descriptor' !
resume: aValue! !

"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testShouldInvokeHandleBlockWhenExceptionMatches

	|handled exception|
	handled := false.
	exception := BlockExceptionDescriptor new.
	(LinkedExceptionHandler
		on: BlockExceptionSelector trueSelector
		do: [:ex|
				self assert: ex == exception
						description: 'Handler invoked with wrong exception'.
				handled := true])
		handle: exception.
	self assert: handled
			description: 'Exception not handled by handler'! !

"June 1, 2008 -> 18:29:2"!

(Delta mirrorFor: #LinkedExceptionHandler) classSide removeMethod: #testShouldInvokeHandleBlockWhenExceptionMatches ifAbsent: [] !


"June 1, 2008 -> 18:29:2"!

(Delta mirrorFor: #LinkedExceptionHandler) classSide removeMethod: #test ifAbsent: [] !


"June 1, 2008 -> 18:29:2"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
resumeBlock: aBlock

	"resume"! !

"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
resumeBlock: aBlock

	resumeBlock := aBlock! !

"June 1, 2008 -> 18:29:3"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'exception descriptor' !
resume: aValue

	resumeBlock value: aValue! !

"June 1, 2008 -> 18:29:3"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'initialization' !
initialize

	defaultBlock := [nil].
	handlerBlock := [:ignore|].
	resumeBlock := [:ignore|]! !

"June 1, 2008 -> 18:29:3"!

(Delta mirrorFor: #Process) classSide removeMethod: #testHandleShouldInvokeDefaultAction ifAbsent: [] !


"June 1, 2008 -> 18:29:3"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testHandleShouldInvokeDefaultAction

	|exception wasInvoked|
	wasInvoked := false.
	exception := BlockExceptionDescriptor new.
	exception
		defaultActionBlock: [wasInvoked := true];
		resumeBlock: [:value|^self "force NLR to prevent problems with test infrastructure"].
	[Processor activeProcess handle: exception]
		ensure: [self assert: wasInvoked
								description: 'Default action not invoked']! !

"June 1, 2008 -> 18:29:3"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testPushedHandlerShouldDeferToDefaultHandlerWhenExceptionDoesntMatch

	|process wasInvoked exception|
	exception := BlockExceptionDescriptor new.
	exception defaultActionBlock: [wasInvoked := true].
	process := Processor activeProcess.
	process pushHandler: (LinkedExceptionHandler
														on: BlockExceptionSelector falseSelector
														do: [:ex| ]).
	wasInvoked := false.
	[[process handle: exception]
		ensure: [self assert: wasInvoked
								description: 'Default action not invoked']]
			ensure: [process popHandler]! !

"June 1, 2008 -> 18:29:3"!

(Delta mirrorFor: #Process) classSide removeMethod: #testPushHandlerShouldDeferToDefaultHandlerWhenExceptionDoesntMatch ifAbsent: [] !


"June 1, 2008 -> 18:29:3"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testPushedHandlerShouldDeferToOuterHandlerWhenExceptionDoesntMatch

	|process wasInvoked exception outerHandler|
	wasInvoked := false.
	exception := BlockExceptionDescriptor new.
	exception
		defaultActionBlock: [];
		resumeBlock: [:value|^self "force NLR to prevent problems with test infrastructure"].
	outerHandler := (LinkedExceptionHandler
										on: BlockExceptionSelector trueSelector
										do: [:ex| wasInvoked := true]).
	process := Processor activeProcess.
	process pushHandler: outerHandler.
	process pushHandler: (LinkedExceptionHandler
														on: BlockExceptionSelector falseSelector
														do: [:ex| ]).
	[[process handle: exception]
			ensure: [self assert: wasInvoked
									descriptor: 'Outer handler should have been invoked']]
				ensure: [process popHandler.
								process popHandler]
! !

"June 1, 2008 -> 18:29:49"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testPushedHandlerShouldDeferToOuterHandlerWhenExceptionDoesntMatch

	|process wasInvoked exception outerHandler|
	wasInvoked := false.
	exception := BlockExceptionDescriptor new.
	exception
		defaultActionBlock: [];
		resumeBlock: [:value|^self "force NLR to prevent problems with test infrastructure"].
	outerHandler := (LinkedExceptionHandler
										on: BlockExceptionSelector trueSelector
										do: [:ex| wasInvoked := true]).
	process := Processor activeProcess.
	process pushHandler: outerHandler.
	process pushHandler: (LinkedExceptionHandler
														on: BlockExceptionSelector falseSelector
														do: [:ex| ]).
	[[process handle: exception]
			ensure: [self assert: wasInvoked
									description: 'Outer handler should have been invoked']]
				ensure: [process popHandler.
								process popHandler]
! !

"June 1, 2008 -> 18:53:25"!

(Delta mirrorFor: #Process) classSide removeMethod: #testPushHandlerShouldDeferToOuterHandlerWhenExceptionDoesntMatch ifAbsent: [] !


"June 1, 2008 -> 18:53:46"!

"System saved" !
"June 1, 2008 -> 19:10:46"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testPushedHandlerShouldDeferToOuterHandlerWhenExceptionDoesntMatch

	|process wasInvoked exception outerHandler|
	wasInvoked := false.
	exception := BlockExceptionDescriptor new.
	exception
		defaultActionBlock: [];
		resumeBlock: [:value|^self "force NLR to prevent problems with test infrastructure"].
	outerHandler := (LinkedExceptionHandler
										on: BlockExceptionSelector trueSelector
										do: [:ex| wasInvoked := true]).
	process := Processor activeProcess.
	process pushHandler: outerHandler.
	process pushHandler: (LinkedExceptionHandler
														on: BlockExceptionSelector falseSelector
														do: [:ex| ]).
	[[process handle: exception]
			ensure: [self assert: wasInvoked
									description: 'Outer handler should have been invoked']]
				ensure: [process popHandler.
								process popHandler]! !

"June 1, 2008 -> 19:11:27"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testPushedHandlerShouldReplaceDefaultHandler

	|process exceptionSelector wasInvoked exception|
	process := Processor activeProcess.
	exception := BlockExceptionDescriptor new.
	wasInvoked := false.
	exceptionSelector := BlockExceptionSelector handlesBlock: [:ex| true].
	[process pushHandler: (LinkedExceptionHandler
							on: exceptionSelector
							do: [:ex| wasInvoked := true]).
	process handle: exception.
	[wasInvoked] verify]
		ensure: [process popHandler]! !

"June 1, 2008 -> 19:13:17"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testPushedHandlerShouldReplaceDefaultHandler

	|process wasInvoked exception|
	process := Processor activeProcess.
	exception := BlockExceptionDescriptor new.
	wasInvoked := false.
	process pushHandler: (LinkedExceptionHandler
													on: BlockExceptionSelector trueSelector
													do: [:ex| wasInvoked := true]).
	[wasInvoked := false.
	process handle: exception.
	self assert: wasInvoked description: 'Handler should be invoked']
		ensure: [process popHandler]! !

"June 1, 2008 -> 19:14:50"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testPushedHandlerShouldReplaceDefaultHandler

	|process wasInvoked exception|
	process := Processor activeProcess.
	exception := BlockExceptionDescriptor new.
	wasInvoked := false.
	process pushHandler: (LinkedExceptionHandler
													on: BlockExceptionSelector trueSelector
													do: [:ex| wasInvoked := true]).
	[wasInvoked := false.
	process handle: exception]
		ensure: [process popHandler].
	self assert: wasInvoked description: 'Handler should be invoked'! !

"June 1, 2008 -> 19:14:59"!

(Delta mirrorFor: #Process) classSide removeMethod: #testPushHandlerShouldReplaceDefaultHandler ifAbsent: [] !


"June 1, 2008 -> 19:15:1"!

(Delta mirrorFor: #Process) classSide removeMethod: #test ifAbsent: [] !


"June 1, 2008 -> 19:15:17"!

"System saved" !
"June 1, 2008 -> 20:0:30"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 1, 2008 -> 20:1:17"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testOnDoShouldInvokeDoWhenExceptionSignalled

	|wasHandled|
	wasHandled := false.
	[Exception signal]
		on: Exception
		do: [:ex| wasHandled := true].
	[wasHandled] verify
! !

"June 1, 2008 -> 20:1:53"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testOnDoShouldInvokeDoWhenExceptionSignalled

	|wasHandled|
	wasHandled := false.
	[Exception signal]
		on: Exception
		do: [:ex| wasHandled := true].
	self assert: wasHandled
			description: 'Signalled exception should be handled'
! !

"June 1, 2008 -> 20:5:40"!

(Delta mirrorFor: #BlockWithoutArguments) classSide removeMethod: #testOnDoShouldInvokeDoWhenExceptionSignalled ifAbsent: [] !


"June 1, 2008 -> 20:5:47"!

! (Delta mirrorFor: #BlockWithoutArguments) classSide methodsFor: 'testing' !
test

	| v <Boolean> |
	
	[ v := false ] ensure: [ v := true ].
	self assert: [ v ].

	[ v := false ] ifCurtailed: [ v := true ].
	self assert: [ v not ].

	self testForUnwind: [ v := false ] onUnwind: [ v := true ].
	self assert: [ v ].

	self testForEnsure: [ v := false ] onUnwind: [ v := true ].
	self assert: [ v ].
	self 
		testOnDoShouldPopHandler;
		testOnDoShouldInvokeNestedHandler! !

"June 1, 2008 -> 20:5:57"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testOnDoShouldInvokeDoWhenExceptionSignalled

	|wasHandled|
	wasHandled := false.
	[Exception signal]
		on: Exception
		do: [:ex| wasHandled := true].
	self assert: wasHandled
			description: 'Signalled exception should be handled'! !

"June 1, 2008 -> 20:6:3"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testOnDoShouldInvokeNestedHandler

	|innerInvoked falseSelector outerInvoked|
	falseSelector := BlockExceptionSelector handlesBlock: [:ex| false].
	innerInvoked := false.
	outerInvoked := false.
	[[[Exception signal]
		on: falseSelector
		do: [:ex| innerInvoked := true]]
			on: Exception
			do: [:ex| outerInvoked := true].
	[innerInvoked not] verify.
	[outerInvoked] verify]
		ensure: [Processor activeProcess resetHandlers]! !

"June 1, 2008 -> 20:8:12"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testOnDoShouldInvokeNestedHandler

	|innerInvoked outerInvoked|
	innerInvoked := false.
	outerInvoked := false.
	[[Exception signal]
		on: BlockExceptionSelector falseSelector
		do: [:ex| innerInvoked := true]]
			on: Exception
			do: [:ex| outerInvoked := true].
	self deny: innerInvoked
			description: 'Inner handler should not be invoked'.
	self assert: outerInvoked
			description: 'Outer handler should be invoked'! !

"June 1, 2008 -> 20:8:21"!

(Delta mirrorFor: #BlockWithoutArguments) classSide removeMethod: #testOnDoShouldInvokeNestedHandler ifAbsent: [] !


"June 1, 2008 -> 20:8:32"!

! (Delta mirrorFor: #BlockWithoutArguments) classSide methodsFor: 'testing' !
test

	| v <Boolean> |
	
	[ v := false ] ensure: [ v := true ].
	self assert: [ v ].

	[ v := false ] ifCurtailed: [ v := true ].
	self assert: [ v not ].

	self testForUnwind: [ v := false ] onUnwind: [ v := true ].
	self assert: [ v ].

	self testForEnsure: [ v := false ] onUnwind: [ v := true ].
	self assert: [ v ].
	self 
		testOnDoShouldPopHandler! !

"June 1, 2008 -> 20:8:46"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testOnDoShouldPopHandler

	|handlerInvoked descriptor selector defaultInvoked|
	Processor activeProcess resetHandlers.
	descriptor := BlockExceptionDescriptor new.
	descriptor defaultActionBlock: [defaultInvoked := true].
	selector := BlockExceptionSelector handlesBlock: [:ex| true].
	[Exception signal]
		on: selector
		do: [:ex| handlerInvoked := true].
	defaultInvoked := false.
	handlerInvoked := false.
	Processor activeProcess handle: descriptor.
	[handlerInvoked not] verify.
	[defaultInvoked] verify	! !

"June 1, 2008 -> 20:9:35"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testOnDoShouldPopHandler

	|handlerInvoked descriptor defaultInvoked|
	Processor activeProcess resetHandlers.
	descriptor := BlockExceptionDescriptor new.
	descriptor defaultActionBlock: [defaultInvoked := true].
	[Exception signal]
		on: BlockExceptionSelector trueSelector
		do: [:ex| handlerInvoked := true].
	defaultInvoked := false.
	handlerInvoked := false.
	Processor activeProcess handle: descriptor.
	[handlerInvoked not] verify.
	[defaultInvoked] verify	! !

"June 1, 2008 -> 20:12:59"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testOnDoShouldPopHandler

	|handlerInvoked descriptor defaultInvoked|
	descriptor := BlockExceptionDescriptor new.
	descriptor defaultActionBlock: [defaultInvoked := true].
	[Exception signal]
		on: BlockExceptionSelector trueSelector
		do: [:ex| handlerInvoked := true].
	defaultInvoked := false.
	handlerInvoked := false.
	Processor activeProcess handle: descriptor.
	self deny: handlerInvoked
			description: 'Handler should have been popped'.
	self assert: defaultInvoked
			description: 'Default action should have been invoked'! !

"June 1, 2008 -> 20:21:34"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testOnDoShouldPopHandler

	|handlerInvoked descriptor defaultInvoked|
	descriptor := BlockExceptionDescriptor new.
	descriptor
		defaultActionBlock: [defaultInvoked := true];
		resumeBlock: [:value| ^self " force NLR"].
	[Exception signal]
		on: BlockExceptionSelector trueSelector
		do: [:ex| handlerInvoked := true].
	defaultInvoked := false.
	handlerInvoked := false.
	[Processor activeProcess handle: descriptor]
		ensure: [self deny: handlerInvoked
								description: 'Handler should have been popped'.
						self assert: defaultInvoked
								description: 'Default action should have been invoked']! !

"June 1, 2008 -> 20:24:1"!

(Delta mirrorFor: #BlockWithoutArguments) classSide removeMethod: #testOnDoShouldPopHandler ifAbsent: [] !


"June 1, 2008 -> 20:24:10"!

! (Delta mirrorFor: #BlockWithoutArguments) classSide methodsFor: 'testing' !
test

	| v <Boolean> |
	
	[ v := false ] ensure: [ v := true ].
	self assert: [ v ].

	[ v := false ] ifCurtailed: [ v := true ].
	self assert: [ v not ].

	self testForUnwind: [ v := false ] onUnwind: [ v := true ].
	self assert: [ v ].

	self testForEnsure: [ v := false ] onUnwind: [ v := true ].
	self assert: [ v ]! !

"June 1, 2008 -> 20:24:41"!

"System saved" !
"June 1, 2008 -> 20:45:57"!

"System saved" !
"June 2, 2008 -> 3:49:54"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Instance Creation' !
runAll

	[self suite run printOn: (Transcript cr; yourself)] fork! !

"June 2, 2008 -> 3:50:54"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

(Delta mirrorFor: #ProcessExceptionHandlingTest)
comment: 
''!


"June 2, 2008 -> 3:50:54"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

(Delta mirrorFor: #LinkedExceptionHandlerTest)
comment: 
''!


"June 2, 2008 -> 3:50:54"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

(Delta mirrorFor: #ExceptionTest)
comment: 
''!


"June 2, 2008 -> 3:50:54"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

(Delta mirrorFor: #MessageNotUnderstoodTest)
comment: 
''!


"June 2, 2008 -> 3:50:54"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 2, 2008 -> 3:50:54"!

(Delta mirrorFor: #BlockExceptionSelector)
comment: 
'Determines whether an exception can be handled by evaluating the handlesBlock.'!


"June 2, 2008 -> 3:50:54"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

(Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest)
comment: 
''!


"June 2, 2008 -> 3:50:55"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

(Delta mirrorFor: #ErrorTest)
comment: 
''!


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 2, 2008 -> 3:50:55"!

(Delta mirrorFor: #BlockExceptionDescriptor)
comment: 
'Implements the <exceptionDescriptor> protocol from the ANSI standard using configurable actionsdefined as blocks. Intended to be used primarily as a testing aid.'!


"June 2, 2008 -> 3:50:55"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 2, 2008 -> 3:50:55"!

(Delta mirrorFor: #TestException)
comment: 
'Concrete exception class that can be used for testing'!


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

(Delta mirrorFor: #BlockExceptionSelectorTest)
comment: 
''!


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

(Delta mirrorFor: #BlockExceptionHandlerTest)
comment: 
''!


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'exception')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'exception')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'exception')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'exception')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'exception')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'exception')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'exception')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'exception')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'exception')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'exception')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'exception')) !


"June 2, 2008 -> 3:50:55"!

(Delta mirrorFor: #BlockExceptionDescriptorTest)
comment: 
''!


"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testHandleShouldInvokeDefaultAction

	|exception wasInvoked|
	wasInvoked := false.
	exception := BlockExceptionDescriptor new.
	exception
		defaultActionBlock: [wasInvoked := true];
		resumeBlock: [:value|^self "force NLR to prevent problems with test infrastructure"].
	[Processor activeProcess handle: exception]
		ensure: [self assert: wasInvoked
								description: 'Default action not invoked']! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testPushedHandlerShouldDeferToDefaultHandlerWhenExceptionDoesntMatch

	|process wasInvoked exception|
	exception := BlockExceptionDescriptor new.
	exception defaultActionBlock: [wasInvoked := true].
	process := Processor activeProcess.
	process pushHandler: (LinkedExceptionHandler
														on: BlockExceptionSelector falseSelector
														do: [:ex| ]).
	wasInvoked := false.
	[[process handle: exception]
		ensure: [self assert: wasInvoked
								description: 'Default action not invoked']]
			ensure: [process popHandler]! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testPushedHandlerShouldDeferToOuterHandlerWhenExceptionDoesntMatch

	|process wasInvoked exception outerHandler|
	wasInvoked := false.
	exception := BlockExceptionDescriptor new.
	exception
		defaultActionBlock: [];
		resumeBlock: [:value|^self "force NLR to prevent problems with test infrastructure"].
	outerHandler := (LinkedExceptionHandler
										on: BlockExceptionSelector trueSelector
										do: [:ex| wasInvoked := true]).
	process := Processor activeProcess.
	process pushHandler: outerHandler.
	process pushHandler: (LinkedExceptionHandler
														on: BlockExceptionSelector falseSelector
														do: [:ex| ]).
	[[process handle: exception]
			ensure: [self assert: wasInvoked
									description: 'Outer handler should have been invoked']]
				ensure: [process popHandler.
								process popHandler]! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testPushedHandlerShouldReplaceDefaultHandler

	|process wasInvoked exception|
	process := Processor activeProcess.
	exception := BlockExceptionDescriptor new.
	wasInvoked := false.
	process pushHandler: (LinkedExceptionHandler
													on: BlockExceptionSelector trueSelector
													do: [:ex| wasInvoked := true]).
	[wasInvoked := false.
	process handle: exception]
		ensure: [process popHandler].
	self assert: wasInvoked description: 'Handler should be invoked'! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testHandlerShouldSetHandlerOnException

	|handler exception assignedHandler|
	exception := BlockExceptionDescriptor new.
	exception handlerBlock: [:handler| assignedHandler := handler].
	handler := LinkedExceptionHandler
							on: BlockExceptionSelector trueSelector
							do: [:ex| ].
	self assert: assignedHandler ~~ handler
			description: 'Handler should not have been assigned yet'.
	handler handle: exception.
	self assert: assignedHandler == handler
			description: 'Handler should have been assigned'! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testPassShouldDeferToNextHandler

	|handler trueSelector exception wasPassed nextHandler|
	exception := BlockExceptionDescriptor new.
	handler := LinkedExceptionHandler
							on: BlockExceptionSelector trueSelector
							do: [:ex| ].
	nextHandler := BlockExceptionHandler handleBlock: [:ex| wasPassed := true].
	handler nextHandler: nextHandler.
	wasPassed := false.
	handler pass: exception.
	self assert: wasPassed
			description: 'Handler should defer pass to nextHandler'! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testReturnShouldEvaluateReturnBlock

	|handler result |
	handler := LinkedExceptionHandler
			on: nil
			do: [:ex| ]
			return: [:returnValue| result := returnValue].
	handler return: #value.
	self assert: result == #value
			description: 'Should have invoked return'! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testShouldDelegateToNextHandlerWhenNoMatch

	|handled exception nextHandler|
	handled := false.
	exception := BlockExceptionDescriptor new.
	nextHandler := BlockExceptionHandler
										handleBlock: [:ex| self assert: ex == exception
																					description: 'Handler invoked with wrong exception'.
																	handled := true].
	(LinkedExceptionHandler
		on: BlockExceptionSelector falseSelector
		do: [:ex| self signalFailure: 'Should not invoke hander'])
			nextHandler: nextHandler;
			handle: exception.
	self assert: handled
			description: 'Next handler not invoked'! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testShouldInvokeExceptionsDefaultActionWhenNoNextHandler

	|handled exception|
	handled := false.
	exception := BlockExceptionDescriptor new.
	exception defaultActionBlock: [handled := true].
	(LinkedExceptionHandler
		on: BlockExceptionSelector falseSelector
		do: [:ex| self shouldNotHappen])
			handle: exception.
	self assert: handled
			description: 'Default action not invoked'! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testShouldInvokeHandleBlockWhenExceptionMatches

	|handled exception|
	handled := false.
	exception := BlockExceptionDescriptor new.
	(LinkedExceptionHandler
		on: BlockExceptionSelector trueSelector
		do: [:ex|
				self assert: ex == exception
						description: 'Handler invoked with wrong exception'.
				handled := true])
		handle: exception.
	self assert: handled
			description: 'Exception not handled by handler'! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testDefaultActionShouldExecuteInSignallingEnvironment

	| original wasHandled |
	original := TestException defaultActionBlock: [self error: ''].
	original resumable: true.
	wasHandled := false.
	[original signal]
		on: Error
		do: [:ex| wasHandled := true].
	self assert: wasHandled! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testIsNestedShouldBeFalseWhenOuterHandlerDoesntHandle

	|wasHandled|
	wasHandled := false.
	[[Exception signal]
		on: Exception
		do: [:ex| self deny: ex isNested.
				wasHandled := true]]
		on: TestException
		do: [:ex|].
	self assert: wasHandled! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testIsNestedShouldBeFalseWithNoHandler

	|exception|
	exception := Exception new.
	self deny: exception isNested! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testIsNestedShouldBeTrueWhenOuterHandlerHandles

	|wasHandled|
	wasHandled := false.
	[[Exception signal]
		on: Exception
		do: [:ex| self assert: ex isNested.
				wasHandled:= true]]
		on: Exception
		do: [:ex| self shouldNotHappen].
	self assert: wasHandled! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testIsNestedShouldBeTrueWhenOuterOuterHandlerHandles

	|wasHandled|
	wasHandled := false.
	[[[Exception signal]
		on: Exception
		do: [:ex| self assert: ex isNested.
				wasHandled := true]]
			on: TestException
			do: [:ex|]]
				on: Exception
				do: [:ex|].
	self assert: wasHandled! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable

	|outer result|
	[(TestException defaultActionBlock: [#result])
		resumable: true;
		signal]
			on: TestException
			do: [:ex|
					self assert: ex outer == #result description: 'outer returned wrong result'.
					result := #returned].
	self assert: result == #returned description: 'outer did not return'! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldReturnResumptionValueWhenResumed

	|wasResumed|
	wasResumed := false.
	[[TestException new resumable: true; signal]
		on: TestException
		do: [:ex| |result|
				result := ex outer.
				self assert: 'result' = result description: result printString.
				wasResumed := true]]
					on: TestException
					do: [:ex| ex resume: 'result'.
							self signalFailure: 'Resume should not return'].
	self assert: wasResumed description: 'not resumed'! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterTwiceShouldInvokeSurroundingHandlerTwice

	|count|
	count := 0.
	[[TestException new
		resumable: true;
		signal]
		on: TestException
		do: [:ex| ex outer.
				ex outer]]
			on: TestException
			do: [:ex| count := count + 1].
	self assert: count == 2 description: 'Count was ', count printString! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldInvokeDefaultActionWithoutReturning

	| signalReturned |
	signalReturned := false.
	[|result|
	result := (TestException defaultActionBlock: ['result'])
						resumable: true;
						signal.
	self assert: result = 'result' description: result printString.
	signalReturned := true]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'Pass should not return'].
	self assert: signalReturned description: 'Signal did not return'! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldInvokeSurroundingHandler

	| wasPassed |
	wasPassed := false.
	[[TestException new signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'Pass should not return']]
				on: TestException
				do: [:ex| wasPassed := true].
	self assert: wasPassed description: 'Outer handler not invoked'! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResignalAsShouldRestoreSignalEnvironment

	|log|
	log := String new writeStream.
	[[Exception signal]
		on: TestException
		do: [:ex| log nextPutAll: 'resignal']]
			on: Exception
			do: [:ex| [log nextPutAll: 'signal '.
							ex resignalAs: TestException new]
								ifCurtailed: [log nextPutAll: 'curtail ']].
	self assert: log contents = 'signal curtail resignal' description: log contents! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeAfterPassShouldReturnFromSignal

	| wasReturned |
	wasReturned := false.
	[[|result|
	result := TestException new resumable: true; signal.
	wasReturned := true]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'Pass should not return']]
				on: TestException
				do: [:ex| ex resume].
	self assert: wasReturned description: 'Resume did not return from signal'! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeAfterPassShouldReturnResultFromSignal

	| wasReturned |
	wasReturned := false.
	[[|result|
	result := TestException new resumable: true; signal.
	self assert: 'result' = result description: result printString.
	wasReturned := true]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'Pass should not return']]
				on: TestException
				do: [:ex| ex resume: 'result'].
	self assert: wasReturned description: 'Resume did not return from signal'! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeShouldReturnAsValueOfOuter

	|result|
	[[Exception signal]
		on: Exception
		do: [:ex| result := ex outer]]
			on: Exception
			do: [:ex| ex resume: #result].
	self assert: result == #result description: result printString! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeShouldReturnValueAsResultOfSignal

	|wasResumed|
	wasResumed := false.
	[|result|
	result := TestException new
						resumable: true;
						signal.
	self assert: #resume == result description: result printString.
	wasResumed := true]
		on: TestException
		do: [:ex| ex resume: #resume].
	self assert: wasResumed description: 'Should have resumed after signal'! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testRetryShouldReevaluateProtectee

	|count|
	count := 0.
	[count := count + 1.
	count == 1 ifTrue:[Exception signal]]
		on: Exception
		do: [:ex| ex retry].
	self assert: count == 2 description: 'Count was ' , count printString! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testRetryUsingShouldReplaceProtectee

	|log count|
	log := String new writeStream.
	count := 0.
	[[Exception signal]
		ensure: [log nextPutAll: 'unwind ']]
			on: Exception
			do: [:ex|
					log nextPutAll: 'handle '.
					count := count + 1.
					count = 1 ifTrue: [ex retryUsing: [log nextPutAll: 'using '.
													Exception signal]]].
	self assert: log contents = 'handle unwind using handle '
			description: log contents! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testReturnShouldDelegateToHandler

	|exception handler result|
	exception := Exception new.
	handler := BlockExceptionHandler new.
	result := #invalid.
	handler returnBlock: [:value| result := value].
	exception handler: handler.
	exception return.
	self assert: result isNil description: 'Return should pass back nil'! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testSignalShouldInvokeProcessHandler

	|wasInvoked|
	wasInvoked := false.
	Processor activeProcess
		pushHandler: (LinkedExceptionHandler
										on: Exception
										do: [:ex| wasInvoked := true]).
	Exception signal.
	[self assert: wasInvoked description: 'Should invoke exception handler']
		ensure: [Processor activeProcess popHandler]! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'instantiation' !
falseSelector

	^BlockExceptionSelector handlesBlock: [:ex| false]! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'instantiation' !
new

	^super new
		initialize;
		yourself! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'instantiation' !
trueSelector

	^BlockExceptionSelector handlesBlock: [:ex| true]! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
defaultActionBlock: block

	defaultBlock := block! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
handler: handler

	handlerBlock value: handler ! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
handlerBlock: block

	handlerBlock := block ! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
resumeBlock: aBlock

	resumeBlock := aBlock! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'exception descriptor' !
defaultAction

	^defaultBlock value! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'exception descriptor' !
isResumable

	^true! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'exception descriptor' !
resume: aValue

	resumeBlock value: aValue! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'initialization' !
initialize

	defaultBlock := [nil].
	handlerBlock := [:ignore|].
	resumeBlock := [:ignore|]! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'restricted - exception handling' !
inContextDo: aBlock

	^aBlock value! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'instantiation' !
falseSelector

	^BlockExceptionSelector handlesBlock: [:ex| false]! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'instantiation' !
handlesBlock: block

	^self new
		handlesBlock: block;
		yourself! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'instantiation' !
trueSelector

	^BlockExceptionSelector handlesBlock: [:ex| true]! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionSelector) methodsFor: 'exception selector' !
handles: exceptionDescriptor

	^handlesBlock value: exceptionDescriptor! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionSelector) methodsFor: 'private - initialization' !
handlesBlock: block

	handlesBlock := block ! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testOnDoShouldInvokeDoWhenExceptionSignalled

	|wasHandled|
	wasHandled := false.
	[Exception signal]
		on: Exception
		do: [:ex| wasHandled := true].
	self assert: wasHandled
			description: 'Signalled exception should be handled'! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testOnDoShouldInvokeNestedHandler

	|innerInvoked outerInvoked|
	innerInvoked := false.
	outerInvoked := false.
	[[Exception signal]
		on: BlockExceptionSelector falseSelector
		do: [:ex| innerInvoked := true]]
			on: Exception
			do: [:ex| outerInvoked := true].
	self deny: innerInvoked
			description: 'Inner handler should not be invoked'.
	self assert: outerInvoked
			description: 'Outer handler should be invoked'! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testOnDoShouldPopHandler

	|handlerInvoked descriptor defaultInvoked|
	descriptor := BlockExceptionDescriptor new.
	descriptor
		defaultActionBlock: [defaultInvoked := true];
		resumeBlock: [:value| ^self " force NLR"].
	[Exception signal]
		on: BlockExceptionSelector trueSelector
		do: [:ex| handlerInvoked := true].
	defaultInvoked := false.
	handlerInvoked := false.
	[Processor activeProcess handle: descriptor]
		ensure: [self deny: handlerInvoked
								description: 'Handler should have been popped'.
						self assert: defaultInvoked
								description: 'Default action should have been invoked']! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testShouldUnwindExceptionHandlersWhenHandlingException

	| wasInvoked |
	wasInvoked := false.
	[[[Notification signal]
			on: Error
			do: [:ex| self signalFailure: 'Should be caught by outer handler']]
				on: Notification
				do: [:ex| self error: 'Provoke outer handler']]
					on: Error
					do: [:ex| wasInvoked:= true].
	self assert: wasInvoked description: 'Outer handler should be invoked'! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #ErrorTest) methodsFor: 'testing' !
testDefaultActionShouldPassToStopHandler

	"%todo - after signalling environment restoration test for exception"
	self halt.! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #ErrorTest) methodsFor: 'testing' !
testErrorShouldSignalError

	| wasSignalled |
	wasSignalled := true.
	[self error: 'error message'.
	self signalFailure: 'should not return']
		on: Error
		do: [:ex| wasSignalled := true.
				self assert: 'error message' = ex messageText
						description: ex messageText printString].
	self assert: wasSignalled
			description: 'Error should be signalled'! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #ErrorTest) methodsFor: 'testing' !
testShouldNotBeResumable

	self deny: Error new isResumable! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #MessageNotUnderstoodTest) methodsFor: 'testing' !
testShouldBeResumable

	self assert: MessageNotUnderstood new isResumable! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #TestException) classSide methodsFor: 'test support' !
defaultActionBlock: block

	^self new
			defaultActionBlock: block;
			yourself! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #TestException) methodsFor: 'test support' !
defaultAction	^defaultActionBlock value! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #TestException) methodsFor: 'test support' !
defaultActionBlock: block	defaultActionBlock := block! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #TestException) methodsFor: 'test support' !
isResumable	^resumable isNil		ifTrue: [false]		ifFalse: [resumable]! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #TestException) methodsFor: 'test support' !
resumable: boolean	^resumable := boolean! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionSelectorTest) methodsFor: 'Testing' !
testShouldHandleWhenHandleBlockReturnsTrue

	|canHandle selector|
	selector := BlockExceptionSelector handlesBlock: [:ex| canHandle].
	canHandle := true.
	self assert: (selector handles: nil).
	canHandle := false.
	self deny: (selector handles: nil)! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionSelectorTest) methodsFor: 'Testing' !
testShouldPassExceptionToHandlesBlock

	|exception selector|
	exception := Object new.
	selector := BlockExceptionSelector handlesBlock: [:ex| self assert: (ex == exception). true].
	self assert: (selector handles: exception)! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReportErrorAfterReturnFromNonResumableDefaultAction

	| handler exception wasHandled |
	handler := BlockExceptionHandler default.
	exception := TestException defaultActionBlock: [].
	exception resumable: false.
	[handler handle: exception.
	self signalFailure: 'Handler should not return']
		on: Error
		do: [:error| self assert: 'Return from non-resumable default action is not supported' = error messageText
									description: error messageText.
				wasHandled := true].
	self assert: wasHandled description: 'Handler should report error'! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testShouldInvokeHandlerBlockWithException

	|handled exception|
	handled := false.
	exception = Object new.
	(BlockExceptionHandler
		handleBlock: [:ex| self assert: (ex == exception).
									handled := true])
		handle: exception.
	self assert: handled! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'Running' !
setUp

	super setUp.
	exception := BlockExceptionDescriptor new! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'testing' !
testDefaultActionShouldInvokeDefaultActionBlock

	|wasInvoked|
	exception := BlockExceptionDescriptor new.
	wasInvoked := false.
	exception defaultActionBlock: [wasInvoked := true].
	exception defaultAction.
	self assert: wasInvoked! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'testing' !
testDefaultDefault

	self assert: exception defaultAction isNil! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'testing' !
testHandlerShouldDelegateToHandlerBlock

	|actualHandler|
	exception handlerBlock: [:handler| actualHandler := handler].
	exception handler: #handler.
	self assert: (actualHandler == #handler)! !

"June 2, 2008 -> 3:59:26"!

"System saved" !
"June 2, 2008 -> 22:17:16"!

Delta define: #DefinitionReader as: (
(Class subclassOf: 'DefinitionFiler' instanceVariables: 'category visibility ')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #DefinitionReader as: (
(Class subclassOf: 'DefinitionFiler' instanceVariables: 'category visibility ')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #DefinitionReader as: (
(Class subclassOf: 'DefinitionFiler' instanceVariables: 'category visibility ')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #DefinitionReader as: (
(Class subclassOf: 'DefinitionFiler' instanceVariables: 'category visibility ')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #DefinitionReader as: (
(Class subclassOf: 'DefinitionFiler' instanceVariables: 'category visibility ')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #DefinitionReader as: (
(Class subclassOf: 'DefinitionFiler' instanceVariables: 'category visibility ')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #DefinitionReader as: (
(Class subclassOf: 'DefinitionFiler' instanceVariables: 'category visibility ')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #DefinitionReader as: (
(Class subclassOf: 'DefinitionFiler' instanceVariables: 'category visibility ')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #DefinitionReader as: (
(Class subclassOf: 'DefinitionFiler' instanceVariables: 'category visibility ')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #DefinitionReader as: (
(Class subclassOf: 'DefinitionFiler' instanceVariables: 'category visibility ')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #DefinitionReader as: (
(Class subclassOf: 'DefinitionFiler' instanceVariables: 'category visibility ')) !


"June 2, 2008 -> 22:17:16"!

(Delta mirrorFor: #DefinitionReader)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"June 2, 2008 -> 22:17:16"!

Delta define: #CommentReader as: (
(Class subclassOf: 'DefinitionReader' instanceVariables: '')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #CommentReader as: (
(Class subclassOf: 'DefinitionReader' instanceVariables: '')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #CommentReader as: (
(Class subclassOf: 'DefinitionReader' instanceVariables: '')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #CommentReader as: (
(Class subclassOf: 'DefinitionReader' instanceVariables: '')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #CommentReader as: (
(Class subclassOf: 'DefinitionReader' instanceVariables: '')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #CommentReader as: (
(Class subclassOf: 'DefinitionReader' instanceVariables: '')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #CommentReader as: (
(Class subclassOf: 'DefinitionReader' instanceVariables: '')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #CommentReader as: (
(Class subclassOf: 'DefinitionReader' instanceVariables: '')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #CommentReader as: (
(Class subclassOf: 'DefinitionReader' instanceVariables: '')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #CommentReader as: (
(Class subclassOf: 'DefinitionReader' instanceVariables: '')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #CommentReader as: (
(Class subclassOf: 'DefinitionReader' instanceVariables: '')) !


"June 2, 2008 -> 22:17:16"!

(Delta mirrorFor: #CommentReader)
comment: 
''!


"June 2, 2008 -> 22:17:16"!

Delta define: #FileOutSet as: (
(Class subclassOf: 'Object' instanceVariables: 'classes
classCategories
definitions')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #FileOutSet as: (
(Class subclassOf: 'Object' instanceVariables: 'classes
classCategories
definitions')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #FileOutSet as: (
(Class subclassOf: 'Object' instanceVariables: 'classes
classCategories
definitions')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #FileOutSet as: (
(Class subclassOf: 'Object' instanceVariables: 'classes
classCategories
definitions')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #FileOutSet as: (
(Class subclassOf: 'Object' instanceVariables: 'classes
classCategories
definitions')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #FileOutSet as: (
(Class subclassOf: 'Object' instanceVariables: 'classes
classCategories
definitions')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #FileOutSet as: (
(Class subclassOf: 'Object' instanceVariables: 'classes
classCategories
definitions')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #FileOutSet as: (
(Class subclassOf: 'Object' instanceVariables: 'classes
classCategories
definitions')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #FileOutSet as: (
(Class subclassOf: 'Object' instanceVariables: 'classes
classCategories
definitions')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #FileOutSet as: (
(Class subclassOf: 'Object' instanceVariables: 'classes
classCategories
definitions')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #FileOutSet as: (
(Class subclassOf: 'Object' instanceVariables: 'classes
classCategories
definitions')) !


"June 2, 2008 -> 22:17:16"!

(Delta mirrorFor: #FileOutSet)
comment: 
'Simple tool to help organize file outs. Acts as a collection for classes
and method categories.

Add classes using addClass: and method categories using
addClass:category:. When adding method categories, you must add those
for class and instance side separately. When adding whole classes, just add
the instance side. File out the results using fileOutOn:.

Files out definitions of all classes before any methods are filed out to
ensure that there are no undefined symbols, even if there are circular
references between classes.'!


"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #DefinitionReader) classSide methodsFor: 'Unclassified' !
for: m <Mirror> category: c <Symbol>  ^ <Instance>
	^(self for: m) category: c
! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #DefinitionReader) methodsFor: 'Unclassified' !
category ^ <Str>
	^category isNil 
		ifTrue: ['Unclassified']
		ifFalse: [category]
! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #DefinitionReader) methodsFor: 'Unclassified' !
category: c <Str>
	category := c.
	('*private*' match: c)
		ifTrue: [ visibility := #private ]
		ifFalse: [ visibility := #public ]
! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #DefinitionReader) methodsFor: 'Unclassified' !
fileInFrom: stream <ReadStream>
	| source <String> |
	[(source := stream nextChunk) isEmpty]
		whileFalse: [self fileInMethod: source].
! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #DefinitionReader) methodsFor: 'Unclassified' !
fileInMethod: source <Str>
	| pt <ParseTree> ast <DeltaMethod> |
	pt := self mirror addMethod: source visibility: self visibility category: self category ifFail: [ :msg <String> :pos <Int> |
		^Transcript 
			nextPutAll: '"<< Method filein error in ';
			nextPutAll: self mirror name; 
			nextPutAll: ' category ';
			nextPutAll: self category; 
			nextPut: $"; cr;
			nextPutAll: (source copyFrom: 1 to: pos); cr;
			nextPutAll: '"<< ';
			nextPutAll: msg;
			nextPutAll: ' <<"'; cr;
			nextPutAll: (source copyFrom: pos + 1 to: source size); cr ].
	
	ast := pt body.
	ast clearBody. 			"Clear the body part of the ast. 
											This will go away once the type information no longer stores DeltaMethods."
! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #DefinitionReader) methodsFor: 'Unclassified' !
visibility ^ <Symbol>
	^visibility! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #CommentReader) methodsFor: 'Unclassified' !
fileInFrom: stream <ReadStream>

	self mirror comment: stream nextChunk! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #FileOutSet) classSide methodsFor: 'instance creation' !
new

	^(super new)
		initialize;
		yourself! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'adding' !
addClass: class

	classes add: class.
	classCategories
		removeKey: class
		ifAbsent: [].
	classCategories
		removeKey: class class
		ifAbsent: [].
	definitions
		remove: class
		ifAbsent: []! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'adding' !
addClass: class category: category

	(classes includes: class)
		ifTrue: [^self].
	classCategories
		at: class
		ifPresent: [:categories| categories add: category]
		ifAbsentPut: [Set with: category]! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'adding' !
addDefinition: class

	(classes includes: class) ifTrue: [^self].
	definitions add: class! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
definitionWriterFor: class

	^(DefinitionWriter for: (ClassMirror on: class))! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
fileOutCategoriesOn: stream

	classCategories keysAndValuesDo: [:class :categories|
		| definitionWriter |
		definitionWriter := self definitionWriterFor: class.
		categories do: [:category|
			definitionWriter fileOutCategory: category on: stream]]! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
fileOutClassHeadersOn: stream

	self definitionsForFileOut do: [:class|
		(self definitionWriterFor: class)
			fileOutHeaderOn: stream]! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
fileOutClassMethodsOn: stream

	self classesForFileOut do: [:class|
		(self definitionWriterFor: class)
			fileOutMethodsOn: stream]! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
fileOutOn: stream

	self fileOutClassHeadersOn: stream.
	self fileOutClassMethodsOn: stream.
	self fileOutCategoriesOn: stream! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private -  filing out' !
allDefinitions

	^Set new
		addAll: classes;
		addAll: definitions;
		yourself! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private -  filing out' !
classSortBlock

	^[:class1 :class2| ((self superclassesFor: class2) includes: class1)
											or: [class1 name <= class2 name
														and: [((self superclassesFor: class1) includes: class2) not]]]! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private -  filing out' !
classesForFileOut

	^classes asSortedCollection: self classSortBlock! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private -  filing out' !
definitionsForFileOut

	^self allDefinitions asSortedCollection: self classSortBlock! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private -  filing out' !
superclassesFor: aClass

	|superclasses|
	superclasses := Set new.
	aClass superclassesDo: [:class| superclasses add: class].
	^superclasses! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private - initialization' !
initialize

	classes := Set new.
	classCategories := Dictionary new.
	definitions := Set new! !

"June 2, 2008 -> 22:17:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 2, 2008 -> 22:17:22"!

(Delta mirrorFor: #BlockExceptionHandler)
comment: 
'Exception handler for an exception. Handles the exception by invoking its handleBlock.'!


"June 2, 2008 -> 22:17:22"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 2, 2008 -> 22:17:22"!

(Delta mirrorFor: #Exception)
comment: 
'Base class of the exception hierarchy. Implements the core of the ANSI exception handling protocols'!


"June 2, 2008 -> 22:17:22"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

(Delta mirrorFor: #Error)
comment: 
''!


"June 2, 2008 -> 22:17:22"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 2, 2008 -> 22:17:22"!

(Delta mirrorFor: #LinkedExceptionHandler)
comment: 
'Exception handler for an exception. Invokes its handleBlock when asked to handle an exceptionthat matches its exceptionSelector. If the exception does not match its exceptionSelector it passesthe exception on to the nextHandler. If the nextHandler is undefined signal an UnhandledExceptionError.This class is internal to the exception handling framework. There should be no need for code outside of thisframework to interact with instances of ExceptionHandler.'!


"June 2, 2008 -> 22:17:22"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 2, 2008 -> 22:17:22"!

(Delta mirrorFor: #MessageNotUnderstood)
comment: 
''!


"June 2, 2008 -> 22:17:22"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

(Delta mirrorFor: #Notification)
comment: 
''!


"June 2, 2008 -> 22:17:22"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 2, 2008 -> 22:17:22"!

(Delta mirrorFor: #Process)
comment: 
'Tags: %BlueBook %User

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license
'!


"June 2, 2008 -> 22:17:22"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| 
										ex inContextDo: [|result|
																		result :=  ex defaultAction.
																		ex isResumable ifFalse: [self defaultActionReturnError].
																		ex resume: result]]! !

"June 2, 2008 -> 22:17:22"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
defaultActionReturnError

	self error: 'Return from non-resumable default action is not supported'! !

"June 2, 2008 -> 22:17:22"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
handleBlock: block

	^self new
		handleBlock: block;
		yourself! !

"June 2, 2008 -> 22:17:22"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
new

	^super new initialize! !

"June 2, 2008 -> 22:17:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
canHandleSignal: exception

	^false! !

"June 2, 2008 -> 22:17:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
handle: exception

	^handleBlock value: exception! !

"June 2, 2008 -> 22:17:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
handle: exception return: aBlock

	aBlock value: (handleBlock value: exception)! !

"June 2, 2008 -> 22:17:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
nextHandler

	^nil! !

"June 2, 2008 -> 22:17:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
nextHandler: ignored! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
pass: exception

	passBlock value: exception! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
passBlock: block

	passBlock := block! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
return: value

	returnBlock value: value! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
returnBlock: block

	returnBlock := block! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'private initialization' !
handleBlock: block

	handleBlock := block! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'private initialization' !
initialize

	handleBlock := [:exception|].
	passBlock := [:exception|].! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'Camp Smalltalk' !
sunitSignalWith: aString
  
        ^self signal: aString! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionInstantiator' !
signal
"Signal the occurrence of an exceptional condition."
	^ self new signal! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionInstantiator' !
signal: signalerText
"Signal the occurrence of an exceptional condition with a specified textual description."
	^ self new signal: signalerText! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionSelector' !
, anotherException
"Create an exception set."
"
	^ExceptionSet new
		add: self;
		add: anotherException;
		yourself"! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionSelector' !
handles: exception
"Determine whether an exception handler will accept a signaled exception."
	^ exception isKindOf: self! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'Camp Smalltalk' !
sunitExitWith: aValue
 
        self return: aValue! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'exceptionBuilder' !
tag: t
"This message is not specified in the ANSI protocol,
but that looks like an oversight because #tag is specified,
and the spec states that the signaler may store the tag value."
	tag := t! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'exceptionDescription' !
tag
"Return an exception's tag value."
	^tag == nil
		ifTrue: [self messageText]
		ifFalse: [tag]! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
isNested
"Determine whether the current exception handler is within 
the scope of another handler for the same exception."
	^ handler notNil and: [handler nextHandler canHandleSignal: self]! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
outer
"Evaluate the enclosing exception action and return to here 
instead of signal if it resumes (see #resumeUnchecked:)."
	| oldHandler oldContext |
	self isResumable
		ifFalse: [self pass].
	[oldContext := contextBlock.
	^(self installContextAndDo: [(oldHandler := handler)
															outer: self return: [:value| ^value]]) value]
		ensure: [handler := oldHandler.
						contextBlock := oldContext]! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
pass
"Yield control to the enclosing exception action for the receiver."
	contextBlock value: [handler pass: self]! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resignalAs: replacementException
"Signal an alternative exception in place of the receiver."
	contextBlock value: [replacementException signal]! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resume
"Return from the message that signaled the receiver."
	self resume: nil! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resume: resumptionValue
"Return resumptionValue as the value of the signal message."
	contextBlock value: [resumptionValue]! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
retry
"Abort an exception handler and re-evaluate its protected block."
	handler retry! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
retryUsing: alternativeBlock
"Abort an exception handler and evaluate a new block 
in place of the handler's protected block."
	handler retryUsing: alternativeBlock! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
return
"Return nil as the value of the block protected 
by the active exception handler."
	self return: nil! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
return: returnValue
"Return the argument as the value of the block protected 
by the active exception handler."
	handler return: returnValue! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
description
"Return a textual description of the exception."
	| desc mt |
	desc := self class name asString.
	^(mt := self messageText) == nil
		ifTrue: [desc]
		ifFalse: [desc, ': ', mt]! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
messageText
"Return an exception's message text."
	^messageText! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
printOn: stream

	stream nextPutAll: self description! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
defaultAction
"The default action taken if the exception is signaled."
	self subclassResponsibility! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
handler: aHandler

	handler := aHandler! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
isResumable
"Determine whether an exception is resumable."
	^ true! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'private signal handling' !
installContextAndDo: aBlock
	"sets up a new context used as the target of a non-local return whenever an exception
	handling action needs to return to the signalling context. The context reference is cached
	in contextBlock. Whenever this block gets evaluated, its context will be consumed, so a
	new one needs to be set up. This is the purpose of the recursive call in the innermost block"
	|result|
	contextBlock := [:action| ^[(self installContextAndDo: action) value]].
	result := aBlock value.
	^[result]! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'restricted exception handling' !
inContextDo: aBlock

	contextBlock isNil
		ifTrue: [^aBlock value].
	contextBlock value: aBlock! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
messageText: signalerText
"Set an exception's message text."
	messageText := signalerText! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
privateSignal

	^self installContextAndDo: [Processor activeProcess handle: self]! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
signal

	^self privateSignal value! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
signal: signalerText
"Signal the occurrence of an exceptional condition with a 
specified textual description."
	self messageText: signalerText.
	^ self signal! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Error) methodsFor: 'exception descriptor' !
isResumable

	^false! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Error) methodsFor: 'priv handling' !
defaultAction

	Processor stopWithError: (ProcessExplicitError new msg: messageText)! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'exceptionBuilder' !
on: anExceptionSelector do: handleBlock

	^self new
		on: anExceptionSelector
		do: handleBlock
		return: [:value|]
		outer: nil;
		yourself! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'exceptionBuilder' !
on: anExceptionSelector do: handleBlock return: returnBlock

	^self new
		on: anExceptionSelector
		do: handleBlock
		return: returnBlock
		outer: nil;
		yourself! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'exceptionBuilder' !
on: anExceptionSelector do: handleBlock return: returnBlock outer: outerBlock

	^self new
		on: anExceptionSelector
		do: handleBlock
		return: returnBlock
		outer: outerBlock;
		yourself! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
canHandleSignal: exception

	^(exceptionSelector handles: exception)
		or: [nextHandler notNil
			and: [nextHandler canHandleSignal: exception]]! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
handle: exception

	self handle: exception
		return: returnBlock! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
handle: exception return: aReturnBlock

	Processor activeProcess popHandler.
	[^(exceptionSelector handles: exception)
		ifTrue: [	exception handler: self.
						aReturnBlock value: (handleBlock value: exception)]
		ifFalse: [nextHandler handle: exception return: aReturnBlock]]
			ensure: [Processor activeProcess pushHandler: self]! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
nextHandler

	^nextHandler! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
outer: exception return: aReturnBlock

	^nextHandler handle: exception return: aReturnBlock! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
pass: exception

	^nextHandler handle: exception! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
protect: aBlock

	Processor activeProcess pushHandler: self.
	^[(self evaluateProtectee: aBlock) value]
		ensure: [Processor activeProcess popHandler]! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
retry

	retryBlock value! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
retryUsing: aBlock

	protectee := aBlock.
	retryBlock value! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
return: aValue

	returnBlock value: aValue! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
nextHandler: exceptionHandler

	nextHandler := exceptionHandler ! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #MessageNotUnderstood) classSide methodsFor: 'instance creation' !
message: aMessage

	^self new message: aMessage; yourself! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #MessageNotUnderstood) methodsFor: 'accessing' !
message

	^message! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #MessageNotUnderstood) methodsFor: 'exception descriptor' !
isResumable

	^true! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #MessageNotUnderstood) methodsFor: 'priv handling' !
defaultAction

	Processor stopWithError: (ProcessDoesNotUnderstandError new message: message)! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #MessageNotUnderstood) methodsFor: 'private initialization' !
message: aMessage

	message := aMessage! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handle: exception

	^self handlerChain handle: exception! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
popHandler

	handlerChain := self handlerChain nextHandler ! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
pushHandler: handler

	handler nextHandler: self handlerChain.
	handlerChain := handler ! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
resetHandlers

	handlerChain := nil

! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
doesNotUnderstand: m <Message> ^<BottomType>
	"Processor stopWithError: (ProcessDoesNotUnderstandError new message: m)"
	(MessageNotUnderstood message: m) signal! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
error: msg <Str> ^<BottomType>

	"Processor stopWithError: (ProcessExplicitError new msg: msg)"
	Error signal: msg! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
shouldNotHappen ^<BottomType>

	self error: 'This shouldn''t happen'.! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
shouldNotImplement ^<BottomType>

	self error: 'A message that cannot be supported by this class has been sent to an instance'.! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
subclassResponsibility ^<BottomType>

	"Note: In the Strongtalk language, a method whose body consists of only 
	 'self subclassResponsibility' is considered a declaration, which subclasses
	  must implement for concrete subclasses"

	self error: 'A message that should be implemented but is not has been sent to this object'.! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
unimplemented ^<BottomType>

	self error: 'A hook for unimplemented code has been encountered'! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'exceptions' !
on: exception do: handlerBlock

	^(LinkedExceptionHandler
		on: exception
		do: handlerBlock
		return: [:value | ^ value]) protect: self
! !

"June 2, 2008 -> 22:23:31"!

Delta define: #AbstractExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 22:24:26"!

! (Delta mirrorFor: #AbstractExceptionHandlingTest) methodsFor: 'Running' !
tearDown

	Processor activeProcess resetHandlers! !

"June 2, 2008 -> 22:24:52"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'Running' !
tearDown

	Processor activeProcess resetHandlers! !

"June 2, 2008 -> 22:25:2"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
tearDown

	Processor activeProcess resetHandlers! !

"June 2, 2008 -> 22:25:12"!

! (Delta mirrorFor: #BlockExceptionSelectorTest) methodsFor: 'Testing' !
tearDown

	Processor activeProcess resetHandlers! !

"June 2, 2008 -> 22:25:24"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
tearDown

	Processor activeProcess resetHandlers! !

"June 2, 2008 -> 22:25:34"!

! (Delta mirrorFor: #ErrorTest) methodsFor: 'testing' !
tearDown

	Processor activeProcess resetHandlers! !

"June 2, 2008 -> 22:25:52"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
tearDown

	Processor activeProcess resetHandlers! !

"June 2, 2008 -> 22:25:59"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
tearDown

	Processor activeProcess resetHandlers! !

"June 2, 2008 -> 22:26:8"!

! (Delta mirrorFor: #MessageNotUnderstoodTest) methodsFor: 'testing' !
tearDown

	Processor activeProcess resetHandlers! !

"June 2, 2008 -> 22:26:18"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
tearDown

	Processor activeProcess resetHandlers! !

"June 2, 2008 -> 22:28:21"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:21"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:21"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:21"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:21"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:21"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:21"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:21"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:21"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:21"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:21"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:31"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:31"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:31"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:31"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:31"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:31"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:31"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:31"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:31"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:31"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:31"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:42"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:42"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:42"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:42"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:42"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:42"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:42"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:42"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:42"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:42"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:42"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:49"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:49"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:49"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:49"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:49"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:49"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:49"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:49"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:49"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:49"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:49"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:9"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:9"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:9"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:9"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:9"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:9"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:9"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:9"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:9"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:9"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:9"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:15"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:15"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:15"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:15"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:15"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:15"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:15"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:15"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:15"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:15"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:15"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:21"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:21"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:21"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:21"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:21"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:21"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:21"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:21"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:21"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:21"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:21"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:27"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:27"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:27"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:27"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:27"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:27"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:27"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:27"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:27"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:27"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:27"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:34"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 2, 2008 -> 22:29:34"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 2, 2008 -> 22:29:34"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 2, 2008 -> 22:29:34"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 2, 2008 -> 22:29:34"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 2, 2008 -> 22:29:34"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 2, 2008 -> 22:29:34"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 2, 2008 -> 22:29:34"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 2, 2008 -> 22:29:34"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 2, 2008 -> 22:29:34"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 2, 2008 -> 22:29:34"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 2, 2008 -> 22:30:18"!

(Delta mirrorFor: #BlockExceptionDescriptorTest) removeMethod: #tearDown ifAbsent: [] !


"June 2, 2008 -> 22:31:3"!

! (Delta mirrorFor: #AbstractExceptionHandlingTest) classSide methodsFor: 'Testing' !
isAbstract

	^true! !

"June 2, 2008 -> 22:31:17"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #tearDown ifAbsent: [] !


"June 2, 2008 -> 22:31:33"!

(Delta mirrorFor: #BlockExceptionSelectorTest) removeMethod: #tearDown ifAbsent: [] !


"June 2, 2008 -> 22:31:40"!

(Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) removeMethod: #tearDown ifAbsent: [] !


"June 2, 2008 -> 22:31:46"!

(Delta mirrorFor: #ErrorTest) removeMethod: #tearDown ifAbsent: [] !


"June 2, 2008 -> 22:31:53"!

(Delta mirrorFor: #ExceptionTest) removeMethod: #tearDown ifAbsent: [] !


"June 2, 2008 -> 22:31:59"!

(Delta mirrorFor: #LinkedExceptionHandlerTest) removeMethod: #tearDown ifAbsent: [] !


"June 2, 2008 -> 22:32:6"!

(Delta mirrorFor: #MessageNotUnderstoodTest) removeMethod: #tearDown ifAbsent: [] !


"June 2, 2008 -> 22:32:12"!

(Delta mirrorFor: #ProcessExceptionHandlingTest) removeMethod: #tearDown ifAbsent: [] !


"June 2, 2008 -> 22:33:32"!

"System saved" !
"June 3, 2008 -> 11:34:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 3, 2008 -> 11:34:13"!

(Delta mirrorFor: #BlockExceptionHandler)
comment: 
'Exception handler for an exception. Handles the exception by invoking its handleBlock.'!


"June 3, 2008 -> 11:34:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:34:13"!

(Delta mirrorFor: #Exception)
comment: 
'Base class of the exception hierarchy. Implements the core of the ANSI exception handling protocols'!


"June 3, 2008 -> 11:34:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:13"!

(Delta mirrorFor: #Error)
comment: 
''!


"June 3, 2008 -> 11:34:13"!

Delta define: #Halt as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"June 3, 2008 -> 11:34:13"!

(Delta mirrorFor: #Halt)
comment: 
''!


"June 3, 2008 -> 11:34:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 3, 2008 -> 11:34:13"!

(Delta mirrorFor: #LinkedExceptionHandler)
comment: 
'Exception handler for an exception. Invokes its handleBlock when asked to handle an exceptionthat matches its exceptionSelector. If the exception does not match its exceptionSelector it passesthe exception on to the nextHandler. If the nextHandler is undefined signal an UnhandledExceptionError.This class is internal to the exception handling framework. There should be no need for code outside of thisframework to interact with instances of ExceptionHandler.'!


"June 3, 2008 -> 11:34:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 3, 2008 -> 11:34:13"!

(Delta mirrorFor: #MessageNotUnderstood)
comment: 
''!


"June 3, 2008 -> 11:34:13"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:14"!

(Delta mirrorFor: #Notification)
comment: 
''!


"June 3, 2008 -> 11:34:14"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 3, 2008 -> 11:34:14"!

(Delta mirrorFor: #Process)
comment: 
'Tags: %BlueBook %User

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license
'!


"June 3, 2008 -> 11:34:14"!

Delta define: #ZeroDivide as: (
(Class subclassOf: 'Error' instanceVariables: 'dividend')) !


"June 3, 2008 -> 11:34:14"!

(Delta mirrorFor: #ZeroDivide)
comment: 
''!


"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| 
										ex inContextDo: [|result|
																		result :=  ex defaultAction.
																		ex isResumable ifFalse: [self defaultActionReturnError].
																		ex resume: result]]! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
defaultActionReturnError

	self error: 'Return from non-resumable default action is not supported'! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
handleBlock: block

	^self new
		handleBlock: block;
		yourself! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
new

	^super new initialize! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
canHandleSignal: exception

	^false! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
handle: exception

	^handleBlock value: exception! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
handle: exception return: aBlock

	aBlock value: (handleBlock value: exception)! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
nextHandler

	^nil! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
nextHandler: ignored! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
pass: exception

	passBlock value: exception! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
passBlock: block

	passBlock := block! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
return: value

	returnBlock value: value! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
returnBlock: block

	returnBlock := block! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'private initialization' !
handleBlock: block

	handleBlock := block! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'private initialization' !
initialize

	handleBlock := [:exception|].
	passBlock := [:exception|].! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'Camp Smalltalk' !
sunitSignalWith: aString
  
        ^self signal: aString! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionInstantiator' !
signal
"Signal the occurrence of an exceptional condition."
	^ self new signal! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionInstantiator' !
signal: signalerText
"Signal the occurrence of an exceptional condition with a specified textual description."
	^ self new signal: signalerText! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionSelector' !
, anotherException
"Create an exception set."
"
	^ExceptionSet new
		add: self;
		add: anotherException;
		yourself"! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionSelector' !
handles: exception
"Determine whether an exception handler will accept a signaled exception."
	^ exception isKindOf: self! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'Camp Smalltalk' !
sunitExitWith: aValue
 
        self return: aValue! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'exceptionBuilder' !
tag: t
"This message is not specified in the ANSI protocol,
but that looks like an oversight because #tag is specified,
and the spec states that the signaler may store the tag value."
	tag := t! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'exceptionDescription' !
tag
"Return an exception's tag value."
	^tag == nil
		ifTrue: [self messageText]
		ifFalse: [tag]! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
isNested
"Determine whether the current exception handler is within 
the scope of another handler for the same exception."
	^ handler notNil and: [handler nextHandler canHandleSignal: self]! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
outer
"Evaluate the enclosing exception action and return to here 
instead of signal if it resumes (see #resumeUnchecked:)."
	| oldHandler oldContext |
	self isResumable
		ifFalse: [self pass].
	[oldContext := contextBlock.
	^(self installContextAndDo: [(oldHandler := handler)
															outer: self return: [:value| ^value]]) value]
		ensure: [handler := oldHandler.
						contextBlock := oldContext]! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
pass
"Yield control to the enclosing exception action for the receiver."
	contextBlock value: [handler pass: self]! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resignalAs: replacementException
"Signal an alternative exception in place of the receiver."
	contextBlock value: [replacementException signal]! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resume
"Return from the message that signaled the receiver."
	self resume: nil! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resume: resumptionValue
"Return resumptionValue as the value of the signal message."
	contextBlock value: [resumptionValue]! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
retry
"Abort an exception handler and re-evaluate its protected block."
	handler retry! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
retryUsing: alternativeBlock
"Abort an exception handler and evaluate a new block 
in place of the handler's protected block."
	handler retryUsing: alternativeBlock! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
return
"Return nil as the value of the block protected 
by the active exception handler."
	self return: nil! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
return: returnValue
"Return the argument as the value of the block protected 
by the active exception handler."
	handler return: returnValue! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
description
"Return a textual description of the exception."
	| desc mt |
	desc := self class name asString.
	^(mt := self messageText) == nil
		ifTrue: [desc]
		ifFalse: [desc, ': ', mt]! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
messageText
"Return an exception's message text."
	^messageText! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
printOn: stream

	stream nextPutAll: self description! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
defaultAction
"The default action taken if the exception is signaled."
	self subclassResponsibility! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
handler: aHandler

	handler := aHandler! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
isResumable
"Determine whether an exception is resumable."
	^ true! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'private signal handling' !
installContextAndDo: aBlock
	"sets up a new context used as the target of a non-local return whenever an exception
	handling action needs to return to the signalling context. The context reference is cached
	in contextBlock. Whenever this block gets evaluated, its context will be consumed, so a
	new one needs to be set up. This is the purpose of the recursive call in the innermost block"
	|result|
	contextBlock := [:action| ^[(self installContextAndDo: action) value]].
	result := aBlock value.
	^[result]! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'restricted exception handling' !
inContextDo: aBlock

	contextBlock isNil
		ifTrue: [^aBlock value].
	contextBlock value: aBlock! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
messageText: signalerText
"Set an exception's message text."
	messageText := signalerText! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
privateSignal

	^self installContextAndDo: [Processor activeProcess handle: self]! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
signal

	^self privateSignal value! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
signal: signalerText
"Signal the occurrence of an exceptional condition with a 
specified textual description."
	self messageText: signalerText.
	^ self signal! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Error) methodsFor: 'exception descriptor' !
isResumable

	^false! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Error) methodsFor: 'priv handling' !
defaultAction

	Processor stopWithError: (ProcessExplicitError new msg: messageText)! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Halt) methodsFor: 'testing' !
defaultAction

		Processor stopWithError: ProcessHaltError new! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Halt) methodsFor: 'testing' !
isResumable

	^true! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'exceptionBuilder' !
on: anExceptionSelector do: handleBlock

	^self new
		on: anExceptionSelector
		do: handleBlock
		return: [:value|]
		outer: nil;
		yourself! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'exceptionBuilder' !
on: anExceptionSelector do: handleBlock return: returnBlock

	^self new
		on: anExceptionSelector
		do: handleBlock
		return: returnBlock
		outer: nil;
		yourself! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'exceptionBuilder' !
on: anExceptionSelector do: handleBlock return: returnBlock outer: outerBlock

	^self new
		on: anExceptionSelector
		do: handleBlock
		return: returnBlock
		outer: outerBlock;
		yourself! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
canHandleSignal: exception

	^(exceptionSelector handles: exception)
		or: [nextHandler notNil
			and: [nextHandler canHandleSignal: exception]]! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
handle: exception

	self handle: exception
		return: returnBlock! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
handle: exception return: aReturnBlock

	Processor activeProcess popHandler.
	[^(exceptionSelector handles: exception)
		ifTrue: [	exception handler: self.
						aReturnBlock value: (handleBlock value: exception)]
		ifFalse: [nextHandler handle: exception return: aReturnBlock]]
			ensure: [Processor activeProcess pushHandler: self]! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
nextHandler

	^nextHandler! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
outer: exception return: aReturnBlock

	^nextHandler handle: exception return: aReturnBlock! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
pass: exception

	^nextHandler handle: exception! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
protect: aBlock

	Processor activeProcess pushHandler: self.
	^[(self evaluateProtectee: aBlock) value]
		ensure: [Processor activeProcess popHandler]! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
retry

	retryBlock value! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
retryUsing: aBlock

	protectee := aBlock.
	retryBlock value! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
return: aValue

	returnBlock value: aValue! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
nextHandler: exceptionHandler

	nextHandler := exceptionHandler ! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #MessageNotUnderstood) classSide methodsFor: 'instance creation' !
message: aMessage

	^self new message: aMessage; yourself! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #MessageNotUnderstood) methodsFor: 'accessing' !
message

	^message! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #MessageNotUnderstood) methodsFor: 'accessing' !
receiver

	^message receiver! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #MessageNotUnderstood) methodsFor: 'exception descriptor' !
isResumable

	^true! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #MessageNotUnderstood) methodsFor: 'priv handling' !
defaultAction

	Processor stopWithError: (ProcessDoesNotUnderstandError new message: message)! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #MessageNotUnderstood) methodsFor: 'private initialization' !
message: aMessage

	message := aMessage! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Notification) methodsFor: 'exception description' !
defaultAction

	^nil! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #ZeroDivide) classSide methodsFor: 'Instance creation' !
dividend: dividend

	^self new
		dividend: dividend;
		yourself! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #ZeroDivide) methodsFor: 'accessing' !
dividend

	^dividend! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #ZeroDivide) methodsFor: 'private - initialization' !
dividend: aValue

	dividend := aValue.
	messageText := 'divide by zero'! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #ZeroDivide) methodsFor: 'testing' !
isResumable

	^true! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handle: exception

	^self handlerChain handle: exception! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
popHandler

	| poppedHandler |
	handlerChain := (poppedHandler := self handlerChain) nextHandler.
	^poppedHandler! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
pushHandler: handler

	handler nextHandler: self handlerChain.
	handlerChain := handler ! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
resetExceptionEnvironment

	handlerChain := nil

! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
resetHandlers

	handlerChain := nil

! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
doesNotUnderstand: m <Message> ^<BottomType>
	"Processor stopWithError: (ProcessDoesNotUnderstandError new message: m)"
	(MessageNotUnderstood message: m) signal! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
error: msg <Str> ^<BottomType>

	"Processor stopWithError: (ProcessExplicitError new msg: msg)"
	Error signal: msg! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
halt

	"Processor stopWithError: ProcessHaltError new."
	Halt signal
! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
shouldNotHappen ^<BottomType>

	self error: 'This shouldn''t happen'.! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
shouldNotImplement ^<BottomType>

	self error: 'A message that cannot be supported by this class has been sent to an instance'.! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
subclassResponsibility ^<BottomType>

	"Note: In the Strongtalk language, a method whose body consists of only 
	 'self subclassResponsibility' is considered a declaration, which subclasses
	  must implement for concrete subclasses"

	self error: 'A message that should be implemented but is not has been sent to this object'.! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
unimplemented ^<BottomType>

	self error: 'A hook for unimplemented code has been encountered'! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'exceptions' !
on: exception do: handlerBlock

	^(LinkedExceptionHandler
		on: exception
		do: handlerBlock
		return: [:value | ^ value]) protect: self
! !

"June 3, 2008 -> 11:34:22"!

Delta define: #AbstractExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #AbstractExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #AbstractExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #AbstractExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #AbstractExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #AbstractExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #AbstractExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #AbstractExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #AbstractExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #AbstractExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #AbstractExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

(Delta mirrorFor: #AbstractExceptionHandlingTest)
comment: 
''!


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 3, 2008 -> 11:34:22"!

(Delta mirrorFor: #BlockExceptionDescriptor)
comment: 
'Implements the <exceptionDescriptor> protocol from the ANSI standard using configurable actionsdefined as blocks. Intended to be used primarily as a testing aid.'!


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 3, 2008 -> 11:34:22"!

(Delta mirrorFor: #BlockExceptionDescriptorTest)
comment: 
''!


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

(Delta mirrorFor: #BlockExceptionHandlerTest)
comment: 
''!


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 3, 2008 -> 11:34:22"!

(Delta mirrorFor: #BlockExceptionSelector)
comment: 
'Determines whether an exception can be handled by evaluating the handlesBlock.'!


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

(Delta mirrorFor: #BlockExceptionSelectorTest)
comment: 
''!


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

(Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest)
comment: 
''!


"June 3, 2008 -> 11:34:22"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'handlers')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'handlers')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'handlers')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'handlers')) !


"June 3, 2008 -> 11:34:22"!

(Delta mirrorFor: #ErrorTest)
comment: 
''!


"June 3, 2008 -> 11:34:22"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

(Delta mirrorFor: #ExceptionTest)
comment: 
''!


"June 3, 2008 -> 11:34:22"!

Delta define: #HaltTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

(Delta mirrorFor: #HaltTest)
comment: 
''!


"June 3, 2008 -> 11:34:22"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

(Delta mirrorFor: #LinkedExceptionHandlerTest)
comment: 
''!


"June 3, 2008 -> 11:34:23"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

(Delta mirrorFor: #MessageNotUnderstoodTest)
comment: 
''!


"June 3, 2008 -> 11:34:23"!

Delta define: #NotificationTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

(Delta mirrorFor: #NotificationTest)
comment: 
''!


"June 3, 2008 -> 11:34:23"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

(Delta mirrorFor: #ProcessExceptionHandlingTest)
comment: 
''!


"June 3, 2008 -> 11:34:23"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 3, 2008 -> 11:34:23"!

(Delta mirrorFor: #TestException)
comment: 
'Concrete exception class that can be used for testing'!


"June 3, 2008 -> 11:34:23"!

Delta define: #WarningTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

(Delta mirrorFor: #WarningTest)
comment: 
''!


"June 3, 2008 -> 11:34:23"!

Delta define: #ZeroDivideTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

(Delta mirrorFor: #ZeroDivideTest)
comment: 
''!


"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #AbstractExceptionHandlingTest) classSide methodsFor: 'Testing' !
isAbstract

	^name = #AbstractExceptionHandlingTest! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #AbstractExceptionHandlingTest) methodsFor: 'Running' !
tearDown
"	some of these tests do nasty things to the exception
	environment so best clean up after them by resetting it"
	Processor activeProcess resetExceptionEnvironment! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #AbstractExceptionHandlingTest) methodsFor: 'test support' !
withStopHandler: stopHandler do: aBlock

	| oldHandler |
	oldHandler := Processor stopHandler.
	Processor stopHandler: stopHandler.
	aBlock
		ensure: [Processor stopHandler: oldHandler]! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'instantiation' !
falseSelector

	^BlockExceptionSelector handlesBlock: [:ex| false]! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'instantiation' !
new

	^super new
		initialize;
		yourself! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'instantiation' !
trueSelector

	^BlockExceptionSelector handlesBlock: [:ex| true]! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
defaultActionBlock: block

	defaultBlock := block! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
handler: handler

	handlerBlock value: handler ! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
handlerBlock: block

	handlerBlock := block ! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
resumeBlock: aBlock

	resumeBlock := aBlock! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'exception descriptor' !
defaultAction

	^defaultBlock value! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'exception descriptor' !
isResumable

	^true! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'exception descriptor' !
resume: aValue

	resumeBlock value: aValue! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'initialization' !
initialize

	defaultBlock := [nil].
	handlerBlock := [:ignore|].
	resumeBlock := [:ignore|]! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'restricted - exception handling' !
inContextDo: aBlock

	^aBlock value! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'Running' !
setUp

	super setUp.
	exception := BlockExceptionDescriptor new! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'testing' !
testDefaultActionShouldInvokeDefaultActionBlock

	|wasInvoked|
	exception := BlockExceptionDescriptor new.
	wasInvoked := false.
	exception defaultActionBlock: [wasInvoked := true].
	exception defaultAction.
	self assert: wasInvoked! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'testing' !
testDefaultDefault

	self assert: exception defaultAction isNil! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'testing' !
testHandlerShouldDelegateToHandlerBlock

	|actualHandler|
	exception handlerBlock: [:handler| actualHandler := handler].
	exception handler: #handler.
	self assert: (actualHandler == #handler)! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReportErrorAfterReturnFromNonResumableDefaultAction

	| handler exception wasHandled |
	handler := BlockExceptionHandler default.
	exception := TestException defaultActionBlock: [].
	exception resumable: false.
	[handler handle: exception.
	self signalFailure: 'Handler should not return']
		on: Error
		do: [:error| self assert: 'Return from non-resumable default action is not supported' = error messageText
									description: error messageText.
				wasHandled := true].
	self assert: wasHandled description: 'Handler should report error'! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testShouldInvokeHandlerBlockWithException

	|handled exception|
	handled := false.
	exception = Object new.
	(BlockExceptionHandler
		handleBlock: [:ex| self assert: (ex == exception).
									handled := true])
		handle: exception.
	self assert: handled! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'instantiation' !
falseSelector

	^BlockExceptionSelector handlesBlock: [:ex| false]! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'instantiation' !
handlesBlock: block

	^self new
		handlesBlock: block;
		yourself! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'instantiation' !
trueSelector

	^BlockExceptionSelector handlesBlock: [:ex| true]! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionSelector) methodsFor: 'exception selector' !
handles: exceptionDescriptor

	^handlesBlock value: exceptionDescriptor! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionSelector) methodsFor: 'private - initialization' !
handlesBlock: block

	handlesBlock := block ! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionSelectorTest) methodsFor: 'Testing' !
testShouldHandleWhenHandleBlockReturnsTrue

	|canHandle selector|
	selector := BlockExceptionSelector handlesBlock: [:ex| canHandle].
	canHandle := true.
	self assert: (selector handles: nil).
	canHandle := false.
	self deny: (selector handles: nil)! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionSelectorTest) methodsFor: 'Testing' !
testShouldPassExceptionToHandlesBlock

	|exception selector|
	exception := Object new.
	selector := BlockExceptionSelector handlesBlock: [:ex| self assert: (ex == exception). true].
	self assert: (selector handles: exception)! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testOnDoShouldInvokeDoWhenExceptionSignalled

	|wasHandled|
	wasHandled := false.
	[Exception signal]
		on: Exception
		do: [:ex| wasHandled := true].
	self assert: wasHandled
			description: 'Signalled exception should be handled'! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testOnDoShouldInvokeNestedHandler

	|innerInvoked outerInvoked|
	innerInvoked := false.
	outerInvoked := false.
	[[Exception signal]
		on: BlockExceptionSelector falseSelector
		do: [:ex| innerInvoked := true]]
			on: Exception
			do: [:ex| outerInvoked := true].
	self deny: innerInvoked
			description: 'Inner handler should not be invoked'.
	self assert: outerInvoked
			description: 'Outer handler should be invoked'! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testOnDoShouldPopHandler

	|handlerInvoked descriptor defaultInvoked|
	descriptor := BlockExceptionDescriptor new.
	descriptor
		defaultActionBlock: [defaultInvoked := true];
		resumeBlock: [:value| ^self " force NLR"].
	[Exception signal]
		on: BlockExceptionSelector trueSelector
		do: [:ex| handlerInvoked := true].
	defaultInvoked := false.
	handlerInvoked := false.
	[Processor activeProcess handle: descriptor]
		ensure: [self deny: handlerInvoked
								description: 'Handler should have been popped'.
						self assert: defaultInvoked
								description: 'Default action should have been invoked']! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testShouldUnwindExceptionHandlersWhenHandlingException

	| wasInvoked |
	wasInvoked := false.
	[[[Notification signal]
			on: Error
			do: [:ex| self signalFailure: 'Should be caught by outer handler']]
				on: Notification
				do: [:ex| self error: 'Provoke outer handler']]
					on: Error
					do: [:ex| wasInvoked:= true].
	self assert: wasInvoked description: 'Outer handler should be invoked'! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ErrorTest) methodsFor: 'testing' !
testDefaultActionShouldPassToStopHandler

	| wasHandled processError |
	wasHandled := false.
	self withStopHandler: [:p| wasHandled := true.
													processError := p processError]
			do: 	[[self error: 'this is an error'] fork.
					Processor yield].
	self assert: wasHandled
			description: 'defaultAction should invoke the stopHandler'.
	self assert: (processError isKindOf: ProcessExplicitError)
			description: 'Process stopped with wrong kind of error', processError printString.
	self assert: 'this is an error' = processError msg
			description: 'Process stopped with wrong message: ', processError msg! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ErrorTest) methodsFor: 'testing' !
testErrorShouldSignalError

	| wasSignalled |
	wasSignalled := true.
	[self error: 'error message'.
	self signalFailure: 'should not return']
		on: Error
		do: [:ex| wasSignalled := true.
				self assert: 'error message' = ex messageText
						description: ex messageText printString].
	self assert: wasSignalled
			description: 'Error should be signalled'! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ErrorTest) methodsFor: 'testing' !
testShouldNotBeResumable

	self deny: Error new isResumable! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testDefaultActionShouldExecuteInSignallingEnvironment

	| original wasHandled |
	original := TestException defaultActionBlock: [self error: ''].
	original resumable: true.
	wasHandled := false.
	[original signal]
		on: Error
		do: [:ex| wasHandled := true].
	self assert: wasHandled! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testDefaultActionShouldExecuteInSignallingEnvironmentAfterResumableOuter

	| original wasHandled |
	original := TestException defaultActionBlock: [self error: ''].
	original resumable: true.
	wasHandled := false.
	[[original signal]
		on: Error
		do: [:ex| wasHandled := true]]
			on: TestException
			do: [:ex| ex outer].
	self assert: wasHandled! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testIsNestedShouldBeFalseWhenOuterHandlerDoesntHandle

	|wasHandled|
	wasHandled := false.
	[[Exception signal]
		on: Exception
		do: [:ex| self deny: ex isNested.
				wasHandled := true]]
		on: TestException
		do: [:ex|].
	self assert: wasHandled! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testIsNestedShouldBeFalseWithNoHandler

	|exception|
	exception := Exception new.
	self deny: exception isNested! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testIsNestedShouldBeTrueWhenOuterHandlerHandles

	|wasHandled|
	wasHandled := false.
	[[Exception signal]
		on: Exception
		do: [:ex| self assert: ex isNested.
				wasHandled:= true]]
		on: Exception
		do: [:ex| self shouldNotHappen].
	self assert: wasHandled! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testIsNestedShouldBeTrueWhenOuterOuterHandlerHandles

	|wasHandled|
	wasHandled := false.
	[[[Exception signal]
		on: Exception
		do: [:ex| self assert: ex isNested.
				wasHandled := true]]
			on: TestException
			do: [:ex|]]
				on: Exception
				do: [:ex|].
	self assert: wasHandled! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable

	|outer result|
	[(TestException defaultActionBlock: [#result])
		resumable: true;
		signal]
			on: TestException
			do: [:ex|
					self assert: ex outer == #result description: 'outer returned wrong result'.
					result := #returned].
	self assert: result == #returned description: 'outer did not return'! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldReturnResumptionValueWhenResumed

	|wasResumed|
	wasResumed := false.
	[[TestException new resumable: true; signal]
		on: TestException
		do: [:ex| |result|
				result := ex outer.
				self assert: 'result' = result description: result printString.
				wasResumed := true]]
					on: TestException
					do: [:ex| ex resume: 'result'.
							self signalFailure: 'Resume should not return'].
	self assert: wasResumed description: 'not resumed'! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterTwiceShouldInvokeSurroundingHandlerTwice

	|count|
	count := 0.
	[[TestException new
		resumable: true;
		signal]
		on: TestException
		do: [:ex| ex outer.
				ex outer]]
			on: TestException
			do: [:ex| count := count + 1].
	self assert: count == 2 description: 'Count was ', count printString! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldInvokeDefaultActionWithoutReturning

	| signalReturned |
	signalReturned := false.
	[|result|
	result := (TestException defaultActionBlock: ['result'])
						resumable: true;
						signal.
	self assert: result = 'result' description: result printString.
	signalReturned := true]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'Pass should not return'].
	self assert: signalReturned description: 'Signal did not return'! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldInvokeSurroundingHandler

	| wasPassed |
	wasPassed := false.
	[[TestException new signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'Pass should not return']]
				on: TestException
				do: [:ex| wasPassed := true].
	self assert: wasPassed description: 'Outer handler not invoked'! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResignalAsShouldRestoreSignalEnvironment

	|log|
	log := String new writeStream.
	[[Exception signal]
		on: TestException
		do: [:ex| log nextPutAll: 'resignal']]
			on: Exception
			do: [:ex| [log nextPutAll: 'signal '.
							ex resignalAs: TestException new]
								ifCurtailed: [log nextPutAll: 'curtail ']].
	self assert: log contents = 'signal curtail resignal' description: log contents! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeAfterPassShouldReturnFromSignal

	| wasReturned |
	wasReturned := false.
	[[|result|
	result := TestException new resumable: true; signal.
	wasReturned := true]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'Pass should not return']]
				on: TestException
				do: [:ex| ex resume].
	self assert: wasReturned description: 'Resume did not return from signal'! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeAfterPassShouldReturnResultFromSignal

	| wasReturned |
	wasReturned := false.
	[[|result|
	result := TestException new resumable: true; signal.
	self assert: 'result' = result description: result printString.
	wasReturned := true]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'Pass should not return']]
				on: TestException
				do: [:ex| ex resume: 'result'].
	self assert: wasReturned description: 'Resume did not return from signal'! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeShouldReturnAsValueOfOuter

	|result|
	[[Exception signal]
		on: Exception
		do: [:ex| result := ex outer]]
			on: Exception
			do: [:ex| ex resume: #result].
	self assert: result == #result description: result printString! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeShouldReturnValueAsResultOfSignal

	|wasResumed|
	wasResumed := false.
	[|result|
	result := TestException new
						resumable: true;
						signal.
	self assert: #resume == result description: result printString.
	wasResumed := true]
		on: TestException
		do: [:ex| ex resume: #resume].
	self assert: wasResumed description: 'Should have resumed after signal'! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testRetryShouldReevaluateProtectee

	|count|
	count := 0.
	[count := count + 1.
	count == 1 ifTrue:[Exception signal]]
		on: Exception
		do: [:ex| ex retry].
	self assert: count == 2 description: 'Count was ' , count printString! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testRetryUsingShouldReplaceProtectee

	|log count|
	log := String new writeStream.
	count := 0.
	[[Exception signal]
		ensure: [log nextPutAll: 'unwind ']]
			on: Exception
			do: [:ex|
					log nextPutAll: 'handle '.
					count := count + 1.
					count = 1 ifTrue: [ex retryUsing: [log nextPutAll: 'using '.
													Exception signal]]].
	self assert: log contents = 'handle unwind using handle '
			description: log contents! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testReturnShouldDelegateToHandler

	|exception handler result|
	exception := Exception new.
	handler := BlockExceptionHandler new.
	result := #invalid.
	handler returnBlock: [:value| result := value].
	exception handler: handler.
	exception return.
	self assert: result isNil description: 'Return should pass back nil'! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testSignalShouldInvokeProcessHandler

	|wasInvoked|
	wasInvoked := false.
	Processor activeProcess
		pushHandler: (LinkedExceptionHandler
										on: Exception
										do: [:ex| wasInvoked := true]).
	Exception signal.
	[self assert: wasInvoked description: 'Should invoke exception handler']
		ensure: [Processor activeProcess popHandler]! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #HaltTest) methodsFor: 'Testing' !
testDefaultActionShouldStopWithProcessHaltError

	| wasHandled processError |
	wasHandled := false.
	self withStopHandler: [:p| wasHandled := true.
													processError := p processError]
			do: [[self halt] fork.
					Processor yield].
	self assert: wasHandled
			description: 'Halt should have been handled'.
	self assert: (processError isKindOf: ProcessHaltError)
			description: 'Wrong kind of error reported'! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #HaltTest) methodsFor: 'Testing' !
testHaltShouldSignalHalt

	| wasSignalled |
	wasSignalled := false.
	[self halt]
		on: Halt
		do: [:ex| wasSignalled := true].
	self assert: wasSignalled! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #HaltTest) methodsFor: 'Testing' !
testShouldBeResumable

	self assert: Halt new isResumable! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testHandlerShouldSetHandlerOnException

	|handler exception assignedHandler|
	exception := BlockExceptionDescriptor new.
	exception handlerBlock: [:handler| assignedHandler := handler].
	handler := LinkedExceptionHandler
							on: BlockExceptionSelector trueSelector
							do: [:ex| ].
	self assert: assignedHandler ~~ handler
			description: 'Handler should not have been assigned yet'.
	handler handle: exception.
	self assert: assignedHandler == handler
			description: 'Handler should have been assigned'! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testPassShouldDeferToNextHandler

	|handler trueSelector exception wasPassed nextHandler|
	exception := BlockExceptionDescriptor new.
	handler := LinkedExceptionHandler
							on: BlockExceptionSelector trueSelector
							do: [:ex| ].
	nextHandler := BlockExceptionHandler handleBlock: [:ex| wasPassed := true].
	handler nextHandler: nextHandler.
	wasPassed := false.
	handler pass: exception.
	self assert: wasPassed
			description: 'Handler should defer pass to nextHandler'! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testReturnShouldEvaluateReturnBlock

	|handler result |
	handler := LinkedExceptionHandler
			on: nil
			do: [:ex| ]
			return: [:returnValue| result := returnValue].
	handler return: #value.
	self assert: result == #value
			description: 'Should have invoked return'! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testShouldDelegateToNextHandlerWhenNoMatch

	|handled exception nextHandler|
	handled := false.
	exception := BlockExceptionDescriptor new.
	nextHandler := BlockExceptionHandler
										handleBlock: [:ex| self assert: ex == exception
																					description: 'Handler invoked with wrong exception'.
																	handled := true].
	(LinkedExceptionHandler
		on: BlockExceptionSelector falseSelector
		do: [:ex| self signalFailure: 'Should not invoke hander'])
			nextHandler: nextHandler;
			handle: exception.
	self assert: handled
			description: 'Next handler not invoked'! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testShouldInvokeExceptionsDefaultActionWhenNoNextHandler

	|handled exception|
	handled := false.
	exception := BlockExceptionDescriptor new.
	exception defaultActionBlock: [handled := true].
	(LinkedExceptionHandler
		on: BlockExceptionSelector falseSelector
		do: [:ex| self shouldNotHappen])
			handle: exception.
	self assert: handled
			description: 'Default action not invoked'! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testShouldInvokeHandleBlockWhenExceptionMatches

	|handled exception|
	handled := false.
	exception := BlockExceptionDescriptor new.
	(LinkedExceptionHandler
		on: BlockExceptionSelector trueSelector
		do: [:ex|
				self assert: ex == exception
						description: 'Handler invoked with wrong exception'.
				handled := true])
		handle: exception.
	self assert: handled
			description: 'Exception not handled by handler'! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #MessageNotUnderstoodTest) methodsFor: 'testing' !
testMessageShouldReturnMessageThatWasNotUnderstood

	| message |
	message := Message
								receiver: 1
								selector: #zork
								arguments: #().
	[(MessageNotUnderstood message: message)
			signal.]
		on: MessageNotUnderstood
		do: [:ex| self assert: message = ex message
								description: 'Wrong message']! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #MessageNotUnderstoodTest) methodsFor: 'testing' !
testReceiverShouldReturnReceiverOfMessage

	| message |
	message := Message
								receiver: 1
								selector: #zork
								arguments: #().
	[(MessageNotUnderstood message: message)
			signal.]
		on: MessageNotUnderstood
		do: [:ex| self assert: 1 = ex receiver
								description: 'Wrong receiver']! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #MessageNotUnderstoodTest) methodsFor: 'testing' !
testResumeShouldReturnResultFromSignal
"	note that until doesNotUnderstand: is fixed in the VM
	we cannot use the more obvious test of sending a
	message to an object that cannot understand it"
	|result|
	[result := (MessageNotUnderstood
							message: (Message
														receiver: 1
														selector: #zork
														arguments: #()))
							signal.]
		on: MessageNotUnderstood
		do: [:ex| ex resume: 5].
	self assert: result = 5
			description: 'Result not returned'! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #MessageNotUnderstoodTest) methodsFor: 'testing' !
testShouldBeResumable

	self assert: MessageNotUnderstood new isResumable! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #NotificationTest) methodsFor: 'Testing' !
testDefaultActionReturnsNil

	self assert: Notification signal isNil! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #NotificationTest) methodsFor: 'Testing' !
testIsResumable

	self assert: Notification new isResumable! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testHandleShouldInvokeDefaultAction

	|exception wasInvoked|
	wasInvoked := false.
	exception := BlockExceptionDescriptor new.
	exception
		defaultActionBlock: [wasInvoked := true];
		resumeBlock: [:value|^self "force NLR to prevent problems with test infrastructure"].
	[Processor activeProcess handle: exception]
		ensure: [self assert: wasInvoked
								description: 'Default action not invoked']! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testPushedHandlerShouldDeferToDefaultHandlerWhenExceptionDoesntMatch

	|process wasInvoked exception|
	exception := BlockExceptionDescriptor new.
	exception defaultActionBlock: [wasInvoked := true].
	process := Processor activeProcess.
	process pushHandler: (LinkedExceptionHandler
														on: BlockExceptionSelector falseSelector
														do: [:ex| ]).
	wasInvoked := false.
	[[process handle: exception]
		ensure: [self assert: wasInvoked
								description: 'Default action not invoked']]
			ensure: [process popHandler]! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testPushedHandlerShouldDeferToOuterHandlerWhenExceptionDoesntMatch

	|process wasInvoked exception outerHandler|
	wasInvoked := false.
	exception := BlockExceptionDescriptor new.
	exception
		defaultActionBlock: [];
		resumeBlock: [:value|^self "force NLR to prevent problems with test infrastructure"].
	outerHandler := (LinkedExceptionHandler
										on: BlockExceptionSelector trueSelector
										do: [:ex| wasInvoked := true]).
	process := Processor activeProcess.
	process pushHandler: outerHandler.
	process pushHandler: (LinkedExceptionHandler
														on: BlockExceptionSelector falseSelector
														do: [:ex| ]).
	[[process handle: exception]
			ensure: [self assert: wasInvoked
									description: 'Outer handler should have been invoked']]
				ensure: [process popHandler.
								process popHandler]! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testPushedHandlerShouldReplaceDefaultHandler

	|process wasInvoked exception|
	process := Processor activeProcess.
	exception := BlockExceptionDescriptor new.
	wasInvoked := false.
	process pushHandler: (LinkedExceptionHandler
													on: BlockExceptionSelector trueSelector
													do: [:ex| wasInvoked := true]).
	[wasInvoked := false.
	process handle: exception]
		ensure: [process popHandler].
	self assert: wasInvoked description: 'Handler should be invoked'! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #TestException) classSide methodsFor: 'test support' !
defaultActionBlock: block

	^self new
			defaultActionBlock: block;
			yourself! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #TestException) methodsFor: 'test support' !
defaultAction	^defaultActionBlock value! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #TestException) methodsFor: 'test support' !
defaultActionBlock: block	defaultActionBlock := block! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #TestException) methodsFor: 'test support' !
isResumable	^resumable isNil		ifTrue: [false]		ifFalse: [resumable]! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #TestException) methodsFor: 'test support' !
resumable: boolean	^resumable := boolean! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #WarningTest) methodsFor: 'Testing' !
testDefaultActionShouldProvokeHalt

	| wasHalted wasSignalled |
	wasHalted := wasSignalled := false.
	[[Warning signal]
		on: Halt
		do: [wasHalted := true]]
				on: Warning
				do: [:ex| wasSignalled := true.
								ex outer].
	self assert: wasSignalled
			description: 'Should have signalled Warning'.	
	self assert: wasHalted
			description: 'Default action should have halted'! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #WarningTest) methodsFor: 'Testing' !
testShouldBeResumable

	self assert: Warning new isResumable! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #ZeroDivideTest) methodsFor: 'Testing' !
testDivideByZeroShouldSignalZeroDivide

	| wasSignalled |
	wasSignalled := false.
	[1/0]
		on: ZeroDivide
		do: [:ex| wasSignalled := true.
						self assert: 1 = ex dividend
								description: 'Wrong dividend:', ex dividend printString.
						self assert: 'divide by zero' = ex messageText
								description: 'Wrong message: ', ex messageText printString].
	self assert: wasSignalled
			description: 'Should have signalled'! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #ZeroDivideTest) methodsFor: 'Testing' !
testDividendShouldReturnDividendThatCreatedException

	[(ZeroDivide dividend: 1) signal]
		on: ZeroDivide
		do: [:ex| self assert: 1 = ex dividend]! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #ZeroDivideTest) methodsFor: 'Testing' !
testShouldBeResumable

	self assert: ZeroDivide new isResumable! !

"June 3, 2008 -> 11:37:37"!

Delta define: #Warning as: (
(Class subclassOf: 'Notification' instanceVariables: '')) !


"June 3, 2008 -> 11:37:37"!

! (Delta mirrorFor: #WarningTest) methodsFor: 'Testing' !
testShouldBeResumable

	self assert: Warning new isResumable! !

"June 3, 2008 -> 11:37:37"!

! (Delta mirrorFor: #WarningTest) methodsFor: 'Testing' !
testDefaultActionShouldProvokeHalt

	| wasHalted wasSignalled |
	wasHalted := wasSignalled := false.
	[[Warning signal]
		on: Halt
		do: [wasHalted := true]]
				on: Warning
				do: [:ex| wasSignalled := true.
								ex outer].
	self assert: wasSignalled
			description: 'Should have signalled Warning'	
							! !

"June 3, 2008 -> 11:37:37"!

! (Delta mirrorFor: #WarningTest) methodsFor: 'Testing' !
testDefaultActionShouldProvokeHalt

	| wasHalted wasSignalled |
	wasHalted := wasSignalled := false.
	[[Warning signal]
		on: Halt
		do: [wasHalted := true]]
				on: Warning
				do: [:ex| wasSignalled := true.
								ex outer].
	self assert: wasSignalled
			description: 'Should have signalled Warning'.	
	self assert: wasHalted
			description: 'Default action should have halted'! !

"June 3, 2008 -> 11:37:37"!

! (Delta mirrorFor: #Warning) methodsFor: 'exception descriptor' !
defaultAction

	self halt! !

"June 3, 2008 -> 11:39:28"!

! (Delta mirrorFor: #Warning) methodsFor: 'exception descriptor' !
defaultAction

	self halt! !

"June 3, 2008 -> 11:39:28"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testDefaultActionShouldExecuteInSignallingEnvironmentAfterResumableOuter

	| original wasHandled |
	original := TestException defaultActionBlock: [self error: ''].
	original resumable: true.
	wasHandled := false.
	[[original signal]
		on: Error
		do: [:ex| wasHandled := true]]
			on: TestException
			do: [:ex| ex outer].
	self assert: wasHandled! !

"June 3, 2008 -> 11:39:28"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
outer
"Evaluate the enclosing exception action and return to here 
instead of signal if it resumes (see #resumeUnchecked:)."
	| oldHandler oldContext |
	self isResumable
		ifFalse: [self pass].
	["oldContext := contextBlock."
	"^(self installContextAndDo: ["
	(oldHandler := handler)
			outer: self return: [:value| ^value]
															"]) value"
															]
		ensure: [handler := oldHandler.
						"contextBlock := oldContext"]! !

"June 3, 2008 -> 11:39:28"!

! (Delta mirrorFor: #Exception) methodsFor: 'restricted exception handling' !
withResume: resumeBlock do: aBlock

	| oldResume |
	aBlock value! !

"June 3, 2008 -> 11:39:28"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:39:28"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:39:28"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:39:28"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:39:28"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:39:28"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:39:28"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:39:28"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"
resumeBlock')) !


"June 3, 2008 -> 11:39:28"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"
resumeBlock')) !


"June 3, 2008 -> 11:39:28"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"
resumeBlock')) !


"June 3, 2008 -> 11:39:28"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"
resumeBlock')) !


"June 3, 2008 -> 11:39:28"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionInstantiator' !
new

	^super new initialize; yourself! !

"June 3, 2008 -> 11:39:28"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionInstantiator' !
new

	^super new
			initialize;
			yourself! !

"June 3, 2008 -> 11:39:28"!

! (Delta mirrorFor: #Exception) methodsFor: 'restricted exception handling' !
initialize

	resumeBlock := [:resumptionValue| contextBlock value: [resumptionValue]]! !

"June 3, 2008 -> 11:39:28"!

! (Delta mirrorFor: #Exception) methodsFor: 'restricted exception handling' !
withResume: aResumeBlock do: aBlock

	| oldResume |
	oldResume := resumeBlock.
	resumeBlock := aResumeBlock.
	aBlock
		ensure: [resumeBlock := oldResume]! !

"June 3, 2008 -> 11:39:28"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resume: resumptionValue
"Return resumptionValue as the value of the signal message."
	resumeBlock value: resumptionValue! !

"June 3, 2008 -> 11:39:28"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
outer: exception return: aReturnBlock

	nextHandler handle: exception return: aReturnBlock! !

"June 3, 2008 -> 11:39:29"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
outer: exception return: aReturnBlock

	exception
		withResume: [:value| ^value]
		do: [nextHandler handle: exception return: aReturnBlock]! !

"June 3, 2008 -> 11:39:29"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
outer
"Evaluate the enclosing exception action and return to here 
instead of signal if it resumes (see #resumeUnchecked:)."
	| oldHandler oldContext |
	self isResumable
		ifFalse: [self pass].
	["oldContext := contextBlock."
	"^(self installContextAndDo: ["
	^(oldHandler := handler)
			outer: self return: [:value| ^value]
															"]) value"
															]
		ensure: [handler := oldHandler.
						"contextBlock := oldContext"]! !

"June 3, 2008 -> 11:39:29"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
handle: exception return: aReturnBlock

	Processor activeProcess popHandler.
	[^(exceptionSelector handles: exception)
		ifTrue: [	exception handler: self.
						returnBlock value: (handleBlock value: exception)]
		ifFalse: [nextHandler handle: exception return: aReturnBlock]]
			ensure: [Processor activeProcess pushHandler: self]! !

"June 3, 2008 -> 11:39:29"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"
resumeBlock')) !


"June 3, 2008 -> 11:39:29"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"
resumeBlock')) !


"June 3, 2008 -> 11:39:29"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"
resumeBlock')) !


"June 3, 2008 -> 11:39:29"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"
resumeBlock')) !


"June 3, 2008 -> 11:39:29"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"
resumeBlock')) !


"June 3, 2008 -> 11:39:29"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"
resumeBlock')) !


"June 3, 2008 -> 11:39:29"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"
resumeBlock')) !


"June 3, 2008 -> 11:39:29"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
signalledHandler "this was the first handler when the exception was originally signalled"
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"
resumeBlock')) !


"June 3, 2008 -> 11:39:29"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
signalledHandler "this was the first handler when the exception was originally signalled"
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"
resumeBlock')) !


"June 3, 2008 -> 11:39:29"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
signalledHandler "this was the first handler when the exception was originally signalled"
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"
resumeBlock')) !


"June 3, 2008 -> 11:39:29"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
signalledHandler "this was the first handler when the exception was originally signalled"
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"
resumeBlock')) !


"June 3, 2008 -> 11:39:29"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
privateSignal

	^self installContextAndDo: [signalledHandler := Processor activeProcess handlerChain.
														signalledHandler handle: self]! !

"June 3, 2008 -> 11:39:29"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain: aHandler

	handlerChain := aHandler! !

"June 3, 2008 -> 11:39:29"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
inEnvironment: aHandler do: block

	| oldHandler |
	oldHandler := self handlerChain.
	handlerChain := aHandler.
	block
		ensure: [handlerChain := oldHandler]! !

"June 3, 2008 -> 11:39:29"!

! (Delta mirrorFor: #Exception) methodsFor: 'restricted exception handling' !
inContextDo: aBlock

	Processor activeProcess
		inEnvironment: signalledHandler
		do: aBlock
	! !

"June 3, 2008 -> 11:39:29"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReportErrorAfterReturnFromNonResumableDefaultAction

	| handler exception wasHandled |
	handler := BlockExceptionHandler default.
	exception := TestException defaultActionBlock: [].
	exception resumable: false.
	[exception signal.
	self signalFailure: 'Handler should not return']
		on: Error
		do: [:error| self assert: 'Return from non-resumable default action is not supported' = error messageText
									description: error messageText.
				wasHandled := true].
	self assert: wasHandled description: 'Handler should report error'! !

"June 3, 2008 -> 11:39:29"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterTwiceShouldInvokeSurroundingHandlerTwice

	|count|
	count := 0.
	[[TestException new
		resumable: true;
		signal]
		on: TestException
		do: [:ex| ex outer.
				ex outer]]
			on: TestException
			do: [:ex| count := count + 1
							ex resume].
	self assert: count == 2 description: 'Count was ', count printString! !

"June 3, 2008 -> 11:39:29"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterTwiceShouldInvokeSurroundingHandlerTwice

	|count|
	count := 0.
	[[TestException new
		resumable: true;
		signal]
		on: TestException
		do: [:ex| ex outer.
				ex outer]]
			on: TestException
			do: [:ex| count := count + 1.
							ex resume].
	self assert: count == 2 description: 'Count was ', count printString! !

"June 3, 2008 -> 11:39:29"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[[[aTestCase runCase.
			true]
				sunitOn: self class failure
				do: [:signal |
						aTestCase echo.
						Transcript cr; tab; show: signal messageText.
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: MessageNotUnderstood
							do: [:signal | |message|
									aTestCase echo.
									message := signal message.
									message receiver printOn: (Transcript cr; yourself).
									Transcript space; show: message selector.
									signal pass]]
										sunitOn: self class error
										do: [:signal |
												self halt.
												aTestCase echo.
												Transcript cr.
												signal class printOn: Transcript.
												signal messageText isNil
													ifFalse: [Transcript space; show: signal messageText].
												self errors add: aTestCase.
												signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"June 3, 2008 -> 11:42:19"!

! (Delta mirrorFor: #WarningTest) methodsFor: 'Testing' !
testDefaultActionShouldProvokeHalt

	| wasHalted wasSignalled |
	wasHalted := wasSignalled := false.
	[[Warning signal]
		on: Halt
		do: [:ex| wasHalted := true]]
				on: Warning
				do: [:ex| wasSignalled := true.
								ex outer].
	self assert: wasSignalled
			description: 'Should have signalled Warning'.	
	self assert: wasHalted
			description: 'Default action should have halted'! !

"June 3, 2008 -> 11:45:34"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Printing' !
echo

	Transcript cr.
	self printOn: Transcript! !

"June 3, 2008 -> 11:47:26"!

! (Delta mirrorFor: #RationalNumber) classSide methodsFor: 'instance creation' !
numerator: n <Int> denominator: d <Int> ^<RationalNumber>

	| gcd <Int> num <Int> denom <Int> |
	d < 0
		ifFalse: [ d == 0
					ifTrue: [ (ZeroDivide dividend: n) signal ]
					ifFalse: [ num := n. denom := d ]	]
		ifTrue: [ num := n negated. denom := d negated ].
	gcd := num gcd: denom.
	num := num // gcd.
	^gcd == denom
		ifTrue: [ num ]
		ifFalse: [	Fraction
							numerator: num
							denominator: denom // gcd ]! !

"June 3, 2008 -> 11:51:15"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[[[aTestCase runCase.
			true]
				sunitOn: self class failure
				do: [:signal |
						aTestCase echo.
						Transcript cr; tab; show: signal messageText.
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: MessageNotUnderstood
							do: [:signal | |message|
									aTestCase echo.
									message := signal message.
									message receiver printOn: (Transcript cr; yourself).
									Transcript space; show: message selector.
									signal pass]]
										sunitOn: self class error
										do: [:signal |
												aTestCase echo.
												Transcript cr.
												signal class printOn: Transcript.
												signal messageText isNil
													ifFalse: [Transcript space; show: signal messageText].
												self errors add: aTestCase.
												signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"June 3, 2008 -> 11:52:4"!

"System saved" !
"June 3, 2008 -> 23:53:37"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testReturnShouldReturnValueAsResutlOfOnDo

	| result |
	result := [Error signal]
						on: Error
						do: [:ex| ex return: #value.
										self signalFailure: 'return: should not return!!'].
	self assert: result = #value
			description: 'Wrong result returned:', result! !

"June 3, 2008 -> 23:56:28"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testReturnShouldReturnValueFromInnerHandler

	| result |
	[result := [Error signal]
						on: Error
						do: [:ex| ex return: #value1]]
							on: Error
							do: [:ex| ex return: #value2].
	self assert: result = #value1
			description: 'Wrong result returned:', result! !

"June 3, 2008 -> 23:57:4"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testReturnShouldReturnValueFromOuterHandler

	| result |
	result := [[Error signal]
						on: Error
						do: [:ex| ex outer]]
							on: Error
							do: [:ex| ex return: #value2].
	self assert: result = #value2
			description: 'Wrong result returned:', result! !

"June 3, 2008 -> 23:57:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testReturnShouldReturnValueFromOuterHandler

	| result |
	result := [[Error signal]
						on: Error
						do: [:ex| ex outer].
					self signalFailure: 'Block should not complete']
							on: Error
							do: [:ex| ex return: #value2].
	self assert: result = #value2
			description: 'Wrong result returned:', result! !

"June 3, 2008 -> 23:58:55"!

"System saved" !
"June 4, 2008 -> 0:3:14"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testExceptionSetForWarningAndHaltHandlesBoth

	| exceptionSet |
	exceptionSet := Warning, Halt.
	self assert: (exceptionSet handles: Warning new)
			description: 'Should handle Warning'.
	self assert: (exceptionSet handles: Halt new)
			description: 'Should handle Halt'.
	self deny: (exceptionSet handles: Error new)
			description: 'Shouldn''t handle Error'.! !

"June 4, 2008 -> 0:5:0"!

Delta define: #ExceptionSet as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 4, 2008 -> 0:5:19"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionSelector' !
, anotherException
"Create an exception set."

	^ExceptionSet new
		add: self;
		add: anotherException;
		yourself! !

"June 4, 2008 -> 0:5:56"!

! (Delta mirrorFor: #ExceptionSet) methodsFor: 'accessing' !
add: exceptionSelector

	! !

"June 4, 2008 -> 0:7:1"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionSelector' !
, anotherException
"Create an exception set."

	^(ExceptionSet with: self)
			,  anotherException! !

"June 4, 2008 -> 0:7:39"!

! (Delta mirrorFor: #ExceptionSet) classSide methodsFor: 'instance creation' !
with: exceptionClass

	^self new , exceptionClass! !

"June 4, 2008 -> 0:7:57"!

! (Delta mirrorFor: #ExceptionSet) methodsFor: 'initialization' !
initialize! !

"June 4, 2008 -> 0:8:5"!

Delta define: #ExceptionSet as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptions')) !


"June 4, 2008 -> 0:8:17"!

! (Delta mirrorFor: #ExceptionSet) methodsFor: 'initialization' !
initialize

	exceptions  := Set new! !

"June 4, 2008 -> 0:8:23"!

! (Delta mirrorFor: #ExceptionSet) methodsFor: 'initialization' !
initialize

	exceptions := Set new! !

"June 4, 2008 -> 0:8:36"!

! (Delta mirrorFor: #ExceptionSet) methodsFor: 'accessing' !
, exceptionClass! !

"June 4, 2008 -> 0:9:29"!

! (Delta mirrorFor: #ExceptionSet) methodsFor: 'accessing' !
, exceptionClass

	exceptions add: exceptionClass! !

"June 4, 2008 -> 0:10:4"!

! (Delta mirrorFor: #ExceptionSet) classSide methodsFor: 'instance creation' !
with: exceptionClass

	^self new initialize , exceptionClass! !

"June 4, 2008 -> 0:10:50"!

! (Delta mirrorFor: #ExceptionSet) methodsFor: 'exception selector' !
handles: anException

	^exceptions includes: anException class! !

"June 4, 2008 -> 0:11:48"!

Delta define: #ExceptionSetTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 4, 2008 -> 0:14:21"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetSelectsMatchingException

	| exceptionSelector wasHandled |
	exceptionSelector := Warning, Halt.
	[Warning signal.
	self error: '']
		on: exceptionSelector
		do: [:ex| wasHandled := true].
	self assert: wasHandled
			description: 'Should have caught Warning'	! !

"June 4, 2008 -> 0:15:20"!

Delta define: #ExceptionSetTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exceptionSelector')) !


"June 4, 2008 -> 0:15:29"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
setUp
! !

"June 4, 2008 -> 0:16:22"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Running' !
setUp

	super setUp.
	exceptionSelector := Warning, Halt.
! !

"June 4, 2008 -> 0:17:7"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetSelectsMatchingException

	| wasHandled |
	exceptionSelector := Warning, Halt.
	[Warning signal.
	self error: '']
		on: exceptionSelector
		do: [:ex| wasHandled := true].
	self assert: wasHandled
			description: 'Should have caught Warning'	! !

"June 4, 2008 -> 0:17:15"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetSelectsMatchingException

	| wasHandled |
	[Warning signal.
	self error: '']
		on: exceptionSelector
		do: [:ex| wasHandled := true].
	self assert: wasHandled
			description: 'Should have caught Warning'	! !

"June 4, 2008 -> 0:17:33"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetSelectsWarning

	| wasHandled |
	[Warning signal.
	self error: '']
		on: exceptionSelector
		do: [:ex| wasHandled := true].
	self assert: wasHandled
			description: 'Should have caught Warning'	! !

"June 4, 2008 -> 0:17:36"!

(Delta mirrorFor: #ExceptionSetTest) removeMethod: #testExceptionSetSelectsMatchingException ifAbsent: [] !


"June 4, 2008 -> 0:17:49"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetSelectsHalt

	| wasHandled |
	[Halt signal.
	self error: '']
		on: exceptionSelector
		do: [:ex| wasHandled := true].
	self assert: wasHandled
			description: 'Should have caught Halt'	! !

"June 4, 2008 -> 0:18:52"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetShouldntSelectNotification

	| wasHandled |
	[Notification signal.
	self error: '']
		on: exceptionSelector
		do: [:ex| wasHandled := true].
	self deny: wasHandled
			description: 'Shouldn''t have caught Notification'	! !

"June 4, 2008 -> 0:19:7"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetShouldntSelectNotification

	| wasHandled |
	[Notification signal]
		on: exceptionSelector
		do: [:ex| wasHandled := true].
	self deny: wasHandled
			description: 'Shouldn''t have caught Notification'	! !

"June 4, 2008 -> 0:19:35"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetShouldntSelectNotification

	| wasHandled |
	wasHandled := false.
	[Notification signal]
		on: exceptionSelector
		do: [:ex| wasHandled := true].
	self deny: wasHandled
			description: 'Shouldn''t have caught Notification'	! !

"June 4, 2008 -> 0:19:43"!

Delta define: #ExceptionSetTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exceptionSelector
wasHandled')) !


"June 4, 2008 -> 0:19:48"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetShouldntSelectNotification

	wasHandled := false.
	[Notification signal]
		on: exceptionSelector
		do: [:ex| wasHandled := true].
	self deny: wasHandled
			description: 'Shouldn''t have caught Notification'	! !

"June 4, 2008 -> 0:19:58"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Running' !
setUp

	super setUp.
	exceptionSelector := Warning, Halt.
	wasHandled := false! !

"June 4, 2008 -> 0:20:12"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetSelectsWarning

	[Warning signal.
	self error: '']
		on: exceptionSelector
		do: [:ex| wasHandled := true].
	self assert: wasHandled
			description: 'Should have caught Warning'	! !

"June 4, 2008 -> 0:20:17"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetSelectsWarning

	[Warning signal.
	self error: '']
		on: exceptionSelector
		do: [:ex| wasHandled := true].
	self assert: wasHandled
			description: 'Should have caught Warning'! !

"June 4, 2008 -> 0:20:25"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetSelectsHalt

	[Halt signal.
	self error: '']
		on: exceptionSelector
		do: [:ex| wasHandled := true].
	self assert: wasHandled
			description: 'Should have caught Halt'	! !

"June 4, 2008 -> 0:20:30"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetSelectsHalt

	[Halt signal.
	self error: '']
		on: exceptionSelector
		do: [:ex| wasHandled := true].
	self assert: wasHandled
			description: 'Should have caught Halt'! !

"June 4, 2008 -> 0:20:54"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetShouldntSelectNotification

	[Notification signal]
		on: exceptionSelector
		do: [:ex| wasHandled := true].
	self deny: wasHandled
			description: 'Shouldn''t have caught Notification'	! !

"June 4, 2008 -> 0:21:49"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
signal: exceptionClass

	[exceptionClass signal]
		on: exceptionSelector
		do: [:ex| wasHandled := true].! !

"June 4, 2008 -> 0:22:8"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetSelectsHalt

	self signal: Halt.
	self assert: wasHandled
			description: 'Should have caught Halt'! !

"June 4, 2008 -> 0:22:23"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetSelectsWarning

	self signal: Warning
	self assert: wasHandled
			description: 'Should have caught Warning'! !

"June 4, 2008 -> 0:22:33"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetSelectsWarning

	self signal: Warning.
	self assert: wasHandled
			description: 'Should have caught Warning'! !

"June 4, 2008 -> 0:22:55"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetShouldntSelectNotification

	self signal: Notification.
	self deny: wasHandled
			description: 'Shouldn''t have caught Notification'	! !

"June 4, 2008 -> 0:25:22"!

"System saved" !
"June 4, 2008 -> 23:36:55"!

! (Delta mirrorFor: #SystemMonitorData) methodsFor: 'private' !
fractionFor: index <Integer> ^<Float>
	
	^total = 0
		ifTrue: [0.0d]
		ifFalse: [(data at: index) asFloat / total]
	! !

"June 4, 2008 -> 23:54:25"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
objectMemorySize

	^{{self primitiveObjectMemorySize}}! !

"June 4, 2008 -> 23:54:53"!

! (Delta mirrorFor: #SystemMonitorData) methodsFor: 'private' !
fractionFor: index <Integer> ^<Float>
	
	^total = 0
		ifTrue: [0.0d]
		ifFalse: [(data at: index) asFloat / total]! !

"June 4, 2008 -> 23:55:46"!

! (Delta mirrorFor: #SystemMonitorData) methodsFor: 'accessing' !
objectMemory

	^VM objectMemorySize! !

"June 4, 2008 -> 23:56:8"!

"System saved" !
"June 4, 2008 -> 23:57:17"!

! (Delta mirrorFor: #SystemMonitor) methodsFor: 'private  - initialization' !
entriesDo: blk <[Str, [^Float]]>
	"Iterates over all entries for the table"
	
	blk value: 'Optimized code'		value: [ self monitorData inCompiledCode ].
	blk value: 'Interpreted code'		value: [ self monitorData inInterpretedCode ].
	blk value: 'PIC code' 					value: [ self monitorData inPICCode ].
	blk value: 'Compiling' 					value: [ self monitorData inCompiler ].
	blk value: 'Garbage Collector'	value: [ self monitorData inGarbageCollector ].
	blk value: 'Stub code'					value: [ self monitorData inStubCode ].
	blk value: 'Primitives/DLL'			value: [ self monitorData inVM ].
	blk value: 'Primitives/DLL'			value: [ self monitorData inVM ]! !

"June 4, 2008 -> 23:57:27"!

! (Delta mirrorFor: #SystemMonitor) methodsFor: 'private' !
buildBareVisualTop: top <Boolean> ^ <Visual>

	self table: (Table rows: 8 columns: 2).
	self addConstantEntriesToTable.
	self startUpdateProcess.
	^self table imbeddedVisual" withBorder: (Border standard3DWithColor: Paint gray raised: false)"
! !

"June 4, 2008 -> 23:58:58"!

"System saved" !
"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #SystemMonitor) methodsFor: 'private  - initialization' !
entriesDo: blk <[Str, [^Float]]>
	"Iterates over all entries for the table"
	
	blk value: 'Optimized code'		value: [ self monitorData inCompiledCode ].
	blk value: 'Interpreted code'		value: [ self monitorData inInterpretedCode ].
	blk value: 'PIC code' 					value: [ self monitorData inPICCode ].
	blk value: 'Compiling' 					value: [ self monitorData inCompiler ].
	blk value: 'Garbage Collector'	value: [ self monitorData inGarbageCollector ].
	blk value: 'Stub code'					value: [ self monitorData inStubCode ].
	blk value: 'Primitives/DLL'			value: [ self monitorData inVM ].
	blk value: 'Object Memory'		value: [ self monitorData objectMemory ]! !

"June 6, 2008 -> 0:37:28"!

Delta define: #Model as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2008 -> 0:37:28"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Model' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'test processing' !
errorLog
	^SUnitNameResolver defaultLogDevice! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'test processing' !
showResult

	self errorLog cr;cr; show: '==== SUnit ======== Start ===='.
	self
		showResultSummary;
		showResultDefects.
	self errorLog cr; show: '==== SUnit ========== End ===='; cr.! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'test processing' !
showResultDefects

	(self result failureCount > 0)
		ifTrue: [
			self errorLog cr; show: '---- SUnit ----- Failures ----'.
			self result failures do: [:failure |
				self errorLog crtab; show: failure printString]].
	(self result errorCount > 0)
		ifTrue: [
			self errorLog cr; show: '---- SUnit ------- Errors ----'.
			self result errors do: [:error |
				self errorLog crtab; show: error printString]].! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'test processing' !
showResultSummary

	| message summary |
	message := (self result runCount = self result correctCount)
		ifTrue: [self successMessage]
		ifFalse: [self failureMessage].
	self errorLog crtab; show: message.
	summary :=
		self result runCount printString, ' run, ',
		self result failureCount printString, ' failed, ',
		self result errorCount printString, ' errors (',
		self duration printString, ' ms)'.
	self errorLog crtab; show: summary.! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
debugButtonLabel
        ^ 'DEBUG'! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
debugState

        ^true! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
errorColor
        ^ Color red! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
failColor
        ^ Color yellow! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
passColor
        ^ Color green! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
refreshButtonLabel
        ^ 'REFRESH'! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
refreshButtonState

        ^true! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
resetColor
        ^ Color white! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
runButtonColor
        ^ Color yellow! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
runButtonLabel
        ^ 'RUN ALL'! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
runButtonState

        ^true! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
runOneButtonLabel
        ^ 'RUN'! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
windowLabel

        ^'SUnit Camp Smalltalk ', TestCase sunitVersion, ' Test Runner'! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
debugTest! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
runOneTest
        Cursor execute showWhile:
                [testSuite notNil
                        ifTrue:
                                [self runWindow.
                                result _ testSuite asSymbol sunitAsClass suite run.
                                self updateWindow: result]
                        ifFalse:
                                [self runWindow.
                                self displayPassFail: 'No Test Suite Selected']]! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
runTests
	Cursor execute showWhile:[
		self runWindow.
		result := TestResult new.
		self suite tests do:[:each|
			self displayPassFail: 'Running ', each name.
			World displayWorld.
			each run: result.
			self updateWindow: result.
		].
	].
! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
selectedErrorTest
        ^selectedErrorTest! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
selectedFailureTest

        ^selectedFailureTest! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
selectedSuite

        ^selectedSuite! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
openAsMorph
        "TestRunner new openAsMorph"
        "=== build the parts ... ==="
        | topWindow runButton errorsList failuresList runOneButton
refreshButton |
        Smalltalk isMorphic
                ifFalse: [^self open].
        (topWindow _ SystemWindow labelled: self windowLabel) model: self.
        runButton _ PluggableButtonMorph
                                on: self
                                getState: #runButtonState
                                action: #runTests
                                label: #runButtonLabel.
        runButton color: self runButtonColor.
        runButton onColor: self runButtonColor offColor: self runButtonColor.
        runOneButton _ PluggableButtonMorph
                                on: self
                                getState: #runButtonState
                                action: #runOneTest
                                label: #runOneButtonLabel.
        runOneButton color: self runButtonColor.
        runOneButton onColor: self runButtonColor offColor: self
runButtonColor.
        refreshButton _ PluggableButtonMorph
                                on: self
                                getState: #refreshButtonState
                                action: #refreshTests
                                label: #refreshButtonLabel.
        refreshButton color: self runButtonColor.
        refreshButton onColor: self runButtonColor offColor: self
runButtonColor.
        passFailText _ PluggableTextMorph
                                on: self
                                text: #passFail
                                accept: nil.
        passFailText retractable: true.
        detailsText _ PluggableTextMorph
                                on: self
                                text: #details
                                accept: nil.
        detailsText retractable: true.
        testsList _ PluggableListMorph
                                on: self
                                list: #tests
                                selected: #selectedSuite
                                changeSelected: #selectedSuite:.
        testsList autoDeselect: false.
        failuresList _ PluggableListMorph
                                on: self
                                list: #failuresList
                                selected: #selectedFailureTest
                                changeSelected: #debugFailureTest:.
        errorsList _ PluggableListMorph
                                on: self
                                list: #errorsList
                                selected: #selectedErrorTest
                                changeSelected: #debugErrorTest:.
        "=== assemble the whole ... ==="
        topWindow addMorph: refreshButton frame: (0.0 @ 0.0 extent: 0.2 @ 0.2).
        topWindow addMorph: testsList frame: (0.2 @ 0.0 extent: 0.6 @ 0.2).
        topWindow addMorph: runOneButton frame: (0.8 @ 0.0 extent: 0.2 @ 0.1).
        topWindow addMorph: runButton frame: (0.8 @ 0.1 extent: 0.2 @ 0.1).
        topWindow addMorph: passFailText frame: (0.0 @ 0.2 extent: 1.0 @ 0.1).
        topWindow addMorph: detailsText frame: (0.0 @ 0.3 extent: 1.0 @ 0.1).
        topWindow addMorph: failuresList frame: (0.0 @ 0.4 extent: 1.0 @ 0.3).
        topWindow addMorph: errorsList frame: (0.0 @ 0.7 extent: 1.0 @ 0.3).
        "=== open it ... ==="
        topWindow openInWorldExtent: 400 @ 200.
        self refreshWindow.
        ^ topWindow! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'accessing' !
details

        ^details! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'accessing' !
errors

        ^errors! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'accessing' !
errorsList

        ^self errors collect: [:error | error printString]! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'accessing' !
failures

        ^failures! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'accessing' !
formatTime: aTime
        aTime hours > 0 ifTrue: [^aTime hours printString , 'h'].
        aTime minutes > 0 ifTrue: [^aTime minutes printString , 'min'].
        ^aTime seconds printString , ' sec'! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'accessing' !
passFail

        ^passFail! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'accessing' !
suite
        ^TestCase buildSuite! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'accessing' !
tests
        ^ tests! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'accessing' !
timeSinceLastPassAsString: aResult
        (lastPass isNil or: [aResult hasPassed not]) ifTrue: [^ ''].
        ^ ', ' , (self formatTime: (Time now subtractTime: lastPass)) , '
since last Pass'! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
displayDetails: aString
        details := aString.
        self changed: #details! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
displayErrors: anOrderedCollection

        errors := anOrderedCollection.
        self changed: #errorsList! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
displayFailures: anOrderedCollection

        failures := anOrderedCollection.
        self changed: #failuresList! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
displayPassFail: aString
        passFail := aString.
        self changed: #passFail! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
failuresList

	^self failures collect: [:failure | failure printString]! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshWindow
        passFailText isMorph
                ifTrue:
                        [passFailText color: Color white.
                        detailsText color: Color white]
                ifFalse:
                        [passFailText insideColor: Color white.
                        detailsText insideColor: Color white].
        self updateErrors: TestResult new.
        self updateFailures: TestResult new.
        self displayPassFail: 'N/A'.
        self displayDetails: '...'! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
runWindow
        passFailText isMorph
                ifTrue:
                        [passFailText color: Color white.
                        detailsText color: Color white]
                ifFalse:
                        [passFailText insideColor: Color white.
                        detailsText insideColor: Color white].
        self updateErrors: TestResult new.
        self updateFailures: TestResult new.
        self displayPassFail: 'Running...'.
        self displayDetails: '...'! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updateDetails: aTestResult
        self displayDetails: aTestResult printString , (self
timeSinceLastPassAsString: aTestResult).
        aTestResult hasPassed ifTrue: [lastPass _ Time now]! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updateErrors: aTestResult

        self displayErrors: aTestResult errors! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updateFailures: aTestResult

        self displayFailures: aTestResult failures asOrderedCollection! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updatePartColors: aColor
        passFailText isMorph
                ifTrue:
                        [passFailText color: aColor.
                        detailsText color: aColor]
                ifFalse:
                        [passFailText insideColor: aColor.
                        detailsText insideColor: aColor]! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updatePassFail: aTestResult
        | message |
        message _ aTestResult hasPassed
                                ifTrue: ['Pass']
                                ifFalse: ['Fail'].
        self displayPassFail: message! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updateWindow: aTestResult
        aTestResult errors size + aTestResult failures size = 0
                ifTrue: [self updatePartColors: self passColor]
                ifFalse: [aTestResult errors size > 0
                                ifTrue: [self updatePartColors: self
errorColor]
                                ifFalse: [self updatePartColors: self
failColor]].
        self updatePassFail: aTestResult.
        self updateDetails: aTestResult.
        self updateFailures: aTestResult.
        self updateErrors: aTestResult! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) classSide methodsFor: 'instance creation' !
new

        ^super new initialize! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) classSide methodsFor: 'instance creation' !
open
	"TestRunner open"
        ^super new initialize openAsMorph! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshTests
        tests := (TestCase allSubclasses collect: [:each | each name])
		asSortedCollection:[:a :b| a name asString <= b name asString].
        self changed: #tests.
        testSuite := nil.
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.
        self changed: #selectedFailureTest.             "added rew"
        self changed: #selectedErrorTest.               "added rew"
        self changed: #selectedSuite.
        self refreshWindow! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
debugErrorTest: anInteger
        selectedErrorTest := anInteger.				"added rew"
        selectedFailureTest := 0.							"added rew"
        self changed: #selectedFailureTest.		"added rew"
        self changed: #selectedErrorTest.			"added rew"
        (anInteger ~= 0)
                ifTrue: [(result errors at: anInteger) debug]! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
debugFailureTest: anInteger

        (anInteger ~= 0)
                ifTrue: [(self failures at: anInteger) debugAsFailure].

        selectedFailureTest := anInteger.
        selectedErrorTest := 0.
        self changed: #selectedErrorTest.
        self changed: #selectedFailureTest! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
selectedSuite: anInteger
        anInteger ~= 0 ifTrue: [testSuite := tests at: anInteger].
        selectedSuite := selectedSuite = anInteger
                                        ifTrue:[0]
                                        ifFalse:[anInteger].
        selectedFailureTest := 0.
        selectedErrorTest := 0.
        self changed: #selectedFailureTest.             "added rew"
        self changed: #selectedErrorTest.               "added rew" 
        self changed: #selectedSuite! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses collect: [:each | each name])
		asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses collect: [:each | each name])
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
openAsMorph
        "TestRunner new openAsMorph"
        "=== build the parts ... ==="
        | topWindow runButton errorsList failuresList runOneButton refreshButton |
        Smalltalk isMorphic
                ifFalse: [^self open].
        (topWindow := SystemWindow labelled: self windowLabel) model: self.
        runButton := PluggableButtonMorph
                               		on: self
                                	getState: #runButtonState
                                	action: #runTests
                                	label: #runButtonLabel.
        runButton color: self runButtonColor.
        runButton onColor: self runButtonColor offColor: self runButtonColor.
        runOneButton := PluggableButtonMorph
                                			on: self
                                			getState: #runButtonState
                                			action: #runOneTest
                                			label: #runOneButtonLabel.
        runOneButton color: self runButtonColor.
        runOneButton onColor: self runButtonColor offColor: self runButtonColor.
        refreshButton := PluggableButtonMorph
                                			on: self
                                			getState: #refreshButtonState
                                			action: #refreshTests
                                			label: #refreshButtonLabel.
        refreshButton color: self runButtonColor.
        refreshButton onColor: self runButtonColor offColor: self runButtonColor.
        passFailText := PluggableTextMorph
                                			on: self
                                			text: #passFail
                                			accept: nil.
        passFailText retractable: true.
        detailsText := PluggableTextMorph
                                		on: self
                                		text: #details
                                		accept: nil.
        detailsText retractable: true.
        testsList := PluggableListMorph
                                on: self
                                list: #tests
                                selected: #selectedSuite
                                changeSelected: #selectedSuite:.
        testsList autoDeselect: false.
        failuresList := PluggableListMorph
                                		on: self
                                		list: #failuresList
                                		selected: #selectedFailureTest
                                		changeSelected: #debugFailureTest:.
        errorsList := PluggableListMorph
                                	on: self
                                	list: #errorsList
                                	selected: #selectedErrorTest
                                	changeSelected: #debugErrorTest:.
        "=== assemble the whole ... ==="
        topWindow addMorph: refreshButton frame: (0.0 @ 0.0 extent: 0.2 @ 0.2).
        topWindow addMorph: testsList frame: (0.2 @ 0.0 extent: 0.6 @ 0.2).
        topWindow addMorph: runOneButton frame: (0.8 @ 0.0 extent: 0.2 @ 0.1).
        topWindow addMorph: runButton frame: (0.8 @ 0.1 extent: 0.2 @ 0.1).
        topWindow addMorph: passFailText frame: (0.0 @ 0.2 extent: 1.0 @ 0.1).
        topWindow addMorph: detailsText frame: (0.0 @ 0.3 extent: 1.0 @ 0.1).
        topWindow addMorph: failuresList frame: (0.0 @ 0.4 extent: 1.0 @ 0.3).
        topWindow addMorph: errorsList frame: (0.0 @ 0.7 extent: 1.0 @ 0.3).
        "=== open it ... ==="
        topWindow openInWorldExtent: 400 @ 200.
        self refreshWindow.
        ^ topWindow! !

"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess') !


"June 6, 2008 -> 0:37:29"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess') !


"June 6, 2008 -> 0:37:29"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess') !


"June 6, 2008 -> 0:37:29"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess') !


"June 6, 2008 -> 0:37:29"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess') !


"June 6, 2008 -> 0:37:29"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
startGCProcess

	GCProcess isNil
		or: [(GCProcess running
					or: [GCProcess suspended]) not]
		ifTrue: [GCProcess := [| delay |
														delay := Delay forMilliseconds: 500.
														[delay wait.
														VM objectMemorySize > 0.95
															ifTrue: [VM collectGarbage]] repeat] fork]
! !

"June 6, 2008 -> 0:37:29"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
startGCProcess

	GCProcess isNil
		or: [(GCProcess running
					or: [GCProcess suspended]) not]
		ifTrue: [GCProcess := [| delay |
														delay := Delay forMilliseconds: 500.
														[delay wait.
														VM objectMemorySize > 0.95
															ifTrue: [VM collectGarbage]] repeat] fork]! !

"June 6, 2008 -> 0:37:29"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
startGCProcess

	self needsNewGCProcess
		ifTrue: [GCProcess := [| delay |
														delay := Delay forMilliseconds: 500.
														[delay wait.
														VM objectMemorySize > 0.95
															ifTrue: [VM collectGarbage]] repeat] fork]! !

"June 6, 2008 -> 0:37:29"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
startGCProcess

	self needsNewGCProcess
		ifTrue: [self initializeGCProcess]! !

"June 6, 2008 -> 0:37:29"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
initializeGCProcess

GCProcess := [| delay |
														delay := Delay forMilliseconds: 500.
														[delay wait.
														VM objectMemorySize > 0.95
															ifTrue: [VM collectGarbage]] repeat] fork! !

"June 6, 2008 -> 0:37:29"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
needsNewGCProcess

	^GCProcess isNil
		or: [(GCProcess running
					or: [GCProcess suspended]) not]! !

"June 6, 2008 -> 0:37:29"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
needsNewGCProcess

	^GCProcess isNil
		or: [(GCProcess running
					or: [GCProcess suspended]) not]! !

"June 6, 2008 -> 0:37:29"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
initializeGCProcess

GCProcess := [| delay |
							delay := Delay forMilliseconds: 500.
							[delay wait.
							VM objectMemorySize > 0.95
								ifTrue: [VM collectGarbage]] repeat] fork! !

"June 6, 2008 -> 0:37:30"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
stopGCProcess

	self needsNewGCProcess
		ifFalse: [GCProcess terminate]! !

"June 6, 2008 -> 0:42:10"!

"System saved" !
"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #Application) methodsFor: 'launching' !
launch ^<Window>

	| win <Window> sess <Session> winCreated <Semaphore> 
		notCreated |
	winCreated := Semaphore new.
	notCreated := false.
	sess := Session in: Screen default
		do: [ :sess <Session> |
					winCreated wait.
					notCreated ifFalse: [	win makeActive show]].
	[win := self windowIn: sess.
	winCreated signal.
	sess sessionWindow: win]
		ifCurtailed: [notCreated := true.
								winCreated signal].
	^win! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #Application) methodsFor: 'launching' !
launch ^<Window>

	| win <Window> sess <Session> winCreated <Semaphore> 
		notCreated |
	winCreated := Semaphore new.
	notCreated := false.
	sess := Session in: Screen default
		do: [ :sess <Session> |
					winCreated wait.
					notCreated ifFalse: [	win makeActive show]].
	[win := self windowIn: sess.
	winCreated signal.
	sess sessionWindow: win]
		ifCurtailed: [notCreated := true.
								winCreated signal].
	^win! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox forSingleSelection! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsRow buttonBar container |
	testsRow := Row holding: (OrderedCollection
															with: ListBox forSingleSelection
															with: ListBox forSingleSelection
															with: (Column holding: (OrderedCollection
																											with: TextView new
																											with: TextView new))).
	buttonBar := Row holding: (OrderedCollection
															with: (Button labelled: #'1' action: [:b|])
															with: (Button labelled: #'2' action: [:b|])
															with: (Button labelled: #'3' action: [:b|])
															with: (Button labelled: #'4' action: [:b|])).
	container := Column holding: (OrderedCollection
																with: testsRow
																with: buttonBar).
	^container! !

"June 7, 2008 -> 3:36:20"!

"System saved" !
"June 7, 2008 -> 3:52:47"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsRow buttonBar container |
	testsRow := Row holding: (OrderedCollection
															with: ListBox forSingleSelection
															with: ListBox forSingleSelection
															with: (Column holding: (OrderedCollection
																											with: TextView forString imbeddedVisual
																											with: TextView forString imbeddedVisual))).
	buttonBar := Row holding: (OrderedCollection
															with: (Button labelled: #'1' action: [:b|])
															with: (Button labelled: #'2' action: [:b|])
															with: (Button labelled: #'3' action: [:b|])
															with: (Button labelled: #'4' action: [:b|])).
	container := Column holding: (OrderedCollection
																with: testsRow
																with: buttonBar).
	^container! !

"June 7, 2008 -> 3:57:35"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
textViewOn: aString

	^(TextView forString
			model: '';
			yourself)! !

"June 7, 2008 -> 3:58:8"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsRow buttonBar container |
	testsRow := Row holding: (OrderedCollection
															with: ListBox forSingleSelection
															with: ListBox forSingleSelection
															with: (Column holding: (OrderedCollection
																											with: (self textViewOn: '') imbeddedVisual
																											with: (self textViewOn: '') imbeddedVisual))).
	buttonBar := Row holding: (OrderedCollection
															with: (Button labelled: #'1' action: [:b|])
															with: (Button labelled: #'2' action: [:b|])
															with: (Button labelled: #'3' action: [:b|])
															with: (Button labelled: #'4' action: [:b|])).
	container := Column holding: (OrderedCollection
																with: testsRow
																with: buttonBar).
	^container! !

"June 7, 2008 -> 3:58:48"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsRow buttonBar container |
	testsRow := Row holding: (OrderedCollection
															with: ListBox forSingleSelection
															with: ListBox forSingleSelection
															with: (Column holding: (OrderedCollection
																											with: (self textViewOn: '') imbeddedVisual
																											with: (self textViewOn: '') imbeddedVisual))).
	buttonBar := Row holding: (OrderedCollection
															with: (Button labeled: #'1' action: [:b|])
															with: (Button labeled: #'2' action: [:b|])
															with: (Button labeled: #'3' action: [:b|])
															with: (Button labeled: #'4' action: [:b|])).
	container := Column holding: (OrderedCollection
																with: testsRow
																with: buttonBar).
	^container! !

"June 7, 2008 -> 3:59:20"!

"System saved" !
"June 7, 2008 -> 4:6:30"!

"System saved" !
"June 7, 2008 -> 14:56:46"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsRow buttonBar container equalizer buttonEqualizer |
	equalizer := Equalizer new.
	buttonEqualizer := Equalizer new.
	testsRow := Row holding: (OrderedCollection
															with: (equalizer for: (Row holding: (OrderedCollection
																																	with: self listbox
																																	with: self listbox)))
															with: (equalizer for: (Column holding: (OrderedCollection
																																			with: (self textViewOn: '') 
																																			with: (self textViewOn: ''))))).
	buttonBar := Row holding: (OrderedCollection
															with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																															action: [:b|]))
															with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																															action: [:b|]))
															with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																															action: [:b|]))).
	container := Column holding: (OrderedCollection
																with: testsRow
																with: buttonBar).
	self refreshWindow.
	^container! !

"June 7, 2008 -> 14:57:0"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshTests
        tests := (TestCase allSubclasses "collect: [:each | each name]")
		asSortedCollection:[:a :b| a name asString <= b name asString].
        self changed: #tests.
        testSuite := nil.
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.
        self changed: #selectedFailureTest.             "added rew"
        self changed: #selectedErrorTest.               "added rew"
        self changed: #selectedSuite.
        self refreshWindow! !

"June 7, 2008 -> 14:57:23"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
textViewOn: aString

	^(TextView forString
			isMultiLine: true;
			model: '';
			yourself)
			imbeddedVisual with3DBorder! !

"June 7, 2008 -> 14:57:36"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
listbox

	^ListBox forSingleSelection with3DBorder! !

"June 7, 2008 -> 14:58:0"!

"System saved" !
"June 7, 2008 -> 15:40:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsRow buttonBar container equalizer buttonEqualizer |
	equalizer := Equalizer new.
	buttonEqualizer := Equalizer new.
	passFailText := self textViewOn: ''.
	testsRow := Row holding: (OrderedCollection
															with: (equalizer for: self listbox)
															with: (equalizer for: (Column holding: (OrderedCollection
																																			with: passFailText imbeddedVisual with3DBorder
																																			with: self listbox
																																			with: self listbox)))).
	buttonBar := Row holding: (OrderedCollection
															with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																															action: [:b|]))
															with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																															action: [:b|]))
															with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																															action: [:b|]))).
	container := Column holding: (OrderedCollection
																with: testsRow
																with: buttonBar).
	"container changeAllocation: (Rectangle
																	corner: 0@0
																	corner: 400@200)
						at: 0@0."
	"self refreshWindow."
	^container! !

"June 7, 2008 -> 15:40:54"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
textViewOn: aString

	^TextView forString
			isMultiLine: true;
			model: '';
			yourself! !

"June 7, 2008 -> 15:41:20"!

"System saved" !
"June 7, 2008 -> 17:32:59"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer textEqualizer resultsRow resultsColumn |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: ''.
	detailsText := self textViewOn: ''.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: (self listbox 
																														naturalHeight: 300;
																														naturalWidth: 150;
																														yStretchy: true;
																														xStretchy: true;
																														yourself) with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																															action: [:b|]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																															action: [:b|]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b|]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: passFailText imbeddedVisual)
																			with: (textEqualizer for: detailsText imbeddedVisual)
																			with: (textEqualizer for: resultsRow)).
	^Row holding: (OrderedCollection
										with: testsColumn
										with: resultsColumn)! !

"June 7, 2008 -> 17:33:19"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
oldbuildBareVisualTop: top

	| testsRow buttonBar container equalizer buttonEqualizer |
	equalizer := Equalizer new.
	buttonEqualizer := Equalizer new.
	passFailText := self textViewOn: ''.
	testsRow := Row holding: (OrderedCollection
															with: (equalizer for: (self listbox 
																									naturalHeight: 300;
																									naturalWidth: 200;
																									yStretchy: true;
																									xStretchy: true;
																									yourself) with3DBorder)
															with: (equalizer for: (Column holding: (OrderedCollection
																																			with: passFailText imbeddedVisual with3DBorder
																																			with: self listbox with3DBorder
																																			with: self listbox with3DBorder)))).
	buttonBar := Row holding: (OrderedCollection
															with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																															action: [:b|]))
															with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																															action: [:b|]))
															with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																															action: [:b|]))).
	container := Column holding: (OrderedCollection
																with: testsRow
																with: buttonBar).

	"self refreshWindow."
	^ApplicationInterceptor
			for: container
			application: self! !

"June 7, 2008 -> 17:33:37"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'notificaition' !
visualAllocated
"self halt."
	"self inSessionProcessDo: [visual allocation: (Rectangle
																												corner: 0@0
																												corner: 400@200)
																	at: 0@0]."
	"self refreshWindow."! !

"June 7, 2008 -> 17:33:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
listbox

	^ListBox forSingleSelection! !

"June 7, 2008 -> 17:34:24"!

"System saved" !
"June 7, 2008 -> 19:32:58"!

Delta define: #TestRunner as: (
(Class subclassOf: 'NotifyingObject mixin |> Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 7, 2008 -> 19:32:58"!

Delta define: #TestRunner as: (
(Class subclassOf: 'NotifyingObject mixin |> Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 7, 2008 -> 19:32:58"!

Delta define: #TestRunner as: (
(Class subclassOf: 'NotifyingObject mixin |> Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 7, 2008 -> 19:32:58"!

Delta define: #TestRunner as: (
(Class subclassOf: 'NotifyingObject mixin |> Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 7, 2008 -> 19:32:58"!

Delta define: #TestRunner as: (
(Class subclassOf: 'NotifyingObject mixin |> Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 7, 2008 -> 19:32:58"!

Delta define: #TestRunner as: (
(Class subclassOf: 'NotifyingObject mixin |> Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 7, 2008 -> 19:32:58"!

Delta define: #TestRunner as: (
(Class subclassOf: 'NotifyingObject mixin |> Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 7, 2008 -> 19:32:58"!

Delta define: #TestRunner as: (
(Class subclassOf: 'NotifyingObject mixin |> Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 7, 2008 -> 19:32:58"!

Delta define: #TestRunner as: (
(Class subclassOf: 'NotifyingObject mixin |> Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 7, 2008 -> 19:32:58"!

Delta define: #TestRunner as: (
(Class subclassOf: 'NotifyingObject mixin |> Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 7, 2008 -> 19:32:58"!

Delta define: #TestRunner as: (
(Class subclassOf: 'NotifyingObject mixin |> Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 7, 2008 -> 19:33:33"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshWindow
        passFailText paint: Paint white.
        detailsText paint: Paint white.
        self updateErrors: TestResult new.
        self updateFailures: TestResult new.
        self displayPassFail: 'N/A'.
        self displayDetails: '...'! !

"June 7, 2008 -> 19:33:33"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer textEqualizer resultsRow resultsColumn |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: ''.
	detailsText := self textViewOn: ''.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: (self listbox 
																														naturalHeight: 300;
																														naturalWidth: 150;
																														yStretchy: true;
																														xStretchy: true;
																														yourself) with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																															action: [:b|]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																															action: [:b|]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b|]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: passFailText imbeddedVisual)
																			with: (textEqualizer for: detailsText imbeddedVisual)
																			with: (textEqualizer for: resultsRow)).
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 7, 2008 -> 19:33:33"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'notificaition' !
visualAllocated

	self refreshWindow! !

"June 7, 2008 -> 19:33:33"!

! (Delta mirrorFor: #TextView) methodsFor: 'private-initialization' !
initialize

	super initialize.
	self setPainter: self defaultPainter copy.
	self autoIndent: true.
	self maxUndo: 0.
	self isMultiLine: true.
	self monoPainter: false.
	self modelOutOfDate: false.
	self oneShotModel: false.
	self scrollable: false.! !

"June 7, 2008 -> 22:6:20"!

"System saved" !
"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

! (Delta mirrorFor: #ListModel) classSide methodsFor: 'instance creation' !
on: model items: itemSelector selected: accessor select: mutator

	^self new
			on: model
			items: itemSelector
			select: accessor
			select: mutator
	! !

"June 7, 2008 -> 22:58:27"!

! (Delta mirrorFor: #ListModel) methodsFor: 'initialization' !
on: model items: selector selected: accessor select: mutator

	model addDependent: self.
	"itemSelector := selector."
	! !

"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
')) !


"June 7, 2008 -> 22:58:27"!

! (Delta mirrorFor: #ListModel) methodsFor: 'initialization' !
on: aModel items: selector selected: accessor select: mutator

	| view |
	view := ListBox forSingleSelection.
	aModel addDependent: self.
	itemBlock := [view stringList: (aModel perform: selector)].
	selectionBlock := [view selections: (OrderedCollection
																		with: (aModel perform: accessor))].
	view onSelChange: [:lb | aModel	
														perform: mutator
														with: lb selections first]
	! !

"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'view " the list box displaying the list items "
model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
itemAspect " a selector used to retrieve the item strings from the model "
selectionAspect " a selector used to retrieve the selection from the model "
selectionMutator " a mutator used to change the selection in the model "')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'view " the list box displaying the list items "
model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
itemAspect " a selector used to retrieve the item strings from the model "
selectionAspect " a selector used to retrieve the selection from the model "
selectionMutator " a mutator used to change the selection in the model "')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'view " the list box displaying the list items "
model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
itemAspect " a selector used to retrieve the item strings from the model "
selectionAspect " a selector used to retrieve the selection from the model "
selectionMutator " a mutator used to change the selection in the model "')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'view " the list box displaying the list items "
model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
itemAspect " a selector used to retrieve the item strings from the model "
selectionAspect " a selector used to retrieve the selection from the model "
selectionMutator " a mutator used to change the selection in the model "')) !


"June 7, 2008 -> 22:58:27"!

! (Delta mirrorFor: #ListModel) methodsFor: 'notification' !
changed: aspect

	aspect == itemAspect
		ifTrue: [^view stringList: (model perform: itemAspect)].
	aspect == selectionAspect
		ifTrue: [^view selections: (OrderedCollection
																with: (model perform: selectionAspect))]! !

"June 7, 2008 -> 22:58:27"!

! (Delta mirrorFor: #ListModel) methodsFor: 'initialization' !
on: aModel items: selector selected: accessor select: mutator

	view := ListBox forSingleSelection.
	model := aModel.
	itemAspect := selector.
	selectionAspect := accessor.
	selectionMutator := mutator.
	
	aModel addDependent: self.
	view onSelChange: [:lb | aModel	
														perform: mutator
														with: lb selections first]
	! !

"June 7, 2008 -> 22:58:27"!

! (Delta mirrorFor: #ListModel) methodsFor: 'initialization' !
on: aModel items: selector selected: accessor select: mutator

	view := ListBox forSingleSelection.
	model := aModel.
	itemAspect := selector.
	selectionAspect := accessor.
	selectionMutator := mutator.
	
	model addDependent: self.
	view onSelChange: [:lb | aModel	
														perform: mutator
														with: lb selections first]
	! !

"June 7, 2008 -> 22:58:27"!

! (Delta mirrorFor: #ListModel) methodsFor: 'initialization' !
on: aModel items: selector selected: accessor select: mutator

	view := ListBox forSingleSelection.
	model := aModel.
	model addDependent: self.
	itemAspect := selector.
	selectionAspect := accessor.
	view onSelChange: [:lb | aModel	
														perform: mutator
														with: lb selections first]
	! !

"June 7, 2008 -> 22:58:27"!

! (Delta mirrorFor: #ListModel) methodsFor: 'initialization' !
on: aModel items: selector selected: accessor select: mutator

	view := ListBox forSingleSelection.
	model := aModel.
	model addDependent: self.
	itemAspect := selector.
	selectionAspect := accessor.
	view onSelChange: [:lb | aModel	
														perform: mutator
														with: lb selections first].
	^view
	! !

"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'view " the list box displaying the list items "
model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
itemAspect " a selector used to retrieve the item strings from the model "
selectionAspect " a selector used to retrieve the selection from the model "
selectionMutator " a mutator used to change the selection in the model "')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'view " the list box displaying the list items "
model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
itemAspect " a selector used to retrieve the item strings from the model "
selectionAspect " a selector used to retrieve the selection from the model "
selectionMutator " a mutator used to change the selection in the model "')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'view " the list box displaying the list items "
model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
itemAspect " a selector used to retrieve the item strings from the model "
selectionAspect " a selector used to retrieve the selection from the model "
selectionMutator " a mutator used to change the selection in the model "')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'view " the list box displaying the list items "
model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
itemAspect " a selector used to retrieve the item strings from the model "
selectionAspect " a selector used to retrieve the selection from the model "
selectionMutator " a mutator used to change the selection in the model "')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'view " the list box displaying the list items "
model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
itemAspect " a selector used to retrieve the item strings from the model "
selectionAspect " a selector used to retrieve the selection from the model "
selectionMutator " a mutator used to change the selection in the model "')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'view " the list box displaying the list items "
model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
itemAspect " a selector used to retrieve the item strings from the model "
selectionAspect " a selector used to retrieve the selection from the model "
selectionMutator " a mutator used to change the selection in the model "')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'view " the list box displaying the list items "
model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
itemAspect " a selector used to retrieve the item strings from the model "
selectionAspect " a selector used to retrieve the selection from the model "
selectionMutator " a mutator used to change the selection in the model "')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'view " the list box displaying the list items "
model " the model that provides the list items "
itemAspect " a selector used to retrieve the item strings from the model "
selectionAspect " a selector used to retrieve the selection from the model "')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'view " the list box displaying the list items "
model " the model that provides the list items "
itemAspect " a selector used to retrieve the item strings from the model "
selectionAspect " a selector used to retrieve the selection from the model "')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'view " the list box displaying the list items "
model " the model that provides the list items "
itemAspect " a selector used to retrieve the item strings from the model "
selectionAspect " a selector used to retrieve the selection from the model "')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'view " the list box displaying the list items "
model " the model that provides the list items "
itemAspect " a selector used to retrieve the item strings from the model "
selectionAspect " a selector used to retrieve the selection from the model "')) !


"June 7, 2008 -> 22:58:27"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: ''.
	detailsText := self textViewOn: ''.
	testList := ListModel
							on: self
							items: #tests
							selected: #selection
							select: #select:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: (testList
																														naturalHeight: 300;
																														naturalWidth: 150;
																														yStretchy: true;
																														xStretchy: true;
																														yourself) with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																															action: [:b|]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																															action: [:b|]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b|]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: passFailText imbeddedVisual)
																			with: (textEqualizer for: detailsText imbeddedVisual)
																			with: (textEqualizer for: resultsRow)).
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 7, 2008 -> 22:58:27"!

! (Delta mirrorFor: #ListModel) classSide methodsFor: 'instance creation' !
on: model items: itemSelector selected: accessor select: mutator

	^self new
			on: model
			items: itemSelector
			selected: accessor
			select: mutator
	! !

"June 7, 2008 -> 22:58:27"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: ''.
	detailsText := self textViewOn: ''.
	testList := ListModel
							on: self
							items: #tests
							selected: #selection
							select: #select:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: (testList
																														naturalHeight: 300;
																														naturalWidth: 150;
																														yStretchy: true;
																														xStretchy: true;
																														yourself) with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b|]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b|]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: passFailText imbeddedVisual)
																			with: (textEqualizer for: detailsText imbeddedVisual)
																			with: (textEqualizer for: resultsRow)).
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 7, 2008 -> 22:58:27"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshTests
		Transcript show: 'Refresh tests';cr.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
		asSortedCollection:[:a :b| a name asString <= b name asString].
        self changed: #tests.
        testSuite := nil.
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.
        self changed: #selectedFailureTest.             "added rew"
        self changed: #selectedErrorTest.               "added rew"
        self changed: #selectedSuite.
        self refreshWindow! !

"June 7, 2008 -> 22:58:27"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'accessing' !
tests
Transcript show: 'tests';cr.
        ^ tests! !

"June 7, 2008 -> 22:58:28"!

! (Delta mirrorFor: #ListModel) methodsFor: 'notification' !
changed: aspect
Transcript show: ('Changed ', aspect); cr.
	aspect == itemAspect
		ifTrue: [^view stringList: (model perform: itemAspect)].
	aspect == selectionAspect
		ifTrue: [^view selections: (OrderedCollection
																with: (model perform: selectionAspect))]! !

"June 7, 2008 -> 22:58:28"!

! (Delta mirrorFor: #NotifyingObject) methodsFor: 'private' !
changed: attribute <Object>
Transcript show: 'changed ', attribute.
	self changed: attribute with: nil! !

"June 7, 2008 -> 22:58:28"!

! (Delta mirrorFor: #NotifyingObject) methodsFor: 'private' !
changed: attribute <Object>
Transcript show: ('changed ', attribute); cr.
	self changed: attribute with: nil! !

"June 7, 2008 -> 22:58:28"!

! (Delta mirrorFor: #NotifyingObject) methodsFor: 'private' !
changed: attribute <Object>
self halt.
	self changed: attribute with: nil! !

"June 7, 2008 -> 22:58:28"!

! (Delta mirrorFor: #ListModel) methodsFor: 'notification' !
update: aspect
Transcript show: ('Changed ', aspect); cr.
	aspect == itemAspect
		ifTrue: [^view stringList: (model perform: itemAspect)].
	aspect == selectionAspect
		ifTrue: [^view selections: (OrderedCollection
																with: (model perform: selectionAspect))]! !

"June 7, 2008 -> 22:58:28"!

! (Delta mirrorFor: #NotifyingObject) methodsFor: 'private' !
changed: attribute <Object>

	self changed: attribute with: nil! !

"June 7, 2008 -> 22:58:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'accessing' !
tests

        ^ tests! !

"June 7, 2008 -> 22:58:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshTests
		Transcript show: 'Refresh tests';cr.
        tests := (TestCase allSubclasses collect: [:each | each name])
							asSortedCollection:[:a :b| a asString <= b asString].
        self changed: #tests.
        testSuite := nil.
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.
        self changed: #selectedFailureTest.             "added rew"
        self changed: #selectedErrorTest.               "added rew"
        self changed: #selectedSuite.
        self refreshWindow! !

"June 7, 2008 -> 22:58:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshTests

        tests := (TestCase allSubclasses collect: [:each | each name])
							asSortedCollection:[:a :b| a asString <= b asString].
        self changed: #tests.
        testSuite := nil.
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.
        self changed: #selectedFailureTest.             "added rew"
        self changed: #selectedErrorTest.               "added rew"
        self changed: #selectedSuite.
        self refreshWindow! !

"June 7, 2008 -> 22:58:28"!

! (Delta mirrorFor: #ListModel) methodsFor: 'notification' !
update: aspect

	aspect == itemAspect
		ifTrue: [^view stringList: (model perform: itemAspect)].
	aspect == selectionAspect
		ifTrue: [^view selections: (OrderedCollection
																with: (model perform: selectionAspect))]! !

"June 7, 2008 -> 22:58:28"!

(Delta mirrorFor: #ListModel) removeMethod: #changed: ifAbsent: [] !


"June 7, 2008 -> 22:58:28"!

! (Delta mirrorFor: #ListModel) methodsFor: 'initialization' !
on: aModel items: selector selected: accessor select: mutator

	view := ListBox forSingleSelection.
	model := aModel.
	model addDependent: self.
	itemAspect := selector.
	selectionAspect := accessor.
	view onSelChange: [:lb | aModel	
														perform: mutator
														with: lb selections anElement].
	^view
	! !

"June 7, 2008 -> 22:58:43"!

"System saved" !
"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: ''.
	detailsText := self textViewOn: ''.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: (testList
																														naturalHeight: 300;
																														naturalWidth: 150;
																														yStretchy: true;
																														xStretchy: true;
																														yourself) with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b|]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b|]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: passFailText imbeddedVisual)
																			with: (textEqualizer for: detailsText imbeddedVisual)
																			with: (textEqualizer for: resultsRow)).
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #Cursor) classSide methodsFor: 'instance creation' !
execute

	^self wait! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: ''.
	detailsText := self textViewOn: ''.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: (testList
																														naturalHeight: 300;
																														naturalWidth: 150;
																														yStretchy: true;
																														xStretchy: true;
																														yourself) with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: passFailText imbeddedVisual)
																			with: (textEqualizer for: detailsText imbeddedVisual)
																			with: (textEqualizer for: resultsRow)).
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
runOneTest
        "Cursor execute showWhile:
                ["
	testSuite notNil
		ifTrue: [self runWindow.
						result := testSuite asSymbol sunitAsClass suite run.
						self updateWindow: result]
 		ifFalse: [self runWindow.
						self displayPassFail: 'No Test Suite Selected']
       "]"! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
runTests
	"Cursor execute showWhile:["
	self runWindow.
	result := TestResult new.
	self suite tests
		do:[:each|
				self displayPassFail: 'Running ', each name.
				Processor yield.
				each run: result.
				self updateWindow: result]
	"]."
! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshWindow: passFailText
        passFailText paint: Paint white.
        detailsText paint: Paint white.
        self updateErrors: TestResult new.
        self updateFailures: TestResult new.
        self displayPassFail: passFailText.
        self displayDetails: '...'! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshWindow

        self refreshWindow: 'N/A'! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
runWindow

        self refreshWindow:  'Running...'! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshWindow: passFailText

        passFailText paint: Paint white.
        detailsText paint: Paint white.
        self updateErrors: TestResult new.
        self updateFailures: TestResult new.
        self displayPassFail: passFailText.
        self displayDetails: '...'! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshWindow: passFailString

        passFailText paint: Paint white.
        detailsText paint: Paint white.
        self updateErrors: TestResult new.
        self updateFailures: TestResult new.
        self displayPassFail: passFailString
        self displayDetails: '...'! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshWindow: passFailString

        passFailText paint: Paint white.
        detailsText paint: Paint white.
        self updateErrors: TestResult new.
        self updateFailures: TestResult new.
        self displayPassFail: passFailString.
        self displayDetails: '...'! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updateWindow: aTestResult
        aTestResult errors size + aTestResult failures size = 0
                ifTrue: [self updatePartColors: self passColor]
                ifFalse: [aTestResult errors size > 0
									ifTrue: [self updatePartColors: self errorColor]
									ifFalse: [self updatePartColors: self failColor]].
        self updatePassFail: aTestResult.
        self updateDetails: aTestResult.
        self updateFailures: aTestResult.
        self updateErrors: aTestResult! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
passColor
        ^ Paint green! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
failColor
        ^ Paint yellow! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
errorColor
        ^ Paint red! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updatePartColors: aColor

	passFailText paint: aColor.
	detailsText color: aColor! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updatePartColors: aColor

	passFailText paint: aColor.
	detailsText paint: aColor! !

"June 7, 2008 -> 23:28:54"!

"System saved" !
"June 7, 2008 -> 23:36:5"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updatePassFail: aTestResult

	| message |
	message := aTestResult hasPassed
								ifTrue: ['Pass']
								ifFalse: ['Fail'].
	self displayPassFail: message! !

"June 7, 2008 -> 23:36:5"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updateDetails: aTestResult

	| detailString |
	detailString := aTestResult printString , (self timeSinceLastPassAsString: aTestResult).
	self displayDetails: detailString.
	aTestResult hasPassed
		ifTrue: [lastPass := Time now]! !

"June 7, 2008 -> 23:36:5"!

! (Delta mirrorFor: #Time) methodsFor: 'arithmetic' !
subtractTime: amt <Date|Time> ^<Instance>

	^self actualClass fromSeconds: self asSeconds - amt asSeconds! !

"June 7, 2008 -> 23:36:26"!

"System saved" !
"June 8, 2008 -> 1:17:40"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updatePassFail: aTestResult

	| message |
	message := aTestResult hasPassed
								ifTrue: ['Pass']
								ifFalse: ['Fail'].
	self displayPassFail: message! !

"June 8, 2008 -> 1:17:40"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updateDetails: aTestResult

	| detailString |
	detailString := aTestResult printString , (self timeSinceLastPassAsString: aTestResult).
	self displayDetails: detailString.
	aTestResult hasPassed
		ifTrue: [lastPass := Time now]! !

"June 8, 2008 -> 1:17:41"!

! (Delta mirrorFor: #Time) methodsFor: 'arithmetic' !
subtractTime: amt <Date|Time> ^<Instance>

	^self actualClass fromSeconds: self asSeconds - amt asSeconds! !

"June 8, 2008 -> 1:23:1"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'accessing' !
formatTime: aTime
        aTime hour > 0 ifTrue: [^aTime hour printString , 'h'].
        aTime minutes > 0 ifTrue: [^aTime minutes printString , 'min'].
        ^aTime second printString , ' sec'! !

"June 8, 2008 -> 1:27:0"!

Delta define: #TextModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 8, 2008 -> 1:27:40"!

! (Delta mirrorFor: #TextModel) classSide methodsFor: 'instance creation' !
on: aModel text: selector

	^self new
			on: aModel
			text: selector! !

"June 8, 2008 -> 1:28:9"!

! (Delta mirrorFor: #TextModel) classSide methodsFor: 'instance creation' !
on: aModel text: aspect

	^self new
			on: aModel
			text: aspect! !

"June 8, 2008 -> 1:29:47"!

Delta define: #TextModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the contents "
aspect "  the aspect of the model "
view " the view to be updated with the contents "')) !


"June 8, 2008 -> 1:30:46"!

! (Delta mirrorFor: #TextModel) methodsFor: 'initialization' !
on: aModel text: anAspect

	view := TextView forString.
	view
		isMultiline: true;
		model: ''.
	model := aModel.
	aspect := anAspect! !

"June 8, 2008 -> 1:32:18"!

! (Delta mirrorFor: #TextModel) methodsFor: 'initialization' !
on: aModel text: anAspect

	view := TextView forString.
	view
		isMultiline: true;
		model: ''.
	model := aModel.
	aspect := anAspect.
	model addDependent: self.
	^view! !

"June 8, 2008 -> 1:33:24"!

! (Delta mirrorFor: #TextModel) methodsFor: 'notification' !
update: anAspect

	anAspect == aspect
		ifTrue: [view model: (model perform: aspect)]! !

"June 8, 2008 -> 1:34:23"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: (testList
																														naturalHeight: 300;
																														naturalWidth: 150;
																														yStretchy: true;
																														xStretchy: true;
																														yourself) with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: passFailText imbeddedVisual)
																			with: (textEqualizer for: detailsText imbeddedVisual)
																			with: (textEqualizer for: resultsRow)).
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 8, 2008 -> 1:34:49"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
textViewOn: aspect

	^TextModel
			on: self
			aspect: aspect! !

"June 8, 2008 -> 1:36:44"!

! (Delta mirrorFor: #TextModel) methodsFor: 'initialization' !
on: aModel aspect: anAspect

	view := TextView forString.
	view
		isMultiline: true;
		model: ''.
	model := aModel.
	aspect := anAspect.
	model addDependent: self.
	^view! !

"June 8, 2008 -> 1:36:47"!

! (Delta mirrorFor: #TextModel) classSide methodsFor: 'instance creation' !
on: aModel aspect: aspect

	^self new
			on: aModel
			aspect: aspect! !

"June 8, 2008 -> 1:37:39"!

! (Delta mirrorFor: #TextModel) methodsFor: 'initialization' !
on: aModel aspect: anAspect

	view := TextView forString.
	view
		isMultiLine: true;
		model: ''.
	model := aModel.
	aspect := anAspect.
	model addDependent: self.
	^view! !

"June 8, 2008 -> 1:40:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: (testList
																														naturalHeight: 300;
																														naturalWidth: 150;
																														yStretchy: true;
																														xStretchy: true;
																														yourself) with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: passFailText imbeddedVisual with3DBorder)
																			with: (textEqualizer for: detailsText imbeddedVisual with3DBorder)
																			with: (textEqualizer for: resultsRow)).
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 8, 2008 -> 1:44:5"!

"System saved" !
"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TextModel) methodsFor: 'notification' !
update: anAspect

	anAspect == aspect
		ifTrue: [Transcript show: ('updated: ', aspect); cr.
					view model: (model perform: aspect)]! !

"June 8, 2008 -> 18:19:37"!

(Delta mirrorFor: #TextModel) classSide removeMethod: #on:text: ifAbsent: [] !


"June 8, 2008 -> 18:19:37"!

(Delta mirrorFor: #TextModel) removeMethod: #on:text: ifAbsent: [] !


"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TextModel) methodsFor: 'initialization' !
on: aModel aspect: anAspect

	view := TextView forString.
	view
		isMultiLine: true;
		model: 'blank'.
	model := aModel.
	aspect := anAspect.
	model addDependent: self.
	^view! !

"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TextModel) methodsFor: 'notification' !
update: anAspect

	anAspect == aspect
		ifTrue: ["Transcript show: ('updated: ', aspect); cr."
					view model: (model perform: aspect).
					view visual invalidate]! !

"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TextModel) methodsFor: 'notification' !
update: anAspect

	anAspect == aspect
		ifTrue: [Transcript show: ('updated: ', aspect, ',', (model perform: aspect)); cr.
					view model: (model perform: aspect).
					view visual invalidate]! !

"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TextModel) methodsFor: 'initialization' !
on: aModel aspect: anAspect

	view := TextView forString.
	view
		isMultiLine: true;
		model: 'blank';
		paint: Paint black.
	model := aModel.
	aspect := anAspect.
	model addDependent: self.
	^view! !

"June 8, 2008 -> 18:19:37"!

(Delta mirrorFor: #TestRunner)
comment: 
'(TestRunner new launch)'!


"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TextView) methodsFor: 'accessing' !
paint: p <Paint>
Transcript cr. p  printOn: Transcript.
	self painter paint: p! !

"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Running' !
run: aResult 
	self tests do: [:each | 
		self sunitChanged: each.
		Processor yield.
		each run: aResult]
			! !

"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
errorColor
        ^ Paint black! !

"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
failColor
        ^ Paint black! !

"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
passColor
        ^ Paint black! !

"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
resetColor
        ^ Color black! !

"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshWindow: passFailString

        "passFailText paint: Paint white.
        detailsText paint: Paint white."
        self updateErrors: TestResult new.
        self updateFailures: TestResult new.
        self displayPassFail: passFailString.
        self displayDetails: '...'! !

"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TextModel) methodsFor: 'notification' !
update: anAspect

	anAspect == aspect
		ifTrue: [view model: (model perform: aspect)]! !

"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TextView) methodsFor: 'accessing' !
paint: p <Paint>

	self painter paint: p! !

"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'notificaition' !
visualAllocated
Transcript show: 'allocated'.
	self refreshWindow! !

"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'notificaition' !
visualAllocated

"	self refreshWindow"! !

"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: (testList
																														naturalHeight: 300;
																														naturalWidth: 150;
																														yStretchy: true;
																														xStretchy: true;
																														yourself) with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: passFailText imbeddedVisual with3DBorder)
																			with: (textEqualizer for: detailsText imbeddedVisual with3DBorder)
																			with: (textEqualizer for: resultsRow)).
	self refreshWindow.
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 8, 2008 -> 18:33:37"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
errorColor
        ^ Paint red! !

"June 8, 2008 -> 18:33:45"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
failColor
        ^ Paint yellow! !

"June 8, 2008 -> 18:37:5"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updateWindow: aTestResult
        aTestResult hasPassed
                ifTrue: [self updatePartColors: self passColor]
                ifFalse: [aTestResult hasErrors
									ifTrue: [self updatePartColors: self errorColor]
									ifFalse: [self updatePartColors: self failColor]].
        self updatePassFail: aTestResult.
        self updateDetails: aTestResult.
        self updateFailures: aTestResult.
        self updateErrors: aTestResult! !

"June 8, 2008 -> 18:41:57"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
passColor
        ^ Paint green! !

"June 8, 2008 -> 23:20:0"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
frameWithBorderAndBackdrop: visual

	^(visual with3DBorder)
			backdrop: (Painter new);
			yourself! !

"June 8, 2008 -> 23:21:35"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: (testList
																														naturalHeight: 300;
																														naturalWidth: 150;
																														yStretchy: true;
																														xStretchy: true;
																														yourself) with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: (self frameWithBorderAndBackDrop: passFailText imbeddedVisual))
																			with: (textEqualizer for: (self frameWithBorderAndBackDrop: detailsText imbeddedVisual))
																			with: (textEqualizer for: resultsRow)).
	self refreshWindow.
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 8, 2008 -> 23:24:59"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updatePartColors: aColor

	passFailText visual backgroundPainter paint: aColor.
	detailsText visual backgroundPainter paint: aColor! !

"June 8, 2008 -> 23:25:56"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: (testList
																														naturalHeight: 300;
																														naturalWidth: 150;
																														yStretchy: true;
																														xStretchy: true;
																														yourself) with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: passFailText imbeddedVisual))
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: detailsText imbeddedVisual))
																			with: (textEqualizer for: resultsRow)).
	self refreshWindow.
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 8, 2008 -> 23:28:31"!

! (Delta mirrorFor: #TextModel) methodsFor: 'initialization' !
on: aModel aspect: anAspect

	view := TextView forString.
	view
		isMultiLine: true;
		model: '';
		paint: Paint black.
	model := aModel.
	aspect := anAspect.
	model addDependent: self.
	^view! !

"June 8, 2008 -> 23:31:31"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshWindow: passFailString

        self updatePartColors: Paint white.
        self updateErrors: TestResult new.
        self updateFailures: TestResult new.
        self displayPassFail: passFailString.
        self displayDetails: '...'! !

"June 8, 2008 -> 23:40:41"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
buildTests

	^(TestCase allSubclasses collect: [:each | each name])
			asSortedCollection:[:a :b| a asString <= b asString]! !

"June 8, 2008 -> 23:40:54"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshTests

        tests := self buildTests.
        self changed: #tests.
        testSuite := nil.
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.
        self changed: #selectedFailureTest.             "added rew"
        self changed: #selectedErrorTest.               "added rew"
        self changed: #selectedSuite.
        self refreshWindow! !

"June 8, 2008 -> 23:41:6"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := self buildTests.
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 8, 2008 -> 23:42:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: (testList
																														naturalHeight: 300;
																														naturalWidth: 150;
																														yStretchy: true;
																														xStretchy: true;
																														yourself) with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: passFailText imbeddedVisual))
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: detailsText imbeddedVisual))
																			with: (textEqualizer for: resultsRow)).
	self updateAll.
	self refreshWindow.
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 8, 2008 -> 23:44:4"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updateAll

	self changed: #selectedFailureTest.
	self changed: #selectedErrorTest.
	self changed: #selectedSuite.
	self refreshWindow! !

"June 8, 2008 -> 23:44:55"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updateAll

	self changed: #tests.
	self changed: #details.
	self changed: #passFail.
	self refreshWindow! !

"June 8, 2008 -> 23:49:55"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: (testList
																														"naturalHeight: 300;
																														naturalWidth: 150;
																														yStretchy: true;
																														xStretchy: true;"
																														yourself) with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: passFailText imbeddedVisual))
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: detailsText imbeddedVisual))
																			with: (textEqualizer for: resultsRow)).
	self updateAll.
	self refreshWindow.
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 8, 2008 -> 23:53:32"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: testList with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: passFailText imbeddedVisual))
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: detailsText imbeddedVisual))
																			with: (textEqualizer for: resultsRow)).
	self updateAll.
	self refreshWindow.
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 9, 2008 -> 0:1:58"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList errorsList failuresList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	failuresList := ListModel
									on: self
									items: #failuresList
									selected: #selectedFailureTest
									select: #debugFailureTest:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: testList with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: passFailText imbeddedVisual))
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: detailsText imbeddedVisual))
																			with: (textEqualizer for: resultsRow)).
	self updateAll.
	self refreshWindow.
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 9, 2008 -> 0:2:41"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList errorsList failuresList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	failuresList := ListModel
									on: self
									items: #failuresList
									selected: #selectedFailureTest
									select: #debugFailureTest:.
	errorsList := ListModel
									on: self
									items: #errorsList
									selected: #selectedErrorTest
									select: #debugErrorTest:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: testList with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: passFailText imbeddedVisual))
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: detailsText imbeddedVisual))
																			with: (textEqualizer for: resultsRow)).
	self updateAll.
	self refreshWindow.
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 9, 2008 -> 0:9:11"!

! (Delta mirrorFor: #ListModel) methodsFor: 'initialization' !
on: aModel items: selector selected: accessor select: mutator

	view := ListBox forSingleSelection.
	model := aModel.
	model addDependent: self.
	itemAspect := selector.
	selectionAspect := accessor.
	view painter: (Painter new font: (Font forSpec: (FontSpec new points: 81; typeface: 'Times Roman')); yourself)
	view onSelChange: [:lb | aModel	
														perform: mutator
														with: lb selections anElement].
	^view
	! !

"June 9, 2008 -> 0:9:34"!

! (Delta mirrorFor: #ListModel) methodsFor: 'initialization' !
on: aModel items: selector selected: accessor select: mutator

	view := ListBox forSingleSelection.
	model := aModel.
	model addDependent: self.
	itemAspect := selector.
	selectionAspect := accessor.
	view painter: Painter new.
	view onSelChange: [:lb | aModel	
														perform: mutator
														with: lb selections anElement].
	^view
	! !

"June 9, 2008 -> 0:20:35"!

! (Delta mirrorFor: #ListModel) methodsFor: 'initialization' !
on: aModel items: selector selected: accessor select: mutator

	view := ListBox forSingleSelection.
	model := aModel.
	model addDependent: self.
	itemAspect := selector.
	selectionAspect := accessor.
	view onSelChange: [:lb | aModel	
														perform: mutator
														with: lb selections anElement].
	^view
	! !

"June 9, 2008 -> 0:22:9"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList errorsList failuresList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	testList painter font: self font.
	failuresList := ListModel
									on: self
									items: #failuresList
									selected: #selectedFailureTest
									select: #debugFailureTest:.
	errorsList := ListModel
									on: self
									items: #errorsList
									selected: #selectedErrorTest
									select: #debugErrorTest:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: testList with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: passFailText imbeddedVisual))
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: detailsText imbeddedVisual))
																			with: (textEqualizer for: resultsRow)).
	self updateAll.
	self refreshWindow.
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 9, 2008 -> 0:22:33"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
font

	^Font forSpec: (FontSpec new points: 8; typeface: 'Times Roman')! !

"June 9, 2008 -> 0:28:34"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList errorsList failuresList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	failuresList := ListModel
									on: self
									items: #failuresList
									selected: #selectedFailureTest
									select: #debugFailureTest:.
	errorsList := ListModel
									on: self
									items: #errorsList
									selected: #selectedErrorTest
									select: #debugErrorTest:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: testList with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: passFailText imbeddedVisual))
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: detailsText imbeddedVisual))
																			with: (textEqualizer for: resultsRow)).
	self updateAll.
	self refreshWindow.
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 9, 2008 -> 0:30:49"!

! (Delta mirrorFor: #TestRunner) classSide methodsFor: 'instance creation' !
open
	"TestRunner open"
        ^super new launch! !

"June 9, 2008 -> 0:31:17"!

! (Delta mirrorFor: #TestRunner) classSide methodsFor: 'instance creation' !
open
	"(TestRunner open)"
        ^super new launch! !

"June 9, 2008 -> 0:32:59"!

! (Delta mirrorFor: #HaltTest) methodsFor: 'Testing' !
testShouldBeResumable

	self deny: Halt new isResumable! !

"June 9, 2008 -> 0:35:12"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList errorsList failuresList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	failuresList := ListModel
									on: self
									items: #failuresList
									selected: #selectedFailureTest
									select: #debugFailureTest:.
	errorsList := ListModel
									on: self
									items: #errorsList
									selected: #selectedErrorTest
									select: #debugErrorTest:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: testList with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: failuresList with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: errorsList with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: passFailText imbeddedVisual))
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: detailsText imbeddedVisual))
																			with: (textEqualizer for: resultsRow)).
	self updateAll.
	self refreshWindow.
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 9, 2008 -> 0:35:24"!

(Delta mirrorFor: #TestRunner)
comment: 
'(TestRunner open)'!


"June 9, 2008 -> 0:38:44"!

"System saved" !
"June 9, 2008 -> 0:39:34"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
debugFailureTest: anInteger

        (anInteger ~= 0)
                ifTrue: [[(self failures at: anInteger) debugAsFailure] fork].

        selectedFailureTest := anInteger.
        selectedErrorTest := 0.
        self changed: #selectedErrorTest.
        self changed: #selectedFailureTest! !

"June 9, 2008 -> 0:40:16"!

! (Delta mirrorFor: #HaltTest) methodsFor: 'Testing' !
testShouldBeResumable

	self assert: Halt new isResumable! !

"June 9, 2008 -> 0:41:8"!

! (Delta mirrorFor: #HaltTest) methodsFor: 'Testing' !
testShouldBeResumable

	self deny: Halt new isResumable! !

"June 9, 2008 -> 0:41:24"!

! (Delta mirrorFor: #HaltTest) methodsFor: 'Testing' !
testShouldBeResumable
	self halt.
	self deny: Halt new isResumable! !

"June 9, 2008 -> 0:41:43"!

! (Delta mirrorFor: #HaltTest) methodsFor: 'Testing' !
testShouldBeResumable

	self assert: Halt new isResumable! !

"June 9, 2008 -> 0:43:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[[aTestCase runCase.
			true]
				sunitOn: self class failure
				do: [:signal |
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
									self errors add: aTestCase.
									signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"June 9, 2008 -> 0:44:29"!

"System saved" !
"June 9, 2008 -> 0:47:16"!

(Delta mirrorFor: #TestRunner) removeMethod: #oldbuildBareVisualTop: ifAbsent: [] !


"June 9, 2008 -> 0:47:19"!

(Delta mirrorFor: #TestRunner) removeMethod: #openAsMorph ifAbsent: [] !


"June 9, 2008 -> 0:47:49"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList errorsList failuresList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	failuresList := ListModel
									on: self
									items: #failuresList
									selected: #selectedFailureTest
									select: #debugFailureTest:.
	errorsList := ListModel
									on: self
									items: #errorsList
									selected: #selectedErrorTest
									select: #debugErrorTest:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: testList with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: failuresList with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: errorsList with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: passFailText imbeddedVisual))
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: detailsText imbeddedVisual))
																			with: (textEqualizer for: resultsRow)).
	self updateAll.
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 9, 2008 -> 0:48:2"!

(Delta mirrorFor: #TestRunner) removeMethod: #listbox ifAbsent: [] !


"June 9, 2008 -> 0:48:20"!

(Delta mirrorFor: #TestRunner) removeMethod: #resetColor ifAbsent: [] !


"June 9, 2008 -> 0:48:31"!

(Delta mirrorFor: #TestRunner) removeMethod: #runButtonColor ifAbsent: [] !


"June 9, 2008 -> 0:48:52"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
refreshButtonLabel
        ^ 'Refresh'! !

"June 9, 2008 -> 0:49:2"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
runButtonLabel
        ^ 'Run All'! !

"June 9, 2008 -> 0:49:10"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
runOneButtonLabel
        ^ 'Run'! !

"June 9, 2008 -> 0:51:28"!

(Delta mirrorFor: #TestRunner)
comment: 
'Test runner for SUnit tests. To launch doit on the following:-

	(TestRunner open)'!


"June 9, 2008 -> 0:53:22"!

"System saved" !
"June 10, 2008 -> 10:12:46"!

Delta define: #DoesNotUnderstandFixture as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 10, 2008 -> 10:13:40"!

! (Delta mirrorFor: #DoesNotUnderstandFixture) methodsFor: 'error handling' !
doesNotUnderstand: message

	^message! !

"June 10, 2008 -> 10:14:7"!

"System saved" !
"June 11, 2008 -> 21:31:27"!

! (Delta mirrorFor: #DoesNotUnderstandFixture) methodsFor: 'dnu triggers' !
dnuTrigger1

	^self quack! !

"June 11, 2008 -> 21:31:45"!

"System saved" !
"June 14, 2008 -> 22:4:38"!

Delta define: #DoesNotUnderstandTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 14, 2008 -> 22:7:41"!

! (Delta mirrorFor: #DoesNotUnderstandTest) methodsFor: 'Testing' !
testUnknownMethodReturnsResultFromDoesNotUnderstand

	| message |
	message := DoesNotUnderstandFixture new zork.
	self assert: #zork == message selector
			description: 'Wrong selector returned'! !

"June 14, 2008 -> 22:8:20"!

! (Delta mirrorFor: #DoesNotUnderstandTest) methodsFor: 'Testing' !
testUnknownNoArgMethodReturnsResultFromDoesNotUnderstand

	| message |
	message := DoesNotUnderstandFixture new zork.
	self assert: #zork == message selector
			description: 'Wrong selector returned'! !

"June 14, 2008 -> 22:8:34"!

! (Delta mirrorFor: #DoesNotUnderstandTest) methodsFor: 'Testing' !
testUnknownOneArgMethodReturnsResultFromDoesNotUnderstand

	| message |
	message := DoesNotUnderstandFixture new zork.
	self assert: #zork == message selector
			description: 'Wrong selector returned'! !

"June 14, 2008 -> 22:8:37"!

(Delta mirrorFor: #DoesNotUnderstandTest) removeMethod: #testUnknownMethodReturnsResultFromDoesNotUnderstand ifAbsent: [] !


"June 14, 2008 -> 22:9:17"!

! (Delta mirrorFor: #DoesNotUnderstandTest) methodsFor: 'Testing' !
testUnknownNoArgMethodReturnsResultFromDoesNotUnderstand

	| message |
	message := DoesNotUnderstandFixture new zork: 1.
	self assert: #zork: == message selector
			description: 'Wrong selector returned'.
	self assert: 1 == message args size
			description: 'Wrong number of args'! !

"June 14, 2008 -> 22:9:49"!

! (Delta mirrorFor: #DoesNotUnderstandTest) methodsFor: 'Testing' !
testUnknownNoArgMethodReturnsResultFromDoesNotUnderstand

	| message |
	message := DoesNotUnderstandFixture new zork: 1.
	self assert: #zork: == message selector
			description: 'Wrong selector returned'.
	self assert: 1 == message arguments size
			description: 'Wrong number of arguments'! !

"June 14, 2008 -> 22:10:25"!

! (Delta mirrorFor: #DoesNotUnderstandTest) methodsFor: 'Testing' !
testUnknownNoArgMethodReturnsResultFromDoesNotUnderstand

	| message |
	message := DoesNotUnderstandFixture new zork: 1.
	self assert: #zork: == message selector
			description: 'Wrong selector returned'.
	self assert: 1 == message arguments size
			description: 'Wrong number of arguments'.
	self assert: 1 == message arguments first
			description: 'Wrong argument returned'! !

"June 14, 2008 -> 22:15:43"!

"System saved" !
"June 15, 2008 -> 18:9:0"!

Delta define: #BlockNLRTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 15, 2008 -> 18:10:49"!

! (Delta mirrorFor: #BlockNLRTest) methodsFor: 'Testing' !
testNLRResult

	100000 timesRepeat: [
		self assert: 1 = (self nlrWith: 1)
				description: 'Should have returned 1']! !

"June 15, 2008 -> 18:12:16"!

! (Delta mirrorFor: #BlockNLRTest) methodsFor: 'Testing' !
nlrWith: value

	self doWith: [^value].
	^2 * value! !

"June 15, 2008 -> 18:12:37"!

! (Delta mirrorFor: #BlockNLRTest) methodsFor: 'Testing' !
doWith: block

	^block value! !

"June 15, 2008 -> 18:14:2"!

! (Delta mirrorFor: #BlockNLRTest) methodsFor: 'Testing' !
testNLRResult

	1000000 timesRepeat: [
		self assert: 1 = (self nlrWith: 1)
				description: 'Should have returned 1']! !

"June 15, 2008 -> 18:14:12"!

! (Delta mirrorFor: #BlockNLRTest) methodsFor: 'Testing' !
testNLRResult

	10000000 timesRepeat: [
		self assert: 1 = (self nlrWith: 1)
				description: 'Should have returned 1']! !

"June 15, 2008 -> 18:15:46"!

! (Delta mirrorFor: #BlockNLRTest) methodsFor: 'Testing' !
testNLRResult

	100000000 timesRepeat: [
		self assert: 1 = (self nlrWith: 1)
				description: 'Should have returned 1']! !

"June 15, 2008 -> 18:16:42"!

"System saved" !
"June 17, 2008 -> 1:14:5"!

! (Delta mirrorFor: #BlockNLRTest) methodsFor: 'Testing' !
nlrWith: value with: boolean

	self doWith: [boolean ifTrue: [^value].
							3 * value].
	^2 * value! !

"June 17, 2008 -> 1:14:5"!

! (Delta mirrorFor: #BlockNLRTest) methodsFor: 'Testing' !
testNLRResult

	100000000 timesRepeat: [
		self assert: 1 = (self nlrWith: 1 with: true)
				description: 'Should have returned 1']! !

"June 17, 2008 -> 1:14:5"!

! (Delta mirrorFor: #BlockNLRTest) methodsFor: 'Testing' !
testNLRResult

	100000000 timesRepeat: [
		| result |
		result := (self nlrWith: 1 with: true).
		self assert: 1 = result
				description: 'Should have returned 1, but was: ', result printString]! !

"June 17, 2008 -> 1:14:36"!

! (Delta mirrorFor: #BlockNLRTest) methodsFor: 'Testing' !
testNLRResult

	10000 timesRepeat: [
		| result |
		result := (self nlrWith: 1 with: true).
		self assert: 1 = result
				description: 'Should have returned 1, but was: ', result printString]! !

"June 17, 2008 -> 1:16:18"!

! (Delta mirrorFor: #BlockNLRTest) methodsFor: 'Testing' !
testNLRResult

	100000 timesRepeat: [
		| result |
		result := (self nlrWith: 1 with: true).
		self assert: 1 = result
				description: 'Should have returned 1, but was: ', result printString]! !

"June 17, 2008 -> 1:16:29"!

! (Delta mirrorFor: #BlockNLRTest) methodsFor: 'Testing' !
testNLRResult

	1000000 timesRepeat: [
		| result |
		result := (self nlrWith: 1 with: true).
		self assert: 1 = result
				description: 'Should have returned 1, but was: ', result printString]! !

"June 17, 2008 -> 1:17:1"!

"System saved" !
"August 17, 2008 -> 19:16:42"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
safePrintString: aValue

	[^aValue printString]
		on: Error
		do: [^'Cannot print instance of ', aValue class name]! !

"August 17, 2008 -> 19:16:42"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
safePrintString: aValue

	^[aValue printString]
		on: Error
		do: ['Cannot print instance of ', aValue class name]! !

"August 17, 2008 -> 19:16:42"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
safePrintString: aValue

	^[aValue printString]
		on: Error
		do: ['Cannot print instance of ', aValue class name]! !

"August 17, 2008 -> 19:16:42"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildClosedHeader ^ <Visual>

	| selector <Symbol> args <Array[Object]> row <Row[Visual]> |
	
	"Check type of activation"
	self activation isSmalltalk
		ifFalse: [	^(StringGlyph for: 'External activation' painter: self codePainter) asVisual ].

	selector := self activation method enclosingMethod selector.
	args := self activation arguments.
	row := Row[Visual] new.
	
	self activation method isBlockMethod
		ifTrue: [		"Add block parens interspersed with arguments"
							row add: (StringGlyph for: '[' painter: self codePainter) asVisual.
							args do: [ :arg <Object> |
								row add: (StringGlyph for: ':' painter: self selectorPainter) asVisual.
								row add: (self
									buildLabel: (self safePrintString: arg)
									painter: self codePainter
									action: [ (Inspector on: arg) launch ]) ].
							row add: (StringGlyph for: '] in ' painter: self codePainter) asVisual.
							row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
		ifFalse: [	"Add receiver"
							| receiver <Object> |
							receiver := self activation receiver.
							row add: (self
								buildLabel: receiver printString 
								painter: self codePainter
								action: [ (Inspector on: receiver) launch ]).
							row add: (StringGlyph for: '>> ' painter: self codePainter) asVisual.
							"Add selector interspersed with arguments"
							args size = 0
								ifTrue: [		row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
								ifFalse: [	| strm <CharacterReadStream> |
													strm := selector readStream.
													args do: [ :arg <Object> |
														row add: (StringGlyph for: (strm upTo: $:), ':' painter: self selectorPainter) asVisual.
														row add: (self
															buildLabel: arg printString 
															painter: self codePainter
															action: [ (Inspector on: arg) launch ]) ]
												]
						].
	^row! !

"August 17, 2008 -> 19:16:42"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildClosedHeader ^ <Visual>

	| selector <Symbol> args <Array[Object]> row <Row[Visual]> |
	
	"Check type of activation"
	self activation isSmalltalk
		ifFalse: [	^(StringGlyph for: 'External activation' painter: self codePainter) asVisual ].

	selector := self activation method enclosingMethod selector.
	args := self activation arguments.
	row := Row[Visual] new.
	
	self activation method isBlockMethod
		ifTrue: [		"Add block parens interspersed with arguments"
							row add: (StringGlyph for: '[' painter: self codePainter) asVisual.
							args do: [ :arg <Object> |
								row add: (StringGlyph for: ':' painter: self selectorPainter) asVisual.
								row add: (self
									buildLabel: (self safePrintString: arg)
									painter: self codePainter
									action: [ (Inspector on: arg) launch ]) ].
							row add: (StringGlyph for: '] in ' painter: self codePainter) asVisual.
							row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
		ifFalse: [	"Add receiver"
							| receiver <Object> |
							receiver := self activation receiver.
							row add: (self
								buildLabel: (self safePrintString: receiver)
								painter: self codePainter
								action: [ (Inspector on: receiver) launch ]).
							row add: (StringGlyph for: '>> ' painter: self codePainter) asVisual.
							"Add selector interspersed with arguments"
							args size = 0
								ifTrue: [		row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
								ifFalse: [	| strm <CharacterReadStream> |
													strm := selector readStream.
													args do: [ :arg <Object> |
														row add: (StringGlyph for: (strm upTo: $:), ':' painter: self selectorPainter) asVisual.
														row add: (self
															buildLabel: (self safePrintString: arg)
															painter: self codePainter
															action: [ (Inspector on: arg) launch ]) ]
												]
						].
	^row! !

"August 17, 2008 -> 19:16:42"!

! (Delta mirrorFor: #Test) methodsFor: 'test' !
printString

^1 + 'a'! !

"August 17, 2008 -> 19:16:42"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
safePrintString: aValue

	^[aValue printString]
		on: Error
		do: ['Cannot print instance of ', aValue class name]! !

"August 17, 2008 -> 19:16:42"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildClosedHeader ^ <Visual>

	| selector <Symbol> args <Array[Object]> row <Row[Visual]> |
	
	"Check type of activation"
	self activation isSmalltalk
		ifFalse: [	^(StringGlyph for: 'External activation' painter: self codePainter) asVisual ].

	selector := self activation method enclosingMethod selector.
	args := self activation arguments.
	row := Row[Visual] new.
	
	self activation method isBlockMethod
		ifTrue: [		"Add block parens interspersed with arguments"
							row add: (StringGlyph for: '[' painter: self codePainter) asVisual.
							args do: [ :arg <Object> |
								row add: (StringGlyph for: ':' painter: self selectorPainter) asVisual.
								row add: (self
									buildLabel: (self safePrintString: arg)
									painter: self codePainter
									action: [ (Inspector on: arg) launch ]) ].
							row add: (StringGlyph for: '] in ' painter: self codePainter) asVisual.
							row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
		ifFalse: [	"Add receiver"
							| receiver <Object> |
							receiver := self activation receiver.
							row add: (self
								buildLabel: (self safePrintString: receiver)
								painter: self codePainter
								action: [ (Inspector on: receiver) launch ]).
							row add: (StringGlyph for: '>> ' painter: self codePainter) asVisual.
							"Add selector interspersed with arguments"
							args size = 0
								ifTrue: [		row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
								ifFalse: [	| strm <CharacterReadStream> |
													strm := selector readStream.
													args do: [ :arg <Object> |
														row add: (StringGlyph for: (strm upTo: $:), ':' painter: self selectorPainter) asVisual.
														row add: (self
															buildLabel: (self safePrintString: arg)
															painter: self codePainter
															action: [ (Inspector on: arg) launch ]) ]
												]
						].
	^row! !

"August 17, 2008 -> 19:16:42"!

! (Delta mirrorFor: #Test) methodsFor: 'test' !
printString

^1 + 'a'! !

"August 17, 2008 -> 19:16:42"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
safePrintString: aValue

	^[aValue printString]
		on: Error
		do: [:ex|'Cannot print instance of ', aValue class name]! !

"August 17, 2008 -> 19:16:42"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
safePrintString: aValue

	^[aValue printString]
		on: Error
		do: [:ex|'instance of ', aValue class name]! !

"August 17, 2008 -> 19:16:42"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
safePrintString: aValue

	^[aValue printString]
		on: Error
		do: [:ex|'??instance of ', aValue class name]! !

"August 17, 2008 -> 19:16:42"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
safePrintString: aValue

	[^aValue printString]
		on: Error
		do: [^'Cannot print instance of ', aValue class name]! !

"August 17, 2008 -> 19:16:42"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
safePrintString: aValue

	^[aValue printString]
		on: Error
		do: ['Cannot print instance of ', aValue class name]! !

"August 17, 2008 -> 19:16:42"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
safePrintString: aValue

	^[aValue printString]
		on: Error
		do: ['Cannot print instance of ', aValue class name]! !

"August 17, 2008 -> 19:16:43"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildClosedHeader ^ <Visual>

	| selector <Symbol> args <Array[Object]> row <Row[Visual]> |
	
	"Check type of activation"
	self activation isSmalltalk
		ifFalse: [	^(StringGlyph for: 'External activation' painter: self codePainter) asVisual ].

	selector := self activation method enclosingMethod selector.
	args := self activation arguments.
	row := Row[Visual] new.
	
	self activation method isBlockMethod
		ifTrue: [		"Add block parens interspersed with arguments"
							row add: (StringGlyph for: '[' painter: self codePainter) asVisual.
							args do: [ :arg <Object> |
								row add: (StringGlyph for: ':' painter: self selectorPainter) asVisual.
								row add: (self
									buildLabel: (self safePrintString: arg)
									painter: self codePainter
									action: [ (Inspector on: arg) launch ]) ].
							row add: (StringGlyph for: '] in ' painter: self codePainter) asVisual.
							row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
		ifFalse: [	"Add receiver"
							| receiver <Object> |
							receiver := self activation receiver.
							row add: (self
								buildLabel: receiver printString 
								painter: self codePainter
								action: [ (Inspector on: receiver) launch ]).
							row add: (StringGlyph for: '>> ' painter: self codePainter) asVisual.
							"Add selector interspersed with arguments"
							args size = 0
								ifTrue: [		row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
								ifFalse: [	| strm <CharacterReadStream> |
													strm := selector readStream.
													args do: [ :arg <Object> |
														row add: (StringGlyph for: (strm upTo: $:), ':' painter: self selectorPainter) asVisual.
														row add: (self
															buildLabel: arg printString 
															painter: self codePainter
															action: [ (Inspector on: arg) launch ]) ]
												]
						].
	^row! !

"August 17, 2008 -> 19:16:43"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildClosedHeader ^ <Visual>

	| selector <Symbol> args <Array[Object]> row <Row[Visual]> |
	
	"Check type of activation"
	self activation isSmalltalk
		ifFalse: [	^(StringGlyph for: 'External activation' painter: self codePainter) asVisual ].

	selector := self activation method enclosingMethod selector.
	args := self activation arguments.
	row := Row[Visual] new.
	
	self activation method isBlockMethod
		ifTrue: [		"Add block parens interspersed with arguments"
							row add: (StringGlyph for: '[' painter: self codePainter) asVisual.
							args do: [ :arg <Object> |
								row add: (StringGlyph for: ':' painter: self selectorPainter) asVisual.
								row add: (self
									buildLabel: (self safePrintString: arg)
									painter: self codePainter
									action: [ (Inspector on: arg) launch ]) ].
							row add: (StringGlyph for: '] in ' painter: self codePainter) asVisual.
							row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
		ifFalse: [	"Add receiver"
							| receiver <Object> |
							receiver := self activation receiver.
							row add: (self
								buildLabel: (self safePrintString: receiver)
								painter: self codePainter
								action: [ (Inspector on: receiver) launch ]).
							row add: (StringGlyph for: '>> ' painter: self codePainter) asVisual.
							"Add selector interspersed with arguments"
							args size = 0
								ifTrue: [		row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
								ifFalse: [	| strm <CharacterReadStream> |
													strm := selector readStream.
													args do: [ :arg <Object> |
														row add: (StringGlyph for: (strm upTo: $:), ':' painter: self selectorPainter) asVisual.
														row add: (self
															buildLabel: (self safePrintString: arg)
															painter: self codePainter
															action: [ (Inspector on: arg) launch ]) ]
												]
						].
	^row! !

"August 17, 2008 -> 19:16:43"!

! (Delta mirrorFor: #Test) methodsFor: 'test' !
printString

^1 + 'a'! !

"August 17, 2008 -> 19:16:43"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
safePrintString: aValue

	^[aValue printString]
		on: Error
		do: ['Cannot print instance of ', aValue class name]! !

"August 17, 2008 -> 19:16:43"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildClosedHeader ^ <Visual>

	| selector <Symbol> args <Array[Object]> row <Row[Visual]> |
	
	"Check type of activation"
	self activation isSmalltalk
		ifFalse: [	^(StringGlyph for: 'External activation' painter: self codePainter) asVisual ].

	selector := self activation method enclosingMethod selector.
	args := self activation arguments.
	row := Row[Visual] new.
	
	self activation method isBlockMethod
		ifTrue: [		"Add block parens interspersed with arguments"
							row add: (StringGlyph for: '[' painter: self codePainter) asVisual.
							args do: [ :arg <Object> |
								row add: (StringGlyph for: ':' painter: self selectorPainter) asVisual.
								row add: (self
									buildLabel: (self safePrintString: arg)
									painter: self codePainter
									action: [ (Inspector on: arg) launch ]) ].
							row add: (StringGlyph for: '] in ' painter: self codePainter) asVisual.
							row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
		ifFalse: [	"Add receiver"
							| receiver <Object> |
							receiver := self activation receiver.
							row add: (self
								buildLabel: (self safePrintString: receiver)
								painter: self codePainter
								action: [ (Inspector on: receiver) launch ]).
							row add: (StringGlyph for: '>> ' painter: self codePainter) asVisual.
							"Add selector interspersed with arguments"
							args size = 0
								ifTrue: [		row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
								ifFalse: [	| strm <CharacterReadStream> |
													strm := selector readStream.
													args do: [ :arg <Object> |
														row add: (StringGlyph for: (strm upTo: $:), ':' painter: self selectorPainter) asVisual.
														row add: (self
															buildLabel: (self safePrintString: arg)
															painter: self codePainter
															action: [ (Inspector on: arg) launch ]) ]
												]
						].
	^row! !

"August 17, 2008 -> 19:16:43"!

! (Delta mirrorFor: #Test) methodsFor: 'test' !
printString

^1 + 'a'! !

"August 17, 2008 -> 19:16:43"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
safePrintString: aValue

	^[aValue printString]
		on: Error
		do: [:ex|'Cannot print instance of ', aValue class name]! !

"August 17, 2008 -> 19:16:43"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
safePrintString: aValue

	^[aValue printString]
		on: Error
		do: [:ex|'instance of ', aValue class name]! !

"August 17, 2008 -> 19:16:43"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
safePrintString: aValue

	^[aValue printString]
		on: Error
		do: [:ex|'??instance of ', aValue class name]! !

"August 17, 2008 -> 19:16:43"!

! (Delta mirrorFor: #Test) methodsFor: 'test' !
blockReturn

	|sem|
	sem := Semaphore new.
	[sem signal.
	^nil] fork.
	sem wait! !

"August 17, 2008 -> 19:16:43"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'accessing' !
windowTitle ^ <Str>

	self process processError isNil ifTrue: [^''].
	^self process processError name! !

"August 17, 2008 -> 19:16:43"!

! (Delta mirrorFor: #Test) methodsFor: 'test' !
blockReturn
	[^nil] fork.
	Processor yield! !

"August 17, 2008 -> 19:17:6"!

"System saved" !
"August 24, 2008 -> 9:31:53"!

! (Delta mirrorFor: #Planner) classSide methodsFor: 'add/remove' !
incrementalRemove: c
	"Entry point for retracting a constraint. Remove the given constraint and incrementally update the 
	dataflow graph."
	"Details: Retracting the given constraint may allow some currently unsatisfiable downstream 
	constraint be satisfied. We thus collect a list of unsatisfied downstream constraints and attempt 
	to satisfy each one in turn. This list is sorted by constraint strength, strongest first, as a heuristic 
	for avoiding unnecessarily adding and then overriding weak constraints."
	"Assume: c is satisfied."

	| out unsatisfied |
	out := c output.
	c markUnsatisfied.
	c removeFromGraph.
	unsatisfied := self removePropagateFrom: out.
	unsatisfied do: [: u | self incrementalAdd: u].! !

"August 24, 2008 -> 9:31:56"!

! (Delta mirrorFor: #Planner) classSide methodsFor: 'add/remove' !
incrementalAdd: c
	"Attempt to satisfy the given constraint and, if successful, incrementally update the dataflow graph."
	"Details: If satifying the constraint is successful, it may override a weaker constraint on its output. 
	The algorithm attempts to resatisfy that constraint using some other method. This process is 
	repeated until either a) it reaches a variable that was not previously determined by any constraint 
	or b) it reaches a constraint that is too weak to be satisfied using any of its methods. The variables 
	of constraints that have been processed are marked with a unique mark value so that we know 
	where we've been. This allows the algorithm to avoid getting into an infinite loop even if the 
	constraint graph has an inadvertent cycle."

	| mark overridden |
	mark := self newMark.
	overridden := c satisfy: mark.
	[overridden == nil] whileFalse:
		[overridden := overridden satisfy: mark].! !

"August 24, 2008 -> 9:46:39"!

"System saved" !
"August 25, 2008 -> 0:32:21"!

! (Delta mirrorFor: #Behavior) methodsFor: 'private' !
primitiveNew ^<Object>

	^{{self primitiveNewIfFail: [ :err <Symbol> | 
		Transcript show: err.
		VM scavengeGarbage.
		{{self primitiveNewIfFail: [:err2<Symbol> |
			Transcript show: err.
			VM collectGarbage.
			{{self primitiveNewIfFail: [:err3 <Symbol> |
				]}}
			]}}
			"can't happen"
		]}}! !

"August 25, 2008 -> 0:32:41"!

! (Delta mirrorFor: #Behavior) methodsFor: 'private' !
primitiveNew ^<Object>

	^{{self primitiveNewIfFail: [ :err <Symbol> | 
		Transcript show: err.
		VM scavengeGarbage.
		{{self primitiveNewIfFail: [:err2<Symbol> |
			Transcript show: err.
			VM collectGarbage.
			{{self primitiveNewIfFail: [:err3 <Symbol> |
				"need to expand memory here"
				]}}
			]}}
			"can't happen"
		]}}! !

"August 25, 2008 -> 0:34:15"!

! (Delta mirrorFor: #Behavior) methodsFor: 'private' !
primitiveNew ^<Object>

	^{{self primitiveNewIfFail: [ :err <Symbol> | 
		Transcript show: err.
		VM scavengeGarbage.
		{{self primitiveNewIfFail: [:err2<Symbol> |
			Transcript show: err.
			VM collectGarbage.
			{{self primitiveNewIfFail: [:err3 <Symbol> |
				"need to expand memory here"
				]}}
			]}}
		]}}! !

"August 25, 2008 -> 0:36:14"!

"System saved" !
"August 25, 2008 -> 0:44:37"!

! (Delta mirrorFor: #Behavior) methodsFor: 'private' !
primitiveNew ^<Object>

	^{{self primitiveNewIfFail: [ :err <Symbol> | 
		Transcript show: err.
		VM scavengeGarbage.
		{{self primitiveNewIfFail: [:err2<Symbol> |
			Transcript show: err2.
			VM collectGarbage.
			{{self primitiveNewIfFail: [:err3 <Symbol> |
				"need to expand memory here"
				]}}
			]}}
		]}}! !

"August 25, 2008 -> 0:45:31"!

"System saved" !
"August 26, 2008 -> 13:8:9"!

! (Delta mirrorFor: #Behavior) methodsFor: 'private' !
primitiveNew ^<Object>

	^{{self primitiveNew2IfFail: [ :err <Symbol> | 
		Transcript show: err.
		VM scavengeGarbage.
		{{self primitiveNew2IfFail: [:err2<Symbol> |
			Transcript show: err2.
			VM collectGarbage.
			{{self primitiveNew2IfFail: [:err3 <Symbol> |
				"need to expand memory here"
				]}}
			]}}
		]}}! !

"August 26, 2008 -> 13:12:7"!

"System saved" !
"August 26, 2008 -> 13:18:2"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'instance creation' !
new ^<Instance>
	"Create and return an initialized instance of this class."

	"%remove when inlining working:"
	^{{self primitiveNew2IfFail: [ :err <Symbol> | 
		Transcript show: err.
		VM scavengeGarbage.
		{{self primitiveNew2IfFail: [:err2<Symbol> |
			Transcript show: err2.
			VM collectGarbage.
			{{self primitiveNew2IfFail: [:err3 <Symbol> |
				"need to expand memory here"
				]}}
			]}}
		]}}
"
	^guaranteed <Instance> (super new)
"! !

"August 26, 2008 -> 13:29:57"!

"System saved" !
"August 26, 2008 -> 13:45:44"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'instance creation' !
new ^<Instance>
	"Create and return an initialized instance of this class."

	"%remove when inlining working:"
	^{{self primitiveNew2IfFail: [ :err <Symbol> | 
		VM scavengeGarbage.
		{{self primitiveNew2IfFail: [:err2<Symbol> |
			Transcript show: err2.
			VM collectGarbage.
			{{self primitiveNew2IfFail: [:err3 <Symbol> |
				"need to expand memory here"
				]}}
			]}}
		]}}
"
	^guaranteed <Instance> (super new)
"! !

"August 26, 2008 -> 14:40:35"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'instance creation' !
new ^<Instance>
	"Create and return an initialized instance of this class."

	"%remove when inlining working:"
	^{{self primitiveNewIfFail: [ :err <Symbol> | 
		VM scavengeGarbage.
		{{self primitiveNewIfFail: [:err2<Symbol> |
			Transcript show: err2.
			VM collectGarbage.
			{{self primitiveNewIfFail: [:err3 <Symbol> |
				"need to expand memory here"
				]}}
			]}}
		]}}
"
	^guaranteed <Instance> (super new)
"! !

"August 26, 2008 -> 14:40:48"!

! (Delta mirrorFor: #Behavior) methodsFor: 'private' !
primitiveNew ^<Object>

	^{{self primitiveNewIfFail: [ :err <Symbol> | 
		Transcript show: err.
		VM scavengeGarbage.
		{{self primitiveNewIfFail: [:err2<Symbol> |
			Transcript show: err2.
			VM collectGarbage.
			{{self primitiveNewIfFail: [:err3 <Symbol> |
				"need to expand memory here"
				]}}
			]}}
		]}}! !

"August 26, 2008 -> 14:41:38"!

! (Delta mirrorFor: #Behavior) methodsFor: 'private' !
primitiveNew ^<Object>

	^{{self primitiveNewIfFail: [ :err <Symbol> | 
		VM scavengeGarbage.
		{{self primitiveNewIfFail: [:err2<Symbol> |
			Transcript show: err2.
			VM collectGarbage.
			{{self primitiveNewIfFail: [:err3 <Symbol> |
				"need to expand memory here"
				]}}
			]}}
		]}}! !

"August 26, 2008 -> 16:47:54"!

"System saved" !
"August 27, 2008 -> 13:25:53"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
expand: size

	{{primitiveExpandMemory: (size * self oopSize)}}! !

"August 27, 2008 -> 13:26:25"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private' !
oopSize

	^{{primitiveOopSize}}! !

"August 27, 2008 -> 13:35:11"!

"System saved" !
"August 28, 2008 -> 9:35:0"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private' !
oopSize
self halt.
	^{{primitiveOopSize}}! !

"August 28, 2008 -> 9:35:54"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private' !
oopSize

	^{{primitiveOopSize}}! !

"August 28, 2008 -> 9:36:45"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private' !
oopSize

	^{{self primitiveOopSize}}! !

"August 28, 2008 -> 9:37:35"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private' !
oopSize

	^{{primitiveOopSize}}! !

"August 28, 2008 -> 12:50:18"!

"System saved" !
"August 28, 2008 -> 15:37:37"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private' !
oopSize

	^{{primitiveSizeOfOop}}! !

"August 28, 2008 -> 15:38:9"!

"System saved" !
"August 28, 2008 -> 15:51:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
deferredGC

	[self collectGarbage] fork! !

"August 28, 2008 -> 15:51:22"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore') !


"August 28, 2008 -> 15:53:25"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
deferredGC

	GCSemaphore := Semaphore new.
	[self collectGarbage.
	GCSemaphore signal] fork! !

"August 28, 2008 -> 16:8:4"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
waitForGC

	GCSemaphore isNil
		ifTrue: [self deferredGC]
		ifFalse:[GCSemaphore wait.
					GCSemaphore := nil]! !

"August 28, 2008 -> 16:17:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
isGCPending

	^GCSemaphore notNil! !

"August 28, 2008 -> 16:45:57"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'instance creation' !
new ^<Instance>
	"Create and return an initialized instance of this class."

	"%remove when inlining working:"
	^{{self primitiveNewIfFail: [ :err <Symbol> | 
		VM scavengeGarbage.
		{{self primitiveNewIfFail: [:err2<Symbol> |
			VM isGCPending
				ifTrue: [VM waitForGC.
							{{self primitiveNewIfFail: [:err3 <Symbol> |
								VM expand: (VMMirror on: self) instanceSize.
								VM deferredGC.
								{{self primitiveNewIfFail: [:err3 <Symbol> |
																"should not happen"]}}]}}]
				ifFalse: [VM expand: (VMMirror on: self) instanceSize.
							VM deferredGC.
							{{self primitiveNewIfFail: [:err3 <Symbol> |
																"should not happen"]}}].
			]}}
		]}}
"
	^guaranteed <Instance> (super new)
"! !

"August 28, 2008 -> 16:54:13"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'instance creation' !
new ^<Instance>
	"Create and return an initialized instance of this class."

	"%remove when inlining working:"
	^{{self primitiveNewIfFail: [ :err <Symbol> | 
		VM scavengeGarbage.
		{{self primitiveNewIfFail: [:err <Symbol> |
			VM isGCPending
				ifTrue: [VM waitForGC.
							{{self primitiveNewIfFail: [:err <Symbol> |
								VM expand: (VMMirror on: self) instanceSize.
								VM deferredGC.
								{{self primitiveNewIfFail: [:err <Symbol> |
																"should not happen"]}}]}}]
				ifFalse: [VM expand: (VMMirror on: self) instanceSize.
							VM deferredGC.
							{{self primitiveNewIfFail: [:err <Symbol> |
																"should not happen"]}}].
			]}}
		]}}
"
	^guaranteed <Instance> (super new)
"! !

"August 28, 2008 -> 17:5:51"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'instance creation' !
new ^<Instance>
	"Create and return an initialized instance of this class."

	"%remove when inlining working:"
	^{{self primitiveNewIfFail: [ :err <Symbol> | 
		VM scavengeGarbage.
		{{self primitiveNewIfFail: [:err <Symbol> |
			VM isGCPending
				ifTrue: [VM waitForGC.
							{{self primitiveNewIfFail: [:err <Symbol> |
								VM expand: (VMMirror on: self) instanceSize.
								VM deferredGC.
								{{self primitiveNewIfFail: [:err <Symbol> |
																		self error: err]}}]}}]
				ifFalse: [VM expand: (VMMirror on: self) instanceSize.
							VM deferredGC.
							{{self primitiveNewIfFail: [:err <Symbol> |
																	self error: err]}}].
			]}}
		]}}
"
	^guaranteed <Instance> (super new)
"! !

"August 28, 2008 -> 17:17:14"!

! (Delta mirrorFor: #IndexedInstanceVariables) classSide methodsFor: 'private' !
primitiveNew: size <Int> ^<Instance>

	^{{self primitiveIndexedObjectNew: size
			ifFail: [ :err <Symbol> |
					VM scavengeGarbage.
					{{self primitiveIndexedObjectNew: size
							ifFail: [ :err <Symbol> |
									VM isGCPending
										ifTrue: [VM waitForGC.
													{{self primitiveIndexedObjectNew: size
															ifFail: [:err <Symbol> |
																	VM expand: (VMMirror on: self) instanceSize + size.
																	VM deferredGC.
																	{{self primitiveIndexedObjectNew: size
																			ifFail: [:err <Symbol> |
																						self error: err]}}]}}]
										ifFalse: [VM expand: (VMMirror on: self) instanceSize + size.
													VM deferredGC.
													{{self primitiveIndexedObjectNew: size
															ifFail: [:err <Symbol> |
																	self error: err]}}]
						]}}
				]}}! !

"August 28, 2008 -> 18:0:1"!

"System saved" !
"August 28, 2008 -> 18:49:8"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'instance creation' !
new ^<Instance>
	"Create and return an initialized instance of this class."

	"%remove when inlining working:"
	^{{self primitiveNewIfFail: [ :err <Symbol> | 
		VM scavengeGarbage.
		{{self primitiveNewIfFail: [:err <Symbol> |
			Transcript show: err; cr.
			VM isGCPending
				ifTrue: [VM waitForGC.
							{{self primitiveNewIfFail: [:err <Symbol> |
								VM expand: (VMMirror on: self) instanceSize.
								VM deferredGC.
								{{self primitiveNewIfFail: [:err <Symbol> |
																		self error: err]}}]}}]
				ifFalse: [VM expand: (VMMirror on: self) instanceSize.
							VM deferredGC.
							{{self primitiveNewIfFail: [:err <Symbol> |
																	self error: err]}}].
			]}}
		]}}
"
	^guaranteed <Instance> (super new)
"! !

"August 28, 2008 -> 18:49:8"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'instance creation' !
new ^<Instance>
	"Create and return an initialized instance of this class."

	"%remove when inlining working:"
	^{{self primitiveNewIfFail: [ :err <Symbol> |
		Transcript show: err; cr.
		VM scavengeGarbage.
		{{self primitiveNewIfFail: [:err <Symbol> |
			Transcript show: err; cr.
			VM isGCPending
				ifTrue: [VM waitForGC.
							{{self primitiveNewIfFail: [:err <Symbol> |
								VM expand: (VMMirror on: self) instanceSize.
								VM deferredGC.
								{{self primitiveNewIfFail: [:err <Symbol> |
																		self error: err]}}]}}]
				ifFalse: [VM expand: (VMMirror on: self) instanceSize.
							VM deferredGC.
							{{self primitiveNewIfFail: [:err <Symbol> |
																	self error: err]}}].
			]}}
		]}}
"
	^guaranteed <Instance> (super new)
"! !

"August 28, 2008 -> 18:49:8"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'instance creation' !
new ^<Instance>
	"Create and return an initialized instance of this class."

	"%remove when inlining working:"
	^{{self primitiveNewIfFail: [ :err <Symbol> |
		VM scavengeGarbage.
		{{self primitiveNewIfFail: [:err <Symbol> |
			Transcript show: err; cr.
			VM isGCPending
				ifTrue: [VM waitForGC.
							{{self primitiveNewIfFail: [:err <Symbol> |
								VM expand: (VMMirror on: self) instanceSize.
								VM deferredGC.
								{{self primitiveNewIfFail: [:err <Symbol> |
																		self error: err]}}]}}]
				ifFalse: [VM expand: (VMMirror on: self) instanceSize.
							VM deferredGC.
							{{self primitiveNewIfFail: [:err <Symbol> |
																	self error: err]}}].
			]}}
		]}}
"
	^guaranteed <Instance> (super new)
"! !

"August 28, 2008 -> 19:24:12"!

"System saved" !
"September 8, 2008 -> 9:45:44"!

! (Delta mirrorFor: #RichardsBenchmarks) classSide methodsFor: 'instance creation' !
loop

	|start elapsed count|
start := Time millisecondClockValue.
count := 0.
[(elapsed := Time millisecondClockValue - start) < 1000]
	whileTrue: [
		self new run.
		count := count + 1].
elapsed * 1000.0/ count printOn: Transcript cr; yourself! !

"September 8, 2008 -> 9:45:57"!

"System saved" !
"September 24, 2008 -> 1:24:11"!

Delta define: #SequenceableCollectionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"September 24, 2008 -> 1:24:12"!

! (Delta mirrorFor: #SequenceableCollectionTest) methodsFor: 'testing' !
testIsSortedBy


	self shouldnt: [#(1 5 3) isSortedBy: [:a :b| a < b]].
	self should: [#(1 3 5) isSortedBy: [:a :b| a < b]]! !

"September 24, 2008 -> 1:24:12"!

! (Delta mirrorFor: #SequenceableCollectionTest) methodsFor: 'testing' !
testIsSortedBy


	"self shouldnt: [#(1 5 3) isSortedBy: [:a :b| a < b]]."
	self should: [#(1 3 5) isSortedBy: [:a :b| a < b]]! !

"September 24, 2008 -> 1:24:12"!

! (Delta mirrorFor: #SequenceableCollectionTest) methodsFor: 'testing' !
testIsSortedBy


	self shouldnt: [#(1 5 3) isSortedBy: [:a :b| a < b]].
	self should: [#(1 3 5) isSortedBy: [:a :b| a < b]]! !

"September 24, 2008 -> 1:24:12"!

! (Delta mirrorFor: #SequenceableCollection) methodsFor: 'testing' !
isSortedBy: compare <[E,E,^Boolean]> ^<Boolean>
	"Returns true if the receiver is in sorted order, using the specified comparison"

	| last <E> |
	self size < 2
		ifTrue: [ ^true ].
	last := self at: 1.
	2 to: self size do:
		[ :i <Int> | |current|
			(compare value: last value: (current := self at: i))
				ifFalse: [ ^false ].
			last := current].
	^true! !

"September 24, 2008 -> 1:24:12"!

Delta define: #SortedCollectionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"September 24, 2008 -> 1:24:12"!

! (Delta mirrorFor: #SortedCollectionTest) methodsFor: 'testing' !
testSortedCollection
	|r c s index|
	r := Random new.
	1 to: 500 do:
		[:j|	c := Array[Int] new: j.
			1 to: j do:
				[ :i <Int> |
					c at: i put: (r next * (SmallInteger maxVal - 1)) asInteger	].
			"Transcript show: 'c size = '; print: c size; cr."
			self should: [ (c asSortedCollection: [ :i1 <Int> :i2 <Int> | i1 <= i2 ]) isSorted ]].! !

"September 24, 2008 -> 1:24:12"!

! (Delta mirrorFor: #SortedCollectionTest) methodsFor: 'testing' !
testSortedCollection
	|r c s index|
	r := Random new.
	1 to: 500 do:
		[:j|	c := Array[Int] new: j.
			1 to: j do:
				[ :i <Int> |
					c at: i put: (r next * (SmallInteger maxVal - 1)) asInteger	].
			"Transcript show: 'c size = '; print: c size; cr."
			self should: [ (c asSortedCollection: [ :i1 <Int> :i2 <Int> | i1 <= i2 ]) isSorted ]
				description: 'collection should be sorted'].! !

"September 24, 2008 -> 1:24:12"!

! (Delta mirrorFor: #SortedCollectionTest) methodsFor: 'testing' !
testSortedCollection
	|r c s index|
	r := Random new.
	1 to: 500 do:
		[:j|	c := Array[Int] new: j.
			1 to: j do:
				[ :i <Int> |
					c at: i put: (r next * (SmallInteger maxVal - 1)) asInteger	].
			"Transcript show: 'c size = '; print: c size; cr."
			self shouldnt: [ (c asSortedCollection: [ :i1 <Int> :i2 <Int> | i1 <= i2 ]) isSorted ]
				description: 'collection should be sorted'].! !

"September 24, 2008 -> 1:24:12"!

! (Delta mirrorFor: #SortedCollectionTest) methodsFor: 'testing' !
testSortedCollection
	|r c s index|
	r := Random new.
	1 to: 500 do:
		[:j|	c := Array[Int] new: j.
			1 to: j do:
				[ :i <Int> |
					c at: i put: (r next * (SmallInteger maxVal - 1)) asInteger	].
			"Transcript show: 'c size = '; print: c size; cr."
			self should: [ (c asSortedCollection: [ :i1 <Int> :i2 <Int> | i1 <= i2 ]) isSorted ]
				description: 'collection should be sorted'].! !

"September 24, 2008 -> 1:24:12"!

! (Delta mirrorFor: #SortedCollectionTest) methodsFor: 'testing' !
testSortSimpleCollection

	self should: [#(5 3 1) asSortedCollection asArray = #(1 3 5)]! !

"September 24, 2008 -> 1:24:12"!

! (Delta mirrorFor: #SortedCollectionTest) methodsFor: 'testing' !
testSortSimpleCollection

	self should: [#(5 3 1) asSortedCollection asArray = #(1 3 5)].
	self should: [#(1 3 5) asSortedCollection asArray = #(1 3 5)].
	self should: [#(1 5 3) asSortedCollection asArray = #(1 3 5)].! !

"September 24, 2008 -> 1:24:12"!

! (Delta mirrorFor: #SortedCollectionTest) methodsFor: 'testing' !
testSortSimpleCollection

	self should: [#(5 3 1) asSortedCollection asArray = #(1 3 5)].
	self should: [#(1 3 5) asSortedCollection asArray = #(1 3 5)].
	self should: [#(1 5 3) asSortedCollection asArray = #(1 3 5)].
	self should: [#(1 2 1)asSortedCollection asArray = #(1 1 2)].! !

"September 24, 2008 -> 1:24:12"!

! (Delta mirrorFor: #SortedCollectionTest) methodsFor: 'testing' !
testSortSimpleCollection

	self should: [#(5 3 1) asSortedCollection asArray = #(1 3 5)].
	self should: [#(1 3 5) asSortedCollection asArray = #(1 3 5)].
	self should: [#(1 5 3) asSortedCollection asArray = #(1 3 5)].
	self should: [#(1 2 1)asSortedCollection asArray = #(1 1 2)].
	self should: [#(1 2 1 2)asSortedCollection asArray = #(1 1 2 2)].! !

"September 24, 2008 -> 1:38:52"!

"System saved" !
"September 25, 2008 -> 17:44:24"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: class ifFail: failureBlock

	^{{primitiveNew: class
			ifFail: [:e| failureBlock value: e]}}! !

"September 25, 2008 -> 17:44:24"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: class

	|allocateBlock|
	allocateBlock := [:failBlock| self new: class ifFail: failBlock].
	^allocateBlock
			value: [:e| self freeSpace > 2 * self survivorSpaceSize
									ifTrue: [self scavengeGarbage
														ifTrue: [self collectGarbage]
														ifFalse: [allocateBlock
																			value: [:e2| self collectGarbage]]]]
						! !

"September 25, 2008 -> 17:44:24"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
spaceToScavenge

	^self freeSpace > 2 * self survivorSpaceSize					! !

"September 25, 2008 -> 17:44:24"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: class

	|allocateBlock|
	allocateBlock := [:failBlock| self new: class ifFail: failBlock].
	^allocateBlock
			value: [:e| self spaceToScavenge
									ifTrue: [self scavengeGarbage
														ifTrue: [self collectGarbage]
														ifFalse: [allocateBlock
																			value: [:e2| self collectGarbage]]]]
						! !

"September 25, 2008 -> 17:44:24"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: class

	|allocateBlock|
	allocateBlock := [:failBlock| self new: class ifFail: failBlock].
	^allocateBlock
			value: [:e| self spaceToScavenge
									ifTrue: [self scavengeAndAllocate: allocateBlock]]! !

"September 25, 2008 -> 17:44:24"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
scavengeAndAllocate: allocateBlock

	^self scavengeGarbage
			ifTrue: [self collectGarbage.
							allocateBlock
								value: [:e| self expand.
													allocateBlock value: [:e2| self error: e2]]]
			ifFalse: [allocateBlock
								value: [:e3| self collectGarbage.
														allocateBlock
															value: [:e4| self expand.
																				allocateBlock value: [:e5| self error: e5]]]]! !

"September 25, 2008 -> 17:44:24"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
survivorSpaceSize

	^self smallIntegerAt: #SurvivorSize! !

"September 25, 2008 -> 17:44:24"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
freeSpace

	^{{freeSpace}}! !

"September 25, 2008 -> 17:44:24"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
spaceToScavenge

	^self freeSpace > (2 * self survivorSpaceSize)	! !

"September 25, 2008 -> 17:44:24"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'integer flags' !
survivorSpaceSize

	^(self smallIntegerAt: #SurvivorSize) * 1024! !

"September 25, 2008 -> 17:44:34"!

"System saved" !
"September 25, 2008 -> 17:44:57"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
freeSpace

	^{{primitiveFreeSpace}}! !

"September 25, 2008 -> 17:49:9"!

"System saved" !
"September 27, 2008 -> 15:22:51"!

! (Delta mirrorFor: #Method) methodsFor: 'debugging' !
debugInfo

	^{{self primitiveMethodDebugInfo}}! !

"September 27, 2008 -> 15:24:31"!

(Delta mirrorFor: #Method) removeMethod: #debugInfo ifAbsent: [] !


"September 28, 2008 -> 21:33:34"!

"System saved" !
"October 12, 2008 -> 14:14:14"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
scavengeAndAllocate: allocateBlock

	|expansions|
	expansions := {{primitiveExpansions}}
	self scavengeGarbage.
	^(expansions ~~ {{primitiveExpansions}})
			ifTrue: [self collectGarbage.
							allocateBlock
								value: [:e| self expand.
													allocateBlock value: [:e2| self error: e2]]]
			ifFalse: [allocateBlock
								value: [:e3| self collectGarbage.
														allocateBlock
															value: [:e4| self expand.
																				allocateBlock value: [:e5| self error: e5]]]]! !

"October 12, 2008 -> 15:26:25"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: class

	|allocateBlock|
	allocateBlock := [:failBlock| self new: class ifFail: failBlock].
	^allocateBlock
			value: [:e| e == #FailedAllocation
									ifTrue: [self spaceToScavenge
														ifTrue: [self scavengeAndAllocate: allocateBlock]]
									ifFalse: [self error: e]]! !

"October 12, 2008 -> 15:29:31"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
scavengeAndAllocate: allocateBlock

	|expansions|
	expansions := {{primitiveExpansions}}
	self scavengeGarbage.
	^(expansions ~~ {{primitiveExpansions}})
			ifTrue: [self collectGarbage.
							allocateBlock
								value: [:e| 
												self expand.
												allocateBlock value: [:e2| self error: e2]]]
			ifFalse: [allocateBlock
								value: [:e3|
												self collectGarbage.
												allocateBlock
													value: [:e4|
																	self expand.
																	allocateBlock value: [:e5| self error: e5]]]]! !

"October 12, 2008 -> 15:31:58"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
expand

	|expansionSize|
	expansionSize := (self smallIntegerAt: #ObjectHeapExpandSize) * self K.
	{{primitiveExpand: expansionSize}}! !

"October 12, 2008 -> 15:36:17"!

"System saved" !
"October 12, 2008 -> 16:47:45"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: class

	|allocateBlock|
	allocateBlock := [:failBlock| self new: class ifFail: failBlock].
	^allocateBlock
			value: [:e| e == #FailedAllocation
									ifTrue: [self spaceToScavenge
														ifTrue: [self scavengeAndAllocate: allocateBlock]]
									ifFalse: [nil error: e]]! !

"October 12, 2008 -> 16:48:5"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
scavengeAndAllocate: allocateBlock

	|expansions|
	expansions := {{primitiveExpansions}}
	self scavengeGarbage.
	^(expansions ~~ {{primitiveExpansions}})
			ifTrue: [self collectGarbage.
							allocateBlock
								value: [:e| 
												self expand.
												allocateBlock value: [:e2| nil error: e2]]]
			ifFalse: [allocateBlock
								value: [:e3|
												self collectGarbage.
												allocateBlock
													value: [:e4|
																	self expand.
																	allocateBlock value: [:e5| nil error: e5]]]]! !

"October 12, 2008 -> 17:5:47"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
K

	^1024! !

"October 12, 2008 -> 17:6:44"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
expand

	|expansionSize|
	expansionSize := (self smallIntegerAt: #ObjectHeapExpandSize) * self K.
	{{primitiveExpandMemory: expansionSize}}! !

"October 12, 2008 -> 17:46:8"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
hasExpandedBlock
	|expansions|
	expansions := {{primitiveExpansions}}.
	^[expansions ~~ {{primitiveExpansions}}]! !

"October 12, 2008 -> 17:47:16"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
scavengeAndAllocate: allocateBlock

	|hasExpanded|
	hasExpanded := self hasExpandedBlock.
	self scavengeGarbage.
	^hasExpanded value
			ifTrue: [self collectGarbage.
							allocateBlock
								value: [:e| 
												self expand.
												allocateBlock value: [:e2| nil error: e2]]]
			ifFalse: [allocateBlock
								value: [:e3|
												self collectGarbage.
												allocateBlock
													value: [:e4|
																	self expand.
																	allocateBlock value: [:e5| nil error: e5]]]]! !

"October 12, 2008 -> 17:50:52"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
collectAndAllocated: allocateBlock

	^self collectGarbage.
	allocateBlock
		value: [:e| 
						self expand.
						allocateBlock value: [:e2| nil error: e2]]! !

"October 12, 2008 -> 17:52:15"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
scavengeAndAllocate: allocateBlock

	|hasExpanded|
	hasExpanded := self hasExpandedBlock.
	self scavengeGarbage.
	^hasExpanded value
			ifTrue: [self collectAndAllocate: allocateBlock]
			ifFalse: [allocateBlock
								value: [:e3| self collectAndAllocate: allocateBlock]]! !

"October 12, 2008 -> 17:54:27"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: class

	|allocateBlock|
	allocateBlock := [:failBlock| self new: class ifFail: failBlock].
	^allocateBlock
			value: [:e| e == #FailedAllocation
									ifTrue: [self spaceToScavenge
														ifTrue: [self scavengeAndAllocate: allocateBlock]
														ifFalse: [self collectAndAllocate: allocateBlock]]
									ifFalse: [nil error: e]]! !

"October 12, 2008 -> 17:55:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
scavengeAndAllocate: allocateBlock

	|hasExpandedBlock|
	hasExpandedBlock := self hasExpandedBlock.
	self scavengeGarbage.
	^hasExpandedBlock value
			ifTrue: [self collectAndAllocate: allocateBlock]
			ifFalse: [allocateBlock
								value: [:e3| self collectAndAllocate: allocateBlock]]! !

"October 12, 2008 -> 17:56:57"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
expand: expansionSize

	{{primitiveExpandMemory: expansionSize}}! !

"October 12, 2008 -> 17:57:11"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
expand

	|expansionSize|
	expansionSize := (self smallIntegerAt: #ObjectHeapExpandSize) * self K.
	self expand: expansionSize! !

"October 12, 2008 -> 17:58:13"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
scavengeAndAllocate: allocateBlock ifExpand: expansionBlock

	|hasExpandedBlock|
	hasExpandedBlock := self hasExpandedBlock.
	self scavengeGarbage.
	^hasExpandedBlock value
			ifTrue: [self collectAndAllocate: allocateBlock]
			ifFalse: [allocateBlock
								value: [:e3| self collectAndAllocate: allocateBlock]]! !

"October 12, 2008 -> 17:58:23"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
collectAndAllocate: allocateBlock

	^self collectGarbage.
	allocateBlock
		value: [:e| 
						self expand.
						allocateBlock value: [:e2| nil error: e2]]! !

"October 12, 2008 -> 17:58:26"!

(Delta mirrorFor: #VM) classSide removeMethod: #collectAndAllocated: ifAbsent: [] !


"October 12, 2008 -> 17:59:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
collectAndAllocate: allocateBlock ifExpand: expansionBlock

	^self collectGarbage.
	allocateBlock
		value: [:e| 
						expansionBlock value.
						allocateBlock value: [:e2| nil error: e2]]! !

"October 12, 2008 -> 17:59:51"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
scavengeAndAllocate: allocateBlock ifExpand: expansionBlock

	|hasExpandedBlock|
	hasExpandedBlock := self hasExpandedBlock.
	self scavengeGarbage.
	^hasExpandedBlock value
			ifTrue: [self collectAndAllocate: allocateBlock
								ifExpand: expansionBlock]
			ifFalse: [allocateBlock
								value: [:e3| self collectAndAllocate: allocateBlock
															ifExpand: expansionBlock]]! !

"October 12, 2008 -> 18:1:52"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: class

	|allocateBlock expansionBlock|
	allocateBlock := [:failBlock| self new: class ifFail: failBlock].
	expansionBlock := [self expand].
	^allocateBlock
			value: [:e| e == #FailedAllocation
									ifTrue: [self spaceToScavenge
														ifTrue: [self scavengeAndAllocate: allocateBlock
																			ifExpand: expansionBlock]
														ifFalse: [self collectAndAllocate: allocateBlock
																			ifExpand: expansionBlock]]
									ifFalse: [nil error: e]]! !

"October 12, 2008 -> 18:2:12"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
collectAndAllocate: allocateBlock ifExpand: expansionBlock

	self collectGarbage.
	^allocateBlock
		value: [:e| 
						expansionBlock value.
						allocateBlock value: [:e2| nil error: e2]]! !

"October 12, 2008 -> 18:2:48"!

(Delta mirrorFor: #VM) classSide removeMethod: #scavengeAndAllocate: ifAbsent: [] !


"October 12, 2008 -> 18:3:8"!

(Delta mirrorFor: #VM) classSide removeMethod: #collectAndAllocate: ifAbsent: [] !


"October 12, 2008 -> 18:4:26"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
allocate: allocateBlock ifExpand: expansionBlock

	^allocateBlock
			value: [:e| e == #FailedAllocation
									ifTrue: [self spaceToScavenge
														ifTrue: [self scavengeAndAllocate: allocateBlock
																			ifExpand: expansionBlock]
														ifFalse: [self collectAndAllocate: allocateBlock
																			ifExpand: expansionBlock]]
									ifFalse: [nil error: e]]! !

"October 12, 2008 -> 18:5:19"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: class

	|allocateBlock expansionBlock|
	allocateBlock := [:failBlock| self new: class ifFail: failBlock].
	expansionBlock := [self expand].
	^self allocate: allocateBlock ifExpand: expansionBlock! !

"October 12, 2008 -> 18:6:23"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: class

	^self allocate: [:failBlock| self new: class ifFail: failBlock]
			ifExpand: [self expand]! !

"October 12, 2008 -> 18:12:6"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
newBytes: byteClass size: size

	^self allocate: [:failBlock| self newBytes: byteClass size: size ifFail: failBlock]
			ifExpand: [self expand: size]! !

"October 12, 2008 -> 18:12:26"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
newBytes: class size: size ifFail: failureBlock

	^{{primitiveNew: class
			ifFail: [:e| failureBlock value: e]}}! !

"October 12, 2008 -> 18:13:16"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: indexableClass size: size

	^self allocate: [:failBlock| self new: indexableClass size: size ifFail: failBlock]
			ifExpand: [self expand: size]! !

"October 12, 2008 -> 18:13:26"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
new: class size: size ifFail: failureBlock

	^{{primitiveNew: class
			ifFail: [:e| failureBlock value: e]}}! !

"October 12, 2008 -> 18:23:47"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: indexableClass size: size

	^self allocate: [:failBlock|
								self new: indexableClass
										size: size
										ifFail: failBlock]
			ifExpand: [self expand: size]! !

"October 12, 2008 -> 18:24:3"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
newBytes: byteClass size: size

	^self allocate: [:failBlock|
								self newBytes: byteClass
										size: size
										ifFail: failBlock]
			ifExpand: [self expand: size]! !

"October 12, 2008 -> 18:24:26"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: indexableClass size: size

	^self allocate: [:failBlock|
								self new: indexableClass
										size: size
										ifFail: failBlock]
			ifExpand: [self expand: size / self oopSize]! !

"October 12, 2008 -> 18:43:36"!

"System saved" !
"October 12, 2008 -> 20:4:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
newBytes: class size: size ifFail: failureBlock

	^{{primitiveIndexedByteNew: class
			size: size
			ifFail: [:e| failureBlock value: e]}}! !

"October 12, 2008 -> 20:4:18"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: indexableClass size: size

	^self allocate: [:failBlock|
								self new: indexableClass
										size: size
										ifFail: failBlock]
			ifExpand: [self expand: size * self oopSize]! !

"October 12, 2008 -> 20:21:2"!

"System saved" !
"October 12, 2008 -> 23:38:45"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
newBytes: byteClass size: size

	^self allocate: [:failBlock :tenured|
								self newBytes: byteClass
										size: size
										tenured: tenured
										ifFail: failBlock]
			ifExpand: [self expand: size]! !

"October 12, 2008 -> 23:39:12"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
newBytes: class size: size tenured: tenured ifFail: failureBlock

	^{{primitiveIndexedByteNew: class
			size: size
			tenured: tenured
			ifFail: [:e| failureBlock value: e]}}! !

"October 12, 2008 -> 23:40:7"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
allocate: allocateBlock ifExpand: expansionBlock

	^allocateBlock
			value: false
			value: [:e| e == #FailedAllocation
									ifTrue: [self spaceToScavenge
														ifTrue: [self scavengeAndAllocate: allocateBlock
																			ifExpand: expansionBlock]
														ifFalse: [self collectAndAllocate: allocateBlock
																			ifExpand: expansionBlock]]
									ifFalse: [nil error: e]]! !

"October 12, 2008 -> 23:40:33"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
newBytes: byteClass size: size

	^self allocate: [:tenured :failBlock|
								self newBytes: byteClass
										size: size
										tenured: tenured
										ifFail: failBlock]
			ifExpand: [self expand: size]! !

"October 12, 2008 -> 23:40:41"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: indexableClass size: size

	^self allocate: [:tenured :failBlock|
								self new: indexableClass
										size: size
										ifFail: failBlock]
			ifExpand: [self expand: size * self oopSize]! !

"October 12, 2008 -> 23:43:23"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
scavengeAndAllocate: allocateBlock ifExpand: expansionBlock

	|hasExpandedBlock|
	hasExpandedBlock := self hasExpandedBlock.
	self scavengeGarbage.
	^hasExpandedBlock value
			ifTrue: [self collectAndAllocate: allocateBlock
								ifExpand: expansionBlock]
			ifFalse: [allocateBlock
								value: true
								value: [:e3| self collectAndAllocate: allocateBlock
															ifExpand: expansionBlock]]! !

"October 12, 2008 -> 23:43:48"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
collectAndAllocate: allocateBlock ifExpand: expansionBlock

	self collectGarbage.
	^allocateBlock
			value: true
			value: [:e| 
						expansionBlock value.
						allocateBlock value: true value: [:e2| nil error: e2]]! !

"October 12, 2008 -> 23:44:4"!

(Delta mirrorFor: #VM) classSide removeMethod: #newBytes:size:ifFail: ifAbsent: [] !


"October 12, 2008 -> 23:45:30"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
collectAndAllocate: allocateBlock ifExpand: expansionBlock

	self collectGarbage.
	^allocateBlock
			value: true
			value: [:e| 
						expansionBlock value.
						allocateBlock
							value: true
							value: [:e2| nil error: e2]]! !

"October 12, 2008 -> 23:45:55"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: class

	^self allocate: [:tenured :failBlock| self new: class ifFail: failBlock]
			ifExpand: [self expand]! !

"October 12, 2008 -> 23:46:28"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
allocate: allocateBlock ifExpand: expansionBlock

	^allocateBlock
			value: false
			value: [:e| e == #FailedAllocation
									ifTrue: [self spaceToScavenge
														ifTrue: [self scavengeAndAllocate: allocateBlock
																				ifExpand: expansionBlock]
														ifFalse: [self collectAndAllocate: allocateBlock
																				ifExpand: expansionBlock]]
									ifFalse: [nil error: e]]! !

"October 12, 2008 -> 23:51:0"!

"System saved" !
"October 16, 2008 -> 17:41:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
shrinkIfPossible

	self freeSpace > (self smallIntegerAt: #ObjectHeapExpandSize) * 3
		ifTrue: [|amountToShrink|
						amountToShrink := self freeSpace - ((self smallIntegerAt: #ObjectHeapExpandSize) * 3).
						self shrink: amountToShrink]! !

"October 16, 2008 -> 17:41:32"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
shrink: size

	{{primitiveShrinkMemory: size}}! !

"October 16, 2008 -> 17:42:26"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
collectAndAllocate: allocateBlock ifExpand: expansionBlock

	self collectGarbage.
	^[allocateBlock
			value: true
			value: [:e| 
						expansionBlock value.
						allocateBlock
							value: true
							value: [:e2| nil error: e2]]]
			ensure: [self shrinkIfPossible]! !

"October 16, 2008 -> 17:43:30"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
shrinkIfPossible

	self freeSpace > ((self smallIntegerAt: #ObjectHeapExpandSize) * 3)
		ifTrue: [|amountToShrink|
						amountToShrink := self freeSpace - ((self smallIntegerAt: #ObjectHeapExpandSize) * 3).
						self shrink: amountToShrink]! !

"October 16, 2008 -> 17:49:31"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
shrinkIfPossible

	self freeSpace > ((self smallIntegerAt: #ObjectHeapExpandSize) * 3)
		ifTrue: [|amountToShrink|
						amountToShrink := self freeSpace - ((self smallIntegerAt: #ObjectHeapExpandSize) * 3 * VM K).
						self shrink: amountToShrink]! !

"October 16, 2008 -> 17:50:4"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
shrinkBarrier

	^(self smallIntegerAt: #ObjectHeapExpandSize) * 3 * VM K! !

"October 16, 2008 -> 17:50:45"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
shrinkIfPossible

	self freeSpace > self shrinkBarrier
		ifTrue: [|amountToShrink|
						amountToShrink := self freeSpace - self shrinkBarrier.
						self shrink: amountToShrink]! !

"October 16, 2008 -> 17:53:7"!

"System saved" !
"October 17, 2008 -> 15:40:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
handleFailure: error allocate: allocateBlock ifExpand: expansionBlock

	^error == #FailedAllocation
			ifTrue: [self spaceToScavenge
								ifTrue: [self scavengeAndAllocate: allocateBlock
														ifExpand: expansionBlock]
								ifFalse: [self collectAndAllocate: allocateBlock
														ifExpand: expansionBlock]]
			ifFalse: [nil error: error]! !

"October 17, 2008 -> 15:40:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: class

	^{{primitiveNew: class
			ifFail: [:e| self handleFailure: e
									allocate: [:tenured :failBlock| self new: class ifFail: failBlock]
									ifExpand: [self expand]]}}! !

"October 17, 2008 -> 15:40:9"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore') !


"October 17, 2008 -> 15:40:9"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore') !


"October 17, 2008 -> 15:40:9"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore') !


"October 17, 2008 -> 15:40:9"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore') !


"October 17, 2008 -> 15:40:9"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore') !


"October 17, 2008 -> 15:40:9"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore') !


"October 17, 2008 -> 15:40:9"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore ScavengeCount') !


"October 17, 2008 -> 15:40:9"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore ScavengeCount') !


"October 17, 2008 -> 15:40:9"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore ScavengeCount') !


"October 17, 2008 -> 15:40:9"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore ScavengeCount') !


"October 17, 2008 -> 15:40:9"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore ScavengeCount') !


"October 17, 2008 -> 15:40:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
resetScavengeCount

	ScavengeCount := 0! !

"October 17, 2008 -> 15:40:9"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore ScavengeCount') !


"October 17, 2008 -> 15:40:9"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore ScavengeCount') !


"October 17, 2008 -> 15:40:9"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore ScavengeCount') !


"October 17, 2008 -> 15:40:9"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore ScavengeCount') !


"October 17, 2008 -> 15:40:9"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore ScavengeCount') !


"October 17, 2008 -> 15:40:9"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore ScavengeCount') !


"October 17, 2008 -> 15:40:9"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore ScavengeCount AllocFailureCount') !


"October 17, 2008 -> 15:40:9"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore ScavengeCount AllocFailureCount') !


"October 17, 2008 -> 15:40:9"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore ScavengeCount AllocFailureCount') !


"October 17, 2008 -> 15:40:9"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore ScavengeCount AllocFailureCount') !


"October 17, 2008 -> 15:40:9"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore ScavengeCount AllocFailureCount') !


"October 17, 2008 -> 15:40:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
resetAllocCounts

	ScavengeCount := 0.
	AllocFailureCount := 0.! !

"October 17, 2008 -> 15:40:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: class

	^{{primitiveNew: class
			ifFail: [:e|
						AllocFailureCount := AllocatFailureCount + 1.
						self handleFailure: e
								allocate: [:tenured :failBlock| self new: class ifFail: failBlock]
								ifExpand: [self expand]]}}! !

"October 17, 2008 -> 15:40:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: class

	^{{primitiveNew: class
			ifFail: [:e|
						AllocFailureCount := AllocFailureCount + 1.
						self handleFailure: e
								allocate: [:tenured :failBlock| self new: class ifFail: failBlock]
								ifExpand: [self expand]]}}! !

"October 17, 2008 -> 15:40:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
allocFailures

	^AllocFailureCount! !

"October 17, 2008 -> 15:40:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'profiling' !
resetProfiler
	{{primitiveFlatProfilerReset}}! !

"October 17, 2008 -> 15:40:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'profiling' !
engageProfiler

	{{primitiveFlatProfilerEngage: Processor activeProcess ifFail: [:e| nil error: e]}}.! !

"October 17, 2008 -> 15:40:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'profiling' !
disengageProfiler

	{{primitiveFlatProfilerDisengage}}.! !

"October 17, 2008 -> 15:40:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'profiling' !
printProfile

	{{primitiveFlatProfilerPrint}}! !

"October 17, 2008 -> 15:40:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'benchmarking' !
benchmarkNew: iterations

	|elapsed|
	self resetProfiler.
	self engageProfiler.
	elapsed := Time millisecondsToRun: [
								iterations timesRepeat: [
									Object new]].
	self disengageProfiler.
	self printProfile.
	Transcript cr; show: elapsed printString.! !

"October 17, 2008 -> 15:40:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'benchmarking' !
benchmarkNewNew: iterations

	|elapsed|
	self resetProfiler.
	self engageProfiler.
	elapsed := Time millisecondsToRun: [
								iterations timesRepeat: [
									VM new: Object]].
	self disengageProfiler.
	self printProfile.
	Transcript cr; show: elapsed printString.! !

"October 17, 2008 -> 15:40:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'benchmarking' !
benchmarkNewNew: iterations

	|elapsed|
	self resetProfiler.
	self engageProfiler.
	self resetAllocCounts.
	elapsed := Time millisecondsToRun: [
								iterations timesRepeat: [
									VM new: Object]].
	self disengageProfiler.
	self printProfile.
	Transcript cr; show: elapsed printString.
	Transcript cr; show: self allocFailures! !

"October 17, 2008 -> 15:40:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'benchmarking' !
benchmarkNewNew: iterations

	|elapsed|
	self resetProfiler.
	self engageProfiler.
	self resetAllocCounts.
	elapsed := Time millisecondsToRun: [
								iterations timesRepeat: [
									VM new: Object]].
	self disengageProfiler.
	self printProfile.
	Transcript cr; show: elapsed printString.
	Transcript cr; show: self allocFailures printString! !

"October 17, 2008 -> 15:40:9"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'instance creation' !
new2

	^{{primitiveNew: self
			ifFail: [:e|
						VM handleFailure: e
								allocate: [:tenured :failBlock| VM new: self ifFail: failBlock]
								ifExpand: [VM expand]]}}! !

"October 17, 2008 -> 15:40:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'benchmarking' !
benchmarkNewNew: iterations

	|elapsed|
	self resetProfiler.
	self engageProfiler.
	self resetAllocCounts.
	elapsed := Time millisecondsToRun: [
								iterations timesRepeat: [
									Object new2]].
	self disengageProfiler.
	self printProfile.
	Transcript cr; show: elapsed printString.
	Transcript cr; show: self allocFailures printString! !

"October 17, 2008 -> 15:40:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'benchmarking' !
benchmarkNewNew: iterations

	|elapsed|
	self resetProfiler.
	self engageProfiler.
	self resetAllocCounts.
	elapsed := Time millisecondsToRun: [
								iterations timesRepeat: [
									Object new2]].
	self disengageProfiler.
	self printProfile.
	Transcript cr; show: elapsed printString.
! !

"October 17, 2008 -> 15:40:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'benchmarking' !
benchmarkNewNew: iterations

	|elapsed|
	self resetProfiler.
	self engageProfiler.
	self resetAllocCounts.
	elapsed := Time millisecondsToRun: [
								iterations timesRepeat: [
									self new: Object]].
	self disengageProfiler.
	self printProfile.
	Transcript cr; show: elapsed printString.
! !

"October 17, 2008 -> 15:40:10"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'benchmarking' !
benchmarkNewNew: iterations

	|elapsed|
	self resetProfiler.
	self engageProfiler.
	self resetAllocCounts.
	elapsed := Time millisecondsToRun: [
								iterations timesRepeat: [
									self new: Object]].
	self disengageProfiler.
	self printProfile.
	Transcript cr; show: elapsed printString.
	Transcript cr; show: self allocFailures printString! !

"October 17, 2008 -> 15:40:10"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: class

	^{{primitiveNew: class
			ifFail: [:e|
						AllocFailureCount := AllocFailureCount + 1.
						VM handleFailure: e
								allocate: [:tenured :failBlock| VM new: class ifFail: failBlock]
								ifExpand: [VM expand]]}}! !

"October 17, 2008 -> 15:40:10"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'benchmarking' !
benchmarkNewNew: iterations

	|elapsed|
	self resetProfiler.
	self engageProfiler.
	self resetAllocCounts.
	elapsed := Time millisecondsToRun: [
								iterations timesRepeat: [
									VM new: Object]].
	self disengageProfiler.
	self printProfile.
	Transcript cr; show: elapsed printString.
	Transcript cr; show: self allocFailures printString! !

"October 17, 2008 -> 15:40:10"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'instance creation' !
new3 ^<Instance>
	"Create and return an initialized instance of this class."

	"%remove when inlining working:"
	^{{self primitiveNew2IfFail: [ :err <Symbol> |]}}
"
	^guaranteed <Instance> (super new)
"! !

"October 17, 2008 -> 15:40:10"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'benchmarking' !
benchmarkNew: iterations

	|elapsed|
	self resetProfiler.
	self engageProfiler.
	elapsed := Time millisecondsToRun: [
								iterations timesRepeat: [
									Object new3]].
	self disengageProfiler.
	self printProfile.
	Transcript cr; show: elapsed printString.! !

"October 17, 2008 -> 15:40:22"!

"System saved" !
"October 17, 2008 -> 22:39:8"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'benchmarking' !
privateBenchmarkNew: iterations

	iterations timesRepeat: [Object new3]! !

"October 17, 2008 -> 22:39:27"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'benchmarking' !
benchmarkNew: iterations

	|elapsed|
	self resetProfiler.
	self engageProfiler.
	elapsed := Time millisecondsToRun: [
								VM privateBenchmarkNew: iterations].
	self disengageProfiler.
	self printProfile.
	Transcript cr; show: elapsed printString.! !

"October 17, 2008 -> 22:39:53"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'benchmarking' !
privateBenchmarkNewNew: iterations

	iterations timesRepeat: [VM new: Object]! !

"October 17, 2008 -> 22:40:15"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'benchmarking' !
benchmarkNewNew: iterations

	|elapsed|
	self resetProfiler.
	self engageProfiler.
	self resetAllocCounts.
	elapsed := Time millisecondsToRun: [
								VM privateBenchmarkNewNew: iterations].
	self disengageProfiler.
	self printProfile.
	Transcript cr; show: elapsed printString.
	Transcript cr; show: self allocFailures printString! !

"October 17, 2008 -> 22:55:21"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'benchmarking' !
privateBenchmarkNewNew: iterations

	iterations timesRepeat: [VM new: Object]! !

"October 18, 2008 -> 12:45:20"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'benchmarking' !
privateBenchmarkNewNew: iterations

	iterations timesRepeat: [VM new: Object]! !

"October 18, 2008 -> 13:26:1"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'benchmarking' !
privateBenchmarkNewNew: iterations

	iterations timesRepeat: [VM new: Object]! !

"October 18, 2008 -> 14:47:39"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'benchmarking' !
privateBenchmarkNewNew: iterations

	iterations timesRepeat: [VM new: Object]! !

"October 18, 2008 -> 15:31:53"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
handleNew: class failure: error

	AllocFailureCount := AllocFailureCount + 1.
	^VM handleFailure: error
			allocate: [:tenured :failBlock| VM new: class ifFail: failBlock]
			ifExpand: [VM expand]! !

"October 18, 2008 -> 15:32:29"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: class

	^{{primitiveNew: class
			ifFail: [:e| VM handleNew: class failure: e]}}! !

"October 18, 2008 -> 16:56:6"!

"System saved" !
"October 26, 2008 -> 17:10:4"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
scavengeAndAllocate: allocateBlock ifExpand: expansionBlock

	|expansions |
	expansions := {{primitiveExpansions}}.
	self scavengeGarbage.
	^(expansions ~~ {{primitiveExpansions}})
			ifTrue: [self collectAndAllocate: allocateBlock
								ifExpand: expansionBlock]
			ifFalse: [allocateBlock
								value: true
								value: [:e3| self collectAndAllocate: allocateBlock
															ifExpand: expansionBlock]]! !

"October 26, 2008 -> 17:10:36"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
expansionCount

	^ {{primitiveExpansions}}! !

"October 26, 2008 -> 17:11:0"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
scavengeAndAllocate: allocateBlock ifExpand: expansionBlock

	|expansions |
	expansions := self expansionCount.
	self scavengeGarbage.
	^(expansions ~~ self expansionCount)
			ifTrue: [self collectAndAllocate: allocateBlock
								ifExpand: expansionBlock]
			ifFalse: [allocateBlock
								value: true
								value: [:e3| self collectAndAllocate: allocateBlock
															ifExpand: expansionBlock]]! !

"October 26, 2008 -> 17:14:35"!

"System saved" !
"October 26, 2008 -> 22:55:49"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
new: class tenured: tenured ifFail: failureBlock

	^{{primitiveNew: class
			tenured: tenured
			ifFail: [:e| failureBlock value: e]}}! !

"October 26, 2008 -> 22:55:49"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
handleNew: class failure: error

	AllocFailureCount := AllocFailureCount + 1.
	^VM handleFailure: error
			allocate: [:tenured :failBlock| VM new: class tenured: tenured ifFail: failBlock]
			ifExpand: [VM expand]! !

"October 26, 2008 -> 22:55:49"!

(Delta mirrorFor: #VM) classSide removeMethod: #hasExpandedBlock ifAbsent: [] !


"October 26, 2008 -> 22:55:49"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: class

	^{{primitiveNew: class
			tenured: false
			ifFail: [:e| VM handleNew: class failure: e]}}! !

"October 26, 2008 -> 22:55:49"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
scavengeAndAllocate: allocateBlock ifExpand: expansionBlock

	|expansions |
	expansions := self expansionCount.
	self scavengeGarbage.
	^(expansions ~~ self expansionCount)
			ifTrue: [self collectAndAllocate: allocateBlock
								ifExpand: expansionBlock]
			ifFalse: [allocateBlock
								value: false
								value: [:e3| self collectAndAllocate: allocateBlock
															ifExpand: expansionBlock]]! !

"October 26, 2008 -> 22:55:49"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
scavengeAndAllocate: allocateBlock ifExpand: expansionBlock

	|expansions |
	expansions := self expansionCount.
	self scavengeGarbage.
	^(expansions ~~ self expansionCount)
			ifTrue: [self collectAndAllocate: allocateBlock
								ifExpand: expansionBlock]
			ifFalse: [allocateBlock
								value: false
								value: [:e3| allocateBlock
															value: true
															value: [:e4| self collectAndAllocate: allocateBlock
																						ifExpand: expansionBlock]]]! !

"October 26, 2008 -> 22:55:49"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
reportNonAllocationFailure: errorSymbol

	(errorSymbol == #allocationFailure)
		ifFalse: [nil error: errorSymbol printString, ' reported during allocation']! !

"October 26, 2008 -> 22:55:50"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
scavengeAndAllocate: allocateBlock ifExpand: expansionBlock

	|expansions |
	expansions := self expansionCount.
	self scavengeGarbage.
	^(expansions ~~ self expansionCount)
			ifTrue: [self collectAndAllocate: allocateBlock
								ifExpand: expansionBlock]
			ifFalse: [allocateBlock
								value: false
								value: [:e1| self reportNonAllocationFailure: e1.
													allocateBlock
															value: true
															value: [:e2| self reportNonAllocationFailure: e2.
																				self collectAndAllocate: allocateBlock
																						ifExpand: expansionBlock]]]! !

"October 26, 2008 -> 22:55:50"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
collectAndAllocate: allocateBlock ifExpand: expansionBlock

	self collectGarbage.
	^[allocateBlock
			value: true
			value: [:e| 
						self reportNonAllocationFailure: e.
						expansionBlock value.
						allocateBlock
							value: true
							value: [:e2| nil error: e2]]]
			ensure: [self shrinkIfPossible]! !

"October 26, 2008 -> 22:55:50"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
collectAndAllocate: allocateBlock ifExpand: expansionBlock

	self collectGarbage.
	^[allocateBlock
			value: false
			value: [:e|
						self reportNonAllocationFailure: e.
						allocateBlock
							value: true
							value: [:e1|
										self reportNonAllocationFailure: e1.
										expansionBlock value.
										allocateBlock
											value: true
											value: [:e2| nil error: e2]]]]
			ensure: [self shrinkIfPossible]! !

"October 26, 2008 -> 22:55:50"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
allocate: allocateBlock ifExpand: expansionBlock

	^allocateBlock
			value: false
			value: [:e|
							self reportNonAllocationFailure: e.
							self spaceToScavenge
									ifTrue: [self scavengeAndAllocate: allocateBlock
															ifExpand: expansionBlock]
									ifFalse: [self collectAndAllocate: allocateBlock
															ifExpand: expansionBlock]]! !

"October 26, 2008 -> 22:55:50"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
handleFailure: error allocate: allocateBlock ifExpand: expansionBlock

	self reportNonAllocationFailure: error.
	self spaceToScavenge
				ifTrue: [self scavengeAndAllocate: allocateBlock
										ifExpand: expansionBlock]
				ifFalse: [self collectAndAllocate: allocateBlock
										ifExpand: expansionBlock]! !

"October 26, 2008 -> 22:55:50"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
reportNonAllocationFailure: errorSymbol

	(errorSymbol == #FailedAllocation)
		ifFalse: [nil error: errorSymbol printString, ' reported during allocation']! !

"October 26, 2008 -> 22:56:0"!

"System saved" !
"October 26, 2008 -> 23:6:39"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
handleNewBytes: class size: size failure: error

	AllocFailureCount := AllocFailureCount + 1.
	^VM handleFailure: error
			allocate: [:tenured :failBlock|
								VM newBytes: class
										size: size
										tenured: tenured
										ifFail: failBlock]
			ifExpand: [VM expand]! !

"October 26, 2008 -> 23:23:52"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
handleNewBytes: class size: size failure: error

	AllocFailureCount := AllocFailureCount + 1.
	^VM handleFailure: error
			allocate: [:tenured :failBlock|
								VM newBytes: class
										size: size
										tenured: tenured
										ifFail: failBlock]
			ifExpand: [VM expandBytes: class size: size]! !

"October 26, 2008 -> 23:35:50"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
expandBytes: class size: size

	|nonIndexableSizeInOops sizeInOops|
	nonIndexableSizeInOops := {{primitiveBehaviorNonIndexableSizeOf: class ifFail: [:err| nil error: err]}} + 1.
	self expand: (nonIndexableSizeInOops * self oopSize + size)! !

"October 26, 2008 -> 23:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
expandBytes: class size: size

	|nonIndexableSizeInOops|
	nonIndexableSizeInOops := {{primitiveBehaviorNonIndexableSizeOf: class ifFail: [:err| nil error: err]}} + 1.
	self expand: (nonIndexableSizeInOops * self oopSize + size)! !

"October 26, 2008 -> 23:39:50"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
expansionSize

	^(self smallIntegerAt: #ObjectHeapExpandSize) * self K! !

"October 27, 2008 -> 0:7:16"!

"System saved" !
"October 27, 2008 -> 0:44:44"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
new: class size: size tenured: tenured ifFail: failureBlock

	^{{primitiveIndexedObjectNew: class
			size: size
			tenured: tenured
			ifFail: [:e| failureBlock value: e]}}! !

"October 27, 2008 -> 0:44:56"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: indexableClass size: size

	^self allocate: [:tenured :failBlock|
								self new: indexableClass
										size: size
										tenured: tenured
										ifFail: failBlock]
			ifExpand: [self expand: size * self oopSize]! !

"October 27, 2008 -> 0:45:46"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
expand: class size: size

	|nonIndexableSizeInOops|
	nonIndexableSizeInOops := {{primitiveBehaviorNonIndexableSizeOf: class ifFail: [:err| nil error: err]}} + 1.
	self expand: (nonIndexableSizeInOops + size) * self oopSize! !

"October 27, 2008 -> 0:46:16"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: indexableClass size: size

	^self allocate: [:tenured :failBlock|
								self new: indexableClass
										size: size
										tenured: tenured
										ifFail: failBlock]
			ifExpand: [self expand: indexableClass size: size]! !

"October 27, 2008 -> 0:46:50"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
fixedSize: class

	^ {{primitiveBehaviorNonIndexableSizeOf: class ifFail: [:err| nil error: err]}} + 1! !

"October 27, 2008 -> 0:47:17"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
expand: class size: size

	|nonIndexableSizeInOops|
	nonIndexableSizeInOops := self fixedSize: class.
	self expand: (nonIndexableSizeInOops + size) * self oopSize! !

"October 27, 2008 -> 0:47:31"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
expandBytes: class size: size

	|nonIndexableSizeInOops|
	nonIndexableSizeInOops := self fixedSize: class.
	self expand: (nonIndexableSizeInOops * self oopSize + size)! !

"October 27, 2008 -> 1:0:17"!

"System saved" !
"October 27, 2008 -> 9:39:43"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
incFailureCount

	AllocFailureCount isNil
		ifTrue: [AllocFailureCount = 1]
		ifFalse: [AllocFailureCount := AllocFailureCount + 1]! !

"October 27, 2008 -> 9:40:0"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
handleNew: class failure: error

	self incFailureCount.
	^VM handleFailure: error
			allocate: [:tenured :failBlock| VM new: class tenured: tenured ifFail: failBlock]
			ifExpand: [VM expand]! !

"October 27, 2008 -> 9:40:7"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
handleNewBytes: class size: size failure: error

	self incFailureCount.
	^VM handleFailure: error
			allocate: [:tenured :failBlock|
								VM newBytes: class
										size: size
										tenured: tenured
										ifFail: failBlock]
			ifExpand: [VM expandBytes: class size: size]! !

"October 27, 2008 -> 9:40:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
handleFailure: error allocate: allocateBlock ifExpand: expansionBlock

	self reportNonAllocationFailure: error.
	^self spaceToScavenge
				ifTrue: [self scavengeAndAllocate: allocateBlock
										ifExpand: expansionBlock]
				ifFalse: [self collectAndAllocate: allocateBlock
										ifExpand: expansionBlock]! !

"October 27, 2008 -> 9:40:32"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'instance creation' !
oldnew ^<Instance>
	"Create and return an initialized instance of this class."

	"%remove when inlining working:"
	^{{self primitiveNewIfFail: [ :err <Symbol> |
		VM scavengeGarbage.
		{{self primitiveNewIfFail: [:err <Symbol> |
			Transcript show: err; cr.
			VM isGCPending
				ifTrue: [VM waitForGC.
							{{self primitiveNewIfFail: [:err <Symbol> |
								VM expand: (VMMirror on: self) instanceSize.
								VM deferredGC.
								{{self primitiveNewIfFail: [:err <Symbol> |
																		self error: err]}}]}}]
				ifFalse: [VM expand: (VMMirror on: self) instanceSize.
							VM deferredGC.
							{{self primitiveNewIfFail: [:err <Symbol> |
																	self error: err]}}].
			]}}
		]}}
"
	^guaranteed <Instance> (super new)
"! !

"October 27, 2008 -> 9:40:32"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'instance creation' !
new ^<Instance>
	"Create and return an initialized instance of this class."

	"%remove when inlining working:"
	^VM new: self
"
	^guaranteed <Instance> (super new)
"! !

"October 27, 2008 -> 10:39:16"!

! (Delta mirrorFor: #IndexedInstanceVariables) classSide methodsFor: 'private' !
oldprimitiveNew: size <Int> ^<Instance>

	^{{self primitiveIndexedObjectNew: size
			ifFail: [ :err <Symbol> |
					VM scavengeGarbage.
					{{self primitiveIndexedObjectNew: size
							ifFail: [ :err <Symbol> |
									VM isGCPending
										ifTrue: [VM waitForGC.
													{{self primitiveIndexedObjectNew: size
															ifFail: [:err <Symbol> |
																	VM expand: (VMMirror on: self) instanceSize + size.
																	VM deferredGC.
																	{{self primitiveIndexedObjectNew: size
																			ifFail: [:err <Symbol> |
																						self error: err]}}]}}]
										ifFalse: [VM expand: (VMMirror on: self) instanceSize + size.
													VM deferredGC.
													{{self primitiveIndexedObjectNew: size
															ifFail: [:err <Symbol> |
																	self error: err]}}]
						]}}
				]}}! !

"October 27, 2008 -> 10:39:24"!

! (Delta mirrorFor: #IndexedByteInstanceVariables) classSide methodsFor: 'private' !
oldprimitiveNew: size <Int> ^<Instance>

	^{{self primitiveIndexedByteNew: size
		ifFail: [ :err <Symbol> |  self error: err ]}}! !

"October 27, 2008 -> 10:40:18"!

! (Delta mirrorFor: #IndexedInstanceVariables) classSide methodsFor: 'private' !
primitiveNew: size <Int> ^<Instance>

	^VM new: self size: size! !

"October 27, 2008 -> 10:40:45"!

! (Delta mirrorFor: #IndexedByteInstanceVariables) classSide methodsFor: 'private' !
primitiveNew: size <Int> ^<Instance>

	^VM newBytes: self size: size! !

"October 27, 2008 -> 10:46:6"!

"System saved" !
"October 27, 2008 -> 12:2:45"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'evaluation' !
recompileAllMethods

	| counter <Int> |
	counter := 0.
	self classesAndMixinsReflectiveDo: [ :mirror <ClassMirror|MixinMirror> |
		Platform errorStream show: 'Recompiling ', mirror name; cr.
		mirror recompileAllMethodsIfFail: [ self shouldNotHappen ].
		"(counter := counter + 1) = 20
			ifTrue: [	counter := 0. VM collectGarbage ]"
	]

! !

"October 27, 2008 -> 12:8:41"!

"System saved" !
"October 27, 2008 -> 16:54:44"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
growBarrier

	^(self smallIntegerAt: #ObjectHeapExpandSize) * VM K! !

"October 27, 2008 -> 16:54:44"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
growIfNecessary

	self freeSpace < self growBarrier
		ifTrue: [self expand]! !

"October 27, 2008 -> 16:54:44"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
collectAndAllocate: allocateBlock ifExpand: expansionBlock

	self collectGarbage.
	self growIfNecessary.
	^[allocateBlock
			value: false
			value: [:e|
						self reportNonAllocationFailure: e.
						allocateBlock
							value: true
							value: [:e1|
										self reportNonAllocationFailure: e1.
										expansionBlock value.
										allocateBlock
											value: true
											value: [:e2| nil error: e2]]]]
			ensure: [self shrinkIfPossible]! !

"October 27, 2008 -> 17:2:4"!

"System saved" !
"October 27, 2008 -> 20:16:14"!

! (Delta mirrorFor: #Test) classSide methodsFor: 'toy benchmarks' !
testContexts
	|value|
	[(1 to: 10) do: [:i|
		value := value + i]]! !

"October 27, 2008 -> 20:16:14"!

! (Delta mirrorFor: #Test) classSide methodsFor: 'toy benchmarks' !
testContexts
	|value|
	[(1 to: 10) do: [:i|
		value := value + i]].
	^value! !

"October 27, 2008 -> 20:16:54"!

! (Delta mirrorFor: #Test) classSide methodsFor: 'toy benchmarks' !
testContexts
	|value|
	[(1 to: 10) do: [:i|
		value := value + i]] value.
	^value! !

"October 27, 2008 -> 20:17:14"!

! (Delta mirrorFor: #Test) classSide methodsFor: 'toy benchmarks' !
testContexts
	|value|
	value := 0.
	[(1 to: 10) do: [:i|
		value := value + i]] value.
	^value! !

"October 27, 2008 -> 20:22:40"!

! (Delta mirrorFor: #Test) classSide methodsFor: 'toy benchmarks' !
testContexts
	|value|
	value := 0.
	[(1 to: 10) do: [:i|
		value := value + i]] value.
	^value! !

"October 28, 2008 -> 9:32:15"!

"System saved" !
"October 31, 2008 -> 19:40:34"!

! (Delta mirrorFor: #Test) classSide methodsFor: 'toy benchmarks' !
allocations: count

	|time|
	time := Time millisecondsToRun: [
		count  timesRepeat: [Object new]
	].
	Transcript show: time printString; cr! !

"October 31, 2008 -> 19:49:31"!

! (Delta mirrorFor: #Test) classSide methodsFor: 'toy benchmarks' !
allocations: count

	count  timesRepeat: [Object new]! !

"October 31, 2008 -> 20:6:13"!

"System saved" !
"November 2, 2008 -> 21:54:23"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
handleNewBytes: class size: size failure: error

	self incFailureCount.
	^self handleFailure: error
			allocate: [:tenured :failBlock|
								VM newBytes: class
										size: size
										tenured: tenured
										ifFail: failBlock]
			ifExpand: [VM expandBytes: class size: size]! !

"November 2, 2008 -> 21:54:23"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
handleNewBytes: class size: size failure: error

	self incFailureCount.
	^self handleFailure: error
			allocate: [:tenured :failBlock|
								self newBytes: class
										size: size
										tenured: tenured
										ifFail: failBlock]
			ifExpand: [VM expandBytes: class size: size]! !

"November 2, 2008 -> 21:54:23"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
handleNewBytes: class size: size failure: error

	self incFailureCount.
	^self handleFailure: error
			allocate: [:tenured :failBlock|
								self newBytes: class
										size: size
										tenured: tenured
										ifFail: failBlock]
			ifExpand: [self expandBytes: class size: size]! !

"November 2, 2008 -> 21:54:23"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
handleNew: class failure: error

	self incFailureCount.
	^self handleFailure: error
			allocate: [:tenured :failBlock| VM new: class tenured: tenured ifFail: failBlock]
			ifExpand: [VM expand]! !

"November 2, 2008 -> 21:54:23"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
handleNew: class failure: error

	self incFailureCount.
	^self handleFailure: error
			allocate: [:tenured :failBlock| self new: class tenured: tenured ifFail: failBlock]
			ifExpand: [VM expand]! !

"November 2, 2008 -> 21:54:23"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
handleNew: class failure: error

	self incFailureCount.
	^self handleFailure: error
			allocate: [:tenured :failBlock| self new: class tenured: tenured ifFail: failBlock]
			ifExpand: [self expand]! !

"November 2, 2008 -> 21:54:23"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: class

	^{{primitiveNew: class
			tenured: false
			ifFail: [:e| self handleNew: class failure: e]}}! !

"November 2, 2008 -> 21:54:23"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
newBytes: byteClass size: size

	^{{primitiveIndexedByteNew: byteClass
			size: size
			tenured: false
			ifFail: [:e| self handleNewBytes: byteClass
										size: size
										failure: e]}}! !

"November 2, 2008 -> 21:54:23"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
handleNew: class size: size failure: error

	self incFailureCount.
	^self handleFailure: error
			allocate: [:tenured :failBlock| self new: class size: size tenured: tenured ifFail: failBlock]
			ifExpand: [self expand: class size: size]! !

"November 2, 2008 -> 21:54:23"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: indexableClass size: size

	^{{primitiveIndexedObjectNew: indexableClass
			size: size
			tenured: false
			ifFail: [:e| self handleNew: indexableClass
										size: size
										failure: e]}}! !

"November 2, 2008 -> 21:54:34"!

"System saved" !
"November 2, 2008 -> 23:6:57"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
newDoubleBytes: doubleByteClass size: size

	^{{primitiveIndexedDoubleByteNew: doubleByteClass
			size: size
			tenured: false
			ifFail: [:e| self handleNewDoubleBytes: doubleByteClass
										size: size
										failure: e]}}! !

"November 2, 2008 -> 23:6:57"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
newDoubleBytes: class size: size tenured: tenured ifFail: failureBlock

	^{{primitiveIndexedDoubleByteNew: class
			size: size
			tenured: tenured
			ifFail: [:e| failureBlock value: e]}}! !

"November 2, 2008 -> 23:6:57"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
handleNewDoubleBytes: class size: size failure: error

	self incFailureCount.
	^self handleFailure: error
			allocate: [:tenured :failBlock|
								self newDoubleBytes: class
										size: size
										tenured: tenured
										ifFail: failBlock]
			ifExpand: [self expandDoubleBytes: class size: size]! !

"November 2, 2008 -> 23:6:57"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
expandDoubleBytes: class size: size

	|nonIndexableSizeInOops|
	nonIndexableSizeInOops := self fixedSize: class.
	self expand: (nonIndexableSizeInOops * self oopSize + (size * 2))! !

"November 2, 2008 -> 23:6:57"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
newDoubleBytes: doubleByteClass size: size

	^{{primitiveIndexedDoubleByteNew: doubleByteClass
			size: size
			tenured: false
			ifFail: [:e| self handleNewDoubleBytes: doubleByteClass
										size: size
										failure: e]}}! !

"November 2, 2008 -> 23:6:57"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
newDoubleBytes: class size: size tenured: tenured ifFail: failureBlock

	^{{primitiveIndexedDoubleByteNew: class
			size: size
			tenured: tenured
			ifFail: [:e| failureBlock value: e]}}! !

"November 2, 2008 -> 23:6:57"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
handleNewDoubleBytes: class size: size failure: error

	self incFailureCount.
	^self handleFailure: error
			allocate: [:tenured :failBlock|
								self newDoubleBytes: class
										size: size
										tenured: tenured
										ifFail: failBlock]
			ifExpand: [self expandDoubleBytes: class size: size]! !

"November 2, 2008 -> 23:6:57"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
expandDoubleBytes: class size: size

	|nonIndexableSizeInOops|
	nonIndexableSizeInOops := self fixedSize: class.
	self expand: (nonIndexableSizeInOops * self oopSize + (size * 2))! !

"November 2, 2008 -> 23:7:6"!

"System saved" !
"November 2, 2008 -> 23:49:40"!

! (Delta mirrorFor: #Behavior) methodsFor: 'private' !
primitiveNew ^<Object>

	^VM new: self! !

"November 2, 2008 -> 23:51:50"!

! (Delta mirrorFor: #IndexedDoubleByteInstanceVariables) classSide methodsFor: 'private' !
primitiveNew: size <Int> ^<Instance>

	^VM newDoubleBytes: self size: size! !

"November 3, 2008 -> 0:0:13"!

"System saved" !
"November 3, 2008 -> 0:20:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
incFailureCount

	AllocFailureCount isNil
		ifTrue: [AllocFailureCount := 1]
		ifFalse: [AllocFailureCount := AllocFailureCount + 1]! !

"November 3, 2008 -> 0:22:59"!

"System saved" !
"January 13, 2009 -> 19:25:6"!

Delta define: #ContextNestingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"January 13, 2009 -> 19:30:53"!

! (Delta mirrorFor: #ContextNestingTest) methodsFor: 'testing' !
testNestedContext

|t1 t2 block|
t1 := 10.
t2 := 1.0.
self testWith: t1.
self testWith: t2		! !

"January 13, 2009 -> 19:33:18"!

! (Delta mirrorFor: #ContextNestingTest) methodsFor: 'testing' !
testWith: value

^self do: [:val|
				self subDo: [:val1|
									value = val1]
						with: val]! !

"January 13, 2009 -> 19:33:46"!

! (Delta mirrorFor: #ContextNestingTest) methodsFor: 'testing' !
do: block

	^block value: 1.0! !

"January 13, 2009 -> 19:33:58"!

! (Delta mirrorFor: #ContextNestingTest) methodsFor: 'testing' !
do: block

	^block value: 10! !

"January 13, 2009 -> 19:34:29"!

! (Delta mirrorFor: #ContextNestingTest) methodsFor: 'testing' !
subDo: block with: value

	^block value: value! !

"January 13, 2009 -> 19:34:48"!

! (Delta mirrorFor: #ContextNestingTest) methodsFor: 'testing' !
testNestedContext

|t1 t2 block|
t1 := 10.
t2 := #symbol.
self testWith: t1.
self testWith: t2		! !

"January 13, 2009 -> 19:35:8"!

! (Delta mirrorFor: #ContextNestingTest) methodsFor: 'testing' !
testNestedContext

self testWith: 10.
self testWith: #symbol		! !

"January 13, 2009 -> 19:37:3"!

! (Delta mirrorFor: #ContextNestingTest) methodsFor: 'testing' !
testWith: value

^self do: [:val|
				self subDo: [:val1|
									value = (val1 /val)]
						with: val]! !

"January 13, 2009 -> 19:37:52"!

"System saved" !
"January 13, 2009 -> 19:46:5"!

! (Delta mirrorFor: #ContextNestingTest) methodsFor: 'testing' !
testOnce

self testWith: 10.
self testWith: #symbol		! !

"January 13, 2009 -> 19:46:13"!

! (Delta mirrorFor: #ContextNestingTest) methodsFor: 'testing' !
testTwice

self testWith: 10.
self testWith: #symbol		! !

"January 13, 2009 -> 19:46:16"!

(Delta mirrorFor: #ContextNestingTest) removeMethod: #testNestedContext ifAbsent: [] !


"January 13, 2009 -> 19:46:22"!

! (Delta mirrorFor: #ContextNestingTest) methodsFor: 'testing' !
testOnce

self testWith: 10! !

"January 13, 2009 -> 19:46:32"!

! (Delta mirrorFor: #ContextNestingTest) methodsFor: 'testing' !
testTwice

self testWith: 10.
self testWith: #symbol! !

"January 13, 2009 -> 19:46:57"!

"System saved" !
"February 5, 2009 -> 0:7:56"!

Delta define: #DeltaParameterTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"February 5, 2009 -> 0:8:50"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
testSetupTypes
	
	DeltaParameter new
		name: #name
		type: (DeltaType for: Object)! !

"February 5, 2009 -> 0:9:22"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
testTriggerUncommonTrap
	
	DeltaParameter new
		name: #name
		type: (DeltaType for: Object class)! !

"February 5, 2009 -> 0:10:13"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
testSetupTypes
	
	DeltaParameter new
		name: #name
		type: (DeltaType for: Object);
		isFloatValue! !

"February 5, 2009 -> 0:10:14"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
testTriggerUncommonTrap
	
	DeltaParameter new
		name: #name
		type: (DeltaType for: Object class);
		isFloatValue! !

"February 5, 2009 -> 0:11:59"!

"System saved" !
"February 8, 2009 -> 15:21:44"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
testSetupTypes
	
	DeltaParameter new
		name: #name
		type: (DeltaType for: Object);
		isFloatValue.
		
	DeltaParameter new
		name: #name
		type: nil;
		isFloatValue.! !

"February 8, 2009 -> 15:22:0"!

"System saved" !
"February 8, 2009 -> 16:3:56"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
debugErrorTest: anInteger
        selectedErrorTest := anInteger.				"added rew"
        selectedFailureTest := 0.							"added rew"
        self changed: #selectedFailureTest.		"added rew"
        self changed: #selectedErrorTest.			"added rew"
        (anInteger ~= 0)
                ifTrue: [[(result errors at: anInteger) debug] fork]! !

"February 8, 2009 -> 16:26:47"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
testSetupTypes
	
	DeltaParameter new
		name: #name
		type: (DeltaType for: Object);
		isFloatValue.
		
	DeltaParameter new
		name: #name
		type: ((DeltaTypeId new)
					setId: #id;
					yourself);
		isFloatValue.! !

"February 8, 2009 -> 16:28:4"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
testSetupTypes
	
	DeltaParameter new
		name: #name
		type: (DeltaType for: Object);
		isFloatValue.
		
	DeltaParameter new
		name: #name
		type: ((DeltaTypeId new)
					setId: #id;
					yourself);
		isFloatValue.
		
	DeltaParameter new
		name: #name
		type: nil;
		type! !

"February 8, 2009 -> 16:29:2"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
testSetupTypes
	
	DeltaParameter new
		name: #name
		type: (DeltaType for: Object);
		isFloatValue.
		
	DeltaParameter new
		name: #name
		type: ((DeltaTypeId new)
					setId: #id;
					yourself);
		isFloatValue.

	DeltaParameter new
		name: #name
		type: ((DeltaClassId new)
					setId: #id;
					yourself);
		isFloatValue.

	DeltaParameter new
		name: #name
		type: nil;
		type! !

"February 8, 2009 -> 16:29:30"!

"System saved" !
"February 8, 2009 -> 16:40:28"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
objectType
	
	^DeltaParameter new
		name: #name
		type: (DeltaType for: Object);
		yourself! !

"February 8, 2009 -> 16:40:48"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
testSetupTypes
	
	self objectType isFloatValue.
		
	DeltaParameter new
		name: #name
		type: ((DeltaTypeId new)
					setId: #id;
					yourself);
		isFloatValue.

	DeltaParameter new
		name: #name
		type: ((DeltaClassId new)
					setId: #id;
					yourself);
		isFloatValue.

	DeltaParameter new
		name: #name
		type: nil;
		type! !

"February 8, 2009 -> 16:41:16"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
typeId
	
	^DeltaParameter new
		name: #name
		type: ((DeltaTypeId new)
					setId: #id;
					yourself);
		yourself! !

"February 8, 2009 -> 16:41:36"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
testSetupTypes
	
	self objectType isFloatValue.
	self typeId isFloatValue.

	DeltaParameter new
		name: #name
		type: ((DeltaClassId new)
					setId: #id;
					yourself);
		isFloatValue.

	DeltaParameter new
		name: #name
		type: nil;
		type! !

"February 8, 2009 -> 16:42:21"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
classId
	
	^DeltaParameter new
		name: #name
		type: ((DeltaClassId new)
					setId: #id;
					yourself);
		yourself! !

"February 8, 2009 -> 16:42:38"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
testSetupTypes
	
	self objectType isFloatValue.
	self typeId isFloatValue.
	self classId isFloatValue.

	DeltaParameter new
		name: #name
		type: nil;
		type! !

"February 8, 2009 -> 16:43:9"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
nilType
	
	^DeltaParameter new
		name: #name
		type: nil;
		yourself! !

"February 8, 2009 -> 16:43:25"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
testSetupTypes
	
	self objectType isFloatValue.
	self typeId isFloatValue.
	self classId isFloatValue.
	self nilType type! !

"February 8, 2009 -> 16:44:20"!

Delta define: #DeltaParameterTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'objectType typeId classId nilType')) !


"February 8, 2009 -> 16:45:9"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
initialize
	
	objectType := self objectType.
	typeId := self typeId.
	classId := self classId.
	nilType := self nilType! !

"February 8, 2009 -> 16:45:32"!

! (Delta mirrorFor: #DeltaParameterTest) classSide methodsFor: 'instance creation' !
new

	^super new initialize; yourself! !

"February 8, 2009 -> 16:45:56"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
testSetupTypes
	
	objectType isFloatValue.
	typeId isFloatValue.
	classId isFloatValue.
	nilType type! !

"February 8, 2009 -> 16:46:11"!

"System saved" !
"February 8, 2009 -> 17:50:52"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
operatorTypeError
	
	^DeltaParameter new
		name: #name
		type: ((DeltaInvalidTypeOperatorError new)
					operator: '+';
					yourself);
		yourself! !

"February 8, 2009 -> 17:51:14"!

Delta define: #DeltaParameterTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'objectType typeId classId nilType operatorTypeError')) !


"February 8, 2009 -> 17:51:30"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
initialize
	
	objectType := self objectType.
	typeId := self typeId.
	classId := self classId.
	nilType := self nilType.
	operatorTypeError := self operatorTypeError! !

"February 8, 2009 -> 17:51:46"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
testSetupTypes
	
	objectType isFloatValue.
	typeId isFloatValue.
	classId isFloatValue.
	nilType type.
	operatorTypeError type! !

"February 8, 2009 -> 17:52:15"!

"System saved" !
"February 8, 2009 -> 18:10:47"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
setupPolymorphicSends

	self objectType type.
	self nilType type.
	self typeId type.
	self classId type.
	self operatorTypeError type.
	self superNilError type.
	! !

"February 8, 2009 -> 18:13:8"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
testSetupTypes
	
	self setupPolymorphicSends.
	self arityError type! !

"February 8, 2009 -> 18:13:10"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
setupPolymorphicSends

	self objectType type.
	self nilType type.
	self typeId type.
	self classId type.
	self operatorTypeError type.
	self superNilError type.
	self placeholderError type.
	self noTypeError type.
	! !

"February 8, 2009 -> 18:13:24"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
superNilError

! !

"February 8, 2009 -> 18:14:26"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
superNilError
	
	^DeltaParameter new
		name: #name
		type: (DeltaSuperSendToNilError new);
		yourself! !

"February 8, 2009 -> 18:15:24"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
placeholderError
	
	^DeltaParameter new
		name: #name
		type: (DeltaPlaceHolderError new
						name: #placeholder;
						yourself);
		yourself! !

"February 8, 2009 -> 18:16:14"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
noTypeError
	
	^DeltaParameter new
		name: #name
		type: (DeltaNoTypeSpecifiedError new);
		yourself! !

"February 8, 2009 -> 18:16:37"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
parameter: type
	
	^DeltaParameter new
		name: #name
		type: type;
		yourself! !

"February 8, 2009 -> 18:17:0"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
operatorTypeError
	
	^self parameter: ((DeltaInvalidTypeOperatorError new)
									operator: '+';
									yourself)! !

"February 8, 2009 -> 18:17:30"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
objectType
	
	^self parameter: (DeltaType for: Object)! !

"February 8, 2009 -> 18:17:45"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
noTypeError
	
	^self parameter: (DeltaNoTypeSpecifiedError new)! !

"February 8, 2009 -> 18:18:38"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
placeholderError
	
	^self parameter: (DeltaPlaceHolderError new
									name: #placeholder;
									yourself)! !

"February 8, 2009 -> 18:19:2"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
superNilError
	
	^self parameter: (DeltaSuperSendToNilError new)! !

"February 8, 2009 -> 18:19:22"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
typeId
	
	^self parameter: ((DeltaTypeId new)
									setId: #id;
									yourself)! !

"February 8, 2009 -> 18:19:48"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
nilType
	
	^self parameter: nil! !

"February 8, 2009 -> 18:20:5"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
classId
	
	^self parameter: ((DeltaClassId new)
									setId: #id;
									yourself)! !

"February 8, 2009 -> 18:21:14"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
arityError
	
	^self parameter: (DeltaGenericArityError new)! !

"February 8, 2009 -> 18:21:28"!

"System saved" !
"February 8, 2009 -> 18:33:55"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
setupPolymorphicSends

	self objectType type.
	self nilType type.
	self typeId type.
	self classId type.
	self operatorTypeError type.
	"self superNilError type.
	self placeholderError type.
	self noTypeError type."
	! !

"February 8, 2009 -> 18:34:1"!

"System saved" !
"February 8, 2009 -> 18:40:48"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
testTriggerUncommonTrap
	
	(self parameter: (DeltaType for: Object class))
		isFloatValue! !

"February 8, 2009 -> 18:41:28"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
testSetupPoly
	
	self setupPolymorphicSends! !

"February 8, 2009 -> 18:41:41"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
testSetupTypes
	
	self arityError type! !

"February 8, 2009 -> 18:42:9"!

"System saved" !
"February 8, 2009 -> 21:34:57"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
setupPolymorphicSends

	self objectType type.
	self nilType type.
	self typeId type.
	self classId type.
	"self operatorTypeError type.
	self superNilError type.
	self placeholderError type.
	self noTypeError type."
	! !

"February 8, 2009 -> 21:35:11"!

"System saved" !
"February 8, 2009 -> 22:59:51"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
setupPolymorphicSends

	self objectType type.
	self nilType type.
	self typeId type.
	"self classId type.
	self operatorTypeError type.
	self superNilError type.
	self placeholderError type.
	self noTypeError type."
	! !

"February 8, 2009 -> 23:0:13"!

"System saved" !
"February 8, 2009 -> 23:45:53"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
setupPolymorphicSends

"	self objectType type."
	self nilType type.
"	self typeId type."
	"self classId type.
	self operatorTypeError type.
	self superNilError type."
	self placeholderError type.
	self noTypeError type.
	! !

"February 8, 2009 -> 23:46:24"!

"System saved" !
"February 19, 2009 -> 19:5:19"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
populatePIC

"	self objectType type."
	self nilType type.
"	self typeId type."
	"self classId type.
	self operatorTypeError type.
	self superNilError type."
	self placeholderError type.
	self noTypeError type.
	! !

"February 19, 2009 -> 19:5:19"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
populatePIC

	self nilType type.
	self placeholderError type.
	self noTypeError type.
	self arityError type	! !

"February 19, 2009 -> 19:5:19"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
populatePIC

	self nilType type.
	self placeholderError type.
	self noTypeError type.
	self arityError type! !

"February 19, 2009 -> 19:5:19"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
objectClassType
	
	^self parameter: (DeltaType for: Object class)! !

"February 19, 2009 -> 19:5:19"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
testTriggerUncommonTrap

	self objectClassType isFloatValue! !

"February 19, 2009 -> 19:5:19"!

(Delta mirrorFor: #DeltaParameterTest) classSide removeMethod: #new ifAbsent: [] !


"February 19, 2009 -> 19:5:19"!

(Delta mirrorFor: #DeltaParameterTest) removeMethod: #initialize ifAbsent: [] !


"February 19, 2009 -> 19:5:19"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
testTriggerUncommonTrap

	self populatePIC.
	self objectClassType isFloatValue! !

"February 19, 2009 -> 19:6:33"!

(Delta mirrorFor: #DeltaParameterTest) removeMethod: #testSetupPoly ifAbsent: [] !


"February 19, 2009 -> 19:6:36"!

(Delta mirrorFor: #DeltaParameterTest) removeMethod: #testSetupTypes ifAbsent: [] !


"February 19, 2009 -> 19:7:27"!

(Delta mirrorFor: #DeltaParameterTest) removeMethod: #setupPolymorphicSends ifAbsent: [] !


"February 19, 2009 -> 19:7:39"!

(Delta mirrorFor: #DeltaParameterTest) removeMethod: #superNilError ifAbsent: [] !


"February 19, 2009 -> 19:7:51"!

(Delta mirrorFor: #DeltaParameterTest) removeMethod: #operatorTypeError ifAbsent: [] !


"February 19, 2009 -> 19:7:59"!

(Delta mirrorFor: #DeltaParameterTest) removeMethod: #objectType ifAbsent: [] !


"February 19, 2009 -> 19:8:23"!

(Delta mirrorFor: #DeltaParameterTest) removeMethod: #classId ifAbsent: [] !


"February 19, 2009 -> 19:9:3"!

(Delta mirrorFor: #DeltaParameterTest) removeMethod: #typeId ifAbsent: [] !


"February 19, 2009 -> 19:9:24"!

"System saved" !
"February 22, 2009 -> 0:32:23"!

Delta define: #DeltaScopeTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"February 22, 2009 -> 0:33:15"!

! (Delta mirrorFor: #DeltaScopeTest) methodsFor: 'testing' !
testAtIfAbsent

	DeltaScope new
		at: #symbol
		ifAbsent: []! !

"February 22, 2009 -> 0:34:34"!

! (Delta mirrorFor: #DeltaScopeTest) methodsFor: 'testing' !
testAtIfAbsent

	(DeltaScope within: nil)
		at: #symbol
		ifAbsent: []! !

"February 22, 2009 -> 0:34:56"!

"System saved" !
"February 22, 2009 -> 0:40:40"!

! (Delta mirrorFor: #DeltaScopeTest) methodsFor: 'testing' !
testAtIfAbsent

|scope1 scope2|
	scope1 := DeltaScope within: nil.
	scope2 := DeltaScope within: scope1.
	scope1 bindings
		at: #symbol
		put: #value.
	scope2
		at: #symbol
		ifAbsent: [].
	scope2
		at: #unknown
		ifAbsent: []! !

"February 22, 2009 -> 0:40:59"!

"System saved" !
"February 23, 2009 -> 1:13:16"!

! (Delta mirrorFor: #DeltaScopeTest) methodsFor: 'testing' !
oldtestAtIfAbsent

|scope1 scope2|
	scope1 := DeltaScope within: nil.
	scope2 := DeltaScope within: scope1.
	scope1 bindings
		at: #symbol
		put: #value.
	scope2
		at: #symbol
		ifAbsent: [].
	scope2
		at: #unknown
		ifAbsent: []! !

"February 23, 2009 -> 1:14:32"!

! (Delta mirrorFor: #DeltaScopeTest) methodsFor: 'testing' !
testAtIfAbsent

|scope1|
	scope1 := DeltaScope within: nil.
	scope1 bindings
		at: #symbol
		put: #value.
	scope1
		at: #symbol
		ifAbsent: [nil]! !

"February 23, 2009 -> 1:15:3"!

"System saved" !
"February 23, 2009 -> 1:29:50"!

Delta define: #BlockMaterializeTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"February 23, 2009 -> 1:30:6"!

Delta define: #IgnoreBlock as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"February 23, 2009 -> 1:30:25"!

! (Delta mirrorFor: #IgnoreBlock) methodsFor: 'test support' !
ignore: block

	^self! !

"February 23, 2009 -> 1:30:55"!

! (Delta mirrorFor: #BlockMaterializeTest) methodsFor: 'testing' !
testIgnoredBlock

	! !

"February 23, 2009 -> 1:31:15"!

Delta define: #BlockMaterializeTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'scope')) !


"February 23, 2009 -> 1:31:57"!

! (Delta mirrorFor: #BlockMaterializeTest) classSide methodsFor: 'instance creation' !
new

	^super new initialize! !

"February 23, 2009 -> 1:32:23"!

! (Delta mirrorFor: #BlockMaterializeTest) methodsFor: 'initialization' !
initialize

	scope := IgnoreBlock new! !

"February 23, 2009 -> 1:33:7"!

! (Delta mirrorFor: #BlockMaterializeTest) methodsFor: 'testing' !
testIgnoredBlock

	self assert: (scope ignore: [nil]) = scope! !

"February 23, 2009 -> 1:34:34"!

"System saved" !
"February 27, 2009 -> 1:4:53"!

Delta define: #CanonicalContextTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"February 27, 2009 -> 1:5:31"!

! (Delta mirrorFor: #CanonicalContextTest) methodsFor: 'testing' !
testDoBlock

! !

"February 27, 2009 -> 1:5:39"!

Delta define: #CanonicalContextTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'vars')) !


"February 27, 2009 -> 1:11:36"!

! (Delta mirrorFor: #CanonicalContextTest) methodsFor: 'fixture' !
setUp

	vars := OrderedCollection new.
	vars add: DeltaParameter new! !

"February 27, 2009 -> 1:12:24"!

! (Delta mirrorFor: #CanonicalContextTest) methodsFor: 'fixture' !
varOfType: aClass

	^aClass new
		name: #name
		type: nil! !

"February 27, 2009 -> 1:12:39"!

! (Delta mirrorFor: #CanonicalContextTest) methodsFor: 'fixture' !
setUp

	vars := OrderedCollection new.
	vars add: (self varOfType: DeltaParameter)! !

"February 27, 2009 -> 1:13:9"!

! (Delta mirrorFor: #CanonicalContextTest) methodsFor: 'testing' !
testDoBlock

	vars do: [:var| var name]
! !

"February 27, 2009 -> 1:13:14"!

! (Delta mirrorFor: #CanonicalContextTest) methodsFor: 'testing' !
testDoBlock

	vars do: [:var| var name]! !

"February 27, 2009 -> 1:13:46"!

! (Delta mirrorFor: #CanonicalContextTest) methodsFor: 'fixture' !
addNewVar

	vars add: (self varOfType: DeltaInstVar)! !

"February 27, 2009 -> 1:16:35"!

! (Delta mirrorFor: #CanonicalContextTest) methodsFor: 'testing' !
testDoBlock

	|names|
	vars do: [:var| var name]! !

"February 27, 2009 -> 1:16:46"!

! (Delta mirrorFor: #CanonicalContextTest) methodsFor: 'testing' !
testDoBlock

	|names|
	names := OrderedCollection new.
	vars do: [:var| var name]! !

"February 27, 2009 -> 1:17:19"!

"System saved" !
"February 27, 2009 -> 1:20:9"!

! (Delta mirrorFor: #CanonicalContextTest) methodsFor: 'testing' !
testDoBlock

	|names|
	names := OrderedCollection new.
	vars do: [:var| names add: var name]! !

"February 27, 2009 -> 1:20:24"!

! (Delta mirrorFor: #CanonicalContextTest) methodsFor: 'testing' !
testDoBlock

	|names|
	names := OrderedCollection new.
	vars do: [:var| names add: var name].
	^names! !

"February 27, 2009 -> 1:21:6"!

"System saved" !
"March 15, 2009 -> 15:14:54"!

Delta define: #ComputeHeapsetTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"March 15, 2009 -> 15:16:41"!

! (Delta mirrorFor: #ComputeHeapsetTest) methodsFor: 'testing' !
testWithTwoSubscopes

	|outer inner1 inner2|
	outer := DeltaCodeScope within: nil.
	inner1 := DeltaGlobalScope within: outer.
	inner2 := DeltaCodeScope within: outer.
	
	outer computeHeapSet! !

"March 15, 2009 -> 15:18:59"!

Delta define: #ComputeHeapSetTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"March 15, 2009 -> 15:19:23"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
testWithTwoSubscopes

	|outer inner1 inner2|
	outer := DeltaCodeScope within: nil.
	inner1 := DeltaGlobalScope within: outer.
	inner2 := DeltaCodeScope within: outer.
	
	outer computeHeapSet! !

"March 15, 2009 -> 15:20:3"!

(Delta mirrorFor: #ComputeHeapsetTest) removeDefinitionIfFail: [] !


"March 15, 2009 -> 15:20:39"!

"System saved" !
"March 15, 2009 -> 16:20:43"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
testWithOneSubscope

	|outer inner|
	outer := DeltaCodeScope within: nil.
	inner := DeltaCodeScope within: outer.
	
	outer computeHeapSet! !

"March 15, 2009 -> 16:20:52"!

"System saved" !
"March 15, 2009 -> 16:43:33"!

Delta define: #ComputeHeapSetTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'outer inner inner2')) !


"March 15, 2009 -> 16:43:49"!

Delta define: #ComputeHeapSetTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'outer')) !


"March 15, 2009 -> 16:44:6"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
testWithOneSubscope

	|inner|
	outer := DeltaCodeScope within: nil.
	inner := DeltaCodeScope within: outer.
	
	outer computeHeapSet! !

"March 15, 2009 -> 16:44:15"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
testWithTwoSubscopes

	|inner1 inner2|
	outer := DeltaCodeScope within: nil.
	inner1 := DeltaGlobalScope within: outer.
	inner2 := DeltaCodeScope within: outer.
	
	outer computeHeapSet! !

"March 15, 2009 -> 16:44:25"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
testWithTwoSubscopes

	|inner1 inner2|
	outer := DeltaCodeScope within: nil.
	DeltaGlobalScope within: outer.
	DeltaCodeScope within: outer.
	
	outer computeHeapSet! !

"March 15, 2009 -> 16:44:49"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
testWithOneSubscope

	|inner|
	outer := DeltaCodeScope within: nil.
	DeltaCodeScope within: outer.
	
	outer computeHeapSet! !

"March 15, 2009 -> 16:44:54"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
testWithOneSubscope

	outer := DeltaCodeScope within: nil.
	DeltaCodeScope within: outer.
	
	outer computeHeapSet! !

"March 15, 2009 -> 16:45:0"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
testWithTwoSubscopes

	outer := DeltaCodeScope within: nil.
	DeltaGlobalScope within: outer.
	DeltaCodeScope within: outer.
	
	outer computeHeapSet! !

"March 15, 2009 -> 16:45:30"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
setupScope

	outer := DeltaCodeScope within: nil.
	DeltaCodeScope within: outer! !

"March 15, 2009 -> 16:45:55"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
testWithTwoSubscopes

	self setupScope.
	DeltaCodeScope within: outer.
	
	outer computeHeapSet! !

"March 15, 2009 -> 16:45:56"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
testWithOneSubscope

	self setupScope.
	
	outer computeHeapSet! !

"March 15, 2009 -> 16:46:26"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
testWithTwoSubscopes

	self setupScope.
	DeltaGlobalScope within: outer.
	
	outer computeHeapSet! !

"March 15, 2009 -> 16:46:53"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
setupTwoSubscopes

	self setupScope.
	DeltaGlobalScope within: outer! !

"March 15, 2009 -> 16:47:4"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
testWithOneSubscope

	self setupTwoSubscopes.
	
	outer computeHeapSet! !

"March 15, 2009 -> 16:47:51"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
testWithOneSubscope

	self setupScope.
	
	outer computeHeapSet! !

"March 15, 2009 -> 16:47:53"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
testWithTwoSubscopes

	self setupTwoSubscopes.
	
	outer computeHeapSet! !

"March 15, 2009 -> 16:48:7"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
testWithOneSubscope

	self setupScope.
	outer computeHeapSet! !

"March 15, 2009 -> 17:1:20"!

"System saved" !
"March 15, 2009 -> 17:2:8"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
testWithTwoSubscopes

	self setupTwoSubscopes.
	outer computeHeapSet! !

"March 15, 2009 -> 17:3:10"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
setupScope

	outer := DeltaCodeScope within: nil.
	(DeltaCodeScope within: outer) inline! !

"March 15, 2009 -> 17:3:22"!

"System saved" !
"March 15, 2009 -> 20:39:5"!

Delta define: #ComputeHeapSetTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'outer inner innerInner')) !


"March 15, 2009 -> 20:39:22"!

Delta define: #ComputeHeapSetTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'outer inner inner2 inner3')) !


"March 15, 2009 -> 20:39:31"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
setupScope

	outer := DeltaCodeScope within: nil.
	(inner := DeltaCodeScope within: outer) inline! !

"March 15, 2009 -> 20:40:44"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
setupScope

	outer := DeltaCodeScope within: nil.
	(inner := DeltaCodeScope within: outer) inline.
	(inner2 := DeltaCodeScope within: inner) inline.
	(inner3 := DeltaCodeScope within: inner2) inline! !

"March 15, 2009 -> 20:51:30"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
setupTwoVars

	|var|
	self setupScope.
	var := DeltaClassVar
					declare: #Var2
					of: nil
					inScope: inner2
					ifThere: [].
	inner2 at: #Var2 put: var! !

"March 15, 2009 -> 20:51:42"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
testWithTwoSubscopes

	self setupTwoVars.
	outer computeHeapSet! !

"March 15, 2009 -> 20:52:24"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
setupScope

	|var|
	outer := DeltaCodeScope within: nil.
	(inner := DeltaCodeScope within: outer) inline.
	(inner2 := DeltaCodeScope within: inner) inline.
	var := DeltaInstVar
					declare: #var1
					of: nil
					inScope: inner2
					ifThere: [].
	inner2 at: #var1 put: var.
	
	"(inner3 := DeltaCodeScope within: inner2) inline"! !

"March 15, 2009 -> 20:52:39"!

"System saved" !
"March 15, 2009 -> 21:21:18"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
setupScope

	|var|
	outer := DeltaCodeScope within: nil.
	(inner := DeltaCodeScope within: outer) inline.
	(inner2 := DeltaCodeScope within: inner) inline.
	var := DeltaInstVar
					declare: #var1
					of: nil
					inScope: inner2
					ifThere: [].
	inner2 superVars add: var.
	
	"(inner3 := DeltaCodeScope within: inner2) inline"! !

"March 15, 2009 -> 21:21:39"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
setupTwoVars

	|var|
	self setupScope.
	var := DeltaClassVar
					declare: #Var2
					of: nil
					inScope: inner2
					ifThere: [].
	inner2 superVars add: var! !

"March 15, 2009 -> 21:22:56"!

"System saved" !
"March 15, 2009 -> 21:35:54"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
setupScope

	|var|
	outer := DeltaCodeScope within: (DeltaCodeScope within: nil).
	(inner := DeltaCodeScope within: outer) inline.
	(inner2 := DeltaCodeScope within: inner) inline.
	var := DeltaInstVar
					declare: #var1
					of: nil
					inScope: inner2
					ifThere: [].
	inner2 superVars add: var.
	
	"(inner3 := DeltaCodeScope within: inner2) inline"! !

"March 15, 2009 -> 21:38:3"!

"System saved" !
"March 21, 2009 -> 13:38:51"!

Delta define: #RecursionBlockTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"March 21, 2009 -> 13:41:37"!

! (Delta mirrorFor: #RecursionBlockTest) methodsFor: 'testing' !
recurse: count block: block

	count > 0
		ifTrue: [self recurse: count - 1
							block: block]
		ifFalse: [block value]! !

"March 21, 2009 -> 13:42:17"!

! (Delta mirrorFor: #RecursionBlockTest) methodsFor: 'testing' !
recurse: count block: block

	count > 0
		ifTrue: [self recurse: count - 1
							block: block]
		ifFalse: [block value: count]! !

"March 21, 2009 -> 13:44:56"!

! (Delta mirrorFor: #RecursionBlockTest) methodsFor: 'testing' !
recurse4

	|result|
	result := OrderedCollection new.
	self recurse: 4
		block: [:var| var isInteger
								ifTrue: [result add: var]]! !

"March 21, 2009 -> 13:45:7"!

! (Delta mirrorFor: #RecursionBlockTest) methodsFor: 'testing' !
recursef4

	|result|
	result := OrderedCollection new.
	self recurse: 4.0
		block: [:var| var isInteger
								ifTrue: [result add: var]]! !

"March 21, 2009 -> 13:45:39"!

! (Delta mirrorFor: #RecursionBlockTest) methodsFor: 'testing' !
testRecurse4! !

"March 21, 2009 -> 13:45:53"!

! (Delta mirrorFor: #RecursionBlockTest) methodsFor: 'testing' !
recurse: val

	|result|
	result := OrderedCollection new.
	self recurse: val
		block: [:var| var isInteger
								ifTrue: [result add: var]]! !

"March 21, 2009 -> 13:45:59"!

(Delta mirrorFor: #RecursionBlockTest) removeMethod: #recurse4 ifAbsent: [] !


"March 21, 2009 -> 13:46:1"!

(Delta mirrorFor: #RecursionBlockTest) removeMethod: #recursef4 ifAbsent: [] !


"March 21, 2009 -> 13:46:20"!

! (Delta mirrorFor: #RecursionBlockTest) methodsFor: 'testing' !
recurse: val

	|result|
	result := OrderedCollection new.
	self recurse: val
		block: [:var| var isInteger
								ifTrue: [result add: var]].
	^result! !

"March 21, 2009 -> 13:47:6"!

! (Delta mirrorFor: #RecursionBlockTest) methodsFor: 'testing' !
testRecurse4

	self recurse: 4! !

"March 21, 2009 -> 13:47:13"!

! (Delta mirrorFor: #RecursionBlockTest) methodsFor: 'testing' !
testRecursef4

	self recurse: 4.0! !

"March 21, 2009 -> 13:50:45"!

"System saved" !
"March 21, 2009 -> 14:2:7"!

! (Delta mirrorFor: #RecursionBlockTest) methodsFor: 'testing' !
testRecurse4

	self recurse: 1! !

"March 21, 2009 -> 14:2:33"!

"System saved" !
"March 21, 2009 -> 14:5:2"!

! (Delta mirrorFor: #RecursionBlockTest) methodsFor: 'testing' !
recurse: val result: result

	self recurse: val
		block: [:var| var isInteger
								ifTrue: [result add: var]].
	^result! !

"March 21, 2009 -> 14:5:32"!

! (Delta mirrorFor: #RecursionBlockTest) methodsFor: 'testing' !
testRecursef4

	self recurse: 4.0
		result: OrderedCollection new! !

"March 21, 2009 -> 14:5:33"!

! (Delta mirrorFor: #RecursionBlockTest) methodsFor: 'testing' !
testRecurse4

	self recurse: 1
		result: OrderedCollection new! !

"March 21, 2009 -> 14:6:14"!

"System saved" !
"March 21, 2009 -> 14:44:29"!

(Delta mirrorFor: #RecursionBlockTest) removeMethod: #recurse: ifAbsent: [] !


"March 21, 2009 -> 14:46:34"!

"System saved" !
"March 21, 2009 -> 15:45:0"!

Delta define: #RecursionBlockTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'var')) !


"March 21, 2009 -> 15:45:22"!

! (Delta mirrorFor: #RecursionBlockTest) methodsFor: 'testing' !
recurse: count block: block

	count > 0
		ifTrue: [self recurse: count - 1
							block: var]
		ifFalse: [block value: var]! !

"March 21, 2009 -> 15:45:41"!

Delta define: #RecursionBlockTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'var value')) !


"March 21, 2009 -> 15:45:49"!

! (Delta mirrorFor: #RecursionBlockTest) methodsFor: 'testing' !
recurse: count block: block

	count > 0
		ifTrue: [self recurse: count - 1
							block: value]
		ifFalse: [block value: value]! !

"March 21, 2009 -> 15:46:2"!

Delta define: #RecursionBlockTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'value')) !


"March 21, 2009 -> 15:46:16"!

! (Delta mirrorFor: #RecursionBlockTest) methodsFor: 'testing' !
testRecurse4

	value = 3.
	self recurse: 1
		result: OrderedCollection new! !

"March 21, 2009 -> 15:46:29"!

! (Delta mirrorFor: #RecursionBlockTest) methodsFor: 'testing' !
testRecursef4

	value = 3.0.
	self recurse: 2
		result: OrderedCollection new! !

"March 21, 2009 -> 15:48:42"!

! (Delta mirrorFor: #RecursionBlockTest) methodsFor: 'testing' !
recurse: count block: block

	count > 0
		ifTrue: [self recurse: count - 1
							block: block]
		ifFalse: [block value: value]! !

"March 21, 2009 -> 15:49:14"!

"System saved" !
"March 21, 2009 -> 16:42:51"!

! (Delta mirrorFor: #RecursionBlockTest) methodsFor: 'testing' !
testRecursef4

	|result|
	value = 3.0.
	result := OrderedCollection new.
	self recurse: 2
		result: result.
	value = 4.
	self recurse: 2
		result: result! !

"March 21, 2009 -> 16:43:1"!

"System saved" !
"March 22, 2009 -> 0:50:22"!

! (Delta mirrorFor: #RecursionBlockTest) methodsFor: 'testing' !
testRecurse

	value = 3.
	self recurse: 1
		result: OrderedCollection new! !

"March 22, 2009 -> 0:50:32"!

(Delta mirrorFor: #RecursionBlockTest) removeMethod: #testRecurse ifAbsent: [] !


"March 22, 2009 -> 0:50:48"!

! (Delta mirrorFor: #RecursionBlockTest) methodsFor: 'testing' !
testRecurseFloat

	|result|
	value = 3.0.
	result := OrderedCollection new.
	self recurse: 2
		result: result.
	value = 4.
	self recurse: 2
		result: result! !

"March 22, 2009 -> 0:50:51"!

(Delta mirrorFor: #RecursionBlockTest) removeMethod: #testRecursef4 ifAbsent: [] !


"March 22, 2009 -> 0:50:55"!

! (Delta mirrorFor: #RecursionBlockTest) methodsFor: 'testing' !
testRecurseInteger

	value = 3.
	self recurse: 1
		result: OrderedCollection new! !

"March 22, 2009 -> 0:50:57"!

(Delta mirrorFor: #RecursionBlockTest) removeMethod: #testRecurse4 ifAbsent: [] !


"March 22, 2009 -> 0:51:4"!

"System saved" !
"March 29, 2009 -> 16:20:37"!

! (Delta mirrorFor: #Integer) methodsFor: 'benchmarking' !
benchFib  "Handy send-heavy benchmark"
	"(result // seconds to run) = approx calls per second"
	" | r t |
	  t _ Time millisecondsToRun: [r _ 26 benchFib].
	  (r * 1000) // t"
	"138000 on a Mac 8100/100"
	^ self < 2
		ifTrue: [1] 
		ifFalse: [(self-1) benchFib + (self-2) benchFib + 1]! !

"March 29, 2009 -> 16:24:3"!

"System saved" !
"April 4, 2009 -> 17:53:0"!

Delta define: #NonInlinedBlockTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"April 4, 2009 -> 17:53:53"!

! (Delta mirrorFor: #NonInlinedBlockTest) methodsFor: 'testing' !
testSetup! !

"April 4, 2009 -> 17:57:36"!

Delta define: #NIBA as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"April 4, 2009 -> 17:57:45"!

Delta define: #NIBB as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"April 4, 2009 -> 17:57:52"!

Delta define: #NIBC as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"April 4, 2009 -> 17:58:14"!

Delta define: #AbstractNIB as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"April 4, 2009 -> 17:59:2"!

Delta define: #NIBC as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:2"!

Delta define: #NIBC as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:2"!

Delta define: #NIBC as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:2"!

Delta define: #NIBC as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:2"!

Delta define: #NIBC as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:2"!

Delta define: #NIBC as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:2"!

Delta define: #NIBC as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:2"!

Delta define: #NIBC as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:2"!

Delta define: #NIBC as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:2"!

Delta define: #NIBC as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:2"!

Delta define: #NIBC as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:8"!

Delta define: #NIBB as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:8"!

Delta define: #NIBB as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:8"!

Delta define: #NIBB as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:8"!

Delta define: #NIBB as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:8"!

Delta define: #NIBB as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:8"!

Delta define: #NIBB as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:8"!

Delta define: #NIBB as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:8"!

Delta define: #NIBB as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:8"!

Delta define: #NIBB as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:8"!

Delta define: #NIBB as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:8"!

Delta define: #NIBB as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:31"!

Delta define: #NIBA as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:31"!

Delta define: #NIBA as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:31"!

Delta define: #NIBA as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:31"!

Delta define: #NIBA as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:31"!

Delta define: #NIBA as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:31"!

Delta define: #NIBA as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:31"!

Delta define: #NIBA as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:31"!

Delta define: #NIBA as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:31"!

Delta define: #NIBA as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:31"!

Delta define: #NIBA as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:31"!

Delta define: #NIBA as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 18:0:21"!

! (Delta mirrorFor: #AbstractNIB) methodsFor: 'testing' !
do: block value: value

	^block value: value! !

"April 4, 2009 -> 18:1:53"!

! (Delta mirrorFor: #NonInlinedBlockTest) methodsFor: 'testing' !
testSetup
	|a b c|
	a := NIBA new.
	b := NIBB new.
	c := NIBC new.
	self exercise: a value: 1.
	self exercise: b value: 1.
	self exercise: c value: 1
! !

"April 4, 2009 -> 18:3:7"!

! (Delta mirrorFor: #NonInlinedBlockTest) methodsFor: 'testing' !
exercise: nib value: value
	
	nib do: [:a | a isNil] value: value! !

"April 4, 2009 -> 18:4:43"!

! (Delta mirrorFor: #NonInlinedBlockTest) methodsFor: 'testing' !
testTrap1
	|a|
	a := NIBA new.
	self exercise: a value: 1.
	self exercise: a value: 1.0! !

"April 4, 2009 -> 18:4:55"!

! (Delta mirrorFor: #NonInlinedBlockTest) methodsFor: 'testing' !
testTrap
	|a|
	a := NIBA new.
	self exercise: a value: 1.
	self exercise: a value: 1.0! !

"April 4, 2009 -> 18:8:25"!

! (Delta mirrorFor: #NonInlinedBlockTest) methodsFor: 'testing' !
exercise: nib value: value
	|set|
	set := Set new.
	nib do: [:a | a isNil
						ifFalse: [set add: a]]
		value: value! !

"April 4, 2009 -> 18:10:7"!

(Delta mirrorFor: #NonInlinedBlockTest) removeMethod: #testTrap1 ifAbsent: [] !


"April 4, 2009 -> 18:10:19"!

"System saved" !
"April 4, 2009 -> 19:1:42"!

Delta define: #NIBD as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 19:2:41"!

! (Delta mirrorFor: #NonInlinedBlockTest) methodsFor: 'testing' !
testSetup
	self exercise: NIBA new value: 1.
	self exercise: NIBB new value: 1.
	self exercise: NIBC new value: 1.
	self exercise: NIBD new value: 1.
! !

"April 4, 2009 -> 19:2:59"!

"System saved" !
"April 4, 2009 -> 23:38:0"!

! (Delta mirrorFor: #NonInlinedBlockTest) methodsFor: 'testing' !
exercise: nib value: value
	|set|
	set := Set new.
	[nib do: [:a | a isNil
						ifFalse: [set add: a]]
		value: value] value! !

"April 4, 2009 -> 23:40:1"!

"System saved" !
"April 5, 2009 -> 11:48:28"!

! (Delta mirrorFor: #NonInlinedBlockTest) methodsFor: 'testing' !
exercise: nib value: value
	|set|
	set := Set new.
	[nib do: [:a | a isNil
							ifFalse: [set add: a].
						self assert: [a notNil]]
		value: value] value! !

"April 5, 2009 -> 11:49:39"!

! (Delta mirrorFor: #NonInlinedBlockTest) methodsFor: 'testing' !
exercise: nib value: value
	|set|
	set := Set new.
	[nib do: [:a | a isNil
							ifFalse: [set add: a].
						a assert: [a notNil]]
		value: value] value! !

"April 5, 2009 -> 11:50:0"!

"System saved" !
"April 5, 2009 -> 13:48:36"!

! (Delta mirrorFor: #NonInlinedBlockTest) methodsFor: 'testing' !
exercise: nib value: value
	|set|
	set := Set new.
	[:val1 | nib do: [:a | a isNil
										ifFalse: [set add: a].
									a assert: [a notNil]]
		value: val1] value: value! !

"April 5, 2009 -> 13:49:10"!

"System saved" !
"April 5, 2009 -> 14:7:4"!

! (Delta mirrorFor: #NonInlinedBlockTest) methodsFor: 'testing' !
exercise: nib value: value
	|set|
	set := Set new.
	nib do: [:val | [:a | a isNil
									ifFalse: [set add: a].
								a assert: [a notNil]]
								value: val]
		value: value! !

"April 5, 2009 -> 14:7:28"!

"System saved" !
"April 12, 2009 -> 2:21:54"!

! (Delta mirrorFor: #NonInlinedBlockTest) methodsFor: 'initialize-release' !
initialize! !

"April 12, 2009 -> 2:23:34"!

! (Delta mirrorFor: #NonInlinedBlockTest) classSide methodsFor: 'instance creation' !
new

	^(super new)
		initialize;
		yourself! !

"April 12, 2009 -> 2:23:53"!

Delta define: #NonInlinedBlockTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'a b c d')) !


"April 12, 2009 -> 2:25:4"!

! (Delta mirrorFor: #NonInlinedBlockTest) methodsFor: 'initialize-release' !
initialize

	a := NIBA new.
	b := NIBB new.
	c := NIBC new.
	d :=NIBD new.! !

"April 12, 2009 -> 2:25:24"!

! (Delta mirrorFor: #NonInlinedBlockTest) methodsFor: 'testing' !
testSetup
	self exercise: a value: 1.
	self exercise: b value: 1.
	self exercise: c value: 1.
	self exercise: d value: 1.
! !

"April 12, 2009 -> 2:25:42"!

! (Delta mirrorFor: #NonInlinedBlockTest) methodsFor: 'testing' !
testSetup
	self exercise: a value: 1.
	self exercise: b value: 1.
	self exercise: c value: 1.
	self exercise: d value: 1! !

"April 12, 2009 -> 2:25:55"!

! (Delta mirrorFor: #NonInlinedBlockTest) methodsFor: 'testing' !
testTrap

	self exercise: a value: 1.
	self exercise: a value: 1.0! !

"April 12, 2009 -> 2:29:33"!

! (Delta mirrorFor: #NonInlinedBlockTest) methodsFor: 'testing' !
exercise2: nib value: value
	|set|
	set := Set new.
	nib do: [:val |
					
					val assert: [val notNil].]
		value: value! !

"April 12, 2009 -> 2:33:0"!

! (Delta mirrorFor: #NonInlinedBlockTest) methodsFor: 'testing' !
exercise2: nib value: value
	|set|
	set := Set new.
	nib do: [:val |
					|block|
					block := [val notNil].
					val assert: [block value].
					val noyNil ifTrue: [set add: val]]
		value: value! !

"April 12, 2009 -> 2:33:16"!

! (Delta mirrorFor: #NonInlinedBlockTest) methodsFor: 'testing' !
testSetup2
	self exercise2: a value: 1.
	self exercise2: b value: 1.
	self exercise2: c value: 1.
	self exercise2: d value: 1! !

"April 12, 2009 -> 2:33:23"!

! (Delta mirrorFor: #NonInlinedBlockTest) methodsFor: 'testing' !
testTrap2

	self exercise2: a value: 1.
	self exercise2: a value: 1.0! !

"April 12, 2009 -> 2:34:4"!

! (Delta mirrorFor: #NonInlinedBlockTest) methodsFor: 'testing' !
exercise2: nib value: value
	|set|
	set := Set new.
	nib do: [:val |
					|block|
					block := [val notNil].
					val assert: [block value].
					val notNil ifTrue: [set add: val]]
		value: value! !

"April 12, 2009 -> 2:35:44"!

"System saved" !
"May 4, 2009 -> 14:11:47"!

Delta define: #CompilerTests as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"May 4, 2009 -> 14:12:58"!

Delta define: #CompilerTests as: (
(Class subclassOf: 'TestCase' instanceVariables: 'a')) !


"May 4, 2009 -> 14:13:9"!

! (Delta mirrorFor: #CompilerTests) methodsFor: 'initialise-release' !
setUp

a := NibA new! !

"May 4, 2009 -> 14:13:16"!

Delta define: #CompilerTests as: (
(Class subclassOf: 'TestCase' instanceVariables: 'a b c d')) !


"May 4, 2009 -> 14:13:58"!

! (Delta mirrorFor: #CompilerTests) methodsFor: 'initialise-release' !
setUp

a := NibA new.
b := NibB new.
c := NibC new.
d := NibD new! !

"May 4, 2009 -> 14:14:51"!

! (Delta mirrorFor: #CompilerTests) methodsFor: 'initialise-release' !
setUp

a := NIBA new.
b := NIBB new.
c := NIBC new.
d := NIBD new! !

"May 4, 2009 -> 14:15:58"!

! (Delta mirrorFor: #CompilerTests) methodsFor: 'testing' !
testOnce! !

"May 4, 2009 -> 14:16:8"!

! (Delta mirrorFor: #CompilerTests) methodsFor: 'testing' !
testOnce

	self with: a! !

"May 4, 2009 -> 14:17:59"!

! (Delta mirrorFor: #CompilerTests) methodsFor: 'testing' !
with: value

	value do: [:a|]
		value: 1! !

"May 4, 2009 -> 14:18:23"!

! (Delta mirrorFor: #CompilerTests) methodsFor: 'testing' !
testTwice

	self with: a.
	self with: b! !

"May 4, 2009 -> 14:19:12"!

Delta define: #AbstractCompilerFixture as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 4, 2009 -> 14:19:46"!

! (Delta mirrorFor: #AbstractCompilerFixture) methodsFor: 'test support' !
value

	^self! !

"May 4, 2009 -> 14:20:1"!

Delta define: #FixtureA as: (
(Class subclassOf: 'AbstractCompilerFixture' instanceVariables: '')) !


"May 4, 2009 -> 14:20:11"!

Delta define: #FixtureB as: (
(Class subclassOf: 'AbstractCompilerFixture' instanceVariables: '')) !


"May 4, 2009 -> 14:20:38"!

! (Delta mirrorFor: #CompilerTests) methodsFor: 'initialise-release' !
setUp

a := CompilerFixtureA new.
b := CompilerFixtureB new! !

"May 4, 2009 -> 14:20:54"!

! (Delta mirrorFor: #CompilerTests) methodsFor: 'initialise-release' !
setUp

a := FixtureA new.
b := FixtureB new! !

"May 4, 2009 -> 14:21:0"!

Delta define: #CompilerTests as: (
(Class subclassOf: 'TestCase' instanceVariables: 'a b')) !


"May 4, 2009 -> 14:21:25"!

! (Delta mirrorFor: #CompilerTests) methodsFor: 'testing' !
with: fixture

	^fixture value
	! !

"May 4, 2009 -> 14:22:23"!

! (Delta mirrorFor: #CompilerTests) classSide methodsFor: 'instance creation' !
new

	^(super new)
		initialize;
		release! !

"May 4, 2009 -> 14:22:29"!

! (Delta mirrorFor: #CompilerTests) methodsFor: 'initialise-release' !
initialize

a := FixtureA new.
b := FixtureB new! !

"May 4, 2009 -> 14:22:37"!

! (Delta mirrorFor: #CompilerTests) classSide methodsFor: 'instance creation' !
new

	^(super new)
		initialize;
		yourself! !

"May 4, 2009 -> 14:22:42"!

(Delta mirrorFor: #CompilerTests) removeMethod: #setUp ifAbsent: [] !


"May 4, 2009 -> 14:23:0"!

! (Delta mirrorFor: #CompilerTests) methodsFor: 'initialise-release' !
initialize

	a := FixtureA new.
	b := FixtureB new! !

"May 4, 2009 -> 14:23:46"!

"System saved" !
"May 4, 2009 -> 14:32:48"!

Delta define: #CompilerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'a b')) !


"May 4, 2009 -> 14:32:48"!

(Delta mirrorFor: #CompilerTest)
comment: 
''!


"May 4, 2009 -> 14:32:48"!

! (Delta mirrorFor: #CompilerTest) classSide methodsFor: 'instance creation' !
new

	^(super new)
		initialize;
		yourself! !

"May 4, 2009 -> 14:32:48"!

! (Delta mirrorFor: #CompilerTest) methodsFor: 'initialise-release' !
initialize

	a := FixtureA new.
	b := FixtureB new! !

"May 4, 2009 -> 14:32:48"!

! (Delta mirrorFor: #CompilerTest) methodsFor: 'testing' !
testOnce

	self with: a! !

"May 4, 2009 -> 14:32:48"!

! (Delta mirrorFor: #CompilerTest) methodsFor: 'testing' !
testTwice

	self with: a.
	self with: b! !

"May 4, 2009 -> 14:32:48"!

! (Delta mirrorFor: #CompilerTest) methodsFor: 'testing' !
with: fixture

	^fixture value
	! !

"May 4, 2009 -> 14:33:20"!

(Delta mirrorFor: #CompilerTests) removeDefinitionIfFail: [] !


"May 4, 2009 -> 14:33:33"!

"System saved" !
"May 24, 2009 -> 17:30:28"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildCodeView ^<Visual>

	| cv <CodeView> vmSrc <Str> strm <CharacterReadStream> gls <OrdCltn[CharacterGlyph]> |

	"Construct vm source with highligthed bci"
	vmSrc := self activation vmPrettyPrint.
	strm := vmSrc readStream.
	gls := OrderedCollection[CharacterGlyph] new: vmSrc size.
	(vmSrc occurrencesOf: self currentByteCodeSeparatorCharacter) = 2
		ifTrue: [	gls addAll: (self standardTextForString: (strm upTo: self currentByteCodeSeparatorCharacter) painter: self codePainter).
						gls addAll: (self standardTextForString: (strm upTo: self currentByteCodeSeparatorCharacter) painter: self codeBCIPainter) ].
	gls addAll: (self standardTextForString: strm contentsRemaining painter: self codePainter).
	
	cv := CodeView forText.
	cv doneBlock: [ :b <Boolean> :onSuccess <[]> | b ifTrue: onSuccess ].	"Dummy for now, we are not showing the real source code"
	cv model: gls.
	^self editorBorderFor: cv
! !

"May 24, 2009 -> 17:34:19"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildActions ^ <Visual>

	| row <Row[Visual]> |

	row := Row[Button] new.
	row add: (Button labeled: 'Step' action: [:b <Button> | ]).
	
	^row! !

"May 24, 2009 -> 17:35:46"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildBody ^<Visual>

	| col <Column[Visual]> |

	col := Column[Visual] new.
	col add: self buildActions;
		add: self buildCodeView.
	^col
! !

"May 24, 2009 -> 17:38:44"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildActions ^ <Visual>

	| row <Row[Visual]> |

	row := Row[Button] new.
	row add: (Button labeled: 'Step into' action: [:b <Button> | ]).
	row add: (Button labeled: 'Step over' action: [:b <Button> | ]).
	row add: (Button labeled: 'Step out' action: [:b <Button> | ]).
	^row! !

"May 26, 2009 -> 11:30:17"!

"System saved" !
"May 30, 2009 -> 20:33:29"!

! (Delta mirrorFor: #ActivationOutliner) classSide methodsFor: 'instance creation' !
on: a <Activation> debugger: debugger<StackTraceInspector> ^ <Instance>

	^self new initActivation: a! !

"May 30, 2009 -> 20:33:29"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'private' !
buildBareVisualTop: top <Boolean> ^ <Visual>

	| stack <Array[Activation]> col <Column[Visual]> start <Int> |
	stack := self process activationStack.
	col := Column[Visual] new.
	start := 1 + self process processError topFramesIgnored.
	
	"Add first activation open"
	self assert: [ start < stack size ].
	col add: ((ActivationOutliner
						on: (stack at: start)
						debugger: self)
							open: true;
							imbeddedVisual) .
	start+1 to: stack size do: [ :i <Int> |
		| a <Activation> |
		a := stack at: i.
		a isBlockValueActivation
			ifFalse: [	col add: (ActivationOutliner on: a) imbeddedVisual ]
	].
	^col
! !

"May 30, 2009 -> 20:33:29"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private-initialization' !
initActivation: a <Activation> debugger: d <StackTraceInspector>

	activation := a! !

"May 30, 2009 -> 20:33:29"!

! (Delta mirrorFor: #ActivationOutliner) classSide methodsFor: 'instance creation' !
on: a <Activation> debugger: debugger<StackTraceInspector> ^ <Instance>

	^self new initActivation: a debugger: debugger! !

"May 30, 2009 -> 20:33:29"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:29"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:29"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:29"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:29"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:29"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:29"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:29"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:29"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:29"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:29"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:29"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private-initialization' !
initActivation: a <Activation> debugger: d <StackTraceInspector>

	activation := a.
	debugger := d! !

"May 30, 2009 -> 20:33:29"!

! (Delta mirrorFor: #ActivationOutliner) classSide methodsFor: 'instance creation' !
on: a <Activation> debugger: debugger<StackTraceInspector> ^ <Instance>

	^self new initActivation: a! !

"May 30, 2009 -> 20:33:30"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'private' !
buildBareVisualTop: top <Boolean> ^ <Visual>

	| stack <Array[Activation]> col <Column[Visual]> start <Int> |
	stack := self process activationStack.
	col := Column[Visual] new.
	start := 1 + self process processError topFramesIgnored.
	
	"Add first activation open"
	self assert: [ start < stack size ].
	col add: ((ActivationOutliner
						on: (stack at: start)
						debugger: self)
							open: true;
							imbeddedVisual) .
	start+1 to: stack size do: [ :i <Int> |
		| a <Activation> |
		a := stack at: i.
		a isBlockValueActivation
			ifFalse: [	col add: (ActivationOutliner on: a) imbeddedVisual ]
	].
	^col
! !

"May 30, 2009 -> 20:33:30"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private-initialization' !
initActivation: a <Activation> debugger: d <StackTraceInspector>

	activation := a! !

"May 30, 2009 -> 20:33:30"!

! (Delta mirrorFor: #ActivationOutliner) classSide methodsFor: 'instance creation' !
on: a <Activation> debugger: debugger<StackTraceInspector> ^ <Instance>

	^self new initActivation: a debugger: debugger! !

"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private-initialization' !
initActivation: a <Activation> debugger: d <StackTraceInspector>

	activation := a.
	debugger := d! !

"May 30, 2009 -> 20:39:16"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'control' !
singleStep: activation

	Transcript cr;
		show: 'single step for: '.
	activation printOn: Transcript.
	Transcript cr! !

"May 30, 2009 -> 20:39:30"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'control' !
singleStep: activation <Activation>

	Transcript cr;
		show: 'single step for: '.
	activation printOn: Transcript.
	Transcript cr! !

"May 30, 2009 -> 20:40:30"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildActions ^ <Visual>

	| row <Row[Visual]> |

	row := Row[Button] new.
	row add: (Button
						labeled: 'Step into'
						action: [:b <Button> | debugger singleStep: self]).
	row add: (Button labeled: 'Step over' action: [:b <Button> | ]).
	row add: (Button labeled: 'Step out' action: [:b <Button> | ]).
	^row! !

"May 30, 2009 -> 20:53:7"!

"System saved" !
"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>')) !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>')) !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>')) !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>')) !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>')) !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>')) !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

! (Delta mirrorFor: #StackTraceInspector) classSide methodsFor: 'private - accessing' !
debuggers ^<Dict[Process,StackTraceInspector]>

	Debuggers isNil
		ifTrue: [Debuggers := Dictionary[Process, StackTraceInspector] new].
	^Debuggers! !

"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

! (Delta mirrorFor: #StackTraceInspector) classSide methodsFor: 'instance creation' !
on: p <Process> ^ <Instance>

	|debugger|
	(debugger := self new) initProcess: p.
	self debuggers at: p put: debugger.
	^debugger! !

"May 30, 2009 -> 22:6:4"!

! (Delta mirrorFor: #StackTraceInspector) classSide methodsFor: 'private - accessing' !
removeDebugger: debugger <StackTraceInspector>

	self debuggers
		remove: debugger process
		ifAbsent: []! !

"May 30, 2009 -> 22:6:4"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'private' !
remove

	self class removeDebugger: self! !

"May 30, 2009 -> 22:6:4"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'control' !
abortProcess

	"Process get aborted by default when stack trace inspector is closed"
	self remove.
	self requestCloseIfTopWindow.

! !

"May 30, 2009 -> 22:6:4"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'control' !
continueProcess

	|topWindow|
	self remove.
	self process resume.
	self process: nil.		"Don't terminate process when window closes"
	topWindow := self visual topWindow.
	topWindow isNil
		ifFalse: [topWindow requestClose]! !

"May 30, 2009 -> 22:6:4"!

! (Delta mirrorFor: #StackTraceInspector) classSide methodsFor: 'private - accessing' !
removeDebugger: debugger <StackTraceInspector>

	self debuggers
		removeAt: debugger process
		ifAbsent: []! !

"May 30, 2009 -> 22:7:32"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'private' !
addActivationsTo: col <Column[Visual]>

	| stack <Array[Activation]> start <Int> |
	stack := self process activationStack.
	start := 1 + self process processError topFramesIgnored.
	
	"Add first activation open"
	self assert: [ start < stack size ].
	col add: ((ActivationOutliner
						on: (stack at: start)
						debugger: self)
							open: true;
							imbeddedVisual) .
	start+1 to: stack size do: [ :i <Int> |
		| a <Activation> |
		a := stack at: i.
		a isBlockValueActivation
			ifFalse: [	col add: (ActivationOutliner
											on: a
											debugger: self) imbeddedVisual ]
	]! !

"May 30, 2009 -> 22:8:6"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'private' !
buildBareVisualTop: top <Boolean> ^ <Visual>

	activationOutliners := Column[Visual] new.
	self addActivationsTo: activationOutliners.
	^activationOutliners
! !

"May 30, 2009 -> 22:9:47"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'private' !
rebuild

	activationOutliners removeAll.
	self addActivationsTo: activationOutliners! !

"May 30, 2009 -> 22:11:31"!

! (Delta mirrorFor: #StackTraceInspector) classSide methodsFor: 'instance creation' !
openOn: p <Process>
	|debugger|
	debugger := self debuggers at: p.
	debugger isNil
		ifTrue: [(self on: p) launch]
		ifFalse: [debugger rebuild]! !

"May 30, 2009 -> 22:17:19"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'private' !
outlinerFor: activation <Activation> open: b <Boolean>

	^(ActivationOutliner
			on: activation
			debugger: self)
				open: b;
				imbeddedVisual! !

"May 30, 2009 -> 22:18:22"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'private' !
addActivationsTo: col <Column[Visual]>

	| stack <Array[Activation]> start <Int> |
	stack := self process activationStack.
	start := 1 + self process processError topFramesIgnored.
	
	"Add first activation open"
	self assert: [ start < stack size ].
	col add: (self outlinerFor: (stack at: start)
						open: true).
	start+1 to: stack size do: [ :i <Int> |
		| a <Activation> |
		a := stack at: i.
		a isBlockValueActivation
			ifFalse: [	col add: (ActivationOutliner
											on: a
											debugger: self) imbeddedVisual ]
	]! !

"May 30, 2009 -> 22:19:25"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'private' !
addActivationsTo: col <Column[Visual]>

	| stack <Array[Activation]> start <Int> |
	stack := self process activationStack.
	start := 1 + self process processError topFramesIgnored.
	
	"Add first activation open"
	self assert: [ start < stack size ].
	col add: (self outlinerFor: (stack at: start)
						open: true).
	start+1 to: stack size do: [ :i <Int> |
		| a <Activation> |
		a := stack at: i.
		a isBlockValueActivation
			ifFalse: [	col add: (self outlinerFor: a open: false) ]
	]! !

"May 31, 2009 -> 1:40:9"!

"System saved" !
"May 31, 2009 -> 1:46:57"!

! (Delta mirrorFor: #StackTraceInspector) classSide methodsFor: 'instance creation' !
openOn: p <Process>
	
	(self debuggers
				at: p
				ifAbsent: [(self on: p) launch. ^self]) rebuild! !

"May 31, 2009 -> 1:48:19"!

"System saved" !
"May 31, 2009 -> 1:49:31"!

! (Delta mirrorFor: #Launcher) classSide methodsFor: 'control' !
startProgEnv ^<Instance>

	| launcher <Instance> |
	self createUITranscript.
	
	"Register stophandler for process scheduler"
	Processor stopHandler: [ :p <Process> | StackTraceInspector openOn: p ].

	launcher := (self new) launch; yourself.

	"Don't launch start page if system is inconsistent so that it won't
		obscure the error messages in the transcript"
	SourceHandler systemIsConsistent
		ifTrue: [ [ launcher browseStartPage ] fork. ]. 

	^launcher
! !

"May 31, 2009 -> 1:49:41"!

"System saved" !
"May 31, 2009 -> 1:54:7"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'control' !
singleStep: activation <Activation>

	{{primitiveProcessSingleStep: self process ifFail: [:err <Symbol> | self error: err]}}! !

"May 31, 2009 -> 1:55:49"!

"System saved" !
"May 31, 2009 -> 2:3:17"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'control' !
singleStep: activation <Activation>

	{{primitiveProcessSingleStep: self process ifFail: [:err <Symbol> | self error: err]}}.
	self process resume! !

"May 31, 2009 -> 2:3:29"!

"System saved" !
"May 31, 2009 -> 11:42:39"!

! (Delta mirrorFor: #StackTraceInspector) classSide methodsFor: 'instance creation' !
openOn: p <Process>
	
	(self debuggers
				at: p
				ifAbsent: [^(self on: p) launch]) rebuild! !

"May 31, 2009 -> 11:42:39"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'private' !
addActivationsTo: col <Column[Visual]>

	| stack <Array[Activation]> start <Int> |
	stack := self process activationStack.
	start := 1 "+ self process processError topFramesIgnored".
	
	"Add first activation open"
	self assert: [ start < stack size ].
	col add: (self outlinerFor: (stack at: start)
						open: true).
	start+1 to: stack size do: [ :i <Int> |
		| a <Activation> |
		a := stack at: i.
		a isBlockValueActivation
			ifFalse: [	col add: (self outlinerFor: a open: false) ]
	]! !

"May 31, 2009 -> 11:42:49"!

"System saved" !
"June 1, 2009 -> 20:53:28"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'private' !
rebuild

	self inSessionProcessDo:
		[activationOutliners removeAll.
		self addActivationsTo: activationOutliners]! !

"June 1, 2009 -> 20:53:39"!

"System saved" !
"June 9, 2009 -> 1:53:0"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'control' !
stepNext: activation <Activation>

	{{primitiveActivationStepNext: activation ifFail: [:err <Symbol> | self error: err]}}.
	self process resume! !

"June 9, 2009 -> 1:54:39"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildActions ^ <Visual>

	| row <Row[Visual]> |

	row := Row[Button] new.
	row add: (Button
						labeled: 'Step into'
						action: [:b <Button> | debugger singleStep: self activation]).
	row add: (Button 
						labeled: 'Step over'
						action: [:b <Button> | debugger stepNext: self activation]).
	row add: (Button labeled: 'Step out' action: [:b <Button> | ]).
	^row! !

"June 9, 2009 -> 1:54:58"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'control' !
stepReturn: activation <Activation>

	{{primitiveActivationStepNext: activation ifFail: [:err <Symbol> | self error: err]}}.
	self process resume! !

"June 9, 2009 -> 1:55:42"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildActions ^ <Visual>

	| row <Row[Visual]> |

	row := Row[Button] new.
	row add: (Button
						labeled: 'Step into'
						action: [:b <Button> | debugger singleStep: self activation]).
	row add: (Button 
						labeled: 'Step over'
						action: [:b <Button> | debugger stepNext: self activation]).
	row add: (Button
						labeled: 'Step out'
						action: [:b <Button> | debugger stepReturn: self activation]).
	^row! !

"June 9, 2009 -> 1:56:0"!

"System saved" !
"June 9, 2009 -> 23:47:44"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'control' !
stepReturn: activation <Activation>

	{{primitiveActivationStepReturn: activation ifFail: [:err <Symbol> | self error: err]}}.
	self process resume! !

"June 9, 2009 -> 23:49:12"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'control' !
singleStep: activation <Activation>

	{{primitiveActivationSingleStep: activation ifFail: [:err <Symbol> | self error: err]}}.
	self process resume! !

"June 9, 2009 -> 23:49:44"!

"System saved" !
"June 9, 2009 -> 23:52:12"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'private' !
step: activation setup: block

	block value: activation.
	self process resume! !

"June 9, 2009 -> 23:53:58"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'control' !
singleStep: activation <Activation>

	self resumeAfter: [{{primitiveActivationSingleStep: activation
										ifFail: [:err <Symbol> | self error: err]}}]! !

"June 9, 2009 -> 23:54:19"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'private' !
resumeAfter: block

	block value.
	self process resume! !

"June 9, 2009 -> 23:54:53"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'control' !
stepNext: activation <Activation>

	self resumeAfter: [{{primitiveActivationStepNext: activation
										ifFail: [:err <Symbol> | self error: err]}}]! !

"June 9, 2009 -> 23:55:15"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'control' !
stepReturn: activation <Activation>

	self resumeAfter: [{{primitiveActivationStepReturn: activation
										ifFail: [:err <Symbol> | self error: err]}}]! !

"June 9, 2009 -> 23:55:24"!

"System saved" !
"June 19, 2009 -> 0:13:15"!

Delta define: #MacOSXPlatform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"June 19, 2009 -> 0:13:15"!

(Delta mirrorFor: #MacOSXPlatform)
comment: 
'The class side holds platform dependent constants and utilities.  Is also used
to get command line args, and other things like that.

Keywords: %machdep  %User

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.4 $
'!


"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLInitialize
    DLLDict := Dictionary new.
    {{primitiveDLLSetupLookup: self selector: #DLLLookup:in: ifFail: [:err | self error: err]}}! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLLibrary: name
    ^DLLDict at: name ifAbsent: [
        DLLDict at: name put: (self DLLLoad: name)
    ]! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLLoad: name
    | r n |
    r := ExternalProxy new.
    n := (self DLLMapName: name) asSymbol.
    ^{{primitiveDLLLoad: n result: r ifFail: [ :err | self error: err]}}! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLLookup: name <Str> in: library <Str>
    "Convert library into proxy"
    | p r |
    p := self DLLLibrary: library.
    r := ExternalProxy new.
    {{primitiveDLLLookup: name asSymbol in: p result: r ifFail: [:err | self error: err]}}.
    ^r! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLMapName: name <Str> ^<Str>
    name = 'libc' ifTrue: [^'libc.dylib'].
    ^name, '.so'! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'clipboard access' !
clipboardText: str <Str>

    self openClipboard.
    [   | glob <HGLOBAL> strm <ReadWriteStream[Character]> xstr <Str> |
        self emptyClipboard.

        "transform string into a form with lfs inserted"
        strm := (String new: str size) readWriteStream.
        str do:
            [ :c <Character> |
                strm put: c.
                c = Character cr
                    ifTrue: [ strm put: Character lf ].
            ].
        xstr := String withAll: strm contentsWritten.

        glob := HGLOBAL new
                        allocate: xstr size + 1
                        attributes: (Win32 GMEM_MOVEABLE
                                            externalBitOr: Win32 GMEM_DDESHARE).
        glob withPointer: CString new
                do: [ :cs <CString> |
                            cs value: xstr   ].

        {{<user ExternalProxy SetClipboardData>
                format: Win32 CF_TEXT
                data: glob
        }} isNull
            ifTrue: [ Win32 handleError ].
    ] ensure:
        [ self closeClipboard ]! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'clipboard access' !
clipboardTextIfAbsent: blk <[^X def]> ^<Str | X>

    self openClipboard.
    [   | glob <HGLOBAL> strm <CharWriteStream> |

        {{<user ExternalProxy IsClipboardFormatAvailable> format: Win32 CF_TEXT}} asBoolean
            ifFalse: [ ^blk value ].
        glob := {{<user HGLOBAL GetClipboardData> format: Win32 CF_TEXT}}.
        glob isNull
            ifTrue: [ Win32 handleError ].
        strm := (String new: 100) writeStream.
        glob withPointer: CString new
                do: [ :cs <CString> |
                            cs asString do:
                                [ :c <Character> |
                                    c = Character lf
                                        ifFalse: [ strm put: c ]
                                ].
                            ^strm contentsWritten
                      ].
    ] ensure:
        [ self closeClipboard ]! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'command line' !
commandLine ^<Str>
   ^self getCommandLine! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'command line' !
commandLineTokens ^<InputStream[Str]>
    "a stream of the input line tokens.  Tokens are sequences separated by whitespace; whitespace can be 
        included in a token by double quoting the arg.  (quotes can be imbedded by doubling, as with Smalltalk strings;
        the returned token has delimiting quotes removed and internal quotes undoubled. "

    | cstrm <CharInputStream> |
    cstrm := self commandLine readStream.
    self skipSpacesIn: cstrm.
    ^CustomInputStream[Str] new
            nextBlock: [    self parseArgFrom: cstrm ];
            atEndBlock: [ cstrm atEnd ].! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'command line' !
getArguments ^<OrdCltn[Str]>

    ^ {{ primitiveCommandLineArgs }} asOrderedCollection
    	collect: [:bytes| bytes asString]! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'command line' !
getCommandLine
    | stream |
    stream := CharacterReadWriteStream on: ''.
    self getArguments do: [:arg| stream nextPutAll: arg; space].
    stream isEmpty ifTrue: [^''].
    ^stream copyFrom: 1 to: stream size - 1! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'constants' !
multipleMatchWildcardCharacter ^<Character>

    ^$*! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'constants' !
singleMatchWildcardCharacter ^<Character>

    ^$?! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'constants' !
wordSize ^<Int>
    ^4! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'environment' !
environmentVariableAt: key <Str> ifAbsent: blk <[^X def]> ^ <Str | X>

    | cKey <CString> cValue <CString> |
    cKey := CString for: key.
    [cValue := {{<libc CString getenv> key: cKey}}.
    ^cValue isNull
    	ifTrue: [blk value]
    	ifFalse: [cValue asString]]
    	ensure: [cKey free]! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'initialization' !
initialize

    self DLLInitialize! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'os specific' !
currentThreadId
	"^ 0"
	^ {{ primitiveCurrentThreadId }}! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'os streams' !
errorStream ^<CharOutputStream>

    ErrorStream isNil
        ifTrue: [   ErrorStream := TempTranscript new ].
    ^ErrorStream! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'platform classes' !
pathClass ^<FilePath class>

    ^UnixFilePath! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'platform classes' !
patternClass ^<FilePattern class>

    ^UnixFilePattern! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'private' !
parseArgFrom: strm <CharInputStream>  ^<Str>

    ^strm peek = $"
        ifTrue: [       strm next.
                        strm upTo: $"   ]
        ifFalse: [  strm upTo: Character space ]! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'private' !
skipSpacesIn: strm <CharInputStream>

    [ strm atEnd not and: [ strm peekFor: Character space] ] whileTrue.
! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'private-clipboard access' !
closeClipboard

    {{<user ExternalProxy CloseClipboard> call}}! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'private-clipboard access' !
emptyClipboard

    {{<user ExternalProxy EmptyClipboard> call}} asBoolean
        ifFalse: [ Win32 handleError ].
! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'private-clipboard access' !
openClipboard

    {{<user ExternalProxy OpenClipboard> hnd: Win32 NULL}} asBoolean
        ifFalse: [ Win32 handleError ].
! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'testing' !
usesCrLfConvention ^<Boolean>

    ^false! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t tm |
	t := TimeT new allocate.
	[{{<libc ExternalProxy time> struct: t}} isAllOnes
		ifTrue: [self error: 'Invalid time'].
	tm := {{<libc TM gmtime>
					struct: t}}.
	^tm asSYSTEMTIME] ensure: [t free]
! !

"June 19, 2009 -> 0:13:55"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLMapName: name <Str> ^<Str>
    name = 'libc' ifTrue: [^'libc.dylib'].
    ^name, '.dylib'! !

"June 19, 2009 -> 0:14:50"!

"System saved" !
"June 19, 2009 -> 0:34:6"!

Delta define: #MacOSXFileDescriptor as: (
(Class subclassOf: 'UnixFileDescriptor' instanceVariables: '')) !


"June 19, 2009 -> 0:35:3"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
fileDescriptorClass ^<FileDescriptor class>
"%TODO delegate to Platform"
    ^UnixFileDescriptor! !

"June 19, 2009 -> 0:35:31"!

Delta define: #MacOSXFilePath as: (
(Class subclassOf: 'UnixFilePath' instanceVariables: '')) !


"June 19, 2009 -> 0:35:50"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'platform classes' !
pathClass ^<FilePath class>

    ^MacOSXFilePath! !

"June 19, 2009 -> 0:36:31"!

! (Delta mirrorFor: #MacOSXFilePath) methodsFor: 'private' !
fileDescriptorClass ^<FileDescriptor class>
"%TODO delegate to Platform"
    ^MacOSXFileDescriptor! !

"June 19, 2009 -> 0:37:18"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'accessing' !
blockSize ^<Int>
    "Use the sector size"
    | statBuffer <StatBuffer> 
    	status <ExternalProxy> |
    statBuffer := StatBuffer new.
    statBuffer allocate.
    [ status := {{<libc ExternalProxy fxstat>
    					version: statBuffer version
            			name: self handle
            			buffer: statBuffer    }}.
	^status asSmallInteger == -1
		ifTrue: [4096]
		ifFalse: [ statBuffer blockSize ]]
		ensure: [ statBuffer free]! !

"June 19, 2009 -> 0:48:25"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'accessing' !
blockSize ^<Int>
    "Use the sector size"
    | statBuffer <StatBuffer> 
    	status <ExternalProxy> |
    statBuffer := StatBuffer new.
    statBuffer allocate.
    [ status := {{<libc ExternalProxy fstat>
    					version: statBuffer version
            			name: self handle
            			buffer: statBuffer    }}.
	^status asSmallInteger == -1
		ifTrue: [4096]
		ifFalse: [ statBuffer blockSize ]]
		ensure: [ statBuffer free]! !

"June 19, 2009 -> 0:49:2"!

"System saved" !
"June 19, 2009 -> 0:54:8"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'accessing' !
size ^<Int>
    "Use the sector size"
    | statBuffer <StatBuffer> 
    	status <ExternalProxy> |
    statBuffer := StatBuffer new.
    statBuffer allocate.
    [ status := {{<libc ExternalProxy fxstat>
    					version: statBuffer version
            			name: self handle
            			buffer: statBuffer    }}.
	^status asSmallInteger == -1
		ifTrue: [0]
		ifFalse: [ statBuffer fileSize ]]
		ensure: [ statBuffer free]! !

"June 19, 2009 -> 0:54:28"!

"System saved" !
"June 19, 2009 -> 1:2:32"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'accessing' !
size ^<Int>
    "Use the sector size"
    | statBuffer <StatBuffer> 
    	status <ExternalProxy> |
    statBuffer := StatBuffer new.
    statBuffer allocate.
    [ status := {{<libc ExternalProxy fstat>
    					version: statBuffer version
            			name: self handle
            			buffer: statBuffer    }}.
	^status asSmallInteger == -1
		ifTrue: [0]
		ifFalse: [ statBuffer fileSize ]]
		ensure: [ statBuffer free]! !

"June 19, 2009 -> 1:2:40"!

"System saved" !
"June 23, 2009 -> 21:2:43"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'accessing' !
size ^<Int>
    "Use the sector size"
    | statBuffer <StatBuffer> 
    	status <ExternalProxy> |
    statBuffer := StatBuffer new.
    statBuffer allocate.
    [ status := {{<libc ExternalProxy fstat>
            			name: self handle
            			buffer: statBuffer    }}.
	^status asSmallInteger == -1
		ifTrue: [0]
		ifFalse: [ statBuffer fileSize ]]
		ensure: [ statBuffer free]! !

"June 23, 2009 -> 21:2:45"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'accessing' !
blockSize ^<Int>
    "Use the sector size"
    | statBuffer <StatBuffer> 
    	status <ExternalProxy> |
    statBuffer := StatBuffer new.
    statBuffer allocate.
    [ status := {{<libc ExternalProxy fstat>
            			name: self handle
            			buffer: statBuffer    }}.
	^status asSmallInteger == -1
		ifTrue: [4096]
		ifFalse: [ statBuffer blockSize ]]
		ensure: [ statBuffer free]! !

"June 23, 2009 -> 21:3:11"!

"System saved" !
"June 23, 2009 -> 21:59:1"!

Delta define: #MacOSXStatBuffer as: (
(Class subclassOf: 'StatBuffer' instanceVariables: '')) !


"June 23, 2009 -> 21:59:35"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'private' !
statBufferClass

	^MacOSXStatBuffer! !

"June 23, 2009 -> 22:0:15"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'accessing' !
size ^<Int>
    "Use the sector size"
    | statBuffer <StatBuffer> 
    	status <ExternalProxy> |
    statBuffer := self statBufferClass new.
    statBuffer allocate.
    [ status := {{<libc ExternalProxy fstat>
            			name: self handle
            			buffer: statBuffer    }}.
	^status asSmallInteger == -1
		ifTrue: [0]
		ifFalse: [ statBuffer fileSize ]]
		ensure: [ statBuffer free]! !

"June 23, 2009 -> 22:0:17"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'accessing' !
blockSize ^<Int>
    "Use the sector size"
    | statBuffer <StatBuffer> 
    	status <ExternalProxy> |
    statBuffer := self statBufferClass new.
    statBuffer allocate.
    [ status := {{<libc ExternalProxy fstat>
            			name: self handle
            			buffer: statBuffer    }}.
	^status asSmallInteger == -1
		ifTrue: [4096]
		ifFalse: [ statBuffer blockSize ]]
		ensure: [ statBuffer free]! !

"June 23, 2009 -> 22:6:38"!

! (Delta mirrorFor: #MacOSXStatBuffer) methodsFor: 'offsets' !
fileSizeOffset

	^48! !

"June 23, 2009 -> 22:6:52"!

! (Delta mirrorFor: #MacOSXStatBuffer) methodsFor: 'offsets' !
blockSizeOffset

	^64! !

"June 23, 2009 -> 22:10:33"!

! (Delta mirrorFor: #MacOSXStatBuffer) methodsFor: 'accessing' !
structureSize

	^96! !

"June 23, 2009 -> 22:12:6"!

"System saved" !
"June 25, 2009 -> 0:52:52"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'accessing' !
stat: block ifFail: failBlock

    | statBuffer <StatBuffer> 
    	status <ExternalProxy> |
    statBuffer := self statBufferClass new.
    statBuffer allocate.
    [ status := {{<libc ExternalProxy fstat>
            			name: self handle
            			buffer: statBuffer    }}.
	^status asSmallInteger == -1
		ifTrue: [failBlock value]
		ifFalse: [ block value: statBuffer ]]
			ensure: [ statBuffer free]

	! !

"June 25, 2009 -> 0:53:35"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'accessing' !
blockSize ^<Int>
    "Use the sector size"
    ^self stat: [:buffer| buffer blockSize]
    		ifFail: [4096]! !

"June 25, 2009 -> 0:53:58"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'accessing' !
size ^<Int>
    "Use the sector size"
    ^self stat: [:buffer| buffer fileSize]
    		ifFail: [0]! !

"June 25, 2009 -> 1:7:41"!

! (Delta mirrorFor: #ExternalReadWriteStream) classSide methodsFor: 'testing' !
test
    "self test"
    |    file <FilePath>
        sz <Int>
        read <ExternalReadStream>
        write <ExternalReadWriteStream>
        in <CharInStream>
        out <CharOutStream>
        bytes <ByteArray>
        s <Str> |
    file := FilePath for: 'deltatest.tmp'.
    sz := 12345.    "make sure this number is much greater than the stream buffer size" 
    write := file writeStream.
    0 to: sz-1 do: 
        [ :i <Int> |
            write nextPut: i \\ 100.    ].
    self test: 1 is: [ write size = sz ].
    write position: 5001.
    write nextPut: 123.
    write close.
    write := file readWriteStream.
    write position: 5000.
    write nextPut: 12.
    self test: 2 is: [ write next = 123 ].
    write setToEnd.
    bytes := write contentsWritten.
    self test: 3 is: [ Transcript show: 'actual: '; print: bytes size; show: ', expected: '; print: sz;cr. bytes size = sz ].
    write close.
    read := file readStream.
    self test: 4 is: [ read peek = 0 ].
    self test: 5 is: [ read size = sz ].
    0 to: sz-1 do:
        [ :i <Int> |
            | byte <Int> |
            byte := read next.
            self test: 6 is:
                [ i ~= 5001
                    ifTrue: [ i ~= 5000
                                ifTrue: [ (i \\ 100) = byte ]
                                ifFalse: [ byte = 12 ]    ]
                    ifFalse: [ byte = 123 ]    ].
            self test: 7 is: [ (bytes at: i + 1) = byte ].    ].

    self test: 8 is: [ read atEnd ].
    read position: 5001.

    self test: 9 is: [ read next = 123 ].
    read position: 0.

    self test: 10 is: [ bytes = read contentsRemaining ].
    read close.
    out := file charOutputStream.
    s := 'hi 
there'.
    out nextPutAll: s.
    out close.
    in := file charInputStream.

    self test: 11 is: [ in peek = (s at: 1) ].

    1 to: s size do: 
        [ :i <Int> |
            self test: 12 is: [
				| n |
				n := in next.
				(s at: i) =  n].    ].

    self test: 13 is: [ in atEnd ].
    in close.
    in := file charInputStream.

    self test: 14 is: [ in contentsRemaining = s ].
    in close.! !

"June 25, 2009 -> 1:8:54"!

"System saved" !
"June 25, 2009 -> 21:58:12"!

Delta define: #Counter as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 25, 2009 -> 21:58:36"!

Delta define: #Counter as: (
(Class subclassOf: 'Object' instanceVariables: 'count')) !


"June 25, 2009 -> 21:59:0"!

! (Delta mirrorFor: #Counter) methodsFor: 'initialization' !
initialize

	count := 0! !

"June 25, 2009 -> 21:59:31"!

! (Delta mirrorFor: #Counter) classSide methodsFor: 'instance creation' !
new

	^(super new)
		initialize;
		yourself! !

"June 25, 2009 -> 22:0:29"!

! (Delta mirrorFor: #Counter) methodsFor: 'updating' !
preinc

	^count := count + 1! !

"June 25, 2009 -> 22:1:12"!

! (Delta mirrorFor: #Counter) methodsFor: 'updating' !
postinc

	^[count] ensure: [count := count + 1]! !

"June 25, 2009 -> 22:4:23"!

! (Delta mirrorFor: #ExternalReadWriteStream) classSide methodsFor: 'testing' !
test
    "self test"
    |    file <FilePath>
        sz <Int>
        read <ExternalReadStream>
        write <ExternalReadWriteStream>
        in <CharInStream>
        out <CharOutStream>
        bytes <ByteArray>
        s <Str> 
        testCount <Counter>
        test <Integer> |
    testCount := Counter new.
    file := FilePath for: 'deltatest.tmp'.
    sz := 12345.    "make sure this number is much greater than the stream buffer size" 
    write := file writeStream.
    0 to: sz-1 do: 
        [ :i <Int> |
            write nextPut: i \\ 100.    ].
    self test: testCount preinc is: [ write size = sz ].
    write position: 5001.
    write nextPut: 123.
    write close.
    write := file readWriteStream.
    write position: 5000.
    write nextPut: 12.
    self test: testCount preinc is: [ write next = 123 ].
    write setToEnd.
    bytes := write contentsWritten.
    self test: testCount preinc is: [ Transcript show: 'actual: '; print: bytes size; show: ', expected: '; print: sz;cr. bytes size = sz ].
    write close.
    read := file readStream.
    self test: testCount preinc is: [ read peek = 0 ].
    self test: testCount preinc is: [ read size = sz ].
    test := testCount preinc.
    0 to: sz-1 do:
        [ :i <Int> |
            | byte <Int> |
            byte := read next.
            self test: 6 is:
                [ i ~= 5001
                    ifTrue: [ i ~= 5000
                                ifTrue: [ (i \\ 100) = byte ]
                                ifFalse: [ byte = 12 ]    ]
                    ifFalse: [ byte = 123 ]    ].
            self test: test is: [ (bytes at: i + 1) = byte ].    ].

    self test: testCount preinc is: [ read atEnd ].
    read position: 5001.

    self test: testCount preinc is: [ read next = 123 ].
    read position: 0.

    self test: testCount preinc is: [ bytes = read contentsRemaining ].
    read close.
    out := file charOutputStream.
    s := 'hi 
there'.
    out nextPutAll: s.
    out close.
    in := file charInputStream.

    self test: testCount preinc is: [ in peek = (s at: 1) ].

	test := testCount preinc.
    1 to: s size do: 
        [ :i <Int> |
            self test: 12 is: [
				| n |
				n := in next.
				(s at: i) =  n].    ].

    self test: testCount preinc is: [ in atEnd ].
    in close.
    in := file charInputStream.

    self test: testCount preinc is: [ in contentsRemaining = s ].
    in close.! !

"June 25, 2009 -> 22:5:32"!

"System saved" !
"June 25, 2009 -> 22:8:54"!

! (Delta mirrorFor: #ExternalReadWriteStream) classSide methodsFor: 'testing' !
test
    "self test"
    |    file <FilePath>
        sz <Int>
        read <ExternalReadStream>
        write <ExternalReadWriteStream>
        in <CharInStream>
        out <CharOutStream>
        bytes <ByteArray>
        s <Str> 
        testCount <Counter>
        test <Integer> |
    testCount := Counter new.
    file := FilePath for: 'deltatest.tmp'.
    sz := 12345.    "make sure this number is much greater than the stream buffer size" 
    write := file writeStream.
    0 to: sz-1 do: 
        [ :i <Int> |
            write nextPut: i \\ 100.    ].
    self test: testCount preinc is: [ write size = sz ].
    write position: 5001.
    write nextPut: 123.
    write close.
    write := file readWriteStream.
    write position: 5000.
    write nextPut: 12.
    self test: testCount preinc is: [ write next = 123 ].
    write setToEnd.
    bytes := write contentsWritten.
    self test: testCount preinc is: [ write atEnd ].
    self test: testCount preinc is: [ Transcript show: 'actual: '; print: bytes size; show: ', expected: '; print: sz;cr. bytes size = sz ].
    write close.
    read := file readStream.
    self test: testCount preinc is: [ read peek = 0 ].
    self test: testCount preinc is: [ read size = sz ].
    test := testCount preinc.
    0 to: sz-1 do:
        [ :i <Int> |
            | byte <Int> |
            byte := read next.
            self test: 6 is:
                [ i ~= 5001
                    ifTrue: [ i ~= 5000
                                ifTrue: [ (i \\ 100) = byte ]
                                ifFalse: [ byte = 12 ]    ]
                    ifFalse: [ byte = 123 ]    ].
            self test: test is: [ (bytes at: i + 1) = byte ].    ].

    self test: testCount preinc is: [ read atEnd ].
    read position: 5001.

    self test: testCount preinc is: [ read next = 123 ].
    read position: 0.

    self test: testCount preinc is: [ bytes = read contentsRemaining ].
    read close.
    out := file charOutputStream.
    s := 'hi 
there'.
    out nextPutAll: s.
    out close.
    in := file charInputStream.

    self test: testCount preinc is: [ in peek = (s at: 1) ].

	test := testCount preinc.
    1 to: s size do: 
        [ :i <Int> |
            self test: 12 is: [
				| n |
				n := in next.
				(s at: i) =  n].    ].

    self test: testCount preinc is: [ in atEnd ].
    in close.
    in := file charInputStream.

    self test: testCount preinc is: [ in contentsRemaining = s ].
    in close.! !

"June 25, 2009 -> 22:10:13"!

! (Delta mirrorFor: #ExternalReadWriteStream) classSide methodsFor: 'testing' !
test
    "self test"
    |    file <FilePath>
        sz <Int>
        read <ExternalReadStream>
        write <ExternalReadWriteStream>
        in <CharInStream>
        out <CharOutStream>
        bytes <ByteArray>
        s <Str> 
        testCount <Counter>
        test <Integer> |
    testCount := Counter new.
    file := FilePath for: 'deltatest.tmp'.
    sz := 12345.    "make sure this number is much greater than the stream buffer size" 
    write := file writeStream.
    0 to: sz-1 do: 
        [ :i <Int> |
            write nextPut: i \\ 100.    ].
    self test: testCount preinc is: [ write size = sz ].
    write position: 5001.
    write nextPut: 123.
    write close.
    write := file readWriteStream.
    write position: 5000.
    write nextPut: 12.
    self test: testCount preinc is: [ write next = 123 ].
    write setToEnd.
    write position: 0.
    self test: testCount preinc is: [ write position = 0 ].
    bytes := write contentsWritten.
    self test: testCount preinc is: [ write atEnd ].
    self test: testCount preinc is: [ Transcript show: 'actual: '; print: bytes size; show: ', expected: '; print: sz;cr. bytes size = sz ].
    write close.
    read := file readStream.
    self test: testCount preinc is: [ read peek = 0 ].
    self test: testCount preinc is: [ read size = sz ].
    test := testCount preinc.
    0 to: sz-1 do:
        [ :i <Int> |
            | byte <Int> |
            byte := read next.
            self test: 6 is:
                [ i ~= 5001
                    ifTrue: [ i ~= 5000
                                ifTrue: [ (i \\ 100) = byte ]
                                ifFalse: [ byte = 12 ]    ]
                    ifFalse: [ byte = 123 ]    ].
            self test: test is: [ (bytes at: i + 1) = byte ].    ].

    self test: testCount preinc is: [ read atEnd ].
    read position: 5001.

    self test: testCount preinc is: [ read next = 123 ].
    read position: 0.

    self test: testCount preinc is: [ bytes = read contentsRemaining ].
    read close.
    out := file charOutputStream.
    s := 'hi 
there'.
    out nextPutAll: s.
    out close.
    in := file charInputStream.

    self test: testCount preinc is: [ in peek = (s at: 1) ].

	test := testCount preinc.
    1 to: s size do: 
        [ :i <Int> |
            self test: 12 is: [
				| n |
				n := in next.
				(s at: i) =  n].    ].

    self test: testCount preinc is: [ in atEnd ].
    in close.
    in := file charInputStream.

    self test: testCount preinc is: [ in contentsRemaining = s ].
    in close.! !

"June 25, 2009 -> 22:14:40"!

! (Delta mirrorFor: #ExternalReadWriteStream) classSide methodsFor: 'testing' !
test
    "self test"
    |    file <FilePath>
        sz <Int>
        read <ExternalReadStream>
        write <ExternalReadWriteStream>
        in <CharInStream>
        out <CharOutStream>
        bytes <ByteArray>
        s <Str> 
        testCount <Counter>
        test <Integer> |
    testCount := Counter new.
    file := FilePath for: 'deltatest.tmp'.
    sz := 12345.    "make sure this number is much greater than the stream buffer size" 
    write := file writeStream.
    0 to: sz-1 do: 
        [ :i <Int> |
            write nextPut: i \\ 100 + 32.    ].
    self test: testCount preinc is: [ write size = sz ].
    write position: 5001.
    write nextPut: 123.
    write close.
    write := file readWriteStream.
    write position: 5000.
    write nextPut: 12.
    self test: testCount preinc is: [ write next = 123 ].
    write setToEnd.
    write position: 0.
    self test: testCount preinc is: [ write position = 0 ].
    bytes := write contentsWritten.
    self test: testCount preinc is: [ write atEnd ].
    self test: testCount preinc is: [ Transcript show: 'actual: '; print: bytes size; show: ', expected: '; print: sz;cr. bytes size = sz ].
    write close.
    read := file readStream.
    self test: testCount preinc is: [ read peek = 0 ].
    self test: testCount preinc is: [ read size = sz ].
    test := testCount preinc.
    0 to: sz-1 do:
        [ :i <Int> |
            | byte <Int> |
            byte := read next.
            self test: 6 is:
                [ i ~= 5001
                    ifTrue: [ i ~= 5000
                                ifTrue: [ (i \\ 100) = byte ]
                                ifFalse: [ byte = 12 ]    ]
                    ifFalse: [ byte = 123 ]    ].
            self test: test is: [ (bytes at: i + 1) = byte ].    ].

    self test: testCount preinc is: [ read atEnd ].
    read position: 5001.

    self test: testCount preinc is: [ read next = 123 ].
    read position: 0.

    self test: testCount preinc is: [ bytes = read contentsRemaining ].
    read close.
    out := file charOutputStream.
    s := 'hi 
there'.
    out nextPutAll: s.
    out close.
    in := file charInputStream.

    self test: testCount preinc is: [ in peek = (s at: 1) ].

	test := testCount preinc.
    1 to: s size do: 
        [ :i <Int> |
            self test: 12 is: [
				| n |
				n := in next.
				(s at: i) =  n].    ].

    self test: testCount preinc is: [ in atEnd ].
    in close.
    in := file charInputStream.

    self test: testCount preinc is: [ in contentsRemaining = s ].
    in close.! !

"June 25, 2009 -> 22:16:55"!

"System saved" !
"June 25, 2009 -> 22:18:9"!

! (Delta mirrorFor: #ExternalReadWriteStream) classSide methodsFor: 'testing' !
test
    "self test"
    |    file <FilePath>
        sz <Int>
        read <ExternalReadStream>
        write <ExternalReadWriteStream>
        in <CharInStream>
        out <CharOutStream>
        bytes <ByteArray>
        s <Str> 
        testCount <Counter>
        test <Integer> |
    testCount := Counter new.
    file := FilePath for: 'deltatest.tmp'.
    sz := 12345.    "make sure this number is much greater than the stream buffer size" 
    write := file writeStream.
    0 to: sz-1 do: 
        [ :i <Int> |
            write nextPut: i \\ 100 + 32.    ].
    self test: testCount preinc is: [ write size = sz ].
    write position: 5001.
    write nextPut: 123.
    write close.
    write := file readWriteStream.
    write position: 5000.
    write nextPut: 12.
    self test: testCount preinc is: [ write next = 123 ].
    write setToEnd.
    write position: 0.
    self test: testCount preinc is: [ write position = 0 ].
    bytes := write contentsWritten.
    "self test: testCount preinc is: [ write atEnd ]."
    self test: testCount preinc is: [ Transcript show: 'actual: '; print: bytes size; show: ', expected: '; print: sz;cr. bytes size = sz ].
    write close.
    read := file readStream.
    self test: testCount preinc is: [ read peek = 0 ].
    self test: testCount preinc is: [ read size = sz ].
    test := testCount preinc.
    0 to: sz-1 do:
        [ :i <Int> |
            | byte <Int> |
            byte := read next.
            self test: 6 is:
                [ i ~= 5001
                    ifTrue: [ i ~= 5000
                                ifTrue: [ (i \\ 100) = byte ]
                                ifFalse: [ byte = 12 ]    ]
                    ifFalse: [ byte = 123 ]    ].
            self test: test is: [ (bytes at: i + 1) = byte ].    ].

    self test: testCount preinc is: [ read atEnd ].
    read position: 5001.

    self test: testCount preinc is: [ read next = 123 ].
    read position: 0.

    self test: testCount preinc is: [ bytes = read contentsRemaining ].
    read close.
    out := file charOutputStream.
    s := 'hi 
there'.
    out nextPutAll: s.
    out close.
    in := file charInputStream.

    self test: testCount preinc is: [ in peek = (s at: 1) ].

	test := testCount preinc.
    1 to: s size do: 
        [ :i <Int> |
            self test: 12 is: [
				| n |
				n := in next.
				(s at: i) =  n].    ].

    self test: testCount preinc is: [ in atEnd ].
    in close.
    in := file charInputStream.

    self test: testCount preinc is: [ in contentsRemaining = s ].
    in close.! !

"June 25, 2009 -> 22:18:24"!

"System saved" !
"June 25, 2009 -> 22:21:22"!

! (Delta mirrorFor: #ExternalReadWriteStream) classSide methodsFor: 'testing' !
test
    "self test"
    |    file <FilePath>
        sz <Int>
        read <ExternalReadStream>
        write <ExternalReadWriteStream>
        in <CharInStream>
        out <CharOutStream>
        bytes <ByteArray>
        s <Str> 
        testCount <Counter>
        test <Integer> |
    testCount := Counter new.
    file := FilePath for: 'deltatest.tmp'.
    sz := 12345.    "make sure this number is much greater than the stream buffer size" 
    write := file writeStream.
    0 to: sz-1 do: 
        [ :i <Int> |
            write nextPut: i \\ 100 + 32.    ].
    self test: testCount preinc is: [ write size = sz ].
    write position: 5001.
    write nextPut: 123.
    write close.
    write := file readWriteStream.
    write position: 5000.
    write nextPut: 12.
    self test: testCount preinc is: [ write next = 123 ].
    write position: 0.
    self test: testCount preinc is: [ write position = 0 ].
    write setToEnd.
    bytes := write contentsWritten.
    "self test: testCount preinc is: [ write atEnd ]."
    self test: testCount preinc is: [ Transcript show: 'actual: '; print: bytes size; show: ', expected: '; print: sz;cr. bytes size = sz ].
    write close.
    read := file readStream.
    self test: testCount preinc is: [ read peek = 0 ].
    self test: testCount preinc is: [ read size = sz ].
    test := testCount preinc.
    0 to: sz-1 do:
        [ :i <Int> |
            | byte <Int> |
            byte := read next.
            self test: 6 is:
                [ i ~= 5001
                    ifTrue: [ i ~= 5000
                                ifTrue: [ (i \\ 100) = byte ]
                                ifFalse: [ byte = 12 ]    ]
                    ifFalse: [ byte = 123 ]    ].
            self test: test is: [ (bytes at: i + 1) = byte ].    ].

    self test: testCount preinc is: [ read atEnd ].
    read position: 5001.

    self test: testCount preinc is: [ read next = 123 ].
    read position: 0.

    self test: testCount preinc is: [ bytes = read contentsRemaining ].
    read close.
    out := file charOutputStream.
    s := 'hi 
there'.
    out nextPutAll: s.
    out close.
    in := file charInputStream.

    self test: testCount preinc is: [ in peek = (s at: 1) ].

	test := testCount preinc.
    1 to: s size do: 
        [ :i <Int> |
            self test: 12 is: [
				| n |
				n := in next.
				(s at: i) =  n].    ].

    self test: testCount preinc is: [ in atEnd ].
    in close.
    in := file charInputStream.

    self test: testCount preinc is: [ in contentsRemaining = s ].
    in close.! !

"June 25, 2009 -> 22:21:27"!

"System saved" !
"June 25, 2009 -> 22:22:51"!

! (Delta mirrorFor: #ExternalReadWriteStream) classSide methodsFor: 'testing' !
test
    "ExternalReadWriteStream test"
    |    file <FilePath>
        sz <Int>
        read <ExternalReadStream>
        write <ExternalReadWriteStream>
        in <CharInStream>
        out <CharOutStream>
        bytes <ByteArray>
        s <Str> 
        testCount <Counter>
        test <Integer> |
    testCount := Counter new.
    file := FilePath for: 'deltatest.tmp'.
    sz := 12345.    "make sure this number is much greater than the stream buffer size" 
    write := file writeStream.
    0 to: sz-1 do: 
        [ :i <Int> |
            write nextPut: i \\ 100 + 32.    ].
    self test: testCount preinc is: [ write size = sz ].
    write position: 5001.
    write nextPut: 123.
    write close.
    write := file readWriteStream.
    write position: 5000.
    write nextPut: 12.
    self test: testCount preinc is: [ write next = 123 ].
    write position: 0.
    self test: testCount preinc is: [ write position = 0 ].
    write setToEnd.
    bytes := write contentsWritten.
    "self test: testCount preinc is: [ write atEnd ]."
    self test: testCount preinc is: [ Transcript show: 'actual: '; print: bytes size; show: ', expected: '; print: sz;cr. bytes size = sz ].
    write close.
    read := file readStream.
    self test: testCount preinc is: [ read peek = 0 ].
    self test: testCount preinc is: [ read size = sz ].
    test := testCount preinc.
    0 to: sz-1 do:
        [ :i <Int> |
            | byte <Int> |
            byte := read next.
            self test: 6 is:
                [ i ~= 5001
                    ifTrue: [ i ~= 5000
                                ifTrue: [ (i \\ 100) = byte ]
                                ifFalse: [ byte = 12 ]    ]
                    ifFalse: [ byte = 123 ]    ].
            self test: test is: [ (bytes at: i + 1) = byte ].    ].

    self test: testCount preinc is: [ read atEnd ].
    read position: 5001.

    self test: testCount preinc is: [ read next = 123 ].
    read position: 0.

    self test: testCount preinc is: [ bytes = read contentsRemaining ].
    read close.
    out := file charOutputStream.
    s := 'hi 
there'.
    out nextPutAll: s.
    out close.
    in := file charInputStream.

    self test: testCount preinc is: [ in peek = (s at: 1) ].

	test := testCount preinc.
    1 to: s size do: 
        [ :i <Int> |
            self test: 12 is: [
				| n |
				n := in next.
				(s at: i) =  n].    ].

    self test: testCount preinc is: [ in atEnd ].
    in close.
    in := file charInputStream.

    self test: testCount preinc is: [ in contentsRemaining = s ].
    in close.! !

"June 25, 2009 -> 22:23:3"!

! (Delta mirrorFor: #ExternalReadWriteStream) classSide methodsFor: 'testing' !
test
    " ExternalReadWriteStream test "
    |    file <FilePath>
        sz <Int>
        read <ExternalReadStream>
        write <ExternalReadWriteStream>
        in <CharInStream>
        out <CharOutStream>
        bytes <ByteArray>
        s <Str> 
        testCount <Counter>
        test <Integer> |
    testCount := Counter new.
    file := FilePath for: 'deltatest.tmp'.
    sz := 12345.    "make sure this number is much greater than the stream buffer size" 
    write := file writeStream.
    0 to: sz-1 do: 
        [ :i <Int> |
            write nextPut: i \\ 100 + 32.    ].
    self test: testCount preinc is: [ write size = sz ].
    write position: 5001.
    write nextPut: 123.
    write close.
    write := file readWriteStream.
    write position: 5000.
    write nextPut: 12.
    self test: testCount preinc is: [ write next = 123 ].
    write position: 0.
    self test: testCount preinc is: [ write position = 0 ].
    write setToEnd.
    bytes := write contentsWritten.
    "self test: testCount preinc is: [ write atEnd ]."
    self test: testCount preinc is: [ Transcript show: 'actual: '; print: bytes size; show: ', expected: '; print: sz;cr. bytes size = sz ].
    write close.
    read := file readStream.
    self test: testCount preinc is: [ read peek = 0 ].
    self test: testCount preinc is: [ read size = sz ].
    test := testCount preinc.
    0 to: sz-1 do:
        [ :i <Int> |
            | byte <Int> |
            byte := read next.
            self test: 6 is:
                [ i ~= 5001
                    ifTrue: [ i ~= 5000
                                ifTrue: [ (i \\ 100) = byte ]
                                ifFalse: [ byte = 12 ]    ]
                    ifFalse: [ byte = 123 ]    ].
            self test: test is: [ (bytes at: i + 1) = byte ].    ].

    self test: testCount preinc is: [ read atEnd ].
    read position: 5001.

    self test: testCount preinc is: [ read next = 123 ].
    read position: 0.

    self test: testCount preinc is: [ bytes = read contentsRemaining ].
    read close.
    out := file charOutputStream.
    s := 'hi 
there'.
    out nextPutAll: s.
    out close.
    in := file charInputStream.

    self test: testCount preinc is: [ in peek = (s at: 1) ].

	test := testCount preinc.
    1 to: s size do: 
        [ :i <Int> |
            self test: 12 is: [
				| n |
				n := in next.
				(s at: i) =  n].    ].

    self test: testCount preinc is: [ in atEnd ].
    in close.
    in := file charInputStream.

    self test: testCount preinc is: [ in contentsRemaining = s ].
    in close.! !

"June 25, 2009 -> 22:24:59"!

! (Delta mirrorFor: #ExternalReadWriteStream) classSide methodsFor: 'testing' !
test
    " ExternalReadWriteStream test "
    |    file <FilePath>
        sz <Int>
        read <ExternalReadStream>
        write <ExternalReadWriteStream>
        in <CharInStream>
        out <CharOutStream>
        bytes <ByteArray>
        s <Str> 
        testCount <Counter>
        test <Integer> |
    testCount := Counter new.
    file := FilePath for: 'deltatest.tmp'.
    sz := 12345.    "make sure this number is much greater than the stream buffer size" 
    write := file writeStream.
    0 to: sz-1 do: 
        [ :i <Int> |
            write nextPut: i \\ 100 + 32.    ].
    self test: testCount preinc is: [ write size = sz ].
    write position: 5001.
    write nextPut: 123.
    write close.
    write := file readWriteStream.
    write position: 5000.
    write nextPut: 12.
    self test: testCount preinc is: [ write next = 123 ].
    write position: 0.
    self test: testCount preinc is: [ write position = 0 ].
    write setToEnd.
    bytes := write contentsWritten.
    "self test: testCount preinc is: [ write atEnd ]."
    self test: testCount preinc is: [ Transcript show: 'actual: '; print: bytes size; show: ', expected: '; print: sz;cr. bytes size = sz ].
    write close.
    read := file readStream.
    self test: testCount preinc is: [ read peek = 32 ].
    self test: testCount preinc is: [ read size = sz ].
    test := testCount preinc.
    0 to: sz-1 do:
        [ :i <Int> |
            | byte <Int> |
            byte := read next.
            self test: 6 is:
                [ i ~= 5001
                    ifTrue: [ i ~= 5000
                                ifTrue: [ (i \\ 100 +32) = byte ]
                                ifFalse: [ byte = 12 ]    ]
                    ifFalse: [ byte = 123 ]    ].
            self test: test is: [ (bytes at: i + 1) = byte ].    ].

    self test: testCount preinc is: [ read atEnd ].
    read position: 5001.

    self test: testCount preinc is: [ read next = 123 ].
    read position: 0.

    self test: testCount preinc is: [ bytes = read contentsRemaining ].
    read close.
    out := file charOutputStream.
    s := 'hi 
there'.
    out nextPutAll: s.
    out close.
    in := file charInputStream.

    self test: testCount preinc is: [ in peek = (s at: 1) ].

	test := testCount preinc.
    1 to: s size do: 
        [ :i <Int> |
            self test: test is: [
				| n |
				n := in next.
				(s at: i) =  n].    ].

    self test: testCount preinc is: [ in atEnd ].
    in close.
    in := file charInputStream.

    self test: testCount preinc is: [ in contentsRemaining = s ].
    in close.! !

"June 25, 2009 -> 22:25:6"!

"System saved" !
"June 27, 2009 -> 1:7:0"!

Delta define: #TextTestRunner as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 27, 2009 -> 1:7:0"!

! (Delta mirrorFor: #TextTestRunner) classSide methodsFor: 'instance creation' !
runAll

	| runner suite |
	runner := self new.
	suite := TestCase buildSuite.
	suite addDependent: runner.
	suite run
	! !

"June 27, 2009 -> 1:7:0"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Running' !
run: aResult 
	self tests do: [:each | 
		self sunitChanged: each with: aResult.
		Processor yield.
		each run: aResult]
			! !

"June 27, 2009 -> 1:7:0"!

! (Delta mirrorFor: #Object) methodsFor: 'Camp Smalltalk' !
sunitChanged: anAspect with: value
 
        self changed: anAspect with: value! !

"June 27, 2009 -> 1:7:0"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Running' !
run: aResult 
	self tests do: [:each | 
		Processor yield.
		each run: aResult.
		self sunitChanged: each with: aResult]
			! !

"June 27, 2009 -> 1:7:0"!

! (Delta mirrorFor: #TextTestRunner) classSide methodsFor: 'instance creation' !
runAll

	| runner suite result |
	runner := self new.
	suite := TestCase buildSuite.
	suite addDependent: runner.
	result := suite run.
	Transcript cr;
		print: result! !

"June 27, 2009 -> 1:7:0"!

! (Delta mirrorFor: #TextTestRunner) methodsFor: 'notifications' !
update: test with: result

	(result isFailure: test)
		ifTrue: [ Transcript print: test; show: ' failed'; cr].
	(result isError: test)
		ifTrue: [ Transcript print: test; show: ' error'; cr]! !

"June 27, 2009 -> 1:7:0"!

! (Delta mirrorFor: #BecomeTest) methodsFor: 'testing' !
testFail

	self fail! !

"June 27, 2009 -> 1:7:0"!

! (Delta mirrorFor: #TextTestRunner) methodsFor: 'notifications' !
update: test with: result
Transcript print: test.
	(result isFailure: test)
		ifTrue: [ Transcript print: test; show: ' failed'; cr].
	(result isError: test)
		ifTrue: [ Transcript print: test; show: ' error'; cr]! !

"June 27, 2009 -> 1:7:0"!

! (Delta mirrorFor: #TextTestRunner) classSide methodsFor: 'instance creation' !
runAll

	| runner suite result |
	runner := self new.
	suite := TestCase buildSuite.
	suite addDependentToHierarch: runner.
	result := suite run.
	Transcript cr;
		print: result! !

"June 27, 2009 -> 1:7:0"!

! (Delta mirrorFor: #TextTestRunner) methodsFor: 'notifications' !
update: test with: result

	(result isFailure: test)
		ifTrue: [ Transcript print: test; show: ' failed'; cr].
	(result isError: test)
		ifTrue: [ Transcript print: test; show: ' error'; cr]! !

"June 27, 2009 -> 1:7:0"!

! (Delta mirrorFor: #TextTestRunner) classSide methodsFor: 'instance creation' !
runAll

	| runner suite result |
	runner := self new.
	suite := TestCase buildSuite.
	suite addDependentToHierarchy: runner.
	result := suite run.
	Transcript cr;
		print: result! !

"June 27, 2009 -> 1:7:0"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Dependencies' !
addDependentToHierarchy: anObject
	self sunitAddDependent: anObject.
	self tests do: [ :each | each addDependentToHierarchy: anObject]
			! !

"June 27, 2009 -> 1:7:0"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Dependencies' !
removeDependentFromHierarchy: anObject
	self sunitRemoveDependent: anObject.
	self tests do: [ :each | each removeDependentFromHierarchy: anObject]
			! !

"June 27, 2009 -> 1:7:0"!

(Delta mirrorFor: #TestSuite) removeMethod: #removeDependentFromHierachy: ifAbsent: [] !


"June 27, 2009 -> 1:7:1"!

(Delta mirrorFor: #TestSuite) removeMethod: #addDependentToHierachy: ifAbsent: [] !


"June 27, 2009 -> 1:7:1"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Dependencies' !
removeDependentFromHierarchy: anObject 
	"an empty method. for Composite compability with TestSuite"


			! !

"June 27, 2009 -> 1:7:1"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Dependencies' !
addDependentToHierarchy: anObject 
	"an empty method. for Composite compability with TestSuite"


			! !

"June 27, 2009 -> 1:7:1"!

(Delta mirrorFor: #TestCase) removeMethod: #addDependentToHierachy: ifAbsent: [] !


"June 27, 2009 -> 1:7:1"!

(Delta mirrorFor: #TestCase) removeMethod: #removeDependentFromHierachy: ifAbsent: [] !


"June 27, 2009 -> 1:7:1"!

! (Delta mirrorFor: #BecomeTest) methodsFor: 'testing' !
testFail

	self assert: false! !

"June 27, 2009 -> 1:7:1"!

! (Delta mirrorFor: #TextTestRunner) classSide methodsFor: 'instance creation' !
runAll

	| runner suite result |
	runner := self new.
	suite := TestCase buildSuite.
	suite addDependentToHierarchy: runner.
	Transcript cr.
	result := suite run.
	Transcript cr;
		print: result! !

"June 27, 2009 -> 1:7:1"!

(Delta mirrorFor: #BecomeTest) removeMethod: #testFail ifAbsent: [] !


"June 27, 2009 -> 1:7:1"!

! (Delta mirrorFor: #BecomeTest) methodsFor: 'testing' !
testFail

	self assert: false description: 'failure message'! !

"June 27, 2009 -> 1:7:1"!

! (Delta mirrorFor: #TextTestRunner) methodsFor: 'notifications' !
update: test with: result

	(result isFailure: test)
		ifTrue: [ Transcript space; print: test; show: ' failed'; cr].
	(result isError: test)
		ifTrue: [ Transcript space; print: test; show: ' error'; cr]! !

"June 27, 2009 -> 1:7:1"!

(Delta mirrorFor: #BecomeTest) removeMethod: #testFail ifAbsent: [] !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file <FilePath>
write <ReadWriteStream>')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file <FilePath>
write <ReadWriteStream>')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file <FilePath>
write <ReadWriteStream>')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file <FilePath>
write <ReadWriteStream>')) !


"June 27, 2009 -> 1:7:1"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'running' !
tearDown

	write ifNotNil: [write close].
	file delete! !

"June 27, 2009 -> 1:7:1"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'running' !
setUp

	file := FilePath for: 'deltatest.tmp'.
	write := file writeStream! !

"June 27, 2009 -> 1:7:1"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'running' !
tearDown

	write isNil ifFalse: [write close].
	file delete! !

"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file <FilePath>
write <ReadWriteStream>')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file <FilePath>
write <ReadWriteStream>')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file <FilePath>
write <ReadWriteStream>')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file <FilePath>
write <ReadWriteStream>')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file <FilePath>
write <ReadWriteStream>')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file <FilePath>
write <ReadWriteStream>')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file <FilePath>
write <ReadWriteStream>')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file		<FilePath>
write		<ReadWriteStream>
sz			<Integer>')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file		<FilePath>
write		<ReadWriteStream>
sz			<Integer>')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file		<FilePath>
write		<ReadWriteStream>
sz			<Integer>')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file		<FilePath>
write		<ReadWriteStream>
sz			<Integer>')) !


"June 27, 2009 -> 1:7:1"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testWrittenFileShouldHaveCorrectSize

	0 to: sz-1 do: 
        [ :i <Int> |
            write nextPut: i \\ 100 + 32.    ].
    self should: [ write size = sz ]
    	description: 'Wrong size ', write size printString.! !

"June 27, 2009 -> 1:7:1"!

! (Delta mirrorFor: #TextTestRunner) methodsFor: 'notifications' !
update: test with: result

	(result isFailure: test)
		ifTrue: [ Transcript space; print: test; show: ' failed'; cr].
	(result isError: test)
		ifTrue: [ Transcript print: test; show: ' error'; cr]! !

"June 27, 2009 -> 1:7:1"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[[aTestCase runCase.
			true]
				sunitOn: self class failure
				do: [:signal |
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
							self halt.
									self errors add: aTestCase.
									signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"June 27, 2009 -> 1:7:1"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'running' !
setUp

    file := FilePath for: 'deltatest.tmp'.
    sz := 12345.    "make sure this number is much greater than the stream buffer size" 
    write := file writeStream.! !

"June 27, 2009 -> 1:7:1"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[[aTestCase runCase.
			true]
				sunitOn: self class failure
				do: [:signal |
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
							"self halt."
									self errors add: aTestCase.
									signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"June 27, 2009 -> 1:7:1"!

! (Delta mirrorFor: #TextTestRunner) classSide methodsFor: 'instance creation' !
run: suite

	| runner result |
	runner := self new.
	suite addDependentToHierarchy: runner.
	Transcript cr.
	result := suite run.
	Transcript cr;
		print: result! !

"June 27, 2009 -> 1:7:1"!

! (Delta mirrorFor: #TextTestRunner) classSide methodsFor: 'instance creation' !
runAll

	self run: TestCase buildSuite! !

"June 27, 2009 -> 1:7:1"!

! (Delta mirrorFor: #TextTestRunner) classSide methodsFor: 'instance creation' !
run: suite

	| runner result |
	runner := self new.
	suite addDependentToHierarchy: runner.
	[Transcript cr.
	result := suite run.
	Transcript cr;
		print: result]
			ensure: [suite removeDependentFromHierarchy: runner]! !

"June 27, 2009 -> 1:7:1"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'running' !
setUp

    file := FilePath for: 'deltatest.tmp'.
    sz := 12345.    "make sure this number is much greater than the stream buffer size" 
    write := file writeStream.
	0 to: sz-1 do: 
        [ :i <Int> |
            write nextPut: i \\ 100 + 32]! !

"June 27, 2009 -> 1:7:1"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testWrittenFileShouldHaveCorrectSize

    self should: [ write size = sz ]
    	description: 'Wrong size ', write size printString.! !

"June 27, 2009 -> 1:7:1"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testModifyingWrittenFileShouldUpdateContents

	| byte |
    write position: 5001.
    write nextPut: 123.
    write close.
    write := file readWriteStream.
    write position: 5000.
    write nextPut: 12.
    byte := write next.
    self should: [ byte = 123 ]
    	description: 'Wrong byte value: ', byte printString.! !

"June 27, 2009 -> 1:7:1"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testContentsWrittenShouldReturnCorrectlySizedCollection

	| bytes |
	write setToEnd.
    bytes := write contentsWritten.

    self should: [ bytes size = sz ]
    	description: 'Wrong byte count: ', bytes size printString! !

"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file		<FilePath>
write		<ReadWriteStream>
sz			<Integer>')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file		<FilePath>
write		<ReadWriteStream>
sz			<Integer>')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file		<FilePath>
write		<ReadWriteStream>
sz			<Integer>')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file		<FilePath>
write		<ReadWriteStream>
sz			<Integer>')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file		<FilePath>
write		<ReadWriteStream>
sz			<Integer>')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file		<FilePath>
write		<ReadWriteStream>
sz			<Integer>')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file		<FilePath>
write		<ReadWriteStream>
sz			<Integer>')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file		<FilePath>
write		<ReadWriteStream>
read		<ReadStream>
sz			<Integer>')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file		<FilePath>
write		<ReadWriteStream>
read		<ReadStream>
sz			<Integer>')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file		<FilePath>
write		<ReadWriteStream>
read		<ReadStream>
sz			<Integer>')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file		<FilePath>
write		<ReadWriteStream>
read		<ReadStream>
sz			<Integer>')) !


"June 27, 2009 -> 1:7:1"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'running' !
tearDown

	write isNil ifFalse: [write close].
	read isNil ifFalse: [read close].
	file delete! !

"June 27, 2009 -> 1:7:1"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testPeekShouldReturnCorrectByte

	| byte |
	write close.
    read := file readStream.
    byte := read peek.
    self should: [ byte = 32 ]
    	description: 'Wrong byte: ', byte printString! !

"June 27, 2009 -> 1:7:10"!

"System saved" !
"June 27, 2009 -> 1:19:50"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'running' !
close: stream

	stream isNil ifTrue: [^self].
	stream isClosed ifTrue: [^self].
	stream close! !

"June 27, 2009 -> 1:20:14"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'running' !
tearDown

	self close: write.
	self close: read.
	file delete! !

"June 27, 2009 -> 1:23:36"!

! (Delta mirrorFor: #ExternalStream) methodsFor: 'testing' !
isClosed

	^self descriptor isClosed! !

"June 27, 2009 -> 1:26:38"!

! (Delta mirrorFor: #ExternalStream) methodsFor: 'testing' !
isClosed

	^self descriptor isNil or: [self descriptor isClosed]! !

"June 27, 2009 -> 1:28:12"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[[aTestCase runCase.
			true]
				sunitOn: self class failure
				do: [:signal |
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
							self halt.
									self errors add: aTestCase.
									signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"June 27, 2009 -> 1:29:5"!

"System saved" !
"June 27, 2009 -> 1:32:1"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testReadStreamShouldHaveCorrectSize

	| size |
	write close.
    read := file readStream.
    size := read size.
    self should: [ size = sz ]
    	description: 'Wrong size: ', size printString! !

"June 27, 2009 -> 1:35:53"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testReadStreamShouldHaveCorrectContents

	| size |
	write close.
    read := file readStream.
    0 to: sz-1 do:
        [ :i <Int> |
            | byte <Int> |
            byte := read next.
            self should: [ (i \\ 100 +32) = byte ]
            	description: 'Wrong byte: ', byte printString, ' at index: ', i printString]! !

"June 27, 2009 -> 1:38:1"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testContentsWrittenShouldMatchReadStreamContents

	| size bytes |
	write setAtEnd.
	bytes := write contentsWritten.
	write close.
    read := file readStream.
    0 to: sz-1 do:
        [ :i <Int> |
            | byte <Int> |
            byte := read next.
            self should: [ (bytes at: i + 1) = byte ]
            	description: 'Wrong byte: ', (bytes at: i + 1) printString, ' at index: ', i printString]! !

"June 27, 2009 -> 1:38:43"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testContentsWrittenShouldMatchReadStreamContents

	| size bytes |
	write setToEnd.
	bytes := write contentsWritten.
	write close.
    read := file readStream.
    0 to: sz-1 do:
        [ :i <Int> |
            | byte <Int> |
            byte := read next.
            self should: [ (bytes at: i + 1) = byte ]
            	description: 'Wrong byte: ', (bytes at: i + 1) printString, ' at index: ', i printString]! !

"June 27, 2009 -> 1:39:48"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testContentsWrittenShouldMatchReadStreamContents

	| size bytes |
	write setToEnd.
	bytes := write contentsWritten.
	write close.
    read := file readStream.
    0 to: sz-1 do:
        [ :i <Int> |
            | byte <Int> |
            byte := read next.
            self should: [ (bytes at: i + 1) = byte ]
            	description: 'Wrong byte: ', (bytes at: i + 1) printString, ' at index: ', i printString].
    self should: [ read atEnd] description: 'Read stream should be at end'! !

"June 27, 2009 -> 1:44:36"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testModifyingWrittenFileShouldUpdateContents

	| byte |
    write position: 5001.
    write nextPut: 123.
    write close.
    write := file readWriteStream.
    write position: 5000.
    write nextPut: 12.
    byte := write next.
    self assert: byte = 123 description: 'Wrong write byte value: ', byte printString.
    write close.

    read := file readStream.
    read position: 5001.
    byte := read next.
    self assert: byte = 123 description: 'Wrong read byte value: ', byte printString! !

"June 27, 2009 -> 1:47:10"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testContentsWrittenShouldMatchReadStreamContents

	| size bytes |
	write setToEnd.
	bytes := write contentsWritten.
	write close.
    read := file readStream.
    0 to: sz-1 do:
        [ :i <Int> |
            | byte <Int> |
            byte := read next.
            self should: [ (bytes at: i + 1) = byte ]
            	description: 'Wrong byte: ', (bytes at: i + 1) printString, ' at index: ', i printString].
    self should: [ read atEnd] description: 'Read stream should be at end'.
    read position: 0.
    self assert: bytes = read contentsRemaining description: 'Invalid contentsRemaining'! !

"June 27, 2009 -> 1:48:21"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file		<FilePath>
write		<ReadWriteStream>
read		<ReadStream>
sz			<Integer>
out		<CharOutputStream>')) !


"June 27, 2009 -> 1:49:22"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file		<FilePath>
write		<ReadWriteStream>
read		<ReadStream>
sz			<Integer>
out		<CharOutputStream>
in			<CharInputStream>')) !


"June 27, 2009 -> 1:50:14"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file			<FilePath>
write			<ReadWriteStream>
read			<ReadStream>
sz				<Integer>
charFile	<FilePath>
out			<CharOutputStream>
in				<CharInputStream>')) !


"June 27, 2009 -> 1:52:40"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file			<FilePath>
write			<ReadWriteStream>
read			<ReadStream>
sz				<Integer>
charFile	<FilePath>
in				<CharInputStream>
s				<ReadString>')) !


"June 27, 2009 -> 1:53:9"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'running' !
setUp

	| out	<CharOutputStream> |
    file := FilePath for: 'deltatest.tmp'.
    charFile := FilePath for: 'deltatest2.tmp'.
    
    sz := 12345.    "make sure this number is much greater than the stream buffer size" 
    write := file writeStream.
	0 to: sz-1 do: 
        [ :i <Int> |
            write nextPut: i \\ 100 + 32].

	out := charFile charOutputStream.
    s := 'hi 
there'.
    out nextPutAll: s.
    out close.
    in := file charInputStream! !

"June 27, 2009 -> 1:53:11"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'running' !
tearDown

	self close: write.
	self close: read.
	self close: in.
	file delete.
	charFile delete! !

"June 27, 2009 -> 1:55:8"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testPeekShouldReturnFirstCharacter

	| char |
	char := in peek.
	self assert: char = (s at: 1)
		description: 'Wrong character: ', char printString! !

"June 27, 2009 -> 1:55:44"!

"System saved" !
"June 27, 2009 -> 1:56:42"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'running' !
setUp

	| out	<CharOutputStream> |
    file := FilePath for: 'deltatest.tmp'.
    charFile := FilePath for: 'deltatest2.tmp'.
    
    sz := 12345.    "make sure this number is much greater than the stream buffer size" 
    write := file writeStream.
	0 to: sz-1 do: 
        [ :i <Int> |
            write nextPut: i \\ 100 + 32].

	out := charFile charOutputStream.
    s := 'hi 
there'.
    out nextPutAll: s.
    out close.
    in := charFile charInputStream! !

"June 27, 2009 -> 1:57:47"!

"System saved" !
"June 27, 2009 -> 1:59:21"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'running' !
tearDown

	self close: write.
	self close: read.
	in close.
	file delete.
	charFile delete! !

"June 27, 2009 -> 2:1:12"!

"System saved" !
"June 27, 2009 -> 2:4:33"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testCharStreamShouldHaveCorrectContents

	1 to: s size do: 
        [ :i <Int> |
            | n |
			n := in next.
            self assert: (s at: i) =  n
            	description: 'Wrong character: ', n printString, ' at index: ', i printString]! !

"June 27, 2009 -> 2:5:24"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testCharStreamShouldHaveCorrectContents

	1 to: s size do: 
        [ :i <Int> |
            | n |
			n := in next.
            self assert: (s at: i) =  n
            	description: 'Wrong character: ', n printString, ' at index: ', i printString].
     self assert: in atEnd description: 'Character stream should be exhausted'! !

"June 27, 2009 -> 2:5:55"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testCharStreamShouldHaveCorrectContents

	1 to: s size do: 
        [ :i <Int> |
            | n |
			n := in next.
            self assert: (s at: i) =  n
            	description: 'Wrong character: ', n printString, ' at index: ', i printString].
    self assert: in atEnd description: 'Character stream should be exhausted'! !

"June 27, 2009 -> 2:7:54"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testCharStreamContentsRemainingShouldHaveCorrectContents

	| contents |
	contents := in contentsRemaining.
	self assert: contents = s description: 'Wrong contents: ', contents! !

"June 27, 2009 -> 2:8:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[[aTestCase runCase.
			true]
				sunitOn: self class failure
				do: [:signal |
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
							"self halt."
									self errors add: aTestCase.
									signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"June 27, 2009 -> 2:9:43"!

"System saved" !
"June 27, 2009 -> 11:59:59"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testWrittenFileShouldHaveCorrectSize
"
    self should: [ write size = sz ]
    	description: 'Wrong size ', write size printString.
    	"! !

"June 27, 2009 -> 12:0:0"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testReadStreamShouldHaveCorrectSize
"
	| size |
	write close.
    read := file readStream.
    size := read size.
    self should: [ size = sz ]
    	description: 'Wrong size: ', size printString
    	"! !

"June 27, 2009 -> 12:0:2"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testReadStreamShouldHaveCorrectContents
"
	| size |
	write close.
    read := file readStream.
    0 to: sz-1 do:
        [ :i <Int> |
            | byte <Int> |
            byte := read next.
            self should: [ (i \\ 100 +32) = byte ]
            	description: 'Wrong byte: ', byte printString, ' at index: ', i printString]
            	"! !

"June 27, 2009 -> 12:0:3"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testPeekShouldReturnFirstCharacter
"
	| char |
	char := in peek.
	self assert: char = (s at: 1)
		description: 'Wrong character: ', char printString
		"! !

"June 27, 2009 -> 12:0:5"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testPeekShouldReturnCorrectByte
"
	| byte |
	write close.
    read := file readStream.
    byte := read peek.
    self should: [ byte = 32 ]
    	description: 'Wrong byte: ', byte printString"! !

"June 27, 2009 -> 12:0:7"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testModifyingWrittenFileShouldUpdateContents
"
	| byte |
    write position: 5001.
    write nextPut: 123.
    write close.
    write := file readWriteStream.
    write position: 5000.
    write nextPut: 12.
    byte := write next.
    self assert: byte = 123 description: 'Wrong write byte value: ', byte printString.
    write close.

    read := file readStream.
    read position: 5001.
    byte := read next.
    self assert: byte = 123 description: 'Wrong read byte value: ', byte printString
    "! !

"June 27, 2009 -> 12:0:9"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testContentsWrittenShouldReturnCorrectlySizedCollection
"
	| bytes |
	write setToEnd.
    bytes := write contentsWritten.

    self should: [ bytes size = sz ]
    	description: 'Wrong byte count: ', bytes size printString
    	"! !

"June 27, 2009 -> 12:0:11"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testContentsWrittenShouldMatchReadStreamContents
"
	| size bytes |
	write setToEnd.
	bytes := write contentsWritten.
	write close.
    read := file readStream.
    0 to: sz-1 do:
        [ :i <Int> |
            | byte <Int> |
            byte := read next.
            self should: [ (bytes at: i + 1) = byte ]
            	description: 'Wrong byte: ', (bytes at: i + 1) printString, ' at index: ', i printString].
    self should: [ read atEnd] description: 'Read stream should be at end'.
    read position: 0.
    self assert: bytes = read contentsRemaining description: 'Invalid contentsRemaining'
    "! !

"June 27, 2009 -> 12:0:13"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testCharStreamShouldHaveCorrectContents
"
	1 to: s size do: 
        [ :i <Int> |
            | n |
			n := in next.
            self assert: (s at: i) =  n
            	description: 'Wrong character: ', n printString, ' at index: ', i printString].
    self assert: in atEnd description: 'Character stream should be exhausted'
    "! !

"June 27, 2009 -> 12:0:14"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testCharStreamContentsRemainingShouldHaveCorrectContents

	"
	| contents |
	contents := in contentsRemaining.
	self assert: contents = s description: 'Wrong contents: ', contents
	"! !

"June 27, 2009 -> 12:0:35"!

"System saved" !
"June 27, 2009 -> 12:4:1"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'running' !
tearDown
"
	self close: write.
	self close: read.
	in close.
	file delete.
	charFile delete"! !

"June 27, 2009 -> 12:4:3"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'running' !
setUp
"
	| out	<CharOutputStream> |
    file := FilePath for: 'deltatest.tmp'.
    charFile := FilePath for: 'deltatest2.tmp'.
    
    sz := 12345."    "make sure this number is much greater than the stream buffer size" 
    "write := file writeStream.
	0 to: sz-1 do: 
        [ :i <Int> |
            write nextPut: i \\ 100 + 32].

	out := charFile charOutputStream.
    s := 'hi 
there'.
    out nextPutAll: s.
    out close.
    in := charFile charInputStream"! !

"June 27, 2009 -> 12:4:8"!

"System saved" !
"June 28, 2009 -> 11:15:30"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'running' !
tearDown

	self close: write.
	self close: read.
	in close.
	file delete.
	charFile delete! !

"June 28, 2009 -> 11:15:54"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'running' !
setUp

	| out	<CharOutputStream> |
    file := FilePath for: 'deltatest.tmp'.
    charFile := FilePath for: 'deltatest2.tmp'.
    
    sz := 12345.    "make sure this number is much greater than the stream buffer size" 
    write := file writeStream.
	0 to: sz-1 do: 
        [ :i <Int> |
            write nextPut: i \\ 100 + 32].

	out := charFile charOutputStream.
    s := 'hi 
there'.
    out nextPutAll: s.
    out close.
    in := charFile charInputStream! !

"June 28, 2009 -> 11:16:16"!

"System saved" !
"June 28, 2009 -> 11:27:36"!

! (Delta mirrorFor: #MacOSXFilePath) methodsFor: 'private' !
stat: block ifFail: failBlock

    | statBuffer <StatBuffer> 
    	status <ExternalProxy> |
    statBuffer := self statBufferClass new.
    statBuffer allocate.
    [ status := {{<libc ExternalProxy fstat>
            			name: self handle
            			buffer: statBuffer    }}.
	^status asSmallInteger == -1
		ifTrue: [failBlock value]
		ifFalse: [ block value: statBuffer ]]
			ensure: [ statBuffer free]
! !

"June 28, 2009 -> 11:27:51"!

! (Delta mirrorFor: #MacOSXFilePath) methodsFor: 'private' !
statBufferClass

	^MacOSXStatBuffer! !

"June 28, 2009 -> 11:35:41"!

! (Delta mirrorFor: #MacOSXStatBuffer) methodsFor: 'offsets' !
gidOffset

	^16! !

"June 28, 2009 -> 11:35:51"!

! (Delta mirrorFor: #MacOSXStatBuffer) methodsFor: 'offsets' !
uidOffset

	^12! !

"June 28, 2009 -> 11:36:15"!

! (Delta mirrorFor: #MacOSXStatBuffer) methodsFor: 'offsets' !
modeOffset

	^8! !

"June 28, 2009 -> 11:37:21"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
StatBuffer

    ^StatBuffer! !

"June 28, 2009 -> 11:38:14"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
stat: testBlock ifFail: failBlock

    | statBuffer <StatBuffer> 
    	status <ExternalProxy>
    	name <CString> |
    statBuffer := self StatBuffer new.
    statBuffer allocate.
    name := CString for: self name.
    [ status := {{<libc ExternalProxy __xstat>
    					version: statBuffer version
            			name: name
            			buffer: statBuffer    }}.
	status asSmallInteger == -1
		ifTrue: [ failBlock value ]
		ifFalse: [ ^testBlock value: statBuffer ]]
		ensure: [ statBuffer free.
						name free]! !

"June 28, 2009 -> 11:39:37"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
statName: name buffer: statBuffer

    ^{{<libc ExternalProxy __xstat>
   				version: statBuffer version
       			name: name
       			buffer: statBuffer}}! !

"June 28, 2009 -> 11:40:46"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
stat: testBlock ifFail: failBlock

    | statBuffer <StatBuffer> 
    	status <ExternalProxy>
    	name <CString> |
    statBuffer := self StatBuffer new.
    statBuffer allocate.
    name := CString for: self name.
    [ status := self statName: name
            			buffer: statBuffer.
	status asSmallInteger == -1
		ifTrue: [ failBlock value ]
		ifFalse: [ ^testBlock value: statBuffer ]]
		ensure: [ statBuffer free.
						name free]! !

"June 28, 2009 -> 11:42:7"!

! (Delta mirrorFor: #MacOSXFilePath) methodsFor: 'private' !
StatBuffer

	^MacOSXStatBuffer! !

"June 28, 2009 -> 11:42:13"!

! (Delta mirrorFor: #MacOSXFilePath) methodsFor: 'private' !
statName: name buffer: statBuffer

    ^{{<libc ExternalProxy fstat>
       			name: name
       			buffer: statBuffer}}! !

"June 28, 2009 -> 11:42:37"!

(Delta mirrorFor: #MacOSXFilePath) removeMethod: #stat:ifFail: ifAbsent: [] !


"June 28, 2009 -> 11:44:17"!

"System saved" !
"June 28, 2009 -> 11:52:29"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
failureLog	
	^SUnitNameResolver defaultLogDevice
			! !

"June 28, 2009 -> 11:52:41"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
logFailure: aString
	self isLogging ifTrue: [
		self failureLog 
			cr; 
			nextPutAll: aString; 
			flush]! !

"June 28, 2009 -> 11:52:48"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
failureLog	
	^SUnitNameResolver defaultLogDevice! !

"June 28, 2009 -> 11:53:21"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[[aTestCase runCase.
			true]
				sunitOn: self class failure
				do: [:signal |
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
							"self halt."
									self logFailure: signal printString.
									self errors add: aTestCase.
									signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"June 28, 2009 -> 11:55:59"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[[aTestCase runCase.
			true]
				sunitOn: self class failure
				do: [:signal |
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
									"self halt."
									[self logFailure: signal printString]
										sunitOn: self class error
										do: [:s2| [self logFailure: 'a ', signal class printString]
															sunitOn: self class error
															do: [:s3| ]].
									self errors add: aTestCase.
									signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"June 28, 2009 -> 11:57:4"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testError

	self error: 'test failed'! !

"June 28, 2009 -> 11:58:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
isLogging

	^true! !

"June 28, 2009 -> 11:58:58"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
logFailure: aString
	self isLogging ifTrue: [
		self failureLog 
			cr; 
			nextPutAll: aString;
			cr;
			flush]! !

"June 28, 2009 -> 11:59:9"!

(Delta mirrorFor: #ExternalReadWriteStreamTest) removeMethod: #testError ifAbsent: [] !


"June 28, 2009 -> 11:59:41"!

"System saved" !
"June 28, 2009 -> 14:40:49"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'private' !
lastError

	^{{primitiveGetLastError}}! !

"June 28, 2009 -> 14:43:20"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
statFailed

	self error: 'could not stat file: ', self lastError printString! !

"June 28, 2009 -> 14:43:31"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
isWriteable

    ^self stat: [:stat| 
    				(stat uid == self geteuid and: [(stat mode bitAnd: self S_IWUSR) == self S_IWUSR])
    					or: [(stat gid == self getegid and: [(stat mode bitAnd: self S_IWGRP) == self S_IWGRP])
    					or: [(stat mode bitAnd: self S_IWOTH) == self S_IWOTH]]]
    	ifFail: [ self statFailed ]! !

"June 28, 2009 -> 14:44:26"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
isDirectory ^<Boolean>

    ^self stat: [:stat| (stat mode bitAnd: self S_IFDIR) == self S_IFDIR]
    	ifFail: [ self statFailed ]! !

"June 28, 2009 -> 14:48:17"!

"System saved" !
"June 28, 2009 -> 14:56:50"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
statFailed

	| errno|
	errno := self lastError.
	self vmHalt.
	self error: 'could not stat file: ', errno printString! !

"June 28, 2009 -> 14:57:49"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
vmHalt

	{{primitiveVMBreakpoint}}! !

"June 28, 2009 -> 14:59:12"!

"System saved" !
"July 5, 2009 -> 16:20:8"!

! (Delta mirrorFor: #MacOSXFilePath) methodsFor: 'private' !
statName: name buffer: statBuffer

    ^{{<libc ExternalProxy stat>
       			name: name
       			buffer: statBuffer}}! !

"July 5, 2009 -> 16:20:56"!

"System saved" !
"July 5, 2009 -> 16:24:16"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testCharStreamContentsRemainingShouldHaveCorrectContents

	| contents |
	contents := in contentsRemaining.
	self assert: contents = s description: 'Wrong contents: ', contents! !

"July 5, 2009 -> 16:24:36"!

"System saved" !
"July 5, 2009 -> 16:25:57"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testCharStreamShouldHaveCorrectContents

	1 to: s size do: 
        [ :i <Int> |
            | n |
			n := in next.
            self assert: (s at: i) =  n
            	description: 'Wrong character: ', n printString, ' at index: ', i printString].
    self assert: in atEnd description: 'Character stream should be exhausted'! !

"July 5, 2009 -> 16:26:10"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testContentsWrittenShouldMatchReadStreamContents

	| size bytes |
	write setToEnd.
	bytes := write contentsWritten.
	write close.
    read := file readStream.
    0 to: sz-1 do:
        [ :i <Int> |
            | byte <Int> |
            byte := read next.
            self should: [ (bytes at: i + 1) = byte ]
            	description: 'Wrong byte: ', (bytes at: i + 1) printString, ' at index: ', i printString].
    self should: [ read atEnd] description: 'Read stream should be at end'.
    read position: 0.
    self assert: bytes = read contentsRemaining description: 'Invalid contentsRemaining'! !

"July 5, 2009 -> 16:26:20"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testContentsWrittenShouldReturnCorrectlySizedCollection

	| bytes |
	write setToEnd.
    bytes := write contentsWritten.

    self should: [ bytes size = sz ]
    	description: 'Wrong byte count: ', bytes size printString! !

"July 5, 2009 -> 16:26:31"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testModifyingWrittenFileShouldUpdateContents

	| byte |
    write position: 5001.
    write nextPut: 123.
    write close.
    write := file readWriteStream.
    write position: 5000.
    write nextPut: 12.
    byte := write next.
    self assert: byte = 123 description: 'Wrong write byte value: ', byte printString.
    write close.

    read := file readStream.
    read position: 5001.
    byte := read next.
    self assert: byte = 123 description: 'Wrong read byte value: ', byte printString! !

"July 5, 2009 -> 16:26:40"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testPeekShouldReturnCorrectByte

	| byte |
	write close.
    read := file readStream.
    byte := read peek.
    self should: [ byte = 32 ]
    	description: 'Wrong byte: ', byte printString! !

"July 5, 2009 -> 16:26:49"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testPeekShouldReturnFirstCharacter

	| char |
	char := in peek.
	self assert: char = (s at: 1)
		description: 'Wrong character: ', char printString! !

"July 5, 2009 -> 16:27:1"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testReadStreamShouldHaveCorrectContents

	| size |
	write close.
    read := file readStream.
    0 to: sz-1 do:
        [ :i <Int> |
            | byte <Int> |
            byte := read next.
            self should: [ (i \\ 100 +32) = byte ]
            	description: 'Wrong byte: ', byte printString, ' at index: ', i printString]! !

"July 5, 2009 -> 16:27:10"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testReadStreamShouldHaveCorrectSize

	| size |
	write close.
    read := file readStream.
    size := read size.
    self should: [ size = sz ]
    	description: 'Wrong size: ', size printString! !

"July 5, 2009 -> 16:27:28"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testWrittenFileShouldHaveCorrectSize

    self should: [ write size = sz ]
    	description: 'Wrong size ', write size printString! !

"July 5, 2009 -> 16:27:55"!

"System saved" !
"July 5, 2009 -> 16:39:47"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[[aTestCase runCase.
			true]
				sunitOn: self class failure
				do: [:signal |
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
									"self halt."
									self vmHalt.
									[self logFailure: signal printString]
										sunitOn: self class error
										do: [:s2| [self logFailure: 'a ', signal class printString]
															sunitOn: self class error
															do: [:s3| ]].
									self errors add: aTestCase.
									signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"July 5, 2009 -> 16:41:0"!

"System saved" !
"July 7, 2009 -> 0:52:15"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
setExternalPosition: p <Int>
    "%todo: support large integer positions for extremely large files"
    |result|
    result := {{<libc ExternalProxy lseek>
        				fd: self handle
        				offset: p
        				whence: self SEEK_SET }}.    "FILE_BEGIN"
    result isAllOnes
    	ifTrue: [self error: 'Could not position file descriptor: ', 
    					{{primitiveGetLastError}}]! !

"July 7, 2009 -> 0:53:42"!

"System saved" !
"July 7, 2009 -> 0:58:32"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
setExternalPosition: p <Int>
    "%todo: support large integer positions for extremely large files"
    |result|
    result := {{<libc ExternalProxy lseek>
        				fd: self handle
        				offset: p
        				whence: self SEEK_SET }}.    "FILE_BEGIN"
    result isAllOnes
    	ifTrue: [self error: 'Could not position file descriptor: ', 
    					{{primitiveGetLastError}} printString]! !

"July 7, 2009 -> 0:58:49"!

"System saved" !
"July 9, 2009 -> 0:46:5"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
setExternalPosition: p <Int>
    "%todo: support large integer positions for extremely large files"
    |result|
    result := {{<libc ExternalProxy lseek>
        				fd: self handle
        				offset: p
        				whence: self SEEK_SET }}.    "FILE_BEGIN"
    result isAllOnes
    	ifTrue: [| error |
    				error := {{primitiveGetLastError}}.
    				self vmHalt.
    				self error: 'Could not position file descriptor: ', 
    					error printString]! !

"July 9, 2009 -> 0:46:57"!

"System saved" !
"July 11, 2009 -> 10:43:11"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
setExternalPosition: p <Int>
    "%todo: support large integer positions for extremely large files"
    |result|
    self vmHalt.
    result := {{<libc ExternalProxy lseek>
        				fd: self handle
        				offset: p
        				whence: self SEEK_SET }}.    "FILE_BEGIN"
    result isAllOnes
    	ifTrue: [| error |
    				error := {{primitiveGetLastError}}.
    				self vmHalt.
    				self error: 'Could not position file descriptor: ', 
    					error printString]! !

"July 11, 2009 -> 10:44:0"!

"System saved" !
"July 12, 2009 -> 15:58:40"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'private' !
setExternalPosition: p <Int>
    "%todo: support large integer positions for extremely large files"
    | result padding |
    padding := p < 0
    					ifTrue: [-1]
    					ifFalse: [0].
    result := {{<libc ExternalProxy lseek>
        				fd: self handle
        				with: padding
        				offset: p
        				whence: self SEEK_SET }}.    "FILE_BEGIN"
    result isAllOnes
    	ifTrue: [| error |
    				error := {{primitiveGetLastError}}.
    				self vmHalt.
    				self error: 'Could not position file descriptor: ', 
    					error printString]! !

"July 12, 2009 -> 16:0:2"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'private' !
lseek: p <Int> whence: whence <Int>
    "%todo: support large integer positions for extremely large files"
    | padding |
    padding := p < 0
    					ifTrue: [-1]
    					ifFalse: [0].
    ^ {{<libc ExternalProxy lseek>
        				fd: self handle
        				with: padding
        				offset: p
        				whence: whence }}! !

"July 12, 2009 -> 16:0:54"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'private' !
setExternalPosition: p <Int>
    "%todo: support large integer positions for extremely large files"
    | result |
    result := self lseek: p
           				whence: self SEEK_SET.    "FILE_BEGIN"
    result isAllOnes
    	ifTrue: [| error |
    				error := {{primitiveGetLastError}}.
    				self vmHalt.
    				self error: 'Could not position file descriptor: ', 
    					error printString]! !

"July 12, 2009 -> 16:2:10"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'private' !
lseekHandle: handle position: p <Int> whence: whence <Int>
    "%todo: support large integer positions for extremely large files"
    | padding |
    padding := p < 0
    					ifTrue: [-1]
    					ifFalse: [0].
    ^ {{<libc ExternalProxy lseek>
        				fd: handle
        				with: padding
        				offset: p
        				whence: whence }}! !

"July 12, 2009 -> 16:2:50"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'private' !
setExternalPosition: p <Int>
    "%todo: support large integer positions for extremely large files"
    | result |
    result := self handle: self handle
    					lseek: p
           				whence: self SEEK_SET.    "FILE_BEGIN"
    result isAllOnes
    	ifTrue: [| error |
    				error := {{primitiveGetLastError}}.
    				self vmHalt.
    				self error: 'Could not position file descriptor: ', 
    					error printString]! !

"July 12, 2009 -> 16:3:9"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
lseekHandle: handle position: p <Int> whence: whence <Int>
    "%todo: support large integer positions for extremely large files"
    | padding |
    padding := p < 0
    					ifTrue: [-1]
    					ifFalse: [0].
    ^ {{<libc ExternalProxy lseek>
        				fd: handle
        				with: padding
        				offset: p
        				whence: whence }}! !

"July 12, 2009 -> 16:3:31"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
lseekHandle: handle position: p <Int> whence: whence <Int>
    "%todo: support large integer positions for extremely large files"
    ^ {{<libc ExternalProxy lseek>
        				fd: handle
        				offset: p
        				whence: whence }}! !

"July 12, 2009 -> 16:4:32"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'private' !
lseek: handle position: p <Int> whence: whence <Int>
    "%todo: support large integer positions for extremely large files"
    | padding |
    padding := p < 0
    					ifTrue: [-1]
    					ifFalse: [0].
    ^ {{<libc ExternalProxy lseek>
        				fd: handle
        				with: padding
        				offset: p
        				whence: whence }}! !

"July 12, 2009 -> 16:4:34"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'private' !
setExternalPosition: p <Int>
    "%todo: support large integer positions for extremely large files"
    | result |
    result := self lseek: self handle
    					position: p
           				whence: self SEEK_SET.    "FILE_BEGIN"
    result isAllOnes
    	ifTrue: [| error |
    				error := {{primitiveGetLastError}}.
    				self vmHalt.
    				self error: 'Could not position file descriptor: ', 
    					error printString]! !

"July 12, 2009 -> 16:4:49"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
lseek: handle position: p <Int> whence: whence <Int>
    "%todo: support large integer positions for extremely large files"
    ^ {{<libc ExternalProxy lseek>
        				fd: handle
        				offset: p
        				whence: whence }}! !

"July 12, 2009 -> 16:5:5"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
setExternalPosition: p <Int>
    "%todo: support large integer positions for extremely large files"
    | result |
    result := self lseek: self handle
    					position: p
           				whence: self SEEK_SET.    "FILE_BEGIN"
    result isAllOnes
    	ifTrue: [| error |
    				error := {{primitiveGetLastError}}.
    				self vmHalt.
    				self error: 'Could not position file descriptor: ', 
    					error printString]! !

"July 12, 2009 -> 16:5:23"!

(Delta mirrorFor: #MacOSXFileDescriptor) removeMethod: #lseek:whence: ifAbsent: [] !


"July 12, 2009 -> 16:5:25"!

(Delta mirrorFor: #MacOSXFileDescriptor) removeMethod: #lseekHandle:position:whence: ifAbsent: [] !


"July 12, 2009 -> 16:5:30"!

(Delta mirrorFor: #MacOSXFileDescriptor) removeMethod: #setExternalPosition: ifAbsent: [] !


"July 12, 2009 -> 16:8:7"!

"System saved" !
"July 12, 2009 -> 18:33:2"!

(Delta mirrorFor: #UnixFileDescriptor) removeMethod: #lseekHandle:position:whence: ifAbsent: [] !


"July 12, 2009 -> 19:39:11"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'private' !
lseek: handle position: p <Int> whence: whence <Int>
    "%todo: support large integer positions for extremely large files"
    | padding |
    padding := p < 0
    					ifTrue: [-1]
    					ifFalse: [0].
    self vmHalt.
    ^ {{<libc ExternalProxy lseek>
        				fd: handle
        				with: padding
        				offset: p
        				whence: whence }}! !

"July 12, 2009 -> 19:39:35"!

"System saved" !
"July 13, 2009 -> 0:40:1"!

! (Delta mirrorFor: #ExternalReadWriteStream) methodsFor: 'accessing' !
contentsWritten  ^<SeqCltn[Int]>
    "%copied (substituting for E) from BasicReadWriteStream"
    | cltn <VarSeqCltn[Int]>  origPos <Int> |
    cltn := self newCollectionOfSize: self position.
    origPos := self position.
    self vmHalt.
    self position: 0.
    1 to: origPos do: [ :i <Int> |
        cltn at: i put: self next.    ].
    self position: origPos.
    ^cltn! !

"July 13, 2009 -> 0:40:24"!

"System saved" !
"July 13, 2009 -> 0:42:0"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'private' !
lseek: handle position: p <Int> whence: whence <Int>
    "%todo: support large integer positions for extremely large files"
    | padding |
    padding := p < 0
    					ifTrue: [-1]
    					ifFalse: [0].
    "self vmHalt."
    ^ {{<libc ExternalProxy lseek>
        				fd: handle
        				with: padding
        				offset: p
        				whence: whence }}! !

"July 13, 2009 -> 0:42:20"!

"System saved" !
"July 14, 2009 -> 1:32:18"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'i/o' !
read: handle buffer: buffer count: count

	^{{<libc ExternalProxy read>
		fd: handle
		buffer: buffer
		count: count }}! !

"July 14, 2009 -> 1:35:19"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'i/o' !
readAt: pos <Int> ifFail: errf <[ExternalError]> ^<Int>
    | result <ExternalProxy> count <Int> |
    self position = pos
        ifFalse: [ self position: pos ].
    self knowAtEnd
        ifTrue: [ count := 0 ]
        ifFalse: [result := self read: self handle
                        				buffer: self buffer
                        				count: self bufferSize.
                     result isAllOnes
                     	ifTrue: [self vmHalt.
                     				errf value: 'Error filling buffer']
                     	ifFalse: [count := result asSmallInteger ]].
    self setPosition: self position + count.
    ^count! !

"July 14, 2009 -> 1:36:21"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
errno

	^{{primitiveGetLastError}}! !

"July 14, 2009 -> 1:36:44"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'i/o' !
readAt: pos <Int> ifFail: errf <[ExternalError]> ^<Int>
    | result <ExternalProxy> count <Int> |
    self position = pos
        ifFalse: [ self position: pos ].
    self knowAtEnd
        ifTrue: [ count := 0 ]
        ifFalse: [result := self read: self handle
                        				buffer: self buffer
                        				count: self bufferSize.
                     result isAllOnes
                     	ifTrue: [self vmHalt.
                     				errf value: 'Error filling buffer: ', self errno printString]
                     	ifFalse: [count := result asSmallInteger ]].
    self setPosition: self position + count.
    ^count! !

"July 14, 2009 -> 1:38:2"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'i/o' !
readAt: pos <Int> ifFail: errf <[ExternalError]> ^<Int>
    | result <ExternalProxy> count <Int> |
    self position = pos
        ifFalse: [ self position: pos ].
    self knowAtEnd
        ifTrue: [ count := 0 ]
        ifFalse: [result := self read: self handle
                        				buffer: self buffer
                        				count: self bufferSize.
                     result isAllOnes
                     	ifTrue: [|msg|
                     				msg := 'Error filling buffer: ', self errno printString.
                     				self vmHalt.
                     				errf value: msg]
                     	ifFalse: [count := result asSmallInteger ]].
    self setPosition: self position + count.
    ^count! !

"July 14, 2009 -> 1:38:38"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
setExternalPosition: p <Int>
    "%todo: support large integer positions for extremely large files"
    | result |
    result := self lseek: self handle
    					position: p
           				whence: self SEEK_SET.    "FILE_BEGIN"
    result isAllOnes
    	ifTrue: [| error |
    				error := self errno.
    				self vmHalt.
    				self error: 'Could not position file descriptor: ', 
    					error printString]! !

"July 14, 2009 -> 1:39:33"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
errorText: message

	^message , self errno! !

"July 14, 2009 -> 1:39:54"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
errorText: message

	^message , self errno printString! !

"July 14, 2009 -> 1:41:13"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
setExternalPosition: p <Int>
    "%todo: support large integer positions for extremely large files"
    | result |
    result := self lseek: self handle
    					position: p
           				whence: self SEEK_SET.    "FILE_BEGIN"
    result isAllOnes
    	ifTrue: [self vmHalt.
    				self error: (self errorText: 'Could not position file descriptor: ')]! !

"July 14, 2009 -> 1:42:21"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'i/o' !
readAt: pos <Int> ifFail: errf <[ExternalError]> ^<Int>
    | result <ExternalProxy> count <Int> |
    self position = pos
        ifFalse: [ self position: pos ].
    self knowAtEnd
        ifTrue: [ count := 0 ]
        ifFalse: [result := self read: self handle
                        				buffer: self buffer
                        				count: self bufferSize.
                     result isAllOnes
                     	ifTrue: [|msg|
                     				msg := self errorText: 'Error filling buffer: '.
                     				self vmHalt.
                     				errf value: msg]
                     	ifFalse: [count := result asSmallInteger ]].
    self setPosition: self position + count.
    ^count! !

"July 14, 2009 -> 1:44:57"!

"System saved" !
"July 14, 2009 -> 10:30:14"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'running' !
setUp

	| out	<CharOutputStream> |
    file := FilePath for: 'deltatest.tmp'.
    charFile := FilePath for: 'deltatest2.tmp'.
    
    sz := 12345.    "make sure this number is much greater than the stream buffer size" 
    write := file readWriteStream.
	0 to: sz-1 do: 
        [ :i <Int> |
            write nextPut: i \\ 100 + 32].

	out := charFile charOutputStream.
    s := 'hi 
there'.
    out nextPutAll: s.
    out close.
    in := charFile charInputStream! !

"July 14, 2009 -> 10:32:14"!

! (Delta mirrorFor: #ExternalReadWriteStream) methodsFor: 'accessing' !
contentsWritten  ^<SeqCltn[Int]>
    "%copied (substituting for E) from BasicReadWriteStream"
    | cltn <VarSeqCltn[Int]>  origPos <Int> |
    cltn := self newCollectionOfSize: self position.
    origPos := self position.
    self position: 0.
    1 to: origPos do: [ :i <Int> |
        cltn at: i put: self next.    ].
    self position: origPos.
    ^cltn! !

"July 14, 2009 -> 10:33:49"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
statFailed

	| errno|
	errno := self lastError.
	self error: 'could not stat file: ', errno printString! !

"July 14, 2009 -> 10:33:51"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
setExternalPosition: p <Int>
    "%todo: support large integer positions for extremely large files"
    | result |
    result := self lseek: self handle
    					position: p
           				whence: self SEEK_SET.    "FILE_BEGIN"
    result isAllOnes
    	ifTrue: [self error: (self errorText: 'Could not position file descriptor: ')]! !

"July 14, 2009 -> 10:33:53"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[[aTestCase runCase.
			true]
				sunitOn: self class failure
				do: [:signal |
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
									[self logFailure: signal printString]
										sunitOn: self class error
										do: [:s2| [self logFailure: 'a ', signal class printString]
															sunitOn: self class error
															do: [:s3| ]].
									self errors add: aTestCase.
									signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"July 14, 2009 -> 10:33:55"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'i/o' !
readAt: pos <Int> ifFail: errf <[ExternalError]> ^<Int>
    | result <ExternalProxy> count <Int> |
    self position = pos
        ifFalse: [ self position: pos ].
    self knowAtEnd
        ifTrue: [ count := 0 ]
        ifFalse: [result := self read: self handle
                        				buffer: self buffer
                        				count: self bufferSize.
                     result isAllOnes
                     	ifTrue: [|msg|
                     				msg := self errorText: 'Error filling buffer: '.
                     				errf value: msg]
                     	ifFalse: [count := result asSmallInteger ]].
    self setPosition: self position + count.
    ^count! !

"July 14, 2009 -> 10:34:13"!

"System saved" !
"July 14, 2009 -> 11:0:4"!

! (Delta mirrorFor: #MacOSXFilePath) methodsFor: 'private' !
O_CREAT

	^16r200! !

"July 14, 2009 -> 11:0:25"!

! (Delta mirrorFor: #MacOSXFilePath) methodsFor: 'private' !
O_TRUNC

	^16r400! !

"July 14, 2009 -> 11:8:33"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'restricted' !
open: dname <ExternalProxy> mode: dmode <SmallInt> ^ <ExternalProxy>

   ^{{<libc ExternalProxy open>
    					name: dname
    					flags: dmode
    					create: 8r777 }}! !

"July 14, 2009 -> 11:8:50"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'restricted' !
open: dname <ExternalProxy> mode: dmode <SmallInt> ^ <ExternalProxy>

   ^{{<libc ExternalProxy open>
    		name: dname
    		flags: dmode
    		create: 8r777 }}! !

"July 14, 2009 -> 11:8:58"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'restricted' !
open: dname <ExternalProxy> mode: dmode <SmallInt> ^ <ExternalProxy>

   ^{{<libc ExternalProxy open>
    		name: dname
    		flags: dmode
    		permissions: 8r777 }}! !

"July 14, 2009 -> 11:9:34"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'restricted' !
openInternalFor: mode <Symbol> ifFail: err <[ExternalError, ^X def]>  ^<ExternalProxy | X>

    |   dname <ExternalProxy>
        dmode <SmallInt>
        proxy <ExternalProxy> |
    dname := self nameProxy.

    [ dmode := self modeFor: mode.
    	proxy := self open: dname
    					mode: dmode]
    		ensure: [ dname free ].

    ^proxy isAllOnes
        ifFalse: [ proxy ]
        ifTrue: [ err value: #cannotOpenFile ]! !

"July 14, 2009 -> 11:10:14"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'restricted' !
openInternalFor: mode <Symbol> ifFail: err <[ExternalError, ^X def]>  ^<ExternalProxy | X>

    |   dname <ExternalProxy>
        dmode <SmallInt>
        proxy <ExternalProxy> |
    dname := self nameProxy.

    [ dmode := self modeFor: mode.
    	proxy := self open: dname
    						mode: dmode]
    		ensure: [ dname free ].

    ^proxy isAllOnes
        ifFalse: [ proxy ]
        ifTrue: [ err value: #cannotOpenFile ]! !

"July 14, 2009 -> 11:10:48"!

! (Delta mirrorFor: #MacOSXFilePath) methodsFor: 'private' !
open: dname <ExternalProxy> mode: dmode <SmallInt> ^ <ExternalProxy>

   ^{{<libc ExternalProxy open>
    		name: dname
    		flags: dmode }}! !

"July 14, 2009 -> 11:12:14"!

"System saved" !
"July 14, 2009 -> 21:49:15"!

(Delta mirrorFor: #MacOSXFilePath) removeMethod: #open:mode: ifAbsent: [] !


"July 14, 2009 -> 21:49:57"!

"System saved" !
"July 18, 2009 -> 12:35:26"!

! (Delta mirrorFor: #DefWithMsgSourceHandler) methodsFor: 'Unclassified' !
sourceForSelector: sel <Symbol> ^ <Str> 

	| list <OrdCltn[Str]> |
	#positions: == sel ifTrue: [self vmHalt].
	list := self attributeAt: sel.
	list size < 2 ifTrue: [ self shouldNotHappen ].
	(list at: 1) do: [ :e <Character> | e isDigit ifFalse: [ self shouldNotHappen ] ].
	self changeLog position: (Integer readFrom: (list at: 1) readStream).
	^self changeLog nextChunk! !

"July 18, 2009 -> 12:40:1"!

"System saved" !
"July 18, 2009 -> 13:27:27"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
vmHalt: condition

	condition ifTrue: [self vmHalt]! !

"July 18, 2009 -> 13:28:22"!

! (Delta mirrorFor: #DefWithMsgSourceHandler) methodsFor: 'Unclassified' !
sourceForSelector: sel <Symbol> ^ <Str> 

	| list <OrdCltn[Str]> |
	list := self attributeAt: sel.
	list size < 2 ifTrue: [ self shouldNotHappen ].
	(list at: 1) do: [ :e <Character> | e isDigit ifFalse: [ self shouldNotHappen ] ].
	self changeLog position: ((Integer readFrom: (list at: 1) readStream) vmHalt: #positions: == sel).
	^self changeLog nextChunk! !

"July 18, 2009 -> 13:32:59"!

"System saved" !
"July 19, 2009 -> 17:5:13"!

! (Delta mirrorFor: #DefWithMsgSourceHandler) methodsFor: 'Unclassified' !
sourceForSelector: sel <Symbol> ^ <Str> 

	| list <OrdCltn[Str]> |
	list := self attributeAt: sel.
	list size < 2 ifTrue: [ self shouldNotHappen ].
	(list at: 1) do: [ :e <Character> | e isDigit ifFalse: [ self shouldNotHappen ] ].
	LSeekStop := #positions: == sel.
	self changeLog position: ((Integer readFrom: (list at: 1) readStream)).
	^self changeLog nextChunk! !

"July 19, 2009 -> 17:12:52"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'private' !
lseek: handle position: p <Int> whence: whence <Int>
    "%todo: support large integer positions for extremely large files"
    | padding |
    padding := p < 0
    					ifTrue: [-1]
    					ifFalse: [0].
    "self vmHalt: LSeekStop."
    ^ {{<libc ExternalProxy lseek>
        				fd: (handle vmHalt: LSeekStop)
        				with: padding
        				offset: p
        				whence: whence }}! !

"July 19, 2009 -> 17:18:42"!

"System saved" !
"July 19, 2009 -> 17:27:32"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'private' !
lseek: handle position: p <Int> whence: whence <Int>
    "%todo: support large integer positions for extremely large files"
    | padding |
    padding := p < 0
    					ifTrue: [-1]
    					ifFalse: [0].
    "self vmHalt: LSeekStop."
    ^ {{<libc ExternalProxy lseek>
        				fd: (handle vmHalt: (LSeekStop notNil and: [LSeekStop]))
        				with: padding
        				offset: p
        				whence: whence }}! !

"July 19, 2009 -> 17:27:46"!

"System saved" !
"July 19, 2009 -> 23:19:10"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'private' !
lseek: handle position: p <Int> whence: whence <Int>
    "%todo: support large integer positions for extremely large files"
    | padding |
    padding := p < 0
    					ifTrue: [-1]
    					ifFalse: [0].
    "self vmHalt: LSeekStop."
    ^ {{<libc ExternalProxy lseek>
        				fd: (handle "vmHalt: (LSeekStop notNil and: [LSeekStop])")
        				offsetLow: p
        				offsetHigh: padding
        				whence: whence }}! !

"July 19, 2009 -> 23:19:31"!

"System saved" !
"July 19, 2009 -> 23:22:14"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'private' !
lseek: handle position: p <Int> whence: whence <Int>
    "%todo: support large integer positions for extremely large files"
    | padding |
    padding := p < 0
    					ifTrue: [-1]
    					ifFalse: [0].
   ^ {{<libc ExternalProxy lseek>
        				fd: handle
        				offsetLow: p
        				offsetHigh: padding
        				whence: whence }}! !

"July 19, 2009 -> 23:23:10"!

! (Delta mirrorFor: #DefWithMsgSourceHandler) methodsFor: 'Unclassified' !
sourceForSelector: sel <Symbol> ^ <Str> 

	| list <OrdCltn[Str]> |
	list := self attributeAt: sel.
	list size < 2 ifTrue: [ self shouldNotHappen ].
	(list at: 1) do: [ :e <Character> | e isDigit ifFalse: [ self shouldNotHappen ] ].
	self changeLog position: ((Integer readFrom: (list at: 1) readStream)).
	^self changeLog nextChunk! !

"July 19, 2009 -> 23:23:31"!

(Delta mirrorFor: #LSeekStop) removeDefinitionIfFail: [] !


"July 19, 2009 -> 23:25:54"!

"System saved" !
"July 26, 2009 -> 23:19:41"!

! (Delta mirrorFor: #HaltTest) methodsFor: 'Testing' !
testDefaultActionShouldStopWithProcessHaltError

	| wasHandled processError |
	wasHandled := false.
	self withStopHandler: [:p| wasHandled := true.
											processError := p processError.
											p terminate]
			do: [[self halt] fork.
					Processor yield].
	self assert: wasHandled
			description: 'Halt should have been handled'.
	self assert: (processError isKindOf: ProcessHaltError)
			description: 'Wrong kind of error reported'! !

"July 26, 2009 -> 23:19:54"!

! (Delta mirrorFor: #ErrorTest) methodsFor: 'testing' !
testDefaultActionShouldPassToStopHandler

	| wasHandled processError |
	wasHandled := false.
	self withStopHandler: [:p| wasHandled := true.
											processError := p processError.
											p terminate]
			do: 	[[self error: 'this is an error'] fork.
					Processor yield].
	self assert: wasHandled
			description: 'defaultAction should invoke the stopHandler'.
	self assert: (processError isKindOf: ProcessExplicitError)
			description: 'Process stopped with wrong kind of error', processError printString.
	self assert: 'this is an error' = processError msg
			description: 'Process stopped with wrong message: ', processError msg! !

"July 26, 2009 -> 23:21:30"!

"System saved" !
"August 1, 2009 -> 16:18:48"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Testing' !
shouldInheritSelectors
	"I should inherit from an Abstract superclass but not from a concrete one by default,
	 unless I have no testSelectors in which case I must be expecting to inherit them
	 from my superclass.  If a test case with selectors wants to inherit selectors from a
	 concrete superclass, override this to true in that subclass."

	^self superclass isAbstract
		or: [self testSelectors isEmpty]

"$QA Ignore:Sends system method(superclass)$"
			! !

"August 3, 2009 -> 21:39:59"!

Delta define: #NLRAlignmentTest as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 3, 2009 -> 21:40:49"!

! (Delta mirrorFor: #NLRAlignmentTest) methodsFor: 'private' !
call: block

	block value! !

"August 3, 2009 -> 21:41:26"!

! (Delta mirrorFor: #NLRAlignmentTest) methodsFor: 'private' !
call: block

	[block value]
		ensure: []! !

"August 3, 2009 -> 21:41:49"!

! (Delta mirrorFor: #NLRAlignmentTest) methodsFor: 'private' !
call: block with: one

	[block value]
		ensure: []! !

"August 3, 2009 -> 21:41:55"!

! (Delta mirrorFor: #NLRAlignmentTest) methodsFor: 'private' !
call: block with: one with: two

	[block value]
		ensure: []! !

"August 3, 2009 -> 21:42:27"!

! (Delta mirrorFor: #NLRAlignmentTest) methodsFor: 'private' !
call: block with: one with: two with: three

	[block value]
		ensure: []! !

"August 3, 2009 -> 21:44:12"!

! (Delta mirrorFor: #NLRAlignmentTest) methodsFor: 'testing' !
testWithNone

	self call: [^self]! !

"August 3, 2009 -> 21:44:27"!

! (Delta mirrorFor: #NLRAlignmentTest) methodsFor: 'testing' !
testWithOne

	self call: [^self] with: 0! !

"August 3, 2009 -> 21:44:37"!

! (Delta mirrorFor: #NLRAlignmentTest) methodsFor: 'testing' !
testWithTwo

	self call: [^self] with: 0 with: 0! !

"August 3, 2009 -> 21:44:49"!

! (Delta mirrorFor: #NLRAlignmentTest) methodsFor: 'testing' !
testWithThree

	self call: [^self] with: 0 with: 0 with: 0! !

"August 3, 2009 -> 21:45:43"!

Delta define: #NLRAlignmentTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 3, 2009 -> 21:45:43"!

Delta define: #NLRAlignmentTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 3, 2009 -> 21:45:43"!

Delta define: #NLRAlignmentTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 3, 2009 -> 21:45:43"!

Delta define: #NLRAlignmentTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 3, 2009 -> 21:45:43"!

Delta define: #NLRAlignmentTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 3, 2009 -> 21:45:43"!

Delta define: #NLRAlignmentTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 3, 2009 -> 21:45:43"!

Delta define: #NLRAlignmentTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 3, 2009 -> 21:45:43"!

Delta define: #NLRAlignmentTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 3, 2009 -> 21:45:43"!

Delta define: #NLRAlignmentTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 3, 2009 -> 21:45:43"!

Delta define: #NLRAlignmentTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 3, 2009 -> 21:45:43"!

Delta define: #NLRAlignmentTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 3, 2009 -> 21:47:19"!

"System saved" !
"August 3, 2009 -> 22:2:20"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
exists ^<Boolean>
	| name result |
	name := self nameProxy.
    [ result := {{<libc ExternalProxy open>
   	 					name: name
    					flags: 0}}.
    	result isAllOnes
    		ifFalse: [{{<libc ExternalProxy close>
   	 							fd: result}}]]
     	ensure: [ name free ].
     ^result isAllOnes not! !

"August 3, 2009 -> 22:2:39"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
exists ^<Boolean>
	| name result |
	name := self nameProxy.
    [ result := {{<libc ExternalProxy open>
   	 					name: name
    					flags: 0}}.
    	result isAllOnes
    		ifFalse: [{{<libc ExternalProxy close>
   	 							fd: result}}]]
     	ensure: [ name free ].
    ^result isAllOnes not! !

"August 3, 2009 -> 22:3:27"!

"System saved" !
"August 8, 2009 -> 10:48:20"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
exists ^<Boolean>
	| name result |
	name := self nameProxy.
    [result := {{<libc ExternalProxy open>
   	 					name: name
    					flags: 0}}.
    result asInteger > 0
    	ifTrue: [{{<libc ExternalProxy close>
   							fd: result}}]]
     	ensure: [ name free ].
    ^result isAllOnes not! !

"August 8, 2009 -> 10:48:37"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
exists ^<Boolean>
	| name result |
	name := self nameProxy.
    [result := {{<libc ExternalProxy open>
   	 					name: name
    					flags: 0
    					ignored: 0}}.
    result asInteger > 0
    	ifTrue: [{{<libc ExternalProxy close>
   							fd: result}}]]
     	ensure: [ name free ].
    ^result isAllOnes not! !

"August 8, 2009 -> 10:50:4"!

"System saved" !
"August 9, 2009 -> 11:25:45"!

! (Delta mirrorFor: #NLRAlignmentTest) methodsFor: 'testing' !
invokeWithNone

	self call: [^0]! !

"August 9, 2009 -> 11:26:40"!

! (Delta mirrorFor: #NLRAlignmentTest) methodsFor: 'testing' !
testWithNone

	self assert: 0 == self invokeWithNone! !

"August 9, 2009 -> 11:26:54"!

! (Delta mirrorFor: #NLRAlignmentTest) methodsFor: 'testing' !
invokeWithOne

	self call: [^1] with: 0! !

"August 9, 2009 -> 11:27:17"!

! (Delta mirrorFor: #NLRAlignmentTest) methodsFor: 'testing' !
testWithOne

	self assert: 1 == self invokeWithOne! !

"August 9, 2009 -> 11:27:31"!

! (Delta mirrorFor: #NLRAlignmentTest) methodsFor: 'testing' !
invokeWithThree

	self call: [^3] with: 0 with: 0 with: 0! !

"August 9, 2009 -> 11:27:51"!

! (Delta mirrorFor: #NLRAlignmentTest) methodsFor: 'testing' !
testWithThree

	self assert: 3 == self invokeWithThree! !

"August 9, 2009 -> 12:16:31"!

! (Delta mirrorFor: #NLRAlignmentTest) methodsFor: 'testing' !
invokeWithTwo

	self call: [^2] with: 0 with: 0! !

"August 9, 2009 -> 12:16:54"!

! (Delta mirrorFor: #NLRAlignmentTest) methodsFor: 'testing' !
testWithTwo

	self assert: 3 == self invokeWithTwo! !

"August 9, 2009 -> 12:20:6"!

! (Delta mirrorFor: #NLRAlignmentTest) methodsFor: 'testing' !
testWithTwo

	self assert: 2 == self invokeWithTwo! !

"August 9, 2009 -> 12:20:57"!

"System saved" !
"August 13, 2009 -> 22:18:36"!

Delta define: #Alien as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:36"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
dataSize

	^self subclassResponsibility! !

"August 13, 2009 -> 22:18:37"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
new

	^self new: self dataSize! !

"August 13, 2009 -> 22:18:37"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
new: size <Integer> ^ <X>! !

"August 13, 2009 -> 22:18:37"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
new: size <Integer> ^ <X>

	^(super new: size)
		size: size;
		initialize! !

"August 13, 2009 -> 22:18:37"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
new: size <Integer> ^ <X>

	^(super primitiveNew: size)
		size: size;
		initialize! !

"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
new: size <Integer> ^ <X>

	^(super new: size)
		size: size;
		initialize! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
size: anInteger <Integer>

	size := anInteger! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
size ^<Integer>

	^size! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) methodsFor: 'instance initialization' !
initialize
	"Subclasses may override to perform specific initialization"! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
newC

	^self newC: self dataSize! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
newC: size <Integer> ^ <X>

	^(super new: 4)
		size: size negated;
		address: (self Ccalloc: size);
		initialize! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
address: anInteger <Integer>

	self unimplemented! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
address ^<Integer>

	self unimplemented! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
Ccalloc: size <Integer> ^ <Integer>

	^{{self primitiveAlienCalloc: size
		ifFail: [:err| self error: 'Failed to alloc alien: ', err]}}! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
Cmalloc: size <Integer> ^ <Integer>

	^{{self primitiveAlienMalloc: size
		ifFail: [:err| self error: 'Failed to malloc alien: ', err]}}! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
Ccalloc: size <Integer> ^ <Integer>

	^{{self primitiveAlienCalloc: size
		ifFail: [:err| self error: 'Failed to calloc alien: ', err]}}! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
newGC

	^self newGC: self dataSize! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
newGC: size <Integer> ^<X>

	| alien address |
	alien := (super new: 4).
	alien size: size negated.
	address := self Ccalloc: size.
	"GCMallocedAliens add: alien finalizing: address."
	^alien
		address: address;
		initialize
		! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
rawNewC: size <Integer> ^ <X>

	^(super new: 4)
		size: size negated;
		address: (self Cmalloc: size);
		initialize! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
atAddress: pointer <Integer> ^<X>! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
atAddress: pointer <Integer> ^<X>

	^(super new: 4)
		size: self dataSize negated;
		address: pointer;
		yourself! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
atAddress: pointer <Integer> ^<X>

	^(super primitiveNew: 4)
		size: self dataSize negated;
		address: pointer;
		yourself! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
new: size <Integer> ^ <X>

	^(super primitiveNew: size)
		size: size;
		initialize! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
newC: size <Integer> ^ <X>

	^(self primitiveNew: 4)
		size: size negated;
		address: (self Ccalloc: size);
		initialize! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
newGC: size <Integer> ^<X>

	| alien address |
	alien := self primitiveNew: 4.
	alien size: size negated.
	address := self Ccalloc: size.
	"GCMallocedAliens add: alien finalizing: address."
	^alien
		address: address;
		initialize
		! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
rawNewC: size <Integer> ^ <X>

	^(self primitiveNew: 4)
		size: size negated;
		address: (self Cmalloc: size);
		initialize! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
atAddress: pointer <Integer> dataSize: dataSize <Integer> ^<X>

	^(super primitiveNew: 4)
		size: dataSize negated;
		address: pointer;
		yourself! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
atAddress: pointer <Integer> dataSize: dataSize <Integer> ^<X>

	^(self primitiveNew: 4)
		size: dataSize negated;
		address: pointer;
		yourself! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
atAddress: pointer <Integer> ^<X>

	^(self primitiveNew: 4)
		size: self dataSize negated;
		address: pointer;
		yourself! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
new: size <Integer> ^ <X>

	^(self primitiveNew: size)
		size: size;
		initialize! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
forPointer: pointer <Integer> ^<X>

	^(self primitiveNew: 4)
		size: 0;
		address: pointer;
		yourself! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
autoFreeAfter: action <BlockWithOneArgument>
	"Evaluate the action, which must be a 1-argument block.
	 The argument passed to the action is a block the action
	 can use to register Aliens created inside the action.
	 Such aliens will be freed as soon as the action completes.
	 Return the value returned from the action. See usage
	 example at the bottom of the method. "
	
	| toFree |
	toFree := OrderedCollection new.
	^[action value: [:alien | toFree add: alien]]
		ensure: [toFree do: [:each | each free]]
		
"
	Alien autoFreeAfter:
		[:autoFree | | foo bar |
		foo := autoFree value: (Alien newCString: 'foo').
		bar := autoFree value: (Alien newCString: 'bar').
		...]
"! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
autoFreeAfter: action <OneArgumentBlock>
	"Evaluate the action, which must be a 1-argument block.
	 The argument passed to the action is a block the action
	 can use to register Aliens created inside the action.
	 Such aliens will be freed as soon as the action completes.
	 Return the value returned from the action. See usage
	 example at the bottom of the method. "
	
	| toFree |
	toFree := OrderedCollection new.
	^[action value: [:alien | toFree add: alien]]
		ensure: [toFree do: [:each | each free]]
		
"
	Alien autoFreeAfter:
		[:autoFree | | foo bar |
		foo := autoFree value: (Alien newCString: 'foo').
		bar := autoFree value: (Alien newCString: 'bar').
		...]
"! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
autoFreeAfter: action <[X, ^ Y]>
	"Evaluate the action, which must be a 1-argument block.
	 The argument passed to the action is a block the action
	 can use to register Aliens created inside the action.
	 Such aliens will be freed as soon as the action completes.
	 Return the value returned from the action. See usage
	 example at the bottom of the method. "
	
	| toFree |
	toFree := OrderedCollection new.
	^[action value: [:alien | toFree add: alien]]
		ensure: [toFree do: [:each | each free]]
		
"
	Alien autoFreeAfter:
		[:autoFree | | foo bar |
		foo := autoFree value: (Alien newCString: 'foo').
		bar := autoFree value: (Alien newCString: 'bar').
		...]
"! !

"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size') classVariables: 'GCMallocedAliens LoadedLibraries') !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size') classVariables: 'GCMallocedAliens LoadedLibraries') !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size') classVariables: 'GCMallocedAliens LoadedLibraries') !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size') classVariables: 'GCMallocedAliens LoadedLibraries') !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size') classVariables: 'GCMallocedAliens LoadedLibraries') !


"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'class initialization' !
initialize

	LoadedLibraries isNil ifTrue: 
		[LoadedLibraries := Dictionary new].
	GCMallocedAliens isNil ifTrue:
		[GCMallocedAlients := nil "AlienWeakTable newForOwner: self"]! !

"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'class initialization' !
initialize

	LoadedLibraries isNil ifTrue: 
		[LoadedLibraries := Dictionary new].
	GCMallocedAliens isNil ifTrue:
		[GCMallocedAlients := AlienWeakTable newForOwner: self]! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #AlienWeakTable) classSide methodsFor: 'instance creation' !
newForOwner: owner
	^self new initializeWithOwner: owner! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #AlienWeakTable) methodsFor: 'initialization' !
initializeWithOwner: owner

	! !

"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUnusedInder <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUnusedInder <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUnusedInder <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUnusedInder <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #AlienWeakTable) methodsFor: 'initialization' !
initializeWithOwner: owner

	accessProtect := Semaphore forMutualExclusion.! !

"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUnusedInder <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUnusedInder <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUnusedInder <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUnusedInder <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUnusedInder <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUnusedInder <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUnusedInder <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUnusedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUnusedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUnusedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUnusedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUnusedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:39"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUnusedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:39"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUnusedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:39"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUnusedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:39"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUnusedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:39"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUnusedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:39"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUnusedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:39"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUsedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:39"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUsedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:39"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUsedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:39"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUsedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #AlienWeakTable) methodsFor: 'initialization' !
initializeWithOwner: anOwner

	accessProtect := Semaphore forMutualExclusion.
	firstUnusedIndex := 1.
	lastUsedIndex := 0.
	weakArray := WeakArray new: 1024.
	strongArray := Array new: 1024.
	owner := anOwner.
	! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
newGC: size <Integer> ^<X>

	| alien address |
	alien := self primitiveNew: 4.
	alien size: size negated.
	address := self Ccalloc: size.
	GCMallocedAliens add: alien finalizing: address.
	^alien
		address: address;
		initialize
		! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #AlienWeakTable) methodsFor: 'adding' !
add: anObject finalizing: postMortemFinalizationTag
	"Register a new object in the table, with the associated tag.
	 The object is held onto weakly, the tag--strongly. The tag
	 will be passed to the owner as the argument of #finalize:
	 some time after the object is garbage collected."

	| size start delta |
	accessProtect critical:
		[size := strongArray size.
		 start := firstUnusedIndex].
	start to: size do:
		[:i|
		(strongArray at: i) == nil ifTrue:
			[accessProtect critical:
				[weakArray at: i put: anObject.
				 strongArray at: i put: postMortemFinalizationTag.
				 firstUnusedIndex := i + 1.
				 i > lastUsedIndex ifTrue: [lastUsedIndex := i]].
			 ^anObject]].
	delta := size min: 4096.
	accessProtect critical:
		[(weakArray := weakArray copyGrownBy: delta)
			 at: size + 1 put: anObject.
		 (strongArray := strongArray  copyGrownBy: delta)
			at: size put: postMortemFinalizationTag.
		 firstUnusedIndex := size + 1.
		 lastUsedIndex := size].
	^anObject! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'class initialization' !
initialize

	LoadedLibraries isNil ifTrue: 
		[LoadedLibraries := Dictionary new].
	GCMallocedAliens isNil ifTrue:
		[GCMallocedAliens := AlienWeakTable newForOwner: self]! !

"August 13, 2009 -> 22:18:39"!

(Delta mirrorFor: #GCMallocedAlients) removeDefinitionIfFail: [] !


"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #Array) methodsFor: 'copying' !
copyGrownBy: delta <Integer> ^<Array[EX]>
	{where EX is returnType of #anElement message of receiverType}

	^self copyWithSize: self size + delta! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
address: anInteger <Integer>

	{{self primitiveAlienAddress: anInteger}}! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
address ^<Integer>

	{{self primitiveAlienAddress}}! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'private - memory allocation' !
Cmalloc: size <Integer> ^ <Integer>

	^{{self primitiveAlienMalloc: size
			ifFail: [:err| self error: 'Failed to malloc alien: ', err]}}! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'private - memory allocation' !
Ccalloc: size <Integer> ^ <Integer>

	^{{self primitiveAlienCalloc: size
			ifFail: [:err| self error: 'Failed to calloc alien: ', err]}}! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
address ^<Integer>

	^self size <= 0
		ifTrue: [{{self primitiveAlienAddress}}]
		ifFalse: [self error: 'One cannot take the address of direct Alien instances; they may move']! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
addressField ^<Integer>

	^{{self primitiveAlienAddress}}! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
address ^<Integer>

	^self size <= 0
		ifTrue: [self addressField]
		ifFalse: [self error: 'One cannot take the address of direct Alien instances; they may move']! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
addressField: anInteger <Integer>

	{{self primitiveAlienAddress: anInteger}}! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
atAddress: pointer <Integer> ^<X>

	^(self primitiveNew: 4)
		size: self dataSize negated;
		addressField: pointer;
		yourself! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
atAddress: pointer <Integer> dataSize: dataSize <Integer> ^<X>

	^(self primitiveNew: 4)
		size: dataSize negated;
		addressField: pointer;
		yourself! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
forPointer: pointer <Integer> ^<X>

	^(self primitiveNew: 4)
		size: 0;
		addressField: pointer;
		yourself! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
newC: size <Integer> ^ <X>

	^(self primitiveNew: 4)
		size: size negated;
		addressField: (self Ccalloc: size);
		initialize! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
newGC: size <Integer> ^<X>

	| alien address |
	alien := self primitiveNew: 4.
	alien size: size negated.
	address := self Ccalloc: size.
	GCMallocedAliens add: alien finalizing: address.
	^alien
		addressField: address;
		initialize
		! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
rawNewC: size <Integer> ^ <X>

	^(self primitiveNew: 4)
		size: size negated;
		addressField: (self Cmalloc: size);
		initialize! !

"August 13, 2009 -> 22:18:39"!

(Delta mirrorFor: #Alien) removeMethod: #address: ifAbsent: [] !


"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedByteAt: index <Integer> ^<Integer>

	^self at: index! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedByteAt: index <Integer> put: byte <Integer> ^<Integer>

	^self at: index put: byte! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedByteAt: index <Integer> ^<Integer>

	|byte|
	byte := self at: index.
	^byte < 128
		ifTrue: [byte]
		ifFalse: [256 - byte]! !

"August 13, 2009 -> 22:18:39"!

Delta define: #AlienTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 13, 2009 -> 22:18:39"!

Delta define: #AlienTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 13, 2009 -> 22:18:39"!

Delta define: #AlienTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 13, 2009 -> 22:18:39"!

Delta define: #AlienTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 13, 2009 -> 22:18:39"!

Delta define: #AlienTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 13, 2009 -> 22:18:39"!

Delta define: #AlienTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 13, 2009 -> 22:18:39"!

Delta define: #AlienTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 13, 2009 -> 22:18:39"!

Delta define: #AlienTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 13, 2009 -> 22:18:39"!

Delta define: #AlienTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'alien')) !


"August 13, 2009 -> 22:18:39"!

Delta define: #AlienTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'alien')) !


"August 13, 2009 -> 22:18:39"!

Delta define: #AlienTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'alien')) !


"August 13, 2009 -> 22:18:39"!

Delta define: #AlienTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'alien')) !


"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'fixture' !
setUp

	alien := Alien new: 4! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedByteAccess

	alien unsignedByteAt: 1 put: 1.
	alien unsignedByteAt: 2 put: 2.
	alien unsignedByteAt: 3 put: 3.
	alien unsignedByteAt: 4 put: 4.
	self assert: (alien unsignedByteAt: 1) == 1! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedByteAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: index].
	1 to: 4 do: [:index|
		self assert: (alien unsignedByteAt: index) == index]! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedByteAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: index].
	1 to: 4 do: [:index|
		self assert: (alien unsignedByteAt: index) == index]! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedByteAccess

	1 to: 4 do: [:index|
		alien signedByteAt: index put: index].
	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index) == index]! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedByteAt: index <Integer> put: byte <Integer> ^<Integer>

	^self at: index put: (byte < 0 ifTrue: [byte + 256] ifFalse: [byte])! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedByteAccess

	1 to: 4 do: [:index|
		alien signedByteAt: index put: index].
	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index) == index].
	1 to: 4 do: [:index|
		alien signedByteAt: index put: index negated].
	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index) == index negated].! !

"August 13, 2009 -> 22:18:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedByteAt: index <Integer> put: byte <Integer> ^<Integer>

	^self at: index put: (byte < 0 ifTrue: [byte - 256] ifFalse: [byte])! !

"August 13, 2009 -> 22:18:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedByteAt: index <Integer> put: byte <Integer> ^<Integer>

	^self at: index put: (byte < 0 ifTrue: [byte + 256] ifFalse: [byte])! !

"August 13, 2009 -> 22:18:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedByteAt: index <Integer> ^<Integer>

	|byte|
	byte := self at: index.
	^byte < 128
		ifTrue: [byte]
		ifFalse: [(256 - byte) negated]! !

"August 13, 2009 -> 22:18:40"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: index].
	self assert: (alien unsignedShortAt: 1) == (2 * 256 + 1)! !

"August 13, 2009 -> 22:19:9"!

"System saved" !
"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> ^<Integer>

	^(self at: index) + (self at: index + 1) * 256! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> ^<Integer>

	^(self at: index) + ((self at: index + 1) * 256)! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: index].
	self assert: (alien unsignedShortAt: 1) == (2 * 256 + 1).
	alien unsignedShortAt: 2 put: 65535.
	self assert: (alien unsignedByteAt: 2) == 255.
	self assert: (alien unsignedByteAt: 3) == 255! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> put: short <Integer>^<Integer>

	^(self at: index) + ((self at: index + 1) * 256)! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> put: short <Integer>^<Integer>

	self at: index put: (short \\ 256).
	self at: index + 1 put: (short / 256).
	^short! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> put: short <Integer>^<Integer>

	self at: index put: (short \\ 256).
	self at: index + 1 put: (short // 256).
	^short! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: index].
	self assert: (alien unsignedShortAt: 1) == (2 * 256 + 1).
	self assert: (alien unsignedShortAt: 2 put: 65535) == 65535.
	self assert: (alien unsignedByteAt: 2) == 255.
	self assert: (alien unsignedByteAt: 3) == 255! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedByteAccess

	1 to: 4 do: [:index|
		self assert: (alien unsignedByteAt: index put: index) == index].
	1 to: 4 do: [:index|
		self assert: (alien unsignedByteAt: index) == index]! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedByteAt: index <Integer> put: byte <Integer> ^<Integer>

	self at: index put: byte.
	^byte! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedByteAccess

	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index put: index) == index].
	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index) == index].
	1 to: 4 do: [:index|
		alien signedByteAt: index put: index negated].
	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index) == index negated].! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedByteAt: index <Integer> put: byte <Integer> ^<Integer>

	self at: index put: (byte < 0 ifTrue: [byte + 256] ifFalse: [byte]).
	^byte! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: 255].
	self assert: (alien signedShortAt: 1) == -1! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> ^<Integer>

	|unsigned|
	unsigned := (self at: index) + ((self at: index + 1) * 256).
	^unsigned < 32768
		ifTrue: [unsigned]
		ifFalse: [65536 - unsigned]! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> ^<Integer>

	|unsigned|
	unsigned := (self at: index) + ((self at: index + 1) * 256).
	^unsigned < 32768
		ifTrue: [unsigned]
		ifFalse: [unsigned - 65536]! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: 255].
	self assert: (alien signedShortAt: 1) == -1
	self assert: (alien signedShortAt: 1 put: 255) == 255.
	self assert: (alien signedShortAt: 1) == 255! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> put: short <Integer> ^<Integer>

	|unsigned|
	unsigned := (self at: index) + ((self at: index + 1) * 256).
	^unsigned < 32768
		ifTrue: [unsigned]
		ifFalse: [unsigned - 65536]! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> put: short <Integer> ^<Integer>

	|unsigned|
	unsigned := short < 0
		ifTrue: [65536 + short]
		ifFalse: [short]
	self unsignedShortAt: index put: unsigned.
	^short! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> put: short <Integer> ^<Integer>

	|unsigned|
	unsigned := short < 0
		ifTrue: [65536 + short]
		ifFalse: [short].
	self unsignedShortAt: index put: unsigned.
	^short! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: 255].
	self assert: (alien signedShortAt: 1) == -1.
	self assert: (alien signedShortAt: 1 put: 255) == 255.
	self assert: (alien signedShortAt: 1) == 255! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedLongAccess

	|long|
	long := 256 * 256 + 1.
	self assert: (alien unsignedLongAt: 1 put: long) == long.! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedLongAt: index <Integer> put: long <Integer>^<Integer>

	self unsignedShortAt: index put: (long \\ (256 * 256)).
	self unsignedShortAt: index + 2 put: (long // (256 * 256)).
	^long! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedLongAccess

	|long|
	long := 256 * 256 + 1.
	self assert: (alien unsignedLongAt: 1 put: long) == long.
	self assert: (alien unsignedLongAt: 1) == long! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedLongAt: index <Integer> ^<Integer>

	^(self unsignedShortAt: index) + ((self unsignedShortAt: index + 2) * (256 * 256))! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedLongAccess

	|long|
	long := 256 * 256 + 1.
	self assert: (alien unsignedLongAt: 1 put: long) == long.
	self assert: (alien unsignedLongAt: 1) == long
	self assert: (alien unsignedByteAt: 1) == 1.
	self assert: (alien unsignedByteAt: 3) == 1! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedLongAccess

	|long|
	long := 256 * 256 + 1.
	self assert: (alien unsignedLongAt: 1 put: long) == long.
	self assert: (alien unsignedLongAt: 1) == long.
	self assert: (alien unsignedByteAt: 1) == 1.
	self assert: (alien unsignedByteAt: 3) == 1! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedByteAccess

	1 to: 4 do: [:index|
		self assert: (alien unsignedByteAt: index put: index) == index].
	1 to: 4 do: [:index|
		self assert: (alien unsignedByteAt: index) == index].
	self assert: (alien asUnsignedByte == 1)! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
asUnsignedByte

	^self unsignedByteAt: 1! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedByteAccess

	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index put: index) == index].
	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index) == index].
	1 to: 4 do: [:index|
		alien signedByteAt: index put: index negated].
	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index) == index negated].
	self assert: alien asSignedByte == -1! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
asSignedByte

	^self signedByteAt: 1! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: index].
	self assert: (alien unsignedShortAt: 1) == (2 * 256 + 1).
	self assert: (alien unsignedShortAt: 2 put: 65535) == 65535.
	self assert: (alien unsignedByteAt: 2) == 255.
	self assert: (alien unsignedByteAt: 3) == 255.
	self assert: alien asUnsignedShort == (2 * 256 + 1)! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
asUnsignedShort

	^self unsignedShortAt: 1! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: index].
	self assert: (alien unsignedShortAt: 1) == (2 * 256 + 1).
	self assert: (alien unsignedShortAt: 2 put: 65535) == 65535.
	self assert: (alien unsignedByteAt: 2) == 255.
	self assert: (alien unsignedByteAt: 3) == 255.
	self assert: alien asUnsignedShort == (255 * 256 + 1)! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: 255].
	self assert: (alien signedShortAt: 1) == -1.
	self assert: (alien signedShortAt: 1 put: 255) == 255.
	self assert: (alien signedShortAt: 1) == 255.
	self assert: alien asSignedShort == 255! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
asSignedShort

	^self signedShortAt: 1! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedLongAccess

	|long|
	long := (256 * 256 + 1) negated.
	self assert: (alien signedLongAt: 1 put: long) == long.
	self assert: (alien signedLongAt: 1) == long.
	self assert: (alien unsignedByteAt: 1) == 255.
	self assert: (alien unsignedByteAt: 3) == 254! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedLongAt: index <Integer> put: long <Integer>^<Integer>

	|unsigned|
	unsigned := long < 0
		ifTrue: [(256 * 256 * 256 * 256) + long]
		ifFalse: [long].
	self unsignedLongAt: index put: unsigned.
	^long! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedLongAt: index <Integer> put: long <Integer>^<Integer>

	|unsigned|
	unsigned := long < 0
		ifTrue: [4294967296 + long]
		ifFalse: [long].
	self unsignedLongAt: index put: unsigned.
	^long! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedLongAt: index <Integer> ^<Integer>

	|unsigned|
	unsigned := (self unsignedShortAt: index) + ((self unsignedShortAt: index + 2) * 65536).
	^unsigned < 2147483648
		ifTrue: [unsigned]
		ifFalse: [unsigned - 4294967296]! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedLongAccess

	|long|
	long := (256 * 256 + 1) negated.
	self assert: (alien signedLongAt: 1 put: long) = long.
	self assert: (alien signedLongAt: 1) = long.
	self assert: (alien unsignedByteAt: 1) == 255.
	self assert: (alien unsignedByteAt: 3) == 254! !

"August 16, 2009 -> 1:26:3"!

Delta define: #LargeIntegerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #LargeIntegerTest) methodsFor: 'testing' !
testUnderflow

	self deny: SmallInteger maxVal + 1 * 8 - 1 = -1! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #LargeIntegerTest) methodsFor: 'testing' !
testUnderflow

	self deny: SmallInteger maxVal + 1 * 8 + 1 negated = -1! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #LargeIntegerTest) methodsFor: 'testing' !
testUnderflow

	self deny: SmallInteger maxVal + 1 * 8 + 1 negated = -1! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> ^<Integer>

	^(self at: index) + (self at: index + 1) * 256! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> ^<Integer>

	^(self at: index) + ((self at: index + 1) * 256)! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: index].
	self assert: (alien unsignedShortAt: 1) == (2 * 256 + 1).
	alien unsignedShortAt: 2 put: 65535.
	self assert: (alien unsignedByteAt: 2) == 255.
	self assert: (alien unsignedByteAt: 3) == 255! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> put: short <Integer>^<Integer>

	^(self at: index) + ((self at: index + 1) * 256)! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> put: short <Integer>^<Integer>

	self at: index put: (short \\ 256).
	self at: index + 1 put: (short / 256).
	^short! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> put: short <Integer>^<Integer>

	self at: index put: (short \\ 256).
	self at: index + 1 put: (short // 256).
	^short! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: index].
	self assert: (alien unsignedShortAt: 1) == (2 * 256 + 1).
	self assert: (alien unsignedShortAt: 2 put: 65535) == 65535.
	self assert: (alien unsignedByteAt: 2) == 255.
	self assert: (alien unsignedByteAt: 3) == 255! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedByteAccess

	1 to: 4 do: [:index|
		self assert: (alien unsignedByteAt: index put: index) == index].
	1 to: 4 do: [:index|
		self assert: (alien unsignedByteAt: index) == index]! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedByteAt: index <Integer> put: byte <Integer> ^<Integer>

	self at: index put: byte.
	^byte! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedByteAccess

	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index put: index) == index].
	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index) == index].
	1 to: 4 do: [:index|
		alien signedByteAt: index put: index negated].
	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index) == index negated].! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedByteAt: index <Integer> put: byte <Integer> ^<Integer>

	self at: index put: (byte < 0 ifTrue: [byte + 256] ifFalse: [byte]).
	^byte! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: 255].
	self assert: (alien signedShortAt: 1) == -1! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> ^<Integer>

	|unsigned|
	unsigned := (self at: index) + ((self at: index + 1) * 256).
	^unsigned < 32768
		ifTrue: [unsigned]
		ifFalse: [65536 - unsigned]! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> ^<Integer>

	|unsigned|
	unsigned := (self at: index) + ((self at: index + 1) * 256).
	^unsigned < 32768
		ifTrue: [unsigned]
		ifFalse: [unsigned - 65536]! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: 255].
	self assert: (alien signedShortAt: 1) == -1
	self assert: (alien signedShortAt: 1 put: 255) == 255.
	self assert: (alien signedShortAt: 1) == 255! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> put: short <Integer> ^<Integer>

	|unsigned|
	unsigned := (self at: index) + ((self at: index + 1) * 256).
	^unsigned < 32768
		ifTrue: [unsigned]
		ifFalse: [unsigned - 65536]! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> put: short <Integer> ^<Integer>

	|unsigned|
	unsigned := short < 0
		ifTrue: [65536 + short]
		ifFalse: [short]
	self unsignedShortAt: index put: unsigned.
	^short! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> put: short <Integer> ^<Integer>

	|unsigned|
	unsigned := short < 0
		ifTrue: [65536 + short]
		ifFalse: [short].
	self unsignedShortAt: index put: unsigned.
	^short! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: 255].
	self assert: (alien signedShortAt: 1) == -1.
	self assert: (alien signedShortAt: 1 put: 255) == 255.
	self assert: (alien signedShortAt: 1) == 255! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedLongAccess

	|long|
	long := 256 * 256 + 1.
	self assert: (alien unsignedLongAt: 1 put: long) == long.! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedLongAt: index <Integer> put: long <Integer>^<Integer>

	self unsignedShortAt: index put: (long \\ (256 * 256)).
	self unsignedShortAt: index + 2 put: (long // (256 * 256)).
	^long! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedLongAccess

	|long|
	long := 256 * 256 + 1.
	self assert: (alien unsignedLongAt: 1 put: long) == long.
	self assert: (alien unsignedLongAt: 1) == long! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedLongAt: index <Integer> ^<Integer>

	^(self unsignedShortAt: index) + ((self unsignedShortAt: index + 2) * (256 * 256))! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedLongAccess

	|long|
	long := 256 * 256 + 1.
	self assert: (alien unsignedLongAt: 1 put: long) == long.
	self assert: (alien unsignedLongAt: 1) == long
	self assert: (alien unsignedByteAt: 1) == 1.
	self assert: (alien unsignedByteAt: 3) == 1! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedLongAccess

	|long|
	long := 256 * 256 + 1.
	self assert: (alien unsignedLongAt: 1 put: long) == long.
	self assert: (alien unsignedLongAt: 1) == long.
	self assert: (alien unsignedByteAt: 1) == 1.
	self assert: (alien unsignedByteAt: 3) == 1! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedByteAccess

	1 to: 4 do: [:index|
		self assert: (alien unsignedByteAt: index put: index) == index].
	1 to: 4 do: [:index|
		self assert: (alien unsignedByteAt: index) == index].
	self assert: (alien asUnsignedByte == 1)! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
asUnsignedByte

	^self unsignedByteAt: 1! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedByteAccess

	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index put: index) == index].
	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index) == index].
	1 to: 4 do: [:index|
		alien signedByteAt: index put: index negated].
	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index) == index negated].
	self assert: alien asSignedByte == -1! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
asSignedByte

	^self signedByteAt: 1! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: index].
	self assert: (alien unsignedShortAt: 1) == (2 * 256 + 1).
	self assert: (alien unsignedShortAt: 2 put: 65535) == 65535.
	self assert: (alien unsignedByteAt: 2) == 255.
	self assert: (alien unsignedByteAt: 3) == 255.
	self assert: alien asUnsignedShort == (2 * 256 + 1)! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
asUnsignedShort

	^self unsignedShortAt: 1! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: index].
	self assert: (alien unsignedShortAt: 1) == (2 * 256 + 1).
	self assert: (alien unsignedShortAt: 2 put: 65535) == 65535.
	self assert: (alien unsignedByteAt: 2) == 255.
	self assert: (alien unsignedByteAt: 3) == 255.
	self assert: alien asUnsignedShort == (255 * 256 + 1)! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: 255].
	self assert: (alien signedShortAt: 1) == -1.
	self assert: (alien signedShortAt: 1 put: 255) == 255.
	self assert: (alien signedShortAt: 1) == 255.
	self assert: alien asSignedShort == 255! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
asSignedShort

	^self signedShortAt: 1! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> ^<Integer>

	^(self at: index) + (self at: index + 1) * 256! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> ^<Integer>

	^(self at: index) + ((self at: index + 1) * 256)! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: index].
	self assert: (alien unsignedShortAt: 1) == (2 * 256 + 1).
	alien unsignedShortAt: 2 put: 65535.
	self assert: (alien unsignedByteAt: 2) == 255.
	self assert: (alien unsignedByteAt: 3) == 255! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> put: short <Integer>^<Integer>

	^(self at: index) + ((self at: index + 1) * 256)! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> put: short <Integer>^<Integer>

	self at: index put: (short \\ 256).
	self at: index + 1 put: (short / 256).
	^short! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> put: short <Integer>^<Integer>

	self at: index put: (short \\ 256).
	self at: index + 1 put: (short // 256).
	^short! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: index].
	self assert: (alien unsignedShortAt: 1) == (2 * 256 + 1).
	self assert: (alien unsignedShortAt: 2 put: 65535) == 65535.
	self assert: (alien unsignedByteAt: 2) == 255.
	self assert: (alien unsignedByteAt: 3) == 255! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedByteAccess

	1 to: 4 do: [:index|
		self assert: (alien unsignedByteAt: index put: index) == index].
	1 to: 4 do: [:index|
		self assert: (alien unsignedByteAt: index) == index]! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedByteAt: index <Integer> put: byte <Integer> ^<Integer>

	self at: index put: byte.
	^byte! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedByteAccess

	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index put: index) == index].
	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index) == index].
	1 to: 4 do: [:index|
		alien signedByteAt: index put: index negated].
	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index) == index negated].! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedByteAt: index <Integer> put: byte <Integer> ^<Integer>

	self at: index put: (byte < 0 ifTrue: [byte + 256] ifFalse: [byte]).
	^byte! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: 255].
	self assert: (alien signedShortAt: 1) == -1! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> ^<Integer>

	|unsigned|
	unsigned := (self at: index) + ((self at: index + 1) * 256).
	^unsigned < 32768
		ifTrue: [unsigned]
		ifFalse: [65536 - unsigned]! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> ^<Integer>

	|unsigned|
	unsigned := (self at: index) + ((self at: index + 1) * 256).
	^unsigned < 32768
		ifTrue: [unsigned]
		ifFalse: [unsigned - 65536]! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: 255].
	self assert: (alien signedShortAt: 1) == -1
	self assert: (alien signedShortAt: 1 put: 255) == 255.
	self assert: (alien signedShortAt: 1) == 255! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> put: short <Integer> ^<Integer>

	|unsigned|
	unsigned := (self at: index) + ((self at: index + 1) * 256).
	^unsigned < 32768
		ifTrue: [unsigned]
		ifFalse: [unsigned - 65536]! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> put: short <Integer> ^<Integer>

	|unsigned|
	unsigned := short < 0
		ifTrue: [65536 + short]
		ifFalse: [short]
	self unsignedShortAt: index put: unsigned.
	^short! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> put: short <Integer> ^<Integer>

	|unsigned|
	unsigned := short < 0
		ifTrue: [65536 + short]
		ifFalse: [short].
	self unsignedShortAt: index put: unsigned.
	^short! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: 255].
	self assert: (alien signedShortAt: 1) == -1.
	self assert: (alien signedShortAt: 1 put: 255) == 255.
	self assert: (alien signedShortAt: 1) == 255! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedLongAccess

	|long|
	long := 256 * 256 + 1.
	self assert: (alien unsignedLongAt: 1 put: long) == long.! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedLongAt: index <Integer> put: long <Integer>^<Integer>

	self unsignedShortAt: index put: (long \\ (256 * 256)).
	self unsignedShortAt: index + 2 put: (long // (256 * 256)).
	^long! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedLongAccess

	|long|
	long := 256 * 256 + 1.
	self assert: (alien unsignedLongAt: 1 put: long) == long.
	self assert: (alien unsignedLongAt: 1) == long! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedLongAt: index <Integer> ^<Integer>

	^(self unsignedShortAt: index) + ((self unsignedShortAt: index + 2) * (256 * 256))! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedLongAccess

	|long|
	long := 256 * 256 + 1.
	self assert: (alien unsignedLongAt: 1 put: long) == long.
	self assert: (alien unsignedLongAt: 1) == long
	self assert: (alien unsignedByteAt: 1) == 1.
	self assert: (alien unsignedByteAt: 3) == 1! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedLongAccess

	|long|
	long := 256 * 256 + 1.
	self assert: (alien unsignedLongAt: 1 put: long) == long.
	self assert: (alien unsignedLongAt: 1) == long.
	self assert: (alien unsignedByteAt: 1) == 1.
	self assert: (alien unsignedByteAt: 3) == 1! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedByteAccess

	1 to: 4 do: [:index|
		self assert: (alien unsignedByteAt: index put: index) == index].
	1 to: 4 do: [:index|
		self assert: (alien unsignedByteAt: index) == index].
	self assert: (alien asUnsignedByte == 1)! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
asUnsignedByte

	^self unsignedByteAt: 1! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedByteAccess

	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index put: index) == index].
	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index) == index].
	1 to: 4 do: [:index|
		alien signedByteAt: index put: index negated].
	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index) == index negated].
	self assert: alien asSignedByte == -1! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
asSignedByte

	^self signedByteAt: 1! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: index].
	self assert: (alien unsignedShortAt: 1) == (2 * 256 + 1).
	self assert: (alien unsignedShortAt: 2 put: 65535) == 65535.
	self assert: (alien unsignedByteAt: 2) == 255.
	self assert: (alien unsignedByteAt: 3) == 255.
	self assert: alien asUnsignedShort == (2 * 256 + 1)! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
asUnsignedShort

	^self unsignedShortAt: 1! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: index].
	self assert: (alien unsignedShortAt: 1) == (2 * 256 + 1).
	self assert: (alien unsignedShortAt: 2 put: 65535) == 65535.
	self assert: (alien unsignedByteAt: 2) == 255.
	self assert: (alien unsignedByteAt: 3) == 255.
	self assert: alien asUnsignedShort == (255 * 256 + 1)! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: 255].
	self assert: (alien signedShortAt: 1) == -1.
	self assert: (alien signedShortAt: 1 put: 255) == 255.
	self assert: (alien signedShortAt: 1) == 255.
	self assert: alien asSignedShort == 255! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
asSignedShort

	^self signedShortAt: 1! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> ^<Integer>

	^(self at: index) + (self at: index + 1) * 256! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> ^<Integer>

	^(self at: index) + ((self at: index + 1) * 256)! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: index].
	self assert: (alien unsignedShortAt: 1) == (2 * 256 + 1).
	alien unsignedShortAt: 2 put: 65535.
	self assert: (alien unsignedByteAt: 2) == 255.
	self assert: (alien unsignedByteAt: 3) == 255! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> put: short <Integer>^<Integer>

	^(self at: index) + ((self at: index + 1) * 256)! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> put: short <Integer>^<Integer>

	self at: index put: (short \\ 256).
	self at: index + 1 put: (short / 256).
	^short! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> put: short <Integer>^<Integer>

	self at: index put: (short \\ 256).
	self at: index + 1 put: (short // 256).
	^short! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: index].
	self assert: (alien unsignedShortAt: 1) == (2 * 256 + 1).
	self assert: (alien unsignedShortAt: 2 put: 65535) == 65535.
	self assert: (alien unsignedByteAt: 2) == 255.
	self assert: (alien unsignedByteAt: 3) == 255! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedByteAccess

	1 to: 4 do: [:index|
		self assert: (alien unsignedByteAt: index put: index) == index].
	1 to: 4 do: [:index|
		self assert: (alien unsignedByteAt: index) == index]! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedByteAt: index <Integer> put: byte <Integer> ^<Integer>

	self at: index put: byte.
	^byte! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedByteAccess

	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index put: index) == index].
	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index) == index].
	1 to: 4 do: [:index|
		alien signedByteAt: index put: index negated].
	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index) == index negated].! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedByteAt: index <Integer> put: byte <Integer> ^<Integer>

	self at: index put: (byte < 0 ifTrue: [byte + 256] ifFalse: [byte]).
	^byte! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: 255].
	self assert: (alien signedShortAt: 1) == -1! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> ^<Integer>

	|unsigned|
	unsigned := (self at: index) + ((self at: index + 1) * 256).
	^unsigned < 32768
		ifTrue: [unsigned]
		ifFalse: [65536 - unsigned]! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> ^<Integer>

	|unsigned|
	unsigned := (self at: index) + ((self at: index + 1) * 256).
	^unsigned < 32768
		ifTrue: [unsigned]
		ifFalse: [unsigned - 65536]! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: 255].
	self assert: (alien signedShortAt: 1) == -1
	self assert: (alien signedShortAt: 1 put: 255) == 255.
	self assert: (alien signedShortAt: 1) == 255! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> put: short <Integer> ^<Integer>

	|unsigned|
	unsigned := (self at: index) + ((self at: index + 1) * 256).
	^unsigned < 32768
		ifTrue: [unsigned]
		ifFalse: [unsigned - 65536]! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> put: short <Integer> ^<Integer>

	|unsigned|
	unsigned := short < 0
		ifTrue: [65536 + short]
		ifFalse: [short]
	self unsignedShortAt: index put: unsigned.
	^short! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> put: short <Integer> ^<Integer>

	|unsigned|
	unsigned := short < 0
		ifTrue: [65536 + short]
		ifFalse: [short].
	self unsignedShortAt: index put: unsigned.
	^short! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: 255].
	self assert: (alien signedShortAt: 1) == -1.
	self assert: (alien signedShortAt: 1 put: 255) == 255.
	self assert: (alien signedShortAt: 1) == 255! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedLongAccess

	|long|
	long := 256 * 256 + 1.
	self assert: (alien unsignedLongAt: 1 put: long) == long.! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedLongAt: index <Integer> put: long <Integer>^<Integer>

	self unsignedShortAt: index put: (long \\ (256 * 256)).
	self unsignedShortAt: index + 2 put: (long // (256 * 256)).
	^long! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedLongAccess

	|long|
	long := 256 * 256 + 1.
	self assert: (alien unsignedLongAt: 1 put: long) == long.
	self assert: (alien unsignedLongAt: 1) == long! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedLongAt: index <Integer> ^<Integer>

	^(self unsignedShortAt: index) + ((self unsignedShortAt: index + 2) * (256 * 256))! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedLongAccess

	|long|
	long := 256 * 256 + 1.
	self assert: (alien unsignedLongAt: 1 put: long) == long.
	self assert: (alien unsignedLongAt: 1) == long
	self assert: (alien unsignedByteAt: 1) == 1.
	self assert: (alien unsignedByteAt: 3) == 1! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedLongAccess

	|long|
	long := 256 * 256 + 1.
	self assert: (alien unsignedLongAt: 1 put: long) == long.
	self assert: (alien unsignedLongAt: 1) == long.
	self assert: (alien unsignedByteAt: 1) == 1.
	self assert: (alien unsignedByteAt: 3) == 1! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedByteAccess

	1 to: 4 do: [:index|
		self assert: (alien unsignedByteAt: index put: index) == index].
	1 to: 4 do: [:index|
		self assert: (alien unsignedByteAt: index) == index].
	self assert: (alien asUnsignedByte == 1)! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
asUnsignedByte

	^self unsignedByteAt: 1! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedByteAccess

	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index put: index) == index].
	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index) == index].
	1 to: 4 do: [:index|
		alien signedByteAt: index put: index negated].
	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index) == index negated].
	self assert: alien asSignedByte == -1! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
asSignedByte

	^self signedByteAt: 1! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: index].
	self assert: (alien unsignedShortAt: 1) == (2 * 256 + 1).
	self assert: (alien unsignedShortAt: 2 put: 65535) == 65535.
	self assert: (alien unsignedByteAt: 2) == 255.
	self assert: (alien unsignedByteAt: 3) == 255.
	self assert: alien asUnsignedShort == (2 * 256 + 1)! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
asUnsignedShort

	^self unsignedShortAt: 1! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: index].
	self assert: (alien unsignedShortAt: 1) == (2 * 256 + 1).
	self assert: (alien unsignedShortAt: 2 put: 65535) == 65535.
	self assert: (alien unsignedByteAt: 2) == 255.
	self assert: (alien unsignedByteAt: 3) == 255.
	self assert: alien asUnsignedShort == (255 * 256 + 1)! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: 255].
	self assert: (alien signedShortAt: 1) == -1.
	self assert: (alien signedShortAt: 1 put: 255) == 255.
	self assert: (alien signedShortAt: 1) == 255.
	self assert: alien asSignedShort == 255! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
asSignedShort

	^self signedShortAt: 1! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedLongAccess

	|long|
	long := (256 * 256 + 1) negated.
	self assert: (alien signedLongAt: 1 put: long) == long.
	self assert: (alien signedLongAt: 1) == long.
	self assert: (alien unsignedByteAt: 1) == 255.
	self assert: (alien unsignedByteAt: 3) == 254! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedLongAt: index <Integer> put: long <Integer>^<Integer>

	|unsigned|
	unsigned := long < 0
		ifTrue: [(256 * 256 * 256 * 256) + long]
		ifFalse: [long].
	self unsignedLongAt: index put: unsigned.
	^long! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedLongAt: index <Integer> put: long <Integer>^<Integer>

	|unsigned|
	unsigned := long < 0
		ifTrue: [4294967296 + long]
		ifFalse: [long].
	self unsignedLongAt: index put: unsigned.
	^long! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedLongAt: index <Integer> ^<Integer>

	|unsigned|
	unsigned := (self unsignedShortAt: index) + ((self unsignedShortAt: index + 2) * 65536).
	^unsigned < 2147483648
		ifTrue: [unsigned]
		ifFalse: [unsigned - 4294967296]! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedLongAccess

	|long|
	long := (256 * 256 + 1) negated.
	self assert: (alien signedLongAt: 1 put: long) = long.
	self assert: (alien signedLongAt: 1) = long.
	self assert: (alien unsignedByteAt: 1) == 255.
	self assert: (alien unsignedByteAt: 3) == 254! !

"August 16, 2009 -> 1:27:35"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
smallIntLimit

	^SmallInteger maxVal + 1! !

"August 16, 2009 -> 1:28:32"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
fourByteLimit

	^self smallIntLimit * 8! !

"August 16, 2009 -> 1:28:54"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
unsignedFourByteLimit

	^self smallIntLimit * 8! !

"August 16, 2009 -> 1:29:7"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
signedFourByteLimit

	^self smallIntLimit * 4! !

"August 16, 2009 -> 1:29:14"!

(Delta mirrorFor: #Alien) removeMethod: #fourByteLimit ifAbsent: [] !


"August 16, 2009 -> 1:30:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedLongAt: index <Integer> ^<Integer>

	|unsigned|
	unsigned := (self unsignedShortAt: index) + ((self unsignedShortAt: index + 2) * 65536).
	^unsigned < self signedFourByteLimit
		ifTrue: [unsigned]
		ifFalse: [unsigned - self unsignedFourByteLimit]! !

"August 16, 2009 -> 1:30:16"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedLongAt: index <Integer> put: long <Integer>^<Integer>

	|unsigned|
	unsigned := long < 0
		ifTrue: [self unsignedFourByteLimit + long]
		ifFalse: [long].
	self unsignedLongAt: index put: unsigned.
	^long! !

"August 16, 2009 -> 1:35:48"!

"System saved" !
"August 16, 2009 -> 1:39:5"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedLongAccess

	|long|
	long := (256 * 256 + 1) negated.
	self assert: (alien signedLongAt: 1 put: long) = long.
	self assert: (alien signedLongAt: 1) = long.
	self assert: (alien unsignedByteAt: 1) == 255.
	self assert: (alien unsignedByteAt: 3) == 254.
	self assert: alien asSignedLong = long! !

"August 16, 2009 -> 1:39:36"!

! (Delta mirrorFor: #Alien) methodsFor: 'converting' !
asSignedLong

	^self signedLongAt: 1! !

"August 16, 2009 -> 1:40:29"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedLongAccess

	|long|
	long := 256 * 256 + 1.
	self assert: (alien unsignedLongAt: 1 put: long) == long.
	self assert: (alien unsignedLongAt: 1) == long.
	self assert: (alien unsignedByteAt: 1) == 1.
	self assert: (alien unsignedByteAt: 3) == 1.
	self assert: alien asUnsignedLong = long! !

"August 16, 2009 -> 1:41:8"!

! (Delta mirrorFor: #Alien) methodsFor: 'converting' !
asUnsignedLong

	^self unsignedLongAt: 1! !

"August 16, 2009 -> 1:42:36"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testDataSize

	self assert: alien dataSize == 4! !

"August 16, 2009 -> 1:42:56"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
dataSize ^<Integer>

	^self size abs! !

"August 16, 2009 -> 1:45:6"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testBoolAccess

	self assert: (alien boolAt: 1 put: true).
	self assert: (alien boolAt: 1).
	self deny: (alien boolAt: 1 put: false).
	self deny: (alien boolAt: 1)! !

"August 16, 2009 -> 1:46:52"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
boolAt: index <Integer> put: value <Boolean> ^<Boolean>

	self at: 1 put: (value ifTrue: [1] ifFalse: [0]).
	^value! !

"August 16, 2009 -> 1:47:43"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
boolAt: index <Integer> ^<Boolean>

	^(self at: 1) ~~ 0! !

"August 16, 2009 -> 1:49:12"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testAsAlien

	self assert: alien asAlien == alien! !

"August 16, 2009 -> 1:49:32"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
asAlien

	^self! !

"August 16, 2009 -> 2:9:26"!

"System saved" !
"August 16, 2009 -> 19:50:21"!

"System saved" !
"August 16, 2009 -> 19:58:6"!

Delta define: #PointerAlienTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 16, 2009 -> 19:58:20"!

Delta define: #PointerAlienTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'pointer')) !


"August 16, 2009 -> 19:59:13"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'fixture' !
setUp

	pointer := Alien forPointer: (Alien Ccalloc: 4)! !

"August 16, 2009 -> 20:0:3"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'fixture' !
tearDown

	pointer free! !

"August 16, 2009 -> 20:0:31"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'testing' !
testIsPointer

	self assert: pointer isPointer! !

"August 16, 2009 -> 20:2:31"!

"System saved" !
"August 18, 2009 -> 21:7:19"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
addressField: anInteger <Integer>

	self signedLongAt: 1 put: anInteger! !

"August 18, 2009 -> 21:7:19"!

! (Delta mirrorFor: #Alien) methodsFor: 'testing' !
isPointer

	^self size == 0! !

"August 18, 2009 -> 21:7:19"!

! (Delta mirrorFor: #Alien) methodsFor: 'deallocation' !
free! !

"August 18, 2009 -> 21:7:19"!

! (Delta mirrorFor: #Alien) methodsFor: 'deallocation' !
free

	{{self primitiveAlienFree}}! !

"August 18, 2009 -> 21:7:19"!

! (Delta mirrorFor: #Alien) methodsFor: 'deallocation' !
free

	{{primitiveAlienFree: self ifFail: [:err| self error: 'Could not free alien']}}! !

"August 18, 2009 -> 21:7:19"!

! (Delta mirrorFor: #Alien) methodsFor: 'deallocation' !
free

	{{primitiveAlienFree: self ifFail: [:err| self error: 'Could not free alien: ', err]}}! !

"August 18, 2009 -> 21:7:19"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
addressField ^<Integer>

	^self signedLongAt: 1! !

"August 18, 2009 -> 21:7:19"!

! (Delta mirrorFor: #Alien) methodsFor: 'deallocation' !
free

	{{primitiveAlienFree: self addressField
		ifFail: [:err| self error: 'Could not free alien: ', err]}}! !

"August 18, 2009 -> 21:7:19"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'testing' !
testFreeingTwiceShouldFail

	pointer free.
	self should: [pointer free] raise: Error! !

"August 18, 2009 -> 21:7:19"!

! (Delta mirrorFor: #Alien) methodsFor: 'deallocation' !
free

	{{primitiveAlienFree: self addressField
		ifFail: [:err| self error: 'Could not free alien: ', err]}}.
	self addressField: 0! !

"August 18, 2009 -> 21:7:19"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'fixture' !
tearDown

	[pointer free]
		on: Error
		do: [:ignore|]! !

"August 18, 2009 -> 21:8:5"!

"System saved" !
"August 22, 2009 -> 14:20:50"!

Delta define: #Mirror as: (
(Class subclassOf: 'Object' instanceVariables: '') abstract) !


"August 22, 2009 -> 14:20:51"!

Delta define: #Mirror as: (
(Class subclassOf: 'Object' instanceVariables: '') abstract) !


"August 22, 2009 -> 14:20:51"!

Delta define: #Mirror as: (
(Class subclassOf: 'Object' instanceVariables: '') abstract) !


"August 22, 2009 -> 14:20:51"!

Delta define: #Mirror as: (
(Class subclassOf: 'Object' instanceVariables: '') abstract) !


"August 22, 2009 -> 14:20:51"!

Delta define: #Mirror as: (
(Class subclassOf: 'Object' instanceVariables: '') abstract) !


"August 22, 2009 -> 14:20:51"!

Delta define: #Mirror as: (
(Class subclassOf: 'Object' instanceVariables: '') abstract) !


"August 22, 2009 -> 14:20:51"!

Delta define: #Mirror as: (
(Class subclassOf: 'Object' instanceVariables: '') abstract) !


"August 22, 2009 -> 14:20:51"!

Delta define: #Mirror as: (
(Class subclassOf: 'Object' instanceVariables: '') abstract) !


"August 22, 2009 -> 14:20:51"!

Delta define: #Mirror as: (
(Class subclassOf: 'Object' instanceVariables: '') abstract) !


"August 22, 2009 -> 14:20:51"!

Delta define: #Mirror as: (
(Class subclassOf: 'Object' instanceVariables: '') abstract) !


"August 22, 2009 -> 14:20:51"!

Delta define: #Mirror as: (
(Class subclassOf: 'Object' instanceVariables: '') abstract) !


"August 22, 2009 -> 14:20:51"!

(Delta mirrorFor: #Mirror)
comment: 
'Mirrors are used in the Strongtalk system as the reflective interface
used to examine objects.  This replaces the way reflection is
done in other Smalltalks, which use a battery of reflective messages
supported by Object and Behavior.  

The reason for this difference is a philisophical one that has an
important benefit.  The philisophical reason is encapsulation: an object''s
interface should be as independent as possible of its implementation.
The benefit is that good encapsulation allows you to create alternative
implementations that behave identically.

But standard Smalltalk violates this principle, because all the reflective
message go through an objects interface (#class, etc),  which means
they are really a hole in the object''s encapsulation.  Mirrors are a way
around this problem.  The idea is that you shouldn''t talk to an object
directly to examine it reflectively, which would violate its interface
encapsulation.  Instead, you ask the system to create a ''mirror'' on that
object, which you can use to ''reflect'' on it (pun).  So if you want to
examine an object o reflectively, you say (Mirror on: o), and the mirror
supports all the reflective operations instead of the object.

This also has the benefit of cleaning up an object''s interface, since it
doesn''t have to support all the reflective messages that the system
(inspectors, etc) uses to manipulate.   This also makes the type system
protocols for objects simpler.

Some of the most common reflective messages in standard Smalltalk-80
(such as #class, #isKindOf:, etc)
are still supported in Strongtalk, but because the system code doesn''t
use them, you are free to reimplement them, so that an object can pretend
to have a different class, for example, without breaking any system code.

Note: the concept (and name) of Mirrors comes from the Self system.

Tags:  %User

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license
'!


"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) classSide methodsFor: 'Unclassified' !
classFor: e < Class | Protocol | Mixin | TypeAlias | GlobalAssociation> ^ <Mirror class>

	"This is not at all object-oriented. However, it maintains the complete separation of
		Mirrors and is quite simple "

(Metaclass == e class class or: [Metaclass == e class]) ifTrue:[^AbstractClassMirror classFor: e].
(Protocol  == e class  or:[ MetaProtocol == e class]) ifTrue:[^ProtocolMirror].
TypeAlias == e class ifTrue:[^TypeAliasMirror].
GlobalAssociation == e class ifTrue:[^GlobalVariableMirror].
^MixinMirror classFor: e
! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) classSide methodsFor: 'Unclassified' !
classReferenceTo: n <Symbol> ^ <DeltaClassId>

^DeltaClassId new setId: n; scope: DeltaGlobals! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) classSide methodsFor: 'Unclassified' !
metaclassReferenceTo: n <Symbol>

^(self classReferenceTo: n) dualClassType! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) classSide methodsFor: 'Unclassified' !
on: element <Class|Mixin|Protocol|TypeAlias|GlobalAssociation> ^ <Instance>

^(self classFor: element) on: element! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
comment  ^ <Str> 

^self sourceInfo comment! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
comment: c  <Str> 

self sourceInfo comment: c
! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
convert: c   <Mirror> ifFail: fb <[Str]>
" The purpose of this method is to convert the definition represented by
the mirror C into myself, if possible. If not, the failure block fb should be
called"
self subclassResponsibility! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
convert: m <Mirror> toGeneric: g   <GenericMirror> ifFail: fb <[Str]>

fb value: 'Cannot convert ', self name, ' into a generic'.! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
convertToClass: c   <ClassMirror> ifFail: fb <[Str]>

fb value: 'Cannot convert ', self name, 'into a class'.! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
convertToGeneric: g <GenericMirror> ifFail: fb <[Str]>

g body convert: self toGeneric: g ifFail: fb.



! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
convertToGenericClass: g <GenericMirror> ifFail: fb <[Str]>

fb value: 'Cannot convert ', self name, ' into a generic class'




! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
convertToGenericMixin: g <GenericMirror> ifFail: fb <[Str]>

fb value: 'Cannot convert ', self name, ' into a generic mirror'
! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
convertToGenericProtocol: g <GenericMirror> ifFail: fb <[Str]>

fb value: 'Cannot convert ', self name, ' into a generic protocol'




! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
convertToGlobalVariable: g <GlobalVariableMirror> ifFail: fb <[Str]>

fb value: 'Cannot convert ', self name, ' into a global variable'.! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
convertToMixin: m <MixinDeclMirror> ifFail: fb <[Str]>

fb value: 'Cannot convert', self name, ' into a mixin'.! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
convertToProtocol: p <ProtocolMirror> ifFail: fb <[Str]>

Delta at: self name put: p reflectee




! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
definitionString   ^ <Str>


self sourceInfo isGeneric ifTrue:[^(GenericMirror new body: self) definitionString].
^self basicDefinitionString.! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
definitionWriterClass ^ <DefinitionWriter class>

^DefinitionWriter! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
fileName  ^<Str>
	^self name, self fileNameExtension! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
fileNameExtension  ^<Str>
	^'.dlt'! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
group ^ <Str>

	"File-out group for definition"
	^self sourceInfo group
! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
group: s <Str>

	"File-out group for definition"
	self sourceInfo group: s
! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
hasTypeInfoLoaded ^ <Boolean>

^Type hasTypeInfoFor: self reflectee! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
isGeneric ^ <Boolean>
    ^ self sourceInfo isGeneric! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
isGeneric: b  <Boolean>
    self sourceInfo isGeneric: b! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
isMeta ^ <Boolean>

self subclassResponsibility! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
mayNeedToUnwind

"Used to mark where we may have to use unwind:protect:
to preserve system integrity"! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
name  ^ <Symbol> 

^self reflectee name! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
name: n <Symbol> ifFail: fb <[Str]>
"i"
"This method can be invoked by the Delta environment to create a  class
named n based upon the source code information in this object.
Handling differs depending on whether an entity named n already exists or not.
"
| exists <Boolean> |

exists := (Delta includesKey: n) and:[(Delta at: n) isError not].

exists ifTrue:[self nameExisting: n ifFail: fb]
             ifFalse:[self nameNew: n ifFail: fb].

(Mirror on: (Delta at: n))  sourceInfo logDefinition.
! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
nestInGenericWithTypeArguments: tas  <Str>

self subclassResponsibility! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
nonAtomic

self deltaHack.! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
placeHolder

^DeltaPlaceHolderError new name: self name! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
placeHolderFor: name <Symbol>

^DeltaPlaceHolderError new name: name! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
printOn: aStream  <Stream> 
	aStream 
		nextPutAll: self class name;
		nextPutAll: ' on ';
		nextPutAll: self name.
! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
priorReflecteeFor: n <Symbol> ^ <Mirror>
	^(Delta at: n) isNil 
									ifTrue:[Delta assocAt: n] "it's a global created as forward reference"
									ifFalse:[Delta at: n].

! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
reflectee  ^ <T>

self subclassResponsibility! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
removeDefinitionIfFail: blk <[]>

	"Remove entry from system dictionary and source database"

	self isMeta
		ifTrue: [	^blk value: 'Cannot remove on meta side'  ].
	self sourceInfo removeIndex.
	Smalltalk removeKey: self name.
	self reflectee: nil.
	^nil
! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
rename: oldId <Symbol> to: newId <Symbol>
"All mirrors must provide a method that renames oldId to newId throughout
their source code"
self subclassResponsibility! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
rename: oldId <Symbol> to: newId <Symbol> in: s <Str> ^ <Str>
"
Callers can rely on the identity of the returned string to know whether a change has taken place;
if no change was made, the incoming parameter 's' is returned.
"
| renamed <Str>  changed <Boolean> |

changed := false.
renamed := TokenStreamEditor  transform: s
		using:[: sym <Symbol> :v <Object> :str <Str> | 
					sym  = #identifier  
						ifTrue:[v = oldId 
												ifTrue:[
															changed := true.
															newId]
												 ifFalse:[str]
									] ifFalse:[str]]
		ifFail:[:s <Str>  :i <Int> | self error: s].
^changed ifTrue:[renamed] ifFalse:[s].! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
renameGroup: grp <Dict[Symbol,Symbol]> 
" grp maps old name to new names.
All mirrors must provide a method that uses the mapping
defined by grp to rename throughout their source code"
self subclassResponsibility! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
renameGroup: grp <Dict[Symbol,Symbol]> in: s <Str> ^ <Str>
"
Callers can rely on the identity of the returned string to know whether a change has taken place;
if no change was made, the incoming parameter 's' is returned.
Right now we determine this by comparing s against the renamed string. Shortly, we will
change this so we remember if we ever made a change."
| renamed <Str>  changed <Boolean> |

changed := false.
renamed := TokenStreamEditor  transform: s
		using:[: sym <Symbol> :v <Object> :str <Str> | 
					sym  = #identifier 
						ifTrue:[
										(grp includesKey: v) ifTrue:[changed := true].
										grp at:  v ifAbsent:[str]
									] 
						ifFalse:[str]
					]
		ifFail:[:s <Str>  :i <Int> | self error: s].
^changed ifTrue:[renamed] ifFalse:[s].! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
renameTo: newId <Symbol>

Smalltalk definitionsReflectiveDo:[ :d <Mirror> | d rename: self name to: newId].! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
revision ^ <Str>

	"Revision for file-out"
	^self sourceInfo revision
! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
revision: s <Str>

	"Revision for file-out"
	self sourceInfo revision: s
! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
sourceInfo ^ <CommonSourceHandler>

self subclassResponsibility! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
typecheck

self subclassResponsibility! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'accessing' !
nameWithTypeArgs ^ <Str>

	"Returns the name with generic type argument names appended, e.g. Set[E]"
	
	| stream <CharReadWriteStream> tas <OrdCltn[TypeFormal]> |
	stream := (String new: self name size) writeStream.
	stream nextPutAll: self name.

	self isGeneric ifTrue: [	
		tas := self hasTypeInfoLoaded
			ifTrue: [		self typeInfo asGeneric formals ]
			ifFalse: [	 (DeltaParser new 
										parseTypeArgs: self typeArgumentString 
										within: DeltaGlobals 
										ifError: [ :msg <Str> :pos <Int> | self shouldNotHappen ]) 
									collect: [ :pt <ParseTree[TypeFormal]> | pt body ] ].
									
		stream nextPut: $[.
		1 to: tas size - 1 do: [ :index <Int> |
			stream 
				nextPutAll: (tas at: index) name;
				nextPut: $, ].
		stream nextPutAll: (tas at: tas size) name.
		stream nextPut: $].
	].

	^stream
	! !

"August 22, 2009 -> 14:21:51"!

Delta define: #DeltaTuple as: (
(Class subclassOf: 'DeltaArray' instanceVariables: '')) !


"August 22, 2009 -> 14:21:51"!

(Delta mirrorFor: #DeltaTuple)
comment: 
''!


"August 22, 2009 -> 14:21:51"!

! (Delta mirrorFor: #DeltaTuple) methodsFor: 'a new category' !
apply: aTool <DeltaTool > ^ <Self>
	aTool tupleNode: self! !

"August 22, 2009 -> 14:21:51"!

! (Delta mirrorFor: #DeltaTuple) methodsFor: 'a new category' !
elements ^ <OrderedCollection[ASTNode]>
	^self value! !

"August 22, 2009 -> 14:21:51"!

! (Delta mirrorFor: #DeltaTuple) methodsFor: 'a new category' !
isArrayNode
    ^ false! !

"August 22, 2009 -> 14:21:51"!

! (Delta mirrorFor: #DeltaTuple) methodsFor: 'a new category' !
isTupleNode
    ^ true! !

"August 22, 2009 -> 14:22:20"!

Delta define: #ASTtoRichTextTool as: (
Generic forAll: 'E ' body: ((Class subclassOf: 'DeltaASTTool' instanceVariables: 'result <SeqCltn[Tuple[[Character,^E],Tuple[Int,Int]]]>
parseTrees <Cltn[ParseTree[ASTNode]]>
currentParseTree <ParseTree[ASTNode]>
selectorEnd <Int>
selectorBuilder <[Character,^E]>
codeBuilder <[Character,^E]>
commentBuilder <[Character,^E]>
typeexpressionBuilder <[Character,^E]>
inferenceclauseBuilder <[Character,^E]>
defaultBuilder <[Character,^E]>
'))) !


"August 22, 2009 -> 14:22:20"!

Delta define: #ASTtoRichTextTool as: (
Generic forAll: 'E ' body: ((Class subclassOf: 'DeltaASTTool' instanceVariables: 'result <SeqCltn[Tuple[[Character,^E],Tuple[Int,Int]]]>
parseTrees <Cltn[ParseTree[ASTNode]]>
currentParseTree <ParseTree[ASTNode]>
selectorEnd <Int>
selectorBuilder <[Character,^E]>
codeBuilder <[Character,^E]>
commentBuilder <[Character,^E]>
typeexpressionBuilder <[Character,^E]>
inferenceclauseBuilder <[Character,^E]>
defaultBuilder <[Character,^E]>
'))) !


"August 22, 2009 -> 14:22:20"!

Delta define: #ASTtoRichTextTool as: (
Generic forAll: 'E ' body: ((Class subclassOf: 'DeltaASTTool' instanceVariables: 'result <SeqCltn[Tuple[[Character,^E],Tuple[Int,Int]]]>
parseTrees <Cltn[ParseTree[ASTNode]]>
currentParseTree <ParseTree[ASTNode]>
selectorEnd <Int>
selectorBuilder <[Character,^E]>
codeBuilder <[Character,^E]>
commentBuilder <[Character,^E]>
typeexpressionBuilder <[Character,^E]>
inferenceclauseBuilder <[Character,^E]>
defaultBuilder <[Character,^E]>
'))) !


"August 22, 2009 -> 14:22:20"!

Delta define: #ASTtoRichTextTool as: (
Generic forAll: 'E ' body: ((Class subclassOf: 'DeltaASTTool' instanceVariables: 'result <SeqCltn[Tuple[[Character,^E],Tuple[Int,Int]]]>
parseTrees <Cltn[ParseTree[ASTNode]]>
currentParseTree <ParseTree[ASTNode]>
selectorEnd <Int>
selectorBuilder <[Character,^E]>
codeBuilder <[Character,^E]>
commentBuilder <[Character,^E]>
typeexpressionBuilder <[Character,^E]>
inferenceclauseBuilder <[Character,^E]>
defaultBuilder <[Character,^E]>
'))) !


"August 22, 2009 -> 14:22:20"!

Delta define: #ASTtoRichTextTool as: (
Generic forAll: 'E ' body: ((Class subclassOf: 'DeltaASTTool' instanceVariables: 'result <SeqCltn[Tuple[[Character,^E],Tuple[Int,Int]]]>
parseTrees <Cltn[ParseTree[ASTNode]]>
currentParseTree <ParseTree[ASTNode]>
selectorEnd <Int>
selectorBuilder <[Character,^E]>
codeBuilder <[Character,^E]>
commentBuilder <[Character,^E]>
typeexpressionBuilder <[Character,^E]>
inferenceclauseBuilder <[Character,^E]>
defaultBuilder <[Character,^E]>
'))) !


"August 22, 2009 -> 14:22:20"!

Delta define: #ASTtoRichTextTool as: (
Generic forAll: 'E ' body: ((Class subclassOf: 'DeltaASTTool' instanceVariables: 'result <SeqCltn[Tuple[[Character,^E],Tuple[Int,Int]]]>
parseTrees <Cltn[ParseTree[ASTNode]]>
currentParseTree <ParseTree[ASTNode]>
selectorEnd <Int>
selectorBuilder <[Character,^E]>
codeBuilder <[Character,^E]>
commentBuilder <[Character,^E]>
typeexpressionBuilder <[Character,^E]>
inferenceclauseBuilder <[Character,^E]>
defaultBuilder <[Character,^E]>
'))) !


"August 22, 2009 -> 14:22:20"!

Delta define: #ASTtoRichTextTool as: (
Generic forAll: 'E ' body: ((Class subclassOf: 'DeltaASTTool' instanceVariables: 'result <SeqCltn[Tuple[[Character,^E],Tuple[Int,Int]]]>
parseTrees <Cltn[ParseTree[ASTNode]]>
currentParseTree <ParseTree[ASTNode]>
selectorEnd <Int>
selectorBuilder <[Character,^E]>
codeBuilder <[Character,^E]>
commentBuilder <[Character,^E]>
typeexpressionBuilder <[Character,^E]>
inferenceclauseBuilder <[Character,^E]>
defaultBuilder <[Character,^E]>
'))) !


"August 22, 2009 -> 14:22:20"!

Delta define: #ASTtoRichTextTool as: (
Generic forAll: 'E ' body: ((Class subclassOf: 'DeltaASTTool' instanceVariables: 'result <SeqCltn[Tuple[[Character,^E],Tuple[Int,Int]]]>
parseTrees <Cltn[ParseTree[ASTNode]]>
currentParseTree <ParseTree[ASTNode]>
selectorEnd <Int>
selectorBuilder <[Character,^E]>
codeBuilder <[Character,^E]>
commentBuilder <[Character,^E]>
typeexpressionBuilder <[Character,^E]>
inferenceclauseBuilder <[Character,^E]>
defaultBuilder <[Character,^E]>
'))) !


"August 22, 2009 -> 14:22:20"!

Delta define: #ASTtoRichTextTool as: (
Generic forAll: 'E ' body: ((Class subclassOf: 'DeltaASTTool' instanceVariables: 'result <SeqCltn[Tuple[[Character,^E],Tuple[Int,Int]]]>
parseTrees <Cltn[ParseTree[ASTNode]]>
currentParseTree <ParseTree[ASTNode]>
selectorEnd <Int>
selectorBuilder <[Character,^E]>
codeBuilder <[Character,^E]>
commentBuilder <[Character,^E]>
typeexpressionBuilder <[Character,^E]>
inferenceclauseBuilder <[Character,^E]>
defaultBuilder <[Character,^E]>
'))) !


"August 22, 2009 -> 14:22:20"!

Delta define: #ASTtoRichTextTool as: (
Generic forAll: 'E ' body: ((Class subclassOf: 'DeltaASTTool' instanceVariables: 'result <SeqCltn[Tuple[[Character,^E],Tuple[Int,Int]]]>
parseTrees <Cltn[ParseTree[ASTNode]]>
currentParseTree <ParseTree[ASTNode]>
selectorEnd <Int>
selectorBuilder <[Character,^E]>
codeBuilder <[Character,^E]>
commentBuilder <[Character,^E]>
typeexpressionBuilder <[Character,^E]>
inferenceclauseBuilder <[Character,^E]>
defaultBuilder <[Character,^E]>
'))) !


"August 22, 2009 -> 14:22:20"!

Delta define: #ASTtoRichTextTool as: (
Generic forAll: 'E ' body: ((Class subclassOf: 'DeltaASTTool' instanceVariables: 'result <SeqCltn[Tuple[[Character,^E],Tuple[Int,Int]]]>
parseTrees <Cltn[ParseTree[ASTNode]]>
currentParseTree <ParseTree[ASTNode]>
selectorEnd <Int>
selectorBuilder <[Character,^E]>
codeBuilder <[Character,^E]>
commentBuilder <[Character,^E]>
typeexpressionBuilder <[Character,^E]>
inferenceclauseBuilder <[Character,^E]>
defaultBuilder <[Character,^E]>
'))) !


"August 22, 2009 -> 14:22:20"!

Delta define: #ASTtoRichTextTool as: (
Generic forAll: 'E ' body: ((Class subclassOf: 'DeltaASTTool' instanceVariables: 'result <SeqCltn[Tuple[[Character,^E],Tuple[Int,Int]]]>
parseTrees <Cltn[ParseTree[ASTNode]]>
currentParseTree <ParseTree[ASTNode]>
selectorEnd <Int>
selectorBuilder <[Character,^E]>
codeBuilder <[Character,^E]>
commentBuilder <[Character,^E]>
typeexpressionBuilder <[Character,^E]>
inferenceclauseBuilder <[Character,^E]>
defaultBuilder <[Character,^E]>
'))) !


"August 22, 2009 -> 14:22:20"!

(Delta mirrorFor: #ASTtoRichTextTool)
comment: 
'Tool generating information for printing sources with rich text.

The tool generates a sequencable collection of elements of type E.
The generated collection will have the same size as the source.
E is the type of the rich text used for each character, e.g. Glyph.

The elements in the resulting collection are built by the 5 builders:

	selectorBuilder <[Character,^E]>
	typeexpressionBuilder <[Character,^E]>
	inferenceclauseBuilder <[Character,^E]>
	codeBuilder <[Character,^E]>
	commentBuilder <[Character,^E]>

The tool has to be parameterized with these 5 builder blocks. 
It is also possible to set a default builder block

	defaultBuilder <[Str, ^E]>
	
which will be used if one of the above mentioned are not specified.
 (c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"August 22, 2009 -> 14:22:20"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'accessing' !
compute ^ <SeqCltn[E]>	
	
	| value <SeqCltn[E]> |
	self insertCommentIntervals.								"Add comment intervals from scanner"
	self parseTrees do: [ :pt <ParseTree> |
		self currentParseTree: pt.
		pt body apply: self ].											"Add AST based intervals"
	self insertSelectorAndCodeIntervals.			"Add remaining intervals"
	self sortResult.

	value := OrderedCollection[E] new: self source size.
	self result do: [ :e <Tuple[[Character,^E], Tuple[Int,Int]]> | 
		e at2 at1 to: e at2 at2 - 1 do: [ :index <Int> |
			value add: (e at1 value: (self source at: index)) ] ].

	self assert: [ value size = self source size ].
	^value
! !

"August 22, 2009 -> 14:22:20"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'accessing' !
parseTree: pt <ParseTree[ASTNode]>

	self parseTrees: (OrderedCollection[ParseTree[ASTNode]] with: pt).
! !

"August 22, 2009 -> 14:22:20"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'accessing' !
parseTrees ^ <Cltn[ParseTree[ASTNode]]>

	^parseTrees! !

"August 22, 2009 -> 14:22:20"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'accessing' !
parseTrees: pts <Cltn[ParseTree[ASTNode]]>

	| src <Str> |
	self initialize.

	"Verify that the source pointers in the list of parse trees are identical"
	self assert: [ pts size > 0 ].
	src := pts first source.
	2 to: pts size do: [ :i <Int> | self assert: [ (pts at: i) source = src ] ].
	
	parseTrees := pts! !

"August 22, 2009 -> 14:22:20"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'builders' !
codeBuilder ^ <[Character,^E]>

	^codeBuilder isNil
		ifTrue: [		self defaultBuilder ]
		ifFalse: [	codeBuilder ]
		! !

"August 22, 2009 -> 14:22:20"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'builders' !
codeBuilder: b <[Character,^E]>

	codeBuilder := b! !

"August 22, 2009 -> 14:22:20"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'builders' !
commentBuilder ^ <[Character,^E]>

	^commentBuilder isNil
		ifTrue: [		self defaultBuilder ]
		ifFalse: [	commentBuilder ]
		! !

"August 22, 2009 -> 14:22:20"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'builders' !
commentBuilder: b <[Character,^E]>

	commentBuilder := b! !

"August 22, 2009 -> 14:22:20"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'builders' !
defaultBuilder ^ <[Character,^E]>

	defaultBuilder isNil
		ifTrue: [	self error: 'Default builder not specified' ].
	^defaultBuilder! !

"August 22, 2009 -> 14:22:20"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'builders' !
defaultBuilder: b <[Character,^E]>

	defaultBuilder := b! !

"August 22, 2009 -> 14:22:20"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'builders' !
inferenceclauseBuilder ^ <[Character,^E]>

	^inferenceclauseBuilder isNil
		ifTrue: [		self defaultBuilder ]
		ifFalse: [	inferenceclauseBuilder ]
		! !

"August 22, 2009 -> 14:22:20"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'builders' !
inferenceclauseBuilder: b <[Character,^E]>

	inferenceclauseBuilder := b! !

"August 22, 2009 -> 14:22:20"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'builders' !
selectorBuilder ^ <[Character,^E]>

	^selectorBuilder isNil
		ifTrue: [		self defaultBuilder ]
		ifFalse: [	selectorBuilder ]
		! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'builders' !
selectorBuilder: b <[Character,^E]>

	selectorBuilder := b! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'builders' !
typeexpressionBuilder ^ <[Character,^E]>

	^typeexpressionBuilder isNil
		ifTrue: [		self defaultBuilder ]
		ifFalse: [	typeexpressionBuilder ]
		! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'builders' !
typeexpressionBuilder: b <[Character,^E]>

	typeexpressionBuilder := b! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
assignmentNode: node <DeltaAssignment >
    node expr apply: self.! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
blockNode: node <DeltaBlock> ^ <Self>
    node body apply: self.
! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
cascadedSendNode: node <DeltaCascadedSend>
    node prevSend apply: self.
    node msg apply: self.! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
classVarNode: node <DeltaInstVar > 

	self varNode: node! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
codeBodyNode: node <DeltaCodeBody >
    node parameters do: [ :d <DeltaParameter>  | d apply: self ].
    node temporaries do: [ :d <DeltaTemporary>  | d apply: self ].
    node statements do: [ :d <DeltaStatement>  | d apply: self ]! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
dllCallNode: node <DeltaDLLCall>
    node msg apply: self.! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
genericApplicationExpressionNode: node <DeltaGenericApplicationExpression >

	"Mark the actuals of the generic application as a type expression"

	| position <Tuple[Int,Int]> | 
	position := self currentParseTree positionForNode: node.
	self addToResultCheckOverlap: self typeexpressionBuilder ,, ((position at1 + node target name size) ,, position at2).
	node target apply: self.
    ! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
guaranteedNode: node <DeltaGuaranteed >

	"Mark the declared type as a type expression"

	| nodePosition <Tuple[Int,Int]> typePosition <Tuple[Int,Int]> | 
	nodePosition := self currentParseTree positionForNode: node.
	typePosition := self findTypeExprIntervalFrom: (self currentParseTree positionForNode: node declaredType).
	self addToResultCheckOverlap: self typeexpressionBuilder ,, (nodePosition at1 ,, typePosition at2).
    node expr apply: self.
    ! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
instVarNode: node <DeltaInstVar > 

	self varNode: node! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
literalNode: node <DeltaLiteral >! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
messageNode: node <DeltaMessage >
    node args do: [ :s <DeltaExpression>  | s apply: self].! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
messagePatternNode: node <MessagePattern>
    node type apply: self
! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
methodDeclNode: node <DeltaMethod>
    node filteree apply: self.
! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
methodNode: node <DeltaMethod>
    node type apply: self.
    node body apply: self.
! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
msgSignatureNode: node <DeltaMsgSignature>

	"We process the type nodes in the domain here. Note that we have to skip them when traversing the
		method parameters, see #parameterNode:. This should be changed at some point - they should
		only be reachable from one place"
	
	| position <Tuple[Int,Int]> domainPosition <Tuple[Int,Int]> |
	
	node domain do: [ :domainNode <DeltaType>  | 
		domainNode isError
			ifFalse: [	domainPosition := self currentParseTree positionForNode: domainNode. 
								self addToResultCheckOverlap: self typeexpressionBuilder ,, (self findTypeExprIntervalFrom: domainPosition) ] ].
	
    position := self currentParseTree positionForNode: node range.
    self selectorEnd: position at1.
    (position at2 - position at1) > 0
    	ifTrue: [	"An explicit return type was given"
    					self addToResultCheckOverlap: self typeexpressionBuilder ,, (self findReturnTypeExprIntervalFrom: position) ]
! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
normalSendNode: node <DeltaSend>
    node recv apply: self.
    node msg apply: self.! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
parameterNode: node <DeltaParameter>

	| methodScope <Scope> realParameterNode <DeltaParameter> position <Tuple[Int,Int]> |
	
	"The first hack below is due to the fact that the rewriter inserts artificial parameters into the AST
		when rewriting loops.
		The second hack below is due to the fact that the types of method parameters are reachable
		from both the method message signature and the parameters in the method code body.
		This should be changed at some point. Also note that CodeScopes hold state and have the parameters 
		copied down for method code bodies. The real parameter present in the parse tree can in this case be 
		found in the super scope. This should really be changed at some point."
	
	self deltaHack.
	node isIntroducedByRewriter ifTrue: [ ^ self ].						"Ignore index parameter inserted by the rewriter."
		
	methodScope := self currentParseTree body scope.		"This is a CodeScope"
	(methodScope parameters includes: node)
		ifTrue: [		"We are in a method code body. We should only process the parameter name.
								The type node is processed in #msgSignatureNode:"
							realParameterNode := methodScope superScope at: node name.
							position := self currentParseTree positionForNode: realParameterNode.
							self addToResultCheckOverlap: self codeBuilder ,, (position at1 ,, (position at1 + realParameterNode name size)) ]
		ifFalse: [	self varNode: node  ].
! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
polyMsgSignatureNode: node <PolyMsgSignature>

	"The formals contain the inferred type variables Some stem from magical
	'def' clauses and others stem from a real inference clause. The latter will have
	their inference clause node present in the parse tree for the method. We take
	any one of them and use it for selecting the entire {where ...} expression."
	
	| tvPos <Tuple[Int,Int]> inferenceClausePos <Tuple[Int,Int]> |
	node formals do: [ :tv <InferredTypeVar> |
		(tvPos := self currentParseTree positionForNode: tv inferenceClause ifAbsent: [nil]) notNil
			ifTrue: [	inferenceClausePos := tvPos ] ].
	inferenceClausePos notNil
		ifTrue: [	self addToResultCheckOverlap: self inferenceclauseBuilder ,, (self findInferenceClauseIntervalFrom: inferenceClausePos) ].

	node body apply: self.! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
primitiveNode: node <DeltaPrimitiveNode>
    node recv isNil ifFalse:[node recv apply: self].
    node msg apply: self.! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
refNode: node <DeltaRef>
! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
returnStatNode: node <DeltaReturnStat>
    node expr apply: self.
! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
superSendNode: node <DeltaSuperSend>
    node msg apply: self.! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
temporaryNode: node <DeltaTemporary>

	self deltaHack.
	node isIntroducedByRewriter ifTrue: [ ^ self ].		"ignore temporaries introduced by rewriter"
	self varNode: node! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
tupleNode: node <DeltaTule>
	node elements do:[:e | e apply: self]! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'private' !
addToResult: t <Tuple[[Character,^E],Tuple[Int,Int]]>
	"Add tuple to result without checking for overlap with existing intervals"
	self result addLast: t! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'private' !
addToResultCheckOverlap: t <Tuple[[Character,^E],Tuple[Int,Int]]>
	"Add tuple to result and checking for overlap with existing intervals.
	The existing intervals can only be fully embedded in the new interval."

	| embeddedIntervals <SeqCltn[Tuple[Int,Int]]> nextBegin <Int> |
	embeddedIntervals := OrderedCollection[Tuple[Int,Int]] new.
	self result do: [ :e <Tuple[[Character,^E],Tuple[Int,Int]]> |
		(t at2 at1 < e at2 at1 and: [ e at2 at2 < t at2 at2 ])
			ifTrue: [	embeddedIntervals add: e at2 ] ].
	embeddedIntervals := embeddedIntervals asSortedCollection:
		[ :i1 <Tuple[Int,Int]> :i2 <Tuple[Int,Int]> |
			i1 at1 <= i2 at1 ].
	nextBegin := t at2 at1.
	embeddedIntervals do: [ :i <Tuple[Int,Int]> |
		self result add: t at1 ,, (nextBegin ,, i at1).
		nextBegin := i at2 ].
	self result add: t at1 ,, (nextBegin ,, t at2 at2).
! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'private' !
currentParseTree ^ <ParseTree[ASTNode]>

	^currentParseTree! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'private' !
currentParseTree: pt <ParseTree[ASTNode]>

	currentParseTree := pt! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'private' !
findInferenceClauseIntervalFrom: position <Tuple[Int,Int]> ^ <Tuple[Int,Int]>

	| begin <Int> end <Int> |
	begin := position at1.
	end := position at2.
	[ (self source at: begin) = ${ ] whileFalse: [
		begin := begin - 1.
		self assert: [ begin > 0 ] ].
	[ (self source at: end) = $} ] whileFalse: [
		end := end + 1.
		self assert: [ end <= self source size ] ].
	^begin ,, (end + 1)
	
	! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'private' !
findReturnTypeExprIntervalFrom: position <Tuple[Int,Int]> ^ <Tuple[Int,Int]>

	| returnPos <Int> begin <Int> |
	returnPos := self findTypeExprIntervalFrom: position.
	begin := returnPos at1.
	[ (self source at: begin) = $^] whileFalse: [
		begin := begin - 1.
		self assert: [ begin > 0 ] ].
	^begin ,, returnPos at2





! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'private' !
findTypeExprIntervalFrom: position <Tuple[Int,Int]> ^ <Tuple[Int,Int]>

	| begin <Int> end <Int> |
	begin := position at1.
	end := position at2.
	[ (self source at: begin) = $< ] whileFalse: [
		begin := begin - 1.
		self assert: [ begin > 0 ] ].
	[ (self source at: end) = $> ] whileFalse: [
		end := end + 1.
		self assert: [ end <= self source size ] ].
	^begin ,, (end + 1)
	
	! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'private' !
insertCommentIntervals

	"All parsetrees will hold the same source and comment positions"
	self parseTrees first commentPositions do: [ :cp <Tuple[Int,Int]> |
		self addToResult: self commentBuilder ,, cp ]
! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'private' !
insertSelectorAndCodeIntervals

	| newIntervals <SeqCltn[Tuple[[Character,^E],Tuple[Int,Int]]]> nextBegin <Int> currentBuilder <[Character,^E]> |
	self sortResult.
	currentBuilder := self selectorBuilder.
	nextBegin := 1.
	newIntervals := OrderedCollection[Tuple[[Character,^E],Tuple[Int,Int]]] new.
	self result do: [ :e <Tuple[[Character,^E],Tuple[Int,Int]]> |
		nextBegin >= self selectorEnd
			ifTrue: [		currentBuilder := self codeBuilder ].
		e at2 at1 > nextBegin
			ifTrue: [ 		(nextBegin < self selectorEnd and: [self selectorEnd < e at2 at1])
									ifTrue: [	newIntervals add: currentBuilder ,, (nextBegin ,, self selectorEnd).
													currentBuilder := self codeBuilder.
													nextBegin := self selectorEnd ].
								newIntervals add: currentBuilder ,, (nextBegin ,, e at2 at1) ].
		nextBegin := e at2 at2 ].
	nextBegin > self source size 
			ifFalse: [ 	nextBegin < self selectorEnd
									ifTrue: [	newIntervals add: currentBuilder ,, (nextBegin ,, self selectorEnd).
													currentBuilder := self codeBuilder.
													nextBegin := self selectorEnd ].
								currentBuilder := self codeBuilder.
								newIntervals add: currentBuilder ,, (nextBegin ,, (self source size + 1)) ].
	newIntervals do: [ :e <Tuple[[Character,^E],Tuple[Int,Int]]> |
		self addToResult: e ].! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'private' !
result ^ <SeqCltn[Tuple[[Character,^E],Tuple[Int,Int]]]>

	^result! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'private' !
result: r <SeqCltn[Tuple[[Character,^E],Tuple[Int,Int]]]>

	result := r! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'private' !
selectorEnd ^ <Int>

	selectorEnd isNil
		ifTrue: [		^0 ]								"#selectorEnd: not called, assume no selector in source"
		ifFalse: [	^selectorEnd ]! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'private' !
selectorEnd: i <Int>

	self assert: [ i isNil or: [ selectorEnd isNil ]].
	selectorEnd := i! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'private' !
sortResult

	self result: 
		(OrderedCollection[Tuple[[Character,^E],Tuple[Int,Int]]] withAll:
			(self result asSortedCollection: 
				[ :t1 <Tuple[[Character,^E],Tuple[Int,Int]]> :t2 <Tuple[[Character,^E],Tuple[Int,Int]]> |
					t1 at2 at1 <= t2 at2 at1 ]))
! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'private' !
source ^ <Str>

	^self parseTrees first source! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'private' !
varNode: node <DeltaVar>

	| position <Tuple[Int,Int]> |
	position := self currentParseTree positionForNode: node.
	self addToResultCheckOverlap: self codeBuilder ,, (position at1 ,, (position at1 + node name size)).
	node type isError
		ifFalse: [	position := self currentParseTree positionForNode: node type. 
							self addToResultCheckOverlap: self typeexpressionBuilder ,, (self findTypeExprIntervalFrom: position) ]! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'private - initialization' !
initialize

	self result: OrderedCollection[Tuple[[Character,^E],Tuple[Int,Int]]] new.
	self selectorEnd: nil.
	self currentParseTree: nil.
	! !

"August 22, 2009 -> 14:22:58"!

Delta define: #DeltaRewriter as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'scope result ')) !


"August 22, 2009 -> 14:22:58"!

Delta define: #DeltaRewriter as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'scope result ')) !


"August 22, 2009 -> 14:22:58"!

Delta define: #DeltaRewriter as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'scope result ')) !


"August 22, 2009 -> 14:22:58"!

Delta define: #DeltaRewriter as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'scope result ')) !


"August 22, 2009 -> 14:22:58"!

Delta define: #DeltaRewriter as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'scope result ')) !


"August 22, 2009 -> 14:22:58"!

Delta define: #DeltaRewriter as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'scope result ')) !


"August 22, 2009 -> 14:22:58"!

Delta define: #DeltaRewriter as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'scope result ')) !


"August 22, 2009 -> 14:22:58"!

Delta define: #DeltaRewriter as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'scope result ')) !


"August 22, 2009 -> 14:22:58"!

Delta define: #DeltaRewriter as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'scope result ')) !


"August 22, 2009 -> 14:22:58"!

Delta define: #DeltaRewriter as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'scope result ')) !


"August 22, 2009 -> 14:22:58"!

Delta define: #DeltaRewriter as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'scope result ')) !


"August 22, 2009 -> 14:22:58"!

(Delta mirrorFor: #DeltaRewriter)
comment: 
'The rewriter recursively traverses the AST and optimizes
    particular nodes by relacing them with other (more optimal)
    nodes.

    Instance variables:

    result      the result after rewriting the current node. If the node
                      has not changed, result simply holds the current node.

    scope      the current scope. Scope is adjusted whenever a
                      new codeBody is entered.
    
 (c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
andOrNode: node
    self assert: [node isAndOrNode].
    result := node! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
assignmentNode: node
    | var expr |
    self assert: [ node isAssignmentNode ].
	var := self rewrite: node var.
	var isFloatValue
		ifTrue: [ result := DeltaFloatAssignment new to: var assign: (self rewriteAsFloatValue: node expr) ]
		ifFalse: [ result := DeltaAssignment new to: var assign: (self rewriteAsOop: node expr) ]! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
at: node error: msg
	"Simple soultion for now - fix this at some point"
	Transcript show: 'error: ', msg ; cr.
	self halt! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
blockNode: node
    | prevScope body |
    self assert: [ node isBlockNode ].
    result := DeltaBlock new body: (self rewrite: node body)! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
cascadedSendNode: node
	| prevSend msg |
	self assert: [node isCascadedSendNode].
	prevSend := self rewrite: node prevSend.
	msg := self rewrite: node msg.
	prevSend isSelfSendNode ifTrue: [
		"do not rewrite: keep normal send instead"
		result := DeltaCascadedSend new to: node prevSend cascade: msg.
		^ self
	].
	prevSend isSuperSendNode ifTrue: [
		Transcript show: 'cascaded super sends not implemented yet' ; cr.
		self halt.
		^ self
	].
	result := DeltaCascadedSend new to: prevSend cascade: msg! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
codeBodyNode: node <CodeBody>
    | prevScope statements |
    self assert: [node isCodeBodyNode].
    prevScope := scope.
    scope := node scope.
    statements := OrderedCollection new.
    node statements do: [ :stat | statements add: (self rewrite: stat)].
    result :=
        DeltaCodeBody new
            parameters: node parameters
            temporaries: node temporaries
            statements: statements
            scope: node scope.
    scope := prevScope! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
dllCallNode: node
    self assert: [node isDLLCallNode].
    result :=
        DeltaDLLCall new
            to: node dll
            send: (self rewrite: node msg)
            called: node function
            return: node proxy
			async: node async! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
genericApplicationExpressionNode: node
    self assert: [node isGenericApplicationExpressionNode].
    result := self rewrite: node target! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
globalVarNode: node
    self assert: [node isGlobalVarNode].
    result := node! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
guaranteedNode: node
    self assert: [node isGuaranteedNode].
    result := self rewrite: node expr! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
if: cond with: block1 and: block2 do: action
	cond value ifFalse: [ ^ false ].
	(self isRemovableBlock: block1 withArgs: 0) ifFalse: [ ^ self ].
	(self isRemovableBlock: block2 withArgs: 0) ifFalse: [ ^ self ].
	"inline the block and do action"
	block1 body scope inline.
	block2 body scope inline.
	action value! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
if: cond with: block nofArgs: nofArgs do: action
	cond value ifFalse: [ ^ false ].
	(self isRemovableBlock: block withArgs: nofArgs) ifFalse: [ ^ self ].
	"inline the block and do action"
	block body scope inline.
	action value! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
ifNode: node
	self assert: [ node isIfNode ].
	result := node! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
inlinedBlockNode: node
	self assert: [ node isInlinedBlockNode ].
	result := node! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
isRemovableBlock: block withArgs: nofArgs
	"
	Private.
	Answers true if block can be removed (inlined)
	within another block, answers false otherwise.
	"
	| s |
	block isBlockNode					ifFalse: [ ^ false ].
	s := block body scope.
	s isInlineable							ifFalse: [ ^ false ].
	s nofParameters = nofArgs		ifFalse: [ ^ false ].
	^ true! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
komment
    "
    The rewriter recursively traverses the AST and optimizes
    particular nodes by relacing them with other (more optimal)
    nodes.

    Instance variables:

    result      the result after rewriting the current node. If the node
                      has not changed, result simply holds the current node.

    scope      the current scope. Scope is adjusted whenever a
                      new codeBody is entered.
    "! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
literalNode: node
    self assert: [ node isLiteralNode ].
    result := node! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
loopNode: node
    self assert: [node isLoopNode].
    result := node! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
messageNode: node
    | args |
    self assert: [node isMessageNode].
    args := OrderedCollection new.
    node arguments do: [ :arg | args add: (self rewriteAsOop: arg)].
    result := DeltaMessage new send: node selector with: args! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
methodNode: node
	self assert: [ node isMethodNode ].
	result :=
		DeltaMethod new
			selector: node selector
			type: node type
			visibility: node visibility
			body: (self rewriteSpecialBodies: node body)! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
normalSendNode: node
	| recv msg sel arg1 arg2 arg3 |
	self assert: [ node isNormalSendNode ].
	recv := self rewrite: node recv.

	recv isFloatValue ifTrue: [
		result := self rewrite: node asFloatOperationOn: recv.
		result notNil ifTrue: [ ^ self ].
		"no FloatValue operation found"
		AutoFloatConversion
			ifTrue: [ recv := DeltaFloatUnaryOpToOop new f: #asFloat x: recv ]
			ifFalse: [ self at: node error: 'not a supported FloatValue operation' ]
	].

	"Prepare arguments for normal message sends"
	msg := self rewriteAsOop: node msg.
	sel := msg selector.
	msg nofArgs >= 1 ifTrue: [ arg1 := msg args at: 1 ].
	msg nofArgs >= 2 ifTrue: [ arg2 := msg args at: 2 ].
	msg nofArgs >= 3 ifTrue: [ arg3 := msg args at: 3 ].

	"Self & Super sends"
	(sel ~= #== and: [ sel ~= #~~ ]) ifTrue: [
		(recv isRefNode and: [ recv decl isReceiverNode ])	ifTrue: [ result := DeltaSelfSend new send: msg.						^ self ]
	].
	(recv isRefNode and: [ recv decl isSuperVarNode ])		ifTrue: [ result := DeltaSuperSend new send: msg.					^ self ].

	"Hardwired asFloatValue message"
	sel = #asFloatValue ifTrue: [
		result :=
			EnableFloatValues
				ifTrue: [ DeltaFloatify new obj: recv ]
				ifFalse: [ recv "simply ignore conversion" ].
		^ self
	].

	"Hardwired ifTrue: / ifFalse: messages"
	self if: [ sel = #ifTrue:				] with: arg1 nofArgs: 0	do: [ result := DeltaIf new if: recv is: true then: arg1.						^ self ].
	self if: [ sel = #ifFalse:			] with: arg1 nofArgs: 0	do: [ result := DeltaIf new if: recv is: false then: arg1.					^ self ].
	self if: [ sel = #ifTrue:ifFalse:	] with: arg1 and: arg2	do: [ result := DeltaIf new if: recv is: true then: arg1 else: arg2.	^ self ].
	self if: [ sel = #ifFalse:ifTrue:	] with: arg1 and: arg2	do: [ result := DeltaIf new if: recv is: false then: arg1 else: arg2.	^ self ].

	"Hardwired and: / or: messages"
	self if: [ sel = #and:					] with: arg1 nofArgs: 0	do: [ result := DeltaAndOr new if: recv and: arg1.							^ self ].
	self if: [ sel = #or:					] with: arg1 nofArgs: 0	do: [ result := DeltaAndOr new if: recv or: arg1.								^ self ].

	"Hardwired whileTrue: / whileFalse: messages"
	self if: [ sel = #whileTrue			] with: recv nofArgs: 0	do: [ result := DeltaLoop new while: true do: recv.							^ self ].
	self if: [ sel = #whileFalse		] with: recv nofArgs: 0	do: [ result := DeltaLoop new while: false do: recv.						^ self ].
	self if: [ sel = #whileTrue:		] with: recv and: arg1	do: [ result := DeltaLoop new while: recv is: true do: arg1.			^ self ].
	self if: [ sel = #whileFalse:		] with: recv and: arg1	do: [ result := DeltaLoop new while: recv is: false do: arg1.			^ self ].

	"Hardwired repeat: / timesRepeat: / to:do: / to:by:do: messages"
	self if: [ sel = #repeat				] with: recv nofArgs: 0	do: [ result := DeltaLoop new repeat: recv.										^ self ].
	self if: [ sel = #timesRepeat:	] with: arg1 nofArgs: 0	do: [ result := DeltaLoop new do: recv timesRepeat: arg1.			^ self ].
	self if: [ sel = #to:do:				] with: arg2 nofArgs: 1	do: [ result := DeltaLoop new from: recv to: arg1 do: arg2.			^ self ].
	self if: [ sel = #to:by:do:			] with: arg3 nofArgs: 1 do: [
		arg2 isIntNode ifTrue: [
			"inline only if step is a constant"
			result := DeltaLoop new from: recv to: arg1 by: arg2 do: arg3.
			^ self
		]
	].

	"Hardwired value message"
"
	self if: [ sel = #value				] with: recv nofArgs: 0 do: [ result := DeltaInlinedBlock new block: recv.							^ self ].
"

	"No rewriting"
	result := DeltaNormalSend new to: recv send: msg! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
parameters: pars matchArguments: args
	| i |
	i := pars size.
	
	"Proceed if no. of parameter matches no. of arguments"
	pars size = args size ifFalse: [ ^ false ].

	"check individual arguments, starting with last one"
	i := pars size.
	[ i > 0 ] whileTrue: [
		(args at: i) isRefNode ifFalse: [ ^ false ].
		(pars at: i) == (args at: i) decl ifFalse: [ ^ false ].
		i := i - 1
	].

	"parameters & arguments match 1-to-1, in same order"
	^ true! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
predictPrimitiveNode: node
	self assert: [ node isPredictPrimitiveNode ].
	result := node! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
predictSpecialPrimitiveNode: node
	self assert: [ node isPredictSpecialPrimitiveNode ].
	result := node! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
primitiveCallNode: node
    self assert: [node isPrimitiveCallNode].
    result := node! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
primitiveNode: node
	| recv msg sel args failureBlock failureCode tail |
	self assert: [ node isPrimitiveNode ].
	recv := self rewriteAsOop: node recv.
	msg := self rewrite: node msg.
	sel := msg selector.
	args := msg args.

	failureBlock := nil.
	(sel size >= #ifFail: size) ifTrue: [
		tail := sel copyFrom: (sel size - #ifFail: size + 1) to: sel size.
		(tail =  'ifFail:' or:[tail = 'IfFail:']) ifTrue: [
			(failureBlock := args removeLast) isBlockNode ifFalse: [
				self error: 'primitive send: last argument must be a block'
			].
			failureBlock body parameters size = 1 ifFalse: [
				self error: 'primitive send: failure block must take exactly one argument'
			]
		]
	].

	failureBlock isNil ifFalse: [
		failureBlock scope isInlineable
			ifTrue: [failureBlock scope inline]
			ifFalse: [
				"
				Generate a failureCode of the form:
				failureBlock value: tos
				"
				self error: 'primitive send: failure block is not inlineable - not implemented'
				"
				Transcript show: 'primitive send: failure block is not inlineable - not implemented' ; cr
				"
			]
	].

	result := DeltaPrimitiveCall new call: sel recv: recv with: args ifFail: failureBlock! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
refNode: node
    self assert: [ node isRefNode ].
	result :=
		node decl isFloatValue
			ifTrue: [ DeltaFloatRef new decl: node decl ]
			ifFalse: [ node ]! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
returnInstVarNode: node
	self assert: [ node isReturnInstVarNode ].
	result := node! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
returnStatNode: node
    self assert: [node isReturnStatNode].
    result := DeltaReturnStat new return: (self rewriteAsOop: node expr)! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
rewrite: node
	"
	Applies self to the node and answers result.
	apply must conform to general AST tools and
	therefore can't return a value itself. The value
	is returned in result.
	"
	node isNil
		ifTrue: [ ^ nil ]
		ifFalse: [ node apply: self. ^ result ]! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
rewrite: node asFloatOperationOn: recv
	| msg sel arg1 |
	"Prepare arguments for float operations"
	self assert: [ recv isFloatValue ].
	msg := node msg.
	sel := msg selector.
	msg nofArgs = 1 ifTrue: [ arg1 := self rewriteAsFloatValue: (msg args at: 1) ].

	"Hardwired unary FloatValue operations"
	msg nofArgs = 0 ifTrue: [
		"Operations that return a float"
		#(abs negated squared sqrt sin cos tan exp ln) do: [ :op |
			sel = op ifTrue: [
				scope usesFloatValues.
				^ DeltaFloatUnaryOp new f: op x: recv
			]
		].
		"Operations that return an oop"
		#(asFloat) do: [ :op |
			sel = op ifTrue: [
				scope usesFloatValues.
				^ DeltaFloatUnaryOpToOop new f: op x: recv
			]
		].
		"unary operation not found"
		^ nil
	].

	"Hardwired binary FloatValue operations"
	msg nofArgs = 1 ifTrue: [
		"Operations that return a float"
		#(+ - * / \\) do: [ :op |
			sel = op ifTrue: [
				scope usesFloatValues.
				^ DeltaFloatBinaryOp new x: recv f: op y: arg1
			]
		].
		"Operations that return an oop"
		#(= ~= < <= > >=) do: [ :op |
			sel = op ifTrue: [
				scope usesFloatValues.
				^ DeltaFloatBinaryOpToOop new x: recv f: op y: arg1
			]
		].
		"binary operation not found"
		^ nil
	].
	"operation not found"
	^ nil! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
rewriteAsFloatValue: node
	| n |
	self assert: [ EnableFloatValues ].
	self assert: [ node notNil ].
	n := self rewrite: node.
	n isFloatValue ifFalse: [
		(n isLiteralNode and: [ n isFloatNode ])
			ifTrue: [
				"float literals are always converted automatically - no run-time overhead involved"
				n := DeltaFloatLiteral new value: n value
			]
			ifFalse: [
				AutoFloatConversion
					ifTrue: [ n := DeltaFloatify new obj: n ]
					ifFalse: [ self at: node error: 'expression type must be FloatValue' ]
			]
	].
	^ n! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
rewriteAsOop: node
	| n |
	n := self rewrite: node.
	(n notNil and: [ n isFloatValue ]) ifTrue: [
		self assert: [ EnableFloatValues ].
		AutoFloatConversion
			ifTrue: [ n := DeltaFloatUnaryOpToOop new f: #asFloat x: n ]
			ifFalse: [ self at: node error: 'expression type cannot be a FloatValue' ]
	].
	^ n! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
rewriteSpecialBodies: b
	"
	Detects access and primitive method
	bodies and rewrites them accordingly.
	"
	| body stats stat decl expr |
	body := self rewrite: b.
	stats := body statements.
	stats size = 1 ifTrue: [
		stat := stats at: 1.
		stat isReturnStatNode ifTrue: [
			expr := stat expr.
			expr isRefNode ifTrue: [
				decl := expr decl.
				decl isInstVarNode ifTrue: [
					body parameters isEmpty ifFalse: [ ^ body ].
					stats := OrderedCollection new.
					stats add: (DeltaReturnInstVar new var: decl).
					^ DeltaCodeBody new
						parameters: body parameters
						temporaries: body temporaries
						statements: stats
						scope: body scope
				]
			].
			expr isPrimitiveCallNode ifTrue: [
				(expr receiver notNil and: [ expr receiver decl isReceiverNode ]) ifTrue: [
					"primitive takes self as first argument"
					(self parameters: body parameters matchArguments: expr arguments) ifTrue: [
						expr failureCode notNil ifTrue: [
							"
							primitive takes exactly the method arguments - add hint
							whether primitive is actually predicted depends on code generator
							"
							stats addFirst: (DeltaPredictSpecialPrimitive new primitive: expr selector).
							^ DeltaCodeBody new
								parameters: body parameters
								temporaries: body temporaries
								statements: stats
								scope: body scope
						]
					]
				]

"				This is old code - not correct anymore because primitives with self argument
				are not handled the right way - keep it around anyway for later - gri 5/2/96.
				
				(self parameters: body parameters matchArguments: expr arguments) ifTrue: [
					expr failureCode isNil ifTrue: [
						stats addFirst: (DeltaPredictPrimitive new primitive: expr selector).
						^ DeltaCodeBody new
							parameters: body parameters
							temporaries: body temporaries
							statements: stats
							scope: body scope
					]
				]
"
			]
		]
	].

	^ body! !

"August 22, 2009 -> 14:22:59"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
selfSendNode: node
    self assert: [node isSelfSendNode].
    result := node! !

"August 22, 2009 -> 14:22:59"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
superSendNode: node
    self assert: [node isSuperSendNode].
    result := node! !

"August 22, 2009 -> 14:22:59"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
tupleNode: aNode <TupleAST>
"
This code added based on Newspeak code.  Therefore:

Copyright 2008 Cadence Design Systems, Inc.
   
   Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0
"
"should rewrite into a tree representing the expression
(Array new:  n) at: 1 put:: e1 ; ...  at: n put: en; yourself
where n is the size of the tuple"
| els <OrderedCollection[AST]>   
  array <NormalSendAST> 
  len <NumberAST> 
  tup <NormalSendAST>
  index <Integer>
|

	len :=  DeltaInt new value: aNode elements size.
	array :=  DeltaNormalSend new
		to: (DeltaRef new decl: (DeltaGlobals at: #Array)) "Array" 
		send: (DeltaMessage new send: #new: with:((Array new:1) at: 1 put: len; yourself)). "Array new: n"
	aNode elements size = 0 ifTrue:[^array apply: self].
	index :=  0.
	tup := aNode elements inject: array into:[:r : e |  | msg <MessageAST> |
	      index := index + 1.
	      msg :=  DeltaMessage new send: #at:put:
								with: ((Array new: 2) at: 1 put: (DeltaInt new value: index); at: 2 put: e; yourself).
	      index = 1 
			ifTrue:[DeltaNormalSend new to: r send: msg] 
						"(Array new: n) at:1 put: e1"
	      	ifFalse:[DeltaCascadedSend new to: r cascade: msg]. "...; at: k put: ek"
		].
^(DeltaCascadedSend new to: tup cascade:(DeltaMessage new send: #yourself with: #()))
	"(Array new:  n) at: 1 put:: e1 ; ...  at: n put: en; yourself"
	 apply: self "visit elements"! !

"August 22, 2009 -> 14:23:19"!

Delta define: #GenericMirror as: (
(Class subclassOf: 'Mirror' instanceVariables: 'body ')) !


"August 22, 2009 -> 14:23:19"!

Delta define: #GenericMirror as: (
(Class subclassOf: 'Mirror' instanceVariables: 'body ')) !


"August 22, 2009 -> 14:23:19"!

Delta define: #GenericMirror as: (
(Class subclassOf: 'Mirror' instanceVariables: 'body ')) !


"August 22, 2009 -> 14:23:19"!

Delta define: #GenericMirror as: (
(Class subclassOf: 'Mirror' instanceVariables: 'body ')) !


"August 22, 2009 -> 14:23:19"!

Delta define: #GenericMirror as: (
(Class subclassOf: 'Mirror' instanceVariables: 'body ')) !


"August 22, 2009 -> 14:23:19"!

Delta define: #GenericMirror as: (
(Class subclassOf: 'Mirror' instanceVariables: 'body ')) !


"August 22, 2009 -> 14:23:19"!

Delta define: #GenericMirror as: (
(Class subclassOf: 'Mirror' instanceVariables: 'body ')) !


"August 22, 2009 -> 14:23:19"!

Delta define: #GenericMirror as: (
(Class subclassOf: 'Mirror' instanceVariables: 'body ')) !


"August 22, 2009 -> 14:23:19"!

Delta define: #GenericMirror as: (
(Class subclassOf: 'Mirror' instanceVariables: 'body ')) !


"August 22, 2009 -> 14:23:19"!

Delta define: #GenericMirror as: (
(Class subclassOf: 'Mirror' instanceVariables: 'body ')) !


"August 22, 2009 -> 14:23:19"!

Delta define: #GenericMirror as: (
(Class subclassOf: 'Mirror' instanceVariables: 'body ')) !


"August 22, 2009 -> 14:23:19"!

(Delta mirrorFor: #GenericMirror)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"August 22, 2009 -> 14:23:19"!

! (Delta mirrorFor: #GenericMirror) classSide methodsFor: 'Unclassified' !
typeArgs: a <Str> body: b  <Mirror>
    ^self new initializeTypeArgs: a body: b! !

"August 22, 2009 -> 14:23:19"!

! (Delta mirrorFor: #GenericMirror) methodsFor: 'Unclassified' !
adjustBounds
"Private"

self body adjustBounds.
! !

"August 22, 2009 -> 14:23:19"!

! (Delta mirrorFor: #GenericMirror) methodsFor: 'Unclassified' !
body  ^ <Mirror>

^body! !

"August 22, 2009 -> 14:23:19"!

! (Delta mirrorFor: #GenericMirror) methodsFor: 'Unclassified' !
body: b   <Mirror>

body := b! !

"August 22, 2009 -> 14:23:19"!

! (Delta mirrorFor: #GenericMirror) methodsFor: 'Unclassified' !
convertToGeneric: g <GenericMirror> ifFail: fb <[Str]>


self deltaHack.

g body class == self body class
  ifTrue:[
               g body convert: self body ifFail: fb.
               self convertTypeTo: g.
                ]
  ifFalse:[fb value: 'Conversion failed - generics have incompatible bodies'].




! !

"August 22, 2009 -> 14:23:19"!

! (Delta mirrorFor: #GenericMirror) methodsFor: 'Unclassified' !
convertTypeTo: g <GenericMirror>

| gt <Generic>  formals <OrdCltn[TypeFormal]> |


gt := Type forDefinition: self body reflectee.
"patch up formals in scope and in gt"
formals :=  (DeltaParser new parseTypeArgs: g typeArgumentString within: DeltaGlobals) collect: [ :pt | pt body].
gt generifyWithFormals: formals.


! !

"August 22, 2009 -> 14:23:19"!

! (Delta mirrorFor: #GenericMirror) methodsFor: 'Unclassified' !
createTypeStructure

self error: 'Should be disabled in this version!!'.
! !

"August 22, 2009 -> 14:23:19"!

! (Delta mirrorFor: #GenericMirror) methodsFor: 'Unclassified' !
definitionString  ^ <Str>

^'Generic forAll: ', self typeArgumentString asString printString, ' body: (', self body basicDefinitionString, ')'! !

"August 22, 2009 -> 14:23:19"!

! (Delta mirrorFor: #GenericMirror) methodsFor: 'Unclassified' !
fileName  ^<Str>
	^self body fileName! !

"August 22, 2009 -> 14:23:19"!

! (Delta mirrorFor: #GenericMirror) methodsFor: 'Unclassified' !
initializeTypeArgs: tas  <Str> body: b  <Mirror>

b nestInGenericWithTypeArguments: tas.
self body: b.! !

"August 22, 2009 -> 14:23:19"!

! (Delta mirrorFor: #GenericMirror) methodsFor: 'Unclassified' !
nameExisting: n <Symbol> ifFail: fb <[Str]>

| b <Mirror> |

b :=  Mirror on: (self priorReflecteeFor: n).
b convertToGeneric: self ifFail: fb.
"self body convert: b ifFail: fb."
b :=  Mirror on: (Delta at: n).
"b nestInGenericWithTypeArguments:  self  typeArgumentString."
self body: b.
"self adjustBounds."

! !

"August 22, 2009 -> 14:23:19"!

! (Delta mirrorFor: #GenericMirror) methodsFor: 'Unclassified' !
nameNew: n <Symbol> ifFail: fb <[Str]>

self body name: n ifFail: fb.
self adjustBounds.! !

"August 22, 2009 -> 14:23:19"!

! (Delta mirrorFor: #GenericMirror) methodsFor: 'Unclassified' !
reflectee  ^ <T>

^self body reflectee! !

"August 22, 2009 -> 14:23:19"!

! (Delta mirrorFor: #GenericMirror) methodsFor: 'Unclassified' !
sourceInfo

	^self body sourceInfo! !

"August 22, 2009 -> 14:23:19"!

! (Delta mirrorFor: #GenericMirror) methodsFor: 'Unclassified' !
typeArgumentString ^ <Str>

^self body typeArgumentString! !

"August 22, 2009 -> 14:23:39"!

Delta define: #MixinDeclMirror as: (
(Class subclassOf: 'MixinMirror' instanceVariables: 'mixinDecl sourceInfo ') classVariables: 'InvocationInfo <VarDict[Mixin, AbstractInvocationData]>') !


"August 22, 2009 -> 14:23:39"!

Delta define: #MixinDeclMirror as: (
(Class subclassOf: 'MixinMirror' instanceVariables: 'mixinDecl sourceInfo ') classVariables: 'InvocationInfo <VarDict[Mixin, AbstractInvocationData]>') !


"August 22, 2009 -> 14:23:39"!

Delta define: #MixinDeclMirror as: (
(Class subclassOf: 'MixinMirror' instanceVariables: 'mixinDecl sourceInfo ') classVariables: 'InvocationInfo <VarDict[Mixin, AbstractInvocationData]>') !


"August 22, 2009 -> 14:23:39"!

Delta define: #MixinDeclMirror as: (
(Class subclassOf: 'MixinMirror' instanceVariables: 'mixinDecl sourceInfo ') classVariables: 'InvocationInfo <VarDict[Mixin, AbstractInvocationData]>') !


"August 22, 2009 -> 14:23:39"!

Delta define: #MixinDeclMirror as: (
(Class subclassOf: 'MixinMirror' instanceVariables: 'mixinDecl sourceInfo ') classVariables: 'InvocationInfo <VarDict[Mixin, AbstractInvocationData]>') !


"August 22, 2009 -> 14:23:39"!

Delta define: #MixinDeclMirror as: (
(Class subclassOf: 'MixinMirror' instanceVariables: 'mixinDecl sourceInfo ') classVariables: 'InvocationInfo <VarDict[Mixin, AbstractInvocationData]>') !


"August 22, 2009 -> 14:23:39"!

Delta define: #MixinDeclMirror as: (
(Class subclassOf: 'MixinMirror' instanceVariables: 'mixinDecl sourceInfo ') classVariables: 'InvocationInfo <VarDict[Mixin, AbstractInvocationData]>') !


"August 22, 2009 -> 14:23:39"!

Delta define: #MixinDeclMirror as: (
(Class subclassOf: 'MixinMirror' instanceVariables: 'mixinDecl sourceInfo ') classVariables: 'InvocationInfo <VarDict[Mixin, AbstractInvocationData]>') !


"August 22, 2009 -> 14:23:39"!

Delta define: #MixinDeclMirror as: (
(Class subclassOf: 'MixinMirror' instanceVariables: 'mixinDecl sourceInfo ') classVariables: 'InvocationInfo <VarDict[Mixin, AbstractInvocationData]>') !


"August 22, 2009 -> 14:23:39"!

Delta define: #MixinDeclMirror as: (
(Class subclassOf: 'MixinMirror' instanceVariables: 'mixinDecl sourceInfo ') classVariables: 'InvocationInfo <VarDict[Mixin, AbstractInvocationData]>') !


"August 22, 2009 -> 14:23:39"!

Delta define: #MixinDeclMirror as: (
(Class subclassOf: 'MixinMirror' instanceVariables: 'mixinDecl sourceInfo ') classVariables: 'InvocationInfo <VarDict[Mixin, AbstractInvocationData]>') !


"August 22, 2009 -> 14:23:39"!

(Delta mirrorFor: #MixinDeclMirror)
comment: 
'This class represents a mirror on a mixin declaration.

The mirror maintains an instance variable, mixinDecl, which is a low level mirror
(a MixinVMMirror) on the actual mixin. Changes are accomplished by forwarding
to this low level mirror. The actual mixin being reflected is also available thru mixinDecl.

Changes to the structure of the mixin are accomplished by creating an uninstalled copy
of the mixin, and performing the changes on it, and the installing the changes atomically
using the changed copy as a constructor which is passed to the VM. The VM also receives
a list of all invocations and their dependent subclasses, so that it can modify them atomically
at the same time.

This process is done using the makeChange:ifFail: method, which in turn invokes the
install:ifFail: method.

Methods are simply added to the mixin, and copied down to invocations. This is not done atomically
at this point.

 (c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) classSide methodsFor: 'Unclassified' !
cleanUp

InvocationInfo keys do: [ :k | k name isNil ifTrue: [ InvocationInfo removeKey: k ]].

! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) classSide methodsFor: 'Unclassified' !
createInvocationOf: mixin <MixinMirror>  named: n <Symbol> superclass: sc <ClassMirror> ifFail: fb <[Str]> ^ <ClassVMMirror>
"h1"
"
create a named invocation of  mixin
"
| klass <ClassVMMirror>  |

klass := self createInvocationValueOf: mixin named: n superclass: sc ifFail: fb.
self addTypeStructureForInvocation: klass.
^klass! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) classSide methodsFor: 'Unclassified' !
createInvocationValueOf: mixin <MixinDeclMirror> named: n <Symbol>  superclass: sc <ClassMirror> ifFail: fb <[Str]> ^ <ClassVMMirror>
"b"
"
create a named invocation value of  mixin
"

| 
klass <ClassVMMirror> 
vmSuperclass <ClassVMMirror> 
vmMixin  <MixinVMMirror> 
|


(Delta includesKey: n) "previous version of n exists"
  ifTrue:[(Delta at: n) isError ifFalse:[ fb value: 'Internal failure: Class ', n , ' already exists']].
vmMixin := MixinVMMirror on: mixin reflectee.
vmSuperclass := ClassVMMirror on: sc reflectee.
klass := ClassVMMirror createInvocationOf: vmMixin named: n superclass: vmSuperclass ifFail: fb.
mixin addInvocation: klass reflectee.
^klass
! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) classSide methodsFor: 'Unclassified' !
init

	InvocationInfo := Dictionary [Mixin, AbstractInvocationData]  new.
! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) classSide methodsFor: 'Unclassified' !
on: mixin <Mixin> ^ <Instance> 

| mixinDecl <MixinVMMirror> |

mixinDecl := MixinVMMirror on: mixin.

^self new reflect: mixinDecl.! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) classSide methodsFor: 'Unclassified' !
superclassType: s  <Str>  body: b  <ClassMirror> ^ <Instance> 
	self deltaHack.  "Should go away once schema changes work"
	^b mixin superclassType: s! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) classSide methodsFor: 'private' !
addBasicTypeStructureForInvocation: class <ClassVMMirror>
"Private" 
| classTypeInfo <MixinInvocationSide> classClassTypeInfo <MixinInvocationSide> |
classTypeInfo := Type atClass: class reflectee 
                                             put:  (DeltaMixinInvocationSide new initialize).
classClassTypeInfo := Type atClass: class classSide reflectee 
                                                        put: (DeltaMixinInvocationSide new initialize).
classTypeInfo  dual: classClassTypeInfo.
classClassTypeInfo  dual: classTypeInfo.
! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) classSide methodsFor: 'private' !
addSuperclassTypeStructureForInvocation: class <ClassVMMirror>

"Private" 
(Type forClass: class reflectee) superclassType: (self classReferenceTo: (class superclass nameIfAbsent:[self error: 'Internal flaw: Use of unnamed superclass'])).
(Type forClass: class classSide reflectee) superclassType: (self metaclassReferenceTo: (class superclass nameIfAbsent:[self error: 'Internal flaw: Use of unnamed superclass'])).

! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) classSide methodsFor: 'private' !
addTypeStructureForInvocation: class <ClassVMMirror>
"e"
"Private"

self addBasicTypeStructureForInvocation: class.
(Type forClass: class reflectee) mixinType: (Type forMixin: class mixin reflectee).
(Type forClass: class classSide reflectee) mixinType: (Type forMixin: class mixin classSide reflectee).
self addSuperclassTypeStructureForInvocation: class.

! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) classSide methodsFor: 'private' !
addTypeStructureForMixin: mixin <MixinVMMirror>
"d"
"Private" 
| cDecl  <ClassUpdate> mixinTypeInfo <SideUpdate> |

cDecl := DeltaClassUpdate new  abstract: false; 
                                                       branded: true; 
                                                       monotonic: true; 
                                                       subtype: true.
mixinTypeInfo :=  DeltaSideUpdate new initialize.
cDecl instanceSide: mixinTypeInfo.

Type atMixin: mixin reflectee put: mixinTypeInfo.
Type atMixin: mixin classSide  reflectee put: (DeltaSideUpdate new initialize classDecl: cDecl).
(Type forMixin: mixin reflectee) superclassType:(self classReferenceTo: #Object).
(Type forMixin: mixin classSide reflectee) superclassType: (self metaclassReferenceTo: #Object).

! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) classSide methodsFor: 'private' !
computeDependentsOf: mixin <MixinDeclMirror> ^ <Array[Class]>
"Private"
"Here we collect all the invocations of mixin and all their subclasses"
| dependents <Array[Class]> |

dependents := Array[Class] new.
mixin vmInvocations do:[:vi <ClassVMMirror> | dependents addAll: vi subclasses].
^dependents.! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) classSide methodsFor: 'private' !
validate: m <MixinVMMirror> name: n <Symbol> superclass: sc <ClassMirror> ifFail: fb <[Str]>
"Private"
"This method performs certain checks to see if associating the name n
with an invocation of mixin could cause problems.

For example, the current version has methods that rely on instance, class or class instance
variables that are not available in mixin or in superclass.
 "! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
abstract

self abstract: true! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
abstract: b <Boolean>

self typeInfo abstract: b.
self sourceInfo abstract: b.! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
addClassVariable: v  <VarDecl> ifFail: blk <[Str]>


self isMeta ifTrue:[blk value: 'One cannot add class variables to meta mixins'].
self makeChange:[:mvm <MixinVMMirror> | mvm addClassVarName: v name ifFail: blk]
        ifFail: blk.

self typeInfoAddClassVariable: v.! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
addInstanceVariable: v  <VarDecl> ifFail: fb <[Str]>

self makeChange:[:mvm <MixinVMMirror> | mvm addInstVarName: v name ifFail: fb]
        ifFail: fb.

self typeInfoAddInstanceVariable: v.
          ! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
addInvocation: inv <Class>

self isMeta ifTrue: [ self error: 'Should not be called for meta-side' ].
self invocationInfo addInvocation: inv.
! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
addMethod: mtd <DeltaMethod> to: inv <ClassVMMirror>
"
Private
"
| m <Method> |

m := self compileMethod: mtd within: inv ifFail:[:e <Str> | self error: 'Internal failure. Cannot compile ', mtd selector, ' within ', inv name, ' : ', e].
inv addMethod: m ifFail:[:e <Str> | self error: 'Internal failure. Cannot add ', mtd selector, ' to ', inv name, ' : ', e].! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
addMethod: str <Str> visibility: vis <Symbol> category: cat <Symbol> ifFail: blk <[Str]> ^ <ParseTree>
	"This is the method to be called to add a method to a mixin"

	| pt <ParseTree> |

	pt := self insertMethod: str visibility: vis category: cat ifFail: blk.
	
	"We do not clear the body here since the caller may need the parse tree.
	The caller is responsible for sending #clearBody to the ast.
	All of this will go away once the type information no longer stores DeltaMethods."

	^pt
! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
addPool: name <Str> ifFail: fb <[Str]>

self deltaHack.
self halt.! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
basicDefinitionString  ^ <Str>

self isMeta 
  ifFalse:[^'Mixin superclassType: ', self superclassTypeString asString printString,  ' body: (', self body definitionString, ')']
  ifTrue:[self deltaHack. self shouldNotHappen].! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
basicLocator  ^ <BasicMixinLocator> 
	^self typeInfo basicLocator! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
body ^ <ClassMirror>

| newBody <ClassMirror> |

self superclassTypeString isEmpty "This is Object"
   ifTrue:[newBody := Class delta]
   ifFalse:[newBody :=  (Class subclassOf: self superclassTypeString
                                                         instanceVariables: self instanceVariableString).
                  ].
newBody := newBody
                                    classVariables: self classVariableString;
                                    protocols: self supportedProtocolString;
                                    classProtocols: self classSide supportedProtocolString.

self isAbstract ifTrue:[newBody abstract].
self extensionsAreSubtypes ifFalse:[newBody extensionsAreNotSubtypes].
self isSubtype ifFalse:[newBody notSubtype].
self isBranded ifFalse:[newBody unbranded].
^newBody

         ! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
body: b  <ClassMirror>

self isMeta ifTrue:[self halt].
self conformToShape: b.
self conformBodyTypeTo:  b.

! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
branded: b <Boolean>

self typeInfo branded: b.
self sourceInfo branded: b! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
changeClassVariablesTo: list <Cltn[VarDecl]>
"Private"

| newDecls <Cltn[VarDecl]> existingDecls <Cltn[VarDecl]> deletedDecls <Cltn[VarDecl]> |

self nonAtomic.

newDecls := OrderedCollection[VarDecl] new.
existingDecls := OrderedCollection[VarDecl] new.
deletedDecls := OrderedCollection[VarDecl] new.

list do: [ :v <VarDecl> | 
	(self classVariableAt: v name ifAbsent: [ nil ]) isNil
		ifTrue: [ newDecls add: v ]
		ifFalse: [ existingDecls add: v ] ].

self classVariablesDo: [ :v <VarDecl> | 
	list detect: [ :e <VarDecl> | e name = v name ] ifNone: [ deletedDecls add: v ] ].

"Remove surplus inst vars"
deletedDecls do: [ :v <VarDecl> | 
	self removeClassVariable: v name ifAbsent: [ self error: 'Cannot remove class variable ', v name, ' from ', self name ] ].

"Add new inst vars"
newDecls do: [ :v <VarDecl> | 
	self addClassVariable: v  ifFail: [ self error: 'Cannot add class variable ', v name, ' to ', self name ] ].

"Update type information on existing inst vars"
existingDecls do: [ :v <VarDecl> | 
	(self classVariableAt: v name ifAbsent: [ self error: 'Should not happen' ]) name: v name type: v type ].

"
self removeAllClassVariables.
list do:[:v <VarDecl> | self addClassVariable: v 
                                                                ifFail:[:e <Str> | self error: 'Failed attempt to install class variable ', v name, ' in mixin ', self name, ' : ', e]].
"! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
changeInstanceVariablesTo: list <Cltn[VarDecl]>
"Private"

| oldDecls <Cltn[VarDecl]> names <OrdCltn[Symbol]> |

self error: 'Should not be called anymore'.
self nonAtomic.
oldDecls := OrderedCollection[VarDecl] new.
self instanceVariablesDo: [ :v <VarDecl> | oldDecls add: v ].
names := list collect: [: v <VarDecl> | v name].

self makeChange: [:mvm <MixinVMMirror> |
                                     mvm changeInstanceVariablesTo: names]
         ifFail: [:s <Str> | self error: s ].

"Now we have changed the mixin; we must adjust the type info"
"Remove old inst vars from the type info"
oldDecls do: [ :v <VarDecl> | 
	self typeInfoRemoveInstanceVariable: v name].

"Add new inst vars to the type info"
list do: [ :v <VarDecl> | 
	self typeInfoAddInstanceVariable: v].

! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
changeMethod: oldAST <MethodDecl> to: newAST  <MethodDecl>

| typeInfo <SideUpdate>  |
" Private "
"Take whatever action is needed when a method changes from oldAST to newAST"

typeInfo := self typeInfo.
typeInfo errorHandler pushDefinition: typeInfo.
typeInfo errorHandler pushSelector: newAST selector.

" update dependencies"
self updateDependenciesFrom: oldAST to: newAST.

"Check if interface has changed, and take appropriate action"
self handleInterfaceChangeFrom: oldAST to: newAST.

typeInfo errorHandler popSelector.
typeInfo errorHandler popDefinition.! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
changePoolsTo: list  <Cltn[Str]>

"Private"

self deltaHack.
self halt.
! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
changeToMixin: mixin <MixinVMMirror> 
oldClasses: ocs <OrderedCollection[Class]>
newClasses: ncs <OrderedCollection[ClassMirror]>
ifFail: fb <[Str, ^DoesNotMatter]> ^ <MixinDeclMirror>

| 
existed <Boolean> 
invocations <SequenceableCollection[Class]>
change <Array[Mixin | Array[Class|Symbol]]>
cvns  <OrderedCollection[Symbol]>
mixinFormat <Symbol>
|

"If I mirror a meta mixin, I ask my instance side to install itself.  The installation is
always done in pairs, with the instance side as the argument to the primitive. "

self isMeta ifTrue:[^self instanceSide changeToMixin:  mixin instanceSide oldClasses: ocs newClasses: ncs  ifFail: fb].
ocs size = ncs size ifFalse:[fb value: 'Number of new classes does not match number of old classes'].
invocations := ClassVMMirror sort: self invocationInfo invocations. 
invocations isEmpty ifTrue:[self shouldNotHappen].
mixin name = self name ifFalse:[fb value: 'Attempt to replace mixin ', self name, ' with mixin ', mixin name].
mixinFormat := self mixinDecl format. 
"The format of the mixin itself can never change. If this turns out to be a problem, we will keep the format
in the VM"
change := Array[Mixin | Array[Class|Symbol]] new: 2 + invocations size.
change at: 1 put: mixin reflectee; 
                at: 2 put: self reflectee.
invocations with: (3 to: invocations size + 2)
						do:[: inv <Class> :i <Integer> |              
								change at: i put: (self prepareInvocation: inv mixinFormat: mixinFormat oldClasses: ocs newClasses: ncs ifFail: fb).
								].
{{primitiveApplyChange: change ifFail: [:e <CompressedSymbol> | fb value: e]}}.
ocs isEmpty ifFalse:[AbstractClassMirror flushSubclassHierarchyCache].
             
! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
classProtocols: p  <Str> 

self classSide supportedProtocol: p! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
classVariableAt: aName <Symbol> ifAbsent: aBlock <[]> ^ <VarDecl>

(self mixinDecl hasClassVarName: aName) ifFalse:[^aBlock value].
self classVariablesDo:[:v <VarDecl> | v name = aName ifTrue:[^v]].
^aBlock value.! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
classVariableString ^ <Str>

^self isMeta ifTrue:[self deltaHack. self error: 'Ask non-metaclass for class variables string']
                        ifFalse:[self sourceInfo classVariableString].
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
classVariables: vars <Str>

| oldNames <Cltn[Symbol]> newNames <OrdCltn[Symbol]> newDecls <OrdCltn[VarDecl]> |

self deltaHack.
"We parse in a dummy scope since the parser insert the classvar decls in the scope and will complain about existing ones."
newDecls := (DeltaParser new parseClassVarList: vars within: (DeltaScope within: nil)) collect: [ :pt <ParseTree[VarDecl]> | pt body scope: DeltaGlobals].

self nonAtomic.
oldNames := OrderedCollection[Symbol] new.
self classVariablesDo: [ :v <VarDecl> | oldNames add: v name ].
newNames := newDecls collect: [: v <VarDecl> | v name].

self makeChange: [:mvm <MixinVMMirror> |
                                     mvm changeClassVariablesTo: newNames]
         ifFail: [:s <Str> | self error: s ].

"Now we have changed the mixin; we must adjust the type info"
"Remove old class vars from the type info"
oldNames do: [ :name <Symbol> | 
	self typeInfoRemoveClassVariable: name ].

newDecls do: [ :v <VarDecl> |
	self typeInfoAddClassVariable: v  ].

self sourceInfo classVariableString: vars.
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
classVariablesDo: blk <[VarDecl]>


"does this really take var decls?"
| typeInfo <SideUpdate> |

typeInfo := self typeInfo .
typeInfo  classVarDecls do: blk.
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
cloneConformingToShape: b <ClassMirror> ^ <MixinVMMirror>
"Private"
"Return a clone of myself,  whose shape conforms to that of b"
| clone <MixinVMMirror> |

clone := MixinVMMirror onCopyOf: self reflectee.
^self conform: clone toShape: b
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
combinedFormatOfMixin: m <Mixin> andSuperclass: sc <Class> ifFail: fb <[Str, ^DoesNotMatter]> ^ <Symbol>

^ self combinedFormatOfMixinFormat: m format andSuperclassFormat: sc format ifFail:fb.! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
combinedFormatOfMixinFormat: m <Symbol> andSuperclassFormat: sc <Symbol> ifFail: fb <[Str, ^DoesNotMatter]> ^ <Symbol>
"Private"
sc = m ifTrue:[^m].
m = #Oops ifTrue:[^sc].
sc = #Oops ifTrue:[^m].


fb value: 'Incompatible formats: mixin has format ', m , ' and superclass has format ', sc.! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
comment  ^ <Str> 

^self sourceInfo comment! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
comment: c  <Str> 

self sourceInfo comment: c
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
compileMethod: m <DeltaMethod> ifFail: fb  <[Str]>  ^ <Method>
"Private"
	
	^self compileMethod: m within: self mixinDecl ifFail: fb! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
compileMethod: m <DeltaMethod> within: d <ClassVMMirror | MixinVMMirror> ifFail: blk  <[Str]>  ^ <Method>
"Private"

	^(DeltaCompiler forClass: d optimize: false ifError: [:e <Str> | ^blk value: e]) compile: (DeltaRewriter new rewrite: m)! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
compiledMethodAt: selector <Symbol> ifFail: blk   <[^X def]> ^ <Method | X>

	^self mixinDecl methodAt: selector ifFail: blk! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
compiledMethodsDo: blk  <[Method]>

	self mixinDecl methodsDo: blk! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
conform: m <MixinVMMirror> toShape: b <ClassMirror> ^ <MixinVMMirror>
"Private"
"make m's shape conform to that of b"
| noClassVars <Boolean> bvs <VarOrdCltn[Symbol]> |

b isMeta ifTrue:[self error: 'Attempt to modify meta mixin directly'].

bvs := OrderedCollection[Symbol] new.
b instanceVariablesDo:[:v <VarDecl> | bvs add: v name].
m changeInstanceVariablesTo: bvs.

bvs := OrderedCollection[Symbol] new.
b classVariablesDo:[:v <VarDecl> | bvs add: v name].
m changeClassVariablesTo: bvs.  

bvs := OrderedCollection[Symbol] new.
b mixin classSide instanceVariablesDo:[:v <VarDecl> | bvs add: v name].
m classSide changeInstanceVariablesTo: bvs.                                                  
              
" must eventually do same for pools"
^m
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
conformBodyTypeTo: b <ClassMirror>
"Private"
|  bType <SideUpdate> |

"modify type information"
self mayNeedToUnwind.
bType :=  (Type forMixin: b mixin reflectee).

self abstract: bType abstract.
self subtype: bType subtype.
self branded: bType branded.
self extensionsAreSubtypes: bType extensionsAreSubtypes.

self protocols: b mixin supportedProtocolString.

self typeInfoClassVariables: b mixin  classVariableString.
self typeInfoInstanceVariables: b mixin instanceVariableString.

self classSide protocols: b mixin classSide supportedProtocolString.
self classSide typeInfoInstanceVariables: b mixin classSide instanceVariableString! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
conformToShape: b <ClassMirror>
"Private"
| clone <MixinVMMirror> |

self installed 
	ifTrue:["Clone myself,  make its shape conform to that of b, and install it in my place"
					clone := self cloneConformingToShape: b.
					"install clone "
					self install: clone 
							 ifFail:[:e <Str> | self error: 'Inconsistency when attempting to modify ', self name, ' ', e].
				]
	ifFalse:[self conform: self mixinDecl toShape: b].
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
convert: m <Mirror> ifFail: fb <[Str]>

m convertToMixin: self ifFail: fb.



! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
convert: m <Mirror> toGeneric: g   <GenericMirror> ifFail: fb <[Str]>

self assert: [g body = self].
m convertToGenericMixin: g ifFail: fb.! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
convertToGenericMixin: g <GenericMirror> ifFail: fb <[Str]>

self convertToMixin: g body ifFail: fb.
self nestInGenericWithTypeArguments: g typeArgumentString.
self adjustBounds.

! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
convertToMixin: m <MixinDeclMirror> changingClass: oldClass <ClassMirror> to: newClass <ClassMirror> ifFail: fb <[Str, ^DoesNotMatter]>

| clone <MixinVMMirror> b <ClassMirror> |

self installed ifFalse:[self shouldNotHappen].
self isMeta
  ifFalse:[
                 m superclassTypeString isEmpty ifFalse:[self superclassType: m  superclassTypeString].
                 b := m body.
                 clone := self cloneConformingToShape: b.
                   "install clone " 
                self changeToMixin: clone 
                         oldClasses: (OrderedCollection[Class] new  add: oldClass reflectee; yourself)
                         newClasses: (OrderedCollection[ClassMirror] new add: newClass; yourself)
                         ifFail: [:e <Str> | self error: 'Inconsistency when attempting to modify ', self name].
                 self conformBodyTypeTo:  b.
                 ]
  ifTrue:[self instanceSide convertToMixin: m instanceSide changingClass: oldClass instanceSide to: newClass instanceSide ifFail: fb].! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
convertToMixin: m <MixinDeclMirror> ifFail: fb <[Str]>

self isMeta
  ifFalse:[
                 m superclassTypeString isEmpty ifFalse:[self superclassType: m  superclassTypeString].
                 self body: m body.
                ]
  ifTrue:[self instanceSide convertToMixin: m instanceSide ifFail: fb].! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
extensionsAreNotSubtypes

^self extensionsAreSubtypes: false! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
extensionsAreSubtypes ^ <Boolean>

^(self sourceInfo extensionsAreSubtypesString  = #false) not! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
extensionsAreSubtypes: e <Boolean>

self typeInfo extensionsAreSubtypes: e.
self sourceInfo extensionsAreSubtypes: e.
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
formatFor: c <ClassVMMirror>   mixinFormat: mf <Symbol> formats: formats <VarDict[Class, Symbol]> ifFail: fb <[Str, ^DoesNotMatter]> ^ <Symbol>
"Private"
|  f  <Symbol> |

c isNil ifTrue: [^#Oops].
c format = #Special ifTrue:[^#Special]. "Magic things like blocks etc."
"Weak arrays are a special case.  We check if the weak array mixin is used, and if so check to see if
the superclass is Array. Other cases are banned"

c mixin reflectee = IndexedNextOfKinInstanceVariables
  ifTrue:[
                c superclass reflectee = Array ifFalse:[self error: 'Bad Magic for weak arrays'].
               ^#IndexedNextOfKinInstanceVariables
               ].
 

f := formats at: c reflectee ifAbsent:[c format].
f isNil ifTrue:[                         
                         f := self combinedFormatOfMixinFormat: mf  
                                         andSuperclassFormat: (self formatFor: c superclass mixinFormat: mf formats: formats ifFail: fb) ifFail: fb.
                          formats at: c reflectee put: f
                          ].
^f

            ! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
formatsOf: cs <Cltn[Class]> mixinFormat: mixinFormat <Symbol> ifFail: fb <[Str, ^DoesNotMatter]> ^ <VarDict[Class, Symbol]>

| 
j  <Integer>
formats <VarDict[Class, Symbol]>
dm <ClassVMMirror>
|

formats := IdentityDictionary[Class, Symbol] new: cs size.
cs do:[:d <Class> | formats at: d put: nil].
cs do:[: d <Class> | 
			dm := ClassVMMirror on: d.
			(self formatFor: dm mixinFormat: dm mixin format formats: formats ifFail: fb). " new format, if legal !!"
			].
^formats! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
handleInterfaceChangeFrom: oldAST  <MethodDecl>  to: newAST  <MethodDecl>
"Private"
"Check if interface has changed, and take appropriate action"
| 
nsig <MsgSignature> 
osig <MsgSignature> 
sub <Boolean> 
sup <Boolean> 
typeInfo <SideUpdate>
|

"compare old and new signatures to determine interface change."
nsig := newAST type.
osig := oldAST type.
typeInfo := self typeInfo .

typeInfo setupTypeAssumptions.
DeltaSilentTypeErrorHandler new catchErrorsFor: [		"Only the result is relevant, not potential errors since they cannot be reported in a meaningful way anyway"
	sub := nsig subtypeOf: osig assuming: DeltaGlobalTrail.
	sup := osig subtypeOf: nsig assuming: DeltaGlobalTrail.
].
 typeInfo  retractTypeAssumptions.

(sub and:[sup]) ifTrue:[^self].
sub ifTrue:[^self heirsCheckSelector: newAST selector withSignature: nsig].
self noteFilteredSendersOf: newAST selector.
sup ifTrue:[
                     self nonSubtypeHeirsCheckSelector: newAST selector withSignature: nsig.
                    "test structural assumptions?"
                     ]
      ifFalse:[self heirsCheckSelector: newAST selector withSignature: nsig].! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
hasSelector: selector <Symbol> ^ <Boolean>

	self compiledMethodAt: selector ifFail: [ ^false ].		"We use compiled methods here since otherwise type info will have to be loaded"
	^true! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
heir: ih <Decl> checkSelector: sel <Symbol> withSignature: sig  <MsgSignature>

"Private.
Check heir ih to see whether it conflicts typewise with the signature sig of selector sel"
| ihSig <MsgSignature> typeInfo <SideUpdate>  ihTypeInfo <MixinInvocationSide> |

ihTypeInfo := Type forMixin: ih mixin reflectee.
typeInfo := self typeInfo .

(ihTypeInfo functions includesKey: sel)
       ifTrue:[
                     typeInfo errorHandler pushDefinitions: ihTypeInfo and: typeInfo.
                     typeInfo errorHandler pushSelector: sel.
                     ihSig := (ihTypeInfo functions at: sel) type.
                     ihTypeInfo subtype
                           ifTrue:[ "need to set and retract type assumptions"
                                        ihTypeInfo setupTypeAssumptions.                          
                                        (ihSig subtypeOf: sig assuming: DeltaGlobalTrail)
                                                 ifFalse:[ typeInfo reportError: DeltaMsgConflictSubtypeInSubError new.].
                                          ihTypeInfo retractTypeAssumptions.
                                          ]
                             ifFalse:[
                                            (ihSig subtypeOf: sig assuming: DeltaGlobalTrail)
                                                      ifFalse:[ typeInfo reportError: DeltaMsgConflictInheritedtypeInSubError new.].
                                            ].
                           typeInfo errorHandler popDefinitions.
                           typeInfo errorHandler popSelector.     
                          ].
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
heirScope  ^ <Scope>

"delete"
self deltaHack.

^(DeltaOverrideScope new base: self superclass heirScope;
                                                     delta: self localScope; yourself)
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
heirsCheckSelector: sel <Symbol> withSignature: sig  <MsgSignature>

"Private.
Check all heirs to see whether they conflict typewise with the signature sig of selector sel"

self immediateHeirs do:[:ih <Decl> |
                                               self heir: ih checkSelector: sel withSignature: sig
                                              ].! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
immediateHeirs  ^ <OrdCltn[ClassMirror]>
	"Return a collection of immediate heirs for all invocations"
	| heirs  <OrdCltn[ClassMirror]> |
	heirs := OrderedCollection[ClassMirror] new.
	self invocations do: [ :inv <AbstractClassMirror> | heirs addAll: inv immediateHeirs ].
	^heirs! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
initializeSuperclassType: s body: b

"self reflect: MixinVMMirror createNewMixin."
self superclassType: s.
self body: b.
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
insertMethod: src <Str> visibility: vis <Symbol> category: cat <Symbol> ifFail: blk <[Str]> ^ <ParseTree>
"Private"
"
This  method is used internally to add a method to a mixin. It is
factored out so that both the typechecking and non-typechecking versions
of adding a method can share almost all the code
"

| pt <ParseTree> method <Method> ast  <DeltaMethod> oldAST  <DeltaMethod> |

    pt := self parseMethod: src ifFail: blk.
    ast := pt body.
    ast visibility: vis.
	
	"Wrong. What about inherited stuff, or messages"
    oldAST := self hasFullTypeInfoLoaded
                                   ifTrue:[self typeInfo methods at: ast selector 
                                                            						ifAbsent:[self typeInfo messages at: ast selector 
                                                                                                                       						 ifAbsent:[nil] ] ].

	method := self compileMethod: ast ifFail: blk.
    self makeChange:[:mvm <MixinVMMirror> | mvm addMethod: method ifFail: blk]
        ifFail: blk.
	self hasFullTypeInfoLoaded ifTrue:[self typeInfo addMethod: ast].
	
	self sourceInfo source: src category: cat 	visibility: vis typeFormat: (ast type formattedName: pt) forSelector: ast selector.

	"ast timeSaved: Time dateAndTimeNow."
	"oldAST isNil ifFalse:[self changeMethod: oldAST to: ast.]."
	
	^pt
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
install

^self mixinDecl install! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
install: mixin <MixinVMMirror> ifFail: fb <[Str, ^DoesNotMatter]> ^ <MixinDeclMirror>
"
Private.

This method installs mixin into the vm as my mixin."

^self changeToMixin: mixin 
         oldClasses: OrderedCollection[Class] new 
         newClasses: OrderedCollection[ClassMirror] new
         ifFail: fb
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
installed  ^ <Boolean>
"Private"

self invocationInfo invocations isEmpty
	ifTrue:[self uninstall].
^self mixinDecl installed! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
instanceVariableAt: aName <Symbol> ifAbsent: aBlock <[]>

(self mixinDecl hasInstVarName: aName) ifFalse:[^aBlock value].
self instanceVariablesDo:[:v <VarDecl> | v name = aName ifTrue:[^v]].
^aBlock value.! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
instanceVariableString ^ <Str>

^self sourceInfo instanceVariableString
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
instanceVariables: vars <Str>

| oldNames <Cltn[Symbol]> newNames <OrdCltn[Symbol]> newDecls <OrdCltn[VarDecl]> |

self deltaHack.
"We parse in a dummy scope since the parser insert the instvar decls in the scope and will complain about existing ones."
newDecls := (DeltaParser new parseInstVarList: vars within: (DeltaScope within: nil)) collect: [ :pt <ParseTree[VarDecl]> | pt body scope: self scope].

self nonAtomic.
oldNames := OrderedCollection[Symbol] new.
self instanceVariablesDo: [ :v <VarDecl> | oldNames add: v name ].
newNames := newDecls collect: [: v <VarDecl> | v name].

self makeChange: [:mvm <MixinVMMirror> |
                                     mvm changeInstanceVariablesTo: newNames]
         ifFail: [:s <Str> | self error: s ].

"Now we have changed the mixin; we must adjust the type info"
"Remove old inst vars from the type info"
oldNames do: [ :name <Symbol> | 
	self typeInfoRemoveInstanceVariable: name ].

self sourceInfo instanceVariableString: vars.
newDecls do:[:v <VarDecl> | self typeInfoAddInstanceVariable: v].
"Reparse again to redeclare instvar decls. This should be changed shortly!!
DeltaParser new parseInstVarList: vars within: self scope."
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
instanceVariablesDo: blk  <[VarDecl]>

| typeInfo <SideUpdate> sorted |

typeInfo := self typeInfo.
self deltaHack.
sorted := SortedCollection[DeltaInstVar] new sortBlock: [:a <DeltaInstVar>  :b <DeltaInstVar> | a ordinalNumber <= b ordinalNumber].
typeInfo  instVarDecls do: [:v <DeltaInstVar> | sorted add: v].
sorted do: blk.
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
invocationInfo ^<AbstractInvocationData>

	^InvocationInfo at: self reflectee ifAbsent: [ self error: 'Inconsistency in invocation data' ].! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
invocations  ^<Cltn[AbstractClassMirror]> 

	^self invocationInfo invocations collect: [ :class <Class> | AbstractClassMirror on: class ]
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
isAbstract ^ <Boolean>

^self sourceInfo abstractString  = #true! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
isBranded ^ <Boolean>

^(self sourceInfo brandedString  = #false) not! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
isMeta ^ <Boolean> 

^self reflectee isMeta! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
isSubtype ^ <Boolean>

^(self sourceInfo subtypeString  = #false) not! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
komment

"This class represents a mirror on a mixin declaration.

The mirror maintains an instance variable, mixinDecl, which is a low level mirror
(a MixinVMMirror) on the actual mixin. Changes are accomplished by forwarding
to this low level mirror. The actual mixin being reflected is also available thru mixinDecl.

Changes to the structure of the mixin are accomplished by creating an uninstalled copy
of the mixin, and performing the changes on it, and the installing the changes atomically
using the changed copy as a constructor which is passed to the VM. The VM also receives
a list of all invocations and their dependent subclasses, so that it can modify them atomically
at the same time.

This process is done using the makeChange:ifFail: method, which in turn invokes the
install:ifFail: method.

Methods are simply added to the mixin, and copied down to invocations. This is not done atomically
at this point.
"! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
localScope  ^ <Scope>

"delete"
self deltaHack.

^DeltaScope new on: self ! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
makeChange: changeBlock <[MixinVMMirror, ^MixinVMMirror]> ifFail: fb <[Str]>

| copy <MixinVMMirror> |

self installed
  ifTrue:[
               copy := changeBlock value: (MixinVMMirror onCopyOf: self reflectee).
                self install: copy ifFail: fb "install copy"
                ]
  ifFalse:[changeBlock value: (MixinVMMirror on: self reflectee)]! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
masterInvocation  ^<Class> 

	^self mixinDecl masterInvocation! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
masterInvocation: c  <Class>  ifFail: fb <[Str]>

self isMeta ifTrue:[self error: 'Should not be called on meta side'].
self invocationInfo invocations size = 1 ifFalse: [^fb value: 'More than one master invocation'].		"The invocations should contain cm as the only element"
self invocationInfo invocations first  == c ifFalse: [^fb value: 'Master invocations not identical'].
self mixinDecl masterInvocation: c ifFail: fb.


! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
methodAt: selector <Symbol> ifFail: blk   <[^X def]> ^ <DeltaMethod | X>

self methodsDo: [:m <DeltaMethod> | m selector = selector ifTrue: [^m]].
^blk value
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
methodsDo: blk  <[DeltaMethod]>

| typeInfo <SideUpdate> |

typeInfo := self typeInfo .
typeInfo  methods do: blk.
typeInfo messages do: blk.! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
methodsFor: category <String>
    ^DefinitionReader for: self category: category
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
mixinDecl  ^ <MixinVMMirror>

^mixinDecl! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
mixinDecl: md <MixinVMMirror>

"self assert:[md isKindOf: MixinVMMirror]."
mixinDecl := md! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
nameExisting: n <Symbol> ifFail: fb <[Str]>

self nonAtomic.
self mixinDecl name: n ifFail: fb.
(Mirror on: (self priorReflecteeFor: n)) convertToMixin: self ifFail: fb.
                          ! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
nameNew: n <Symbol> ifFail: fb <[Str]>

"Must check if n exists already. If so, we must update it to reflect the
state of this mixin.
"
self setName: n ifFail: fb.
self install.
Delta at: n put: self reflectee.
      ! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
nestInGenericWithTypeArguments: tas  <Str>

super nestInGenericWithTypeArguments: tas.
self isMeta ifFalse:[self sourceInfo typeArgumentString: tas].! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
nonSubtypeHeir: ih <Decl> checkSelector: sel <Symbol> withSignature: sig  <MsgSignature>

"Private.
Check heir ih to see whether it conflicts typewise with the signature sig of selector sel"
| ihSig <MsgSignature>  typeInfo <SideUpdate>  ihTypeInfo <MixinInvocationSide> |


ihTypeInfo := Type forClass: ih reflectee.
typeInfo := self typeInfo .

(ihTypeInfo functions includesKey: sel)
       ifTrue:[
                      typeInfo errorHandler pushDefinitions: ihTypeInfo and: typeInfo.
                      typeInfo errorHandler pushSelector: sel.
                     ihSig := (ihTypeInfo functions at: sel) type.
                     ihTypeInfo  subtype
                             ifFalse:[
                                            (ihSig subtypeOf: sig assuming: DeltaGlobalTrail)
                                                      ifFalse:[ typeInfo reportError: DeltaMsgConflictInheritedtypeInSubError new.].
                                            ].
                           typeInfo errorHandler popDefinitions.
                           typeInfo errorHandler popSelector.     
                          ].
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
nonSubtypeHeirsCheckSelector: sel <Symbol> withSignature: sig  <MsgSignature>

"Private.
Check all heirs that are inherited types of me to see whether they conflict typewise with the siganture sig of the
selector sel"

self immediateHeirs do:[:ih <Decl> |
                                               self nonSubtypeHeir: ih checkSelector: sel withSignature: sig
                                               ].! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
notSubtype

self subtype: false! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
noteFilteredSendersOf: sel <Symbol>

" Private.
This method is intended to make a note of all potentially problematic
senders of the message sel.  Collect all senders, and filter
them according to a suitable criterion. Then add these to the set of
methods that may require typechecking."

| unfilteredSenders  <Set[MethodLocator]>  senders  <Set[MethodLocator]>  |

unfilteredSenders := self sendersOf:  sel.
"Here is where we supposedly filter out irrelevant sends. Currently we just select those 
methods that had successfully typechecked  "

senders := unfilteredSenders select:[:s | s deltaMethod  typecheckedSuccessfully].
 "add all relevant senders to the list of methods that must be re-typechecked"
senders do:[: sender  <MethodLocator>  | DeltaMethodsToRevisit add: sender.].
  





! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
parseMethod: src <Str> ifFail: blk <[Str,Int]> ^ <ParseTree[DeltaMethod]>

	| scope <Scope> mi <Class> |
	"We use a constructed untyped scope if no type information is loaded.
		This is currently only enabled for mixins with a master invocation (since 
		currently computing the superclass type class object for a pure mixin will 
		cause type information to be loaded)."
	scope := (self hasTypeInfoLoaded or: [ (mi := self masterInvocation) isNil])
		ifTrue: [		self scope ]
		ifFalse: [	DeltaUntypedClassScope for: (AbstractClassMirror on: mi) ].
	^DeltaParser new parseMethod: src within: scope ifError: blk
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
poolString ^ <Str>

^self sourceInfo poolString! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
pools: pools  <Str> 

self assert: [ pools isString ].
self changePoolsTo: ((DeltaParser new parseIdList: pools within: DeltaGlobals) collect: [ :pt <ParseTree[Ref]> | pt body])! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
prepareInvocation2: inv <Class> mixinFormat: mixinFormat <Symbol> 
oldClasses: ocs <OrderedCollection[Class]> newClasses: ncs <OrderedCollection[ClassMirror]> 
ifFail: fb <[Str, ^DoesNotMatter]> ^  <Array[Class|Symbol]>
| 
dependents <Collection[Class]>
a <Array[Class | Symbol]>
mir <ClassVMMirror>
j  <Integer>
formats <VarDict[Class, Symbol]>
sc <ClassVMMirror | ClassMirror>
dm <ClassVMMirror>
formatMightChange <Boolean>
fmt <Symbol> 
|

                                      
mir := ClassVMMirror on: inv.
dependents := mir sortedSubclasses remove: inv; yourself.
formats := IdentityDictionary[Class, Symbol] new.
formatMightChange := ocs isEmpty not.
formatMightChange 
	ifTrue:[
				formats at: inv put: nil.
				dependents do:[:d <Class> | formats at: d put: nil].
				fmt := self formatFor: mir mixinFormat: mixinFormat formats: formats ifFail: fb.
				]
	ifFalse:[fmt := mir format].
a := Array[Class | Symbol] new: 3 + (dependents size * 2).
a at: 1 put: inv.
a at: 2 put: fmt. " new format, if legal !!"
sc := ((ocs includes: inv)
			ifTrue:[ncs at: (ocs indexOf: inv ifAbsent:[self error: 'Internal failure in change'])]
			ifFalse:[mir]) superclass.
a at: 3 put: (sc notNil ifTrue:[sc reflectee] ifFalse:[nil]).
j := 4.
dependents do:[: d <Class>  | 
								dm := ClassVMMirror on: d.
								a at: j put: d.
								fmt := formatMightChange 
									ifTrue:[self formatFor: dm mixinFormat: dm mixin format formats: formats ifFail: fb]
									ifFalse:[dm format].
								a at: j + 1 put:  fmt. " new format, if legal !!"
								j := j + 2.
								].                           
^a! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
prepareInvocation: inv <Class> mixinFormat: mixinFormat <Symbol> 
oldClasses: ocs <OrderedCollection[Class]> newClasses: ncs <OrderedCollection[ClassMirror]> 
ifFail: fb <[Str, ^DoesNotMatter]> ^  <Array[Class|Symbol]>
| 
dependents <Collection[Class]>
a <Array[Class | Symbol]>
mir <ClassVMMirror>
j  <Integer>
formats <VarDict[Class, Symbol]>
sc <ClassVMMirror | ClassMirror>
dm <ClassVMMirror>
formatMightChange <Boolean>
fmt <Symbol> 
|

                                      
mir := ClassVMMirror on: inv.
dependents := mir sortedSubclasses remove: inv; yourself.
formats := IdentityDictionary[Class, Symbol] new.
formatMightChange := ocs isEmpty not.
formatMightChange 
	ifTrue:[
				formats at: inv put: nil.
				dependents do:[:d <Class> | formats at: d put: nil].
				fmt := self formatFor: mir mixinFormat: mixinFormat formats: formats ifFail: fb.
				]
	ifFalse:[fmt := mir format].
a := Array[Class | Symbol] new: 3 + (dependents size * 2).
a at: 1 put: inv.
a at: 2 put: fmt. " new format, if legal !!"
sc := ((ocs includes: inv)
			ifTrue:[ncs at: (ocs indexOf: inv ifAbsent:[self error: 'Internal failure in change'])]
			ifFalse:[mir]) superclass.
a at: 3 put: (sc notNil ifTrue:[sc reflectee] ifFalse:[nil]).
j := 4.
dependents do:[: d <Class>  | 
								dm := ClassVMMirror on: d.
								a at: j put: d.
								fmt := formatMightChange 
									ifTrue:[self formatFor: dm mixinFormat: dm mixin format formats: formats ifFail: fb]
									ifFalse:[dm format].
								a at: j + 1 put:  fmt. " new format, if legal !!"
								j := j + 2.
								].                           
^a! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
privateMethodsFor: category <String>

	"For compatability"
    ^self methodsFor: category
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
protocols: p  <Str> 

self supportedProtocol: p! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
publicMethodsFor: category <String>

	"For compatability"
    ^self methodsFor: category
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
recompileAllMethodsIfFail: blk <[]>

	self compiledMethodsDo: [ :method <Method> |
		self recompileMethod: method selector ifFail: blk ]! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
recompileMethod: selector <Symbol> ifFail: blk <[]>

	| src <Str> method <Method> ast  <DeltaMethod> |

	src := self sourceForSelector: selector.
	ast := (self parseMethod: src ifFail: blk) body.
	method := self compileMethod: ast ifFail: blk.
	self makeChange:[:mvm <MixinVMMirror> | mvm addMethod: method ifFail: [^blk value]]
		ifFail: [self error: 'Failed attempt to install method in mixin ', self name].
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
referencesToAssociation: assoc <Association> ^ <Cltn[MethodLocator]>
	| result <Cltn[MethodLocator]> |
	result := OrderedCollection [MethodLocator] new.
	self mixinDecl methodsDo: [ :method <Method> | 
		 (method referencesAssociation: assoc) ifTrue: [
				result add: (MethodLocator new definition: self basicLocator selector: method selector)]].
	^result! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
reflect: r  <MixinVMMirror>
"Private"

| i <InvocationData> ci <MetaInvocationData> |
self mixinDecl: r.
(InvocationInfo includesKey: r reflectee) ifFalse: [
	i := InvocationData new.
	InvocationInfo at: r reflectee put: i.
	(InvocationInfo includesKey: r classSide reflectee) ifFalse: [
		ci := MetaInvocationData new dual: i.
		InvocationInfo at: r classSide reflectee put: ci ] ]
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
reflectee  ^ <Mixin>

	^self mixinDecl isNil
		ifTrue: [		nil ]
		ifFalse: [	self mixinDecl reflectee ]! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
reflectee: r <Mixin>

	self mixinDecl reflectee: r! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
removeAllClassVariables
"We need to create the collection of names first, because we cannot iterate over the same
collection we are modifying "
| names <OrdCltn[Symbol]> |

names := OrderedCollection[Symbol] new.
self mixinDecl classVarNamesDo: [: n <Symbol> | names add: n].
names do:
   [: n <Symbol> | 
   self removeClassVariable: n 
            ifAbsent:[self error: 'Internal inconsistency - missing class variable in ', self name]
   ].
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
removeAllInstanceVariables

"We need to create the collection of names first, because we cannot iterate over the same
collection we are modifying "
| names <OrdCltn[Symbol]> |

names := OrderedCollection[Symbol] new.
self mixinDecl instVarNamesDo: [: n <Symbol> | names add: n].
names do:
   [: n <Symbol> | 
   self removeInstanceVariable: n 
            ifAbsent:[self error: 'Internal inconsistency - missing instance variable in ', self name]
   ].
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
removeClassVariable: name  <Symbol>  ifAbsent: blk  <[]> 

self isMeta ifTrue:[self error: 'Class variables cannot be manipulated through metaclasses'].
self makeChange:[:mvm <MixinVMMirror> | mvm removeClassVarName: name ifFail: [: e <Str> | blk value]]
        ifFail: [:e <Str> | self error: 'Failed attempt to remove class variable ', name, ' in mixin ', self name, ' : ', e].

self typeInfoRemoveClassVariable: name.! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
removeClassVariable: name  <Symbol>  ifFail: blk  <[Str]> 

self isMeta ifTrue:[blk value].
self makeChange:[:mvm <MixinVMMirror> | mvm removeClassVarName: name ifFail: blk]
        ifFail: blk.

self typeInfoRemoveClassVariable: name.! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
removeDefinitionIfFail: blk <[]>

	"Remove entry from system dictionary and source database"

	super removeDefinitionIfFail: [ ^blk value ].
	self mixinDecl: nil.
	^nil! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
removeInstanceVariable: name  <Symbol>  ifAbsent: blk  <[]> 

self makeChange:[:mvm <MixinVMMirror> | mvm removeInstVarName: name ifFail: [: e <Str> | blk value]]
        ifFail: [:e <Str> | self error: 'Failed attempt to remove instance variable ', name, ' in mixin ', self name, ' : ', e].

self typeInfoRemoveInstanceVariable: name.! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
removeMethod: selector <Symbol>  ifAbsent: blk <[]>

| typeInfo <SideUpdate> |

self mayNeedToUnwind.

(self hasSelector: selector)
	ifFalse: [	self sourceInfo removeSelector: selector ifAbsent: [].		"Remove if present in source database (for consistency)"
						^blk value ].
						
self makeChange:[:mvm <MixinVMMirror> | mvm removeMethodAt: selector ifFail: [:e <Str> | ^blk value ]] 
         ifFail: [:e <Str> | 'Failed attempt to remove method ', selector, ' in mixin ', self name, ' : ', e].

self hasFullTypeInfoLoaded
	ifTrue:[
				typeInfo := self typeInfo.
				typeInfo  methods removeKey: selector 
                                 				    ifAbsent:[typeInfo messages removeKey: selector
                                                                                    			            ifAbsent: []. "Should never happen"
                                                     				  ].	
				].
self sourceInfo removeSelector: selector ifAbsent: blk.! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
removePool: name <Str>  ifAbsent: blk <[]>

self deltaHack.
self halt.! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
rename: oldId <Symbol> to: newId <Symbol>

| s <ReadString> src <ReadString>  |

"rename in all methods"
self methodsDo:[: m <DeltaMethod> |
									src := self sourceForSelector: m selector.
									s := self rename: oldId to: newId in: src.
									s == src
										ifFalse:[self addMethod: s
																visibility: (self sourceInfo visibilityForSelector: m selector)
																category: (self sourceInfo categoryForSelector: m selector)
																ifFail:[:msg <Str>  :i <Int>  | self error: 'Renamed code uparseable: ', msg].
														].
								].
"rename in all instance variables"
s := self rename: oldId to: newId in: (src := self instanceVariableString).
s == src  ifFalse:[self instanceVariables: s].
"rename in supported protocol"
s := self rename: oldId to: newId in: (src := self supportedProtocolString).
s == src ifFalse:[self supportedProtocol: s].
"If non meta: "
self isMeta
	ifFalse:[
				"rename in superclass type"
					s := self rename: oldId to: newId in: (src := self superclassTypeString).
					s == src ifFalse:[self superclassType: s].
				"rename in all class variables"
					s := self rename: oldId to: newId in: (src := self classVariableString).
					s == src ifFalse:[self classVariables: s].
				"rename in all type arguments, if any"
					s := self rename: oldId to: newId in: (src := self typeArgumentString).
					s == src ifFalse:[self nestInGenericWithTypeArguments: s].
					self classSide rename: oldId to: newId.
				].
! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
renameGroup: grp <Dict[Symbol,Symbol]>

| s <ReadString> src <ReadString>  |

"rename in all methods"
self methodsDo:[: m <DeltaMethod> |
									src := self sourceForSelector: m selector.
									s := self renameGroup: grp in: src.
									s == src
										ifFalse:[self addMethod: s
																visibility: (self sourceInfo visibilityForSelector: m selector)
																category: (self sourceInfo categoryForSelector: m selector)
																ifFail:[:msg <Str>  :i <Int>  | self error: 'Renamed code uparseable: ', msg].
														].
								].
"rename in all instance variables"
s := self renameGroup: grp in: (src := self instanceVariableString).
s == src  ifFalse:[self instanceVariables: s].
"rename in supported protocol"
s := self renameGroup: grp in: (src := self supportedProtocolString).
s == src ifFalse:[self supportedProtocol: s].
"If non meta: "
self isMeta
	ifFalse:[
				"rename in superclass type"
					s := self renameGroup: grp in: (src := self superclassTypeString).
					s == src ifFalse:[self superclassType: s].
				"rename in all class variables"
					s := self renameGroup: grp in: (src := self classVariableString).
					s == src ifFalse:[self classVariables: s].
				"rename in all type arguments, if any"
					s := self renameGroup: grp in: (src := self typeArgumentString).
					s == src ifFalse:[self nestInGenericWithTypeArguments: s].
					self classSide renameGroup: grp.
				].
! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
scope  ^ <Scope>

	^self typeInfo scope
! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
scope: s <Scope>

	self typeInfo scope: s
! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
selectorsFor: cat <Str> ^ <OrdCltn[Symbol]>
	
	^self sourceInfo selectorsFor: cat! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
selectorsMatching: pattern <Str> ^ <Set[Symbol]>

	| result <Set[Symbol]> |
	result := Set[Symbol] new.
	self compiledMethodsDo: [ :method <Method> | 		"We use compiled methods here since otherwise type info will have to be loaded"
		(pattern platformMatch: method selector) 
			ifTrue: [	result add: method selector ] ].
	^result! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
setName: n <Symbol> ifFail: fb <[Str]>

self mixinDecl name: n ifFail: fb.
self sourceInfo setName: n! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
sourceForSelector: sel <Symbol>  ^ <Str>

	^self sourceInfo sourceForSelector: sel
! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
sourceInfo ^<MixinSourceHandler>

	sourceInfo isNil 
		ifTrue: [ sourceInfo := MixinSourceHandler for: self ].
	^sourceInfo! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
subtype ^ <Boolean>

	^self typeInfo subtype! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
subtype: s <Boolean>

	self typeInfo subtype: s.
	self sourceInfo subtype: s.
! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
superclassType ^ <ClassNode>

^self typeInfo superclassType.
! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
superclassType: st <Str>

| superclass <ClassExpr> |

self assert: [ st isString ].
self sourceInfo superclassTypeString: st.
superclass := (DeltaParser new parseClassOrMixinExpr: st within: self scope) body.
self typeInfo superclassType: superclass.
(Type forMixin: self classSide reflectee) superclassType: superclass dualClassType.
AbstractClassMirror flushSubclassHierarchyCache.
! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
superclassTypeString ^ <Str>

^self sourceInfo superclassTypeString
! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
supportedProtocol: p <Str>

self assert: [ p isString ].
self sourceInfo supportedProtocolString: p.
p isEmpty ifFalse:[self typeInfo supportedProtocol: (DeltaParser new
parseTypeExpr: p within: self scope superScope) body]
                    ifTrue:[self typeInfo supportedProtocol: nil].! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
supportedProtocolString ^ <Str>

^self sourceInfo supportedProtocolString
! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
typeArgumentString ^ <Str>

^self isMeta ifTrue:[self instanceSide typeArgumentString]
                        ifFalse:[self sourceInfo typeArgumentString].
! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
typeForNode: n <ASTNode> inMethod: m <Method > ^ <ObjectType>

^self typeInfo typeForNode: n inMethod: m! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
typeInfo ^ <SideUpdate>
"Private"

^(Type forMixin: self reflectee)! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
typeInfoAddClassVariable: v  <VarDecl>
"Private"

self isMeta ifFalse:[self classSide scope at: v name put: v.].
self typeInfo scope at: v name put: v.! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
typeInfoAddInstanceVariable: v  <VarDecl>
"Private"

self typeInfo scope at: v name put: v.! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
typeInfoClassVariables: vars <Str>
"Change class vars in type info and source only"
self deltaHack.
self assert: [ vars isString ].
self sourceInfo classVariableString: vars.
self classVariablesDo: [: v <VarDecl> | self typeInfoRemoveClassVariable: v name].
 ((DeltaParser new parseClassVarList: vars within: self scope) collect: [ :pt <ParseTree[VarDecl]> | pt body  scope: DeltaGlobals])
   do:[:v <VarDecl> | self typeInfoAddClassVariable: v].

! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
typeInfoInstanceVariables: vars <Str>
"Change inst vars in type info and source only"
self deltaHack. 
self assert: [ vars isString ].
self sourceInfo instanceVariableString: vars.
self instanceVariablesDo: [: v <VarDecl> | self typeInfoRemoveInstanceVariable: v name].
 ((DeltaParser new parseInstVarList: vars within: self scope) collect: [ :pt <ParseTree[VarDecl]> | pt body])
   do:[:v <VarDecl> | self typeInfoAddInstanceVariable: v].

! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
typeInfoRemoveClassVariable: name  <Symbol> 
"Private"

self isMeta ifFalse:[self classSide scope removeKey: name.].
self typeInfo scope removeKey: name.! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
typeInfoRemoveInstanceVariable: name  <Symbol> 
"Private"
self typeInfo scope removeKey: name.! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
typeNameForNode: n <ASTNode> inMethod: m <Method > ^ <String>

^self typeInfo typeNameForNode: n inMethod: m! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
unbranded

self branded: false! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
uninstall

^self mixinDecl uninstall! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
updateDependenciesFrom: oldAST to: newAST

" Private.
Update the top level dependency graph based upon the differences among the new and old ASTs"
| newRefs <OrdCltn[Symbol]> oldRefs <OrdCltn[Symbol]> |
"add dependencies present in newAST"

newRefs := (DeltaReferenceGatherer new initialize methodNode: newAST) references.
newRefs do:[:r <Symbol> | DeltaDependencyGraph addDependencyFrom: self  name to: r].

oldRefs := (DeltaReferenceGatherer new initialize methodNode: oldAST) references.
oldRefs do:[:r <Symbol> | DeltaDependencyGraph removeDependencyFrom: self  name to: r].
"remove dependencies present in oldAST"
! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
vmInvocations ^ <OrdCltn[ClassVMMirror]>
"Private"
	^self invocationInfo invocations collect:[: inv <Class> | ClassVMMirror on: inv]
! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
|> c <ClassMirror > ^ <ClassMirror>
"h2"
| invocation <ClassVMMirror> |

self isMeta ifTrue:[self error: 'MetaMixins should not be invoked'].

invocation := ClassVMMirror createInvocationOf: self mixinDecl 
                              superclass:  (ClassVMMirror on: c reflectee)
                              ifFail: [: e | self error: 'Internal inconsistency in MixinDeclMirror>>|> ', e].
self class addTypeStructureForInvocation: invocation.
self addInvocation: invocation reflectee.

^InvocationMirror on: invocation reflectee
! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'accessing' !
shortDescription ^ <Str>

	"Returns a short desciption of this mixin"
	
	| header <String> |
	header := ''.
	self isGeneric
		ifTrue: [ 		header := header, 'generic ' ].
	self isSubtype
		ifFalse: [ 	header := header, 'non-subtype ' ].
	self isAbstract
		ifTrue: [		header := header, 'abstract ' ].
	header := header, 'mixin on ', self superclassTypeString.
	^header at: 1 put: (header at: 1) asUppercase; yourself
! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'loading type info' !
createMethodTypeStructure

	| 
	ast <DeltaMethod> 
	ti <DeltaSideUpdate>
	selector <Symbol>
	methods <IdentitySet[Symbol]> 
	messages <IdentitySet[Symbol]>
	 |

ti := self typeInfo.
methods := IdentityDictionary[Symbol, DeltaMethod] new.
messages := IdentityDictionary[Symbol, DeltaMethod] new.
ti 	methods: methods;
	messages: messages.
self compiledMethodsDo:
[: m <Method> | 
		selector := m selector.
		m isAbstract
			ifTrue: [		messages at: selector put: (LazyMessage new mixin: self reflectee; mySelector: selector)]
			ifFalse: [	methods at: selector put: (LazyMethod new mixin: self reflectee; mySelector: selector)] 
]
! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'loading type info' !
createTypeStructure
" This method creates type information for my mixin, based upon the contents of
the  source database"
|
cDecl  <ClassUpdate> 
mixinTypeInfo <SideUpdate>
classMixinTypeInfo <SideUpdate>
st <ClassId | MixinInvocationNode | GenericApplicationClassType>
classSide <MixinDeclMirror>
isGeneric <Boolean>
sp <Str>
sts <Str>
tas <VarOrdCltn[TypeFormal]>
 |

self isMeta ifTrue:[^self instanceSide createTypeStructure].
ReportTypeLoading
	ifTrue:[ Platform errorStream show: 'Loading type info for ', self name; cr].
self name = #Object ifTrue:[^self createTypeStructureForObject].
classSide := self classSide.
isGeneric := self sourceInfo isGeneric.

"Create type info node(s)"

cDecl := DeltaClassUpdate new  abstract: self isAbstract; 
                                                       branded: self isBranded; 
                                                       monotonic: self extensionsAreSubtypes; 
                                                       subtype: self isSubtype.
mixinTypeInfo :=  DeltaSideUpdate new initialize.
cDecl instanceSide: mixinTypeInfo.
classMixinTypeInfo :=  DeltaSideUpdate new initialize classDecl: cDecl.
"Nil out methods to provoke reparsing"
mixinTypeInfo methods: nil; messages: nil.
classMixinTypeInfo  methods: nil; messages: nil.

cDecl instanceSide: mixinTypeInfo.

Type atMixin: self reflectee put: mixinTypeInfo.
Type atMixin: self classSide  reflectee put: classMixinTypeInfo.

DeltaSilentTypeErrorHandler new catchErrorsFor: [
isGeneric
   ifTrue:[ 
                tas := (DeltaParser new parseTypeArgs: self typeArgumentString
                                                              within:  DeltaGlobals
                                                              ifError:[:m <Str> : i <Integer> | self error: 'Source database contains invalid code'])
                              collect: [ :pt <ParseTree> | pt body].
               mixinTypeInfo := DeltaGenericSideUpdate new name: self name  body: mixinTypeInfo formals: tas.
               classMixinTypeInfo := DeltaGenericSideUpdate new name: classSide name body: classMixinTypeInfo formals: tas.
              Type atMixin: self reflectee put: mixinTypeInfo.
              Type atMixin: self classSide  reflectee put: classMixinTypeInfo.
              self adjustBounds.
               ].

"set up superclass type info "
sts := self superclassTypeString.
sts isEmpty ifTrue:[sts := 'Object'].
st := (DeltaParser new parseClassOrMixinExpr:  sts within: self scope superScope) body.

mixinTypeInfo superclassType:  st.
classMixinTypeInfo superclassType: st dualClassType.

"Patch up instance, class and pool variables for both sides"

 ((DeltaParser new parseInstVarList: self instanceVariableString within: self scope) collect: [ :pt <ParseTree[VarDecl]> | pt body])
   do:[:v <VarDecl> | self typeInfoAddInstanceVariable: v].

 ((DeltaParser new parseClassVarList: self classVariableString within: self scope) collect: [ :pt <ParseTree[VarDecl]> | pt body scope: DeltaGlobals])
   do:[:v <VarDecl> | self typeInfoAddClassVariable: v].

 ((DeltaParser new parseInstVarList:  classSide instanceVariableString within:  classSide scope) collect: [ :pt <ParseTree[VarDecl]> | pt body])
   do:[:v <VarDecl> |  classSide typeInfoAddInstanceVariable: v].

"self  typeInfoPools: self poolString."

" patch up supported protocol info on both sides"

sp := self supportedProtocolString.
sp isEmpty 
	ifFalse:[mixinTypeInfo supportedProtocol: (DeltaParser new parseTypeExpr: sp 
                                                                    within: self scope superScope) body.
					isGeneric ifTrue:[mixinTypeInfo formals do:[:f <TypeFormal>  | mixinTypeInfo supportedProtocol addRelevantTypeVar: f typeVar]].
                   ].

sp :=  self classSide supportedProtocolString.

sp isEmpty 
	ifFalse:[classMixinTypeInfo supportedProtocol: (DeltaParser new parseTypeExpr:  sp 
                                                                               within:  classSide scope superScope) body.
 					isGeneric ifTrue:[classMixinTypeInfo formals do:[:f <TypeFormal>  | 
 																													classMixinTypeInfo supportedProtocol addRelevantTypeVar: f typeVar
 																													]
 													].
                   ].
                   ].
! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'loading type info' !
createTypeStructureForObject

"Private"
"Special case, when reflectee is Object. Requires special type structure"

|
cDecl  <ClassUpdate> 
mixinTypeInfo <SideUpdate>
classMixinTypeInfo <SideUpdate>
st <ClassId | MixinInvocationNode | GenericApplicationClassType>
classSide <MixinDeclMirror>
sp <Str>
sts <Str>
|

classSide := self classSide.


"Create type info node(s)"

cDecl := DeltaClassUpdate new  abstract: self isAbstract; 
                                                       branded: self isBranded; 
                                                       monotonic: self extensionsAreSubtypes; 
                                                       subtype: self isSubtype.
mixinTypeInfo :=  DeltaSide new initialize.
classMixinTypeInfo :=  DeltaObjectClassSide new initialize classDecl: cDecl.
"Nil out methods to provoke reparsing"
mixinTypeInfo methods: nil; messages: nil.
classMixinTypeInfo methods: nil; messages: nil.

cDecl instanceSide: mixinTypeInfo.

Type atMixin: self reflectee put: mixinTypeInfo.
Type atMixin: self classSide  reflectee put: classMixinTypeInfo.

classMixinTypeInfo superclassType: (DeltaClassId new setId: #Class; scope: DeltaGlobals).


"Patch up instance, class and pool variables for both sides"

 ((DeltaParser new parseInstVarList: self instanceVariableString within: self scope) collect: [ :pt <ParseTree[VarDecl]> | pt body])
   do:[:v <VarDecl> | self typeInfoAddInstanceVariable: v].

 ((DeltaParser new parseClassVarList: self classVariableString within: self scope) collect: [ :pt <ParseTree[VarDecl]> | pt body scope: DeltaGlobals])
   do:[:v <VarDecl> | self typeInfoAddClassVariable: v].

 ((DeltaParser new parseInstVarList:  classSide instanceVariableString within:  classSide scope) collect: [ :pt <ParseTree[VarDecl]> | pt body])
   do:[:v <VarDecl> |  classSide typeInfoAddInstanceVariable: v].

"self  typeInfoPools: self poolString."

" patch up supported protocol info on both sides"

sp := self supportedProtocolString.
sp isEmpty ifFalse:[mixinTypeInfo supportedProtocol: (DeltaParser new parseTypeExpr: sp 
                                                                    within: self scope superScope) body.].

sp :=  self classSide supportedProtocolString.

sp isEmpty ifFalse:[classMixinTypeInfo supportedProtocol: (DeltaParser new parseTypeExpr:  sp 
                                                                               within:  classSide scope superScope) body.].




! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'loading type info' !
hasFullTypeInfoLoaded ^ <Boolean>

^self hasTypeInfoLoaded and:[self typeInfo hasMethodsLoaded].! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'loading type info' !
loadMsgSelector: sel <Symbol> ^ <DeltaMethod>

| ast <DeltaMethod> |
	ReportTypeLoading
		ifTrue:[Platform errorStream  show: 'Loading type info for message ', self name, '>>', sel; cr].
   ast := (DeltaParser new parseMethodHeader: (self sourceForSelector:  sel)
                                                  within: self scope
                                                  ifError: [self error: 'Internal failure: Source database has syntax errors']
                                                         ) body.
    ast visibility: (self sourceInfo visibilityForSelector: sel).
    self typeInfo messages at: sel put: ast.
    ast clearBody.
    ^ast! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'loading type info' !
loadSelector: sel <Symbol> ^ <DeltaMethod>

| ast <DeltaMethod> |

	ReportTypeLoading
		ifTrue:[Platform errorStream show: 'Loading type info for method ', self name, '>>', sel; cr].
   ast := (DeltaParser new parseMethodHeader: (self sourceForSelector:  sel)
                                                  within: self scope
                                                  ifError: [: e <Str> :i <Int> | self error: 'Internal failure: Source database has syntax errors']
                                                         ) body.
    ast visibility: (self sourceInfo visibilityForSelector: sel).
    self typeInfo methods at: sel put: ast.
    ast clearBody.
    ^ast! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'typechecking' !
typecheck

	| methodsWithoutBody <OrdCltn[DeltaMethod]> tmp <DeltaMethod> |

	methodsWithoutBody := OrderedCollection[DeltaMethod] new.
	self methodsDo: [ :m <DeltaMethod> | m body isNil ifTrue: [ methodsWithoutBody add: m ]].
	[
		methodsWithoutBody do: [ :m <DeltaMethod> |
			DeltaSilentTypeErrorHandler new catchErrorsFor: [
				tmp := (self parseMethod: (self sourceForSelector: m selector) ifFail: [:s <Str> :i <Int> | self halt]) body
			].
               m type: tmp type.
			m body: tmp body
		].
		self typeInfo typecheck.
	] ensure: [
		methodsWithoutBody do: [ :m <DeltaMethod> | m clearBody ]
	]
! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'typechecking' !
typecheckClassVars

self typeInfo typecheckClassVarDecls 


! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'typechecking' !
typecheckDeclaration

self typeInfo typecheckDeclaration! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'typechecking' !
typecheckInstVars

self typeInfo typecheckInstVarDecls 
! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'typechecking' !
typecheckInterface

self typeInfo typecheckInterface! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'typechecking' !
typecheckSelector: sel <Symbol>

	| m <DeltaMethod> tmp <DeltaMethod> methodHasBody <Boolean> |
	
	m := self methodAt: sel ifFail: [self error: 'Method not found'].
	methodHasBody := m body notNil.
	[
		methodHasBody
			ifFalse: [	DeltaSilentTypeErrorHandler new catchErrorsFor: [
									tmp := (self parseMethod: (self sourceForSelector: sel) ifFail: [:s <Str> :i <Int> | self shouldNotHappen]) body
								].
								m type: tmp type.
								m body: tmp body.
							].
		self typeInfo typecheckMethod: m.
	] ensure: [
		methodHasBody
			ifFalse: [	m clearBody ]
	]
! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'typechecking' !
typecheckSelectorInterface: sel <Symbol>

	| m <DeltaMethod> tmp <DeltaMethod> methodHasBody <Boolean> |
	
	m := self methodAt: sel ifFail: [self error: 'Method not found'].
	methodHasBody := m body notNil.
	[
		methodHasBody
			ifFalse: [	DeltaSilentTypeErrorHandler new catchErrorsFor: [
									tmp := (self parseMethod: (self sourceForSelector: sel) ifFail: [:s <Str> :i <Int> | self shouldNotHappen]) body
								].
								m body: tmp body.
							].
		self typeInfo typecheckMethodInterface: m.
	] ensure: [
		methodHasBody
			ifFalse: [	m clearBody ]
	]
! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'typechecking' !
typecheckSuperclassClause

self typeInfo typecheckSuperclassType.
! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'typechecking' !
typecheckSupportedProtocol

self typeInfo typecheckSupportedProtocol. ! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'typechecking' !
typecheckTypeArguments

self typeInfo asGeneric typecheckTypeArgs. 
! !

"August 22, 2009 -> 14:24:24"!

Delta define: #ProtocolMirror as: (
(Class subclassOf: 'Mirror' instanceVariables: 'reflectee sourceInfo ')) !


"August 22, 2009 -> 14:24:24"!

Delta define: #ProtocolMirror as: (
(Class subclassOf: 'Mirror' instanceVariables: 'reflectee sourceInfo ')) !


"August 22, 2009 -> 14:24:24"!

Delta define: #ProtocolMirror as: (
(Class subclassOf: 'Mirror' instanceVariables: 'reflectee sourceInfo ')) !


"August 22, 2009 -> 14:24:24"!

Delta define: #ProtocolMirror as: (
(Class subclassOf: 'Mirror' instanceVariables: 'reflectee sourceInfo ')) !


"August 22, 2009 -> 14:24:24"!

Delta define: #ProtocolMirror as: (
(Class subclassOf: 'Mirror' instanceVariables: 'reflectee sourceInfo ')) !


"August 22, 2009 -> 14:24:24"!

Delta define: #ProtocolMirror as: (
(Class subclassOf: 'Mirror' instanceVariables: 'reflectee sourceInfo ')) !


"August 22, 2009 -> 14:24:24"!

Delta define: #ProtocolMirror as: (
(Class subclassOf: 'Mirror' instanceVariables: 'reflectee sourceInfo ')) !


"August 22, 2009 -> 14:24:24"!

Delta define: #ProtocolMirror as: (
(Class subclassOf: 'Mirror' instanceVariables: 'reflectee sourceInfo ')) !


"August 22, 2009 -> 14:24:24"!

Delta define: #ProtocolMirror as: (
(Class subclassOf: 'Mirror' instanceVariables: 'reflectee sourceInfo ')) !


"August 22, 2009 -> 14:24:24"!

Delta define: #ProtocolMirror as: (
(Class subclassOf: 'Mirror' instanceVariables: 'reflectee sourceInfo ')) !


"August 22, 2009 -> 14:24:24"!

Delta define: #ProtocolMirror as: (
(Class subclassOf: 'Mirror' instanceVariables: 'reflectee sourceInfo ')) !


"August 22, 2009 -> 14:24:24"!

(Delta mirrorFor: #ProtocolMirror)
comment: 
'This class represents a mirror on a protocol declaration.

The mirror is on the run-time representation of a protocol,
of class Protocol, that only retains its name.

The protocol is used as a key to look up source code and type information.
The mirror allows certain manipulations of these.

 (c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) classSide methodsFor: 'Unclassified' !
on: protocol <Protocol> ^ <Instance> 

	^self new reflectee: protocol! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) classSide methodsFor: 'Unclassified' !
superProtocol: name <Str> subtype: b <Boolean> ^ <Instance>

    ^(self on: Protocol new) initializeSuperProtocol: name subtype: b branded: true! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
addMessage: src <Str> category: cat <Str> ifFail: aBlock ^ <ParseTree>

	|  pt <ParseTree> mp <MessagePattern> | 

	pt := self addMessage: src  ifFail: aBlock.
	mp := pt body.
	self sourceInfo source: src category: cat visibility: #public typeFormat: (mp type formattedName: pt) forSelector: mp selector.
	^pt! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
addMessage: src <Str>  ifFail: aBlock ^ <ParseTree>
	"Private"
	|  pt <ParseTree> mp <MessagePattern> |

	pt := self parseMessage: src ifFail: aBlock.
	mp := pt body.
	self messages at: mp selector put: mp type.
	^pt
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
addMethod: str <Str> visibility: v <Symbol> category: cat <Str> ifFail: blk ^ <ParseTree>

	^self addMessage: str category: cat ifFail: blk
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
adjustBounds
"Private"

self typeInfo  asGeneric adjustBoundToTrivialApplication.		"Update name of target in trivial application"
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
asProtocol
	^self typeInfo asProtocol! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
basicDefinitionString  ^ <Str>

^'Protocol superProtocol: ', self superprotocolString asString printString,  
(self isSubtype ifFalse:['; notSubtype '] ifTrue:['']),
(self isBranded ifFalse:['; unbranded '] ifTrue:[''])
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
basicLocator  ^ <BasicMixinLocator> 
	^self typeInfo basicLocator! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
branded ^ <Boolean>

self deltaHack.
^true
"^self typeInfo branded"! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
branded: b <Boolean>
"Private"
self deltaHack.
"
^self typeInfo branded: b"! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
classSide ^ <ProtocolMirror>

^self actualClass on: self reflectee classProtocol! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
comment: c  <Str> 

c isNil
	ifTrue: [	Transcript show: 'Protocol ', self name, ' has comment set to nil, change this to an empty string'; cr.
					self sourceInfo comment: '' ]
	ifFalse: [	self sourceInfo comment: c ]
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
convert: m <Mirror> ifFail: fb <[Str]>

m convertToProtocol: self ifFail: fb.
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
convert: m <Mirror> toGeneric: g   <GenericMirror> ifFail: fb <[Str]>

self assert: [g body = self].
m convertToGenericProtocol: g ifFail: fb! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
convertToGenericClass: g <ProtocolMirror> ifFail: fb <[Str]>

fb value: 'Cannot convert a protocol into a generic class'
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
convertToGenericProtocol: g <ProtocolMirror> ifFail: fb <[Str]>

self convertToProtocol: g body ifFail: fb.
self nestInGenericWithTypeArguments: g typeArgumentString.
self adjustBounds.
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
convertToProtocol: p <ProtocolMirror> ifFail: fb <[Str]>

self superProtocol: p superprotocolString.
self subtype: p subtype.
self branded: p isBranded.
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
createMessageTypeStructure

self sourceInfo selectorsDo: 
[: m <Symbol> | 
    self addMessage: (self sourceForSelector: m )
             ifFail: [self error: 'Internal failure: Source database has syntax errors'].
].
                                                       ! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
createTypeStructure
    
| tas <VarOrdCltn[TypeFormal]> genericTypeInfo <GenericProtocolUpdate> |

self nonAtomic.
ReportTypeLoading
	ifTrue:[Platform errorStream show: 'Loading type info for Protocol ', self name; cr].
self setupInitialTypeInfo.
self setSuperProtocol: self superprotocolString.
self typeInfo subtype: self isSubtype.
"self branded: self isBranded."

self isGeneric
     ifTrue:[
                  tas := (DeltaParser new parseTypeArgs: self typeArgumentString
                                                                 within:  DeltaGlobals
                                                                 ifError:[:m <Str> : i <Integer> | self error: 'Source database contains invalid code'])
                                collect: [ :pt <ParseTree> | pt body].
                 genericTypeInfo := (DeltaGenericProtocolUpdate new name: self name  body: self typeInfo formals: tas).
                Type atProtocol: self reflectee 
                           put: genericTypeInfo.            
                  ].

Type atProtocol: self classSide  reflectee  put: self typeInfo classProtocol.  
self createMessageTypeStructure.

! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
fileNameExtension  ^<Str>
	^'.str'! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
hasSelector: selector <Symbol> ^ <Boolean>

	^self sourceInfo hasSelector: selector! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
initializeSuperProtocol: n  <Str> subtype: st  <Boolean> branded: b  <Boolean>

	self setupInitialTypeInfo.
	self superProtocol: n.
	self subtype: st.
	b ifFalse: [self unbranded].! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
instanceSide ^ <ProtocolMirror>

	^self actualClass on: self reflectee instanceProtocol! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
isAssociationOop
	self deltaHack.
	^false! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
isBranded ^ <Boolean>

^(self sourceInfo brandedString = #false) not! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
isMarkOop
  ^false! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
isMemOop
    ^ false! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
isMeta ^ <Boolean>

^self reflectee isMeta! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
isMetaSide
	^false! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
isMethodOop
    ^ false! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
isMixin
    ^false! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
isProtocol
  ^true! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
isSmiOop
    ^ false! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
isSubtype ^ <Boolean>

^(self sourceInfo subtypeString  = #false) not! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
isSymbolOop
    ^ false! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
komment

"This class represents a mirror on a protocol declaration.

The mirror is on the run-time representation of a protocol,
of class Protocol, that only retains its name.

The protocol is used as a key to look up source code and type information.
The mirror allows certain manipulations of these.
"! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
localPrimaryInterface
"Private "
"Should probably be eliminated"
self halt. "See if this is this called anymore?"
self deltaHack.
	^self typeInfo localPrimaryInterface! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
localSecondaryInterface
"Private"
"Should probably be eliminated"
self deltaHack.
	^self typeInfo localSecondaryInterface! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
messageAt: selector <Symbol> ifFail: aBlock <[^X def]> ^ <Message | X> 
    ^self messages at: selector ifAbsent: aBlock
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
messages  ^ <Dict[Symbol,Type]>

^self typeInfo messages
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
methodAt: selector <Symbol> ifFail: aBlock <[^X def]> ^ <Message | X> 
    ^self messageAt: selector ifAbsent: aBlock
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
methodsDo: blk <[Message]>

	self messages do: blk
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
methodsFor: category <String>
    ^DefinitionReader for: self category: category! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
nameExisting: n <Symbol> ifFail: fb <[Str]>

"This method modifies an existing protocol named n so that it is equivalent to me"

|  p  <ProtocolMirror> |
p :=  Mirror on: (self priorReflecteeFor: n).
p convertToProtocol: self ifFail: fb.
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
nameNew: n <Symbol> ifFail: fb <[Str]>

"This method is used to create a new protocol
named n based upon the source code information in this object.
"
self reflectee name: n.
self typeInfo name: n.
self sourceInfo setName: n.
Delta at: n put: self reflectee.

! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
nestInGenericWithTypeArguments: tas  <Str>

| formals <OrdCltn[TypeFormal]> |

formals :=  (DeltaParser new parseTypeArgs: tas within: DeltaGlobals) collect: [ :pt | pt body].
self typeInfo generifyWithFormals: formals.
self sourceInfo typeArgumentString: tas; isGeneric: true.
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
notSubtype

    	self subtype: false! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
parseMessage: src <Str> ifFail: blk <[Str,Int]> ^ <ParseTree>

	^DeltaParser new parseMessageDeclaration: src within: self scope ifError: blk
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
parseMethod: src <Str> ifFail: blk <[Str,Int]> ^ <ParseTree>

	^self parseMessage: src  ifFail: blk 
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
privateMethodsFor: category <String>

	"For compatability"
    ^self methodsFor: category
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
publicMethodsFor: category <String>

	"For compatability"
    ^self methodsFor: category
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
reflectee   ^ <Protocol>
"Private"

^reflectee! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
reflectee: r   <Protocol>
"Private"

reflectee := r.
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
removeMethod: selector <Symbol> ifAbsent: blk <[]>
    self messages removeKey: selector ifAbsent: blk.
    self sourceInfo removeSelector: selector ifAbsent: blk! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
rename: oldId <Symbol> to: newId <Symbol>
| s <ReadString> src <ReadString>  |


"rename in all messages" 
self methodsDo:[: m <Message> |
									src := self sourceForSelector: m selector.
									s := self rename: oldId to: newId in: src.
									s == src
										ifFalse:[self addMessage: s
																category: (self sourceInfo categoryForSelector: m selector)
																ifFail:[:msg <Str>  :i <Int>  | self error: 'Renamed code uparseable: ', msg].
														].
								].
self isMeta
	ifFalse:[
					"rename in super protocol"
					s := self rename: oldId to: newId in: (src := self superprotocolString).
					s == src ifFalse:[self superProtocol: s].
					"rename in all type arguments, if any"
					s := self rename: oldId to: newId in: (src := self typeArgumentString).
					s == src ifFalse:[self nestInGenericWithTypeArguments: s].
					self classSide rename: oldId to: newId.
				].! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
renameGroup: grp <Dict[Symbo,Symbol]> 
| s <ReadString> src <ReadString>  |

"rename in all messages" 
self methodsDo:[: m <Message> |
									src := self sourceForSelector: m selector.
									s := self renameGroup: grp in: src.
									s == src
										ifFalse:[self addMessage: s
																category: (self sourceInfo categoryForSelector: m selector)
																ifFail:[:msg <Str>  :i <Int>  | self error: 'Renamed code uparseable: ', msg].
														].
								].
self isMeta
	ifFalse:[
					"rename in super protocol"
					s := self renameGroup: grp in: (src := self superprotocolString).
					s == src ifFalse:[self superProtocol: s].
					"rename in all type arguments, if any"
					s := self renameGroup: grp in: (src := self typeArgumentString).
					s == src ifFalse:[self nestInGenericWithTypeArguments: s].
					self classSide renameGroup: grp.
					].! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
scope ^ <Scope>
	^self typeInfo scope! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
scope: s <Scope>

self typeInfo scope: s

! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
selectorsFor: cat <Str> ^ <OrdCltn[Symbol]>
	
	^self sourceInfo selectorsFor: cat! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
selectorsMatching: pattern <Str> ^ <Set[Symbol]>

	| result <Set[Symbol]> |
	result := Set[Symbol] new.
	self sourceInfo selectorsDo: [ :selector <Symbol> | 		
		(pattern platformMatch: selector) 
			ifTrue: [	result add: selector ] ].
	^result! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
setSuperProtocol: sp  <Str>

| superprotocol <Protocol> |

superprotocol :=  sp isEmpty 
                                     ifTrue:[ DeltaTypeId new setId: #Object; scope: DeltaGlobals]
                                     ifFalse:[(DeltaParser new parseType: sp 
                                     													within: DeltaGlobals
                                     													ifError: [: e <Str> : i <Int> | self error: e]) body.].
superprotocol isProtocol ifFalse:[self error:  sp, ' is not a protocol'].
superprotocol scope: self scope.

self typeInfo superprotocol: superprotocol.
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
setupInitialTypeInfo
"Private"
| rawProtocol  <RawProtocol>  |

rawProtocol := DeltaRawProtocol new.
rawProtocol	 primaryInterface:  (DeltaInterface new initialize)
				      secondaryInterface: (DeltaInterface new initialize)
				      branded: true.

Type atProtocol: self reflectee
           put: (DeltaDeclaredProtocolUpdate new
			            value: self reflectee
			            superprotocol: nil
			            delta: rawProtocol
			            branded: true
			            subtype: true)


! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
sourceForSelector: sel <Symbol>  ^ <Str>

	^self sourceInfo sourceForSelector: sel
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
sourceInfo ^<ProtocolSourceHandler>

	sourceInfo isNil 
		ifTrue: [ sourceInfo := ProtocolSourceHandler for: self ].
	^sourceInfo! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
subtype  ^ <Boolean>

^self typeInfo subtype! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
subtype: st  <Boolean>

self typeInfo subtype: st.
self sourceInfo subtype: st.! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
superProtocol  ^ <ProtocolMirror>

^ProtocolMirror on: (self typeInfo superprotocol protocolObj)! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
superProtocol: sp  <Str>

self assert: [ sp isString ].
self sourceInfo superprotocolString: sp.
self setSuperProtocol: sp.! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
superprotocolString  ^ <Str>

^self sourceInfo superprotocolString! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
typeArgumentString ^ <Str>

^self sourceInfo typeArgumentString! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
typeInfo ^ <ProtocolUpdate>

"Private"

^(Type forProtocol: self reflectee).! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
unbranded

self branded: false! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'accessing' !
shortDescription ^ <Str>

	"Returns a short desciption of this protocol"

	| header <String> |
	header := ''.
	self isGeneric
		ifTrue: [ 		header := header, 'generic ' ].
	self isSubtype
		ifFalse: [ 	header := header, 'non-subtype ' ].
	header := header, 'subprotocol of ', self superprotocolString.
	^header at: 1 put: (header at: 1) asUppercase; yourself! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'typechecking' !
typecheck

	self typeInfo typecheck
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'typechecking' !
typecheckDeclaration

	self typeInfo typecheckDeclaration
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'typechecking' !
typecheckInterface

	self typeInfo typecheckInterface
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'typechecking' !
typecheckSelector: sel <Symbol> 

    self typeInfo setupTypeAssumptions.
	self typeInfo errorHandler pushDefinition: self typeInfo.
	self typeInfo typecheckMessage: (self messageAt: sel ifFail:[self error: 'message not found']).
	self typeInfo errorHandler popDefinition.
    self typeInfo retractTypeAssumptions.
	
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'typechecking' !
typecheckSuperprotocol

self typeInfo typecheckSuperprotocol! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'typechecking' !
typecheckTypeArguments

self typeInfo typecheckTypeArgs. ! !

"August 22, 2009 -> 14:24:39"!

Delta define: #ClassMirror as: (
(Class subclassOf: 'AbstractClassMirror' instanceVariables: 'mixin ')) !


"August 22, 2009 -> 14:24:39"!

Delta define: #ClassMirror as: (
(Class subclassOf: 'AbstractClassMirror' instanceVariables: 'mixin ')) !


"August 22, 2009 -> 14:24:39"!

Delta define: #ClassMirror as: (
(Class subclassOf: 'AbstractClassMirror' instanceVariables: 'mixin ')) !


"August 22, 2009 -> 14:24:39"!

Delta define: #ClassMirror as: (
(Class subclassOf: 'AbstractClassMirror' instanceVariables: 'mixin ')) !


"August 22, 2009 -> 14:24:39"!

Delta define: #ClassMirror as: (
(Class subclassOf: 'AbstractClassMirror' instanceVariables: 'mixin ')) !


"August 22, 2009 -> 14:24:39"!

Delta define: #ClassMirror as: (
(Class subclassOf: 'AbstractClassMirror' instanceVariables: 'mixin ')) !


"August 22, 2009 -> 14:24:39"!

Delta define: #ClassMirror as: (
(Class subclassOf: 'AbstractClassMirror' instanceVariables: 'mixin ')) !


"August 22, 2009 -> 14:24:39"!

Delta define: #ClassMirror as: (
(Class subclassOf: 'AbstractClassMirror' instanceVariables: 'mixin ')) !


"August 22, 2009 -> 14:24:39"!

Delta define: #ClassMirror as: (
(Class subclassOf: 'AbstractClassMirror' instanceVariables: 'mixin ')) !


"August 22, 2009 -> 14:24:39"!

Delta define: #ClassMirror as: (
(Class subclassOf: 'AbstractClassMirror' instanceVariables: 'mixin ')) !


"August 22, 2009 -> 14:24:39"!

Delta define: #ClassMirror as: (
(Class subclassOf: 'AbstractClassMirror' instanceVariables: 'mixin ')) !


"August 22, 2009 -> 14:24:39"!

(Delta mirrorFor: #ClassMirror)
comment: 
'This class implements the user-level reflective interface for classes.
Classes are in fact implemented as mixin invocations. When a ClassMirror
is created, it creates a mixin for itself. All changes made to a class are implemented
by asking the mixin to change accordingly.

 (c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"August 22, 2009 -> 14:24:39"!

! (Delta mirrorFor: #ClassMirror) classSide methodsFor: 'Unclassified' !
delta ^ <Instance>
    ^self new initializeDelta! !

"August 22, 2009 -> 14:24:39"!

! (Delta mirrorFor: #ClassMirror) classSide methodsFor: 'Unclassified' !
on: class<Class> ^ <Instance> 

^self new reflect: class ! !

"August 22, 2009 -> 14:24:39"!

! (Delta mirrorFor: #ClassMirror) classSide methodsFor: 'Unclassified' !
sort: cs <Collection[Class]> ^ <OrdCltn[Class]>

^ClassVMMirror sort: cs! !

"August 22, 2009 -> 14:24:39"!

! (Delta mirrorFor: #ClassMirror) classSide methodsFor: 'Unclassified' !
subclassOf: s <Str> instanceVariables: instVars <Str> ^ <Instance>
    ^self new initializeSubclassOf: s instanceVariables: instVars! !

"August 22, 2009 -> 14:24:39"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
abstract
    self mixin abstract! !

"August 22, 2009 -> 14:24:39"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
abstract: a <Boolean>

self mixin abstract: a! !

"August 22, 2009 -> 14:24:39"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
addClassVariable: v  <VarDecl> ifFail: fb <[Str]>

self mixin addClassVariable: v ifFail: fb! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
addInstanceVariable: v  <VarDecl> ifFail:  blk <[Str]>


self mixin addInstanceVariable: v ifFail: blk! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
addMethod: str <Str> visibility: vis  <Symbol> category: cat ifFail: blk <[Str]> ^ <ParseTree>

^self mixin addMethod: str visibility: vis category: cat ifFail: blk! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
addPool: name <Str>  ifFail: fb <Str>

self mixin addPool: name ifFail: fb! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
basicDefinitionString   ^ <Str>
| classVarStr protocolStr classProtocolStr stream first |

classVarStr := self mixin classVariableString.
protocolStr := self mixin supportedProtocolString.
classProtocolStr := self mixin classSide supportedProtocolString.

stream := (String new: 20) writeStream.
self superclass isNil
	ifTrue: [
		stream nextPutAll: '(Class delta)'.
		self mixin instanceVariableString isEmpty ifFalse: [
			stream nextPutAll: ' instanceVariables: '.
			stream nextPutAll: self mixin instanceVariableString asString printString]]
	ifFalse: [
		stream nextPutAll: '(Class subclassOf: '.
		stream nextPutAll: self mixin superclassTypeString asString printString.
		stream nextPutAll: ' instanceVariables: '.
		stream nextPutAll: self mixin instanceVariableString asString printString, ')'].

first := true.
classVarStr isEmpty ifFalse: [
	first ifTrue: [ first := false ] ifFalse: [ stream nextPut: $; ].
	stream nextPutAll: ' classVariables: ', classVarStr asString printString].
protocolStr isEmpty ifFalse: [
	first ifTrue: [ first := false ] ifFalse: [ stream nextPut: $; ].
	stream nextPutAll: ' protocols: ', protocolStr asString printString].
classProtocolStr isEmpty ifFalse: [
	first ifTrue: [ first := false ] ifFalse: [ stream nextPut: $; ].
	stream nextPutAll: ' classProtocols: ', classProtocolStr asString printString].
self isAbstract ifTrue:[
	first ifTrue: [ first := false ] ifFalse: [ stream nextPut: $; ].
	stream nextPutAll: ' abstract'].
self extensionsAreSubtypes ifFalse:[
	first ifTrue: [ first := false ] ifFalse: [ stream nextPut: $; ].
	stream nextPutAll: ' extensionsAreNotSubtypes'].
self isSubtype ifFalse:[
	first ifTrue: [ first := false ] ifFalse: [ stream nextPut: $; ].
	stream nextPutAll: ' notSubtype'].
self isBranded ifFalse:[
	first ifTrue: [ first := false ] ifFalse: [ stream nextPut: $; ].
	stream nextPutAll: ' unbranded'].

^stream contents
! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
basicLocator  ^ <BasicMixinLocator> 
	^self typeInfo basicLocator! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
branded: b <Boolean>

self mixin branded: b.
! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
classProtocols: p  <Str>

self mixin classProtocols: p! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
classVariableString ^ <Str>

^self mixin classVariableString! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
classVariables: cv <Str>

self mixin classVariables: cv! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
classVariablesDo: blk   <[VarDecl]>
    self mixin classVariablesDo: blk! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
comment  ^ <Str> 

	^self sourceInfo comment! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
comment: c  <Str> 

	self sourceInfo comment: c! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
compiledMethodAt: selector <Symbol> ifFail: blk   <[^X def]> ^ <Method | X>

	^self mixin compiledMethodAt: selector ifFail: blk! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
compiledMethodsDo: blk  <[Method]>

	self mixin compiledMethodsDo: blk! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
convert: m <Mirror> ifFail: fb <[Str]>

m convertToClass: self ifFail: fb.



! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
convert: m <Mirror> toGeneric: g   <GenericMirror> ifFail: fb <[Str]>

self assert: [g body = self].
m convertToGenericClass: g ifFail: fb! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
convertToClass: c   <ClassMirror> ifFail: fb <[Str, ^DoesNotMatter]>

	self superclass isNil
		ifFalse: [	self superclass reflectee = c superclass reflectee
								ifFalse: [	| oldsuperclass <AbstractClassMirror> |
													oldsuperclass := self superclass.
													self mixin convertToMixin: c mixin changingClass: self to: c ifFail: fb.
													self typeInfo superclassType: self mixin typeInfo superclassType.
													self classSide typeInfo superclassType: self mixin classSide typeInfo superclassType.
													self superclass sourceInfo changedSubclasses.
													oldsuperclass sourceInfo changedSubclasses.
												]
								ifTrue: 	[	self mixin convertToMixin: c mixin ifFail: fb
												]
						]
! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
convertToGenericClass: g <ProtocolMirror> ifFail: fb <[Str]>

self convertToClass: g body ifFail: fb.
self nestInGenericWithTypeArguments: g typeArgumentString.
self adjustBounds.






! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
convertToGenericProtocol: g <ProtocolMirror> ifFail: fb <[Str]>

fb value: 'Cannot convert a class into a generic protocol'





! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
createTypeStructure

| 
classTypeInfo <MixinInvocationSide> 
classClassTypeInfo <MixinInvocationSide>
classSide <ClassMirror>
|

self isMeta ifTrue:[^self instanceSide createTypeStructure].
self name = #Object ifTrue:[^self createTypeStructureForObject].
classSide := self classSide.
self nonAtomic.
classTypeInfo := Type atClass: self reflectee 
                                             put:  (DeltaMixinInvocationSide new initialize klass: self reflectee).
classClassTypeInfo := Type atClass:  classSide reflectee 
                                                        put: (DeltaMixinInvocationSide new initialize klass: classSide reflectee).
classTypeInfo  dual: classClassTypeInfo.
classClassTypeInfo  dual: classTypeInfo.

classTypeInfo mixinType:  (Type forMixin: self mixin  reflectee).
classClassTypeInfo mixinType:  (Type forMixin:  classSide mixin  reflectee).

" A named class shares its scope with its mixin"
classTypeInfo scope: self mixin scope.
classClassTypeInfo scope:  classSide mixin scope.

"Can we share the superclass type nodes with the mixin?"
classTypeInfo superclassType: (DeltaParser new parseClassOrMixinExpr: self mixin superclassTypeString  
																									within: self scope superScope) body.
classClassTypeInfo superclassType: classTypeInfo superclassType dualClassType.
" (DeltaParser new parseClassOrMixinExpr: classSide mixin superclassTypeString  within: DeltaGlobals) body."! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
createTypeStructureForObject

"Private"
"Special case, when reflectee is Object. Requires special type structure"

| 
classTypeInfo <MixinInvocationSide> 
classClassTypeInfo <MixinInvocationSide>
classSide <ClassMirror>
|


classSide := self classSide.
self nonAtomic.
classTypeInfo := Type atClass: self reflectee 
                                             put:  (DeltaObjectInvocationSide new initialize klass: self reflectee).
classClassTypeInfo := Type atClass:  classSide reflectee 
                                                        put: (DeltaObjectClassInvocationSide new initialize klass: classSide reflectee).
classTypeInfo  dual: classClassTypeInfo.
classClassTypeInfo  dual: classTypeInfo.

" A named class shares its scope with its mixin"
classTypeInfo scope: self mixin scope.
classClassTypeInfo scope:  classSide mixin scope.

classClassTypeInfo mixinType:  (Type forMixin:  classSide mixin  reflectee).

classClassTypeInfo superclassType: (DeltaClassId new setId: #Class; scope: DeltaGlobals).
! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
extensionsAreNotSubtypes
    self mixin extensionsAreNotSubtypes! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
extensionsAreSubtypes ^ <Boolean>

	^self mixin extensionsAreSubtypes! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
extensionsAreSubtypes: e <Boolean>

self mixin extensionsAreSubtypes: e! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
hasSelector: selector <Symbol> ^ <Boolean>

	^self mixin hasSelector: selector! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
initialize

mixin := MixinDeclMirror createNewMixin.! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
initializeDelta
    self initialize! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
initializeSubclassOf: s  <Str> instanceVariables: instVars  <Str>

    self initialize.
    self superclass: s.
    self instanceVariables: instVars! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
installed  ^ <Boolean>
"Private"
^self mixin installed! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
instanceVariableString ^ <Str>

^self mixin instanceVariableString! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
instanceVariables: iv  <Str>

self mixin instanceVariables: iv! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
instanceVariablesDo: blk   <[VarDecl]>
    self mixin instanceVariablesDo: blk! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
isAbstract ^ <Boolean>

	^self mixin isAbstract! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
isBranded ^ <Boolean>

	^self mixin isBranded
! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
isMixinInvocation  ^ <Boolean>

^false! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
isSubtype ^ <Boolean>

	^self mixin isSubtype
! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
komment

"
This class implements the user-level reflective interface for classes.
Classes are in fact implemented as mixin invocations. When a ClassMirror
is created, it creates a mixin for itself. All changes made to a class are implemented
by asking the mixin to change accordingly.
"! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
methodAt: selector <Symbol> ifFail: blk   <[^X def]> ^ <DeltaMethod | X>

^self mixin methodAt: selector ifFail: blk ! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
methodsDo: blk   <[DeltaMethod]>
    self mixin methodsDo: blk! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
methodsFor: category <String>
    ^DefinitionReader for: self category: category
! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
mixin  ^<MixinDeclMirror>

^mixin! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
nameExisting: n <Symbol> ifFail: fb <[Str]>

"This method modifies an existing class named n so that it is equivalent to me"
|  c  <ClassMirror>  |

"self verifyNoCyclesFor: n ifFail: fb."

c :=  Mirror on: (self priorReflecteeFor: n).
c convertToClass: self ifFail: fb.
self reflect: (Delta at: n).



! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
nameNew: n <Symbol> ifFail: fb <[Str]>
"i"
"This method is used to create a new class
named n based upon the source code information in this object.

Here we create the canonical invocation, and install it.
"
| klass <ClassVMMirror> |

self mixin invocations isEmpty ifFalse: [^fb value: 'internal inconsistency'].

klass := MixinDeclMirror createInvocationOf: self mixin named: n superclass: self superclass ifFail: fb.
self mixin setName: n ifFail: fb.
(Type forClass: klass reflectee) superclassType: (Type forMixin: self mixin reflectee) superclassType.
(Type forClass: klass classSide reflectee)  superclassType: (Type forMixin: self mixin classSide reflectee) superclassType.
self reflect: klass reflectee.
Delta at: n put: klass reflectee.
! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
nestInGenericWithTypeArguments: tas  <Str>

self mixin nestInGenericWithTypeArguments: tas.! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
notSubtype
    self mixin notSubtype! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
parseMethod: src <Str> ifFail: blk <[Str,Int]> ^ <ParseTree>

	^self mixin parseMethod: src ifFail: blk
! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
pools: p  <Str>

self mixin pools: p! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
privateMethodsFor: category <String>

	"For compatability"
    ^self methodsFor: category
! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
protocols: p  <Str>

self mixin protocols: p! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
publicMethodsFor: category <String>

	"For compatability"
    ^self methodsFor: category
! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
recompileAllMethodsIfFail: blk <[]>

	self mixin recompileAllMethodsIfFail: blk! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
recompileMethod: selector <Symbol> ifFail: blk <[Str]>

	self mixin recompileMethod: selector ifFail: blk! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
referenceToSelf ^ <DeltaClassId>

^DeltaClassId new 
                 setId: (self nameIfAbsent:[self error: 'Internal flaw: Use of unnamed superclass']);
                 scope: DeltaGlobalScope! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
referencesToAssociation: assoc <Association> ^ <Cltn[MethodLocator]>
	^self mixin referencesToAssociation: assoc! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
reflect: c <Class>

self reflectee: c.
mixin := MixinDeclMirror on: (ClassVMMirror on: c) mixin reflectee.
mixin masterInvocation isNil ifTrue: [self error: 'Internal inconsistency'].
mixin masterInvocation == c ifFalse: [self error: 'Internal inconsistency']." Verify that c is master invocation"

! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
removeClassVariable: name  <Symbol>  ifAbsent: blk  <[]> 
    self mixin removeClassVariable: name ifAbsent: blk! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
removeClassVariable: name  <Symbol>  ifFail: blk  <[Str]> 
    self mixin removeClassVariable: name ifFail: blk! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
removeDefinitionIfFail: blk <[]>

	"Remove entry from system dictionary and source database"
	
	"Forwards to the mixin rather than calling super"
	self isMeta
		ifTrue: [	^blk value: 'Cannot remove on meta side'  ].
	self directSubclasses isEmpty
		ifFalse: [	^blk value: 'Class has subclasses' ].	
	self actualClass flushSubclassHierarchyCache.
	^self mixin removeDefinitionIfFail: blk! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
removeInstanceVariable: name  <Symbol>  ifAbsent: blk  <[]> 
    self mixin removeInstanceVariable: name ifAbsent: blk! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
removeMethod: selector  <Symbol>  ifAbsent: blk  <[]> 
    self mixin removeMethod: selector  ifAbsent: blk! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
rename: oldId <Symbol> to: newId <Symbol>

self mixin rename: oldId to: newId! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
renameGroup: grp <Dict[Symbol, Symbol]> 

self mixin renameGroup: grp! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
scope^ <Scope>

	^self mixin scope
! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
scope: s <Scope>

	self mixin scope: s
! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
selectorsFor: cat <Str> ^ <OrdCltn[Symbol]>

	^self mixin selectorsFor: cat! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
selectorsMatching: pattern <Str> ^ <Set[Symbol]>

	^self mixin selectorsMatching: pattern
! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
sourceForSelector: sel <Symbol>  ^ <Str>

	^self mixin sourceForSelector: sel
! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
sourceInfo ^ <MixinSourceHandler>

	^self mixin sourceInfo! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
subtype ^ <Boolean>

	^self mixin subtype! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
subtype: s <Boolean>

	self mixin subtype: s.
! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
superclass: s  <Str>

	self mixin superclassType: s.
	
	
! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
supportedProtocol: p <Str>

	self mixin supportedProtocol: p! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
supportedProtocolString ^ <Str>

^self mixin supportedProtocolString! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
typeArgumentString ^ <Str>

^self mixin typeArgumentString! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
typeForNode: n <ASTNode> inMethod: m <Method > ^ <ObjectType>

^self mixin typeForNode: n inMethod: m! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
typeNameForNode: n <ASTNode> inMethod: m <Method > ^ <String>

^self mixin typeNameForNode: n inMethod: m! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
unbranded

self mixin unbranded! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
verifyNoCyclesFor: n <Symbol> ifFail: fb <[Symbol, ^DoesNotMatter]>
"Private"
"This method is only called if there already exists an entity with the name 'n' in
the system dictionary (otherwise, there could not be a cycle, since no
subclasses could have been created).
The method is called before my reflectee is actually created and placed in the
SystemDictionary under its name. That is why we start the check with my
superclass.
This code assumes the atomic addition of one class at a time.
"
| cs <VarOrdCltn[Symbol]> |

n = #Object ifTrue:[^self].
cs := OrderedCollection[Symbol] new.
cs add: n.
self superclass isNil ifFalse:[self superclass verifyNoCyclesIn: cs ifFail: fb].
! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'typechecking' !
typecheck

self mixin typecheck! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'typechecking' !
typecheckClassVars

self mixin typecheckClassVars! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'typechecking' !
typecheckDeclaration

self mixin typecheckDeclaration! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'typechecking' !
typecheckInstVars

self mixin typecheckInstVars! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'typechecking' !
typecheckInterface

self mixin typecheckInterface! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'typechecking' !
typecheckSelector: aSymbol <Symbol>

self mixin typecheckSelector: aSymbol! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'typechecking' !
typecheckSelectorInterface: aSymbol <Symbol>

self mixin typecheckSelectorInterface: aSymbol! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'typechecking' !
typecheckSuperclassClause

self mixin typecheckSuperclassClause! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'typechecking' !
typecheckSupportedProtocol

self mixin typecheckSupportedProtocol! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'typechecking' !
typecheckTypeArguments

self mixin typecheckTypeArguments! !

"August 22, 2009 -> 14:25:9"!

Delta define: #DeltaParser as: (
(Class subclassOf: 'Object' instanceVariables: 'pseudoVars error scanner <DeltaScanner>  token <Symbol>  topScope <Scope> prevTokenBegin <Int> prevTokenEnd <Int> nodePositions defsAllowed <Boolean> ')) !


"August 22, 2009 -> 14:25:9"!

Delta define: #DeltaParser as: (
(Class subclassOf: 'Object' instanceVariables: 'pseudoVars error scanner <DeltaScanner>  token <Symbol>  topScope <Scope> prevTokenBegin <Int> prevTokenEnd <Int> nodePositions defsAllowed <Boolean> ')) !


"August 22, 2009 -> 14:25:9"!

Delta define: #DeltaParser as: (
(Class subclassOf: 'Object' instanceVariables: 'pseudoVars error scanner <DeltaScanner>  token <Symbol>  topScope <Scope> prevTokenBegin <Int> prevTokenEnd <Int> nodePositions defsAllowed <Boolean> ')) !


"August 22, 2009 -> 14:25:9"!

Delta define: #DeltaParser as: (
(Class subclassOf: 'Object' instanceVariables: 'pseudoVars error scanner <DeltaScanner>  token <Symbol>  topScope <Scope> prevTokenBegin <Int> prevTokenEnd <Int> nodePositions defsAllowed <Boolean> ')) !


"August 22, 2009 -> 14:25:9"!

Delta define: #DeltaParser as: (
(Class subclassOf: 'Object' instanceVariables: 'pseudoVars error scanner <DeltaScanner>  token <Symbol>  topScope <Scope> prevTokenBegin <Int> prevTokenEnd <Int> nodePositions defsAllowed <Boolean> ')) !


"August 22, 2009 -> 14:25:9"!

Delta define: #DeltaParser as: (
(Class subclassOf: 'Object' instanceVariables: 'pseudoVars error scanner <DeltaScanner>  token <Symbol>  topScope <Scope> prevTokenBegin <Int> prevTokenEnd <Int> nodePositions defsAllowed <Boolean> ')) !


"August 22, 2009 -> 14:25:9"!

Delta define: #DeltaParser as: (
(Class subclassOf: 'Object' instanceVariables: 'pseudoVars error scanner <DeltaScanner>  token <Symbol>  topScope <Scope> prevTokenBegin <Int> prevTokenEnd <Int> nodePositions defsAllowed <Boolean> ')) !


"August 22, 2009 -> 14:25:9"!

Delta define: #DeltaParser as: (
(Class subclassOf: 'Object' instanceVariables: 'pseudoVars error scanner <DeltaScanner>  token <Symbol>  topScope <Scope> prevTokenBegin <Int> prevTokenEnd <Int> nodePositions defsAllowed <Boolean> ')) !


"August 22, 2009 -> 14:25:9"!

Delta define: #DeltaParser as: (
(Class subclassOf: 'Object' instanceVariables: 'pseudoVars error scanner <DeltaScanner>  token <Symbol>  topScope <Scope> prevTokenBegin <Int> prevTokenEnd <Int> nodePositions defsAllowed <Boolean> ')) !


"August 22, 2009 -> 14:25:9"!

Delta define: #DeltaParser as: (
(Class subclassOf: 'Object' instanceVariables: 'pseudoVars error scanner <DeltaScanner>  token <Symbol>  topScope <Scope> prevTokenBegin <Int> prevTokenEnd <Int> nodePositions defsAllowed <Boolean> ')) !


"August 22, 2009 -> 14:25:9"!

Delta define: #DeltaParser as: (
(Class subclassOf: 'Object' instanceVariables: 'pseudoVars error scanner <DeltaScanner>  token <Symbol>  topScope <Scope> prevTokenBegin <Int> prevTokenEnd <Int> nodePositions defsAllowed <Boolean> ')) !


"August 22, 2009 -> 14:25:9"!

(Delta mirrorFor: #DeltaParser)
comment: 
'The Strongtalk parser.
 (c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
array ^ <VarOrdCltn[DeltaLiteral]>
    | a <VarOrdCltn[DeltaLiteral]>  |

    self check: #lparen.
    a := OrderedCollection[DeltaLiteral]  new.
    [(token ~= #rparen) and: [token ~= #eos]] whileTrue: [
        a add: (self literal: false)
    ].
    self check: #rparen.
    ^ a! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
assignment ^ <DeltaAssignment>
    |
    maybeVar <DeltaVariable | DeltaLiteral> 
    var <DeltaVariable> 
    expr <Expression> 
    |
    maybeVar := self variable.
    self check: #becomes.
    expr := self expression.
    ^ maybeVar isRefNode
        ifTrue: [
            var := guaranteed <DeltaRef>  maybeVar.
            (var decl isParameterNode)
                ifTrue: [self error: 'variable must not be a parameter'.]
                ifFalse: [self node: (DeltaAssignment new to: var assign: expr) beginNode: var endNode: expr]
        ]
        ifFalse: [self error: 'left-hand must be a variable'.]! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
binaryClassOrMixin

| expr sel |

expr := self unaryClassOrMixin.
   [self binaryClassOrMixinSel] 
      whileTrue: [
                            sel := self get: #binarySel.
                            expr := sel = #* ifTrue:[self node:(DeltaMixinCompositionNode new inputMixin: expr outputMixin: self unaryClassOrMixin) begin: 0 end: 0]
                                                          ifFalse:[sel = #|> ifTrue:[self node:(DeltaMixinInvocationNode new mix: expr on: self unaryClassOrMixin) begin: 0 end: 0]
                                                                                           ifFalse:[self node:(DeltaMixinInvocationNode new mix: self unaryClassOrMixin on: expr) begin: 0 end: 0]
                                                                        ]
                            ].

^expr
       ! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
binaryClassOrMixinSel ^ <Boolean>

| tokenVal |

tokenVal := scanner tokenVal.
^token = #binarySel and:[tokenVal = #* or:[tokenVal = '|>' asSymbol or: [tokenVal = '<|' asSymbol]]].
! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
binaryExpr ^ <Expression>
    | expr <Expression>  msg <Message>  |
    expr := self unaryExpr.
    [self binarySel] whileTrue: [
	   msg := self binaryMsg.
        expr := self node: (DeltaNormalSend new to: expr send: msg) beginNode: expr endNode: msg
    ].
    ^ expr! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
binaryMsg ^ <DeltaMessage>
    |
    sel <Symbol> 
    args <VarOrdCltn[Expression]> 
    start <Int> 
    |
    self assert: [self binarySel].
    sel := scanner tokenVal.
    start := scanner tokenBeg.
    self nextToken.
    args := OrderedCollection[Expression]  new.
    args add: self unaryExpr.
    ^self node: (DeltaMessage new send: sel with: args) begin: start endNode: args last
! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
binaryMsgSequence ^ <OrdCltn[DeltaMessage]>
    | msgs <VarOrdCltn[DeltaMessage]>  |

msgs := OrderedCollection[DeltaMessage]  new.
msgs addFirst: self binaryMsg.
[self binarySel] whileTrue:[msgs addLast: self binaryMsg.].
token = #keyword ifTrue:[msgs addLast: self keywordMsg].
^msgs! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
binarySel ^ <Boolean>
    ^ (((((token = #binarySel) or: [token = #less]) or: [token = #greater]) or: [token = #vbar]) or: [token = #comma]) or: [token = #slash]! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
block ^ <DeltaBlock>
    |
    pars
    blk  <DeltaBlock> 
    start <Int> 
    |
    self check: #lbracket.
    start := prevTokenBegin.
    self openCodeScope.

    pars := OrderedCollection new.
    token = #colon ifTrue: [self parameters: pars].

    blk := DeltaBlock new body: (self body: pars).
    self closeScope.
    self check: #rbracket.
    ^self node: blk begin: start end: prevTokenEnd! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
blockType ^ <DeltaBlockApplicationType>
    |
    tas <VarOrdCltn[ObjectType]> 
    start <Int> 
    tid <DeltaTypeId> 
    |
    self check: #lbracket.
    start := prevTokenEnd.
    tid := self node: (DeltaTypeId new setId: #Fun; scope: DeltaGlobals) begin: start end: start.
    tas := token  == #rbracket ifFalse:[self blockTypeArgList]
                                                       ifTrue:[self defaultBlockTypeArgList].
    self check: #rbracket.
    ^self node: (DeltaBlockApplicationType new apply: tid  to: tas) begin: start end: prevTokenEnd! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
blockTypeArgList ^ <VarOrdCltn[ObjectType]>
    |
    tas <VarOrdCltn[ObjectType]> 
    first <ObjectType> 
    |
    tas := OrderedCollection[ObjectType]  new.
    token = #arrow
        ifTrue: [
            self nextToken.
            tas addLast: self typeExpr.
        ]
    ifFalse: [
        first :=  self typeExpr.
        tas :=
            token = #comma
                ifTrue: [self nextToken. self blockTypeArgList]
                ifFalse: [self defaultBlockTypeArgList].
        tas addFirst: first.
    ].
    ^ tas.! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
blockTypeArguments ^ <OrdCltn[ObjectType]>
    | tas <VarOrdCltn[ObjectType]>  |

    self check: #lbracket.
    tas := self blockTypeArgList.
    self check: #rbracket.
    ^tas! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
body: pars ^ <DeltaCodeBody>
    |
    temps <OrdCltn[Statement]> 
    stats <OrdCltn[Statement]> 
    codeBody <DeltaCodeBody> 
    |

    temps := OrderedCollection new.
    token = #vbar ifTrue: [self temporaries: temps].

    stats := OrderedCollection new.
    (token ~= #eos) & (token ~= #rbracket) ifTrue: [self statements: stats].

    topScope parameters: pars.
    topScope temporaries: temps.

    codeBody :=
        DeltaCodeBody new
            parameters: pars
            temporaries: temps
            statements: stats
            scope: topScope.

    stats isEmpty
        ifTrue: [^self node: codeBody begin: prevTokenEnd end: prevTokenEnd]
        ifFalse: [^self node: codeBody beginNode: stats first endNode: stats last]
! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
classOrMixin

^self binaryClassOrMixin! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
defaultBlockTypeArgList  ^ <VarOrdCltn[ObjectType]> 

^OrderedCollection[ObjectType] new
   addLast: (self node: (DeltaTypeId new setId: #Object; scope: topScope) 
                               begin: prevTokenBegin 
		                     end: prevTokenBegin);
   yourself! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
dllCall ^ <DLLCall>
    |
    start <Int> 
    dllName <Symbol> 
    proxy <DeltaVariable | DeltaLiteral> 
    functionName <Symbol> 
	async
    msg <Message> 
    |
    start := scanner tokenBeg.
    self check: #less.
    dllName := self get: #identifier.
    proxy := self variable.
    functionName := self get: #identifier.
	async :=
		(token = #identifier and: [ scanner tokenVal = #async ])
			ifTrue: [ self nextToken. true ]
			ifFalse: [ false ].
    self check: #greater.
    msg := self message.
    ^self node: (DeltaDLLCall new to: dllName send: msg called: functionName return: proxy async: async) begin: start endNode: msg
! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
expr ^ <Expression>
    |
    primary <Expression> 
    sends <OrdCltn[OrdCltn[DeltaMessage]]> 
    exp <Expression> 
    initialSend <DeltaSend> 
    |
    (token = #identifier and: [scanner tokenVal = #super])
        ifTrue: [
            primary := self super.
            sends := self send.
        ]
        ifFalse: [
            (token = #identifier and: [scanner tokenVal = #guaranteed])
                ifTrue: [
                    primary := self guaranteed.
                    sends := OrderedCollection[OrdCltn[DeltaMessage]]  new
                ]
                ifFalse: [
                    primary := self primary.
                    sends :=
                        (token = #identifier or: [self binarySel or: [token = #keyword]])
                            ifTrue: [self send]
                            ifFalse: [OrderedCollection[OrdCltn[DeltaMessage]]  new]
                     ]
        ].

    exp :=
        sends isEmpty
            ifTrue: [primary]
            ifFalse: [
                 sends first
                    inject: primary
                    into: [ :target <Expression>  :msg <DeltaMessage>  |
                        initialSend :=
                            self node: (DeltaNormalSend new to: target send: msg) beginNode: target endNode: msg
                    ].
                sends last
                    inject: initialSend
                    into: [ :target <DeltaSend>  :msg <DeltaMessage>  |
                        self node: (DeltaCascadedSend new to: target cascade: msg) beginNode: target endNode: msg 
                    ]
            ].

    ^ exp! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
expression ^ <Expression>
    ^ scanner copy token = #becomes
        ifTrue: [self assignment]
        ifFalse: [self expr]! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
genericTypeArgument  ^ <DeltaTypeFormal>

"
GenericTypeArgumentClause  -> ((Id [Variance]) | Id) [TypeParamConstraint]
"

 |
 tv <DeltaTypeVar>
 tf <DeltaTypeFormal>
 start <Integer>
 tid <Symbol>
 tpc <TypeParamConstraint> 
 variance <Symbol>
 |

start := scanner tokenBeg.
variance := #unrelated.
token = #lparen
  ifTrue:[
               self get: #lparen.
               tid :=  self get: #identifier.
               variance := self variance.
               self check: #rparen.
               ]
  ifFalse:[tid :=  self get: #identifier].

token = #less
     ifTrue:[tpc := self typeParamConstraint.]
     ifFalse:[tpc := Association 
								key:#subtypeOf: 
								value: (self node: (DeltaTypeId new setId: #Object; scope: DeltaGlobals) begin: prevTokenBegin end: prevTokenBegin)
                    ].

tv := self node: (DeltaTypeVar new name: tid bound: tpc value; subtype: tpc key = #subtypeOf:) begin: start endNode: tpc value.

^self node: (DeltaTypeFormal new variance: variance typeVar: tv) begin: start endNode: tv
! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
guaranteed ^ <DeltaGuaranteed>
    |
    guarantee < DeltaGuaranteed > 
    start < Integer > 
    |

    (token = #identifier and: [scanner tokenVal = #guaranteed])
        ifTrue: [
            start := scanner tokenBeg.
            self nextToken.
            guarantee := self node: (DeltaGuaranteed new type: self type expr: self primary) begin: start end: prevTokenEnd
        ]
        ifFalse: [self error:' ''guaranteed'' expected'].

    ^ guarantee.! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
ifUnary: unaryBlock <[^Object] >ifBinary: binaryBlock <[^Object] >ifKeyword: keywordBlock <[^Object] >else: elseBlock <[^Object] > ^ <Self>
    token = #identifier ifTrue: [^ unaryBlock value].
    self binarySel ifTrue: [^ binaryBlock value].
    token = #keyword ifTrue: [^ keywordBlock value].
    ^ elseBlock value! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
inferenceClause ^ <ObjectTypeInferenceClause>
    |
argIndex <Int> 
id <Symbol> 
clause <ObjectTypeInferenceClause> 
start <Int> 
target <InferenceClause> 
 |

start := self scanner tokenBeg.
id := self get: #identifier.
(id = #returnType)
  ifTrue:[
            clause := self returnTypeInferenceClause
            ]
  ifFalse:[id = #arg
                ifTrue:[
                         token = #number ifFalse:[self error: 'integer expected'].
                         argIndex := scanner tokenVal.
                         self nextToken.
                         token = #identifier ifTrue:[target := self inferenceClauseTail].
                         clause := self node: (DeltaArgTypeSelection new target: target arg: argIndex) begin: start end: prevTokenEnd
                         ]
    ifFalse:[id = #typeArg ifTrue:[clause := self typeArgInferenceClause]
	ifFalse:[id = #receiverType ifFalse:[self error: ' ''returnType'', ''arg'' or ''receiverType'' expected']
                                           ifTrue:[clause := self node: (DeltaReceiverTypeSelection new) begin: start end: prevTokenEnd]]]].
^clause! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
inferenceClauseTail ^ <MsgSignatureInferenceClause>
    |
    id <Symbol> 
    clause <MsgSignatureInferenceClause> 
    |
    self scanner tokenBeg.
    id := self get: #identifier.
    id = #of
        ifTrue: [clause := self msgSelector]
        ifFalse: [self error: ' ''of'' expected'].
    ^ clause.! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
keywordMsg ^ <DeltaMessage>
    | sel <Str>  args <VarOrdCltn[Expression]>  start <Int>  |
    token = #keyword ifFalse: [self error: 'keyword expected'].
    start := scanner tokenBeg.
    sel := ''.
    args := OrderedCollection[Expression]  new.
    [token = #keyword] whileTrue: [
        sel := sel, scanner tokenVal asString.
        self nextToken.
        args add: self binaryExpr
    ].
    ^self node: (DeltaMessage new send: sel asSymbol with: args) begin: start end: prevTokenEnd! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
literal: withHash <Boolean > ^ <DeltaLiteral>
    token = #number ifTrue: [^ self literalNumber].
    token = #character ifTrue: [^ self literalChar].
    token = #string ifTrue: [^ self literalString].
    token = #lbrace ifTrue:[^ self tuple].
    withHash ifTrue: [
        token = #hash
            ifTrue: [self nextToken]
            ifFalse: [self error: 'Primary expected']
        ].
    ^ token = #lparen
        ifTrue: [self literalArray]
        ifFalse: [self literalSymbol]! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
literalArray ^ <DeltaArray>
    |
    start <Int> 
    val <Symbol> 
    |
    start := scanner tokenBeg.
    val := self array.
    "self nextToken."
    ^self node: (DeltaArray new value: val) begin: start end: prevTokenEnd! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
literalChar ^ <DeltaChar>
    | start <Int>   val <Symbol>  |

    start := scanner tokenBeg.
    val := scanner tokenVal.
    self nextToken.
    ^self node: (DeltaChar new value: val) begin: start end: prevTokenEnd! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
literalNumber ^ <Self>
    | start <Int>  val <Object>  constructor <DeltaLiteral class>  |
    start := scanner tokenBeg.
    val := scanner tokenVal.
    self nextToken.
      constructor :=
        (val isKindOf: SmallInteger)
              ifTrue: [DeltaSmallInt]
              ifFalse:[(val isKindOf: Integer) ifTrue: [DeltaInt]
              ifFalse: [(val isKindOf: Float) ifTrue: [DeltaFloat]
              ifFalse: [self error: 'Number scanned is not a number']]].
    ^self node: (constructor new value: val) begin: start end: prevTokenEnd.! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
literalString ^ <DeltaString>
    | start <Int>  val <Symbol>  |

start := scanner tokenBeg.
val := scanner tokenVal.
self nextToken.
 ^self node: (DeltaString new value: val) begin: start end: prevTokenEnd! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
literalSymbol ^ <DeltaSymbol>
    | start <Int>  val <Symbol>  |

start := scanner tokenBeg.
val := self symbol.
 ^self node: (DeltaSymbol new value: val) begin: start end: prevTokenEnd! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
message ^ <DeltaMessage>
    ^ self
        ifUnary: [self unaryMsg]
        ifBinary: [self binaryMsg]
        ifKeyword: [self keywordMsg]
        else: [self error: 'Msg expected'].! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
messagePattern  ^ <MsgSignature>
    |
    pars  <OrdCltn[DeltaParameter]>
    pattern <DeltaMessagePattern> 
    |

    self openNonCodeScope.
    pars := OrderedCollection new.
    pattern := self msgPattern: pars isMessage: true.
    self closeScope.
    ^ pattern! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
method  ^ <DeltaMethod>
    |
    pars <OrdCltn[DeltaParameter]>
    pattern <DeltaMessagePattern> 
    method <DeltaMethod> 
    copiedPars  <OrdCltn[DeltaParameter]>
    |

    self openNonCodeScope. 
 " method header must not reference scope of method body"
    pars := OrderedCollection [DeltaParameter]new.
    pattern := self msgPattern: pars.
"header done, open code scope for method body"
    self openCodeScope.
    self deltaHack.
    self declare: (DeltaReceiver new name: #self type: (topScope at: #self) type).
   "#self must be present in method scope because from the compilers viewpoint
     it is not imported from an outer scope, so we duplicate the declaration."
  "For the same reason, we duplicate the parameters.
   Both these hacks will go away when the CodeScopes are factored out of the
   AST"
   copiedPars := OrderedCollection  [DeltaParameter] new.
   pars do: [: p <DeltaParameter> | 
                   self declare: (p class new  name: p name type: p type).
                   copiedPars add: (topScope at: p name).
                   ].
    method :=
        DeltaMethod new
            selector: pattern selector
            type: pattern type
            visibility: #public
            body: (self body: copiedPars).
    self closeScope.
    self check: #eos.
    ^self node: method begin: 1 end: scanner source size + 1! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
methodSignature  ^ <MsgSignature>
    |
    pars  <OrdCltn[DeltaParameter]>
    pattern <DeltaMessagePattern> 
    |

    self openNonCodeScope.
    pars := OrderedCollection new.
    pattern := self msgPattern: pars.
    self closeScope.
    ^ pattern type! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
mixinExpr 

! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
msgDeclaration

^self msgPattern:  OrderedCollection[DeltaParameter] new isMessage: true.
! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
msgPattern: pars <OrdCltn[DeltaParameter]>  ^ <DeltaMessagePattern>
"This message parses a message pattern - the header of a
Strongtalk method,  or a message declaration"

^self msgPattern: pars isMessage: false.! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
msgPattern: pars  <OrdCltn[DeltaParameter]> isMessage: isMsg <Boolean>  ^ <DeltaMessagePattern>
"This message parses a message pattern - the header of a
Strongtalk method,  or a message declaration"
    |
    sel <Str> 
    decl
    domain <VarOrdCltn[ObjectType]> 
    range <ObjectType> 
    type <DeltaMsgSignature> 
    tPat <OrdCltn[InferredTypeVar]> 
    msgPat <DeltaMessagePattern> 
    start <Int>  
    hasType <Boolean>  
    formals <OrdCltn[TypeFormal]> 
    variableDeclParser <[DeltaVar class]>
    msgSigConstructor <MsgSignature class>
    polyMsgSigConstructor <PolyMsgSignature class>
    inferenceTool <InferenceSugarTool>
    |

    isMsg ifTrue:[
                             variableDeclParser :=  [:dp <DeltaVar class> | self variableDeclForMsgDeclOf: dp parameters: pars].
                             msgSigConstructor := DeltaProtocolMsgSignature.
                             polyMsgSigConstructor := DeltaPolyProtocolMsgSignature.
                             ]
               ifFalse:[
                             variableDeclParser := [:dp <DeltaVar class> | self variableDecl: dp].
                             msgSigConstructor := DeltaMsgSignature.
                             polyMsgSigConstructor := DeltaPolyMsgSignature.
                              ].
    start := scanner tokenBeg.
"We assume initially that no explicit return type will be given"
    hasType := false.
" The header may contain 'def clauses' - references to type arguments
that should be automatically defined. The syntax for these is only
acceptable in certain contexts,  so here we explicitly set the necessary
flag so that such defs are acceptable."
    self defsAllowed: true.
"The first (and possibly only) part of a message pattern is a
selector, with value argument declarations. We parse this.
We use the block variableDeclParser to parse the formal arguments
and later check to see if a type argument pattern follows."
    domain := OrderedCollection[ObjectType]  new.
    self
        ifUnary: [
            sel := scanner tokenVal.
            self nextToken.
        ]
        ifBinary: [
            sel := scanner tokenVal.
            self nextToken.
            decl := variableDeclParser value: DeltaParameter.
            pars add: decl.
            domain add: decl declaredType.
        ]
        ifKeyword: [
            sel := ''.
            [token = #keyword] whileTrue: [
                sel := sel, scanner tokenVal asString.
                self nextToken.
                decl := variableDeclParser value: DeltaParameter.
                pars add: decl.
                domain add: decl declaredType.
            ]
        ]
        else: [self error: 'MsgPattern expected'].

"Having parsed the first part of the message pattern, we must
disallow further 'def clauses'"
    self defsAllowed: false.
"Now we check to see if a return type is explicitly declared.
We must see a '^' followed by a '<' marking the beginning of a type.
Otherwise, the '^' might be a return expression in a method body.
"
    ((token = #arrow) and: [scanner copy token = #less])
        ifTrue: [
            "accept ^ only if followed by a type."
			hasType := true. "note that an explicit return type was provided"
            self nextToken.
            range := self type.
        ]
        ifFalse: [
            range := self node: (DeltaTypeId new setId: #Self; scope: topScope) begin: prevTokenEnd end: prevTokenEnd "Self"
        ].

"Initially, we create a message signature node for the pattern just parsed"
    type := self
		node: (msgSigConstructor new domain: domain range: range)
		beginNode: (domain isEmpty ifTrue: [range] ifFalse: [domain first])
		endNode: range.

 "At this point,  we must determine whether any formal type arguments were
introduced by means of 'def clauses'. 
We use InferenceSugarTool to process type and collect such formals.
If there are none, formals will be set to an empty collection."

    inferenceTool :=
		DeltaInferenceSugarTool
			topScope: self topScope 
			errorBlock:
				[ :n <ASTNode> :s <Str> |
					error value:s value: (self nodeBeginFor: n)
				].
	type apply: inferenceTool.
	formals := inferenceTool formals.

"Explicitly declared formals may now follow. This is marked by the use '{{'.
These formals are parsed using the typePattern routine, and added to formals."
(token = #lbrace and: [scanner copy token ~= #lbrace])
         ifTrue: [
	     hasType := true.
             tPat := self typePattern.
             tPat do:[:tf <InferredTypeVar> | formals add: tf]].

"If any formal type arguments were declared, either using 'def clauses' or
explicitly or both, they will be stored in formals.  If formals is empty, we are
sure that there are none. If there are formals, the type of the message/method
must be a PolyMsgSignature, using the  formals defined, whose body is the
msg signature created earlier. Otherwise, the type created previously is
the type of the method/message.
"
     formals isEmpty ifFalse: [
             type := self
				node: (polyMsgSigConstructor new formals: formals body: type)
				beginNode: type
				endNode: (tPat isNil ifTrue: [type] ifFalse: [tPat last])
            ].

  isMsg ifTrue:[ type selector: sel asSymbol ].
  
"At this point, type is set correctly to be the type of the method/message, and the
pattern as a whole can be represented by a node using the parsed selector and type."
	msgPat := DeltaMessagePattern new selector: sel asSymbol type: type.

"?"
	^hasType
		ifTrue: [self node: msgPat begin: start endNode: type]
		ifFalse: [self node: msgPat begin: start end: prevTokenEnd]! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
msgSelector ^ <MsgSignatureInferenceClause>
    |
    id <Symbol> 
    sel <Symbol> 
    start <Int> 
    |

    start := self scanner tokenBeg.
    sel := self symbolLiteral.
    id := self get: #identifier.
    id = #message ifFalse:[^self error: '''message'' expected'].
    id := self get: #identifier.
    id = #of ifFalse:[^self error: '''of'' expected'].
    ^self 
		node: (DeltaMsgTypeSelection new target: self inferenceClause selector: sel) 
		begin: start 
		end: prevTokenEnd! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
msgSequence ^ <OrdCltn[DeltaMessage]>
    | seq <OrdCltn[DeltaMessage]>  |

    ^ token = #identifier
        ifTrue: [self  unaryMsgSequence]
        ifFalse: [
            self binarySel
                ifTrue: [self binaryMsgSequence]
                ifFalse: [OrderedCollection[DeltaMessage]  new add: self keywordMsg; yourself]
        ]! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
optionalTypeExpr ^ <TypeExpr>

^(token = #identifier or:[token = #lbracket or:[token = #lparen]]) 
	 ifTrue:[self typeExpr]
	 ifFalse:[DeltaNoTypeSpecifiedError new]! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
parameters: pars  ^ <Self>
    | start <Int>   |

    [token = #colon] whileTrue: [
        start := scanner tokenBeg.
        self nextToken.
        pars add: (self variableDecl: DeltaParameter).
    ].
    self check: #vbar! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
parseTreeFor: node <ASTNode>  ^ <ParseTree>

	^DeltaParseTree new 
			body: node 
			source: self scanner source
			nodePositions: nodePositions 
			commentPositions: 
			self scanner commentPositions
			
	
! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
primary ^ <Expression>
    | expr <Expression>  tas <OrdCltn[ObjectType]>  varNode <DeltaRef | DeltaLiteral>  idNode <DeltaVariable>  |
    token = #identifier
        ifTrue: [
                  expr := varNode := self variable.
                  token = #lbracket
                    ifTrue: [
                               varNode isRefNode ifTrue:[idNode := guaranteed <DeltaVariable>  varNode.

                              tas := self typeArguments.
                               expr := self
							node: (DeltaGenericApplicationExpression new apply: idNode to: tas)
							beginNode: idNode
							end: prevTokenEnd
                               ]]
        ]
        ifFalse: [
            token = #lparen
                ifTrue: [
                    self nextToken.
                    expr := self expression.
                    self check: #rparen
                ]
                ifFalse: [
                    token = #lbracket
                        ifTrue: [expr := self block]
                        ifFalse: [
                            token = #dlbrace
                                ifTrue: [expr := self primitive]
                                ifFalse: [expr := self literal: true]
                        ]
                ]
        ].
    ^ expr! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
primaryClassOrMixin ^ <ClassOrMixin>

| 
name <Symbol>  
tid <DeltaTypeId> 
tas <OrdCltn[ObjectType]>  
start <Int>   
constructor <GenericApplicationType class>  
tf <GenericApplicationType>  
cm <ClassOrMixin> 
|


   token = #lparen 
           ifTrue:[
                        self nextToken.
                        cm := self classOrMixin.
                        self check: #rparen.
                        ^cm
                        ].
    name := guaranteed <Symbol>  ( self get: #identifier).
    tf := tid := self node:(DeltaClassId new setId: name asSymbol;
                                       scope: topScope) 
                                       begin: (start := prevTokenBegin)
                                       end: prevTokenEnd .
    token = #lbracket
      ifTrue: [
                   constructor := DeltaGenericApplicationClassType.
                   tas := self typeArguments.
 
                   tf := self node: (constructor new apply: tid  to: tas)
                                                   begin: start
                                                   end: prevTokenEnd.
                   ].
    ^tf.
! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
primitive ^ <DeltaPrimitive|DeltaDLLCall>
    |  call <DeltaPrimitive | DeltaDLLCall>  |
    self check: #dlbrace.
    call :=
        token = #less
           ifTrue: [self dllCall]
           ifFalse: [self primitiveCall].
    self check: #drbrace.
    ^ call! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
primitiveCall ^ <DeltaPrimitive>
    | start <Int>  recv <DeltaVariable>  msg <Message>  |
    start := scanner tokenBeg.
    ((token = #identifier) and: [scanner tokenVal == #self])
        ifTrue: [recv := guaranteed <DeltaVariable>  (self variable)]
        ifFalse: [recv := nil].
    msg := self message.
    ^self node: (DeltaPrimitive new to: recv send: msg) begin: start endNode: msg
! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
returnTypeInferenceClause ^ <DeltaReturnTypeSelection>
    |  target <InferenceClause>  clause <DeltaReturnTypeSelection>  start <Int>  |

start := prevTokenBegin.
              (token = #identifier and:[
              scanner tokenVal = #of]) ifFalse:[self error: '''of'' expected'.].
self nextToken.
target :=self msgSelector.
clause := self node: (DeltaReturnTypeSelection new target: target) begin: start endNode: target.
^clause.! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
send ^ <OrdCltn[OrdCltn[DeltaMessage]]>
    | msgs < VarOrdCltn[OrdCltn[DeltaMessage]]>  cascadedMsgs <VarOrdCltn[DeltaMessage]>  |

    msgs := OrderedCollection[OrdCltn[DeltaMessage]]  new.
    cascadedMsgs := OrderedCollection[DeltaMessage]  new.
    msgs addFirst: self msgSequence.
    [token = #semicolon] whileTrue: [
        self nextToken.
        cascadedMsgs addLast: self message
    ].
    msgs addLast: cascadedMsgs.
   ^msgs.! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
statement ^ <Statement>
    | stat <Statement>  start <Int>  |
        ^token = #arrow
        ifTrue: [
            start := scanner tokenBeg.
            self nextToken.
            topScope doesReturn.
            self node: (DeltaReturnStat new return: self expression; scope: topScope) begin: start end: prevTokenEnd
        ]
        ifFalse: [self expression]! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
statements: stats  ^ <OrdCltn[Statement]>
    |
    t <Symbol> 
    |
    stats add: self statement.
    [(token = #period) and: [((t := scanner copy token) ~= #rbracket) and: [t ~= #eos]]] whileTrue: [
        self check: #period.
        stats add: self statement
    ].
    token = #period ifTrue: [self nextToken]! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
super
    | s "<DeltaVariable>" |

    topScope accessSelf.
    s := self node: (DeltaRef new decl: (topScope at: #super)) begin: scanner tokenBeg end: scanner tokenEnd.
    self  get: #identifier.
    ^ s! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
symbol ^ <Symbol>
    | sym <Symbol>   pos <Int>  |
    self
        ifUnary: [sym := scanner tokenVal. self nextToken]
        ifBinary: [sym := scanner tokenVal. self nextToken]
        ifKeyword: [
            sym := '' asSymbol.
            pos := scanner tokenBeg.
            [(token = #keyword) and: [pos = scanner tokenBeg]] whileTrue: [
                sym := sym, scanner tokenVal asString.
                pos := scanner tokenEnd.
                self nextToken
            ].
            sym := sym asSymbol
        ]
        else: [
            token = #string
                ifTrue: [sym := scanner tokenVal asSymbol. self nextToken]
                ifFalse: [self error: 'symbol expected']
        ].
    ^ sym! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
symbolLiteral ^ <Symbol>
    self check: #hash.
    ^ self symbol.! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
temporaries: temps  ^ <Self>
    self check: #vbar.
    [token = #identifier] whileTrue: [
        temps add: (self variableDecl: DeltaTemporary)
    ].
    self check: #vbar
! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
tuple ^ <DeltaTuple>
    | a <VarOrdCltn[Expression]>  start <Integer> |

    start := scanner tokenBeg.
    self check: #lbrace.
    a := OrderedCollection[Expression]  new.
    ((token ~= #rbrace) and: [token ~= #eos]) ifTrue: [a add: self expr].
    [(token ~= #rbrace) and: [token ~= #eos]] whileTrue: [
        self check: #period.
        (token ~= #rbrace) ifTrue:[a add: self expr].
    ].
    self check: #rbrace.
     ^self node: (DeltaTuple new value: a) begin: start end: prevTokenEnd! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
type ^ <TypeExpr>
    | type <TypeExpr>  |

    self check: #less.
    type := self typeExpr.
    self check: #greater.
    ^type! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
typeArgInferenceClause ^ <ObjectTypeInferenceClause>
"TypeArgInferenceClause = typeArg int for generic SymbolLiteral of InferenceClause"

| typeArgIndex <Integer> id <Symbol> gid <Symbol> start <Int> |

start :=  prevTokenBegin.
token = #number ifFalse:[self error: 'integer expected'].
typeArgIndex := scanner tokenVal.
self nextToken.
id := self get: #identifier.
id = #for ifFalse:[self error: '''for'' expected'].
id := self get: #identifier.
id = #generic ifFalse:[self error: '''generic'' expected'].
gid := self symbolLiteral.
id := self get: #identifier.
id = #of ifFalse:[^self error: '''of'' expected'].

^self 	node: (GenericFormalInferenceClause 	target: self inferenceClause
																	arg: typeArgIndex
																	id: gid)
			begin: start  end: prevTokenEnd
! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
typeArguments ^ <OrdCltn[ObjectType]>
    | tas <VarOrdCltn[ObjectType]>  |

    self check: #lbracket.
    tas := OrderedCollection[ObjectType]  new.
    tas addFirst: self typeExpr.
    [token = #comma] whileTrue: [
        self nextToken.
        tas addLast: self typeExpr.
    ].
    self check: #rbracket.
    ^tas! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
typeBoundQualifier ^ <Symbol>
    | id <Str>  |

"TypeBoundQualifier = 'subtypeOf:' | 'inheritedTypeOf:'"

id := self get: #keyword.
(id = #subtypeOf:) ifTrue:[^ id].
(id = #inheritedTypeOf:) ifFalse:[self error: '''subtypeOf:'' or ''inheritedTypeOf:'' expected'].
"id := self get: #identifier.
id = #types ifFalse:[self error: '''types'' expected']."
^#inheritedTypeOf:! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
typeExpr ^ <TypeExpr>
    |
constructor <DeltaUnionType class | DeltaProtocolMerge class | DeltaProtocolOverride class> 
te <TypeExpr> 
t2 <TypeTerm> 
	|

    te := self typeTerm.
    [(token = #vbar) | (token = #semicolon) | (token = #slash)]
      whileTrue: [
                       constructor := self constructorFor: token.
                       self nextToken.
                       t2 :=   self typeTerm.
                       te := self node: (constructor new type1: te type2: t2) beginNode: te endNode: t2
                       ].
    ^te! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
typeFactor ^ <TypeFactor>
    | name <Symbol>  tid <DeltaTypeId>  tas <OrdCltn[ObjectType]>  start <Int>   constructor <GenericApplicationType class>  tf <GenericApplicationType>  |

    token = #lbracket ifTrue:[^self blockType].
    token = #lparen ifTrue:[
        self nextToken.
            tf := self typeExpr.
            self check: #rparen.
            ^tf.
             ].
    name := guaranteed <Symbol>  ( self get: #identifier).
    tf := tid := self 
		node: (DeltaTypeId new setId: name asSymbol; scope: topScope)
		begin: prevTokenBegin
		end: prevTokenEnd.
    token = #lbracket
      ifTrue: [
                 constructor := DeltaGenericApplicationType.
                 tas := tid name asSymbol = #Fun
                             ifFalse:[
                                       tid name asSymbol = #Tuple 
                                               ifTrue:[constructor := DeltaTupleType]
                                               ifFalse:[tid name asSymbol = #VarTuple ifTrue:[constructor := DeltaVarTupleType]].
                                       self typeArguments]
                             ifTrue:[
                                       constructor := DeltaBlockApplicationType.
                                       self blockTypeArguments
                                       ].
                 tf := self node: (constructor new apply: tid to: tas) beginNode: tid end: prevTokenEnd.
                 ].
    ^tf.! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
typeFormalDecl ^ <InferredTypeVar>
    |  tid <Symbol>  id <Symbol>   tpc <TypeParamConstraint>  ic <InferenceClause>   |

id := self get: #identifier.
id = #where
  ifTrue:[
            tid := id := self get: #identifier.
            token = #less
                ifTrue:[tpc := self typeParamConstraint.]
                ifFalse:[tpc := Association key:#subtypeOf: value:(self node: (DeltaTypeId new setId: #Object; scope: DeltaGlobals) begin: prevTokenBegin end: prevTokenBegin)].
            id := self get: #identifier.
            id = #is
               ifTrue:[
                         ic := self inferenceClause.
                         ]
               ifFalse:[self error: ' ''is'' expected'].
            ]
  ifFalse:[self error: '''where'' expected'].
" The newly declared type formal must exist in a scope of its own. This is
because:
1. Each type formal must see the preceding type formals,
but not itself.
2. The type formals must be visible in the method scope, but not visible in the
    surrounding class.
"
self validatePolyTypeArg: tid in: topScope.
self openTypeArgScope.
^topScope at: tid put: (self node: (DeltaInferredTypeVar new name: tid bound: tpc value inferenceClause: ic subtype: tpc key = #subtypeOf:) begin: 0 end: 0).! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
typeParamConstraint ^ <TypeParamConstraint>
    | tbq <Symbol>  te <TypeExpr>  |

self check: #less.
tbq := #subtypeOf:.
token = #keyword
  ifTrue:[tbq := self typeBoundQualifier].
te := self typeExpr.
self check: #greater.
^Association key: tbq value: te! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
typePattern ^ <OrdCltn[InferredTypeVar]>
    | tfs <VarOrdCltn[InferredTypeVar]>   savedScope <Scope> |

self check: #lbrace.
tfs := OrderedCollection [InferredTypeVar]  new.
savedScope := self topScope.
"The type formals should not be parsed in the scope of the method,
but in the scope surrounding it. Then, each new type formal will introduce
a new scope. The innermost type formal scope is should be the superscope
of the method scope.
Consequently, we adjust topScope here, and readjust at the end"
self topScope: self topScope superScope.
tfs addFirst: self typeFormalDecl.

[token = #semicolon]
  whileTrue:[
                  self nextToken.
                  tfs addLast: self typeFormalDecl.
                  ].

self check: #rbrace.
savedScope superScope: self topScope.
self topScope: savedScope.
^tfs! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
typeTerm ^ <TypeTerm>
    |
    tTerm  <TypeTerm> 
    unarySel <Symbol> 
    stop <Int> 
    |
    tTerm := self typeFactor.
    [token = #identifier] whileTrue: [
        stop := scanner tokenEnd.
        unarySel := self get: #identifier.
        defsAllowed ifFalse:[unarySel = #def ifTrue:[self error: 'Type variable defs not allowed here'].].
        tTerm := self
			node: (DeltaUnaryTypeExpr new target: tTerm selector: unarySel)
			beginNode: tTerm 
			end: stop
    ].
    ^tTerm! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
unaryClassOrMixin ^ <ClassOrMixin>

| expr sel <Str> |

expr := self primaryClassOrMixin.
token = #identifier ifTrue:[
                                   sel := scanner tokenVal.
                                   (sel = #mixin  or:[sel = #delta])
                                      ifTrue:[
                                                   self get: #identifier.
                                                    expr := self node:(DeltaMixinDerivationNode new class: expr selector: sel asSymbol) begin: 0 end: 0
                                                    ].
                                   ].
^expr
       ! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
unaryExpr ^ <Expression>
    | expr <Expression>  msg <Message>  |
    expr := (token = #identifier and:[scanner tokenVal = #super])
                           ifTrue:[self super] ifFalse:[self primary.].

    [token = #identifier] whileTrue: [
		msg := self unaryMsg.
        expr := self node: (DeltaNormalSend new to: expr send: msg) beginNode: expr endNode: msg.
    ].
    ^ expr! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
unaryMsg ^ <DeltaMessage>
    | msg <DeltaMessage>  |
    token = #identifier ifFalse: [self halt].
    msg := self
		node: (DeltaMessage new send: scanner tokenVal with: OrderedCollection[Expression]  new)
		begin: scanner tokenBeg 
		end: scanner tokenEnd.
    self nextToken.
    ^ msg! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
unaryMsgSequence ^ <OrdCltn[DeltaMessage]>
    | msgs <VarOrdCltn[DeltaMessage]>  |

    msgs := OrderedCollection[DeltaMessage]  new.
    msgs addFirst: self unaryMsg.
    [token = #identifier] whileTrue:[msgs addLast: self unaryMsg.].
    [self binarySel] whileTrue: [msgs addLast: self binaryMsg.].
    token = #keyword ifTrue: [msgs addLast: self keywordMsg].
    ^ msgs! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
validatePolyTypeArg: ptn <Symbol> in: s <Scope>
" 
This method is designed to check if the type argument named ptn is already
defined in the current parametrically polymorphic method or message,
and to generate an error if this is the case. It recurses up the scope chain until
it reaches a scope that is not a polyArgScope - in other words, a scope that does 
not house polymorphic type arguments.
"
s isPolyArgScope ifFalse:[^self].
(s includesIndexLocally: ptn) ifTrue:[self error: ptn , ' already defined']
                                                       ifFalse:[self validatePolyTypeArg: ptn in: s superScope].! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
variable ^ <DeltaRef|DeltaLiteral>
    |
    name <Symbol> 
    var <DeltaVarDecl> 
    |
    name := self get: #identifier.

    "Check if pseudo variable:"
    name == #super ifTrue: [^self error: 'super is not a valid primary expression'].
    name == #nil ifTrue: [^self node: (DeltaNil new value: nil) begin: prevTokenBegin end: prevTokenEnd].
    name == #true ifTrue: [^self node: (DeltaBool new value: true) begin: prevTokenBegin end: prevTokenEnd].
    name == #false ifTrue: [^self node: (DeltaBool new value: false) begin: prevTokenBegin end: prevTokenEnd].

    "Do lookup:"
    var :=
        topScope
            at: name
            ifAbsent: (self undeclaredVariableHandler: name).

    ((var isReceiverNode) or: [var isInstVarNode]) ifTrue: [topScope accessSelf].
    ^self node: (DeltaRef new decl: var) begin: prevTokenBegin end: prevTokenEnd
! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
variableDecl: classOfVar <DeltaVar class > ^ <DeltaLocalVar>
    | name <Symbol>  type <ObjectType>  vdec <DeltaLocalVar>  start <Int>  |
    start := scanner tokenBeg.
    name := self get: #identifier.
    token = #less ifTrue: [type := self type]
                           ifFalse:[type := self node: (DeltaNoTypeSpecifiedError new) begin: start end: start + name size].
    (pseudoVars includes: name)
        ifTrue: [self error: 'predeclared pseudo variable']
        ifFalse: [
            vdec := classOfVar new name: name type: type.
            self declare: vdec
        ].
    ^self node: vdec begin: start end: prevTokenEnd.
! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
variableDeclForMsgDeclOf: classOfVar <DeltaVar class > parameters: p  <OrdCltn[DeltaParameter]> ^ <DeltaLocalVar>

"We take the parameter collection as an argument so we can tell what number of parameter we are
declaring. This is used to give the parameter a default name. Ugh"
    | name <Symbol>  type <ObjectType>  vdec <DeltaLocalVar>  start <Int>  |
    start := scanner tokenBeg.
    token = #identifier
        ifTrue: [name := self get: #identifier]
        ifFalse: [name :=  (p size + 1) printString asSymbol].     "Unique and invalid parameter name"
    token = #less ifTrue: [type := self type]
                           ifFalse:[type := self node: DeltaNoTypeSpecifiedError new begin: start end: start + name size].
    (pseudoVars includes: name)
        ifTrue: [self error: 'predeclared pseudo variable']
        ifFalse: [
            vdec := classOfVar new name: name type: type.
            self declare: vdec ].
	^self node: vdec begin: start end: prevTokenEnd
! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
variableDeclForMsgDeclaration: classOfVar <DeltaVar class > ^ <DeltaLocalVar>
    | name <Symbol>  type <ObjectType>  vdec <DeltaLocalVar>  start <Int>  |
    start := scanner tokenBeg.
    token = #identifier
        ifTrue: [name := self get: #identifier]
        ifFalse: [name := topScope nofParameters printString asSymbol].     "Unique and invalid parameter name"
    token = #less ifTrue: [type := self type]
                           ifFalse:[type := self node: DeltaNoTypeSpecifiedError new begin: start end: start + name size].
    (pseudoVars includes: name)
        ifTrue: [self error: 'predeclared pseudo variable']
        ifFalse: [
            vdec := classOfVar new name: name type: type.
            self declare: vdec ].
	^self node: vdec begin: start end: prevTokenEnd
! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
variance  ^ <Symbol>
| sym |
token = #identifier
  ifFalse:[^#covar]
  ifTrue:[
               sym := self get: #identifier.
               sym = #covariant ifTrue:[^#covar].
                sym = #covar ifTrue:[^#covar].
               sym = #contravariant ifTrue:[^#contra].
                sym = #contra ifTrue:[^#contra].
               sym = #unrelated ifTrue:[^#unrelated].
               self error: ' covar, contra or unrelated expected'.
               ].! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'node location - private' !
node: n <ASTNode> begin: b <Int> end: e <Int> ^<ASTNode>

	self assert: [(nodePositions includesKey: n) not].
	nodePositions at: n put: (b ,, e).
	^n! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'node location - private' !
node: n <ASTNode> begin: b <Int> endNode: en <ASTNode> ^<ASTNode>

	^self node: n begin: b end: ((nodePositions at: en) at2)! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'node location - private' !
node: n <ASTNode> beginNode: bn <ASTNode> end: e  <Int> ^<ASTNode>

	^self node: n begin: ((nodePositions at: bn) at1) end: e! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'node location - private' !
node: n <ASTNode> beginNode: bn <ASTNode> endNode: en <ASTNode> ^<ASTNode>

	^self node: n begin: ((nodePositions at: bn) at1) end: ((nodePositions at: en) at2)! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'node location - private' !
nodeBeginFor: n <ASTNode>  ^<Integer>

	self assert: [(nodePositions includesKey: n)].
	^(nodePositions at: n) at1
! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'node location - private' !
nodeEndFor: n <ASTNode>  ^<Integer>

	self assert: [(nodePositions includesKey: n)].
	^(nodePositions at: n) at2
! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'parsing' !
parseClassOrMixinExpr: s <Str>  within: aScope <DeltaScope >  ^ <ParseTree[ClassId | GenericApplicationClassType]>

	^self parseClassOrMixinExpr: s within: aScope ifError: [ :msg <Str> :pos <Int> | Transcript show: msg; cr. self halt].
! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'parsing' !
parseClassOrMixinExpr: s <Str>  within: aScope <DeltaScope > ifError: blk <[Str,Int]> ^ <ParseTree[ClassId | GenericApplicationClassType]>

    | expr <Expression>    errorBlock <[Str, Int, ^BottomType]>  |

   self open: (DeltaScanner new open: s ifError: blk)
            within: aScope
            ifError: blk.
expr := self classOrMixin.
 token = #eos ifFalse:[self error: 'unrecognized tokens at end of input'].
^self parseTreeFor: expr
! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'parsing' !
parseClassVarList: s <Str >   within: aScope <Scope>  ^ <OrdCltn[ParseTree[DeltaLocalVar]]>

    ^self parseClassVarList: s within: aScope ifError: [ :msg <Str>  :pos <Int>  | Transcript show: msg; cr. self halt]! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'parsing' !
parseClassVarList: s <Str > within: aScope <Scope> ifError: blk <[Str,Int]> ^ <OrdCltn[ParseTree[DeltaLocalVar]]>

     | vars <VarOrdCltn[DeltaVar]> |
    self open: (DeltaScanner new open: s ifError: blk)  within: aScope ifError: blk.
    vars := OrderedCollection[DeltaVarDecl]  new.
    [token = #identifier] whileTrue: [vars addLast: (self parseTreeFor: (self variableDecl: DeltaClassVar))].
    token = #eos ifFalse:[self error: 'unrecognized tokens at end of input'].
    ^ vars ! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'parsing' !
parseDoitExpr: src <Str> within: scope <Scope> ifError: blk <[Str,Int]> ^ <ParseTree[DeltaMethod]>
	"Parse a doit expression <expr> within a dummy method: doit [ <expr> ].
		The new scope used below shouldn't really be necessary, 	but currently 
		the compiler requires #self to be present in the method scope.
		This is accomplished by copying the declaration from the outer scope."
		
	|
	method <DeltaMethod>
	newScope <DeltaScope>
	prefix <Str>
	suffix <Str>
	errorBlk <[Str,Int]>
	|
	newScope := scope.
	(newScope includesIndex: #self)
		ifFalse: [	newScope := DeltaScope new initialize: newScope.
							newScope at: #self put: (DeltaReceiver new name: #self type: nil) ].
	prefix := 'doit ['.
	suffix := ']'.
	errorBlk := [ :msg <Str> :pos <Int> | ^blk value: msg value: pos - prefix size ].
	self open: (DeltaScanner new open: (prefix, src, suffix) ifError: errorBlk) within: newScope ifError: errorBlk.
	method  := self method.
	token = #eos ifFalse:[self error: 'unrecognized tokens at end of input'].
	^self parseTreeFor: method
! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'parsing' !
parseIdList: s <Str >   within: aScope <Scope>  ^ <OrdCltn[ParseTree[DeltaLocalVar]]>
    |
    vars <VarOrdCltn[DeltaRef]> 
    errorBlock <[Str, Int, ^BottomType]> 
    |
    errorBlock := [ :msg <Str>  :pos <Int>  | Transcript show: msg; cr. self halt].
    self open: (DeltaScanner new open: s ifError: errorBlock) within: aScope  ifError: errorBlock.
    vars := OrderedCollection[DeltaVarDecl]  new.
    [token = #identifier] whileTrue: [vars addLast: (self parseTreeFor: self variable)].
    ^ vars ! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'parsing' !
parseInstVarList: s <Str >  within: aScope <Scope>  ^ <OrdCltn[ParseTree[DeltaLocalVar]]>

    ^self parseInstVarList: s within: aScope ifError: [ :msg <Str>  :pos <Int>  | Transcript show: msg; cr. self halt]! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'parsing' !
parseInstVarList: s <Str >  within: aScope <Scope> ifError: blk <[Str,Int]> ^ <OrdCltn[ParseTree[DeltaLocalVar]]>
    | i
    vars <VarOrdCltn[DeltaVar]> 
    errorBlock <[Str, Int, ^BottomType]> 
    |
    self open: (DeltaScanner new open: s ifError: blk) within: aScope ifError: blk.
    vars := OrderedCollection[DeltaVarDecl]  new.
self deltaHack. "remove ordinal num when constructors are used"
    i := 1.
    [token = #identifier] whileTrue: [vars addLast: (self parseTreeFor: ((self variableDecl: DeltaInstVar) ordinalNumber: i)).
i := i + 1].
    token = #eos ifFalse:[self error: 'unrecognized tokens at end of input'].    
    ^ vars ! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'parsing' !
parseMessageDeclaration: s   <Str>  within: aScope <DeltaScope> ifError: blk <[Str,Int]> ^ <ParseTree[DeltaMessagePattern]>

	| mPattern <DeltaMessagePattern> | 
    self open: (DeltaScanner new open: s ifError: blk) within: aScope ifError: blk.
	mPattern := self messagePattern.
    token = #eos ifFalse:[self error: 'unrecognized tokens at end of input'].
	^self parseTreeFor: mPattern
! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'parsing' !
parseMethod: s  <Str>  within: aScope <DeltaScope> ifError: blk <[Str,Int]> ^ <ParseTree[DeltaMethod]>

    | method <DeltaMethod> |
    self open: (DeltaScanner new open: s ifError: blk) within: aScope ifError: blk.
    method  := self method.
    token = #eos ifFalse:[self error: 'unrecognized tokens at end of input'].
	^self parseTreeFor: method! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'parsing' !
parseMethodHeader: s   <Str>  within: aScope <DeltaScope> ifError: blk <[Str,Int]> ^ <ParseTree[DeltaMethod]>
	| mPattern <DeltaMessagePattern> mtd <DeltaMethod> codeBody <DeltaCodeBody> | 

    self open: (DeltaScanner new open: s ifError: blk) within: aScope ifError: blk.
	mPattern := self messagePattern.
	    codeBody :=
        DeltaCodeBody new
            parameters: OrderedCollection[DeltaVar] new
            temporaries: OrderedCollection[DeltaVar] new
            statements: OrderedCollection[DeltaStatement] new
            scope: topScope.
    mtd :=  DeltaMethod new
    				  selector: mPattern selector
    				  type: mPattern type
    				  visibility: #public.				
	^self parseTreeFor: mtd
! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'parsing' !
parseMethodSignature: s  <DeltaMethod>  within: aScope <DeltaScope> ifError: blk <[Str,Int]> ^ <ParseTree[MsgSignature]>

    |
    sig <MsgSignature>
    |

    self open: (DeltaScanner new open: s ifError: blk) within: aScope ifError: blk.
    sig  := self methodSignature.
	^self parseTreeFor: sig! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'parsing' !
parseMixinExpr: s <Str>  within: aScope <DeltaScope >  ^ <ParseTree[ClassId | GenericApplicationClassType]>

    | expr <Expression>    errorBlock <[Str, Int, ^BottomType]>  |

  errorBlock := [ :msg <Str> :pos <Int> | Transcript show: msg; cr. self halt].
   self open: (DeltaScanner new open: s ifError: errorBlock)
            within: aScope
            ifError: errorBlock.
expr := self classOrMixin.
 token = #eos ifFalse:[self error: 'unrecognized tokens at end of input'].
^self parseTreeFor: expr
! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'parsing' !
parseOptionalTypeExpr: s <Str >within: scope <DeltaScope >  ifError: blk <[Str,Int]> ^ <ParseTree[TypeExpr]>

	self open: (DeltaScanner new open: s ifError: blk)
		within: scope
		ifError: blk.
	^self parseTreeFor: self optionalTypeExpr
! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'parsing' !
parseRefList: s <Str >   within: aScope <Scope>  ^ <OrdCltn[ParseTree[DeltaLocalVar]]>
    |
    vars <VarOrdCltn[DeltaRef]> 
    errorBlock <[Str, Int, ^BottomType]> 
    |
    errorBlock := [ :msg <Str>  :pos <Int>  | Transcript show: msg; cr. self halt].
    self open: (DeltaScanner new open: s ifError: errorBlock) within: aScope  ifError: errorBlock.
    vars := OrderedCollection[DeltaVarDecl]  new.
    [token = #identifier] whileTrue: [vars addLast: (self parseTreeFor: self variable)].
    ^ vars ! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'parsing' !
parseType: s <Str > within: aScope <DeltaScope > ifError: blk <[Str, Int]>   ^ <ParseTree[DeltaType]>

| pt <ParseTree[DeltaType]> |

	self open: (DeltaScanner new open: s ifError: blk) within: aScope ifError: blk.
	pt := self parseTreeFor: self type.
	token = #eos ifFalse:[blk value: 'unrecognized tokens at end of input' value: prevTokenEnd].
	^pt
! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'parsing' !
parseTypeArgs: s <Str >  within: aScope <DeltaScope >   ^ <OrdCltn[ParseTree[DeltaTypeFormal]]>
    |
    tas <OrdCltn[DeltaTypeFormal]>
    errorBlock <[Str, Int, ^BottomType]> 
    |

    errorBlock := [ :msg <Str>  :pos <Int>  | Transcript show: msg; cr. self halt].
    self open: (DeltaScanner new open: s ifError: errorBlock) within: aScope ifError: errorBlock.
    tas := OrderedCollection[DeltaTypeFormal]  new.
    tas addFirst: (self parseTreeFor: self genericTypeArgument).
    [token = #comma] whileTrue: [
        self nextToken.
        tas addLast: (self parseTreeFor: self genericTypeArgument).
    ].
    token = #eos ifFalse:[self error: 'unrecognized tokens at end of input'].
    ^ tas ! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'parsing' !
parseTypeArgs: s <Str >  
within: aScope <DeltaScope >  
ifError: eb  <[Str,Int]> ^ <OrdCltn[ParseTree[DeltaTypeFormal]]>
    |
    tas <OrdCltn[ParseTree[DeltaTypeFormal]]>
    |

    self open: (DeltaScanner new open: s ifError: eb) within: aScope ifError: eb.
    tas := OrderedCollection[ParseTree[DeltaTypeFormal]]  new.
    tas addFirst: (self parseTreeFor: self genericTypeArgument).
    [token = #comma] whileTrue: [
        self nextToken.
        tas addLast: (self parseTreeFor: self genericTypeArgument).
    ].
    token = #eos ifFalse:[self error: 'unrecognized tokens at end of input'].
    ^ tas ! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'parsing' !
parseTypeExpr: s <Str > within: scope <DeltaScope > ^ <ParseTree[TypeExpr]>

	^self parseTypeExpr: s within: scope ifError: [ :msg <Str>  :pos <Int>  | Transcript show: msg; cr. self halt].
! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'parsing' !
parseTypeExpr: s <Str >within: scope <DeltaScope >  ifError: blk <[Str,Int]> ^ <ParseTree[TypeExpr]>

	self open: (DeltaScanner new open: s ifError: blk)
		within: scope
		ifError: blk.
	^self parseTreeFor: self typeExpr
! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'parsing' !
parseTypeFormalDecl: s <Str >  within: aScope <DeltaScope >   ^ <ParseTree[DeltaTypeFormal]>
    |
    tas <VarOrdCltn[DeltaTypeFormal]> 
    errorBlock <[Str, Int, ^BottomType]> 
    |

    errorBlock := [ :msg <Str>  :pos <Int>  | Transcript show: msg; cr. self halt].
    self open: (DeltaScanner new open: s ifError: errorBlock) within: aScope ifError: errorBlock.
    ^self  parseTreeFor: self typeFormalDecl.
 ! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'private' !
check: aToken <Symbol > ^ <Self>
    token = aToken ifFalse: [self error: aToken asString, ' expected'].
    self nextToken! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'private' !
closeScope ^ <Self>
    topScope := topScope superScope! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'private' !
constructorFor: operator <Symbol > ^ <DeltaUnionTypeclass|DeltaProtocolMergeclass|DeltaProtocolOverrideclass>
    operator = #vbar ifTrue: [^ DeltaUnionType].
    operator = #semicolon ifTrue: [^ DeltaProtocolMerge].
    operator = #slash
        ifTrue: [^ DeltaProtocolOverride]
        ifFalse: [^ self error: 'parser bug'].! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'private' !
convertToDeclRef: node ^ <Ref | GenericApplicationClassType>

^self 
	node: (node isRefNode
		ifTrue: [ DeltaClassId new setId: node name; scope: DeltaGlobals ]
		ifFalse: [ DeltaGenericApplicationClassType new apply: (self convertToDeclRef: node target) to: node actuals ])
	beginNode: node 
	endNode: node	
! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'private' !
declare: var
    topScope at: var name put: var ifThere: [self error: 'variable declared twice']! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'private' !
defsAllowed ^ <Boolean>

^defsAllowed! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'private' !
defsAllowed: d <Boolean>

defsAllowed := d.! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'private' !
error: aString <Str > ^ <BottomType>
    error isNil
        ifTrue: [super error: aString]
        ifFalse: [error value: aString value: scanner tokenBeg - 1]! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'private' !
get: aToken <Symbol > ^ <Symbol>
    | val <Symbol>  |
    token = aToken
        ifTrue: [val := scanner tokenVal. self nextToken. ^ val]
        ifFalse: [self error: aToken asString, ' expected'. " ^ nil - this should never get executed - it would cause a crash"]! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'private' !
nextToken ^ <Self>
    prevTokenBegin := scanner tokenBeg.
    prevTokenEnd := scanner tokenEnd.
    token := scanner token! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'private' !
open: aScanner <DeltaScanner >ifError: aBlock <[Str,Int,^BottomType] > ^ <Self>
    self open: aScanner within: nil ifError: aBlock! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'private' !
open: aScanner <DeltaScanner >within: aScope <DeltaScope >ifError: aBlock <[Str,Int,^BottomType] > ^ <Self>
    pseudoVars := #(self super nil true false).
    scanner := aScanner.
    error := aBlock.
    topScope := aScope.
    nodePositions := IdentityDictionary new.
    self defsAllowed: false.
    self nextToken! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'private' !
openCodeScope ^ <Self>
    topScope := DeltaCodeScope within: topScope! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'private' !
openNonCodeScope ^ <Self>
    topScope := DeltaScope within: topScope! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'private' !
openScope ^ <Self>
    topScope := DeltaCodeScope within: topScope! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'private' !
openTypeArgScope ^ <Self>
    topScope := DeltaPolyArgScope within: topScope! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'private' !
scanner ^ <DeltaScanner>
    ^scanner! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'private' !
topScope

^topScope! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'private' !
topScope: ts

topScope := ts.! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'private' !
undeclaredVariableHandler: name <Symbol>  ^ <[^BottomType]>

^ [(name at: 1) isLowercase
            ifTrue: [self error: 'undeclared variable ', name.]
            ifFalse: [ 
"
                            Transcript show: name asString, ' registered as undefined.' ; cr.
                            Delta installPlaceHolderNamed: name.
                            DeltaGlobals at: name.
"
                            Transcript show: 'Global ', name asString, ' is used but not defined so it has been added.' ; cr.
                            Delta declareGlobal: name type: '' initialValue: Delta nilObj.
                            DeltaGlobals at: name.
                            ]
    ].
! !

"August 22, 2009 -> 14:25:37"!

Delta define: #DeltaASTLocationTool as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'astNode astIndex count toEscape ')) !


"August 22, 2009 -> 14:25:37"!

Delta define: #DeltaASTLocationTool as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'astNode astIndex count toEscape ')) !


"August 22, 2009 -> 14:25:37"!

Delta define: #DeltaASTLocationTool as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'astNode astIndex count toEscape ')) !


"August 22, 2009 -> 14:25:37"!

Delta define: #DeltaASTLocationTool as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'astNode astIndex count toEscape ')) !


"August 22, 2009 -> 14:25:37"!

Delta define: #DeltaASTLocationTool as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'astNode astIndex count toEscape ')) !


"August 22, 2009 -> 14:25:37"!

Delta define: #DeltaASTLocationTool as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'astNode astIndex count toEscape ')) !


"August 22, 2009 -> 14:25:37"!

Delta define: #DeltaASTLocationTool as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'astNode astIndex count toEscape ')) !


"August 22, 2009 -> 14:25:37"!

Delta define: #DeltaASTLocationTool as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'astNode astIndex count toEscape ')) !


"August 22, 2009 -> 14:25:37"!

Delta define: #DeltaASTLocationTool as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'astNode astIndex count toEscape ')) !


"August 22, 2009 -> 14:25:37"!

Delta define: #DeltaASTLocationTool as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'astNode astIndex count toEscape ')) !


"August 22, 2009 -> 14:25:37"!

Delta define: #DeltaASTLocationTool as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'astNode astIndex count toEscape ')) !


"August 22, 2009 -> 14:25:37"!

(Delta mirrorFor: #DeltaASTLocationTool)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"August 22, 2009 -> 14:25:37"!

! (Delta mirrorFor: #DeltaASTLocationTool) classSide methodsFor: 'Unclassified' !
indexForNode: n <DeltaASTNode > startingFrom: root <DeltaASTNode >  ^ <Int>
	| tool <DeltaASTLocationTool>  |
	
	root isNil ifTrue:[^0].
	tool := self new astNode: n.
	tool toEscape: [^tool astIndex].
	root apply: tool.
	^0			"Not found"
! !

"August 22, 2009 -> 14:25:37"!

! (Delta mirrorFor: #DeltaASTLocationTool) classSide methodsFor: 'Unclassified' !
new ^<Instance>
	^super new initialize! !

"August 22, 2009 -> 14:25:37"!

! (Delta mirrorFor: #DeltaASTLocationTool) classSide methodsFor: 'Unclassified' !
nodeForIndex: i <Int >startingFrom: root <DeltaASTNode > ^ <DeltaASTNode>
	| tool <DeltaASTLocationTool>  |
	tool := self new astIndex: i.
	tool toEscape: [^tool astNode].
	root apply: tool.
	^nil		"Not found"! !

"August 22, 2009 -> 14:25:37"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
assignmentNode: node <DeltaMethod > ^ <Self>
    self check: node.
    node var apply: self.
    node expr apply: self.! !

"August 22, 2009 -> 14:25:37"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
astIndex ^ <Int>
    ^astIndex.! !

"August 22, 2009 -> 14:25:37"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
astIndex: i <Int > ^ <Self>
    astIndex := i.! !

"August 22, 2009 -> 14:25:37"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
astNode ^ <DeltaASTNode>
    ^astNode.! !

"August 22, 2009 -> 14:25:37"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
astNode: n <DeltaASTNode > ^ <Self>
    astNode := n.! !

"August 22, 2009 -> 14:25:37"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
blockApplicationTypeNode: node <BlockApplicationType > ^ <Self>

self genericApplicationTypeNode: node! !

"August 22, 2009 -> 14:25:37"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
blockNode: node <DeltaMethod > ^ <Self>
    self check: node.
    node body apply: self.
! !

"August 22, 2009 -> 14:25:37"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
cascadedSendNode: node <DeltaMethod > ^ <Self>
    self check: node.
    node prevSend apply: self.
    node msg apply: self.! !

"August 22, 2009 -> 14:25:37"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
check: n <DeltaASTNode > ^ <Self>

	self astNode isNil
		ifTrue: [self astIndex == self count								"Looking for index"
			ifTrue: [self astNode: n. self toEscape value]]
		ifFalse: [self astNode == n 											"Looking for node"
			ifTrue: [self astIndex: self count. self toEscape value]].
	self count: self count + 1.
! !

"August 22, 2009 -> 14:25:37"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
classVarNode: node <DeltaClassVar > ^ <Self>

self check: node.
node declaredType apply: self.
 
   ! !

"August 22, 2009 -> 14:25:37"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
codeBodyNode: node <DeltaCodeBody > ^ <Self>
    self check: node.
    node parameters do: [ :d <DeltaParameter>  | d apply: self ].
    node temporaries do: [ :d <DeltaTemporary>  | d apply: self ].
    node statements do: [ :d <DeltaStatement>  | d apply: self ]! !

"August 22, 2009 -> 14:25:37"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
count ^ <Int>
    ^count! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
count: c <Int > ^ <Self>
    count := c.! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
dllCallNode: node
    self check: node.
    node msg apply: self.! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
genericApplicationExpressionNode: node <DeltaGenericApplicationExpression > ^ <Self>
    self check: node.
    node actuals do: [ :d <DeltaType>  | d apply: self].
    node target apply: self.! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
genericApplicationTypeNode: node <DeltaGenericApplicationType > ^ <Self>
    self check: node.
    node actuals do: [ :d <DeltaType>  | d apply: self].
    node target apply: self.

! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
guaranteedNode: node <DeltaMethod > ^ <Self>
    self check: node.
    node declaredType apply: self.
    node expr apply: self.! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
initialize
	self count: 1! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
instVarNode: node <DeltaInstVar > ^ <Self>

self check: node.
node declaredType apply: self.
 
   ! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
literalNode: node <DeltaLiteral> ^ <Self>
    self check: node.! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
messageNode: node <DeltaStatementList > ^ <Self>
    self check: node.
    node args do: [ :s <DeltaExpression>  | s apply: self].! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
messagePatternNode: node <MessagePattern>

    self check: node.
    node type apply: self.


! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
methodDeclNode: node <DeltaMethod > ^ <Self>
    self check: node.
    node filteree apply: self.
! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
methodNode: node <DeltaMethod > ^ <Self>
    self check: node.
    node type apply: self.
    self deltaHack.
    node body notNil ifTrue: [node body apply: self].
! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
mixinCompositionNode: node <MixinCompositionNode>

self check: node.
node iMixin apply: self.
node oMixin apply: self.


! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
mixinDerivationNode: node

self check: node.
node klass apply: self.


! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
mixinInvocationNode: node <MixinInvocationNode>

self check: node.
node myMixin apply: self.
node myClass apply: self.

! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
msgSignatureNode: node <DeltaMsgSignature > ^ <Self>
    self check: node.
    node domain do: [ :d <DeltaType>  | d apply: self].
    node range apply: self.! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
normalSendNode: node <DeltaMethod > ^ <Self>
    self check: node.
    node recv apply: self.
    node msg apply: self.! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
parameterNode: node <DeltaParameter > ^ <Self>
	self check: node.
	node type apply: self.! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
polyMsgSignatureNode: node <PolyMsgSignature > ^ <Self>
	self check: node.
	node formals do: [ :d <TypeVar>  | d apply: self].
	node body apply: self.! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
primitiveNode: node <DeltaPrimitive > ^ <Self>
    self check: node.
    node recv isNil ifFalse:[node recv apply: self].
    node msg apply: self.! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
protocolMergeNode: node
	self check: node.
	node type1 apply: self.
	node type2 apply: self.! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
protocolOverrideNode: node
	self check: node.
	node type1 apply: self.
	node type2 apply: self.! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
refNode: node <DeltaRef > ^ <Self>
    self check: node.
	"Is this correct ?"! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
returnStatNode: node <DeltaReturnStat> ^ <Self>
    self check: node.
    node expr apply: self.
! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
statementListNode: node <DeltaStatementList > ^ <Self>
    self check: node.
    node code do: [ :s <DeltaStatement>  | s apply: self].! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
superSendNode: node <DeltaMethod > ^ <Self>
    self check: node.
    node msg apply: self.! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
temporaryNode: node <DeltaTemporary > ^ <Self>
	self check: node.
	node type apply: self.! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
toEscape ^ <[]>
    ^toEscape! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
toEscape: blk <[]>
	toEscape := blk! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
tupleNode: node <DeltaTuple>
	self check: node.
	node elements do:[:e | e apply: self]! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
tupleTypeNode: node <TupleType > ^ <Self>

self genericApplicationTypeNode: node! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
typeErrorNode: node <DeltaTypeError > ^ <Self>
    self check: node.! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
typeFormalNode: node <TypeFormal>

self check: node.
node typeVar apply: self.

! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
typeIdNode: node <DeltaTypeId > ^ <Self>
    self check: node.! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
typeVarNode: node <DeltaTypeVar > ^ <Self>
	self check: node.
	node declaredBound apply: self.
! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
unaryGenAppNode: node <DeltaUnaryGenApp>

self check: node.
node dual apply: self! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
unaryTypeExprNode: node <DeltaMethod > ^ <Self>
self deltaHack.
    self check: node.
    node target apply: self.
! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
unionTypeNode: node <UnionType>
	self check: node.
	node type1 apply: self.
	node type2 apply: self.! !

"August 22, 2009 -> 14:26:0"!

Delta define: #DeltaASTTool as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 22, 2009 -> 14:26:0"!

Delta define: #DeltaASTTool as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 22, 2009 -> 14:26:0"!

Delta define: #DeltaASTTool as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 22, 2009 -> 14:26:0"!

Delta define: #DeltaASTTool as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 22, 2009 -> 14:26:0"!

Delta define: #DeltaASTTool as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 22, 2009 -> 14:26:0"!

Delta define: #DeltaASTTool as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 22, 2009 -> 14:26:0"!

Delta define: #DeltaASTTool as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 22, 2009 -> 14:26:0"!

Delta define: #DeltaASTTool as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 22, 2009 -> 14:26:0"!

Delta define: #DeltaASTTool as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 22, 2009 -> 14:26:0"!

Delta define: #DeltaASTTool as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 22, 2009 -> 14:26:0"!

Delta define: #DeltaASTTool as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 22, 2009 -> 14:26:0"!

(Delta mirrorFor: #DeltaASTTool)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
accessMethodNode: node <Object > ^ <Self>
    ^ self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
andOrNode: node <Object > ^ <Self>
    ^ self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
assignmentNode: node <DeltaAssignment > ^ <Self>
    ^ self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
blockApplicationTypeNode: node <BlockApplicationType>
    self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
blockNode: node <DeltaBlock > ^ <Self>
    ^ self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
cascadedSendNode: node <DeltaCascadedSend > ^ <Self>
    ^ self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
classVarNode: node <DeltaClassVar > ^ <Self>
    ^ self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
codeBodyNode: cb <CodeBody>

self subclassResponsibility! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
dllCallNode: node
    self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
genericApplicationExpressionNode: node
    self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
genericApplicationTypeNode: node <GenericApplicationType>
    self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
globalVarNode: node <DeltaGlobalVar > ^ <Self>
    ^ self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
guaranteedNode: node
    self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
ifNode: node <Object > ^ <Self>
    ^ self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
instVarNode: node <DeltaInstVar > ^ <Self>
    ^ self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
literalNode: node <DeltaLiteral > ^ <Self>
    ^ self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
loopNode: node <Object > ^ <Self>
    ^ self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
messageNode: node <DeltaMessage > ^ <Self>
    ^ self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
messagePatternNode: node <MessagePattern>

self subclassResponsibility
! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
methodNode: node <DeltaMethod > ^ <Self>
    ^ self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
mixinCompositionNode: node

self subclassResponsibility


! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
mixinDerivationNode: node

self subclassResponsibility


! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
mixinInvocationNode: node

self subclassResponsibility


! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
normalSend: node
    self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
normalSendNode: node
    self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
parameterNode: node <DeltaParameter > ^ <Self>
    ^ self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
polyMsgSignatureNode: node <PolyMsgSignature > ^ <Self>

self subclassResponsibility! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
poolVarNode: node <DeltaPoolVar > ^ <Self>
    ^ self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
predictPrimitiveNode: node
    self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
primitiveCallNode: node
    self subclassResponsibility! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
primitiveNode: node <DeltaPrimitive > ^ <Self>
     self subclassResponsibility! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
protocolMergeNode: node <ProtocolMerge>

self subclassResponsibility
! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
protocolOverrideNode: node <ProtocolOverride>

self subclassResponsibility
! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
receiverNode: node <DeltaReceiver > ^ <Self>
    ^ self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
refNode: node <DeltaRef > ^ <Self>
    ^ self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
returnInstVarNode: node
    self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
returnStatNode: node <DeltaReturnStat > ^ <Self>
    ^ self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
superSendNode: node <DeltaSuperSend > ^ <Self>
    ^ self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
superVarNode: node <DeltaSuperVar > ^ <Self>
    ^ self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
temporaryNode: node <DeltaTemporary > ^ <Self>
    ^ self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
tupleTypeNode: node <TupleType>
    self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
tuplelNode: node <DeltaLiteral > ^ <Self>
    ^ self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
typeFormalNode: node <TypeFormal>

self subclassResponsibility.! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
typeVarNode: node <TypeVar> 

self subclassResponsibility.! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
unaryGenAppNode: node <DeltaUnaryGenApp>

self subclassResponsibility! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
unaryTypeExprNode: node <UnaryTypeExpr>

self subclassResponsibility.! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
unionTypeNode: node <UnionType>

self subclassResponsibility! !

"August 22, 2009 -> 14:26:22"!

Delta define: #DeltaASTPrinter as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'stream indent prec ')) !


"August 22, 2009 -> 14:26:22"!

Delta define: #DeltaASTPrinter as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'stream indent prec ')) !


"August 22, 2009 -> 14:26:22"!

Delta define: #DeltaASTPrinter as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'stream indent prec ')) !


"August 22, 2009 -> 14:26:22"!

Delta define: #DeltaASTPrinter as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'stream indent prec ')) !


"August 22, 2009 -> 14:26:22"!

Delta define: #DeltaASTPrinter as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'stream indent prec ')) !


"August 22, 2009 -> 14:26:22"!

Delta define: #DeltaASTPrinter as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'stream indent prec ')) !


"August 22, 2009 -> 14:26:22"!

Delta define: #DeltaASTPrinter as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'stream indent prec ')) !


"August 22, 2009 -> 14:26:22"!

Delta define: #DeltaASTPrinter as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'stream indent prec ')) !


"August 22, 2009 -> 14:26:22"!

Delta define: #DeltaASTPrinter as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'stream indent prec ')) !


"August 22, 2009 -> 14:26:22"!

Delta define: #DeltaASTPrinter as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'stream indent prec ')) !


"August 22, 2009 -> 14:26:22"!

Delta define: #DeltaASTPrinter as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'stream indent prec ')) !


"August 22, 2009 -> 14:26:22"!

(Delta mirrorFor: #DeltaASTPrinter)
comment: 
'Instance variables:

	stream		output stream

	indent		current indentation level, starting with 0 (no indentation)

	prec			current precedence level (of enclosing expression),
					starting with 0 (lowest precedence):

					0	precedence of keyword messages
					1	precedence of binary messages
					2	precedence of unary messages
	
 (c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) classSide methodsFor: 'Unclassified' !
new
	^ super new initialize! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
andOrNode: node
	| op |
	self assert: [ node isAndOrNode ].
	node isAnd
		ifTrue: [ op := ' and: ' ]
		ifFalse: [ op := ' or: ' ].
	self print: node recv.
	self write: op.
	self write: '[ '.
	self print: node arg.
	self write: ' ]'! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
assignmentNode: node
	self assert: [ node isAssignmentNode ].
	self print: node var.
	self write: ' := '.
	self print: node expr! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
blockNode: node
	| pars |
	self assert: [ node isBlockNode ].
	self write: '[] '.
	pars := node parameters.
	pars size > 0 ifTrue: [
		pars do: [ :par |
			self write: ':'.
			self write: par name.
			self write: ' '
		].
		self write: '| '
	].
	self print: node body.
	self write: ' []'! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
cascadedSendNode: node
	self assert: [ node isCascadedSendNode ].
	self print: node prevSend.
	self write: ' ; '.
	self print: node msg! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
classVarNode: node
	self assert: [ node isClassVarNode ].
	self write: node name! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
codeBodyNode: node
    | t first |
    self assert: [ node isCodeBodyNode ].

    "temporaries"
    t := node temporaries.
    t size > 0 ifTrue: [
        self write: '| '.
        t do: [ :var | self write: var name, ' '].
        self write: '|'.
        self ln
    ].

    "statements"
	first := true.
	node statements do: [ :stat |
		first
			ifTrue: [first := false]
			ifFalse: [
				self write: '.'.
				self ln
			].
		self print: stat
	]! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
ifNode: node
	| t e |
	self assert: [node isIfNode].
	node ifTrue
		ifTrue: [ t := ' ifTrue: '. e := ' ifFalse: ' ]
		ifFalse: [ e := ' ifTrue: '. t := ' ifFalse: ' ].
	node cond apply: self.
	self write: t.
	self write: '[ '.
	self indent: [
		self ln.
		self print: node then
	].
	self ln.
	self write: ' ]'.
	node else isNil ifFalse: [
		self write: e.
		self write: '[ '.
		self indent: [
			self ln.
			self print: node else
		].
		self ln.
		self write: ' ]'
	]! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
indent: block
	indent := indent + 1.
	block value.
	indent := indent - 1! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
initialize
	stream := Transcript.	"default stream"
	indent := 0.
	prec := 0! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
inlinedBlockNode: node
	self assert: [ node isInlinedBlockNode ].
	self write: '[ '.
	self print: node body.
	self write: ' ] value'! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
intersperse: sel with: args
	| nofArgs keys first |
	nofArgs := args size.

	"unary message"
	nofArgs = 0 ifTrue: [
		self write: sel.
		^ self
	].

	"binary message or keyword message with 1 argument"
	nofArgs = 1 ifTrue: [
		self write: sel.
		self write: ' '.
		((sel at: sel size) = $:)
			ifTrue: [self print: (args at: 1) within: 2]
			ifFalse: [self print: (args at: 1) within: 1].
		^ self
	].

	"keyword message"
	first := true.
	keys := sel asArrayOfSubstringsSeparatedBy: $:.
	1 to: args size do: [ :i |
		first
			ifTrue: [first := false]
			ifFalse: [self write: ' '].
		self write: (keys at: i).
		self write: ': '.
		self print: (args at: i) within: 2
	]! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
komment
	"
	Instance variables:

	stream		output stream

	indent		current indentation level, starting with 0 (no indentation)

	prec			current precedence level (of enclosing expression),
					starting with 0 (lowest precedence):

					0	precedence of keyword messages
					1	precedence of binary messages
					2	precedence of unary messages
	"! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
literalNode: node
	self assert: [ node isLiteralNode ].
	node isCharNode ifTrue: [ self write: '$' ].
	self write: node value printString! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
ln
	| i |
	stream cr.
	i := indent.
	[ i > 0 ] whileTrue: [ stream tab. i := i - 1 ]! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
loopNode: node
	self assert: [ node isLoopNode ].
	node prologue isNil ifFalse: [
		self print: node prologue.
		self write: '.'.
		self ln
	].
	self write: '[ '.
	self print: node cond.
	self write: ' ]'.
	node whileTrue
		ifTrue: [ self write: ' whileTrue' ]
		ifFalse: [ self write: ' whileFalse' ].
	node body isNil ifFalse: [
		self write: ': ['.
		self indent: [
			self ln.
			self print: node body
		].
		self ln.
		self write: ']'
	]
	! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
messageNode: node
	self assert: [ node isMessageNode ].
	self intersperse: node selector with: node arguments! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
methodNode: node <DeltaMethod > ^ <Self>
	self assert: [ node isMethodNode ].
	self intersperse: node selector with: node body parameters.
	self indent: [
		self ln.
		self print: node body
	].
	self ln! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
normalSendNode: node
	self assert: [ node isNormalSendNode ].
	self print: node recv.
	self write: ' '.
	self print: node msg! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
parameterNode: node
	self assert: [ node isParameterNode ].	
	self write: node name! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
predictPrimitiveNode: node
	self assert: [ node isPredictPrimitiveNode ].
	self write: '"predict ', node primitive, '"'! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
primitiveCallNode: node
	self assert: [ node isPrimitiveCallNode ].
	self write: node selector! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
print: node
	node apply: self! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
print: node on: aStream
	stream := aStream.
	self print: node! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
print: node within: p
	| prevPrec |
	prevPrec := prec.
	prec := p.
	node apply: self.
	prec := prevPrec! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
receiverNode: node
	self assert: [ node isReceiverNode ].	
	self write: node name! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
refNode: node
	self assert: [ node isRefNode ].
	self write: node decl name! !

"August 22, 2009 -> 14:26:23"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
returnStatNode: node
	self assert: [ node isReturnStatNode ].
	self write: '^ '.
	self print: node expr! !

"August 22, 2009 -> 14:26:23"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
selfSendNode: node
	self assert: [ node isSelfSendNode ].
	self write: 'self '.
	self print: node msg! !

"August 22, 2009 -> 14:26:23"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
superSendNode: node
	self assert: [ node isSuperSendNode ].
	self write: 'super '.
	self print: node msg! !

"August 22, 2009 -> 14:26:23"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
superVarNode: node
	self assert: [ node isSuperVarNode ].
	self write: node name! !

"August 22, 2009 -> 14:26:23"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
temporaryNode: node
	self assert: [ node isTemporaryNode ].	
	self write: node name! !

"August 22, 2009 -> 14:26:23"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
tupleNode: node
	self write: '{ '.
	node elements do: [: e | 
		e  apply: self.
		self write: '.'.
		].
	self write: ' }'.! !

"August 22, 2009 -> 14:26:23"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
typeVarNode: node
	self write: node name! !

"August 22, 2009 -> 14:26:23"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
write: s
	stream nextPutAll: s! !

"August 22, 2009 -> 14:26:42"!

Delta define: #DeltaReferenceGatherer as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'references ')) !


"August 22, 2009 -> 14:26:42"!

Delta define: #DeltaReferenceGatherer as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'references ')) !


"August 22, 2009 -> 14:26:42"!

Delta define: #DeltaReferenceGatherer as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'references ')) !


"August 22, 2009 -> 14:26:42"!

Delta define: #DeltaReferenceGatherer as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'references ')) !


"August 22, 2009 -> 14:26:42"!

Delta define: #DeltaReferenceGatherer as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'references ')) !


"August 22, 2009 -> 14:26:42"!

Delta define: #DeltaReferenceGatherer as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'references ')) !


"August 22, 2009 -> 14:26:42"!

Delta define: #DeltaReferenceGatherer as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'references ')) !


"August 22, 2009 -> 14:26:42"!

Delta define: #DeltaReferenceGatherer as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'references ')) !


"August 22, 2009 -> 14:26:42"!

Delta define: #DeltaReferenceGatherer as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'references ')) !


"August 22, 2009 -> 14:26:42"!

Delta define: #DeltaReferenceGatherer as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'references ')) !


"August 22, 2009 -> 14:26:42"!

Delta define: #DeltaReferenceGatherer as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'references ')) !


"August 22, 2009 -> 14:26:42"!

(Delta mirrorFor: #DeltaReferenceGatherer)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
assignmentNode: node <DeltaAssignment > ^ <Self>

node var apply: self.
node expr apply: self.! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
blockApplicationTypeNode: node <BlockApplicationType > ^ <Self>

self genericApplicationTypeNode: node! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
blockNode: node <DeltaBlock > ^ <Self>
    node body apply: self.! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
cascadedSendNode: node <DeltaCascadedSend > ^ <Self>

node msg apply: self.
node prevSend apply: self.! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
codeBodyNode: node <CodeBody>

node temporaries do:[:tmp  <VarDecl>  | tmp apply: self.].
node statements do:[:stmt  <Statement> | stmt apply: self.].! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
dllCallNode: node
     self deltaHack.! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
genericApplicationExpressionNode: node

node target apply: self.
node actuals do:[:actual  <ObjectType>  | actual apply: self].! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
genericApplicationTypeNode: node

node target apply: self.
node actuals do:[:actual  <ObjectType>  | actual apply: self].! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
guaranteedNode: node
 
node expr apply: self.
node declaredType apply: self.! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
initialize

self references: Set[Symbol] new.! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
literalNode: node <DeltaLiteral > ^ <Self>
    

"Should we do something for the case where the type of a literal changes?"! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
messageNode: node <DeltaMessage > ^ <Self>

node args do:[:arg  <Expression> | arg apply: self].! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
methodNode: node <DeltaMethod > ^ <Self>

node type apply: self.
node body isNil ifFalse:[node body apply: self].! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
msgSignatureNode: node <DeltaMsgSignature > ^ <Self>

    node domain do: [ :d <DeltaType>  | d apply: self.].
    node range apply: self.! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
normalSendNode: node

node recv apply: self.
node msg apply: self.! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
note: n <Symbol>

(DeltaGlobals at: n ifAbsent:[^self]).
self references add: n.! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
parameterNode: node <DeltaParameter > ^ <Self>

self varNode: node! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
polyMsgSignatureNode: node <PolyMsgSignature > ^ <Self>

    node formals do: [ :d <TypeVar>  | d apply: self.].
    node body apply: self.! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
primitiveCallNode: node

node recv isNil ifFalse:[node recv apply: self].
node msg apply: self.! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
primitiveNode: node <DeltaPrimitive > ^ <Self>
    ^ self primitiveCallNode: node! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
protocolMergeNode: node <ProtocolMerge>

node type1 apply: self.
node type2 apply: self.! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
protocolOverrideNode: node

node type1 apply: self.
node type2 apply: self.! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
refNode: node <DeltaRef > ^ <Self>

self note: node name.! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
references ^ <OrdCltn[Symbol]>

^references! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
references: r <OrdCltn[Symbol]> ^ <OrdCltn[Symbol]>

references := r! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
returnStatNode: node <DeltaReturnStat > ^ <Self>

node expr apply: self.! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
statementListNode: node <DeltaStatementList > ^ <Self>

node code apply: self.! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
temporaryNode: node <DeltaTemporary > ^ <Self>

self varNode: node.! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
tupleNode: node <DeltaTuple>
	node elements do:[:e | e apply: self]! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
tupleTypeNode: node <TupleType > ^ <Self>

self genericApplicationTypeNode: node! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
typeErrorNode: node <DeltaTypeError > ^ <Self>
! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
typeIdNode: node <DeltaTypeId > ^ <Self>

self note: node name.! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
typeVarNode: node <TypeVar> 

node declaredBound apply: self.! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
unaryTypeExprNode: node <DeltaUnaryTypeExpr > ^ <Self>

node target apply: self.! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
unionTypeNode: node

node type1 apply: self.
node type2 apply: self.! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
varNode: node <DeltaTemporary > ^ <Self>

node type apply: self.! !

"August 22, 2009 -> 14:58:4"!

"System saved" !
"August 23, 2009 -> 19:50:35"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"August 23, 2009 -> 19:50:35"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"August 23, 2009 -> 19:50:35"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"August 23, 2009 -> 19:50:35"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"August 23, 2009 -> 19:50:35"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"August 23, 2009 -> 19:50:35"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"August 23, 2009 -> 19:50:35"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"August 23, 2009 -> 19:50:35"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"August 23, 2009 -> 19:50:35"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"August 23, 2009 -> 19:50:35"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"August 23, 2009 -> 19:50:35"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"August 23, 2009 -> 19:50:35"!

(Delta mirrorFor: #TestCase)
comment: 
'A TestCase is a Command representing the future running of a test case. Create one with the class method #selector: aSymbol, passing the name of the method to be run when the test case runs.

When you discover a new fixture, subclass TestCase, declare instance variables for the objects in the fixture, override #setUp to initialize the variables, and possibly override# tearDown to deallocate any external resources allocated in #setUp.

When you are writing a test case method, send #assert: aBoolean when you want to check for an expected value. For example, you might say "self assert: socket isOpen" to test whether or not a socket is open at a point in a test.'!


"August 23, 2009 -> 19:50:35"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Accessing' !
allTestSelectors

	^(self sunitAllSelectors
		select: [:each | 'test*' sunitMatch: each])
		reject: [:each| each includes: $:]! !

"August 23, 2009 -> 19:50:35"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Accessing' !
resources

	^#()
			! !

"August 23, 2009 -> 19:50:35"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Accessing' !
sunitVersion
	^'3.1'
			! !

"August 23, 2009 -> 19:50:35"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Accessing' !
testSelectors

	^(self sunitSelectors 
		select: [:each | 'test*' sunitMatch: each])
		reject: [:each| each includes: $:]
			! !

"August 23, 2009 -> 19:50:35"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
buildSuite
	| suite |
	^self isAbstract
		ifTrue: 
			[suite := self suiteClass named: self name asString.
			self allSubclasses 
				do: [:each | each isAbstract ifFalse: [suite addTest: each buildSuiteFromSelectors]].
			suite]
		ifFalse: [self buildSuiteFromSelectors]
			! !

"August 23, 2009 -> 19:50:35"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
buildSuiteFromAllSelectors

	^self buildSuiteFromMethods: self allTestSelectors
			! !

"August 23, 2009 -> 19:50:35"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
buildSuiteFromLocalSelectors

	^self buildSuiteFromMethods: self testSelectors
			! !

"August 23, 2009 -> 19:50:35"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
buildSuiteFromMethods: testMethods

	^testMethods
		inject: (self suiteClass named: self name asString)
		into: [:suite :selector |
			suite
				addTest: (self selector: selector);
				yourself]
			! !

"August 23, 2009 -> 19:50:35"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
buildSuiteFromSelectors

	^self shouldInheritSelectors
		ifTrue: [self buildSuiteFromAllSelectors]
		ifFalse: [self buildSuiteFromLocalSelectors]
			! !

"August 23, 2009 -> 19:50:35"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
suiteClass
	^TestSuite
			! !

"August 23, 2009 -> 19:50:35"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Instance Creation' !
debug: aSymbol

	^(self selector: aSymbol) debug
			! !

"August 23, 2009 -> 19:50:35"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Instance Creation' !
run: aSymbol

	^(self selector: aSymbol) run
			! !

"August 23, 2009 -> 19:50:35"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Instance Creation' !
runAll

	[self suite run printOn: (Transcript cr; yourself)] fork! !

"August 23, 2009 -> 19:50:35"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Instance Creation' !
selector: aSymbol

	^self new setTestSelector: aSymbol
			! !

"August 23, 2009 -> 19:50:35"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Instance Creation' !
suite

	^self buildSuite
			! !

"August 23, 2009 -> 19:50:35"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Testing' !
isAbstract
	"Override to true if a TestCase subclass is Abstract and should not have
	TestCase instances built from it"

	^self sunitName = #TestCase
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Testing' !
shouldInheritSelectors
	"I should inherit from an Abstract superclass but not from a concrete one by default,
	 unless I have no testSelectors in which case I must be expecting to inherit them
	 from my superclass.  If a test case with selectors wants to inherit selectors from a
	 concrete superclass, override this to true in that subclass."

	^self superclass isAbstract
		or: [self testSelectors isEmpty]

"$QA Ignore:Sends system method(superclass)$"
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
assert: aBooleanOrBlock

	aBooleanOrBlock value ifFalse: [self signalFailure: 'Assertion failed']
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
assert: aBoolean description: aString
	aBoolean ifFalse: [
		self logFailure: aString.
		TestResult failure sunitSignalWith: aString]
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
assert: aBoolean description: aString resumable: resumableBoolean 
	| exception |
	aBoolean
		ifFalse: 
			[self logFailure: aString.
			exception := resumableBoolean
						ifTrue: [TestResult resumableFailure]
						ifFalse: [TestResult failure].
			exception sunitSignalWith: aString]
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
deny: aBoolean

	self assert: aBoolean not
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
deny: aBoolean description: aString
	self assert: aBoolean not description: aString
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
deny: aBoolean description: aString resumable: resumableBoolean 
	self
		assert: aBoolean not
		description: aString
		resumable: resumableBoolean
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
resources
	| allResources resourceQueue |
	allResources := Set new.
	resourceQueue := OrderedCollection new.
	resourceQueue addAll: self class resources.
	[resourceQueue isEmpty] whileFalse: [
		| next |
		next := resourceQueue removeFirst.
		allResources add: next.
		resourceQueue addAll: next resources].
	^allResources
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
selector
	^testSelector
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
should: aBlock
	self assert: aBlock value
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
should: aBlock description: aString
	self assert: aBlock value description: aString
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
should: aBlock raise: anExceptionalEvent 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent)
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
should: aBlock raise: anExceptionalEvent description: aString 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent)
		description: aString
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
should: aBlock raise: anException withExceptionDo: anotherBlock 

	^self assert: [self executeShould: aBlock inScopeOf: anException withExceptionDo: anotherBlock]! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
shouldnt: aBlock
	self deny: aBlock value
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
shouldnt: aBlock description: aString
	self deny: aBlock value description: aString
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
shouldnt: aBlock raise: anExceptionalEvent 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent) not
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
shouldnt: aBlock raise: anExceptionalEvent description: aString 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent) not 		description: aString
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
signalFailure: aString
	TestResult failure sunitSignalWith: aString! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Dependencies' !
addDependentToHierarchy: anObject 
	"an empty method. for Composite compability with TestSuite"


			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Dependencies' !
removeDependentFromHierarchy: anObject 
	"an empty method. for Composite compability with TestSuite"


			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Printing' !
echo

	Transcript cr.
	self printOn: Transcript! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Printing' !
printOn: aStream

	aStream
		nextPutAll: self class printString;
		nextPutAll: '>>#';
		nextPutAll: testSelector
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Private' !
executeShould: aBlock inScopeOf: anExceptionalEvent 
	^[aBlock value.
 	false] sunitOn: anExceptionalEvent
		do: [:ex | ex sunitExitWith: true]
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Private' !
executeShould: aBlock inScopeOf: anException withExceptionDo: anotherBlock

	^[aBlock value.
 	false] 
		on: anException
		do: [:exception | 
			anotherBlock value: exception.
			exception return: true]! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Private' !
performTest

	self perform: testSelector sunitAsSymbol
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Private' !
setTestSelector: aSymbol
	testSelector := aSymbol
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
debug
	self resources do: [:res | 
		res isAvailable ifFalse: [^res signalInitializationError]].
	[(self class selector: testSelector) runCase] 
		sunitEnsure: [self resources do: [:each | each reset]]
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
debugAsFailure
	| semaphore |
	semaphore := Semaphore new.
	self resources do: [:res | 
		res isAvailable ifFalse: [^res signalInitializationError]].
	[semaphore wait. self resources do: [:each | each reset]] fork.
	(self class selector: testSelector) runCaseAsFailure: semaphore.

			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
failureLog	
	^SUnitNameResolver defaultLogDevice

			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
isLogging
	"By default, we're not logging failures. If you override this in 
	a subclass, make sure that you override #failureLog"
	^true
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
logFailure: aString
	self isLogging ifTrue: [
		self failureLog 
			cr; 
			nextPutAll: aString; 
			flush]
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
openDebuggerOnFailingTestMethod
	"SUnit has halted one step in front of the failing test method. Step over the 'self halt' and 
	 send into 'self perform: testSelector' to see the failure from the beginning"

	self
		halt;
		performTest
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
run
	| result |
	result := TestResult new.
	self run: result.
	^result
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
run: aResult
	aResult runCase: self
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
runCase

	[self setUp.
	self performTest] sunitEnsure: [self tearDown]
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
runCaseAsFailure: aSemaphore
	[self setUp.
	self openDebuggerOnFailingTestMethod] sunitEnsure: [
		self tearDown.
		aSemaphore signal]
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
setUp
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
tearDown
			! !

"August 23, 2009 -> 19:50:44"!

Delta define: #Block as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 23, 2009 -> 19:50:44"!

Delta define: #Block as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 23, 2009 -> 19:50:44"!

Delta define: #Block as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 23, 2009 -> 19:50:44"!

Delta define: #Block as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 23, 2009 -> 19:50:44"!

Delta define: #Block as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 23, 2009 -> 19:50:44"!

Delta define: #Block as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 23, 2009 -> 19:50:44"!

Delta define: #Block as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 23, 2009 -> 19:50:44"!

Delta define: #Block as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 23, 2009 -> 19:50:44"!

Delta define: #Block as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 23, 2009 -> 19:50:44"!

Delta define: #Block as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 23, 2009 -> 19:50:44"!

Delta define: #Block as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 23, 2009 -> 19:50:44"!

(Delta mirrorFor: #Block)
comment: 
'Tags: %BlueBook

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.3 $
'!


"August 23, 2009 -> 19:50:44"!

! (Delta mirrorFor: #Block) classSide methodsFor: 'fancy control structures' !
exitFrom: blk <[[RET def,^BottomType], ^FALLOFF def]>  ^<RET | FALLOFF>

	^blk value: [ :ret <RET> | ^ret ]! !

"August 23, 2009 -> 19:50:44"!

! (Delta mirrorFor: #Block) classSide methodsFor: 'file out' !
fileOutSignature ^<Integer>
    ^75! !

"August 23, 2009 -> 19:50:44"!

! (Delta mirrorFor: #Block) methodsFor: 'arity' !
arity
	self subclassResponsibility! !

"August 23, 2009 -> 19:50:44"!

! (Delta mirrorFor: #Block) methodsFor: 'debugging' !
blockIsOptimized ^ <Boolean>

	^{{self primitiveBlockIsOptimized}}! !

"August 23, 2009 -> 19:50:44"!

! (Delta mirrorFor: #Block) methodsFor: 'debugging' !
blockMethod ^ <Method>

	^{{self primitiveBlockMethod}}! !

"August 23, 2009 -> 19:50:44"!

! (Delta mirrorFor: #Block) methodsFor: 'evaluating' !
value ^<Object>

	self error: 'Block with arguments invoked with none'! !

"August 23, 2009 -> 19:50:44"!

! (Delta mirrorFor: #Block) methodsFor: 'evaluating' !
valueWithArguments: a <Array[Object]> ^ <Object>
	^self subclassResponsibility! !

"August 23, 2009 -> 19:50:44"!

! (Delta mirrorFor: #Block) methodsFor: 'file out' !
fileOutOn: d <Dumper>
	self error: 'should not file out blocks'! !

"August 23, 2009 -> 19:50:44"!

! (Delta mirrorFor: #Block) methodsFor: 'private' !
validateValues: a <Array[Object]>
	self assert:[a size = self arity].! !

"August 23, 2009 -> 19:50:52"!

Delta define: #BlockWithEightArguments as: (
Generic forAll: '(A1 contra) , (A2 contra), (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra)  , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, ^R]')) !


"August 23, 2009 -> 19:50:52"!

Delta define: #BlockWithEightArguments as: (
Generic forAll: '(A1 contra) , (A2 contra), (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra)  , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, ^R]')) !


"August 23, 2009 -> 19:50:52"!

Delta define: #BlockWithEightArguments as: (
Generic forAll: '(A1 contra) , (A2 contra), (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra)  , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, ^R]')) !


"August 23, 2009 -> 19:50:52"!

Delta define: #BlockWithEightArguments as: (
Generic forAll: '(A1 contra) , (A2 contra), (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra)  , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, ^R]')) !


"August 23, 2009 -> 19:50:52"!

Delta define: #BlockWithEightArguments as: (
Generic forAll: '(A1 contra) , (A2 contra), (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra)  , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, ^R]')) !


"August 23, 2009 -> 19:50:52"!

Delta define: #BlockWithEightArguments as: (
Generic forAll: '(A1 contra) , (A2 contra), (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra)  , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, ^R]')) !


"August 23, 2009 -> 19:50:52"!

Delta define: #BlockWithEightArguments as: (
Generic forAll: '(A1 contra) , (A2 contra), (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra)  , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, ^R]')) !


"August 23, 2009 -> 19:50:52"!

Delta define: #BlockWithEightArguments as: (
Generic forAll: '(A1 contra) , (A2 contra), (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra)  , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, ^R]')) !


"August 23, 2009 -> 19:50:52"!

Delta define: #BlockWithEightArguments as: (
Generic forAll: '(A1 contra) , (A2 contra), (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra)  , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, ^R]')) !


"August 23, 2009 -> 19:50:52"!

Delta define: #BlockWithEightArguments as: (
Generic forAll: '(A1 contra) , (A2 contra), (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra)  , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, ^R]')) !


"August 23, 2009 -> 19:50:52"!

Delta define: #BlockWithEightArguments as: (
Generic forAll: '(A1 contra) , (A2 contra), (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra)  , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, ^R]')) !


"August 23, 2009 -> 19:50:52"!

Delta define: #BlockWithEightArguments as: (
Generic forAll: '(A1 contra) , (A2 contra), (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra)  , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, ^R]')) !


"August 23, 2009 -> 19:50:52"!

(Delta mirrorFor: #BlockWithEightArguments)
comment: 
'(c) 1996-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.2 $'!


"August 23, 2009 -> 19:50:52"!

! (Delta mirrorFor: #BlockWithEightArguments) methodsFor: 'arity' !
arity ^ <Integer>
	^8! !

"August 23, 2009 -> 19:50:52"!

! (Delta mirrorFor: #BlockWithEightArguments) methodsFor: 'evaluating' !
value: arg1 <A1> value: arg2 <A2> value: arg3 <A3> value: arg4 <A4> value: arg5 <A5> value: arg6 <A6> value: arg7 <A7> value: arg8 <A8>
    "Block dispatch method (vm generated)"
    ^{{self primitiveValue: arg1 value: arg2 value: arg3 value: arg4 value: arg5 value: arg6 value: arg7 value: arg8}}! !

"August 23, 2009 -> 19:50:52"!

! (Delta mirrorFor: #BlockWithEightArguments) methodsFor: 'evaluating' !
valueWithArguments: a <Array[Object]> ^ <R>
	self validateValues: a.
	^self value: (a at: 1) value: (a at: 2) value: (a at: 3)
			value: (a at: 4) value: (a at: 5) value: (a at: 6) 
			value: (a at: 7) value: (a at: 8)! !

"August 23, 2009 -> 19:50:58"!

Delta define: #BlockWithFiveArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra), (A5 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, ^R]')) !


"August 23, 2009 -> 19:50:58"!

Delta define: #BlockWithFiveArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra), (A5 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, ^R]')) !


"August 23, 2009 -> 19:50:58"!

Delta define: #BlockWithFiveArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra), (A5 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, ^R]')) !


"August 23, 2009 -> 19:50:58"!

Delta define: #BlockWithFiveArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra), (A5 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, ^R]')) !


"August 23, 2009 -> 19:50:58"!

Delta define: #BlockWithFiveArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra), (A5 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, ^R]')) !


"August 23, 2009 -> 19:50:58"!

Delta define: #BlockWithFiveArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra), (A5 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, ^R]')) !


"August 23, 2009 -> 19:50:58"!

Delta define: #BlockWithFiveArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra), (A5 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, ^R]')) !


"August 23, 2009 -> 19:50:58"!

Delta define: #BlockWithFiveArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra), (A5 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, ^R]')) !


"August 23, 2009 -> 19:50:58"!

Delta define: #BlockWithFiveArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra), (A5 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, ^R]')) !


"August 23, 2009 -> 19:50:58"!

Delta define: #BlockWithFiveArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra), (A5 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, ^R]')) !


"August 23, 2009 -> 19:50:58"!

Delta define: #BlockWithFiveArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra), (A5 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, ^R]')) !


"August 23, 2009 -> 19:50:58"!

Delta define: #BlockWithFiveArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra), (A5 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, ^R]')) !


"August 23, 2009 -> 19:50:58"!

(Delta mirrorFor: #BlockWithFiveArguments)
comment: 
'(c) 1996-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.2 $'!


"August 23, 2009 -> 19:50:58"!

! (Delta mirrorFor: #BlockWithFiveArguments) methodsFor: 'arity' !
arity ^ <Integer>
	^5! !

"August 23, 2009 -> 19:50:58"!

! (Delta mirrorFor: #BlockWithFiveArguments) methodsFor: 'evaluating' !
value: arg1 <A1> value: arg2 <A2> value: arg3 <A3> value: arg4 <A4> value: arg5 <A5>
    "Block dispatch method (vm generated)"
    ^{{self primitiveValue: arg1 value: arg2 value: arg3 value: arg4 value: arg5}}! !

"August 23, 2009 -> 19:50:58"!

! (Delta mirrorFor: #BlockWithFiveArguments) methodsFor: 'evaluating' !
valueWithArguments: a <Array[Object]> ^ <R>
	self validateValues: a.
	^self value: (a at: 1) value: (a at: 2) value: (a at: 3)
			value: (a at: 4) value: (a at: 5)! !

"August 23, 2009 -> 19:51:4"!

Delta define: #BlockWithFourArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, ^R]')) !


"August 23, 2009 -> 19:51:4"!

Delta define: #BlockWithFourArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, ^R]')) !


"August 23, 2009 -> 19:51:4"!

Delta define: #BlockWithFourArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, ^R]')) !


"August 23, 2009 -> 19:51:4"!

Delta define: #BlockWithFourArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, ^R]')) !


"August 23, 2009 -> 19:51:4"!

Delta define: #BlockWithFourArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, ^R]')) !


"August 23, 2009 -> 19:51:4"!

Delta define: #BlockWithFourArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, ^R]')) !


"August 23, 2009 -> 19:51:4"!

Delta define: #BlockWithFourArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, ^R]')) !


"August 23, 2009 -> 19:51:4"!

Delta define: #BlockWithFourArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, ^R]')) !


"August 23, 2009 -> 19:51:4"!

Delta define: #BlockWithFourArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, ^R]')) !


"August 23, 2009 -> 19:51:4"!

Delta define: #BlockWithFourArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, ^R]')) !


"August 23, 2009 -> 19:51:4"!

Delta define: #BlockWithFourArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, ^R]')) !


"August 23, 2009 -> 19:51:4"!

Delta define: #BlockWithFourArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, ^R]')) !


"August 23, 2009 -> 19:51:5"!

(Delta mirrorFor: #BlockWithFourArguments)
comment: 
'(c) 1996-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.2 $'!


"August 23, 2009 -> 19:51:5"!

! (Delta mirrorFor: #BlockWithFourArguments) methodsFor: 'arity' !
arity ^ <Integer>
	^4! !

"August 23, 2009 -> 19:51:5"!

! (Delta mirrorFor: #BlockWithFourArguments) methodsFor: 'evaluating' !
value: arg1 <A1> value: arg2 <A2> value: arg3 <A3> value: arg4 <A4>

    "Block dispatch method (vm generated)"
    ^{{self primitiveValue: arg1 value: arg2 value: arg3 value: arg4}}! !

"August 23, 2009 -> 19:51:5"!

! (Delta mirrorFor: #BlockWithFourArguments) methodsFor: 'evaluating' !
valueWithArguments: a <Array[Object]> ^ <R>
	self validateValues: a.
	^self value: (a at: 1) value: (a at: 2) value: (a at: 3)
			value: (a at: 4)! !

"August 23, 2009 -> 19:51:24"!

Delta define: #BlockWithNineArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra), (A9 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, A9, ^R]')) !


"August 23, 2009 -> 19:51:24"!

Delta define: #BlockWithNineArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra), (A9 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, A9, ^R]')) !


"August 23, 2009 -> 19:51:24"!

Delta define: #BlockWithNineArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra), (A9 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, A9, ^R]')) !


"August 23, 2009 -> 19:51:24"!

Delta define: #BlockWithNineArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra), (A9 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, A9, ^R]')) !


"August 23, 2009 -> 19:51:24"!

Delta define: #BlockWithNineArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra), (A9 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, A9, ^R]')) !


"August 23, 2009 -> 19:51:24"!

Delta define: #BlockWithNineArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra), (A9 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, A9, ^R]')) !


"August 23, 2009 -> 19:51:24"!

Delta define: #BlockWithNineArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra), (A9 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, A9, ^R]')) !


"August 23, 2009 -> 19:51:24"!

Delta define: #BlockWithNineArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra), (A9 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, A9, ^R]')) !


"August 23, 2009 -> 19:51:24"!

Delta define: #BlockWithNineArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra), (A9 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, A9, ^R]')) !


"August 23, 2009 -> 19:51:24"!

Delta define: #BlockWithNineArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra), (A9 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, A9, ^R]')) !


"August 23, 2009 -> 19:51:24"!

Delta define: #BlockWithNineArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra), (A9 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, A9, ^R]')) !


"August 23, 2009 -> 19:51:24"!

Delta define: #BlockWithNineArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra), (A9 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, A9, ^R]')) !


"August 23, 2009 -> 19:51:24"!

(Delta mirrorFor: #BlockWithNineArguments)
comment: 
'(c) 1996-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.2 $'!


"August 23, 2009 -> 19:51:24"!

! (Delta mirrorFor: #BlockWithNineArguments) methodsFor: 'arity' !
arity ^ <Integer>
	^9! !

"August 23, 2009 -> 19:51:24"!

! (Delta mirrorFor: #BlockWithNineArguments) methodsFor: 'evaluating' !
value: arg1 <A1> value: arg2 <A2> value: arg3 <A3> value: arg4 <A4> value: arg5 <A5> value: arg6 <A6> value: arg7 <A7> value: arg8 <A8> value: arg9 <A9>
    "Block dispatch method (vm generated)"
    ^{{self primitiveValue: arg1 value: arg2 value: arg3 value: arg4 value: arg5 value: arg6 value: arg7 value: arg8 value: arg9}}! !

"August 23, 2009 -> 19:51:24"!

! (Delta mirrorFor: #BlockWithNineArguments) methodsFor: 'evaluating' !
valueWithArguments: a <Array[Object]> ^ <R>
	self validateValues: a.
	^self value: (a at: 1) value: (a at: 2) value: (a at: 3)
			value: (a at: 4) value: (a at: 5) value: (a at: 6) 
			value: (a at: 7) value: (a at: 8) value: (a at: 9)! !

"August 23, 2009 -> 19:51:31"!

Delta define: #BlockWithOneArgument as: (
Generic forAll: '(A1 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, ^R]')) !


"August 23, 2009 -> 19:51:31"!

Delta define: #BlockWithOneArgument as: (
Generic forAll: '(A1 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, ^R]')) !


"August 23, 2009 -> 19:51:31"!

Delta define: #BlockWithOneArgument as: (
Generic forAll: '(A1 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, ^R]')) !


"August 23, 2009 -> 19:51:31"!

Delta define: #BlockWithOneArgument as: (
Generic forAll: '(A1 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, ^R]')) !


"August 23, 2009 -> 19:51:31"!

Delta define: #BlockWithOneArgument as: (
Generic forAll: '(A1 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, ^R]')) !


"August 23, 2009 -> 19:51:31"!

Delta define: #BlockWithOneArgument as: (
Generic forAll: '(A1 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, ^R]')) !


"August 23, 2009 -> 19:51:31"!

Delta define: #BlockWithOneArgument as: (
Generic forAll: '(A1 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, ^R]')) !


"August 23, 2009 -> 19:51:31"!

Delta define: #BlockWithOneArgument as: (
Generic forAll: '(A1 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, ^R]')) !


"August 23, 2009 -> 19:51:31"!

Delta define: #BlockWithOneArgument as: (
Generic forAll: '(A1 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, ^R]')) !


"August 23, 2009 -> 19:51:31"!

Delta define: #BlockWithOneArgument as: (
Generic forAll: '(A1 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, ^R]')) !


"August 23, 2009 -> 19:51:31"!

Delta define: #BlockWithOneArgument as: (
Generic forAll: '(A1 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, ^R]')) !


"August 23, 2009 -> 19:51:31"!

Delta define: #BlockWithOneArgument as: (
Generic forAll: '(A1 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, ^R]')) !


"August 23, 2009 -> 19:51:31"!

(Delta mirrorFor: #BlockWithOneArgument)
comment: 
'(c) 1996-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.2 $'!


"August 23, 2009 -> 19:51:31"!

! (Delta mirrorFor: #BlockWithOneArgument) methodsFor: 'arity' !
arity ^ <Integer>
	^1! !

"August 23, 2009 -> 19:51:31"!

! (Delta mirrorFor: #BlockWithOneArgument) methodsFor: 'evaluating' !
value: arg1 <A1>
    "Block dispatch method (vm generated)"
    ^{{self primitiveValue: arg1}}! !

"August 23, 2009 -> 19:51:31"!

! (Delta mirrorFor: #BlockWithOneArgument) methodsFor: 'evaluating' !
valueWithArguments: a <Array[Object]> ^ <R>
	self validateValues: a.
	^self value: a first! !

"August 23, 2009 -> 19:51:37"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"August 23, 2009 -> 19:51:37"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"August 23, 2009 -> 19:51:37"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"August 23, 2009 -> 19:51:37"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"August 23, 2009 -> 19:51:37"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"August 23, 2009 -> 19:51:37"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"August 23, 2009 -> 19:51:37"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"August 23, 2009 -> 19:51:37"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"August 23, 2009 -> 19:51:37"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"August 23, 2009 -> 19:51:37"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"August 23, 2009 -> 19:51:37"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"August 23, 2009 -> 19:51:37"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"August 23, 2009 -> 19:51:37"!

(Delta mirrorFor: #BlockWithoutArguments)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.4 $
'!


"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) classSide methodsFor: 'testing' !
test

	| v <Boolean> |
	
	[ v := false ] ensure: [ v := true ].
	self assert: [ v ].

	[ v := false ] ifCurtailed: [ v := true ].
	self assert: [ v not ].

	self testForUnwind: [ v := false ] onUnwind: [ v := true ].
	self assert: [ v ].

	self testForEnsure: [ v := false ] onUnwind: [ v := true ].
	self assert: [ v ]! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) classSide methodsFor: 'testing' !
testForEnsure: b <[]> onUnwind: b2 <[]> ^<Object>

	[ ^b value ] ensure: b2! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) classSide methodsFor: 'testing' !
testForUnwind: b <[]> onUnwind: b2 <[]> ^<Object>

	[ ^b value ] ifCurtailed: b2! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'Camp Smalltalk' !
sunitEnsure: aBlock
 
        ^self ensure: aBlock! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'Camp Smalltalk' !
sunitOn: anException do: aHandlerBlock
 
        ^self on: anException do: aHandlerBlock! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'arity' !
arity ^ <Integer>
	^0! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
critical ^<R>
	"This is used for very short, fast critical regions where the overhead or inconvenience
	  of a semaphore is not desired.  The argument is evaluated without any process context
	  switches taking place, so that it can perform atomic operations.  WARNING: the blk MUST
	  NOT do anything that might cause the process to block, such as any kind of I/O.  This
	  method is only appropriate for very fast atomic operations that are extremely reliable, since
	  no other processes will get a chance to run while it is being evaluated, and if it crashes,
	  it will not be debuggable, since the development & debugger processes will not be able to run."

	"%todo: implement this right.  NOTE: an interesting semantic idea: we could dramatically improve
	  the usefulnes of this if it was a critical region on the receiver, not on the system as a whole."

	^self value! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
ensure: f <[]> ^<R>

	"Use the following impl when vm bug fixed"
	"[ ^self value ] ifCurtailed: f"

	| result <R> |
	[ result := self value ] ifCurtailed: f.
	f value.
	^result! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
fork ^<Process>

	^self forkAt: Processor activePriority! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
forkAt: priority <Int> ^<Process>

	^self newProcess priority: priority; resume! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
ifCurtailed: protect <[]> ^<R>

	^guaranteed <R>
		  {{self primitiveUnwindProtect: protect
				ifFail: [ :err <Symbol> |	self shouldNotHappen ]
		  }}
! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
newProcess ^<Process>

	^Process for: self! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
profile

	Profiler do: self! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
repeat ^<BottomType>

	[ true ] whileTrue: [ self value ].
	self shouldNotHappen.! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
time ^<Int>

	^Time millisecondsToRun: self! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
userTime ^<Int>

	^Time userMillisecondsToRun: self! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
value ^<R>

    ^{{self primitiveValue}}! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
valueIfFail: fail <[^X def]>  ^<R | X>

	^self value! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
valueWithArguments: a <Array[Object]> ^ <R>
	self validateValues: a.
	^self value! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
verify
	"Evaluate the receiver, and generate an error if it does not return true.  This is different than
	  Object>>#assert: in that 1) it is a boolean block message, and 2) it ALWAYS evaluates, whereas
	  #assert: does not guarantee that it will evaluate the predicate.

	  Use verify in situations where you must ensure that the test is performed, for example when there
	  are side-effects that must take place, or if it is testing code that should always be performed.

	  Note that this message is only valid for blocks that return boolean values."

	"Note: we don't use self as the receiver for #error: below because it will currently
		prevent the block from being optimized away by the inliner"
	self value
		ifFalse: [ BlockWithoutArguments[Object] error: 'Assertion failed' ].

	"%hack %todo: remove this when compiler bug fixed"
	^nil! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
verify: message
	"Evaluate the receiver, and generate an error if it does not return true.  This is different than
	  Object>>#assert: in that 1) it is a boolean block message, and 2) it ALWAYS evaluates, whereas
	  #assert: does not guarantee that it will evaluate the predicate.

	  Use verify in situations where you must ensure that the test is performed, for example when there
	  are side-effects that must take place, or if it is testing code that should always be performed.

	  Note that this message is only valid for blocks that return boolean values."

	"Note: we don't use self as the receiver for #error: below because it will currently
		prevent the block from being optimized away by the inliner"
	self value
		ifFalse: [ BlockWithoutArguments[Object] error: 'Assertion failed: ', message ].

	"%hack %todo: remove this when compiler bug fixed"
	^nil! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
whileFalse ^<Object>

	^self whileFalse: []! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
whileFalse: blk <[]> ^<Object>

	"We can guarantee that self value is a Boolean in typesafe programs because the typechecker removes this
		  message from the protocol of blocks that don't return Booleans"
	(guaranteed <Boolean> (self value))
		ifFalse: [	blk value.
					[ (guaranteed <Boolean> (self value)) ]
						whileFalse: [ blk value ]	].
	^nil! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
whileTrue ^<Object>

	^self whileTrue: []! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
whileTrue: blk <[]> ^<Object>

	"We can guarantee that self value is a Boolean in typesafe programs because the typechecker removes this
		  message from the protocol of blocks that don't return Booleans"


	(guaranteed <Boolean> (self value))
		ifTrue: [	blk value.
					[ (guaranteed <Boolean> (self value)) ]
						whileTrue: [ blk value ]	].

	^nil! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'exceptions' !
on: exception do: handlerBlock

	^(LinkedExceptionHandler
		on: exception
		do: handlerBlock
		return: [:value | ^ value]) protect: self
! !

"August 23, 2009 -> 19:51:44"!

Delta define: #BlockWithSevenArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, ^R]')) !


"August 23, 2009 -> 19:51:44"!

Delta define: #BlockWithSevenArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, ^R]')) !


"August 23, 2009 -> 19:51:44"!

Delta define: #BlockWithSevenArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, ^R]')) !


"August 23, 2009 -> 19:51:44"!

Delta define: #BlockWithSevenArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, ^R]')) !


"August 23, 2009 -> 19:51:44"!

Delta define: #BlockWithSevenArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, ^R]')) !


"August 23, 2009 -> 19:51:44"!

Delta define: #BlockWithSevenArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, ^R]')) !


"August 23, 2009 -> 19:51:44"!

Delta define: #BlockWithSevenArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, ^R]')) !


"August 23, 2009 -> 19:51:44"!

Delta define: #BlockWithSevenArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, ^R]')) !


"August 23, 2009 -> 19:51:44"!

Delta define: #BlockWithSevenArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, ^R]')) !


"August 23, 2009 -> 19:51:44"!

Delta define: #BlockWithSevenArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, ^R]')) !


"August 23, 2009 -> 19:51:44"!

Delta define: #BlockWithSevenArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, ^R]')) !


"August 23, 2009 -> 19:51:44"!

Delta define: #BlockWithSevenArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, ^R]')) !


"August 23, 2009 -> 19:51:44"!

(Delta mirrorFor: #BlockWithSevenArguments)
comment: 
'(c) 1996-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.2 $'!


"August 23, 2009 -> 19:51:44"!

! (Delta mirrorFor: #BlockWithSevenArguments) methodsFor: 'arity' !
arity ^ <Integer>
	^7! !

"August 23, 2009 -> 19:51:44"!

! (Delta mirrorFor: #BlockWithSevenArguments) methodsFor: 'evaluating' !
value: arg1 <A1> value: arg2 <A2> value: arg3 <A3> value: arg4 <A4> value: arg5 <A5> value: arg6 <A6> value: arg7 <A7>
    "Block dispatch method (vm generated)"
    ^{{self primitiveValue: arg1 value: arg2 value: arg3 value: arg4 value: arg5 value: arg6 value: arg7}}! !

"August 23, 2009 -> 19:51:44"!

! (Delta mirrorFor: #BlockWithSevenArguments) methodsFor: 'evaluating' !
valueWithArguments: a <Array[Object]> ^ <R>
	self validateValues: a.
	^self value: (a at: 1) value: (a at: 2) value: (a at: 3)
			value: (a at: 4) value: (a at: 5) value: (a at: 6) 
			value: (a at: 7)! !

"August 23, 2009 -> 19:51:52"!

Delta define: #BlockWithSixArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, ^R]')) !


"August 23, 2009 -> 19:51:52"!

Delta define: #BlockWithSixArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, ^R]')) !


"August 23, 2009 -> 19:51:52"!

Delta define: #BlockWithSixArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, ^R]')) !


"August 23, 2009 -> 19:51:52"!

Delta define: #BlockWithSixArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, ^R]')) !


"August 23, 2009 -> 19:51:52"!

Delta define: #BlockWithSixArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, ^R]')) !


"August 23, 2009 -> 19:51:52"!

Delta define: #BlockWithSixArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, ^R]')) !


"August 23, 2009 -> 19:51:52"!

Delta define: #BlockWithSixArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, ^R]')) !


"August 23, 2009 -> 19:51:52"!

Delta define: #BlockWithSixArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, ^R]')) !


"August 23, 2009 -> 19:51:52"!

Delta define: #BlockWithSixArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, ^R]')) !


"August 23, 2009 -> 19:51:52"!

Delta define: #BlockWithSixArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, ^R]')) !


"August 23, 2009 -> 19:51:52"!

Delta define: #BlockWithSixArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, ^R]')) !


"August 23, 2009 -> 19:51:52"!

Delta define: #BlockWithSixArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, ^R]')) !


"August 23, 2009 -> 19:51:52"!

(Delta mirrorFor: #BlockWithSixArguments)
comment: 
'(c) 1996-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.2 $'!


"August 23, 2009 -> 19:51:52"!

! (Delta mirrorFor: #BlockWithSixArguments) methodsFor: 'arity' !
arity ^ <Integer>
	^6! !

"August 23, 2009 -> 19:51:52"!

! (Delta mirrorFor: #BlockWithSixArguments) methodsFor: 'evaluating' !
value: arg1 <A1> value: arg2 <A2> value: arg3 <A3> value: arg4 <A4> value: arg5 <A5> value: arg6 <A6>
    "Block dispatch method (vm generated)"
    ^{{self primitiveValue: arg1 value: arg2 value: arg3 value: arg4 value: arg5 value: arg6}}! !

"August 23, 2009 -> 19:51:52"!

! (Delta mirrorFor: #BlockWithSixArguments) methodsFor: 'evaluating' !
valueWithArguments: a <Array[Object]> ^ <R>
	self validateValues: a.
	^self value: (a at: 1) value: (a at: 2) value: (a at: 3)
			value: (a at: 4) value: (a at: 5) value: (a at: 6)! !

"August 23, 2009 -> 19:51:58"!

Delta define: #BlockWithThreeArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, ^R]')) !


"August 23, 2009 -> 19:51:58"!

Delta define: #BlockWithThreeArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, ^R]')) !


"August 23, 2009 -> 19:51:58"!

Delta define: #BlockWithThreeArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, ^R]')) !


"August 23, 2009 -> 19:51:58"!

Delta define: #BlockWithThreeArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, ^R]')) !


"August 23, 2009 -> 19:51:58"!

Delta define: #BlockWithThreeArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, ^R]')) !


"August 23, 2009 -> 19:51:58"!

Delta define: #BlockWithThreeArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, ^R]')) !


"August 23, 2009 -> 19:51:58"!

Delta define: #BlockWithThreeArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, ^R]')) !


"August 23, 2009 -> 19:51:58"!

Delta define: #BlockWithThreeArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, ^R]')) !


"August 23, 2009 -> 19:51:58"!

Delta define: #BlockWithThreeArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, ^R]')) !


"August 23, 2009 -> 19:51:58"!

Delta define: #BlockWithThreeArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, ^R]')) !


"August 23, 2009 -> 19:51:58"!

Delta define: #BlockWithThreeArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, ^R]')) !


"August 23, 2009 -> 19:51:58"!

Delta define: #BlockWithThreeArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, ^R]')) !


"August 23, 2009 -> 19:51:58"!

(Delta mirrorFor: #BlockWithThreeArguments)
comment: 
'(c) 1996-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.2 $'!


"August 23, 2009 -> 19:51:58"!

! (Delta mirrorFor: #BlockWithThreeArguments) methodsFor: 'arity' !
arity ^ <Integer>
	^3! !

"August 23, 2009 -> 19:51:58"!

! (Delta mirrorFor: #BlockWithThreeArguments) methodsFor: 'evaluating' !
value: arg1 <A1> value: arg2 <A2> value: arg3 <A3>
    "Block dispatch method (vm generated)"
    ^{{self primitiveValue: arg1 value: arg2 value: arg3}}! !

"August 23, 2009 -> 19:51:58"!

! (Delta mirrorFor: #BlockWithThreeArguments) methodsFor: 'evaluating' !
valueWithArguments: a <Array[Object]> ^ <R>
	self validateValues: a.
	^self value: (a at: 1) value: (a at: 2) value: (a at: 3)! !

"August 23, 2009 -> 19:52:4"!

Delta define: #BlockWithTwoArguments as: (
Generic forAll: '(A1 contra), (A2 contra) , (R covar)  ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, ^R]')) !


"August 23, 2009 -> 19:52:4"!

Delta define: #BlockWithTwoArguments as: (
Generic forAll: '(A1 contra), (A2 contra) , (R covar)  ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, ^R]')) !


"August 23, 2009 -> 19:52:4"!

Delta define: #BlockWithTwoArguments as: (
Generic forAll: '(A1 contra), (A2 contra) , (R covar)  ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, ^R]')) !


"August 23, 2009 -> 19:52:4"!

Delta define: #BlockWithTwoArguments as: (
Generic forAll: '(A1 contra), (A2 contra) , (R covar)  ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, ^R]')) !


"August 23, 2009 -> 19:52:4"!

Delta define: #BlockWithTwoArguments as: (
Generic forAll: '(A1 contra), (A2 contra) , (R covar)  ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, ^R]')) !


"August 23, 2009 -> 19:52:4"!

Delta define: #BlockWithTwoArguments as: (
Generic forAll: '(A1 contra), (A2 contra) , (R covar)  ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, ^R]')) !


"August 23, 2009 -> 19:52:4"!

Delta define: #BlockWithTwoArguments as: (
Generic forAll: '(A1 contra), (A2 contra) , (R covar)  ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, ^R]')) !


"August 23, 2009 -> 19:52:4"!

Delta define: #BlockWithTwoArguments as: (
Generic forAll: '(A1 contra), (A2 contra) , (R covar)  ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, ^R]')) !


"August 23, 2009 -> 19:52:4"!

Delta define: #BlockWithTwoArguments as: (
Generic forAll: '(A1 contra), (A2 contra) , (R covar)  ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, ^R]')) !


"August 23, 2009 -> 19:52:4"!

Delta define: #BlockWithTwoArguments as: (
Generic forAll: '(A1 contra), (A2 contra) , (R covar)  ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, ^R]')) !


"August 23, 2009 -> 19:52:4"!

Delta define: #BlockWithTwoArguments as: (
Generic forAll: '(A1 contra), (A2 contra) , (R covar)  ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, ^R]')) !


"August 23, 2009 -> 19:52:4"!

Delta define: #BlockWithTwoArguments as: (
Generic forAll: '(A1 contra), (A2 contra) , (R covar)  ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, ^R]')) !


"August 23, 2009 -> 19:52:4"!

(Delta mirrorFor: #BlockWithTwoArguments)
comment: 
'(c) 1996-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.2 $'!


"August 23, 2009 -> 19:52:4"!

! (Delta mirrorFor: #BlockWithTwoArguments) methodsFor: 'arity' !
arity ^ <Integer>
	^2! !

"August 23, 2009 -> 19:52:4"!

! (Delta mirrorFor: #BlockWithTwoArguments) methodsFor: 'evaluating' !
value: arg1 <A1> value: arg2 <A2>
    "Block dispatch method (vm generated)"
    ^{{self primitiveValue: arg1 value: arg2}}! !

"August 23, 2009 -> 19:52:4"!

! (Delta mirrorFor: #BlockWithTwoArguments) methodsFor: 'evaluating' !
valueWithArguments: a <Array[Object]> ^ <R>
	self validateValues: a.
	^self value: (a at: 1) value: (a at: 2)! !

"August 23, 2009 -> 19:52:39"!

"System saved" !
"August 23, 2009 -> 20:40:53"!

! (Delta mirrorFor: #Object) methodsFor: 'utility' !
value

	^self! !

"August 23, 2009 -> 20:40:59"!

"System saved" !
"August 29, 2009 -> 1:31:51"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedByteAt: index <Integer> ^<Integer>

	^{{self primitiveSignedByteAt: index
				ifFail: [:err| self error: 'Unable to get signed byte'] }}! !

"August 29, 2009 -> 1:31:51"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedByteAt: index <Integer> ^<Integer>

	^{{self primitiveAlienSignedByteAt: index
				ifFail: [:err| self error: 'Unable to get signed byte'] }}! !

"August 29, 2009 -> 1:31:51"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
new: size <Integer> ^ <X>

	^(self primitiveNew: size + 4)
		size: size;
		initialize! !

"August 29, 2009 -> 1:31:51"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
size: anInteger <Integer>

	{{self primitiveAlienSize: anInteger
				ifFail: [:err| self error: 'failed to set alien size: ', err] }}! !

"August 29, 2009 -> 1:31:51"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
size ^<Integer>

	^{{self primitiveAlienSizeifFail: [:err| self error: 'failed to get alien size: ', err] }}! !

"August 29, 2009 -> 1:31:51"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedByteAt: index <Integer> ^<Integer>

	^{{self primitiveSignedByteAt: index
				ifFail: [:err| self error: 'Unable to get signed byte'] }}! !

"August 29, 2009 -> 1:31:51"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedByteAt: index <Integer> ^<Integer>

	^{{self primitiveAlienSignedByteAt: index
				ifFail: [:err| self error: 'Unable to get signed byte'] }}! !

"August 29, 2009 -> 1:31:51"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
new: size <Integer> ^ <X>

	^(self primitiveNew: size + 4)
		size: size;
		initialize! !

"August 29, 2009 -> 1:31:51"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
size: anInteger <Integer>

	{{self primitiveAlienSize: anInteger
				ifFail: [:err| self error: 'failed to set alien size: ', err] }}! !

"August 29, 2009 -> 1:31:51"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
size ^<Integer>

	^{{self primitiveAlienSizeifFail: [:err| self error: 'failed to get alien size: ', err] }}! !

"August 29, 2009 -> 1:31:51"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
addressField ^<Integer>

	^{{ self primitiveAlienAddressIfFail: [:err| self error: 'failed to get address of alien ', err] }}! !

"August 29, 2009 -> 1:31:51"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
addressField: anInteger <Integer>

	^{{ self primitiveAlienAddress: anInteger
					ifFail: [:err| self error: 'failed to set address of alien ', err] }}! !

"August 29, 2009 -> 1:32:25"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
size ^<Integer>

	^{{self primitiveAlienSizeIfFail: [:err| self error: 'failed to get alien size: ', err] }}! !

"August 29, 2009 -> 1:34:23"!

"System saved" !
"August 29, 2009 -> 1:38:0"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedByteAt: index <Integer> ^<Integer>

	^{{self primitiveAlienSignedByteAt: index
				ifFail: [:err| self error: 'Unable to get signed byte ', err] }}! !

"August 29, 2009 -> 1:38:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedByteAt: index <Integer> put: byte <Integer> ^<Integer>

	^{{self primitiveAlienSignedByteAt: index
				put: byte
				ifFail: [:err| self error: 'Unable to set signed byte ', err] }}! !

"August 29, 2009 -> 1:39:41"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedLongAt: index <Integer> ^<Integer>

	^{{self primitiveAlienSignedLongAt: index
				ifFail: [:err| self error: 'Unable to get signed long ', err] }}! !

"August 29, 2009 -> 1:40:15"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedLongAt: index <Integer> put: long <Integer>^<Integer>

	^{{self primitiveAlienSignedLongAt: index
				put: long
				ifFail: [:err| self error: 'Unable to get signed long ', err] }}! !

"August 29, 2009 -> 1:43:19"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> ^<Integer>

	^{{self primitiveAlienSignedShortAt: index
				ifFail: [:err| self error: 'Unable to get signed short ', err] }}! !

"August 29, 2009 -> 1:43:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> put: short <Integer> ^<Integer>

	^{{self primitiveAlienSignedShortAt: index
				put: short
				ifFail: [:err| self error: 'Unable to set signed short ', err] }}! !

"August 29, 2009 -> 1:44:13"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> ^<Integer>

	^{{self primitiveAlienUnsignedShortAt: index
				ifFail: [:err| self error: 'Unable to get unsigned short ', err] }}! !

"August 29, 2009 -> 1:44:31"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> put: short <Integer>^<Integer>

	^{{self primitiveAlienUnsignedShortAt: index
				put: short
				ifFail: [:err| self error: 'Unable to set unsigned short ', err] }}! !

"August 29, 2009 -> 1:44:55"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedByteAt: index <Integer> ^<Integer>

	^{{self primitiveAlienUnsignedByteAt: index
				ifFail: [:err| self error: 'Unable to get unsigned byte ', err] }}! !

"August 29, 2009 -> 1:45:20"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedByteAt: index <Integer> put: byte <Integer> ^<Integer>

	^{{self primitiveAlienUnsignedByteAt: index
				put: byte
				ifFail: [:err| self error: 'Unable to set unsigned byte ', err] }}! !

"August 29, 2009 -> 1:45:37"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedLongAt: index <Integer> ^<Integer>

	^{{self primitiveAlienUnsignedLongAt: index
				ifFail: [:err| self error: 'Unable to get unsigned long ', err] }}! !

"August 29, 2009 -> 1:45:56"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedLongAt: index <Integer> put: long <Integer>^<Integer>

	^{{self primitiveAlienUnsignedLongAt: index
				put: long
				ifFail: [:err| self error: 'Unable to set unsigned long ', err] }}! !

"August 29, 2009 -> 1:51:49"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedByteIndexOutOfRange

	self should: [self signedByteAt: 0] raise: Error! !

"August 29, 2009 -> 1:52:12"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedByteIndexOutOfRange

	self should: [self signedByteAt: 0] raise: Error.
	self should: [self signedByteAt: 5] raise: Error! !

"August 29, 2009 -> 1:53:53"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedShortIndexOutOfRange

	self should: [self signedShortAt: 0] raise: Error.
	self should: [self signedShortAt: 4] raise: Error! !

"August 29, 2009 -> 1:54:31"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedShortIndexOutOfRange

	self should: [self signedShortAt: 0 put: 1] raise: Error.
	self should: [self signedShortAt: 4 put: 1] raise: Error.
	self should: [self signedShortAt: 0] raise: Error.
	self should: [self signedShortAt: 4] raise: Error! !

"August 29, 2009 -> 1:55:2"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedByteIndexOutOfRange

	self should: [self signedByteAt: 0] raise: Error.
	self should: [self signedByteAt: 5] raise: Error.
	self should: [self signedByteAt: 0 put: 1] raise: Error.
	self should: [self signedByteAt: 5 put: 1] raise: Error! !

"August 29, 2009 -> 1:55:42"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedLongIndexOutOfRange

	self should: [self signedLongAt: 0] raise: Error.
	self should: [self signedLongAt: 2] raise: Error.
	self should: [self signedLongAt: 0 put: 1] raise: Error.
	self should: [self signedLongAt: 2 put: 1] raise: Error! !

"August 29, 2009 -> 1:56:18"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedLongIndexOutOfRange

	self should: [self unsignedLongAt: 0] raise: Error.
	self should: [self unsignedLongAt: 2] raise: Error.
	self should: [self unsignedLongAt: 0 put: 1] raise: Error.
	self should: [self unsignedLongAt: 2 put: 1] raise: Error! !

"August 29, 2009 -> 1:57:8"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedShortIndexOutOfRange

	self should: [self unsignedShortAt: 0 put: 1] raise: Error.
	self should: [self unsignedShortAt: 4 put: 1] raise: Error.
	self should: [self unsignedShortAt: 0] raise: Error.
	self should: [self unsignedShortAt: 4] raise: Error! !

"August 29, 2009 -> 1:57:41"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedByteIndexOutOfRange

	self should: [self unsignedByteAt: 0] raise: Error.
	self should: [self unsignedByteAt: 5] raise: Error.
	self should: [self unsignedByteAt: 0 put: 1] raise: Error.
	self should: [self unsignedByteAt: 5 put: 1] raise: Error! !

"August 29, 2009 -> 2:5:10"!

"System saved" !
"August 29, 2009 -> 14:59:34"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
rawNewC: size <Integer> ^ <X>

	^(self primitiveNew: 8)
		size: size negated;
		addressField: (self Cmalloc: size);
		initialize! !

"August 29, 2009 -> 14:59:35"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
newGC: size <Integer> ^<X>

	| alien address |
	alien := self primitiveNew: 8.
	alien size: size negated.
	address := self Ccalloc: size.
	GCMallocedAliens add: alien finalizing: address.
	^alien
		addressField: address;
		initialize
		! !

"August 29, 2009 -> 14:59:37"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
newC: size <Integer> ^ <X>

	^(self primitiveNew: 8)
		size: size negated;
		addressField: (self Ccalloc: size);
		initialize! !

"August 29, 2009 -> 14:59:40"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
atAddress: pointer <Integer> dataSize: dataSize <Integer> ^<X>

	^(self primitiveNew: 8)
		size: dataSize negated;
		addressField: pointer;
		yourself! !

"August 29, 2009 -> 15:0:6"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
forPointer: pointer <Integer> ^<X>

	^(self primitiveNew: 8)
		size: 0;
		addressField: pointer;
		yourself! !

"August 29, 2009 -> 15:1:37"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
atAddress: pointer <Integer> ^<X>

	^(self primitiveNew: 8)
		size: self dataSize negated;
		addressField: pointer;
		yourself! !

"August 29, 2009 -> 15:2:27"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: '') classVariables: 'GCMallocedAliens LoadedLibraries') !


"August 29, 2009 -> 15:3:37"!

"System saved" !
"August 29, 2009 -> 15:4:16"!

Delta define: #DirectAlienTest as: (
(Class subclassOf: 'AlienTest' instanceVariables: '')) !


"August 29, 2009 -> 15:4:37"!

! (Delta mirrorFor: #DirectAlienTest) methodsFor: 'fixture' !
setUp

	alien := Alien new: 4! !

"August 29, 2009 -> 15:5:9"!

! (Delta mirrorFor: #AlienTest) classSide methodsFor: 'test case' !
isAbstract

	^self == AlienTest! !

"August 29, 2009 -> 15:5:26"!

(Delta mirrorFor: #AlienTest) removeMethod: #setUp ifAbsent: [] !


"August 29, 2009 -> 15:5:40"!

"System saved" !
"August 29, 2009 -> 15:6:33"!

Delta define: #IndirectAlienTest as: (
(Class subclassOf: 'AlienTest' instanceVariables: '')) !


"August 29, 2009 -> 15:6:59"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'fixture' !
setUp

	alien := Alien newC: 4! !

"August 29, 2009 -> 15:7:42"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'fixture' !
tearDown

	[alien free]
		on: Error
		do: [:ignore|]! !

"August 29, 2009 -> 15:8:18"!

"System saved" !
"August 29, 2009 -> 15:9:28"!

Delta define: #PointerAlienTest as: (
(Class subclassOf: 'AlienTest' instanceVariables: 'pointer')) !


"August 29, 2009 -> 15:9:28"!

Delta define: #PointerAlienTest as: (
(Class subclassOf: 'AlienTest' instanceVariables: 'pointer')) !


"August 29, 2009 -> 15:9:28"!

Delta define: #PointerAlienTest as: (
(Class subclassOf: 'AlienTest' instanceVariables: 'pointer')) !


"August 29, 2009 -> 15:9:28"!

Delta define: #PointerAlienTest as: (
(Class subclassOf: 'AlienTest' instanceVariables: 'pointer')) !


"August 29, 2009 -> 15:9:28"!

Delta define: #PointerAlienTest as: (
(Class subclassOf: 'AlienTest' instanceVariables: 'pointer')) !


"August 29, 2009 -> 15:9:28"!

Delta define: #PointerAlienTest as: (
(Class subclassOf: 'AlienTest' instanceVariables: 'pointer')) !


"August 29, 2009 -> 15:9:28"!

Delta define: #PointerAlienTest as: (
(Class subclassOf: 'AlienTest' instanceVariables: 'pointer')) !


"August 29, 2009 -> 15:9:28"!

Delta define: #PointerAlienTest as: (
(Class subclassOf: 'AlienTest' instanceVariables: 'pointer')) !


"August 29, 2009 -> 15:9:28"!

Delta define: #PointerAlienTest as: (
(Class subclassOf: 'AlienTest' instanceVariables: 'pointer')) !


"August 29, 2009 -> 15:9:28"!

Delta define: #PointerAlienTest as: (
(Class subclassOf: 'AlienTest' instanceVariables: 'pointer')) !


"August 29, 2009 -> 15:9:28"!

Delta define: #PointerAlienTest as: (
(Class subclassOf: 'AlienTest' instanceVariables: 'pointer')) !


"August 29, 2009 -> 15:9:43"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'fixture' !
setUp

	alien := pointer := Alien forPointer: (Alien Ccalloc: 4)! !

"August 29, 2009 -> 15:10:16"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'testing' !
testDataSize

	self assert: alien dataSize == 0! !

"August 29, 2009 -> 15:10:34"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'testing' !
testFreeingTwiceShouldFail

	alien free.
	self should: [alien free] raise: Error! !

"August 29, 2009 -> 15:10:41"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'testing' !
testIsPointer

	self assert: alien isPointer! !

"August 29, 2009 -> 15:10:49"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'fixture' !
tearDown

	[alien free]
		on: Error
		do: [:ignore|]! !

"August 29, 2009 -> 15:11:5"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'fixture' !
setUp

	alien := Alien forPointer: (Alien Ccalloc: 4)! !

"August 29, 2009 -> 15:11:13"!

Delta define: #PointerAlienTest as: (
(Class subclassOf: 'AlienTest' instanceVariables: '')) !


"August 29, 2009 -> 15:11:54"!

"System saved" !
"August 29, 2009 -> 15:27:19"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'fixture' !
dataSize

	^4! !

"August 29, 2009 -> 15:27:19"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'fixture' !
setUp

	alien := Alien newC: self dataSize! !

"August 29, 2009 -> 15:27:19"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'fixture' !
dataSize

	^4! !

"August 29, 2009 -> 15:27:20"!

! (Delta mirrorFor: #DirectAlienTest) methodsFor: 'fixture' !
setUp

	alien := Alien new: self dataSize! !

"August 29, 2009 -> 15:27:20"!

(Delta mirrorFor: #IndirectAlienTest) removeMethod: #dataSize ifAbsent: [] !


"August 29, 2009 -> 15:27:20"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'fixture' !
setUp

	alien := Alien forPointer: (Alien Ccalloc: self dataSize)! !

"August 29, 2009 -> 15:28:47"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'testing' !
testSignedByteIndexOutOfRange

	self should: [alien signedByteAt: 0] raise: Error.
	self should: [alien signedByteAt: 0 put: 1] raise: Error! !

"August 29, 2009 -> 15:29:12"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedByteIndexOutOfRange

	self should: [alien signedByteAt: 0] raise: Error.
	self should: [alien signedByteAt: 5] raise: Error.
	self should: [alien signedByteAt: 0 put: 1] raise: Error.
	self should: [alien signedByteAt: 5 put: 1] raise: Error! !

"August 29, 2009 -> 15:30:22"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'testing' !
testSignedLongIndexOutOfRange

	self should: [alien signedLongAt: 0] raise: Error.
	self should: [alien signedLongAt: 0 put: 1] raise: Error! !

"August 29, 2009 -> 15:30:42"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedLongIndexOutOfRange

	self should: [alien signedLongAt: 0] raise: Error.
	self should: [alien signedLongAt: 2] raise: Error.
	self should: [alien signedLongAt: 0 put: 1] raise: Error.
	self should: [alien signedLongAt: 2 put: 1] raise: Error! !

"August 29, 2009 -> 15:31:18"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'testing' !
testSignedShortIndexOutOfRange

	self should: [alien signedShortAt: 0 put: 1] raise: Error.
	self should: [alien signedShortAt: 0] raise: Error! !

"August 29, 2009 -> 15:31:47"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedShortIndexOutOfRange

	self should: [alien signedShortAt: 0 put: 1] raise: Error.
	self should: [alien signedShortAt: 4 put: 1] raise: Error.
	self should: [alien signedShortAt: 0] raise: Error.
	self should: [alien signedShortAt: 4] raise: Error! !

"August 29, 2009 -> 15:32:13"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'testing' !
testUnsignedByteIndexOutOfRange

	self should: [alien unsignedByteAt: 0] raise: Error.
	self should: [alien unsignedByteAt: 0 put: 1] raise: Error! !

"August 29, 2009 -> 15:32:32"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedByteIndexOutOfRange

	self should: [alien unsignedByteAt: 0] raise: Error.
	self should: [alien unsignedByteAt: 5] raise: Error.
	self should: [alien unsignedByteAt: 0 put: 1] raise: Error.
	self should: [alien unsignedByteAt: 5 put: 1] raise: Error! !

"August 29, 2009 -> 15:32:59"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'testing' !
testUnsignedLongIndexOutOfRange

	self should: [alien unsignedLongAt: 0] raise: Error.
	self should: [alien unsignedLongAt: 0 put: 1] raise: Error! !

"August 29, 2009 -> 15:33:21"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedLongIndexOutOfRange

	self should: [alien unsignedLongAt: 0] raise: Error.
	self should: [alien unsignedLongAt: 2] raise: Error.
	self should: [alien unsignedLongAt: 0 put: 1] raise: Error.
	self should: [alien unsignedLongAt: 2 put: 1] raise: Error! !

"August 29, 2009 -> 15:34:0"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'testing' !
testUnsignedShortIndexOutOfRange

	self should: [alien unsignedShortAt: 0 put: 1] raise: Error.
	self should: [alien unsignedShortAt: 0] raise: Error! !

"August 29, 2009 -> 15:34:39"!

"System saved" !
"August 29, 2009 -> 15:35:36"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedByteIndexOutOfRange

	self should: [alien signedByteAt: 0] raise: Error.
	self should: [alien signedByteAt: self dataSize + 1] raise: Error.
	self should: [alien signedByteAt: 0 put: 1] raise: Error.
	self should: [alien signedByteAt: self dataSize + 1 put: 1] raise: Error! !

"August 29, 2009 -> 15:35:55"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedByteIndexOutOfRange

	self should: [alien unsignedByteAt: 0] raise: Error.
	self should: [alien unsignedByteAt: self dataSize + 1] raise: Error.
	self should: [alien unsignedByteAt: 0 put: 1] raise: Error.
	self should: [alien unsignedByteAt: self dataSize + 1 put: 1] raise: Error! !

"August 29, 2009 -> 15:36:15"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedShortIndexOutOfRange

	self should: [self unsignedShortAt: 0 put: 1] raise: Error.
	self should: [self unsignedShortAt: self dataSize put: 1] raise: Error.
	self should: [self unsignedShortAt: 0] raise: Error.
	self should: [self unsignedShortAt: self dataSize] raise: Error! !

"August 29, 2009 -> 15:36:37"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedShortIndexOutOfRange

	self should: [alien signedShortAt: 0 put: 1] raise: Error.
	self should: [alien signedShortAt: self dataSize put: 1] raise: Error.
	self should: [alien signedShortAt: 0] raise: Error.
	self should: [alien signedShortAt: self dataSize] raise: Error! !

"August 29, 2009 -> 15:37:3"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedLongIndexOutOfRange

	self should: [alien unsignedLongAt: 0] raise: Error.
	self should: [alien unsignedLongAt: self dataSize - 3] raise: Error.
	self should: [alien unsignedLongAt: 0 put: 1] raise: Error.
	self should: [alien unsignedLongAt: self dataSize - 3 put: 1] raise: Error! !

"August 29, 2009 -> 15:37:16"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedLongIndexOutOfRange

	self should: [alien unsignedLongAt: 0] raise: Error.
	self should: [alien unsignedLongAt: self dataSize - 2] raise: Error.
	self should: [alien unsignedLongAt: 0 put: 1] raise: Error.
	self should: [alien unsignedLongAt: self dataSize - 2 put: 1] raise: Error! !

"August 29, 2009 -> 15:37:33"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedLongIndexOutOfRange

	self should: [alien signedLongAt: 0] raise: Error.
	self should: [alien signedLongAt: self dataSize - 2] raise: Error.
	self should: [alien signedLongAt: 0 put: 1] raise: Error.
	self should: [alien signedLongAt: self dataSize - 2 put: 1] raise: Error! !

"August 29, 2009 -> 15:38:3"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'fixture' !
dataSize

	^8! !

"August 29, 2009 -> 15:38:18"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testDataSize

	self assert: alien dataSize == self dataSize! !

"August 29, 2009 -> 15:39:11"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testDoubleAccess

	alien doubleAt: 1 put: 1.0! !

"August 29, 2009 -> 15:40:10"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
doubleAt: index <Integer> put: double <Float> ^<Integer>

	^{{self primitiveAlienDoubleAt: index
				put: double
				ifFail: [:err| self error: 'Unable to set double ', err] }}! !

"August 29, 2009 -> 15:40:45"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testDoubleAccess

	alien doubleAt: 1 put: 1.0.
	self assert: (alien doubleAt: 1) = 1.0! !

"August 29, 2009 -> 15:41:13"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
doubleAt: index <Integer> ^<Integer>

	^{{self primitiveAlienDoubleAt: index
				ifFail: [:err| self error: 'Unable to get double ', err] }}! !

"August 29, 2009 -> 15:41:43"!

"System saved" !
"August 29, 2009 -> 15:44:52"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testDoubleIndexOutOfRange

	self should: [alien doubleAt: 0 put: 1.0] raise: Error.
	self should: [alien doubleAt: 0] raise: Error! !

"August 29, 2009 -> 15:45:15"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'testing' !
testDoubleIndexOutOfRange

	self should: [alien doubleAt: 0 put: 1.0] raise: Error.
	self should: [alien doubleAt: 0] raise: Error! !

"August 29, 2009 -> 15:45:42"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testDoubleIndexOutOfRange

	self should: [alien doubleAt: 0 put: 1.0] raise: Error.
	self should: [alien doubleAt: self dataSize - 6 put: 1.0] raise: Error.
	self should: [alien doubleAt: 0] raise: Error! !

"August 29, 2009 -> 15:46:0"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testDoubleIndexOutOfRange

	self should: [alien doubleAt: 0 put: 1.0] raise: Error.
	self should: [alien doubleAt: self dataSize - 6 put: 1.0] raise: Error.
	self should: [alien doubleAt: self dataSize - 6] raise: Error.
	self should: [alien doubleAt: 0] raise: Error! !

"August 29, 2009 -> 15:47:37"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testFloatAccess

	alien floatAt: 1 put: 1.0.
	self assert: (alien floatAt: 1) = 1.0! !

"August 29, 2009 -> 15:48:3"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
floatAt: index <Integer> put: double <Float> ^<Integer>

	^{{self primitiveAlienFloatAt: index
				put: double
				ifFail: [:err| self error: 'Unable to set float ', err] }}! !

"August 29, 2009 -> 15:48:29"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
floatAt: index <Integer> ^<Double>

	^{{self primitiveAlienFloatAt: index
				ifFail: [:err| self error: 'Unable to get float ', err] }}! !

"August 29, 2009 -> 15:48:37"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
floatAt: index <Integer> put: double <Float> ^<Float>

	^{{self primitiveAlienFloatAt: index
				put: double
				ifFail: [:err| self error: 'Unable to set float ', err] }}! !

"August 29, 2009 -> 15:48:44"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
doubleAt: index <Integer> put: double <Float> ^<Float>

	^{{self primitiveAlienDoubleAt: index
				put: double
				ifFail: [:err| self error: 'Unable to set double ', err] }}! !

"August 29, 2009 -> 15:48:50"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
doubleAt: index <Integer> ^<Float>

	^{{self primitiveAlienDoubleAt: index
				ifFail: [:err| self error: 'Unable to get double ', err] }}! !

"August 29, 2009 -> 15:49:45"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testFloatAccess

	alien floatAt: 1 put: 1.0.
	self assert: (alien floatAt: 1) = 1.0.
	alien floatAt: 1 put: 1.23456.
	self assert: (alien floatAt: 1) = 1.23456! !

"August 29, 2009 -> 15:50:31"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testFloatAccess

	alien floatAt: 1 put: 1.0.
	self assert: (alien floatAt: 1) = 1.0.
	alien floatAt: 1 put: 1.23456.
	self assert: ((alien floatAt: 1) - 1.23456) abs < 0.000001! !

"August 29, 2009 -> 15:50:51"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testFloatAccess

	alien floatAt: 1 put: 1.0.
	self assert: (alien floatAt: 1) = 1.0.
	alien floatAt: 1 put: 1.23456.
	self assert: ((alien floatAt: 1) - 1.23456) abs < 0.0000001! !

"August 29, 2009 -> 15:50:56"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testFloatAccess

	alien floatAt: 1 put: 1.0.
	self assert: (alien floatAt: 1) = 1.0.
	alien floatAt: 1 put: 1.23456.
	self assert: ((alien floatAt: 1) - 1.23456) abs < 0.00000001! !

"August 29, 2009 -> 15:51:2"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testFloatAccess

	alien floatAt: 1 put: 1.0.
	self assert: (alien floatAt: 1) = 1.0.
	alien floatAt: 1 put: 1.23456.
	self assert: ((alien floatAt: 1) - 1.23456) abs < 0.0000001! !

"August 29, 2009 -> 15:51:32"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testDoubleAccess

	alien doubleAt: 1 put: 1.0.
	self assert: (alien doubleAt: 1) = 1.0.
	alien doubleAt: 1 put: 1.23456.
	self assert: ((alien doubleAt: 1) - 1.23456) abs < 0.0000001! !

"August 29, 2009 -> 15:51:41"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testDoubleAccess

	alien doubleAt: 1 put: 1.0.
	self assert: (alien doubleAt: 1) = 1.0.
	alien doubleAt: 1 put: 1.23456.
	self assert: ((alien doubleAt: 1) - 1.23456) abs < 0.00000000001! !

"August 29, 2009 -> 15:51:48"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testDoubleAccess

	alien doubleAt: 1 put: 1.0.
	self assert: (alien doubleAt: 1) = 1.0.
	alien doubleAt: 1 put: 1.23456.
	self assert: ((alien doubleAt: 1) - 1.23456) abs < 0.000000000001! !

"August 29, 2009 -> 15:52:25"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testFloatAccess

	alien floatAt: 1 put: 1.0.
	self assert: (alien floatAt: 1) = 1.0.
	alien floatAt: 1 put: 1.23456.
	self assert: ((alien floatAt: 1) - 1.23456) abs < 0.0000001.
	self deny: ((alien floatAt: 1) - 1.23456) abs < 0.00000001! !

"August 29, 2009 -> 15:53:8"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testFloatIndexOutOfRange

	self should: [alien doubleAt: 0 put: 1.0] raise: Error.
	self should: [alien doubleAt: self dataSize - 6 put: 1.0] raise: Error.
	self should: [alien doubleAt: self dataSize - 6] raise: Error.
	self should: [alien doubleAt: 0] raise: Error! !

"August 29, 2009 -> 15:53:30"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'testing' !
testFloatIndexOutOfRange

	self should: [alien doubleAt: 0 put: 1.0] raise: Error.
	self should: [alien doubleAt: 0] raise: Error! !

"August 29, 2009 -> 15:57:37"!

"System saved" !
"August 29, 2009 -> 19:35:22"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testFreeAfter

	|arg|
	alien freeAfter: [:buf| arg := buf].
	self assert: alien == arg! !

"August 29, 2009 -> 19:35:22"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
freeAfter: aBlock <[Alien]>

	[aBlock value: self]
		value! !

"August 29, 2009 -> 19:35:22"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testFreeAfter

	|arg|
	self deny: alien address == 0.
	alien freeAfter: [:buf| arg := buf].
	self assert: alien == arg! !

"August 29, 2009 -> 19:35:22"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testFreeAfter

	|arg|
	self deny: alien address == 0.
	alien freeAfter: [:buf| arg := buf].
	self assert: alien == arg.
	self assert: alien address == 0! !

"August 29, 2009 -> 19:35:22"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
freeAfter: aBlock <[Alien]>

	[aBlock value: self]
		ensure: [self free]! !

"August 29, 2009 -> 19:35:22"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testPointer

	|pointer|
	pointer := alien pointer.
	self assert: pointer address == alien address.
	self assert: pointer size == 0! !

"August 29, 2009 -> 19:35:22"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
pointer

	^self class forPointer: self address! !

"August 29, 2009 -> 19:35:22"!

! (Delta mirrorFor: #DirectAlienTest) methodsFor: 'testing' !
testPointer

	self should: [alien pointer] raise: Error! !

"August 29, 2009 -> 19:35:22"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'testing' !
testPointer

	self should: [alien pointer] raise: Error! !

"August 29, 2009 -> 19:35:22"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
pointer

	self isPointer ifTrue: [self error:  'One cannot take the address of pointer Alien instances; they may move, and are already pointers'].
	^self class forPointer: self address! !

"August 29, 2009 -> 19:35:22"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testReplaceFrom

	|replacement|
	replacement := '12345678'.
	alien replaceFrom: 1 to: self dataSize with: replacement startingAt: 1.
	1 to: self dataSize do: [:i|
		self assert: (replacement at: i) == (Character value: (alien unsignedByteAt: i))
			description: 'Wrong value at ', i printString]! !

"August 29, 2009 -> 19:35:22"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
replaceFrom: start <Integer> to: stop <Integer> with: replacement <Alien|IndexedByteInstanceVariables> startingAt: replacementStart <Integer> ^ <self>

	! !

"August 29, 2009 -> 19:35:22"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
replaceFrom: start <Integer>
to: stop <Integer>
with: replacement <Alien|IndexedByteInstanceVariables>
startingAt: replacementStart <Integer> ^ <self>

	! !

"August 29, 2009 -> 19:35:22"!

(Delta mirrorFor: #Alien) removeMethod: #replaceFrom:to:with:startingAt: ifAbsent: [] !


"August 29, 2009 -> 19:35:22"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testReplaceFrom

	|replacement|
	replacement := ByteArray with: 1 with: 2 with: 3.
	alien replaceFrom: 1 to: 3 with: replacement startingAt: 1.
	1 to: self dataSize do: [:i|
		self assert: (replacement at: i) == (alien unsignedByteAt: i)
			description: 'Wrong value at ', i printString]! !

"August 29, 2009 -> 19:35:22"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testReplaceFrom

	|replacement|
	replacement := ByteArray withAll: #(1 2 3).
	alien replaceFrom: 1 to: 3 with: replacement startingAt: 1.
	1 to: self dataSize do: [:i|
		self assert: (replacement at: i) == (alien unsignedByteAt: i)
			description: 'Wrong value at ', i printString]! !

"August 29, 2009 -> 19:35:22"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
at: index <Integer> put: byte <SmallInteger> ^ <SmallInteger>

	^self signedByteAt: index put: byte! !

"August 29, 2009 -> 19:35:22"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testReplaceFrom

	|replacement|
	replacement := ByteArray withAll: #(1 2 3).
	alien replaceFrom: 1 to: 3 with: replacement startingAt: 1.
	1 to: 3 do: [:i|
		self assert: (replacement at: i) == (alien unsignedByteAt: i)
			description: 'Wrong value at ', i printString]! !

"August 29, 2009 -> 19:35:22"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
at: index <Integer> ^ <SmallInteger>

	^self signedByteAt: index! !

"August 29, 2009 -> 19:35:22"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testReplaceFrom

	|replacement|
	replacement := ByteArray withAll: #(1 2 3).
	alien replaceFrom: 1 to: 3 with: replacement startingAt: 1.
	1 to: 3 do: [:i|
		self assert: (replacement at: i) == (alien at: i)
			description: 'Wrong value at ', i printString]! !

"August 29, 2009 -> 19:37:28"!

"System saved" !
"August 30, 2009 -> 20:44:41"!

! (Delta mirrorFor: #Character) classSide methodsFor: 'constants' !
null ^<Character>
	"carriage-return"

	"%note: There should be an entry for all constants in #constantNameIfNone:"

	^self value: 0! !

"August 30, 2009 -> 20:45:8"!

! (Delta mirrorFor: #Character) classSide methodsFor: 'constants' !
nul ^<Character>
	"carriage-return"

	"%note: There should be an entry for all constants in #constantNameIfNone:"

	^self value: 0! !

"August 30, 2009 -> 20:45:14"!

! (Delta mirrorFor: #Character) methodsFor: 'printing' !
constantNameIfNone: blk <[^Str]> ^<Str>

	self = Character cr
		ifTrue: [ ^'cr' ].
	self = Character formFeed
		ifTrue: [ ^'formFeed' ].
	self = Character lf
		ifTrue: [ ^'lf' ].
	self = Character space
		ifTrue: [ ^'space' ].
	self = Character tab
		ifTrue: [ ^'tab' ].
	self = Character nul
		ifTrue: [ ^'nul' ].
	^blk value! !

"August 30, 2009 -> 20:45:18"!

(Delta mirrorFor: #Character) classSide removeMethod: #null ifAbsent: [] !


"August 30, 2009 -> 20:47:33"!

"System saved" !
"August 30, 2009 -> 22:42:41"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testReplaceFrom

	|replacement|
	replacement := ByteArray withAll: #(1 2 255).
	alien replaceFrom: 1 to: 3 with: replacement startingAt: 1.
	1 to: 3 do: [:i|
		self assert: (replacement at: i) == (alien at: i)
			description: 'Wrong value at ', i printString]! !

"August 30, 2009 -> 22:42:41"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
at: index <Integer> put: byte <SmallInteger> ^ <SmallInteger>

	^self unsignedByteAt: index put: byte! !

"August 30, 2009 -> 22:42:41"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
at: index <Integer> ^ <SmallInteger>

	^self unsignedByteAt: index! !

"August 30, 2009 -> 22:42:41"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testReplaceFromToWithStartingAt

	|replacement|
	replacement := ByteArray withAll: #(1 2 255).
	alien replaceFrom: 1 to: 3 with: replacement startingAt: 1.
	1 to: 3 do: [:i|
		self assert: (replacement at: i) == (alien at: i)
			description: 'Wrong value at ', i printString]! !

"August 30, 2009 -> 22:42:41"!

(Delta mirrorFor: #IndirectAlienTest) removeMethod: #testReplaceFrom ifAbsent: [] !


"August 30, 2009 -> 22:42:41"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testReplaceFromToWithStartingAt

	|replacement|
	replacement := ByteArray withAll: #(1 2 255).
	
	alien replaceFrom: 1 to: 3 with: replacement startingAt: 1.
	1 to: 3 do: [:i|
		self assert: (replacement at: i) == (alien at: i)
			description: 'Wrong value at ', i printString].
			
	alien replaceFrom: 2 to: 4 with: replacement startingAt: 1.
	1 to: 3 do: [:i|
		self assert: (replacement at: i) == (alien at: i + 1)
			description: 'Wrong value at ', i printString].! !

"August 30, 2009 -> 22:42:41"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testReplaceFromToWithStartingAt

	|replacement|
	replacement := ByteArray withAll: #(1 2 255).
	
	alien replaceFrom: 1 to: 3 with: replacement startingAt: 1.
	1 to: 3 do: [:i|
		self assert: (replacement at: i) == (alien unsignedAt: i)
			description: 'Wrong value at ', i printString].
			
	alien replaceFrom: 2 to: 4 with: replacement startingAt: 1.
	1 to: 3 do: [:i|
		self assert: (replacement at: i) == (alien unsignedAt: i + 1)
			description: 'Wrong value at ', i printString].! !

"August 30, 2009 -> 22:42:41"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testReplaceFromToWithStartingAt

	|replacement|
	replacement := ByteArray withAll: #(1 2 255).
	
	alien replaceFrom: 1 to: 3 with: replacement startingAt: 1.
	1 to: 3 do: [:i|
		self assert: (replacement at: i) == (alien unsignedByteAt: i)
			description: 'Wrong value at ', i printString].
			
	alien replaceFrom: 2 to: 4 with: replacement startingAt: 1.
	1 to: 3 do: [:i|
		self assert: (replacement at: i) == (alien unsignedByteAt: i + 1)
			description: 'Wrong value at ', i printString].! !

"August 30, 2009 -> 22:42:41"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testReplaceFromToWithStartingAtWithSymbol

	|replacement|
	replacement := #'123'.
	
	alien replaceFrom: 1 to: 3 with: replacement startingAt: 1.
	1 to: 3 do: [:i|
		self assert: (replacement at: i) == (alien unsignedByteAt: i)
			description: 'Wrong value at ', i printString].
			
	alien replaceFrom: 2 to: 4 with: replacement startingAt: 1.
	1 to: 3 do: [:i|
		self assert: (replacement at: i) == (alien unsignedByteAt: i + 1)
			description: 'Wrong value at ', i printString].! !

"August 30, 2009 -> 22:42:41"!

Delta define: #CharacterTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 30, 2009 -> 22:42:41"!

! (Delta mirrorFor: #CharacterTest) methodsFor: 'testing' !
testIsCharacter

	self assert: $A isCharacter.
	self deny: 1 isCharacter! !

"August 30, 2009 -> 22:42:41"!

(Delta mirrorFor: #IndirectAlienTest) removeMethod: #testReplaceFromToWithStartingAtWithSymbol ifAbsent: [] !


"August 30, 2009 -> 22:42:41"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testReplaceFromToWithStartingAt

	|replacement|
	replacement := ByteArray withAll: #(1 2 255).
	
	alien replaceFrom: 1 to: 3 with: replacement startingAt: 1.
	1 to: 3 do: [:i|
		self assert: (replacement at: i) == (alien unsignedByteAt: i)
			description: 'Wrong value at ', i printString].
			
	alien replaceFrom: 2 to: 4 with: replacement startingAt: 1.
	1 to: 3 do: [:i|
		self assert: (replacement at: i) == (alien unsignedByteAt: i + 1)
			description: 'Wrong value at ', i printString].! !

"August 30, 2009 -> 22:42:41"!

(Delta mirrorFor: #IndirectAlienTest) removeMethod: #testReplaceFromToWithStartingAt ifAbsent: [] !


"August 30, 2009 -> 22:42:41"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testStrcpy

	|contents|
	contents := #'12345678'.
	alien replaceFrom: 1 to: 8 with: (contents collect: [:c| c asciiValue]) startingAt: 1.! !

"August 30, 2009 -> 22:42:41"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testStrcpy

	|contents|
	contents := #'12345678'.
	alien replaceFrom: 1 to: 8 with: (contents collect: [:c| c asciiValue]) startingAt: 1.
	self assert: (contents asString = alien strcpy)! !

"August 30, 2009 -> 22:42:41"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strcpy

	|string|
	string := String new: self size.
	1 to: self size do: [:i|
		string at: i put: (Character value: (self unsignedByteAt: i))].
	^string! !

"August 30, 2009 -> 22:42:41"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strcpy

	|string|
	string := String new: self dataSize.
	1 to: self dataSize do: [:i|
		string at: i put: (Character value: (self unsignedByteAt: i))].
	^string! !

"August 30, 2009 -> 22:42:41"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testStrcpy

	|contents|
	contents := #'12345678'.
	alien replaceFrom: 1 to: 8 with: (contents collect: [:c| c asciiValue]) startingAt: 1.
	self assert: (contents asString = alien strcpy)
	
	alien unsignedByteAt: 5 put: 0.
	self assert: (contents asString copyFrom: 1 to: 4) = alien strcpy! !

"August 30, 2009 -> 22:42:41"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testStrcpy

	|contents|
	contents := #'12345678'.
	alien replaceFrom: 1 to: 8 with: (contents collect: [:c| c asciiValue]) startingAt: 1.
	self assert: (contents asString = alien strcpy).
	
	alien unsignedByteAt: 5 put: 0.
	self assert: (contents asString copyFrom: 1 to: 4) = alien strcpy! !

"August 30, 2009 -> 22:42:41"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strlen

	1 to: self dataSize do: [:i|	(self unsignedByteAt: i) == 0 ifTrue: [^ i - 1]].
	^self dataSize! !

"August 30, 2009 -> 22:42:41"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strcpy

	|string|
	string := String new: self strlen.
	1 to: self strlen do: [:i|
		string at: i put: (Character value: (self unsignedByteAt: i))].
	^string! !

"August 30, 2009 -> 22:42:41"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strcpy

	|string length|
	length := self strlen.
	string := String new: length.
	1 to: length do: [:i|
		string at: i put: (Character value: (self unsignedByteAt: i))].
	^string! !

"August 30, 2009 -> 22:42:41"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testStrcpyFrom

	|contents shortContents|
	contents := '12345678'.
	shortContents := contents asString copyFrom: 5 to: 8.
	alien replaceFrom: 1 to: 8 with: (contents collect: [:c| c asciiValue]) startingAt: 1.
	self assert: shortContents asString = (alien strcpyFrom: 5)! !

"August 30, 2009 -> 22:42:41"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strlenFrom: startIndex

	startIndex to: self dataSize do: [:i|	(self unsignedByteAt: i) == 0 ifTrue: [^ i - startIndex]].
	^self dataSize - startIndex! !

"August 30, 2009 -> 22:42:41"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strcpyFrom: startIndex

	|string length offset|
	length := self strlenFrom: startIndex.
	string := String new: length.
	offset := startIndex - 1.
	1 to: length do: [:i|
		string at: i put: (Character value: (self unsignedByteAt: i + offset))].
	^string! !

"August 30, 2009 -> 22:42:42"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testStrcpyFrom

	|contents shortContents actual|
	contents := '12345678'.
	shortContents := contents asString copyFrom: 5 to: 8.
	alien replaceFrom: 1 to: 8 with: (contents collect: [:c| c asciiValue]) startingAt: 1.
	actual := alien strcpyFrom: 5.
	self assert: shortContents asString = actual
		description: 'Expected :''',shortContents, ''', but was: ''',actual,''''! !

"August 30, 2009 -> 22:42:42"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strlenFrom: startIndex

	startIndex to: self dataSize do: [:i|	(self unsignedByteAt: i) == 0 ifTrue: [^ i - startIndex]].
	^self dataSize - startIndex + 1! !

"August 30, 2009 -> 22:42:42"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strcpy

	^self strcpyFrom: 1! !

"August 30, 2009 -> 22:42:42"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strlenStartingAt: startIndex

	startIndex to: self dataSize do: [:i|	(self unsignedByteAt: i) == 0 ifTrue: [^ i - startIndex]].
	^self dataSize - startIndex + 1! !

"August 30, 2009 -> 22:42:42"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testStrlen

	|contents|
	contents := #'12345678'.
	alien replaceFrom: 1 to: 8 with: (contents collect: [:c| c asciiValue]) startingAt: 1.
	self assert: alien strlen = 8! !

"August 30, 2009 -> 22:42:42"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strlen

	^self strlenStartingAt: 1! !

"August 30, 2009 -> 22:42:42"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strcpyFrom: startIndex

	|string length offset|
	length := self strlenStartingAt: startIndex.
	string := String new: length.
	offset := startIndex - 1.
	1 to: length do: [:i|
		string at: i put: (Character value: (self unsignedByteAt: i + offset))].
	^string! !

"August 30, 2009 -> 22:42:42"!

(Delta mirrorFor: #Alien) removeMethod: #strlenFrom: ifAbsent: [] !


"August 30, 2009 -> 22:42:42"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'testing' !
testStrcpy

	|contents|
	contents := #'12345678'.
	alien replaceFrom: 1 to: 7 with: (contents collect: [:c| c asciiValue]) startingAt: 1.
	alien unsignedByteAt: 8 put: 0.
	self assert: (contents asString copyFrom: 1 to: 7) = alien strcpy! !

"August 30, 2009 -> 22:42:42"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'testing' !
testStrcpy

	|contents actual expected|
	contents := #'12345678'.
	alien replaceFrom: 1 to: 7 with: (contents collect: [:c| c asciiValue]) startingAt: 1.
	alien unsignedByteAt: 8 put: 0.
	
	actual := alien strcpy.
	expected := contents asString copyFrom: 1 to: 7.
	self assert: expected = actual
		description: 'Expected: ''',expected,''', but was: ''',actual,''''! !

"August 30, 2009 -> 22:42:42"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strlenStartingAt: startIndex

	self dataSize == 0
		ifTrue: [|count|
					count := 1.
					[(self unsignedByteAt: count) == 0]
						whileFalse: [count := count + 1].
					^count - 1].
	startIndex to: self dataSize do: [:i| (self unsignedByteAt: i) == 0
																ifTrue: [^ i - startIndex]].
	^self dataSize - startIndex + 1! !

"August 30, 2009 -> 22:42:42"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
rawStrlenStartingAt: startIndex

	|count|
	count := 1.
	[(self unsignedByteAt: count) == 0]
		whileFalse: [count := count + 1].
	^count - 1! !

"August 30, 2009 -> 22:42:42"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strlenStartingAt: startIndex

	self dataSize == 0
		ifTrue: [^self rawStrlenStartingAt: 1].
	startIndex to: self dataSize do: [:i| (self unsignedByteAt: i) == 0
																ifTrue: [^ i - startIndex]].
	^self dataSize - startIndex + 1! !

"August 30, 2009 -> 22:42:42"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'testing' !
testStrcpyFrom

	|contents actual expected|
	contents := #'12345678'.
	alien replaceFrom: 1 to: 7 with: (contents collect: [:c| c asciiValue]) startingAt: 1.
	alien unsignedByteAt: 8 put: 0.
	
	actual := alien strcpyFrom: 3.
	expected := contents asString copyFrom: 3 to: 7.
	self assert: expected = actual
		description: 'Expected: ''',expected,''', but was: ''',actual,''''! !

"August 30, 2009 -> 22:43:5"!

"System saved" !
"August 30, 2009 -> 23:3:22"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
rawStrlenStartingAt: startIndex

	|index|
	index := startIndex.
	[(self unsignedByteAt: index) == 0]
		whileFalse: [index := index + 1].
	^index - startIndex! !

"August 30, 2009 -> 23:11:58"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'testing' !
testStrcpyFrom

	|contents actual expected|
	self halt.
	contents := #'12345678'.
	alien replaceFrom: 1 to: 7 with: (contents collect: [:c| c asciiValue]) startingAt: 1.
	alien unsignedByteAt: 8 put: 0.
	
	actual := alien strcpyFrom: 3.
	expected := contents asString copyFrom: 3 to: 7.
	self assert: expected = actual
		description: 'Expected: ''',expected,''', but was: ''',actual,''''! !

"August 30, 2009 -> 23:11:59"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'testing' !
testStrcpy

	|contents actual expected|
	self halt.
	contents := #'12345678'.
	alien replaceFrom: 1 to: 7 with: (contents collect: [:c| c asciiValue]) startingAt: 1.
	alien unsignedByteAt: 8 put: 0.
	
	actual := alien strcpy.
	expected := contents asString copyFrom: 1 to: 7.
	self assert: expected = actual
		description: 'Expected: ''',expected,''', but was: ''',actual,''''! !

"August 30, 2009 -> 23:19:34"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strlenStartingAt: startIndex

	self dataSize == 0
		ifTrue: [^self rawStrlenStartingAt: startIndex].
	startIndex to: self dataSize do: [:i| (self unsignedByteAt: i) == 0
																ifTrue: [^ i - startIndex]].
	^self dataSize - startIndex + 1! !

"August 30, 2009 -> 23:19:41"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'testing' !
testStrcpy

	|contents actual expected|
	contents := #'12345678'.
	alien replaceFrom: 1 to: 7 with: (contents collect: [:c| c asciiValue]) startingAt: 1.
	alien unsignedByteAt: 8 put: 0.
	
	actual := alien strcpy.
	expected := contents asString copyFrom: 1 to: 7.
	self assert: expected = actual
		description: 'Expected: ''',expected,''', but was: ''',actual,''''! !

"August 30, 2009 -> 23:19:51"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'testing' !
testStrcpyFrom

	|contents actual expected|
	contents := #'12345678'.
	alien replaceFrom: 1 to: 7 with: (contents collect: [:c| c asciiValue]) startingAt: 1.
	alien unsignedByteAt: 8 put: 0.
	
	actual := alien strcpyFrom: 3.
	expected := contents asString copyFrom: 3 to: 7.
	self assert: expected = actual
		description: 'Expected: ''',expected,''', but was: ''',actual,''''! !

"August 31, 2009 -> 0:9:43"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testReplaceFromToWithStartingAtWithString

	|replacement|
	replacement := '1234'.
	
	alien replaceFrom: 1 to: 4 with: replacement startingAt: 1.
	self assert: replacement = alien strcpy! !

"August 31, 2009 -> 0:34:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedByteAt: index <Integer> put: byte <Integer> ^<Integer>

	|c|
	c := byte isCharacter
				ifTrue: [byte asciiValue]
				ifFalse: [byte].
	^{{self primitiveAlienUnsignedByteAt: index
				put: c
				ifFail: [:err| self error: 'Unable to set unsigned byte ', err] }}! !

"August 31, 2009 -> 0:34:37"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedByteAt: index <Integer> put: byte <Integer|Character> ^<Integer>

	|c|
	c := byte isCharacter
				ifTrue: [byte asciiValue]
				ifFalse: [byte].
	^{{self primitiveAlienUnsignedByteAt: index
				put: c
				ifFail: [:err| self error: 'Unable to set unsigned byte ', err] }}! !

"August 31, 2009 -> 0:42:7"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testStrcpyUTF8

	|replacement|
	replacement := '1234'.
	
	alien replaceFrom: 1 to: 4 with: replacement startingAt: 1.
	self should: [alien strcpyUTF8]
		raise: Error
		withExceptionDo: [:ex| self assert: 'A hook for unimplemented code has been encountered' = ex message]! !

"August 31, 2009 -> 0:43:21"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testStrcpyUTF8Unimplemented

	|replacement|
	replacement := '1234'.
	
	alien replaceFrom: 1 to: 4 with: replacement startingAt: 1.
	self should: [alien strcpyUTF8]
		raise: Error
		withExceptionDo: [:ex| self assert: 'A hook for unimplemented code has been encountered' = ex messageText]! !

"August 31, 2009 -> 0:43:24"!

(Delta mirrorFor: #AlienTest) removeMethod: #testStrcpyUTF8 ifAbsent: [] !


"August 31, 2009 -> 0:44:1"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strcpyUTF8

	^self unimplemented! !

"August 31, 2009 -> 0:44:21"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testStrcpyUTF8FromUnimplemented

	|replacement|
	replacement := '1234'.
	
	alien replaceFrom: 1 to: 4 with: replacement startingAt: 1.
	self should: [alien strcpyUTF8From: 1]
		raise: Error
		withExceptionDo: [:ex| self assert: 'A hook for unimplemented code has been encountered' = ex messageText]! !

"August 31, 2009 -> 0:44:33"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strcpyUTF8From: startIndex

	^self unimplemented! !

"August 31, 2009 -> 0:44:54"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strcpyUTF8

	^self strcpyFrom: 1! !

"August 31, 2009 -> 0:45:8"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strcpyUTF8

	^self strcpyUTF8From: 1! !

"August 31, 2009 -> 1:17:2"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testStrlenThroughPointerAt

	|contents|
	contents := '1234567'.
	alien replaceFrom: 1 to: 7 with: contents startingAt: 1.
	alien unsignedByteAt: 8 put: 0.
	(Alien newC: 4) freeAfter: [:pointer|
											pointer unsignedLongAt: 1 put: alien address.
											self assert: (pointer strlenThroughPointerAt: 1) == 7]! !

"August 31, 2009 -> 1:19:57"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
strlenThroughPointerAt: index

	^(Alien forPointer: (self unsignedLongAt: index))
		rawStrlenStartinAt: 1! !

"August 31, 2009 -> 1:20:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
strlenThroughPointerAt: index

	^(Alien forPointer: (self unsignedLongAt: index))
		rawStrlenStartingAt: 1! !

"August 31, 2009 -> 1:22:34"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testAutoFreeAfter

	|wasCalled|
	Alien autoFreeAfter: [:autoFree| wasCalled := true]! !

"August 31, 2009 -> 1:23:5"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testAutoFreeAfter

	|wasCalled|
	Alien autoFreeAfter: [:autoFree| wasCalled := true].
	self assert: wasCalled! !

"August 31, 2009 -> 1:24:51"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testAutoFreeAfter

	|wasCalled|
	Alien autoFreeAfter: [:autoFree|
									wasCalled := true.
									autoFree value: alien.
									self deny: alien address == 0].
	self assert: alien address == 0.
	self assert: wasCalled! !

"August 31, 2009 -> 1:25:50"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testAutoFreeAfter

	|wasCalled toFree|
	Alien autoFreeAfter: [:autoFree|
									wasCalled := true.
									autoFree value: alien.
									self deny: alien address == 0.
									autoFree value: (toFree := Alien newC:4).
									self deny: alien address == 0].
	self assert: alien address == 0.
	self assert: alien address == 0.
	self assert: wasCalled! !

"August 31, 2009 -> 1:33:13"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'testing' !
testNewCString

	(Alien newCString: '12345678')
		freeAfter: [:pointer|
							self assert: 8 = pointer strlen.
							self assert: '12345678' = pointer strcpy]! !

"August 31, 2009 -> 1:35:18"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
newCString: string <String> ^ <Alien>

	^(Alien rawNewC: string size + 1)
		replaceFrom: 1
		to: string size
		with: string
		startingAt: 1;
		unsignedByteAt: string size + 1 put: 0;
		yourself! !

"August 31, 2009 -> 1:40:39"!

Delta define: #AlienClassTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 31, 2009 -> 1:41:29"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testNewCString

	(Alien newCString: '12345678')
		freeAfter: [:pointer|
							self assert: 8 = pointer strlen.
							self assert: '12345678' = pointer strcpy]! !

"August 31, 2009 -> 1:41:40"!

(Delta mirrorFor: #PointerAlienTest) removeMethod: #testNewCString ifAbsent: [] !


"August 31, 2009 -> 1:48:46"!

! (Delta mirrorFor: #ExternalProxy) methodsFor: 'accessing' !
asInteger ^<Int>
	"Like asSmallInteger, but can be used on ExternalData, since integers support this also,
		and it will eventually produce large integers when necessary"

	"%todo: enhance to support largeintegers when needed"
	^(self high << 16 + self low)! !

"August 31, 2009 -> 1:49:56"!

! (Delta mirrorFor: #ExternalProxy) methodsFor: 'accessing' !
asInteger ^<Int>
	"Like asSmallInteger, but can be used on ExternalData, since integers support this also,
		and it will eventually produce large integers when necessary"

	"%todo: enhance to support largeintegers when needed"
	^((self high bitShift: 16) + self low)! !

"August 31, 2009 -> 1:50:25"!

! (Delta mirrorFor: #ExternalProxy) methodsFor: 'accessing' !
asInteger ^<Int>
	"Like asSmallInteger, but can be used on ExternalData, since integers support this also,
		and it will eventually produce large integers when necessary"

	"%todo: enhance to support largeintegers when needed"
	^((self high asLargeInteger bitShift: 16) + self low)! !

"August 31, 2009 -> 1:51:7"!

! (Delta mirrorFor: #ExternalProxy) methodsFor: 'accessing' !
asInteger ^<Int>
	"Like asSmallInteger, but can be used on ExternalData, since integers support this also,
		and it will eventually produce large integers when necessary"

	"%todo: enhance to support largeintegers when needed"
	^((self high * 65536) + self low)! !

"August 31, 2009 -> 1:56:6"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testEnsureLoadedWin32

	|library|
	Platform == Win32Platform ifFalse: [^self].
	(Alien ensureLoaded: 'USER32.DLL')
		autoFreeAfter: [:library| |proxy|
								proxy := Platform DLLLoad: 'user'.
								self assert: library asUnsignedLong = proxy asInteger]
								! !

"August 31, 2009 -> 2:0:23"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
ensureLoaded: libraryName

	|proxy|
	proxy := ExternalProxy new.
	{{primitiveDLLLoad: libraryName result: proxy ifFail: [:err|] }}.
	^(Alien new: 4)
			unsignedLongAt: 1 put: proxy asInteger;
			yourself! !

"August 31, 2009 -> 2:1:52"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testEnsureLoadedWin32

	|library proxy|
	Platform == Win32Platform ifFalse: [^self].
	proxy := Platform DLLLoad: 'user'.
	library := Alien ensureLoaded: 'USER32.DLL'.
	self assert: library asUnsignedLong = proxy asInteger
								! !

"August 31, 2009 -> 2:2:37"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testEnsureLoadedWin32

	|library proxy|
	Platform == Win32Platform ifFalse: [^self].
	proxy := Platform DLLLoad: 'user'.
	library := Alien ensureLoaded: 'USER32.DLL'.
	self assert: library asUnsignedLong = proxy asInteger.
	self assert: library == (Alien ensureLoaded: 'USER32.DLL')! !

"August 31, 2009 -> 2:4:3"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
ensureLoaded: libraryName

	^LoadedLibraries
		at: libraryName
		ifAbsentPut: [|proxy|
							proxy := ExternalProxy new.
							{{primitiveDLLLoad: libraryName result: proxy ifFail: [:err|] }}.
							(Alien new: 4)
								unsignedLongAt: 1 put: proxy asInteger;
								yourself]! !

"August 31, 2009 -> 2:16:11"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'private - accessing' !
loadedLibraries

	LoadedLibraries isNil ifTrue: 
		[LoadedLibraries := Dictionary new].
	^LoadedLibraries! !

"August 31, 2009 -> 2:16:26"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
ensureLoaded: libraryName

	^self loadedLibraries
		at: libraryName
		ifAbsentPut: [|proxy|
							proxy := ExternalProxy new.
							{{primitiveDLLLoad: libraryName result: proxy ifFail: [:err|] }}.
							(Alien new: 4)
								unsignedLongAt: 1 put: proxy asInteger;
								yourself]! !

"August 31, 2009 -> 2:19:34"!

Delta define: #DictionaryTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 31, 2009 -> 2:22:28"!

! (Delta mirrorFor: #DictionaryTest) methodsFor: 'testing' !
testAtIfAbsentPut

	|dict|
	dict := Dictionary new.
	self assert: (dict at: 'a' ifAbsent: []) isNil.
	self assert: (dict at: 'a'
							ifAbsentPut: ['b']) = 'b'.
	self assert: (dict at: 'a'
							ifAbsentPut: ['c']) = 'b'
	! !

"August 31, 2009 -> 2:24:13"!

! (Delta mirrorFor: #HashedCollection) methodsFor: 'accessing' !
at: key <K> ifAbsentPut: block <[^X def]> ^ <E|X>

	! !

"August 31, 2009 -> 2:25:17"!

! (Delta mirrorFor: #HashedCollection) methodsFor: 'accessing' !
at: key <K> ifAbsentPut: block <[^X def]> ^ <E|X>

	^self at: key ifAbsent: [self at: key put: block value]! !

"August 31, 2009 -> 2:28:47"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'private - test support' !
unimplementedText

	[self unimplemented]
		on: Error
		do: [:ex|^ex messageText]! !

"August 31, 2009 -> 2:29:10"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testNewGCUnimplemented

	self should: [Alien newGC: 4]
		raise: Error
		withExceptionDo: [:ex| self assert: self unimplementedText = ex messageText]! !

"August 31, 2009 -> 2:30:1"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
newGC: size <Integer> ^<X>

	| alien address |
	self unimplemented.
	alien := self primitiveNew: 8.
	alien size: size negated.
	address := self Ccalloc: size.
	GCMallocedAliens add: alien finalizing: address.
	^alien
		addressField: address;
		initialize
		! !

"August 31, 2009 -> 2:32:23"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testPrimLoadLibraryWin32

	|library proxy|
	Platform == Win32Platform ifFalse: [^self].
	proxy := Platform DLLLoad: 'user'.
	library := Alien primLoadLibrary: 'USER32.DLL'.
	self assert: library = proxy asInteger! !

"August 31, 2009 -> 2:33:14"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
primLoadLibrary: libraryName

	|proxy|
	proxy := ExternalProxy new.
	{{primitiveDLLLoad: libraryName result: proxy ifFail: [:err|] }}.
	^proxy asInteger! !

"August 31, 2009 -> 2:35:56"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
ensureLoaded: libraryName

	^self loadedLibraries
		at: libraryName
		ifAbsentPut: [(Alien new: 4)
								unsignedLongAt: 1 put: (self primLoadLibrary: libraryName);
								yourself]! !

"August 31, 2009 -> 2:44:45"!

Delta define: #AlienLibraryTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 31, 2009 -> 2:45:0"!

! (Delta mirrorFor: #AlienLibraryTest) methodsFor: 'fixture' !
setUp

	! !

"August 31, 2009 -> 2:45:12"!

Delta define: #AlienLibraryTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'library')) !


"August 31, 2009 -> 2:46:33"!

! (Delta mirrorFor: #AlienLibraryTest) methodsFor: 'fixture' !
setUp

	self ensureWin32Or: [^self].
	library := Alien ensureLoaded: 'msvcrt.dll'
	! !

"August 31, 2009 -> 2:47:8"!

! (Delta mirrorFor: #AlienLibraryTest) methodsFor: 'fixture' !
ensureWin32Or: block

	Platform == Win32Platform
		ifFalse: [block value]! !

"August 31, 2009 -> 2:51:3"!

! (Delta mirrorFor: #AlienLibraryTest) methodsFor: 'testing' !
testPrimFindSymbol

	self ensureWin32Or: [^self].
	! !

"August 31, 2009 -> 2:52:52"!

"System saved" !
"August 31, 2009 -> 2:54:43"!

Delta define: #AlienLibraryTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'library proxy')) !


"August 31, 2009 -> 3:3:13"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLMapName: name <Str> ^<Str>
    name = 'user'       ifTrue: [^'USER32.DLL'].
    name = 'gdi'            ifTrue: [^'GDI32.DLL'].
    name = 'kernel'     ifTrue: [^'KERNEL32.DLL'].
    name = 'comdlg'     ifTrue: [^'COMDLG32.DLL'].
    "self error: 'Mapping ', name, ' not found'"
    ^name! !

"August 31, 2009 -> 3:4:27"!

Delta define: #AlienLibraryTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'library proxy address')) !


"August 31, 2009 -> 3:4:48"!

! (Delta mirrorFor: #AlienLibraryTest) methodsFor: 'fixture' !
setUp

	self ensureWin32Or: [^self].
	library := Alien ensureLoaded: 'msvcrt.dll'! !

"August 31, 2009 -> 3:6:9"!

! (Delta mirrorFor: #AlienLibraryTest) methodsFor: 'testing' !
testPrimFindSymbol

	self ensureWin32Or: [^self].
	self assert: (library primFindSymbol: 'sprintf')
						= (Platform DLLLookup: 'sprintf' in: 'msvcrt.dll') asInteger! !

"August 31, 2009 -> 3:11:25"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
primFindSymbol: symbolName <String> ^ <Integer>

	|result library|
	result := ExternalProxy new.
	library := ExternalProxy
						forHigh: (self unsignedShortAt: 3)
						low: (self unsignedShortAt: 1).
	{{primitiveDLLLookup: symbolName asSymbol
			in: library
			result: result
			ifFail: [:err | self error: err]}}.
	^result asInteger	! !

"August 31, 2009 -> 3:12:29"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
asExternalProxy ^<ExternalProxy>

	^ExternalProxy
		forHigh: (self unsignedShortAt: 3)
		low: (self unsignedShortAt: 1)! !

"August 31, 2009 -> 3:15:23"!

Delta define: #NotFoundError as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"August 31, 2009 -> 3:15:55"!

! (Delta mirrorFor: #AlienLibraryTest) methodsFor: 'testing' !
testPrimFindSymbolUnknown

	self ensureWin32Or: [^self].
	self should: (library primFindSymbol: 'unknownSymbol')
			raise: NotFoundError! !

"August 31, 2009 -> 3:16:47"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
primFindSymbol: symbolName <String> ^ <Integer>

	|result library|
	result := ExternalProxy new.
	library := ExternalProxy
						forHigh: (self unsignedShortAt: 3)
						low: (self unsignedShortAt: 1).
	{{primitiveDLLLookup: symbolName asSymbol
			in: library
			result: result
			ifFail: [:err | err == #NotFound
									ifTrue: [NotFoundError signal]
									ifFalse: [self error: err]]}}.
	^result asInteger	! !

"August 31, 2009 -> 3:21:5"!

! (Delta mirrorFor: #Error) methodsFor: 'priv handling' !
defaultAction

	Processor stopWithError: (ProcessExplicitError new msg: messageText isNil ifTrue: [''] ifFalse: [messageText])! !

"August 31, 2009 -> 3:21:25"!

! (Delta mirrorFor: #Error) methodsFor: 'priv handling' !
defaultAction

	Processor stopWithError: (ProcessExplicitError new msg: (messageText isNil ifTrue: [''] ifFalse: [messageText]))! !

"August 31, 2009 -> 3:22:57"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
messageText
"Return an exception's message text."
	^messageText isNil
		ifTrue: ['']
		ifFalse: [messageText]
		! !

"August 31, 2009 -> 3:23:16"!

! (Delta mirrorFor: #Error) methodsFor: 'priv handling' !
defaultAction

	Processor stopWithError: (ProcessExplicitError new msg: self messageText)! !

"August 31, 2009 -> 3:23:37"!

! (Delta mirrorFor: #AlienLibraryTest) methodsFor: 'testing' !
testPrimFindSymbolUnknown

	self ensureWin32Or: [^self].
	self should: [library primFindSymbol: 'unknownSymbol']
			raise: NotFoundError! !

"August 31, 2009 -> 3:28:24"!

"System saved" !
"August 31, 2009 -> 20:10:27"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
primFindSymbol: symbolName <String> ^ <Integer>

	|result library|
	result := ExternalProxy new.
	library := self asExternalProxy.
	{{primitiveDLLLookup: symbolName asSymbol
			in: library
			result: result
			ifFail: [:err | err == #NotFound
									ifTrue: [NotFoundError signal]
									ifFalse: [self error: err]]}}.
	^result asInteger	! !

"August 31, 2009 -> 20:10:27"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testLookupInLibraryWin32

	|function proxy|
	Platform == Win32Platform ifFalse: [^self].
	proxy := Platform DLLLookup: 'sprintf' in: 'msvcrt.dll'.
	function := Alien lookup: 'sprintf' inLibrary: 'msvcrt.dll'.
	self assert: function asUnsignedInteger = proxy asInteger! !

"August 31, 2009 -> 20:10:27"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'libraries' !
lookup: symbolName <String> inLibrary: libraryName <String> ^ <Alien>

	^(Alien primLoadLibrary: libraryName)
		primFindSymbol: symbolName! !

"August 31, 2009 -> 20:10:28"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'libraries' !
lookup: symbolName <String> inLibrary: libraryName <String> ^ <Alien>

	^(Alien forPointer: (Alien primLoadLibrary: libraryName))
		primFindSymbol: symbolName! !

"August 31, 2009 -> 20:10:28"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'libraries' !
lookup: symbolName <String> inLibrary: libraryName <String> ^ <Alien>

	^Alien forPointer: ((Alien ensureLoaded: libraryName)
										primFindSymbol: symbolName)! !

"August 31, 2009 -> 20:10:28"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'libraries' !
lookup: symbolName <String> inLibrary: libraryName <String> ^ <Alien>

	^self forPointer: ((Alien ensureLoaded: libraryName)
										primFindSymbol: symbolName)! !

"August 31, 2009 -> 20:10:28"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testLookupInLibraryWin32

	|function proxy|
	Platform == Win32Platform ifFalse: [^self].
	proxy := Platform DLLLookup: 'sprintf' in: 'msvcrt.dll'.
	function := Alien lookup: 'sprintf' inLibrary: 'msvcrt.dll'.
	self assert: function asUnsignedLong = proxy asInteger! !

"August 31, 2009 -> 20:10:28"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testLookupInLibraryWin32

	|function proxy|
	Platform == Win32Platform ifFalse: [^self].
	proxy := Platform DLLLookup: 'sprintf' in: 'msvcrt.dll'.
	function := Alien lookup: 'sprintf' inLibrary: 'msvcrt.dll'.
	self assert: function address = proxy asInteger! !

"August 31, 2009 -> 20:10:28"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testLookupOrNilInLibraryWin32

	|function proxy|
	Platform == Win32Platform ifFalse: [^self].
	proxy := Platform DLLLookup: 'sprintf' in: 'msvcrt.dll'.
	function := Alien lookup: 'sprintf' inLibrary: 'msvcrt.dll'.
	self assert: function address = proxy asInteger
	self assert: (Alien lookup: 'unknown' inLibrary: 'msvcrt.dll') isNil! !

"August 31, 2009 -> 20:10:28"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testLookupOrNilInLibraryWin32

	|function proxy|
	Platform == Win32Platform ifFalse: [^self].
	proxy := Platform DLLLookup: 'sprintf' in: 'msvcrt.dll'.
	function := Alien lookupOrNil: 'sprintf' inLibrary: 'msvcrt.dll'.
	self assert: function address = proxy asInteger
	self assert: (Alien lookupOrNil: 'unknown' inLibrary: 'msvcrt.dll') isNil! !

"August 31, 2009 -> 20:10:28"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'libraries' !
lookupOrNil: symbolName <String> inLibrary: libraryName <String> ^ <Alien>

	^[self lookupOrNil: symbolName inLibrary: libraryName]
			on: NotFoundError
			do: [:err| nil]! !

"August 31, 2009 -> 20:20:28"!

"System saved" !
"August 31, 2009 -> 20:23:25"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'libraries' !
lookupOrNil: symbolName <String> inLibrary: libraryName <String> ^ <Alien>

	^[self lookup: symbolName inLibrary: libraryName]
			on: NotFoundError
			do: [:err| nil]! !

"August 31, 2009 -> 20:24:20"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testLookupOrNilInLibraryWin32

	|function proxy|
	Platform == Win32Platform ifFalse: [^self].
	proxy := Platform DLLLookup: 'sprintf' in: 'msvcrt.dll'.
	function := Alien lookupOrNil: 'sprintf' inLibrary: 'msvcrt.dll'.
	self assert: function address = proxy asInteger.
	self assert: (Alien lookupOrNil: 'unknown' inLibrary: 'msvcrt.dll') isNil! !

"August 31, 2009 -> 20:53:29"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testLookupClockWin32

	|function proxy|
	Platform == Win32Platform ifFalse: [^self].
	function := Alien lookupOrNil: 'clock' inLibrary: 'msvcrt.dll'.
! !

"August 31, 2009 -> 20:53:41"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testLookupClockWin32

	|function proxy|
	Platform == Win32Platform ifFalse: [^self].
	function := Alien lookup: 'clock' inLibrary: 'msvcrt.dll'.
! !

"August 31, 2009 -> 20:54:8"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testLookupClockWin32

	|function proxy|
	Platform == Win32Platform ifFalse: [^self].
	function := Alien lookup: 'clock' inLibrary: 'msvcrt.dll'.
	function halt! !

"August 31, 2009 -> 20:55:30"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testLookupClockWin32

	|function result|
	Platform == Win32Platform ifFalse: [^self].
	function := Alien lookup: 'clock' inLibrary: 'msvcrt.dll'.
	result := Alien new: 8.
	function primFFICall: result! !

"August 31, 2009 -> 20:55:55"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testLookupClockWin32

	|function result|
	Platform == Win32Platform ifFalse: [^self].
	function := Alien lookup: 'clock' inLibrary: 'msvcrt.dll'.
	result := Alien new: 8.
	function primFFICallResult: result! !

"August 31, 2009 -> 20:56:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien>! !

"August 31, 2009 -> 21:0:17"!

"System saved" !
"September 1, 2009 -> 2:20:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien>

	{{primitiveAlienCallResult: result ifFail: [:err| self error: err]}}! !

"September 1, 2009 -> 2:20:17"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien>

	{{self primitiveAlienCallResult: result ifFail: [:err| self error: err]}}! !

"September 1, 2009 -> 2:37:50"!

"System saved" !
"September 7, 2009 -> 18:34:26"!

Delta define: #UndefinedObjectTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"September 7, 2009 -> 18:34:56"!

! (Delta mirrorFor: #UndefinedObjectTest) methodsFor: 'testing' !
testAsAlien

	self assert: nil asAlien == 0! !

"September 7, 2009 -> 18:35:52"!

! (Delta mirrorFor: #UndefinedObject) methodsFor: 'Aliens-converting' !
asAlien

	^0! !

"September 7, 2009 -> 18:37:0"!

Delta define: #AlienTrueTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"September 7, 2009 -> 18:37:24"!

! (Delta mirrorFor: #AlienTrueTest) methodsFor: 'testing' !
testAsAlien

	self assert: true asAlien == 1! !

"September 7, 2009 -> 18:38:33"!

! (Delta mirrorFor: #True) methodsFor: 'Aliens-converting' !
asAlien

	^1! !

"September 7, 2009 -> 18:38:50"!

Delta define: #AlienFalseTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"September 7, 2009 -> 18:39:12"!

! (Delta mirrorFor: #AlienFalseTest) methodsFor: 'testing' !
testAsAlien

	self assert: false asAlien == 0! !

"September 7, 2009 -> 18:39:50"!

! (Delta mirrorFor: #False) methodsFor: 'Aliens-converting' !
asAlien

	^0! !

"September 7, 2009 -> 18:40:49"!

Delta define: #AlienStringTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"September 7, 2009 -> 18:43:4"!

! (Delta mirrorFor: #AlienStringTest) methodsFor: 'testing' !
testAsAlien

	|alien|
	alien := '123456' asString.
	self assert: (alien size = 7).
	self assert: '123456' = alien strcpy
	! !

"September 7, 2009 -> 18:44:14"!

! (Delta mirrorFor: #AlienStringTest) methodsFor: 'testing' !
testAsAlien

	|alien|
	alien := '123456' asAlien.
	self assert: (alien size = 7).
	self assert: '123456' = alien strcpy
	! !

"September 7, 2009 -> 18:45:11"!

! (Delta mirrorFor: #AlienStringTest) methodsFor: 'testing' !
testAsAlien

	|alien string|
	string := '123456' asString.
	alien := string asAlien.
	self assert: (alien size = 7).
	self assert: string = alien strcpy
	! !

"September 7, 2009 -> 18:48:21"!

! (Delta mirrorFor: #AlienStringTest) methodsFor: 'testing' !
testAsAlien

	|alien string|
	string := '123456' asString.
	alien := string asAlien.
	self assert: (alien size abs = 7).
	self assert: string = alien strcpy
	! !

"September 7, 2009 -> 18:49:1"!

! (Delta mirrorFor: #String) methodsFor: 'Aliens-converting' !
asAlien

	^(Alien newC: self size + 1)
		replaceFrom: 1 to: self size with: self startingAt: 1
	! !

"September 7, 2009 -> 18:57:20"!

Delta define: #AlienFunctionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"September 7, 2009 -> 18:57:49"!

Delta define: #AlienFunctionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'function')) !


"September 7, 2009 -> 18:59:17"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'private - test support' !
ensureWin32Or: block

	Platform == Win32Platform
		ifFalse: [block value]! !

"September 7, 2009 -> 18:59:36"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'fixture' !
setUp

	self ensureWin32Or: [^self].
	function := Alien 
							lookup: 'sprintf'
							inLibrary: 'msvcrt.dll'! !

"September 7, 2009 -> 19:5:52"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithTwoArgs
	
	self ensureWin32Or: [^self].
	Alien
		autoFreeAfter: [:free|
			|result formatString|
			result := free value: (Alien newC: 200).
			formatString = '12345' asString.
			function primFFICallResult: nil
							with: result
							with: (free value: formatString asAlien).
			self assert: formatString = result strcpy]! !

"September 7, 2009 -> 19:8:1"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'fixture' !
libcName
	
	Platform == Win32Platform
		ifTrue: [^'msvcrt.dll'].
	Platform == MacOSXPlatform
		ifTrue: [^'libc.dylib'].
	Platform == UnixPlatform
		ifTrue: [^'libc.6.so']
	self error: 'Unsupported platform'! !

"September 7, 2009 -> 19:8:18"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'fixture' !
setUp

	self ensureWin32Or: [^self].
	function := Alien 
							lookup: 'sprintf'
							inLibrary: self libcName! !

"September 7, 2009 -> 19:8:27"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'fixture' !
setUp

	function := Alien 
							lookup: 'sprintf'
							inLibrary: self libcName! !

"September 7, 2009 -> 19:8:31"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithTwoArgs
	
	Alien
		autoFreeAfter: [:free|
			|result formatString|
			result := free value: (Alien newC: 200).
			formatString = '12345' asString.
			function primFFICallResult: nil
							with: result
							with: (free value: formatString asAlien).
			self assert: formatString = result strcpy]! !

"September 7, 2009 -> 19:8:35"!

(Delta mirrorFor: #AlienFunctionTest) removeMethod: #ensureWin32Or: ifAbsent: [] !


"September 7, 2009 -> 19:12:0"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|nil> with: arg1 <Alien|SmallInteger> with: arg2 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result ifFail: [:err| self error: err]}}! !

"September 7, 2009 -> 19:12:24"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|nil> with: arg1 <Alien|SmallInteger> with: arg2 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			ifFail: [:err| self error: err]}}! !

"September 7, 2009 -> 19:13:45"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithTwoArgs
	
	Alien
		autoFreeAfter: [:free|
			|result formatString|
			result := free value: (Alien newC: 200).
			formatString := '12345' asString.
			function primFFICallResult: nil
							with: result
							with: (free value: formatString asAlien).
			self assert: formatString = result strcpy]! !

"September 7, 2009 -> 19:54:10"!

"System saved" !
"September 7, 2009 -> 20:34:30"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithTwoArgs
	
	Alien
		autoFreeAfter: [:free|
			|result formatString|
			result := free value: (Alien newC: 200).
			formatString := '12345' asString.
			function primFFICallResult: nil
							with: result
							with: (free value: formatString asAlien pointer).
			self assert: formatString = result strcpy]! !

"September 7, 2009 -> 20:34:59"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithTwoArgs
	
	Alien
		autoFreeAfter: [:free|
			|result formatString|
			result := free value: (Alien newC: 200).
			formatString := '12345' asString.
			function primFFICallResult: nil
							with: result
							with: (free value: formatString asAlien) pointer.
			self assert: formatString = result strcpy]! !

"September 7, 2009 -> 20:35:14"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithTwoArgs
	
	Alien
		autoFreeAfter: [:free|
			|result formatString|
			result := free value: (Alien newC: 200).
			formatString := '12345' asString.
			function primFFICallResult: nil
							with: result pointer
							with: (free value: formatString asAlien) pointer.
			self assert: formatString = result strcpy]! !

"September 7, 2009 -> 20:37:3"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithThreeArgs
	
	Alien
		autoFreeAfter: [:free|
			|result formatString|
			result := free value: (Alien newC: 200).
			formatString := '%d' asString.
			function primFFICallResult: nil
							with: result pointer
							with: (free value: formatString asAlien) pointer
							with: 1.
			self assert: '1' asString = result strcpy]! !

"September 7, 2009 -> 20:38:2"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|nil>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			with: arg3
			ifFail: [:err| self error: err]}}! !

"September 7, 2009 -> 20:38:45"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithFourArgs
	
	Alien
		autoFreeAfter: [:free|
			|result formatString|
			result := free value: (Alien newC: 200).
			formatString := '%d %d' asString.
			function primFFICallResult: nil
							with: result pointer
							with: (free value: formatString asAlien) pointer
							with: 1
							with: 2.
			self assert: '1 2' asString = result strcpy]! !

"September 7, 2009 -> 20:40:31"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithFourArgs
	
	Alien
		autoFreeAfter: [:free|
			|result formatString|
			result := free value: (Alien newC: 200).
			formatString := '%d %d' asString.
			function primFFICallResult: nil
							with: result pointer
							with: (free value: formatString asAlien) pointer
							with: ((free value: (Alien newC: 4))
										signedLongAt: 1 put: 1;
										yourself)
							with: 2.
			self assert: '1 2' asString = result strcpy]! !

"September 7, 2009 -> 20:41:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|nil>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			with: arg3
			with: arg4
			ifFail: [:err| self error: err]}}! !

"September 7, 2009 -> 20:43:8"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithFourArgs
	
	Alien
		autoFreeAfter: [:free|
			|formattedString formatString result|
			result := Alien new: 4.
			formattedString := free value: (Alien newC: 200).
			formatString := '%d %d' asString.
			function primFFICallResult: result
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: ((free value: (Alien newC: 4))
										signedLongAt: 1 put: 1;
										yourself)
							with: 2.
			self assert: '1 2' asString = formattedString strcpy.
			self assert: 3 == result asUnsignedLong]! !

"September 7, 2009 -> 20:44:59"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithFourArgs
	
	Alien
		autoFreeAfter: [:free|
			|formattedString formatString result1|
			result1 := Alien new: 4.
			formattedString := free value: (Alien newC: 200).
			formatString := '%d %d' asString.
			function primFFICallResult: result1
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: ((free value: (Alien newC: 4))
										signedLongAt: 1 put: 1;
										yourself)
							with: 2.
			self assert: '1 2' asString = formattedString strcpy.
			self assert: 3 == result1 asUnsignedLong]! !

"September 7, 2009 -> 20:45:15"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithThreeArgs
	
	Alien
		autoFreeAfter: [:free|
			|result1 formatString|
			result1 := free value: (Alien newC: 200).
			formatString := '%d' asString.
			function primFFICallResult: nil
							with: result1 pointer
							with: (free value: formatString asAlien) pointer
							with: 1.
			self assert: '1' asString = result1 strcpy]! !

"September 7, 2009 -> 20:45:28"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithTwoArgs
	
	Alien
		autoFreeAfter: [:free|
			|result1 formatString|
			result1 := free value: (Alien newC: 200).
			formatString := '12345' asString.
			function primFFICallResult: nil
							with: result1 pointer
							with: (free value: formatString asAlien) pointer.
			self assert: formatString = result1 strcpy]! !

"September 7, 2009 -> 20:45:33"!

Delta define: #AlienFunctionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'function
result')) !


"September 7, 2009 -> 20:46:0"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithFourArgs
	
	Alien
		autoFreeAfter: [:free|
			|formattedString formatString |
			result := Alien new: 4.
			formattedString := free value: (Alien newC: 200).
			formatString := '%d %d' asString.
			function primFFICallResult: result
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: ((free value: (Alien newC: 4))
										signedLongAt: 1 put: 1;
										yourself)
							with: 2.
			self assert: '1 2' asString = formattedString strcpy.
			self assert: 3 == result asUnsignedLong]! !

"September 7, 2009 -> 20:46:49"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithThreeArgs
	
	Alien
		autoFreeAfter: [:free|
			|formatString|
			result := free value: (Alien newC: 200).
			formatString := '%d' asString.
			function primFFICallResult: nil
							with: result pointer
							with: (free value: formatString asAlien) pointer
							with: 1.
			self assert: '1' asString = result strcpy]! !

"September 7, 2009 -> 20:47:7"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithTwoArgs
	
	Alien
		autoFreeAfter: [:free|
			|formatString|
			result := free value: (Alien newC: 200).
			formatString := '12345' asString.
			function primFFICallResult: nil
							with: result pointer
							with: (free value: formatString asAlien) pointer.
			self assert: formatString = result strcpy]! !

"September 7, 2009 -> 20:47:40"!

Delta define: #AlienFunctionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'function
result
formattedString')) !


"September 7, 2009 -> 20:47:49"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithFourArgs
	
	Alien
		autoFreeAfter: [:free|
			|formatString |
			result := Alien new: 4.
			formattedString := free value: (Alien newC: 200).
			formatString := '%d %d' asString.
			function primFFICallResult: result
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: ((free value: (Alien newC: 4))
										signedLongAt: 1 put: 1;
										yourself)
							with: 2.
			self assert: '1 2' asString = formattedString strcpy.
			self assert: 3 == result asUnsignedLong]! !

"September 7, 2009 -> 20:48:18"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithThreeArgs
	
	Alien
		autoFreeAfter: [:free|
			|formatString|
			formattedString := free value: (Alien newC: 200).
			formatString := '%d' asString.
			function primFFICallResult: nil
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: 1.
			self assert: '1' asString = formattedString strcpy]! !

"September 7, 2009 -> 20:48:28"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithTwoArgs
	
	Alien
		autoFreeAfter: [:free|
			|formatString|
			formattedString := free value: (Alien newC: 200).
			formatString := '12345' asString.
			function primFFICallResult: nil
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer.
			self assert: formatString = formattedString strcpy]! !

"September 7, 2009 -> 20:49:34"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'fixture' !
setUp

	function := Alien 
							lookup: 'sprintf'
							inLibrary: self libcName.
	result := Alien new: 4.
	formattedString := Alien newC: 200! !

"September 7, 2009 -> 20:49:53"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'fixture' !
tearDown

	formattedString free! !

"September 7, 2009 -> 20:50:7"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithFourArgs
	
	Alien
		autoFreeAfter: [:free|
			|formatString |
			formatString := '%d %d' asString.
			function primFFICallResult: result
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: ((free value: (Alien newC: 4))
										signedLongAt: 1 put: 1;
										yourself)
							with: 2.
			self assert: '1 2' asString = formattedString strcpy.
			self assert: 3 == result asUnsignedLong]! !

"September 7, 2009 -> 20:50:11"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithThreeArgs
	
	Alien
		autoFreeAfter: [:free|
			|formatString|
			formatString := '%d' asString.
			function primFFICallResult: nil
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: 1.
			self assert: '1' asString = formattedString strcpy]! !

"September 7, 2009 -> 20:50:12"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithTwoArgs
	
	Alien
		autoFreeAfter: [:free|
			|formatString|
			formatString := '12345' asString.
			function primFFICallResult: nil
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer.
			self assert: formatString = formattedString strcpy]! !

"September 7, 2009 -> 20:52:56"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithThreeArgs
	
	Alien autoFreeAfter: [:free|
			|formatString|
			formatString := '%d' asString.
			function primFFICallResult: nil
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: 1].
	self assert: '1' asString = formattedString strcpy! !

"September 7, 2009 -> 20:52:57"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithFiveArgs
	
	Alien autoFreeAfter: [:free|
			|formatString |
			formatString := '%d %d %d' asString.
			function primFFICallResult: result
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: 1
							with: 2
							with: 3].
	self assert: '1 2 3' asString = formattedString strcpy.
	self assert: 5 == result asUnsignedLong! !

"September 7, 2009 -> 20:53:32"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|nil>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			with: arg3
			with: arg4
			with: arg5
			ifFail: [:err| self error: err]}}! !

"September 7, 2009 -> 20:54:34"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithSixArgs
	
	Alien autoFreeAfter: [:free|
			|formatString |
			formatString := '%d %d %d %d' asString.
			function primFFICallResult: result
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: 1
							with: 2
							with: 3
							with: 4].
	self assert: '1 2 3 4' asString = formattedString strcpy.
	self assert: 7 == result asUnsignedLong! !

"September 7, 2009 -> 20:55:1"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|nil>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			with: arg3
			with: arg4
			with: arg5
			with: arg6
			ifFail: [:err| self error: err]}}! !

"September 7, 2009 -> 20:55:32"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithSevenArgs
	
	Alien autoFreeAfter: [:free|
			|formatString |
			formatString := '%d %d %d %d %d' asString.
			function primFFICallResult: result
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: 1
							with: 2
							with: 3
							with: 4
							with: 5].
	self assert: '1 2 3 4 5' asString = formattedString strcpy.
	self assert: 9 == result asUnsignedLong! !

"September 7, 2009 -> 20:56:6"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|nil>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			with: arg3
			with: arg4
			with: arg5
			with: arg6
			with: arg7
			ifFail: [:err| self error: err]}}! !

"September 7, 2009 -> 20:56:36"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithEightArgs
	
	Alien autoFreeAfter: [:free|
			|formatString |
			formatString := '%d %d %d %d %d %d' asString.
			function primFFICallResult: result
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: 1
							with: 2
							with: 3
							with: 4
							with: 5
							with: 6].
	self assert: '1 2 3 4 5 6' asString = formattedString strcpy.
	self assert: 11 == result asUnsignedLong! !

"September 7, 2009 -> 20:58:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|nil>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger>
with: arg8 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: { arg1. arg2. arg3. arg4. arg5. arg6. arg7. arg8 }
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 9:53:8"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithNineArgs
	
	Alien autoFreeAfter: [:free|
			|formatString |
			formatString := '%d %d %d %d %d %d %d' asString.
			function primFFICallResult: result
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: 1
							with: 2
							with: 3
							with: 4
							with: 5
							with: 6
							with: 7].
	self assert: '1 2 3 4 5 6 7' asString = formattedString strcpy.
	self assert: 13 == result asUnsignedLong! !

"September 8, 2009 -> 9:53:50"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|nil>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger>
with: arg8 <Alien|SmallInteger>
with: arg9 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: { arg1. arg2. arg3. arg4. arg5. arg6. arg7. arg8. arg9 }
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 9:54:17"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithTenArgs
	
	Alien autoFreeAfter: [:free|
			|formatString |
			formatString := '%d %d %d %d %d %d %d %d' asString.
			function primFFICallResult: result
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: 1
							with: 2
							with: 3
							with: 4
							with: 5
							with: 6
							with: 7
							with: 8].
	self assert: '1 2 3 4 5 6 7 8' asString = formattedString strcpy.
	self assert: 15 == result asUnsignedLong! !

"September 8, 2009 -> 9:54:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|nil>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger>
with: arg8 <Alien|SmallInteger>
with: arg9 <Alien|SmallInteger>
with: arg10 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: { arg1. arg2. arg3. arg4. arg5. arg6. arg7. arg8. arg9. arg10 }
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 9:55:21"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithElevenArgs
	
	Alien autoFreeAfter: [:free|
			|formatString |
			formatString := '%d %d %d %d %d %d %d %d %d' asString.
			function primFFICallResult: result
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: 1
							with: 2
							with: 3
							with: 4
							with: 5
							with: 6
							with: 7
							with: 8
							with: 9].
	self assert: '1 2 3 4 5 6 7 8 9' asString = formattedString strcpy.
	self assert: 17 == result asUnsignedLong! !

"September 8, 2009 -> 9:55:45"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|nil>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger>
with: arg8 <Alien|SmallInteger>
with: arg9 <Alien|SmallInteger>
with: arg10 <Alien|SmallInteger>
with: arg11 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: { arg1. arg2. arg3. arg4. arg5. arg6. arg7. arg8. arg9. arg10. arg11 }
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 9:56:25"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithTwelveArgs
	
	Alien autoFreeAfter: [:free|
			|formatString |
			formatString := '%d %d %d %d %d %d %d %d %d %d' asString.
			function primFFICallResult: result
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: 1
							with: 2
							with: 3
							with: 4
							with: 5
							with: 6
							with: 7
							with: 8
							with: 9
							with: 10].
	self assert: '1 2 3 4 5 6 7 8 9 10' asString = formattedString strcpy.
	self assert: 20 == result asUnsignedLong! !

"September 8, 2009 -> 9:57:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|nil>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger>
with: arg8 <Alien|SmallInteger>
with: arg9 <Alien|SmallInteger>
with: arg10 <Alien|SmallInteger>
with: arg11 <Alien|SmallInteger>
with: arg12 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: { arg1. arg2. arg3. arg4. arg5. arg6. arg7. arg8. arg9. arg10. arg11. arg12 }
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 9:57:38"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien>
with: arg1 <Alien|UndefinedObject>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger>
with: arg8 <Alien|SmallInteger>
with: arg9 <Alien|SmallInteger>
with: arg10 <Alien|SmallInteger>
with: arg11 <Alien|SmallInteger>
with: arg12 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: { arg1. arg2. arg3. arg4. arg5. arg6. arg7. arg8. arg9. arg10. arg11. arg12 }
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 9:57:48"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien>
with: arg1 <Alien|UndefinedObject>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger>
with: arg8 <Alien|SmallInteger>
with: arg9 <Alien|SmallInteger>
with: arg10 <Alien|SmallInteger>
with: arg11 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: { arg1. arg2. arg3. arg4. arg5. arg6. arg7. arg8. arg9. arg10. arg11 }
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 9:57:58"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien>
with: arg1 <Alien|UndefinedObject>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger>
with: arg8 <Alien|SmallInteger>
with: arg9 <Alien|SmallInteger>
with: arg10 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: { arg1. arg2. arg3. arg4. arg5. arg6. arg7. arg8. arg9. arg10 }
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 9:58:7"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien>
with: arg1 <Alien|UndefinedObject>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger>
with: arg8 <Alien|SmallInteger>
with: arg9 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: { arg1. arg2. arg3. arg4. arg5. arg6. arg7. arg8. arg9 }
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 9:58:14"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien>
with: arg1 <Alien|UndefinedObject>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger>
with: arg8 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: { arg1. arg2. arg3. arg4. arg5. arg6. arg7. arg8 }
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 9:58:24"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien>
with: arg1 <Alien|UndefinedObject>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			with: arg3
			with: arg4
			with: arg5
			with: arg6
			with: arg7
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 9:58:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien>
with: arg1 <Alien|UndefinedObject>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			with: arg3
			with: arg4
			with: arg5
			with: arg6
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 9:58:47"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien>
with: arg1 <Alien|UndefinedObject>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			with: arg3
			with: arg4
			with: arg5
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 9:58:54"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien>
with: arg1 <Alien|UndefinedObject>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			with: arg3
			with: arg4
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 9:59:1"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien>
with: arg1 <Alien|UndefinedObject>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			with: arg3
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 9:59:16"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien> with: arg1 <Alien|UndefinedObject> with: arg2 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 10:3:13"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject> with: arg1 <Alien|SmallInteger> with: arg2 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 10:3:42"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			with: arg3
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 10:3:49"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			with: arg3
			with: arg4
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 10:3:58"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			with: arg3
			with: arg4
			with: arg5
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 10:4:10"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			with: arg3
			with: arg4
			with: arg5
			with: arg6
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 10:4:16"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			with: arg3
			with: arg4
			with: arg5
			with: arg6
			with: arg7
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 10:4:25"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger>
with: arg8 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: { arg1. arg2. arg3. arg4. arg5. arg6. arg7. arg8 }
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 10:4:47"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger>
with: arg8 <Alien|SmallInteger>
with: arg9 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: { arg1. arg2. arg3. arg4. arg5. arg6. arg7. arg8. arg9 }
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 10:4:57"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger>
with: arg8 <Alien|SmallInteger>
with: arg9 <Alien|SmallInteger>
with: arg10 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: { arg1. arg2. arg3. arg4. arg5. arg6. arg7. arg8. arg9. arg10 }
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 10:5:17"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger>
with: arg8 <Alien|SmallInteger>
with: arg9 <Alien|SmallInteger>
with: arg10 <Alien|SmallInteger>
with: arg11 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: { arg1. arg2. arg3. arg4. arg5. arg6. arg7. arg8. arg9. arg10. arg11 }
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 10:5:26"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger>
with: arg8 <Alien|SmallInteger>
with: arg9 <Alien|SmallInteger>
with: arg10 <Alien|SmallInteger>
with: arg11 <Alien|SmallInteger>
with: arg12 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: { arg1. arg2. arg3. arg4. arg5. arg6. arg7. arg8. arg9. arg10. arg11. arg12 }
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 10:26:29"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithArguments
	
	Alien autoFreeAfter: [:free|
			|formatString|
			formatString := '%d' asString.
			function primFFICallResult: nil
							withArguments: { formattedString pointer.
														(free value: formatString asAlien) pointer.
														1 } ].
	self assert: '1' asString = formattedString strcpy! !

"September 8, 2009 -> 10:27:33"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
withArguments: arguments <Array[Alien|SmallInteger]> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: arguments
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 10:27:56"!

Delta define: #AlienFunctionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'sprintf
function
result
formattedString')) !


"September 8, 2009 -> 10:28:4"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'fixture' !
setUp

	sprintf := function := Alien 
							lookup: 'sprintf'
							inLibrary: self libcName.
	result := Alien new: 4.
	formattedString := Alien newC: 200! !

"September 8, 2009 -> 10:28:15"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithArguments
	
	Alien autoFreeAfter: [:free|
			|formatString|
			formatString := '%d' asString.
			sprintf primFFICallResult: nil
							withArguments: { formattedString pointer.
														(free value: formatString asAlien) pointer.
														1 } ].
	self assert: '1' asString = formattedString strcpy! !

"September 8, 2009 -> 10:28:24"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithEightArgs
	
	Alien autoFreeAfter: [:free|
			|formatString |
			formatString := '%d %d %d %d %d %d' asString.
			sprintf primFFICallResult: result
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: 1
							with: 2
							with: 3
							with: 4
							with: 5
							with: 6].
	self assert: '1 2 3 4 5 6' asString = formattedString strcpy.
	self assert: 11 == result asUnsignedLong! !

"September 8, 2009 -> 10:28:44"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithFiveArgs
	
	Alien autoFreeAfter: [:free|
			|formatString |
			formatString := '%d %d %d' asString.
			sprintf primFFICallResult: result
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: 1
							with: 2
							with: 3].
	self assert: '1 2 3' asString = formattedString strcpy.
	self assert: 5 == result asUnsignedLong! !

"September 8, 2009 -> 10:28:45"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithElevenArgs
	
	Alien autoFreeAfter: [:free|
			|formatString |
			formatString := '%d %d %d %d %d %d %d %d %d' asString.
			sprintf primFFICallResult: result
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: 1
							with: 2
							with: 3
							with: 4
							with: 5
							with: 6
							with: 7
							with: 8
							with: 9].
	self assert: '1 2 3 4 5 6 7 8 9' asString = formattedString strcpy.
	self assert: 17 == result asUnsignedLong! !

"September 8, 2009 -> 10:28:56"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithFourArgs
	
	Alien
		autoFreeAfter: [:free|
			|formatString |
			formatString := '%d %d' asString.
			sprintf primFFICallResult: result
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: ((free value: (Alien newC: 4))
										signedLongAt: 1 put: 1;
										yourself)
							with: 2.
			self assert: '1 2' asString = formattedString strcpy.
			self assert: 3 == result asUnsignedLong]! !

"September 8, 2009 -> 10:29:3"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithNineArgs
	
	Alien autoFreeAfter: [:free|
			|formatString |
			formatString := '%d %d %d %d %d %d %d' asString.
			sprintf primFFICallResult: result
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: 1
							with: 2
							with: 3
							with: 4
							with: 5
							with: 6
							with: 7].
	self assert: '1 2 3 4 5 6 7' asString = formattedString strcpy.
	self assert: 13 == result asUnsignedLong! !

"September 8, 2009 -> 10:29:10"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithSevenArgs
	
	Alien autoFreeAfter: [:free|
			|formatString |
			formatString := '%d %d %d %d %d' asString.
			sprintf primFFICallResult: result
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: 1
							with: 2
							with: 3
							with: 4
							with: 5].
	self assert: '1 2 3 4 5' asString = formattedString strcpy.
	self assert: 9 == result asUnsignedLong! !

"September 8, 2009 -> 10:29:20"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithTwelveArgs
	
	Alien autoFreeAfter: [:free|
			|formatString |
			formatString := '%d %d %d %d %d %d %d %d %d %d' asString.
			sprintf primFFICallResult: result
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: 1
							with: 2
							with: 3
							with: 4
							with: 5
							with: 6
							with: 7
							with: 8
							with: 9
							with: 10].
	self assert: '1 2 3 4 5 6 7 8 9 10' asString = formattedString strcpy.
	self assert: 20 == result asUnsignedLong! !

"September 8, 2009 -> 10:29:30"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithThreeArgs
	
	Alien autoFreeAfter: [:free|
			|formatString|
			formatString := '%d' asString.
			sprintf primFFICallResult: nil
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: 1].
	self assert: '1' asString = formattedString strcpy! !

"September 8, 2009 -> 10:29:37"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithTenArgs
	
	Alien autoFreeAfter: [:free|
			|formatString |
			formatString := '%d %d %d %d %d %d %d %d' asString.
			sprintf primFFICallResult: result
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: 1
							with: 2
							with: 3
							with: 4
							with: 5
							with: 6
							with: 7
							with: 8].
	self assert: '1 2 3 4 5 6 7 8' asString = formattedString strcpy.
	self assert: 15 == result asUnsignedLong! !

"September 8, 2009 -> 10:29:49"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithTwoArgs
	
	Alien
		autoFreeAfter: [:free|
			|formatString|
			formatString := '12345' asString.
			sprintf primFFICallResult: nil
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer.
			self assert: formatString = formattedString strcpy]! !

"September 8, 2009 -> 10:30:12"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'fixture' !
setUp

	sprintf := Alien 
							lookup: 'sprintf'
							inLibrary: self libcName.
	result := Alien new: 4.
	formattedString := Alien newC: 200! !

"September 8, 2009 -> 10:30:23"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithSixArgs
	
	Alien autoFreeAfter: [:free|
			|formatString |
			formatString := '%d %d %d %d' asString.
			sprintf primFFICallResult: result
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: 1
							with: 2
							with: 3
							with: 4].
	self assert: '1 2 3 4' asString = formattedString strcpy.
	self assert: 7 == result asUnsignedLong! !

"September 8, 2009 -> 10:30:36"!

Delta define: #AlienFunctionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'sprintf
labs
result
formattedString')) !


"September 8, 2009 -> 10:31:28"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'fixture' !
setUp

	sprintf := Alien lookup: 'sprintf' inLibrary: self libcName.
	labs := Alien lookup: 'labs' inLibrary: self libcName.
	result := Alien new: 4.
	formattedString := Alien newC: 200! !

"September 8, 2009 -> 10:33:23"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithOneArg

	labs primFFICallResult: result
			with: -1.
	self assert: 1 == result asSignedLong! !

"September 8, 2009 -> 10:33:46"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject> with: arg1 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 10:34:44"!

"System saved" !