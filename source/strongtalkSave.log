
"October 17, 2006 -> 14:36:48"!

! (Delta mirrorFor: #DefinitionWriter) methodsFor: 'Unclassified' !
fileOutBodyOn: stream <WriteStream> ^ <Int>

	| pos <Int> sortedCategories <Cltn[Str]> |
	pos := stream position.
	sortedCategories := self mirror sourceInfo categories asSortedCollection: 
			[ :s <Str> :s2 <Str> | s  <= s2  ]
	 do: [ :cat <Str> | 
		self fileOutCategory: cat on: stream ].
	^pos! !

"October 17, 2006 -> 14:37:7"!

! (Delta mirrorFor: #DefinitionWriter) methodsFor: 'Unclassified' !
fileOutBodyOn: stream <WriteStream> ^ <Int>

	| pos <Int> sortedCategories <Cltn[Str]> |
	pos := stream position.
	sortedCategories := self mirror sourceInfo categories asSortedCollection: 
			[ :s <Str> :s2 <Str> | s  <= s2  ].
	sortedCategories do: [ :cat <Str> | 
		self fileOutCategory: cat on: stream ].
	^pos! !

"October 17, 2006 -> 14:40:57"!

"System saved" !
"June 2, 2007 -> 20:46:56"!

"System saved" !
"June 4, 2007 -> 1:26:52"!

Delta define: #InstanceVariableOutliner as: (
(Class subclassOf: 'DefinitionItemOutliner' instanceVariables: '')) !


"June 4, 2007 -> 1:26:54"!

Delta define: #InstanceVariableOutliner as: (
(Class subclassOf: 'DefinitionItemOutliner' instanceVariables: '')) !


"June 4, 2007 -> 1:26:54"!

Delta define: #InstanceVariableOutliner as: (
(Class subclassOf: 'DefinitionItemOutliner' instanceVariables: '')) !


"June 4, 2007 -> 1:26:54"!

Delta define: #InstanceVariableOutliner as: (
(Class subclassOf: 'DefinitionItemOutliner' instanceVariables: '')) !


"June 4, 2007 -> 1:26:54"!

Delta define: #InstanceVariableOutliner as: (
(Class subclassOf: 'DefinitionItemOutliner' instanceVariables: '')) !


"June 4, 2007 -> 1:26:54"!

Delta define: #InstanceVariableOutliner as: (
(Class subclassOf: 'DefinitionItemOutliner' instanceVariables: '')) !


"June 4, 2007 -> 1:26:54"!

Delta define: #InstanceVariableOutliner as: (
(Class subclassOf: 'DefinitionItemOutliner' instanceVariables: '')) !


"June 4, 2007 -> 1:26:54"!

Delta define: #InstanceVariableOutliner as: (
(Class subclassOf: 'DefinitionItemOutliner' instanceVariables: '')) !


"June 4, 2007 -> 1:26:54"!

Delta define: #InstanceVariableOutliner as: (
(Class subclassOf: 'DefinitionItemOutliner' instanceVariables: '')) !


"June 4, 2007 -> 1:26:54"!

Delta define: #InstanceVariableOutliner as: (
(Class subclassOf: 'DefinitionItemOutliner' instanceVariables: '')) !


"June 4, 2007 -> 1:26:54"!

Delta define: #InstanceVariableOutliner as: (
(Class subclassOf: 'DefinitionItemOutliner' instanceVariables: '')) !


"June 4, 2007 -> 1:26:54"!

(Delta mirrorFor: #InstanceVariableOutliner)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"June 4, 2007 -> 1:26:55"!

! (Delta mirrorFor: #InstanceVariableOutliner) methodsFor: 'private' !
aspectForUpdate ^ <Symbol>

	^#instanceVariables
! !

"June 4, 2007 -> 1:26:56"!

! (Delta mirrorFor: #InstanceVariableOutliner) methodsFor: 'private' !
header ^ <Str>

	^'Instance variables'! !

"June 4, 2007 -> 1:26:57"!

! (Delta mirrorFor: #InstanceVariableOutliner) methodsFor: 'private' !
modelAsCharGlyphs ^ <CharGlyphs>

	| tool <ASTtoRichTextTool[CharGlyph]> pts <Cltn[ParseTree]> |
	self useRichTextForSources
		ifTrue: [
			pts := DeltaParser new
							parseInstVarList: self mirror instanceVariableString 
							within: (DeltaScope within: nil)
							ifError: [ :msg <Str> :pos <Int> | self shouldNotHappen ].
			^pts isEmpty
				ifTrue: [ 		OrderedCollection[CharGlyphs] new ]
				ifFalse: [ 	self richTextForParseTrees: pts ] ]
		ifFalse: [
			^self standardTextForString: self mirror instanceVariableString painter: self codePainter ]

! !

"June 4, 2007 -> 1:26:58"!

! (Delta mirrorFor: #InstanceVariableOutliner) methodsFor: 'private' !
storeAndOnSuccess: blk <[]>

	"The right way to do this is to have a #instanceVariables:ifFail: in ClassMirror and MixinDeclMirror
		that will parse and	update accordingly.
		
		In the meantime, we parse an extra time here to check for errors and call #instanceVariables: afterwards.
		This should be changed shortly."
		
	| ivs <Str> eval <Str> constructor <Mirror> |
	self deltaHack.
	ivs := self charGlyphModelAsString: self codeView.
	DeltaParser new 
		parseInstVarList: ivs
		within: (DeltaScope within: nil)
		ifError: [ :msg <Str> :pos <Int> | ^self showParseError: msg at: pos in: self codeView ].
	self mirror instanceVariables: ivs.
	blk value.
! !

"June 4, 2007 -> 1:26:59"!

! (Delta mirrorFor: #InstanceVariableOutliner) methodsFor: 'typechecking' !
typecheck

self typecheckAction:[self mirror typecheckInstVars]
		title: 'Typechecking ', self mirror name, ' instance variables'.! !

"June 4, 2007 -> 1:27:0"!

! (Delta mirrorFor: #InstanceVariableOutliner) methodsFor: 'accessing' !
locator ^ <ClassVarLocator>

^InstVarLocator ofDefinition: self mirror basicLocator! !

"June 4, 2007 -> 1:27:1"!

! (Delta mirrorFor: #InstanceVariableOutliner) methodsFor: 'menus' !
hasMenu ^<Boolean>

	^true! !

"June 4, 2007 -> 1:27:2"!

! (Delta mirrorFor: #InstanceVariableOutliner) methodsFor: 'menus' !
menuBar ^<Menu>

	^Menu new
		add: (MenuAction new
					name: 'References...';
					action: [ self referencesToInstVar ])
! !

"June 4, 2007 -> 1:27:3"!

! (Delta mirrorFor: #InstanceVariableOutliner) methodsFor: 'control' !
referencesToInstVar
! !

"June 4, 2007 -> 1:28:33"!

"System saved" !
"June 4, 2007 -> 1:31:2"!

"System saved" !
"June 4, 2007 -> 1:37:50"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"June 4, 2007 -> 1:37:50"!

(Delta mirrorFor: #Win32Platform)
comment: 
'The class side holds platform dependent constants and utilities.  Is also used
to get command line args, and other things like that.

Keywords: %machdep  %User

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.4 $
'!


"June 4, 2007 -> 1:37:52"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'platform classes' !
pathClass ^<FilePath class>

    ^Win32FilePath! !

"June 4, 2007 -> 1:37:53"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'platform classes' !
patternClass ^<FilePattern class>

    ^Win32FilePattern! !

"June 4, 2007 -> 1:37:54"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'testing' !
usesCrLfConvention ^<Boolean>

    ^true! !

"June 4, 2007 -> 1:37:55"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'constants' !
multipleMatchWildcardCharacter ^<Character>

    ^$*! !

"June 4, 2007 -> 1:37:55"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'constants' !
singleMatchWildcardCharacter ^<Character>

    ^$?! !

"June 4, 2007 -> 1:37:56"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'constants' !
wordSize ^<Int>
    ^4! !

"June 4, 2007 -> 1:37:57"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'command line' !
getArguments ^<OrdCltn[Str]>

    | line <Str> args <VarOrdCltn[Str]> strm <CharInputStream> |
    line := self getCommandLine.
    args := OrderedCollection[Str] new.
    strm := line readStream.

    [   "skip whitespace"
        [ strm atEnd not and: [ strm peekFor: Character space] ] whileTrue.
        strm atEnd ] whileFalse: [
            args addLast: (self parseArgFrom: strm).        ].
    ^args! !

"June 4, 2007 -> 1:37:58"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'command line' !
getCommandLine
    | p size result |
    p := {{<kernel ExternalProxy GetCommandLineA>getCommandLine}}.
    size := 0.
    [(p byteAt: size) == 0] whileFalse: [ size := size + 1 ].
    result := String new: size.
    1 to: size do: [:index |
       result at: index put: (Character value: (p byteAt: index - 1))
    ].
    ^result! !

"June 4, 2007 -> 1:37:59"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLInitialize
    DLLDict := Dictionary new.
    {{primitiveDLLSetupLookup: self selector: #DLLLookup:in: ifFail: [:err | self error: err]}}! !

"June 4, 2007 -> 1:38:0"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLLibrary: name
    ^DLLDict at: name ifAbsent: [
        DLLDict at: name put: (self DLLLoad: name)
    ]! !

"June 4, 2007 -> 1:38:1"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLLoad: name
    | r n |
    r := ExternalProxy new.
    n := (self DLLMapName: name) asSymbol.
    ^{{primitiveDLLLoad: n result: r ifFail: [ :err | self error: err]}}! !

"June 4, 2007 -> 1:38:2"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLLookup: name <Str> in: library <Str>
    "Convert library into proxy"
    | p r |
    p := self DLLLibrary: library.
    r := ExternalProxy new.
    {{primitiveDLLLookup: name asSymbol in: p result: r ifFail: [:err | self error: err]}}.
    ^r! !

"June 4, 2007 -> 1:38:3"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLMapName: name <Str> ^<Str>
    name = 'user'       ifTrue: [^'USER32.DLL'].
    name = 'gdi'            ifTrue: [^'GDI32.DLL'].
    name = 'kernel'     ifTrue: [^'KERNEL32.DLL'].
    name = 'comdlg'     ifTrue: [^'COMDLG32.DLL'].
    self error: 'Mapping ', name, ' not found'! !

"June 4, 2007 -> 1:38:4"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'initialization' !
initialize

    self DLLInitialize! !

"June 4, 2007 -> 1:38:5"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'os streams' !
errorStream ^<CharOutputStream>

    ErrorStream isNil
        ifTrue: [   ErrorStream := TempTranscript new ].
    ^ErrorStream! !

"June 4, 2007 -> 1:38:6"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'environment' !
environmentVariableAt: key <Str> ifAbsent: blk <[^X def]> ^ <Str | X>

    | cKey <CString> cValue <CString> size <Int> cSize <ExternalProxy> result <Str> done <Boolean> found <Boolean> |
    size := 1024.
    cKey := CString for: key.
    done := false.
    [ done ] whileFalse: [
        cValue := CString for: (String new: size).
        cSize := {{<kernel ExternalProxy GetEnvironmentVariableA> key: cKey buffer: cValue bufSize: size}}.
        cSize asSmallInteger > size
            ifTrue: [   cValue free.                                                    "Buffer size too small for value of variable"
                            size := cSize asSmallInteger ]
            ifFalse: [  done := true.                                                   "Buffer size ok, check if variable was found"
                            (found := cSize asSmallInteger ~= 0)
                                ifTrue: [ result := cValue asString ] ] ].
    cKey free. 
    cValue free.
    ^found
        ifTrue: [ result ]
        ifFalse: blk ! !

"June 4, 2007 -> 1:38:7"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'private-clipboard access' !
closeClipboard

    {{<user ExternalProxy CloseClipboard> call}}! !

"June 4, 2007 -> 1:38:8"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'private-clipboard access' !
emptyClipboard

    {{<user ExternalProxy EmptyClipboard> call}} asBoolean
        ifFalse: [ Win32 handleError ].
! !

"June 4, 2007 -> 1:38:9"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'private-clipboard access' !
openClipboard

    {{<user ExternalProxy OpenClipboard> hnd: Win32 NULL}} asBoolean
        ifFalse: [ Win32 handleError ].
! !

"June 4, 2007 -> 1:38:10"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'clipboard access' !
clipboardText: str <Str>

    self openClipboard.
    [   | glob <HGLOBAL> strm <ReadWriteStream[Character]> xstr <Str> |
        self emptyClipboard.

        "transform string into a form with lfs inserted"
        strm := (String new: str size) readWriteStream.
        str do:
            [ :c <Character> |
                strm put: c.
                c = Character cr
                    ifTrue: [ strm put: Character lf ].
            ].
        xstr := String withAll: strm contentsWritten.

        glob := HGLOBAL new
                        allocate: xstr size + 1
                        attributes: (Win32 GMEM_MOVEABLE
                                            externalBitOr: Win32 GMEM_DDESHARE).
        glob withPointer: CString new
                do: [ :cs <CString> |
                            cs value: xstr   ].

        {{<user ExternalProxy SetClipboardData>
                format: Win32 CF_TEXT
                data: glob
        }} isNull
            ifTrue: [ Win32 handleError ].
    ] ensure:
        [ self closeClipboard ]! !

"June 4, 2007 -> 1:38:11"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'clipboard access' !
clipboardTextIfAbsent: blk <[^X def]> ^<Str | X>

    self openClipboard.
    [   | glob <HGLOBAL> strm <CharWriteStream> |

        {{<user ExternalProxy IsClipboardFormatAvailable> format: Win32 CF_TEXT}} asBoolean
            ifFalse: [ ^blk value ].
        glob := {{<user HGLOBAL GetClipboardData> format: Win32 CF_TEXT}}.
        glob isNull
            ifTrue: [ Win32 handleError ].
        strm := (String new: 100) writeStream.
        glob withPointer: CString new
                do: [ :cs <CString> |
                            cs asString do:
                                [ :c <Character> |
                                    c = Character lf
                                        ifFalse: [ strm put: c ]
                                ].
                            ^strm contentsWritten
                      ].
    ] ensure:
        [ self closeClipboard ]! !

"June 4, 2007 -> 1:38:12"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'private' !
parseArgFrom: strm <CharInputStream>  ^<Str>

    ^strm peek = $"
        ifTrue: [       strm next.
                        strm upTo: $"   ]
        ifFalse: [  strm upTo: Character space ]! !

"June 4, 2007 -> 1:48:31"!

"System saved" !
"June 4, 2007 -> 2:36:39"!

Delta define: #UnixPlatform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"June 4, 2007 -> 2:36:39"!

(Delta mirrorFor: #UnixPlatform)
comment: 
'The class side holds platform dependent constants and utilities.  Is also used
to get command line args, and other things like that.

Keywords: %machdep  %User

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.4 $
'!


"June 4, 2007 -> 2:36:40"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'platform classes' !
pathClass ^<FilePath class>

    ^Win32FilePath! !

"June 4, 2007 -> 2:36:41"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'platform classes' !
patternClass ^<FilePattern class>

    ^Win32FilePattern! !

"June 4, 2007 -> 2:36:42"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'testing' !
usesCrLfConvention ^<Boolean>

    ^true! !

"June 4, 2007 -> 2:36:42"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'constants' !
multipleMatchWildcardCharacter ^<Character>

    ^$*! !

"June 4, 2007 -> 2:36:43"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'constants' !
singleMatchWildcardCharacter ^<Character>

    ^$?! !

"June 4, 2007 -> 2:36:44"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'constants' !
wordSize ^<Int>
    ^4! !

"June 4, 2007 -> 2:36:45"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'command line' !
getArguments ^<OrdCltn[Str]>

    | line <Str> args <VarOrdCltn[Str]> strm <CharInputStream> |
    line := self getCommandLine.
    args := OrderedCollection[Str] new.
    strm := line readStream.

    [   "skip whitespace"
        [ strm atEnd not and: [ strm peekFor: Character space] ] whileTrue.
        strm atEnd ] whileFalse: [
            args addLast: (self parseArgFrom: strm).        ].
    ^args! !

"June 4, 2007 -> 2:36:46"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'command line' !
getCommandLine
    | p size result |
    p := {{<kernel ExternalProxy GetCommandLineA>getCommandLine}}.
    size := 0.
    [(p byteAt: size) == 0] whileFalse: [ size := size + 1 ].
    result := String new: size.
    1 to: size do: [:index |
       result at: index put: (Character value: (p byteAt: index - 1))
    ].
    ^result! !

"June 4, 2007 -> 2:36:47"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLInitialize
    DLLDict := Dictionary new.
    {{primitiveDLLSetupLookup: self selector: #DLLLookup:in: ifFail: [:err | self error: err]}}! !

"June 4, 2007 -> 2:36:47"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLLibrary: name
    ^DLLDict at: name ifAbsent: [
        DLLDict at: name put: (self DLLLoad: name)
    ]! !

"June 4, 2007 -> 2:36:48"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLLoad: name
    | r n |
    r := ExternalProxy new.
    n := (self DLLMapName: name) asSymbol.
    ^{{primitiveDLLLoad: n result: r ifFail: [ :err | self error: err]}}! !

"June 4, 2007 -> 2:36:49"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLLookup: name <Str> in: library <Str>
    "Convert library into proxy"
    | p r |
    p := self DLLLibrary: library.
    r := ExternalProxy new.
    {{primitiveDLLLookup: name asSymbol in: p result: r ifFail: [:err | self error: err]}}.
    ^r! !

"June 4, 2007 -> 2:36:50"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLMapName: name <Str> ^<Str>
    name = 'user'       ifTrue: [^'USER32.DLL'].
    name = 'gdi'            ifTrue: [^'GDI32.DLL'].
    name = 'kernel'     ifTrue: [^'KERNEL32.DLL'].
    name = 'comdlg'     ifTrue: [^'COMDLG32.DLL'].
    self error: 'Mapping ', name, ' not found'! !

"June 4, 2007 -> 2:36:51"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'initialization' !
initialize

    self DLLInitialize! !

"June 4, 2007 -> 2:36:52"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'os streams' !
errorStream ^<CharOutputStream>

    ErrorStream isNil
        ifTrue: [   ErrorStream := TempTranscript new ].
    ^ErrorStream! !

"June 4, 2007 -> 2:36:53"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'environment' !
environmentVariableAt: key <Str> ifAbsent: blk <[^X def]> ^ <Str | X>

    | cKey <CString> cValue <CString> size <Int> cSize <ExternalProxy> result <Str> done <Boolean> found <Boolean> |
    size := 1024.
    cKey := CString for: key.
    done := false.
    [ done ] whileFalse: [
        cValue := CString for: (String new: size).
        cSize := {{<kernel ExternalProxy GetEnvironmentVariableA> key: cKey buffer: cValue bufSize: size}}.
        cSize asSmallInteger > size
            ifTrue: [   cValue free.                                                    "Buffer size too small for value of variable"
                            size := cSize asSmallInteger ]
            ifFalse: [  done := true.                                                   "Buffer size ok, check if variable was found"
                            (found := cSize asSmallInteger ~= 0)
                                ifTrue: [ result := cValue asString ] ] ].
    cKey free. 
    cValue free.
    ^found
        ifTrue: [ result ]
        ifFalse: blk ! !

"June 4, 2007 -> 2:36:54"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'private-clipboard access' !
closeClipboard

    {{<user ExternalProxy CloseClipboard> call}}! !

"June 4, 2007 -> 2:36:55"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'private-clipboard access' !
emptyClipboard

    {{<user ExternalProxy EmptyClipboard> call}} asBoolean
        ifFalse: [ Win32 handleError ].
! !

"June 4, 2007 -> 2:36:55"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'private-clipboard access' !
openClipboard

    {{<user ExternalProxy OpenClipboard> hnd: Win32 NULL}} asBoolean
        ifFalse: [ Win32 handleError ].
! !

"June 4, 2007 -> 2:36:57"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'clipboard access' !
clipboardText: str <Str>

    self openClipboard.
    [   | glob <HGLOBAL> strm <ReadWriteStream[Character]> xstr <Str> |
        self emptyClipboard.

        "transform string into a form with lfs inserted"
        strm := (String new: str size) readWriteStream.
        str do:
            [ :c <Character> |
                strm put: c.
                c = Character cr
                    ifTrue: [ strm put: Character lf ].
            ].
        xstr := String withAll: strm contentsWritten.

        glob := HGLOBAL new
                        allocate: xstr size + 1
                        attributes: (Win32 GMEM_MOVEABLE
                                            externalBitOr: Win32 GMEM_DDESHARE).
        glob withPointer: CString new
                do: [ :cs <CString> |
                            cs value: xstr   ].

        {{<user ExternalProxy SetClipboardData>
                format: Win32 CF_TEXT
                data: glob
        }} isNull
            ifTrue: [ Win32 handleError ].
    ] ensure:
        [ self closeClipboard ]! !

"June 4, 2007 -> 2:36:58"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'clipboard access' !
clipboardTextIfAbsent: blk <[^X def]> ^<Str | X>

    self openClipboard.
    [   | glob <HGLOBAL> strm <CharWriteStream> |

        {{<user ExternalProxy IsClipboardFormatAvailable> format: Win32 CF_TEXT}} asBoolean
            ifFalse: [ ^blk value ].
        glob := {{<user HGLOBAL GetClipboardData> format: Win32 CF_TEXT}}.
        glob isNull
            ifTrue: [ Win32 handleError ].
        strm := (String new: 100) writeStream.
        glob withPointer: CString new
                do: [ :cs <CString> |
                            cs asString do:
                                [ :c <Character> |
                                    c = Character lf
                                        ifFalse: [ strm put: c ]
                                ].
                            ^strm contentsWritten
                      ].
    ] ensure:
        [ self closeClipboard ]! !

"June 4, 2007 -> 2:36:59"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'private' !
parseArgFrom: strm <CharInputStream>  ^<Str>

    ^strm peek = $"
        ifTrue: [       strm next.
                        strm upTo: $"   ]
        ifFalse: [  strm upTo: Character space ]! !

"June 4, 2007 -> 2:38:38"!

"System saved" !
"June 4, 2007 -> 19:11:14"!

"System saved" !
"June 5, 2007 -> 2:15:5"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'command line' !
getArguments ^<OrdCltn[Str]>

    ^ {{ primitiveCommandLineArgs }}! !

"June 5, 2007 -> 2:16:16"!

"System saved" !
"June 5, 2007 -> 2:21:43"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'command line' !
getArguments ^<OrdCltn[Str]>

    ^ {{ primitiveCommandLineArgs }} asOrderedCollection
    	collect: [:bytes| bytes asString]! !

"June 5, 2007 -> 2:25:28"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'command line' !
getCommandLine
    | stream |
    stream := WriteStream on: ''.
    self getArguments do: [:arg| stream nextPutAll: arg]
    	separatedBy: [stream nextPut: $ ].
    ^stream contents! !

"June 5, 2007 -> 2:33:27"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'command line' !
getCommandLine
    | stream |
    stream := CharacterReadWriteStream on: ''.
    self getArguments do: [:arg| stream nextPutAll: arg]
    	separatedBy: [stream nextPut: $ ].
    ^stream contents! !

"June 5, 2007 -> 2:41:14"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'command line' !
getCommandLine
    | stream |
    stream := CharacterReadWriteStream on: ''.
    self getArguments do: [:arg| stream nextPutAll: arg; space].
    stream isEmpty ifTrue: [^''].
    ^stream copyFrom: 1 to stream size - 1! !

"June 5, 2007 -> 2:42:28"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'command line' !
getCommandLine
    | stream |
    stream := CharacterReadWriteStream on: ''.
    self getArguments do: [:arg| stream nextPutAll: arg; space].
    stream isEmpty ifTrue: [^''].
    ^stream copyFrom: 1 to: stream size - 1! !

"June 5, 2007 -> 2:44:40"!

"System saved" !
"June 5, 2007 -> 21:6:39"!

Delta define: #WinPOINT as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:6:39"!

(Delta mirrorFor: #WinPOINT)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.1 $
'!


"June 5, 2007 -> 21:6:40"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
asPoint ^<Point>
	^self x @ self y! !

"June 5, 2007 -> 21:6:41"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
structureSize ^<Int>
	^8! !

"June 5, 2007 -> 21:6:42"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
x ^<SmallInteger>

	^self smallIntegerAt: self xOffset! !

"June 5, 2007 -> 21:6:42"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
x: v <SmallInteger>

	self smallIntegerAt: self xOffset put: v! !

"June 5, 2007 -> 21:6:43"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
y ^<SmallInteger>

	^self smallIntegerAt: self yOffset! !

"June 5, 2007 -> 21:6:44"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
y: v <SmallInteger>

	self smallIntegerAt: self yOffset put: v! !

"June 5, 2007 -> 21:6:45"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'offsets' !
xOffset ^<Int>
	^0! !

"June 5, 2007 -> 21:6:46"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'offsets' !
yOffset ^<Int>
	^4! !

"June 5, 2007 -> 21:7:0"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:7:2"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:7:2"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:7:2"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:7:2"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:7:2"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:7:2"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:7:2"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:7:2"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:7:2"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:7:2"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:7:3"!

(Delta mirrorFor: #MINMAXINFO)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"June 5, 2007 -> 21:7:3"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'accessing' !
ptMaxSize ^<WinPOINT>

	^self subProxyAt: self ptMaxSizeOffset result: WinPOINT new! !

"June 5, 2007 -> 21:7:4"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'accessing' !
ptMaxTrackSize ^<WinPOINT>

	^self subProxyAt: self ptMaxTrackSizeOffset result: WinPOINT new! !

"June 5, 2007 -> 21:7:5"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'accessing' !
ptMinTrackSize ^<WinPOINT>

	^self subProxyAt: self ptMinTrackSizeOffset result: WinPOINT new! !

"June 5, 2007 -> 21:7:6"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'accessing' !
structureSize ^<Int>

	^40! !

"June 5, 2007 -> 21:7:6"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'offsets' !
ptMaxPositionOffset ^<Int>

	^16! !

"June 5, 2007 -> 21:7:7"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'offsets' !
ptMaxSizeOffset ^<Int>

	^8! !

"June 5, 2007 -> 21:7:8"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'offsets' !
ptMaxTrackSizeOffset ^<Int>

	^32! !

"June 5, 2007 -> 21:7:9"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'offsets' !
ptMinTrackSizeOffset ^<Int>

	^24! !

"June 5, 2007 -> 21:7:10"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'offsets' !
ptReservedOffset ^<Int>

	^0! !

"June 5, 2007 -> 21:7:25"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:7:28"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:7:28"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:7:28"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:7:29"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:7:29"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:7:30"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:7:30"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:7:31"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:7:31"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:7:31"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:7:32"!

(Delta mirrorFor: #Win32Control)
comment: 
'A Visual that has a corresponding native Win32 window.

%optional #commandWith: - should override to process any WM_COMMAND messages needed

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.5 $
'!


"June 5, 2007 -> 21:7:34"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'private' !
controlForHandle: hwnd <ExternalProxy> ifAbsent: b <[^X def]> ^<Win32Control | X>

	^self controlFor: (self controlIdFor: hwnd) ifAbsent: b! !

"June 5, 2007 -> 21:7:35"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'private' !
controls ^<VarDict[Int, Win32Control]>

	"Assumption: allers must be in a critical region for self"

	Controls isNil
		ifTrue: [ Controls := Dictionary[Int, Win32Control] new ].
	^Controls! !

"June 5, 2007 -> 21:7:36"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'private' !
dispatchMsgFor: hwnd <ExternalProxy>
msg: msg <SmallInteger>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^(self controlForHandle: hwnd ifAbsent: [ ^0 ])
		message: msg for: hwnd wParam: wParam lParam: lParam! !

"June 5, 2007 -> 21:7:37"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
assignId ^<Int>
	"Assign and return a unique control id number.  It is assumed that we are already in a
		critical region on the Win32Control."

	MaxControlId isNil
				ifTrue: [ MaxControlId := 1 ]
				ifFalse: [ MaxControlId := MaxControlId + 1].
	^MaxControlId! !

"June 5, 2007 -> 21:7:38"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
buttonColorMsg: hdc <ExternalProxy> for: control <Int> ^<ExternalData>

	^(self controlFor: control  ifAbsent: [ ^0 ]) buttonColorMsg: hdc! !

"June 5, 2007 -> 21:7:39"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
controlFor: id <Int> ifAbsent: b <[^X def]> ^<Win32Control | X>

	^Win32Control
		critical: [	self controls at: id ifAbsent: b ]! !

"June 5, 2007 -> 21:7:40"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
controlIdFor: hwnd <HWND> ^<Int>

	^{{<user ExternalProxy GetWindowLongA> hwnd: hwnd value: Win32 GWL_ID}} asSmallInteger.
! !

"June 5, 2007 -> 21:7:41"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
customWndProc ^<APICallback>

	"Don't need a critical region"
	CustomWndProc isNil
		ifTrue: [	CustomWndProc := APICallBack
							register:
								[ :hwnd <ExternalProxy> :msg <SmallInteger> :wParam <ExternalData> :lParam <ExternalData> |
									self dispatchMsgFor: hwnd msg: msg wParam: wParam lParam: lParam ]
							parameters: (OrderedCollection[Class]
								with: ExternalProxy with: SmallInteger with: ExternalProxy with: ExternalProxy).	].
	^CustomWndProc! !

"June 5, 2007 -> 21:7:42"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
drawItemMsg: data <DRAWITEMSTRUCT> for: control <Int> ^<ExternalData>

	^(self controlFor: control ifAbsent: [ ^0 ]) drawItemMsg: data! !

"June 5, 2007 -> 21:7:43"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
measureItemMsg: data <MEASUREITEMSTRUCT> for: control <Int> ^<ExternalData>

	^(self controlFor: control ifAbsent: [ ^0 ]) measureItemMsg: data! !

"June 5, 2007 -> 21:7:44"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
notificationMsg: notifyCode <ExternalData> for: control <Int>

	(self controlFor: control ifAbsent: [ ^0 ]) notificationMsg: notifyCode! !

"June 5, 2007 -> 21:7:44"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
registerControl: id <Int> for: inst <Win32Control>

	Win32Control critical: 
		[ self controls at: id put: inst	]! !

"June 5, 2007 -> 21:7:45"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
unregisterControl: id <Int>

	Win32Control critical: [ self controls removeKey: id ]! !

"June 5, 2007 -> 21:7:46"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'testing' !
debugEvents ^<Boolean>

	^Session debugEvents! !

"June 5, 2007 -> 21:7:47"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'testing' !
debugNotifications ^<Boolean>

	^false! !

"June 5, 2007 -> 21:7:48"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
backgroundPainter ^<Painter>

	backgroundPainter isNil
		ifTrue: [ ^super backgroundPainter ].
	^backgroundPainter! !

"June 5, 2007 -> 21:7:49"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
enabled ^<Boolean>

	^enabled! !

"June 5, 2007 -> 21:7:50"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
enabled: flag <Boolean>

	self enabled = flag
		ifFalse: [	self setEnabled: flag ].! !

"June 5, 2007 -> 21:7:51"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
fullyEnabled ^<Boolean>

	"is true if we are enabled and all parents are enabled"
	^self enabled and: [ super enabled ]! !

"June 5, 2007 -> 21:7:52"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
nativeWindow ^<Window | Win32Control>

	^self! !

"June 5, 2007 -> 21:7:53"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
redraw ^<Boolean>

	^redraw! !

"June 5, 2007 -> 21:7:54"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'control' !
changing

	"flush the cached background painter so that it updates"
	backgroundPainter := nil.
	
	super changing! !

"June 5, 2007 -> 21:7:55"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'control' !
deferringRedrawDo: blk <[^Object]>
	"defer redrawing during evaluation of blk.  If these calls are nested recursively,
	   redrawing is deferred until the outermost returns, at which point the entire control
	   is invalidated.  This can be used to surround a large number of changes to the receiver
	   that would otherwise cause redundant redrawing."

	| oldFlag <Boolean> |
	oldFlag := self redraw.
	self redraw: false.
	blk value.
	self redraw: oldFlag.
	oldFlag
		ifTrue: [ self invalidate ]! !

"June 5, 2007 -> 21:7:56"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'control' !
ignoreNextFocusSet: flag <Boolean>

	ignoreNextFocusSet := flag! !

"June 5, 2007 -> 21:7:57"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'control' !
release

	self hasWin32Handle
		ifTrue: [ self destroyWin32Handle ].
	super release.! !

"June 5, 2007 -> 21:7:58"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'control' !
visible: flag <Boolean>

	| data <ExternalData> |
	self assert: [ self hasWin32Handle ].

	data := flag ifTrue: [ Win32 SW_SHOW ] ifFalse: [ Win32 SW_HIDE ].
	{{<user ExternalProxy ShowWindow> hwnd: self win32Handle flag: data}}.! !

"June 5, 2007 -> 21:7:59"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'debugging' !
printAllocOn: strm <CharOutputStream>

	super printAllocOn: strm.
	self hasWin32Handle
		ifTrue: [	strm show: ' hwnd: '; print: self win32Handle ]
		ifFalse: [ strm show: ' (no hwnd)' ]! !

"June 5, 2007 -> 21:8:1"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'displaying' !
localDisplayOn: can <Canvas>

	can subwindowsToDisplay add: self! !

"June 5, 2007 -> 21:8:2"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'event handling' !
character: c <Character> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	^(self callOrigWndProcFor: ev msg) = 0! !

"June 5, 2007 -> 21:8:3"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'event handling' !
keyDown: key <Symbol> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	^(self callOrigWndProcFor: ev msg) = 0! !

"June 5, 2007 -> 21:8:4"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'event handling' !
keyUp: key <Symbol> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	^(self callOrigWndProcFor: ev msg) = 0! !

"June 5, 2007 -> 21:8:5"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'event handling' !
mouseEvent: type <Symbol> at: loc <Point> event: ev <UIEvent> ^<Boolean>

	| orig <Point> |

	"Translate location back into native window coordinates"
	orig := self allocation enclosingRect origin.
	^(self callOrigWndProcFor: ev msg withLParam: (ExternalProxy forHigh: loc y - orig y low: loc x - orig x)) = 0! !

"June 5, 2007 -> 21:8:6"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'geometry-local' !
allocation: r <Region> at: pos <Point>

	| oldAlloc <Region> alloc <Rect> oldLayoutStatus <Int> |
	oldLayoutStatus := self layoutStatus.
	oldAlloc := allocation.
	alloc := r enclosingRect.
	super allocation: r at: pos.

	oldAlloc isNil
		ifTrue: [ self win32Handle.		"Make sure window is created with the current allocation & position" ]
		ifFalse: [	| oldNativePos <Point> old <Rect> | 
						"We need to use a variable since pos...Window changes nativePos"
						old := oldAlloc enclosingRect.
						oldNativePos := nativePosition.
						self hasWin32Handle
							ifTrue: [	(old width ~= alloc width
													or: [ old height ~= alloc height
													or: [ oldNativePos ~= self nativePosition ]  ] )
												ifTrue: [  self updateWindowDimensions  ]	 ]
							ifFalse: [	self isAttached
												ifTrue: [ self win32Handle ]	] ].
	"Invalidate if we are relaying out as a %hack to solve the problems that a higher level
		relayoutAndInvalidate doesn't invalidate contained native windows like this one"
	oldLayoutStatus = Visual needsRelayout
		ifTrue: [ self invalidate ]! !

"June 5, 2007 -> 21:8:7"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'geometry-nonlocal' !
moveBy: positionDelta <Point>

	"We override this since moving a native visual will generate any needed invalidations
	  automatically."

	self adjustPositionBy: positionDelta! !

"June 5, 2007 -> 21:8:8"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'initialization' !
initialize

	super initialize.
	redraw := true.
	enabled := true.
	isFocus := false.
	self addNonLocalCount: 1.		"Receiver is non-local"
	ignoreNextFocusSet := false.

	self refreshInterval: self defaultRefreshInterval.
	self paintPending: false.
	self useDisplayBuffering: true.
	controls := IdentitySet[Win32Control] new.! !

"June 5, 2007 -> 21:8:10"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
checkPaintTime: t <Float>
	"If we have reached our refresh time, paint"

	(self hasWin32Handle and: [ self paintPending ])
		ifTrue: [ self nextPaintTime <= t
						ifTrue: [ self display ]
						ifFalse: [ self session needPaintAtTime: self nextPaintTime ]	 ]! !

"June 5, 2007 -> 21:8:11"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
controls ^<Extensible[Win32Control]>

	^controls! !

"June 5, 2007 -> 21:8:12"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
cursor ^<Cursor>

	^cursor! !

"June 5, 2007 -> 21:8:13"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
cursor: c <Cursor>

	cursor := c.! !

"June 5, 2007 -> 21:8:14"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
defaultRefreshInterval ^<Float>

	^0.25! !

"June 5, 2007 -> 21:8:15"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
globalFromLocalPosition: p <WinPOINT> ^<WinPOINT>

	| wp <WinPOINT> result <WinPOINT> |
	wp := WinPOINT new allocate.
	wp x: p x; y: p y.
	{{<user ExternalProxy ClientToScreen>
			handle: self win32Handle
			point: wp
	}} asBoolean
		ifFalse: [ Win32 handleError ].
	result := wp x @ wp y.
	wp free.
	^result! !

"June 5, 2007 -> 21:8:16"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
handleMouseEvent: type <Symbol> at: loc <Point> ^<Boolean>

	| ev <UIEvent> |

	"%todo: remove the dispatch block for all events; isn't needed anymore"
	ev := UIEvent
			forMsg: self session currentMsg
			dispatch:
				[ :e <UIEvent> :h <UIEventHandler> |
					h mouseEvent: type at: loc event: e ].
	Sampler notNil
		ifTrue: [ Sampler 
						in: self topWindow visual 
						sampleEvent: type 
						at: (loc translatedBy: self positionInTopWindow)
						event: ev ].
	^self mouseEvent: type at: loc event: ev! !

"June 5, 2007 -> 21:8:17"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
localFromGlobalPosition: p <WinPOINT> ^<WinPOINT>

	| wp <WinPOINT> result <WinPOINT> |
	wp := WinPOINT new allocate.
	wp x: p x; y: p y.
	{{<user ExternalProxy ScreenToClient>
			handle: self win32Handle
			point: wp
	}} asBoolean
		ifFalse: [ Win32 handleError ].
	result := wp x @ wp y.
	wp free.
	^result translatedBy: self allocation enclosingRect origin! !

"June 5, 2007 -> 21:8:18"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
nextPaintTime ^<Float>

	^nextPaintTime! !

"June 5, 2007 -> 21:8:19"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
nextPaintTime: t <Float>

	nextPaintTime := t! !

"June 5, 2007 -> 21:8:20"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
noPalette

	palette := nil! !

"June 5, 2007 -> 21:8:21"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
paintOccuring

	self nextPaintTime: Time clockValue + self refreshInterval.
	self paintPending: false.
	self session paintOccuredFor: self.! !

"June 5, 2007 -> 21:8:22"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
paintPending ^<Boolean>

	^paintPending! !

"June 5, 2007 -> 21:8:23"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
paintPending: b <Boolean>

	paintPending := b! !

"June 5, 2007 -> 21:8:24"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
palette ^<Palette>

	^palette! !

"June 5, 2007 -> 21:8:25"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
palette: p <Palette>

	p == palette
		ifTrue: [ ^self ].
	self assert: [ palette isNil ].
	palette := p! !

"June 5, 2007 -> 21:8:26"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
paletteChangedMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	wParam @= self win32Handle
		ifFalse: [ self recursiveRealizePaletteForeground: false updateColors: true.
						self palette isNil
							ifTrue: [ ^self callDefWndProcFor: hwnd
											msgCode: msg
											wParam: wParam
											lParam: lParam	].
					 ].
	^0! !

"June 5, 2007 -> 21:8:28"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
queryPaletteMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self recursiveRealizePaletteForeground: true updateColors: false.
	self palette isNil
		ifTrue: [ ^self callDefWndProcFor: hwnd
						msgCode: msg
						wParam: wParam
						lParam: lParam	].
	^0! !

"June 5, 2007 -> 21:8:29"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
recursiveRealizePaletteForeground: fore <Boolean> updateColors: update <Boolean>

	self palette isNil
		ifFalse: [	self withDCDo:
							[ :hdc <HDC> |
								| oldpal <Win32Handle> |
								oldpal := Palette select: self palette win32Handle into: hdc background: fore not.
								self palette unrealize.
								self palette realizeFor: hdc.
								Palette debugging
									ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
								Palette select: oldpal win32Handle into: hdc background: fore not.
							 ].
						self invalidate.
						].
	self controls do:
		[ :c <Win32Control> |
			c recursiveRealizePaletteForeground: fore updateColors: update ].! !

"June 5, 2007 -> 21:8:30"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
refreshInterval ^<Float>

	^refreshInterval! !

"June 5, 2007 -> 21:8:31"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
refreshInterval: d <Float>
	"Wait no longer than this amount of time (in seconds) between
		paint operations, if possible"

	refreshInterval := d! !

"June 5, 2007 -> 21:8:32"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
registerControl: c <Win32Control>

	self controls include: c! !

"June 5, 2007 -> 21:8:33"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
registerPaintTime

	self paintPending
		ifFalse: [	self paintPending: true.
						self nextPaintTime: Time clockValue + self refreshInterval.
						self session schedulePaintFor: self at: self nextPaintTime.	].! !

"June 5, 2007 -> 21:8:34"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
setCursor ^<ExternalData>

	^cursor isNil
		ifFalse: [	{{<user ExternalProxy SetCursor> handle: cursor win32Handle}}.
						1 ]
		ifTrue: [ 0 ]! !

"June 5, 2007 -> 21:8:35"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
setCursorMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^(cursor notNil
			and: [	| hitcode <Int> |
						hitcode := lParam asExternalProxy low.
						hitcode = 1 or: [ hitcode = 65534 ] "client area or disabled"  ])
		ifTrue: [ 	self setCursor.
						1 ]
		ifFalse: [ self callOrigWndProc: msg wParam: wParam lParam: lParam ]
! !

"June 5, 2007 -> 21:8:36"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
showTimes ^<Boolean>
	"Report preference, layout, and painting times on the transcript"

	^false! !

"June 5, 2007 -> 21:8:37"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
unregisterControl: c <Win32Control>

	self controls removeEvery: c! !

"June 5, 2007 -> 21:8:38"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
useDisplayBuffering ^<Boolean>

	^useDisplayBuffering! !

"June 5, 2007 -> 21:8:39"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
useDisplayBuffering: f <Boolean>

	useDisplayBuffering := f! !

"June 5, 2007 -> 21:8:41"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
withBufferedCanvasDo: drawing <[Canvas,^X def]> ^<X>

	^self withDirectCanvasDo:
		[ :directCanvas <Canvas> |
			| invalid <Rect> oldpal <Win32Handle> |
			invalid := directCanvas clippingRect.

			self session
				withBufferCanvasFor: invalid
				do: [ :bufferCanvas <Canvas> :buffer <HBITMAP> |
							self palette isNil
								ifFalse: [ oldpal := bufferCanvas win32Palette: self palette win32Handle ].

							"draw on the buffer canvas"
							drawing value: bufferCanvas.
							bufferCanvas shallowFlush.

							"Now, copy the buffer bits onto the screen"
							directCanvas atOffset: invalid origin
								do: [ bufferCanvas atOffset: invalid origin 
									do: [	directCanvas
													bitBlt: bufferCanvas
												extent: invalid extent
												op: UI ropCopy.		].	].
							oldpal notNil
								ifTrue: [ 	Palette debugging
													ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
												bufferCanvas win32Palette: oldpal ]. 
						].	
		]! !

"June 5, 2007 -> 21:8:42"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
withCanvasDo: drawing <[Canvas,^X def]> ^<X>

	^(self useDisplayBuffering and: [ Window bufferingPossible ])
		ifFalse: [	self withDirectCanvasDo: drawing ]
		ifTrue: [	self withBufferedCanvasDo: drawing ]! !

"June 5, 2007 -> 21:8:43"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
withDCDo: blk <[HDC]>
	"With the window's device context do the block (not for painting)"

	| hdc <HDC> |
	hdc := {{<user HDC GetDC> hwnd: self win32Handle}}.
	[ blk value: hdc ]
		ensure: [ hdc releaseDCFor: self win32Handle ]! !

"June 5, 2007 -> 21:8:45"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
withDirectCanvasDo: drawing <[Canvas,^X def]> ^<X>

	|	can <Canvas>
		ps <PAINTSTRUCT>
		paintBlk <[^Object]>
		result <X>
		oldpal <Win32Handle>  |

	"use a critical region to paint, since background painting might reuse the
	  same device context in the UI thread"
	^self critical:
		[	ps := PAINTSTRUCT new allocateZeroed.
			can := self beginPaint: self win32Handle paintStructure: ps.
			can isNull
				ifTrue: [ Win32 handleError ].
			can	initialize;
				toRelease: [ :dc <HDC> | "End paint will release the context" ];
				initClippingRectBeforeTranslation: ps rcPaint asRectangle;
				window: self.
			self palette isNil
				ifFalse: [ oldpal := can win32Palette: self palette win32Handle ].

			Session debugInvalidation
				ifTrue: [	can withPainter: (Painter new paint: Paint red)
									do: [ can displayFilledRectangle: ps rcPaint asRectangle; flush. ].
								Platform errorStream show: self class name, ' rendering: '; print: ps rcPaint asRectangle; cr.	].

			result := drawing value: can.
			oldpal notNil
				ifTrue: [ 	Palette debugging
									ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
								can win32Palette: oldpal ]. 
			can release. 

			self endPaint: self win32Handle paintStructure: ps.
			ps free.
			result	]! !

"June 5, 2007 -> 21:8:46"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Windows with mods' !
display

	"win32 controls do no Smalltalk level painting by default"! !

"June 5, 2007 -> 21:8:47"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'notification' !
detaching

	super detaching.
	self cleanUp! !

"June 5, 2007 -> 21:8:48"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'notification' !
isFocus: f <Boolean>

	isFocus := f.
	super isFocus: f.
! !

"June 5, 2007 -> 21:8:49"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'notification' !
nativePositionChanged

	"DON'T pass this message to super, since our children are native relative to us!!"

	(self checkForNativePositionChanging or: [ self isAttached ])
		ifTrue: [ self updateWindowDimensions ]! !

"June 5, 2007 -> 21:8:50"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
buildWin32Handle

	self subclassResponsibility! !

"June 5, 2007 -> 21:8:51"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
callOrigWndProc: msgCode <ExternalData> wParam: wParam <ExternalData> lParam: lParam <ExternalData>^<ExternalData>
	"Like callOrigWndProcFor:, but takes all args rather than using a MSG structure"

	"Note that we use the receiver's win32Handle below rather than the one in the message so
	 	 this works even when the event was generated during a grab"
	^{{<user ExternalProxy CallWindowProcA> 
		proc: self originalWndProc
		hwnd: self win32Handle
		msg: msgCode
		wparam: wParam
		lparam: lParam }}! !

"June 5, 2007 -> 21:8:52"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
callOrigWndProcFor: m <MSG> ^<ExternalData>

	"Note that we use the receiver's win32Handle below rather than the one in the message so
	 	 this works even when the event was generated during a grab"
	^{{<user ExternalProxy CallWindowProcA> 
		proc: self originalWndProc
		hwnd: self win32Handle
		msg: m message
		wparam: m wParam
		lparam: m lParam }}! !

"June 5, 2007 -> 21:8:53"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
callOrigWndProcFor: m <MSG> withLParam: lParam <ExternalData>^<ExternalData>
	"Like callOrigWndProcFor:, but overrides the lParam value from the msg"

	"Note that we use the receiver's win32Handle below rather than the one in the message so
	 	 this works even when the event was generated during a grab"
	^{{<user ExternalProxy CallWindowProcA> 
		proc: self originalWndProc
		hwnd: self win32Handle
		msg: m message
		wparam: m wParam
		lparam: lParam }}! !

"June 5, 2007 -> 21:8:54"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
canBeFocusCandidate ^<Boolean>
	"%optional: Subclasses that cannot be the input focus even when they are enabled should override this
	  to return false"

	^true! !

"June 5, 2007 -> 21:8:55"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
checkForNativePositionChanging ^<Boolean>
	"returns true if the native position has been changed"

	
	^self hasWin32Handle
			and: [	| oldpos <Point> |
						oldpos := nativePosition.
						oldpos ~= self nativePosition	]! !

"June 5, 2007 -> 21:8:56"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
cleanUp

	self isFocus
		ifTrue: [	self nativeWindow ignoreNextFocusSet: true.
						self session noInputFocus. ].
	self destroyWin32Handle.
! !

"June 5, 2007 -> 21:8:57"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
controlId ^<Int>

	^controlId! !

"June 5, 2007 -> 21:8:58"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
createNativeWindow

	"we need a critical region to protect the class variable:"
	Win32Control
		critical: [	controlId := self actualClass assignId.
							self actualClass registerControl: self controlId for: self.
							self paintPending: false.
							self buildWin32Handle.
							self palette notNil
								ifTrue: [ self recursiveRealizePaletteForeground: true updateColors: true. ].
							self nativeWindow registerControl: self.
	
							self originalWndProc: (self wndProc).
							self wndProc: self customWndProc.
							self isFocus
								ifTrue: [ self setFocus ].
						].! !

"June 5, 2007 -> 21:8:59"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
createVisible ^<Boolean>

	^true! !

"June 5, 2007 -> 21:9:0"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
customWndProc ^<APICallback>

	^self actualClass customWndProc! !

"June 5, 2007 -> 21:9:1"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
debugTest: msgCode <ExternalData> for: hwnd <ExternalData>

	Win32Control debugEvents
			ifTrue: [	Platform errorStream
									show: 'control winproc event: ';
									show: (MSG descriptionOf: msgCode asExternalProxy);
									show: ' window: ';
									print: hwnd;
									cr. 	].! !

"June 5, 2007 -> 21:9:2"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
destroyWin32Handle

	win32Handle notNil
		ifTrue: [	| hand <ExternalProxy> |
						self actualClass unregisterControl: self controlId.
						self nativeWindow unregisterControl: self.
						hand := self win32Handle.
						win32Handle := nil.		"We nil the handle before destroying so that we can tell
																we are dead if there is a focus shift caused by destroy"
						{{<user ExternalProxy DestroyWindow>
							handle: hand }}.		]! !

"June 5, 2007 -> 21:9:3"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
displayUpwardPopUpMenuAt: loc <Point> ^<Boolean>
	"Look up the parent chain for a popUp menu and display it, if there is one.
		Return true if one was found"

	| m <Menu> t <Timer> |
	m := self parent popUpMenuIfAbsent: [ ^false ].
	self	displayPopUpMenu: m
			at: loc
			forButton: #secondary.
	t := self session atIntervals: 1.0 do:
			[	m release.
				t release. ].
	^true! !

"June 5, 2007 -> 21:9:4"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
extendedWin32Style ^<ExternalData>

	^Win32 WS_EX_NOPARENTNOTIFY! !

"June 5, 2007 -> 21:9:6"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
handleMouseEvent: type <Symbol>
message: msgCode <ExternalData>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>

	| loc <Point> |
	"Translate to be relative to our origin"
	loc := (lParam low @ lParam high) + self allocation enclosingRect origin.
	self handleMouseEvent: type at: loc! !

"June 5, 2007 -> 21:9:7"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
hasWin32Handle ^<Boolean>

	^win32Handle notNil! !

"June 5, 2007 -> 21:9:8"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
invalidate: r <Region>

	self registerPaintTime.
	(self layoutStatus = Visual valid and: [ self hasWin32Handle ])
		ifTrue: [	| rect <Rect> nativerect <RECT> |

						nativerect := RECT new allocate.
						rect := r enclosingRect relativeTo: self allocation origin.
						nativerect
							left: rect left asInteger;
							right: rect right asInteger;
							top: rect top asInteger;
							bottom: rect bottom asInteger.
						{{<user ExternalProxy InvalidateRect>
							hwnd: self win32Handle
							RECT: nativerect
							erase: true}}.
						nativerect free.	]! !

"June 5, 2007 -> 21:10:22"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
nativePosition ^<Point>

	"We have to adjust for the fact that our allocation origin might not be 0@0"
	^nativePosition := self positionInContainingNativeWindow + self allocation enclosingRect origin! !

"June 5, 2007 -> 21:10:23"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
originalWndProc ^<HWND>

	^originalWndProc! !

"June 5, 2007 -> 21:10:23"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
originalWndProc: h <HWND>

	originalWndProc := h! !

"June 5, 2007 -> 21:10:25"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
redraw: flag <Boolean>
	"Tell the widget to start or stop redrawing (temporarily) when necessary.  This is usually used
		with a true arg before a large number of changes, followed by a send with a false arg."

	flag = self redraw
		ifFalse: [	redraw := flag.
						self hasWin32Handle
							ifTrue: [	self	sendMessage: Win32 WM_SETREDRAW
													wparam: flag asExternalData
													lparam: 0	]].! !

"June 5, 2007 -> 21:10:26"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
setEnabled: flag <Boolean>

	enabled := flag.
	win32Handle notNil
		ifTrue: [	{{<user ExternalProxy EnableWindow>
								handle: self win32Handle
								state: self fullyEnabled asExternalData}}.	].
! !

"June 5, 2007 -> 21:10:27"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
setWindowText: t <Str>

	| label <CString> |
	label := CString for: t.
	{{<user ExternalProxy SetWindowText>
		handle: self win32Handle
		str: label}}.
	label free.! !

"June 5, 2007 -> 21:10:28"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
updateWindowDimensions
	"set the control's native size and position"

	| pos <Point> |

	pos := self nativePosition.
	self paintPending: false.
	{{<user ExternalProxy MoveWindow>
		handle: self win32Handle
		x: pos x asInteger
		y: pos y asInteger
		width: self allocation enclosedRect width asInteger
		height: self allocation enclosedRect height asInteger
		repaint: true asExternalData
	 }} asBoolean
			ifFalse: [ Win32 handleError ]! !

"June 5, 2007 -> 21:10:29"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
win32Style ^<ExternalData>

	| s <ExternalData> |
	s := Win32 WS_CHILDWINDOW.
	self createVisible
		ifTrue: [ s := s externalBitOr: Win32 WS_VISIBLE. ].
	self fullyEnabled
		ifFalse: [ s := s externalBitOr: Win32 WS_DISABLED ].
	^s! !

"June 5, 2007 -> 21:10:30"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
wndProc ^<ExternalProxy>

	^Window wndProcOf: self win32Handle! !

"June 5, 2007 -> 21:10:31"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
wndProc: wp <ExternalProxy>

	Window wndProcOf: self win32Handle put: wp! !

"June 5, 2007 -> 21:10:32"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private-message handling' !
beforeKillFocus

	(self session hasInputFocus and: [ self session inputFocus nativeWindow = self ])
		ifTrue: [ self session noInputFocus ].! !

"June 5, 2007 -> 21:10:33"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private-message handling' !
beforeSetFocus

	ignoreNextFocusSet
		ifTrue: [	"We requested the focus, and have already recorded it, so
							ignore this."
						ignoreNextFocusSet := false.	]
		ifFalse: [	"We didn't request this, so windows must be requesting it, so
							record it"
						"We don't use becomeFocus here because that would cause another
							windows setFocus message"
						self session inputFocus: self.		]! !

"June 5, 2007 -> 21:10:34"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private-message handling' !
contextMenuMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<Boolean>

	^self displayUpwardPopUpMenuAt:
			(self localFromGlobalPosition: lParam low @ lParam high)! !

"June 5, 2007 -> 21:10:35"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private-testing' !
isFocusCandidate ^<Boolean>

	^self canBeFocusCandidate
		and: [ self hasWin32Handle
		and: [ self enabled ] ]! !

"June 5, 2007 -> 21:10:36"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private-testing' !
isRectangularAndOpaque ^<Boolean>

	^true! !

"June 5, 2007 -> 21:10:37"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-to session' !
blinkFocus: shown <Boolean>
	
! !

"June 5, 2007 -> 21:10:39"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
buttonColorMsg: hdc <ExternalProxy> ^<ExternalData>

	"Should only get sent to buttons, which override this"
	self shouldNotHappen! !

"June 5, 2007 -> 21:10:40"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
commandWith: notifyCode <ExternalData> ^<ExternalData>

	"Subclasses should override to process command msgs"! !

"June 5, 2007 -> 21:10:41"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
drawItemMsg: data <DRAWITEMSTRUCT> ^<ExternalData>

	self shouldNotHappen! !

"June 5, 2007 -> 21:10:42"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
hInstance ^<ExternalProxy>

	^self parent nativeWindow hInstance! !

"June 5, 2007 -> 21:10:43"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
measureItemMsg: data <MEASUREITEMSTRUCT> ^<ExternalData>

	self shouldNotHappen! !

"June 5, 2007 -> 21:10:44"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
message: msgCode <ExternalData>
for: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self debugTest: msgCode for: hwnd.

	(self session handleIfFocusMsg: msgCode for: self wParam: wParam lParam: lParam) = 0
		ifTrue: [ ^0 ].

	msgCode @= Win32 WM_LBUTTONDOWN 
		ifTrue: [	self handleMouseEvent: #primaryButtonDown
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_LBUTTONUP 
		ifTrue: [	self handleMouseEvent: #primaryButtonUp
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_LBUTTONDBLCLK
		ifTrue: [	self handleMouseEvent: #primaryButtonDoubleClick
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_RBUTTONDOWN 
		ifTrue: [	self handleMouseEvent: #secondaryButtonDown
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_RBUTTONUP 
		ifTrue: [	self handleMouseEvent: #secondaryButtonUp
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_RBUTTONDBLCLK
		ifTrue: [	self handleMouseEvent: #secondaryButtonDoubleClick
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_MOUSEMOVE 
		ifTrue: [	self handleMouseEvent: #mouseMove
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].

	msgCode @= Win32 WM_CTLCOLORBTN
		ifTrue: [ ^Win32Control buttonColorMsg: wParam asExternalProxy for: (Win32Control controlIdFor: lParam) ].

	msgCode @= Win32 WM_DRAWITEM
		ifTrue: [	^Win32Control drawItemMsg: (DRAWITEMSTRUCT forProxy: lParam) for: wParam asSmallInteger ].

	msgCode @= Win32 WM_MEASUREITEM
		ifTrue: [	| data <MEASUREITEMSTRUCT> |
						data := MEASUREITEMSTRUCT forProxy: lParam.
						data CtlType @= Win32 ODT_MENU
							ifFalse: [ ^Win32Control measureItemMsg: data for: data CtlID asSmallInteger ] ].

	(msgCode @= Win32 WM_COMMAND and: [ lParam @~= Win32 NULL ])
		ifTrue: [	"Then this is a control window notification, which should be forwarded back to the
						  smalltalk control object"
						Win32Control notificationMsg: wParam asExternalProxy high for: (Win32Control controlIdFor: lParam).
						^0 ].

	msgCode @= Win32 WM_SETFOCUS
		ifTrue: [ self beforeSetFocus ].
	msgCode @= Win32 WM_KILLFOCUS
		ifTrue: [ self beforeKillFocus ].

	msgCode @= Win32 WM_CONTEXTMENU
		ifTrue: [ (self contextMenuMsg: msgCode hwnd: hwnd wParam: wParam lParam: lParam)
						ifTrue: [ ^0 ]. ].

	msgCode @= Win32 WM_QUERYNEWPALETTE 
		ifTrue: [	self queryPaletteMsg: msgCode hwnd: hwnd
								wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_PALETTECHANGED 
		ifTrue: [	self paletteChangedMsg: msgCode hwnd: hwnd
								wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_SETCURSOR 
		ifTrue: [	^self setCursorMsg: msgCode hwnd: hwnd
								wParam: wParam lParam: lParam	 ].

	^{{<user ExternalProxy CallWindowProcA> 
		proc: self originalWndProc
		hwnd: hwnd
		msg: msgCode
		wparam: wParam
		lparam: lParam }}! !

"June 5, 2007 -> 21:10:46"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
notificationMsg: notifyCode <ExternalData>

	"Subclasses can extend to process notification msgs"

	Win32Control debugNotifications
			ifTrue: [ Platform errorStream
							show: 'control notification: ';
							print: notifyCode;
							show: ' window: ';
							print: self win32Handle;
							cr ].

	notifyCode @= Win32 BN_KILLFOCUS
		ifTrue: [ "%todo" ].
	notifyCode @= Win32 BN_SETFOCUS
		ifTrue: [ "%todo" ].
! !

"June 5, 2007 -> 21:10:47"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
sendMessage: msg <ExternalData>
wparam: wp <ExternalData>
lparam: lp <ExternalData>
^<ExternalProxy>

	^{{<user ExternalProxy SendMessageA>
			handle: self win32Handle
			msg: msg
			wparam: wp
			lparam: lp}}! !

"June 5, 2007 -> 21:10:48"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
setFocus

	ignoreNextFocusSet := true.
	 self win32Handle @= {{<user ExternalProxy GetFocus> call}}
		ifFalse: [  {{<user ExternalProxy SetFocus> hwnd: self win32Handle}} ]! !

"June 5, 2007 -> 21:10:49"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
win32Handle ^<HWND>

	win32Handle isNil	
		ifTrue: [ self createNativeWindow ].
	^win32Handle! !

"June 5, 2007 -> 21:10:50"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'testing' !
isFocus ^<Boolean>

	^isFocus! !

"June 5, 2007 -> 21:14:43"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 21:14:45"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 21:14:46"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 21:14:46"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 21:14:47"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 21:14:48"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 21:14:49"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 21:14:49"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 21:14:50"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 21:14:50"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 21:14:51"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 21:14:52"!

(Delta mirrorFor: #Window)
comment: 
'Native windows, with a fairly machine independent interface
(except for methods with ''win32'' in their names).

Tags: %User %UI

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.
'!


"June 5, 2007 -> 21:14:54"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'custom messages' !
LAYOUT ^<ExternalData>
	"This is by the UI thread to tell a window's session process to layout a window.  This has
	  to be done through the message queue so that the layout code runs in the window's session
	  process.  lParam low is width, and lParam high is height."

	^16r400! !

"June 5, 2007 -> 21:14:55"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'debugging' !
bufferingPossible ^<Boolean>

	BufferingPossible isNil
		ifTrue: [ BufferingPossible := true ].
	^BufferingPossible! !

"June 5, 2007 -> 21:14:56"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'debugging' !
bufferingPossible: f <Boolean>
	"If this is set to false, all double buffering will be disabled, usually for debugging
		purposes."

	BufferingPossible := f! !

"June 5, 2007 -> 21:14:57"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
defaultWin32Cursor ^<ExternalProxy>

	^{{<user ExternalProxy LoadCursorA> arg: 0 arg: Win32 IDC_ARROW}}! !

"June 5, 2007 -> 21:14:58"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
defaultWin32Icon ^<ExternalProxy>

	^{{<user ExternalProxy LoadIconA> arg: 0 arg: Win32 IDI_APPLICATION}}! !

"June 5, 2007 -> 21:14:59"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
defaultWndProc ^<ExternalProxy>

	"Don't need a critical region because duplicate inits are no problem"
	DefaultWndProc isNil
		ifTrue: [	DefaultWndProc := Platform DLLLookup: 'DefWindowProcA' in: 'user' ].
	^DefaultWndProc! !

"June 5, 2007 -> 21:15:0"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
parentOf: w <HWND> ^<HWND>

	^{{<user ExternalProxy GetParent> wnd: w}}! !

"June 5, 2007 -> 21:15:1"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
wndProcOf: w <HWND> ^<HWND>

	^{{<user ExternalProxy GetWindowLongA> wnd: w attr: Win32 GWL_WNDPROC}}! !

"June 5, 2007 -> 21:15:2"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
wndProcOf: w <HWND> put: newWinProc <HWND> ^<HWND>

	^{{<user ExternalProxy SetWindowLongA> wnd: w attr: Win32 GWL_WNDPROC value: newWinProc}}! !

"June 5, 2007 -> 21:15:3"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
addNonLocalCount: delta <Int>
	
	! !

"June 5, 2007 -> 21:15:4"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
containerBackgroundPainter ^<Painter>

	^Painter defaultBackground! !

"June 5, 2007 -> 21:15:5"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
containsFocus: flag <Boolean>

	flag
		ifTrue: [	self session activeWindow: self.
						self mostRecentInputFocus: session inputFocus.	].
	"We don't need to remove the active window ifFalse because the session does that"! !

"June 5, 2007 -> 21:15:6"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
displayNowIfInvalid
	"Redraw any invalid areas before proceeded"

	self display! !

"June 5, 2007 -> 21:15:7"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
displayPopUpMenu: menu <Menu> at: loc <Point> forButton: button <Symbol>

	| gloc <Point> flags <ExternalData> |
	popUpMenu := menu.

	flags := Win32 TPM_LEFTALIGN.
	button = #left
		ifTrue: [ flags := flags externalBitOr: Win32 TPM_LEFTBUTTON ]
		ifFalse: [ flags := flags externalBitOr: Win32 TPM_RIGHTBUTTON ].

	gloc := self globalFromLocalPosition: loc.
	{{<user ExternalProxy TrackPopupMenu>
		handle: menu win32Handle
		flags: flags
		x: gloc x
		y: gloc y
		reserved: 0
		window: self win32Handle
		rect: Win32 NULL
	}} asBoolean
		ifFalse: [ Win32 getLastError @= Win32 ERROR_POPUP_ALREADY_ACTIVE
							ifFalse: [ Win32 handleError ].
						].

	popUpMenu := nil.
! !

"June 5, 2007 -> 21:15:9"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
invalidate: r <Region> forChild: child <Visual>

	self invalidate: (r enclosingRect translatedBy: child position)! !

"June 5, 2007 -> 21:15:10"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
isAttached ^<Boolean>

	^true! !

"June 5, 2007 -> 21:15:11"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
nativeWindow ^<Window | Win32Control>

	^self! !

"June 5, 2007 -> 21:15:12"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
parentVisualOfChild ^<Visual>

	self shouldNotHappen! !

"June 5, 2007 -> 21:15:13"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
popUpMenuIfAbsent: f <[^X def]> ^<Menu | X>

	^f value! !

"June 5, 2007 -> 21:15:15"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
positionInContainingNativeWindowOf: child <Visual> ^<Point>

	^child position! !

"June 5, 2007 -> 21:15:16"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
positionInTopWindowOf: child <Visual>

	^child position! !

"June 5, 2007 -> 21:15:17"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
scrollIfNeededToMakeVisible: area <Rect>
relativeTo: v <Visual>
minimizeMotion: minimizeMotion <Boolean>


	! !

"June 5, 2007 -> 21:15:18"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
scrollMeOrAParentBy: distance <Int> vertical: vertical <Boolean>

	"do nothing"! !

"June 5, 2007 -> 21:15:19"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
topWindow ^<Window>

	^self! !

"June 5, 2007 -> 21:15:20"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
translate: p <Point> fromChild: child <Visual> ^<Point>

	"Translate p from the child's coordinates to ours"
	^p translatedBy: child position! !

"June 5, 2007 -> 21:15:21"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
translate: p <Point> toChild: child <Visual> ^<Point>

	"Translate p from our coordinates to the child's"
	^p relativeTo: child position! !

"June 5, 2007 -> 21:15:23"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
translateRect: r <Rect> fromChild: child <Visual> ^<Rect>

	"Translate p from the child's coordinates to ours"
	^r translatedBy: child position! !

"June 5, 2007 -> 21:15:24"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
translateRect: r <Rect> toChild: child <Visual> ^<Rect>

	"Translate p from the child's coordinates to ours"
	^r relativeTo: child position! !

"June 5, 2007 -> 21:15:25"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
allocation ^<Region>

	^Point origin corner: self extent! !

"June 5, 2007 -> 21:15:27"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
backgroundPainter ^<Painter>
	"The paint for the window background.  This can be automatically derived from the
	 background painter for the visual.  It can also be set explicitly."

	^self hasBackgroundPainter
		ifTrue: [ backgroundPainter ]
		ifFalse: [ backgroundPainter := self visual backgroundPainter ]! !

"June 5, 2007 -> 21:15:28"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
backgroundPainter: p <Painter>

	backgroundPainter := p! !

"June 5, 2007 -> 21:15:29"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
cursor ^<Cursor>

	^cursor! !

"June 5, 2007 -> 21:15:30"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
cursor: c <Cursor>

	cursor := c.! !

"June 5, 2007 -> 21:15:31"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
desiredPosition: p <Point>

	desiredPosition := p! !

"June 5, 2007 -> 21:15:32"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
enabled ^<Boolean>

	^enabled! !

"June 5, 2007 -> 21:15:34"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
enabled: flag <Boolean>

	self enabled = flag
		ifFalse: [	self setEnabled: flag ].! !

"June 5, 2007 -> 21:15:35"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
extent ^<Point>

	^extent! !

"June 5, 2007 -> 21:15:36"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
hasParent ^<Boolean>

	^parent notNil! !

"June 5, 2007 -> 21:15:37"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
hasSession ^<Session>

	^session notNil! !

"June 5, 2007 -> 21:15:38"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
hasWin32Handle ^<Boolean>

	^win32Handle notNil! !

"June 5, 2007 -> 21:15:39"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
initialInputFocus: v <Visual>

	initialInputFocus := v! !

"June 5, 2007 -> 21:15:41"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
max ^<Rect>

	^max! !

"June 5, 2007 -> 21:15:42"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
medium ^<Medium>

	^medium! !

"June 5, 2007 -> 21:15:43"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
menu ^<Menu>

	^menu! !

"June 5, 2007 -> 21:15:44"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
menu: m <Menu>

	menu isNil
		ifFalse: [ menu release ].
	menu := m.
	menu window: self.
	self hasWin32Handle
		ifTrue: [ self setNativeMenu ]! !

"June 5, 2007 -> 21:15:45"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
min ^<Rect>

	^min! !

"June 5, 2007 -> 21:15:47"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
mostRecentInputFocus: v  <Visual>

	mostRecentInputFocus := v! !

"June 5, 2007 -> 21:15:48"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
name: nm <Str>

	"By default, do nothing. Subclasses with a title bar can override this"! !

"June 5, 2007 -> 21:15:49"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
natural ^<Rect>

	^natural! !

"June 5, 2007 -> 21:15:50"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
noPalette

	palette := nil! !

"June 5, 2007 -> 21:15:51"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
optimizeIncrementalLayout ^<Boolean>
^false.
	^optimizeIncrementalLayout! !

"June 5, 2007 -> 21:15:52"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
optimizeIncrementalLayout: f <Boolean>

	(f ~= optimizeIncrementalLayout and: [ self hasWin32Handle ])
		ifTrue: [ self changing ].
	optimizeIncrementalLayout := f.! !

"June 5, 2007 -> 21:15:54"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
palette ^<Palette>

	^palette! !

"June 5, 2007 -> 21:15:55"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
palette: p <Palette>

	p == palette
		ifTrue: [ ^self ].
	self assert: [ palette isNil ].
	palette := p! !

"June 5, 2007 -> 21:15:56"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
parent ^<Window>

	^parent! !

"June 5, 2007 -> 21:15:58"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
parent: p <Window>
	"This message must be sent before the window handle is created"

	parent := p! !

"June 5, 2007 -> 21:15:59"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
refreshInterval ^<Float>

	^refreshInterval! !

"June 5, 2007 -> 21:16:0"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
refreshInterval: d <Float>
	"Wait no longer than this amount of time (in seconds) between
		paint operations, if possible"

	refreshInterval := d! !

"June 5, 2007 -> 21:16:1"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
session ^<Session>

	^session! !

"June 5, 2007 -> 21:16:2"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
setNativeMenu

	{{<user ExternalProxy SetMenu>
		wnd: self win32Handle
		menu: self menu win32Handle
	}} asBoolean
		ifFalse: [ Win32 handleError ]! !

"June 5, 2007 -> 21:16:3"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
toClose ^<[Window]>

	^toClose! !

"June 5, 2007 -> 21:16:5"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
toClose: blk <[Window]>

	toClose := blk! !

"June 5, 2007 -> 21:16:6"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
useDisplayBuffering ^<Boolean>

	^useDisplayBuffering! !

"June 5, 2007 -> 21:16:7"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
useDisplayBuffering: f <Boolean>

	useDisplayBuffering := f! !

"June 5, 2007 -> 21:16:8"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
visual ^<Visual>

	^visual! !

"June 5, 2007 -> 21:16:10"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
close
	"Close and destroy the window.  This causes release to be sent to the window and its visual"

	self session aboutToDestroyWindow: self.
	{{<user ExternalProxy DestroyWindow> arg: win32Handle}}.
! !

"June 5, 2007 -> 21:16:11"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
ignoreNextFocusSet: flag <Boolean>

	ignoreNextFocusSet := flag! !

"June 5, 2007 -> 21:16:12"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
invalidate

	self visual layoutStatus > Visual invalid
		ifTrue: [ self invalidate: self allocation enclosingRect	].! !

"June 5, 2007 -> 21:16:13"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
invalidate: r <Region>

	| rect <Rect> |

	self registerPaintTime.
	rect := r enclosingRect.
	(self scratchRECT)
		left: rect left asInteger;
		right: rect right asInteger;
		top: rect top asInteger;
		bottom: rect bottom asInteger.
	{{<user ExternalProxy InvalidateRect>
		hwnd: self win32Handle
		RECT: self scratchRECT
		erase: false asExternalData}}! !

"June 5, 2007 -> 21:16:14"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
makeActive
	"Make this the active window"

	{{<user ExternalProxy SetForegroundWindow> hwnd: self win32Handle }}.! !

"June 5, 2007 -> 21:16:16"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
release

	scratchRECT free.

	self session unregisterWindow: self.

	visual notNil
		ifTrue: [	visual detaching; release.
						visual := nil.	].

	win32Handle := nil.

	self hasMenu
		ifTrue: [ self menu release ].
	mostRecentInputFocus := nil.
	menu := nil.
	popUpMenu := nil.
	toClose := nil.
	controls := nil.
! !

"June 5, 2007 -> 21:16:17"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
requestClose

	self toClose value: self.! !

"June 5, 2007 -> 21:16:18"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
show
	"Make the window visible"

	{{<user ExternalProxy ShowWindow>
			window: self win32Handle
			nCmdShow: self nCmdShow}}.
	! !

"June 5, 2007 -> 21:16:19"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
showModal
	"Make the window visible as a modal window"

	self session addModalWindow: self.
	self show.
	! !

"June 5, 2007 -> 21:16:20"!

! (Delta mirrorFor: #Window) methodsFor: 'debugging' !
dumpOn: strm <CharOutputStream>

Transcript show: self class name, ' extent: '; print: self extent; show: ' hwnd: '; print: self win32Handle; cr.
	self visual dumpOn: strm indent: 1.! !

"June 5, 2007 -> 21:16:22"!

! (Delta mirrorFor: #Window) methodsFor: 'event handling' !
character: c <Character> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	^(self visual character: c focus: focus event: ev)
		or: [	c = Character tab
					onTrue: [ self handleTabEvent: ev ] ]! !

"June 5, 2007 -> 21:16:23"!

! (Delta mirrorFor: #Window) methodsFor: 'event handling' !
keyDown: key <Symbol> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	(self visual keyDown: key focus: focus event: ev)
		ifTrue: [ ^true ].
		
	(key = #TAB and: [ ev ctrlPressed ])
		ifTrue: [ self handleTabEvent: ev.	^true ].
	key = #F1 ifTrue: [ Profiler start.	^true ].
	key = #F2 ifTrue: [ Profiler stop.	^true ].
	^false	! !

"June 5, 2007 -> 21:16:24"!

! (Delta mirrorFor: #Window) methodsFor: 'event handling' !
keyUp: key <Symbol> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	^self visual keyUp: key focus: focus event: ev
! !

"June 5, 2007 -> 21:16:26"!

! (Delta mirrorFor: #Window) methodsFor: 'event handling' !
mouseEvent: type <Symbol> at: loc <Point> event: ev <UIEvent> ^<Boolean>

	^self visual layoutStatus = Visual valid
		and: [ 	| grabGotIt <Boolean> |
						grabGotIt := self session
												mouseEvent: type
												at: loc
												event: ev.
						grabGotIt or: [	(self visual renderingRegion inParentContainsPoint: loc)
												and: [	Sampler notNil
																ifTrue: [ Sampler in: self visual sampleEvent: type at: loc - self visual position event: ev ].
															self visual
																mouseEvent: type
																at: loc - self visual position
																event: ev	] ] ]
! !

"June 5, 2007 -> 21:16:27"!

! (Delta mirrorFor: #Window) methodsFor: 'initialization' !
initSession: sess <Session>
visual: vis <Visual>

	medium := sess medium.
	session := sess.
	visual := vis.

	(self visual)
		parent: self id: 1.

	self showTimes
		ifTrue: [ Transcript show: 'prefs: '; print: [ self computePreferences ] time; cr. ]
		ifFalse: [ self computePreferences ].

	scratchRECT := RECT new allocate.
	self optimizeIncrementalLayout: true.
	ignoreNextFocusSet := false.

	self refreshInterval: self defaultRefreshInterval.
	self paintPending: false.
	self useDisplayBuffering: true.

	self toClose: [ :w <Window> | w close ].
	self enabled: true.
	controls := IdentitySet[Win32Control] new.
	self haveErased: false.! !

"June 5, 2007 -> 21:16:29"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
activeMenu ^<Menu>
	"Returns the menu that is currently active, if there is one.  It may either be the top level menu,
	  or a popup menu over the window"

	^popUpMenu notNil
		ifTrue: [ popUpMenu ]
		ifFalse: [ menu ]! !

"June 5, 2007 -> 21:16:30"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
beforeQueuedMessage

	"%remove this and calls to it"! !

"June 5, 2007 -> 21:16:35"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
beforeSetFocus

	ignoreNextFocusSet
		ifTrue: [	"We requested the focus, and have already recorded it, so
							ignore this."
						ignoreNextFocusSet := false.	]
		ifFalse: [	self visual layoutValid
							ifTrue: [	"We didn't request this, so windows must be requesting it, so
												record it"
											self findInputFocus	]	].! !

"June 5, 2007 -> 21:16:36"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
beginPaint: hwnd <HWND>  paintStructure: ps <PAINTSTRUCT>  ^<HDC>

	^{{<user HDC BeginPaint> arg: hwnd arg: ps}}! !

"June 5, 2007 -> 21:16:37"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
buildWin32Handle
	"Subclasses must implement to create the appropriate type of window handle &
	  store it in win32Handle"

	self subclassResponsibility! !

"June 5, 2007 -> 21:16:38"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
callAsyncDefWndProcFor: hwnd <HWND>
msgCode: msgCode <ExternalData>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>
	"like callDefWndProcFor:msgCode:wParam:lParam:
			but is asynchronous"

	^{{<user ExternalProxy DefWindowProcA async>
			hwnd: hwnd
			value: msgCode
			value: wParam
			value: lParam
	  }}! !

"June 5, 2007 -> 21:16:39"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
callDefWndProcFor: hwnd <HWND>
msgCode: msgCode <ExternalData>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^{{<user ExternalProxy DefWindowProcA>
			hwnd: hwnd
			value: msgCode
			value: wParam
			value: lParam
	  }}! !

"June 5, 2007 -> 21:16:41"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
computePreferences

	natural := Point origin corner: self visual natural enclosingRect extent.
	min := Point origin corner: self visual min enclosingRect extent.
	max := Point origin corner: self visual max enclosingRect extent.! !

"June 5, 2007 -> 21:16:42"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
controls ^<Extensible[Win32Control]>

	^controls! !

"June 5, 2007 -> 21:16:43"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
defaultRefreshInterval ^<Float>

	^0.25! !

"June 5, 2007 -> 21:16:44"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
defaultWndProc ^<ExternalProxy>

	^self actualClass defaultWndProc! !

"June 5, 2007 -> 21:16:45"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
deferredPaintRegion ^<Rect>

	^deferredPaintRegion! !

"June 5, 2007 -> 21:16:46"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
deferredPaintRegion: r <Rect>

	deferredPaintRegion := r! !

"June 5, 2007 -> 21:16:48"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
desiredXPos ^<ExternalData>

	^desiredPosition isNil
		ifFalse: [ desiredPosition x asInteger ]
		ifTrue: [  Win32 CW_USEDEFAULT ]! !

"June 5, 2007 -> 21:16:49"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
desiredYPos ^<ExternalData>

	^desiredPosition isNil
		ifFalse: [ desiredPosition y asInteger ]
		ifTrue: [  Win32 CW_USEDEFAULT ]! !

"June 5, 2007 -> 21:16:50"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
display

	| subs <Cltn[Win32Control]> |
	self withCanvasDo:
			[ :can <Canvas> |
				| paintBlk <[^Object]> |	
				paintBlk := 
					[	self paintBackgroundOn: can.
						self displayVisualIfCanOn: can.
						can shallowFlush.  ].
				self showTimes
					ifTrue: [  Transcript show: 'paint: '; print: paintBlk time; cr. ]
					ifFalse: [ paintBlk value ].
				can hasSubwindowsToDisplay
					ifTrue: [ subs := can takeSubwindowsToDisplay ].
			].
	subs notNil
		ifTrue: [	subs do:
							[ :sub <Win32Control> |
								"%hack: the handle test should not be 
									necessary; something is screwed up"
								sub hasWin32Handle
									ifTrue: [	sub sendMessage: Win32 WM_PAINT
														wparam: 0 lparam: 0.
												].
							].
					 ]! !

"June 5, 2007 -> 21:16:52"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
displayVisualIfCanOn: canvas <Canvas>

	self session visualCriticalWouldBlock
		ifTrue: [ self recordDeferredPaint: canvas clippingRect ]
		ifFalse: [	self paintOccuring.
						self visual displayOn: canvas.	]! !

"June 5, 2007 -> 21:16:53"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
endPaint: hwnd <HWND>  paintStructure: ps <PAINTSTRUCT>

	^{{<user ExternalProxy EndPaint> arg: hwnd arg: ps}}! !

"June 5, 2007 -> 21:17:13"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
extent: e <Point>
	"Change the window's extent.  This will cause a relayout
		to happen later, which will record the extent."

	| pos <Point> adjusted <Rect> |
	adjusted := self fitToMedium: e.
	pos := self getPosition.
	{{<user ExternalProxy MoveWindow>
		hwnd: self win32Handle
		x: pos x
		y: pos y
		width: adjusted x
		height: adjusted y
		repaint: true asExternalData
	}} asBoolean 
		ifFalse: [ Win32 handleError ].! !

"June 5, 2007 -> 21:17:14"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
findInputFocus

	"find some non-native visual
	  within us to give the input focus to."

	"If there is already a focus, and it is in this window, then we are in a callback caused
	  by our own attempt to set the focus, so do nothing."
	(self session hasInputFocus and: [ self session inputFocus nativeWindow = self ])
		ifTrue: [ ^self ].

	"If we have a valid memory of what our input focus was last time, use it"
	self purgeMostRecentFocusIfNeeded.
	(mostRecentInputFocus notNil and: [ mostRecentInputFocus topWindow = self ])
		ifTrue: [ "Search to see if the most recent one is still a reachable, valid candidate"
					 "%todo: we could optimize this by adding another call to the heirarchy called
						verifyFocusCandidate which sends verifyFocusCandidate:self up the heirarchy,
						giving pacifiers etc. a chance to deny it the focus.  This would be MUCH faster
						than the following loop."
					"Also note that we use session inputFocus: rather than becomeFocus, because this
						 thing was previously the focus, so we don't want to do things like scroll it"
					 self visual focusCandidatesDo:
						[ :cand <Visual> |
							cand = mostRecentInputFocus
								ifTrue: [	self session inputFocus: cand.

												^self		"^^^^^^^^^^^^^"		] ]. ].

	"There is no valid previous focus to reuse, so just choose the first one"
	(self visual firstFocusCandidateIfAbsent: [ ^self ])
		becomeFocus.
! !

"June 5, 2007 -> 21:17:15"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
fitToMedium: clientExtent <Point>  ^<Point>
	"takes a client extent, and returns a window extent adjusted so that it will fit on the screen"

	| normal <Point> withoutCaption <Point> captionHeight <Int> adjClient <Point> |	
	normal := (self windowSizeForClientAreaSize: clientExtent) min: self medium extent.
	withoutCaption := (self windowSizeWithoutCaptionForClientAreaSize: clientExtent) min: self medium extent.
	captionHeight := normal y - withoutCaption y.
	^self windowSizeForClientAreaSize:
			 (clientExtent x min: self medium extent x)
		@ ((clientExtent y + captionHeight min: self medium extent y) - captionHeight).! !

"June 5, 2007 -> 21:17:17"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
getPosition ^<Point>

	{{<user ExternalProxy GetWindowRect>
		hwnd: self win32Handle
		rect: self scratchRECT
	}} asBoolean
		ifFalse: [ Win32 handleError ].
	^self scratchRECT left @ self scratchRECT top! !

"June 5, 2007 -> 21:17:18"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
globalFromLocalPosition: p <WinPOINT> ^<WinPOINT>

	| wp <WinPOINT> result <WinPOINT> |
	wp := WinPOINT new allocate.
	wp x: p x; y: p y.
	{{<user ExternalProxy ClientToScreen>
			handle: self win32Handle
			point: wp
	}} asBoolean
		ifFalse: [ Win32 handleError ].
	result := wp x @ wp y.
	wp free.
	^result! !

"June 5, 2007 -> 21:17:19"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
handleTabEvent: ev <UIEvent>

	ev shiftPressed
		ifTrue: [ self moveFocusBack ]
		ifFalse: [ self moveFocusForward ]! !

"June 5, 2007 -> 21:17:21"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
hasBackgroundPainter ^<Boolean>

	^backgroundPainter notNil! !

"June 5, 2007 -> 21:17:22"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
hasMenu ^<Boolean>
	"Returns the menu that is currently active, if there is one.  It may either be the top level menu,
	  or a popup menu over the window"

	^popUpMenu notNil or: [ menu notNil ]! !

"June 5, 2007 -> 21:17:23"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
haveErased ^<Boolean>

	^haveErased! !

"June 5, 2007 -> 21:17:24"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
haveErased: f <Boolean>

	haveErased := f! !

"June 5, 2007 -> 21:17:26"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
initWindowsMessageHandlers

	WindowsMessageHandlers
		at: Win32 WM_CLOSE	put:
				[ :w <Window> :msg  <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w closeMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_SETCURSOR	put:
				[ :w <Window> :msg  <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w setCursorMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_PAINT	put:
				[ :w <Window> :msg  <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w paintMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_ERASEBKGND	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w eraseBackgroundMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_CTLCOLORBTN	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w buttonColorMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_DRAWITEM	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w drawItemMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_KEYDOWN	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w keyDownMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_KEYUP	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w keyUpMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_CHAR	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w characterMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];

		"mouse events are handled by a common event routine"
		at: Win32 WM_LBUTTONDOWN put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #primaryButtonDown at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_LBUTTONUP	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #primaryButtonUp at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_LBUTTONDBLCLK	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #primaryButtonDoubleClick at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_MBUTTONDOWN	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #middleButtonDown at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_MBUTTONUP	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #middleButtonUp at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_RBUTTONDOWN put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #secondaryButtonDown at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_RBUTTONUP put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #secondaryButtonUp at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_RBUTTONDBLCLK put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #secondaryButtonDoubleClick at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_MOUSEMOVE put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #mouseMove at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];

		at: Win32 WM_MEASUREITEM	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w measureItemMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_SETFOCUS	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w setFocusMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_KILLFOCUS	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w killFocusMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_COMMAND	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w commandMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_GETMINMAXINFO	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w getMinMaxInfoMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_SIZE	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w sizeMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_NCDESTROY	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w ncDestroyMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_DESTROY	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w destroyMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_CAPTURECHANGED	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w captureChangedMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_INITMENUPOPUP	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w initMenuPopupMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_QUERYNEWPALETTE	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w queryPaletteMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_PALETTECHANGED	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w paletteChangedMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];

		"---------- Custom messages"
		at: Window LAYOUT	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w layoutMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];

		yourself! !

"June 5, 2007 -> 21:17:28"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
initialInputFocus ^ <Visual>

	^initialInputFocus! !

"June 5, 2007 -> 21:17:29"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
layout: extent <Point>

	| firstLayout <Boolean> |

	firstLayout := self visual layoutStatus = Visual invalid.
 	self showTimes
		ifTrue: [	Transcript show: 'layout: '; print: [ 
								self visual allocationInParent: (0@0 corner: extent).
						] time; cr. ]
		ifFalse: [	self visual allocationInParent: (0@0 corner: extent). ].

	"We have to do this now because we can't set the input focus until layout is
		complete, since the containing native window must be accessed, etc."
	firstLayout
		ifTrue: [	self palette notNil
							ifTrue: [ self recursiveRealizePaletteForeground: true updateColors: true. ].
						(self initialInputFocus notNil and: [ self initialInputFocus isFocusCandidate ])
							ifTrue: [		self initialInputFocus becomeFocus.
												self initialInputFocus: nil 	"Not needed anymore, prevent memory leak"	]
							ifFalse: [	self findInputFocus ]
					  ]! !

"June 5, 2007 -> 21:17:30"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
localFromGlobalPosition: p <WinPOINT> ^<WinPOINT>

	| wp <WinPOINT> result <WinPOINT> |
	wp := WinPOINT new allocate.
	wp x: p x; y: p y.
	{{<user ExternalProxy ScreenToClient>
			handle: self win32Handle
			point: wp
	}} asBoolean
		ifFalse: [ Win32 handleError ].
	result := wp x @ wp y.
	wp free.
	^result! !

"June 5, 2007 -> 21:17:32"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
menuCommandForItem: id <Int>

	(MenuItem itemFor: id)
		execute! !

"June 5, 2007 -> 21:17:33"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
moveFocusBack

	(self visual lastFocusCandidateBefore: self session inputFocus)
		becomeFocus! !

"June 5, 2007 -> 21:17:34"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
moveFocusForward

	(self visual nextFocusCandidateAfter: self session inputFocus)
		becomeFocus! !

"June 5, 2007 -> 21:17:35"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
nCmdShow ^<ExternalProxy>

	^{{primitiveWindowsNCmdShow}}! !

"June 5, 2007 -> 21:17:36"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
nextPaintTime ^<Float>

	^nextPaintTime! !

"June 5, 2007 -> 21:17:37"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
nextPaintTime: t <Float>

	nextPaintTime := t! !

"June 5, 2007 -> 21:17:39"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
paintBackgroundOn: can <Canvas>

	can withPainter: self backgroundPainter do:
		[ can displayFilledRectangle:
			(Point origin corner: self allocation enclosingRect extent) ].! !

"June 5, 2007 -> 21:17:40"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
paintOccuring

	self nextPaintTime: Time clockValue + self refreshInterval.
	self paintPending: false.
	self session paintOccuredFor: self.! !

"June 5, 2007 -> 21:17:41"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
parentHandle ^<ExternalData>

	^parent isNil
		ifFalse: [ parent win32Handle ]
		ifTrue: [ Win32 NULL ]! !

"June 5, 2007 -> 21:17:42"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
purgeMostRecentFocusIfNeeded

	"%kludge: This should be called occasionally (in user time) to avoid memory leaks caused by
	  a pointer to a zombie visual"
	"%todo: this isn't called yet.  Set up a scanner that sends this to all windows every ten seconds or
	   so."
	(mostRecentInputFocus notNil and: [ mostRecentInputFocus isAttached not ])
		ifTrue: [ mostRecentInputFocus := nil ]! !

"June 5, 2007 -> 21:17:44"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
recordDeferredPaint: region <Rect> 

	self deferredPaintRegion:
		(self deferredPaintRegion isNil
			ifTrue: [ region ]
			ifFalse: [ self deferredPaintRegion merge: region ]
		)! !

"June 5, 2007 -> 21:17:45"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
recordExtent

		self setExtent: self trueClientAreaExtent.! !

"June 5, 2007 -> 21:17:46"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
registerPaintTime

	self paintPending
		ifFalse: [	self paintPending: true.
						self nextPaintTime: Time clockValue + self refreshInterval.
						self session schedulePaintFor: self at: self nextPaintTime.	].! !

"June 5, 2007 -> 21:17:47"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
relayoutIfNeeded

	self relayoutIfNeededForExtent: self extent! !

"June 5, 2007 -> 21:17:48"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
relayoutIfNeededForExtent: e <Point>

	self visual needsRelayout
		ifTrue: [ self layout: (self visual max enclosingRect extent min: e) ].
	self invalidate.! !

"June 5, 2007 -> 21:17:49"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
scratchRECT ^<RECT>

	^scratchRECT! !

"June 5, 2007 -> 21:17:51"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
setCursor ^<ExternalData>

	^cursor isNil
		ifFalse: [	{{<user ExternalProxy SetCursor> handle: cursor win32Handle}}.
						1 ]
		ifTrue: [ 0 ]! !

"June 5, 2007 -> 21:17:52"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
setEnabled: flag <Boolean>

	enabled := flag.
	self hasWin32Handle
		ifTrue: [	{{<user ExternalProxy EnableWindow async>
								handle: self win32Handle
								state: enabled asExternalData}}.	].! !

"June 5, 2007 -> 21:17:53"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
setExtent: e <Point>

	extent := e! !

"June 5, 2007 -> 21:17:55"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
setName: nm <Str>

	self hasWin32Handle
		ifTrue: [	| title <CString> |
						title := CString for: nm.
						[	{{<user ExternalProxy SetWindowTextA>
											hwnd: self win32Handle
											title: title
							}} asBoolean
								ifFalse: [ Win32 handleError ].
						] ensure: [ title free ]
					 ]! !

"June 5, 2007 -> 21:17:56"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
shouldCallDefaultHandlerAsynchronouslyFor: msgCode <ExternalData>  ^<Boolean>

	^msgCode @= Win32 WM_SYSCOMMAND		"so that window moves let other sessions repaint"! !

"June 5, 2007 -> 21:17:57"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
showTimes ^<Boolean>
	"Report preference, layout, and painting times on the transcript"

	^false! !

"June 5, 2007 -> 21:17:58"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
trueClientAreaExtent ^<Point>

	^self trueClientAreaExtentFor: self win32Handle! !

"June 5, 2007 -> 21:17:59"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
trueClientAreaExtentFor: hwnd <ExternalData> ^<Point>

	| extent <Point> rect <RECT> |
	rect := RECT new allocate.
	{{<user RECT GetClientRect> arg: hwnd arg: rect}}.
	extent := (rect right - rect left) @ (rect bottom - rect top).
	rect free.
	^extent! !

"June 5, 2007 -> 21:18:0"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
win32Handle: h <HWND>

	win32Handle := h! !

"June 5, 2007 -> 21:18:2"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
win32Style ^<ExternalData>

	| s <ExternalData> |
	s := 0.
	self enabled
		ifFalse: [ s := s externalBitOr: Win32 WS_DISABLED ].
	^s
! !

"June 5, 2007 -> 21:18:3"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
windowSizeForClientAreaSize: extent <Point>  ^<Point>
	"returns an integral point that is the correct window size for a desired client area size"

	^self windowSizeForClientAreaSize: extent windowStyle: self win32Style! !

"June 5, 2007 -> 21:18:4"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
windowSizeForClientAreaSize: extent <Point> windowStyle: style <ExternalData>  ^<Point>
	"returns an integral point that is the correct window size for a desired client area size"

	| r <RECT> result <Point> |
	r := RECT new allocate.
	r top: 0; left: 0; right: extent x asInteger; bottom: extent y asInteger.
	{{<user ExternalProxy AdjustWindowRect>
				 rect: r style: style hasMenu: self hasMenu asExternalData}} asBoolean
		ifFalse: [ Win32 handleError ].
	result := (r right - r left) @ (r bottom - r top).
	r free.
	^result! !

"June 5, 2007 -> 21:18:5"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
windowSizeWithoutCaptionForClientAreaSize: extent <Point>  ^<Point>
	"returns an integral point that is the correct window size for a desired client area size"

	^self windowSizeForClientAreaSize: extent
			windowStyle: (self win32Style externalBitAnd: (Win32 WS_CAPTION asSmallInteger bitInvert))! !

"June 5, 2007 -> 21:18:7"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
windowsMessageHandlers ^<Dict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>

	"Don't need critical region since duplicate inits are no problem"
	WindowsMessageHandlers isNil
		ifTrue: [	WindowsMessageHandlers :=
							CustomDictionary[ExternalData,[Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData]]
									withCompareBlock: [ :k1 <ExternalData> :k2 <ExternalData> |    k1 @= k2 ]
									hashBlock: [ :k <ExternalData> |  k hash ].
						self initWindowsMessageHandlers.
						].
	^WindowsMessageHandlers! !

"June 5, 2007 -> 21:18:8"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
withBufferedCanvasDo: drawing <[Canvas,^X def]> ^<X>

	^self withDirectCanvasDo:
		[ :directCanvas <Canvas> |
			| invalid <Rect> oldpal <Win32Handle> |
			invalid := directCanvas clippingRect.

			self session
				withBufferCanvasFor: invalid
				do: [ :bufferCanvas <Canvas> :buffer <HBITMAP> |

						self palette isNil
							ifFalse: [ oldpal := bufferCanvas win32Palette: self palette win32Handle ].

						"draw on the buffer canvas"
						drawing value: bufferCanvas.
						bufferCanvas shallowFlush.

						"Now, copy the buffer bits onto the screen"
						directCanvas atOffset: invalid origin
							do: [ bufferCanvas atOffset: invalid origin 
								do: [	directCanvas
											bitBlt: bufferCanvas
											extent: invalid extent
											op: UI ropCopy.		].	].
						 oldpal notNil
								ifTrue: [ 	Palette debugging
													ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
												bufferCanvas win32Palette: oldpal ]. 
						].	
		]! !

"June 5, 2007 -> 21:18:9"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
withCanvasDo: drawing <[Canvas,^X def]> ^<X>

	^(self useDisplayBuffering and: [ Window bufferingPossible ])
		ifFalse: [	self withDirectCanvasDo: drawing ]
		ifTrue: [	self withBufferedCanvasDo: drawing ]! !

"June 5, 2007 -> 21:18:11"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
withDCDo: blk <[HDC]>
	"With the window's device context do the block (not for painting)"

	| hdc <HDC> |
	hdc := {{<user HDC GetDC> hwnd: self win32Handle}}.
	[ blk value: hdc ]
		ensure: [ hdc releaseDCFor: self win32Handle ]! !

"June 5, 2007 -> 21:18:13"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
withDirectCanvasDo: drawing <[Canvas,^X def]> ^<X>

	|	can <Canvas>
		ps <PAINTSTRUCT>
		paintBlk <[^Object]>
		result <X>
		oldpal <Win32Handle> |

	"use a critical region to paint, since background painting might reuse the
	  same device context in the UI thread"
	^self critical:
		[	ps := PAINTSTRUCT new allocateZeroed.
			can := self beginPaint: self win32Handle paintStructure: ps.
			can isNull
				ifTrue: [ Win32 handleError ].
			can	initialize;
				toRelease: [ :dc <HDC> | "End paint will release the context" ];
				initClippingRectBeforeTranslation: ps rcPaint asRectangle;
				window: self.
			self palette isNil
				ifFalse: [ oldpal := can win32Palette: self palette win32Handle ].

			Session debugInvalidation
				ifTrue: [	can withPainter: (Painter new paint: Paint red)
									do: [ can displayFilledRectangle: ps rcPaint asRectangle; flush. ].
								Platform errorStream show: self class name, ' rendering: '; print: ps rcPaint asRectangle; cr.	].

			result := drawing value: can.
			oldpal notNil
				ifTrue: [ 	Palette debugging
									ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
								can win32Palette: oldpal ]. 
			can release. 

			self endPaint: self win32Handle paintStructure: ps.
			ps free.
			result	]! !

"June 5, 2007 -> 21:18:14"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
wndProc ^<APICallback>

	^self session wndProc! !

"June 5, 2007 -> 21:18:15"!

! (Delta mirrorFor: #Window) methodsFor: 'private-testing' !
paintPending ^<Boolean>

	^paintPending! !

"June 5, 2007 -> 21:18:16"!

! (Delta mirrorFor: #Window) methodsFor: 'private-testing' !
paintPending: b <Boolean>

	paintPending := b! !

"June 5, 2007 -> 21:18:17"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
changing

	self session changing: self.
	self session recordPrefsFor: self.
	natural := min := max := nil.! !

"June 5, 2007 -> 21:18:19"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
checkLayout: oldPrefs <SeqCltn[Region]>

	| oldNat <Rect> alloc <Rect> nat <Rect> ext <Point> |
	oldNat := (oldPrefs at: 2) enclosingRect.
	self computePreferences.
	nat := self natural enclosingRect.
	alloc := self allocation enclosingRect.

	"We have to do the relayout eagerly, even before the size message
			comes back, because the caller assumes that layout is then done."

	((alloc contains: self min enclosingRect)
			and: [ self max enclosedRect contains: alloc ]
	)	ifFalse: [	"We definitely have to change our size"
							self relayoutIfNeededForExtent: nat extent.
							self extent: nat extent.
							^self	].

	(self optimizeIncrementalLayout
			or: [ nat = oldNat
			or: [	alloc contains: nat ] ])
		ifTrue: [	self relayoutIfNeededForExtent: self extent.
						^self ].

	ext := (nat width max: alloc width) @ (nat height max: alloc height).
	self relayoutIfNeededForExtent: ext.
	self extent: ext.! !

"June 5, 2007 -> 21:18:20"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
checkPaintTime: t <Float>
	"If we have reached our refresh time, paint"
	
"%todo: figure out how to remove the following %hack
		this should not be sent after the receiver is released)"	
visual isNil ifTrue: [ ^self ].

	(self hasWin32Handle and: [ self paintPending ])
		ifTrue: [ self nextPaintTime <= t
						ifTrue: [ self display ]
						ifFalse: [ self session needPaintAtTime: self nextPaintTime ]	 ]! !

"June 5, 2007 -> 21:18:21"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
oldcheckLayout: oldPrefs <SeqCltn[Region]>

	| oldNat <Rect> alloc <Rect> nat <Rect> |
	oldNat := (oldPrefs at: 2) enclosingRect.
	self computePreferences.
	nat := self natural enclosingRect.
	alloc := self allocation enclosingRect.

	"We have to do the relayout eagerly, even before the size message
			comes back, because the caller assumes that layout is then done."
	self relayoutIfNeeded.

	((alloc contains: self min enclosingRect)
			and: [ (self max enclosedRect contains: alloc)
			and: [ self optimizeIncrementalLayout
							or: [ nat = oldNat
							or: [	alloc contains: nat ] ] ] ]
	)	ifFalse: [	"We definitely have to change our size"
						self setExtent: nat extent.	].
! !

"June 5, 2007 -> 21:18:23"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
prefs ^<SeqCltn[Region]>

	^Array[Region] with: self min with: self natural with: self max! !

"June 5, 2007 -> 21:18:24"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
prefsStatus ^<Int>

	^Visual valid! !

"June 5, 2007 -> 21:18:25"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
prerecordPrefsIfNeeded

	"nothing to do"! !

"June 5, 2007 -> 21:18:26"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
processDeferredPainting

	self deferredPaintRegion notNil
		ifTrue: [	self invalidate: self deferredPaintRegion.
						self deferredPaintRegion: nil.		]! !

"June 5, 2007 -> 21:18:28"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
removeParentsFrom: leaves <Set[RelayoutTarget]>
alreadyChecked: checked <Set[RelayoutTarget]>

	"nothing to do"! !

"June 5, 2007 -> 21:18:29"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
hInstance ^<ExternalProxy>

	^self medium hInstance! !

"June 5, 2007 -> 21:18:30"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
message: msg <MSG>
	"This is invoked in the UI thread when a new message arrives in the queue."

	"Forward messages to the session, which will execute them in its thread"
	self session message: msg! !

"June 5, 2007 -> 21:18:31"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
message: msgCode <ExternalData>
for: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	"This is where all the win32 messages get converted to our semantics.  This
	  method executes in the window's session's thread for queued messages, and
	  either the session or UI thread for unqueued messages."

	"%note/%todo: each message below must call beforeQueuedMessage before processing
	     the message IFF the message is a queued (in session thread) message"

	^(self windowsMessageHandlers at: msgCode
		ifAbsent: [ ^self handleMiscMsg: msgCode hwnd: hwnd wParam: wParam lParam: lParam ]
     )	value: self
		value: msgCode
		value: hwnd
		value: wParam
		value: lParam! !

"June 5, 2007 -> 21:18:32"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
recursiveRealizePaletteForeground: fore <Boolean> updateColors: update <Boolean>

	self palette isNil
		ifFalse: [	self withDCDo:
							[ :hdc <HDC> |
								| oldpal <Win32Handle> |
								oldpal := Palette select: self palette win32Handle into: hdc background: fore not.
								self palette unrealize.
								self palette realizeFor: hdc.
								Palette debugging
									ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
								Palette select: oldpal win32Handle into: hdc background: fore not.
							 ].
						self invalidate.
						].
	self controls do:
		[ :c <Win32Control> |
			c recursiveRealizePaletteForeground: fore updateColors: update ].! !

"June 5, 2007 -> 21:18:34"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
registerControl: c <Win32Control>

	self controls include: c! !

"June 5, 2007 -> 21:18:35"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
releaseCapture

	{{<user ExternalProxy ReleaseCapture> noArgs}}! !

"June 5, 2007 -> 21:18:36"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
sendMessage: msg <ExternalData>
wparam: wp <ExternalData>
lparam: lp <ExternalData>
^<ExternalData>

	^{{<user ExternalProxy SendMessageA>
			handle: self win32Handle
			msg: msg
			wparam: wp
			lparam: lp}}! !

"June 5, 2007 -> 21:18:37"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
setCapture

	{{<user ExternalProxy SetCapture> hwnd: self win32Handle}}.
! !

"June 5, 2007 -> 21:18:38"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
setFocus

	 self win32Handle @= {{<user ExternalProxy GetFocus> call}}
		ifFalse: [  {{<user ExternalProxy SetFocus> hwnd: self win32Handle}} ]! !

"June 5, 2007 -> 21:18:40"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
unregisterControl: c <Win32Control>

	self controls removeEvery: c! !

"June 5, 2007 -> 21:18:41"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
win32Handle ^<HWND>

	win32Handle isNil
		ifTrue: [	self session creatingWindow: self do:
							[	self buildWin32Handle; recordExtent. ].  ].
	^win32Handle! !

"June 5, 2007 -> 21:18:42"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
characterMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self beforeQueuedMessage.
	^self session handleIfFocusMsg: msg for: self wParam: wParam lParam: lParam
! !

"June 5, 2007 -> 21:18:43"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
closeMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self requestClose.
	^0! !

"June 5, 2007 -> 21:18:45"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
commandMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	
	self beforeQueuedMessage.

	^lParam @~= Win32 NULL
		ifTrue: [	"Then this is a control window notification, which should be forwarded back to the
						  smalltalk control object"
						Win32Control notificationMsg: wParam asExternalProxy high for: (Win32Control controlIdFor: lParam).
						0 ]
		ifFalse: [ wParam asExternalProxy high = 0
							ifTrue: [	self menuCommandForItem: wParam low.
											0	]
							ifFalse: [ self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam ]	]! !

"June 5, 2007 -> 21:18:46"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
handleMiscMsg: msgCode <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	"This performs the default window system handling for a message"
	
	^(self shouldCallDefaultHandlerAsynchronouslyFor: msgCode)
		ifTrue: [	"Some messages should be handled asyncronously, so that for
							example, moving a window allows other sessions to refresh"
						self callAsyncDefWndProcFor: hwnd
							msgCode: msgCode
							wParam:  wParam
							lParam: lParam ]
		ifFalse: [	self callDefWndProcFor: hwnd
								msgCode: msgCode
								wParam:  wParam
								lParam: lParam	]! !

"June 5, 2007 -> 21:18:48"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
handleMouseEvent: type <Symbol>
at: loc <Point>
msg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	| ev <UIEvent> |
	self beforeQueuedMessage.

	"%todo: remove the dispatch block for all events; isn't needed anymore"
	ev := UIEvent
			forMsg: self session currentMsg
			dispatch:
				[ :e <UIEvent> :h <UIEventHandler> |
					h mouseEvent: type at: loc event: e ].
	self mouseEvent: type at: loc event: ev.

	"Mouse events are always passed through to the default wnd proc since their may be window system specific things
	  like bringing the window to the foreground that always have to happen. (I used to pass it through only when it
	  was a left button down msg, but this is cleaner)"
	^self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam! !

"June 5, 2007 -> 21:18:49"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
initMenuPopupMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self beforeQueuedMessage.
	self hasMenu 
		ifTrue: [ self activeMenu updateMenuWithHandle: wParam ].
	^0! !

"June 5, 2007 -> 21:18:50"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
keyDownMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self beforeQueuedMessage.
	^self session handleIfFocusMsg: msg for: self wParam: wParam lParam: lParam
! !

"June 5, 2007 -> 21:18:51"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
keyUpMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self beforeQueuedMessage.
	^self session handleIfFocusMsg: msg for: self wParam: wParam lParam: lParam
! !

"June 5, 2007 -> 21:18:52"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
layoutMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	| ext <Point> |
	ext := lParam low @ lParam high.
	(self visual layoutStatus < Visual valid
			or: [ self visual allocation enclosingRect extent ~= ext ])
		ifTrue: [ self layout: ext ].
	^0! !

"June 5, 2007 -> 21:18:53"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
paintMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self display.
	^0! !

"June 5, 2007 -> 21:18:55"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
setCursorMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^(cursor notNil
			and: [	| hitcode <Int> |
						hitcode := lParam asExternalProxy low.
						hitcode = 1 or: [ hitcode = 65534 ] "client area or disabled"  ])
		ifTrue: [ 	self setCursor.
						1 ]
		ifFalse: [ self callDefWndProcFor: hwnd
								msgCode: msg
								wParam: wParam
								lParam: lParam ]
! !

"June 5, 2007 -> 21:18:56"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
buttonColorMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^Win32Control buttonColorMsg: wParam asExternalProxy for: (Win32Control controlIdFor: lParam)! !

"June 5, 2007 -> 21:18:58"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
captureChangedMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self session lostCapture.
	
	^self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam! !

"June 5, 2007 -> 21:18:59"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
destroyMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^0! !

"June 5, 2007 -> 21:19:0"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
drawItemMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^Win32Control drawItemMsg: (DRAWITEMSTRUCT forProxy: lParam) for: wParam asSmallInteger! !

"June 5, 2007 -> 21:19:1"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
eraseBackgroundMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	| can <Canvas> |

	self haveErased
		ifTrue: [ ^1 ].
	self haveErased: true.

	"Don't paint background when a paint is pending to reduce flickering"
	self paintPending
		ifTrue: [ ^0 ].

	"Use a critical region because the window's thread might be drawing"
	self critical:
		[	can := HDC forProxy: wParam asExternalProxy.
			can initialize.
			self paintBackgroundOn: can. 	].
	^1! !

"June 5, 2007 -> 21:19:3"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
getMinMaxInfoMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	| info <MINMAXINFO> adjmin <Point> adjmax <Point> |
	info := MINMAXINFO forProxy: lParam asExternalProxy.
	adjmin := (self fitToMedium: self min extent) max: info ptMinTrackSize asPoint.
	adjmax := (self fitToMedium: self max extent) min: info ptMaxSize asPoint.
	info ptMaxSize x: adjmax x; y: adjmax y.
	info ptMaxTrackSize x: adjmax x; y: adjmax y.
	info ptMinTrackSize x: adjmin x; y: adjmin y.
	^0! !

"June 5, 2007 -> 21:19:4"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
killFocusMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	"This window is losing the input focus, which means that some non-native visual
	  within us probably has the focus, so we have to discard the focus."

	(self session hasInputFocus and: [ self session inputFocus nativeWindow = self ])
		ifTrue: [ self session noInputFocus ].

	^self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam! !

"June 5, 2007 -> 21:19:5"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
measureItemMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	| data <MEASUREITEMSTRUCT> |
	data := MEASUREITEMSTRUCT forProxy: lParam.
	^data CtlType @= Win32 ODT_MENU
		ifFalse: [ Win32Control measureItemMsg: data for: data CtlID asSmallInteger ]
		ifTrue: [ self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam ]! !

"June 5, 2007 -> 21:19:6"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
ncDestroyMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self release.
	^0! !

"June 5, 2007 -> 21:19:8"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
paletteChangedMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	wParam @= self win32Handle
		ifFalse: [ self recursiveRealizePaletteForeground: false updateColors: true.
						self palette isNil
							ifTrue: [ ^self callDefWndProcFor: hwnd
											msgCode: msg
											wParam: wParam
											lParam: lParam	].
					].
	^0! !

"June 5, 2007 -> 21:19:45"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
queryPaletteMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self recursiveRealizePaletteForeground: true updateColors: false.
	self palette isNil
		ifTrue: [ ^self callDefWndProcFor: hwnd
						msgCode: msg
						wParam: wParam
						lParam: lParam	].
	^0! !

"June 5, 2007 -> 21:19:46"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
setFocusMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	"This window is getting the input focus, which means that some non-native visual
	  within us will have to be chosen if possible."

	self beforeSetFocus.

	^self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam! !

"June 5, 2007 -> 21:19:48"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
sizeMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	"%todo: do we need to check the value of wParam first?"
	self critical:
		[ wParam @= Win32 SIZE_MINIMIZED
			ifFalse: [	| m <MSG> |
								self invalidate.
								m := MSG new allocate.
								[ m	hwnd: self win32Handle;
										message: Window LAYOUT;
										wParam: 0;
										lParam: lParam.
									self recordExtent.
									self session message: m.
								] ensure: [ m free ]
							]
		 ].
	^0! !

"June 5, 2007 -> 21:19:49"!

! (Delta mirrorFor: #Window) methodsFor: 'testing' !
isActive ^<Boolean>

	^self session hasActiveWindow and: [ self session activeWindow = self ]! !

"June 5, 2007 -> 21:27:17"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 21:27:19"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 21:27:19"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 21:27:19"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 21:27:19"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 21:27:19"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 21:27:19"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 21:27:19"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 21:27:19"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 21:27:19"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 21:27:19"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 21:27:20"!

(Delta mirrorFor: #SystemInitializer)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"June 5, 2007 -> 21:27:23"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
benchmarkDictionary
	| dict |
	dict := Dictionary new.

	"Benchmarks"
	dict at: #richards			put: [ :runner :repeat :inner | runner new runRichardsBenchmarks: 		repeat ].
	dict at: #smopstones	put: [ :runner :repeat :inner | runner new runSmopstoneBenchmarks:	repeat ].
	dict at: #slopstones		put: [ :runner :repeat :inner | runner new runSlopstoneBenchmarks:		repeat ].
	dict at: #stanford			put: [ :runner :repeat :inner | runner new runStanfordBenchmarks:		repeat ].
	dict at: #deltablue			put: [ :runner :repeat :inner | runner new runDeltaBlue:							repeat ].
	dict at: #benchmarks	put: [ :runner :repeat :inner | 
		runner new runStanfordBenchmarks:			repeat.
		runner new runRichardsBenchmarks:		repeat.
		runner new runDeltaBlue:								repeat.
		runner new runSlopstoneBenchmarks:		repeat.
		runner new runSmopstoneBenchmarks:	repeat.
	].
	
	dict at: #loop			put: [ :runner :repeat :inner | runner new runStanfordLoopBenchmarks: repeat ].
	
	"Individual Stanford Benchmarks"
	dict at: #bubblesort		put: [ :runner :repeat :inner | runner new runIndividualStanford: BubbleSortBenchmark repeat: repeat inner: inner].
	dict at: #bubblesort2	put: [ :runner :repeat :inner | runner new runIndividualStanford: BubbleSort2Benchmark repeat: repeat inner: inner].
	dict at: #intmm				put: [ :runner :repeat :inner | runner new runIndividualStanford: IntMMBenchmark repeat: repeat inner: inner].
	dict at: #intmm2			put: [ :runner :repeat :inner | runner new runIndividualStanford: IntMM2Benchmark repeat: repeat inner: inner].
	dict at: #mm					put: [ :runner :repeat :inner | runner new runIndividualStanford: MMBenchmark repeat: repeat inner: inner].
	dict at: #mm2				put: [ :runner :repeat :inner | runner new runIndividualStanford: MM2Benchmark repeat: repeat inner: inner].
	dict at: #perm				put: [ :runner :repeat :inner | runner new runIndividualStanford: PermBenchmark repeat: repeat inner: inner].
	dict at: #perm2				put: [ :runner :repeat :inner | runner new runIndividualStanford: Perm2Benchmark repeat: repeat inner: inner].
	dict at: #queens			put: [ :runner :repeat :inner | runner new runIndividualStanford: QueensBenchmark repeat: repeat inner: inner].
	dict at: #queens2			put: [ :runner :repeat :inner | runner new runIndividualStanford: Queens2Benchmark repeat: repeat inner: inner].
	dict at: #quicksort		put: [ :runner :repeat :inner | runner new runIndividualStanford: QuicksortBenchmark repeat: repeat inner: inner].
	dict at: #quicksort2		put: [ :runner :repeat :inner | runner new runIndividualStanford: Quicksort2Benchmark repeat: repeat inner: inner].
	dict at: #towers			put: [ :runner :repeat :inner | runner new runIndividualStanford: TowersBenchmark repeat: repeat inner: inner].
	dict at: #towers2			put: [ :runner :repeat :inner | runner new runIndividualStanford: Towers2Benchmark repeat: repeat inner: inner].
	dict at: #treesort			put: [ :runner :repeat :inner | runner new runIndividualStanford: TreeSortBenchmark repeat: repeat inner: inner].
	dict at: #treesort2		put: [ :runner :repeat :inner | runner new runIndividualStanford: TreeSort2Benchmark repeat: repeat inner: inner].
	dict at: #puzzle				put: [ :runner :repeat :inner | runner new runIndividualStanford: PuzzleBenchmark repeat: repeat inner: inner].
	dict at: #sieve				put: [ :runner :repeat :inner | runner new runIndividualStanford: SieveBenchmark repeat: repeat inner: inner].
	dict at: #sumto				put: [ :runner :repeat :inner | runner new runIndividualStanford: SumToBenchmark repeat: repeat inner: inner].
	dict at: #recurse			put: [ :runner :repeat :inner | runner new runIndividualStanford: RecurseBenchmark repeat: repeat inner: inner].
	dict at: #atallput			put: [ :runner :repeat :inner | runner new runIndividualStanford: AtAllPutBenchmark repeat: repeat inner: inner].
	dict at: #incrementall	put: [ :runner :repeat :inner | runner new runIndividualStanford: IncrementAllBenchmark repeat: repeat inner: inner].
	dict at: #nestedloop		put: [ :runner :repeat :inner | runner new runIndividualStanford: NestedLoopBenchmark repeat: repeat inner: inner].
	dict at: #tak					put: [ :runner :repeat :inner | runner new runIndividualStanford: TakBenchmark repeat: repeat inner: inner].
	dict at: #takl					put: [ :runner :repeat :inner | runner new runIndividualStanford: TaklBenchmark repeat: repeat inner: inner].
	dict at: #ordcol				put: [ :runner :repeat :inner | runner new runIndividualStanford: OrderedCollectionBenchmark repeat: repeat inner: inner].
	dict at: #dictionary		put: [ :runner :repeat :inner | runner new runIndividualStanford: DictionaryBenchmark repeat: repeat inner: inner].
	dict at: #dictatput		put: [ :runner :repeat :inner | runner new runIndividualStanford: DictionaryAtPutBenchmark repeat: repeat inner: inner].
	dict at: #livermore		put: [ :runner :repeat :inner | runner new runIndividualStanford: LivermoreBenchmark repeat: repeat inner: inner].

	"Individual Slopstone Benchmarks"
	dict at: #addint				put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 1 repeat: repeat inner: inner].
	dict at: #addfloat			put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 2 repeat: repeat inner: inner].
	dict at: #stringaccess	put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 3 repeat: repeat inner: inner].
	dict at: #createobject	put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 4 repeat: repeat inner: inner].
	dict at: #perform			put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 5 repeat: repeat inner: inner].
	dict at: #evaluate			put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 6 repeat: repeat inner: inner].
	
	"Individual Smopstone Benchmarks"
	dict at: #fractonacci	put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 1 repeat: repeat inner: inner].
	dict at: #primes   		put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 2 repeat: repeat inner: inner].
	dict at: #streams		put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 3 repeat: repeat inner: inner].
	dict at: #strings			put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 4 repeat: repeat inner: inner].
	dict at: #sets				put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 5 repeat: repeat inner: inner].
	dict at: #sorting 			put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 6 repeat: repeat inner: inner].
	dict at: #sorcerer		put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 7 repeat: repeat inner: inner].

	"Test Suites"
	dict at: #testsuite		put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new testBasicClasses] ].

	"Individual Tests"
	dict at: #string				put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: String title: 'String' ] ].
	dict at: #number			put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: Number title: 'Number' ] ].
	dict at: #sortedcol		put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: SortedCollection title: 'SortedCollection' ] ].
	dict at: #readstream	put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: SeqCltnReadStream title: 'SeqCltnReadStream' ] ].
	dict at: #writestream	put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: SeqCltnReadWriteStream title: 'SeqCltnReadWriteStream' ] ].
	dict at: #bag				put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: Bag title: 'Bag' ] ].
	dict at: #keyedset		put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: KeyedSet title: 'KeyedSet' ] ].
	dict at: #set					put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: Set title: 'Set' ] ].
	dict at: #orderedcol	put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: OrderedCollection title: 'OrderedCollection' ] ].
	dict at: #character		put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: Character title: 'Character' ] ].
	dict at: #readwrite		put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: ExternalReadWriteStream title: 'ExternalReadWriteStream' ] ].

	"Errors"
	dict at: #break				put: [ :runner :repeat :inner | {{primitiveBreak}} ].

	"Bootstrap"
	dict at: #boot				put: [ :runner :repeat :inner | Dumper fileOut ].

	"Test Suite for the VM people"
	dict at: #vmtest				put: [ :runner :repeat :inner | VMSuite run ].
	dict at: #vminterpreted	put: [ :runner :repeat :inner | VMSuite runInterpreted ].
	dict at: #vmcompiled	put: [ :runner :repeat :inner | VMSuite runCompiled ].
	dict at: #vmvanilla			put: [ :runner :repeat :inner | VMSuite runVanilla ].
	dict at: #dump					put: [  :runner :repeat :inner | InliningDatabase dump ].
	dict at: #compileAll		put: [  :runner :repeat :inner | InliningDatabase compileAll ].
	dict at: #gc						put: [  :runner :repeat :inner | VM collectGarbage ].
	dict at: #norecomp		put: [  :runner :repeat :inner | VM booleanAt: #UseRecompilation put: false ].

	"Misc."
	dict at: #zone					put: [ :runner :repeat :inner | {{primitivePrintZone}} ].
	dict at: #decode				put: [ :runner :repeat :inner | {{primitiveDecodeAllMethods}} ].
	dict at: #mandelbrot		put: [ :runner :repeat :inner | repeat timesRepeat: [ Mandelbrot new computeImageOnly ] ].
	dict at: #mandelprof		put: [ :runner :repeat :inner | Profiler do: [ Mandelbrot new computeImageOnly ] ].
	dict at: #mandeltest		put: [ :runner :repeat :inner | Mandelbrot new computeImageOnly ].
	dict at: #typecheck		put: [ :runner :repeat :inner | runner new runTypecheckerBenchmarks: repeat ].
	dict at: #genprims			put: [ :runner :repeat :inner | DeltaPrimitiveGenerator doit].

	^dict! !

"June 5, 2007 -> 21:27:24"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
findRunner: test ifAbsent: blk
	test = 'timer'
		ifTrue: [^BenchmarkRunner].
	test = 'nmethod'
		ifTrue: [^BenchmarkNMethodInvocationRunner].
	test = 'method'
		ifTrue: [^BenchmarkMethodInvocationRunner].
	test = 'prims'
		ifTrue: [^BenchmarkPrimitiveRunner].
	test = 'lookup'
		ifTrue: [^BenchmarkLookupCacheRunner].
	test = 'blocks'
		ifTrue: [^BenchmarkBlockRunner].
	blk value.! !

"June 5, 2007 -> 21:27:25"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
lower: str
	| result |
	result := String new: str size.
	1 to: str size do: [ :index |
		result at: index put: (str at: index) asLowercase
	].
	^result! !

"June 5, 2007 -> 21:27:26"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
parseInteger: str ifFail: blk
	| result |
	result := 0.
	str do: [ :c | | val |
		val := c asciiValue.
		(val >= $0 asciiValue and: [ val <= $9 asciiValue ])  ifTrue: [
			result := (result * 10) + ( val - $0 asciiValue)
		] ifFalse: [
			^blk value
		]
	].
	^result! !

"June 5, 2007 -> 21:27:27"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
processCommandLineArguments ^<Boolean>
	"process command line args, and return boolean indicating whether the 
		default program should be run (which is normally the GUI)"

	| args <ReadStream[Str]>  runDefault <Boolean> |
	args := Platform commandLineTokens.
	args next.  "Skip command"
	runDefault := true.
	
	[ args atEnd ] whileFalse: [  | arg <Str> |
		arg := args next.
		
		arg = '-benchmark'
			ifTrue: [	self runBenchmarks: args.
						runDefault := false ].
		arg = '-script'
			ifTrue: [	args atEnd
							ifTrue: [ Transcript show: 'Command line argument error: -script option must be followed by a filename';cr. ]
							ifFalse: [ self runScript: args next ].
						runDefault := false ].		].
	^runDefault
! !

"June 5, 2007 -> 21:27:28"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
runBenchmarks: args <InputStream[Str]>

	| dict runner repeat inner print |
	dict := self benchmarkDictionary.
	runner	:= BenchmarkRunner.
	repeat	:= 1.
	inner	:= 1.
	print		:= false.

	[ args atEnd ] whileFalse: [	| arg <Str> cmd options |
		arg := args next.
		options	:= false.
		arg = 'profile'	ifTrue: [ runner := BenchMarkProfileRunner.		options := true ].
		arg = 'prims'		ifTrue: [ runner := BenchmarkPrimTraceRunner.	options := true ].
		arg = 'inner'		ifTrue: [ inner := repeat. repeat := 1.						options := true ].
		arg = 'print'		ifTrue: [ print := true.												options := true ].
		options ifFalse: [
			repeat := self parseInteger: arg ifFail: [
				Transcript show: 'Processing '; show: arg; show: ' ('; show: repeat printString; show: ' times)'; cr.
				cmd := dict at: arg ifAbsent: [nil].
				cmd isNil ifTrue:  [ Transcript show: 'Command not found'; cr ]
							   ifFalse: [ cmd value: runner value: repeat value: inner ].
				repeat
			]
		]
	].

	print ifTrue: [
		{{primitivePrintMemory}}.
	]! !

"June 5, 2007 -> 21:27:29"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
runDefaultProgram
	"This starts the 'default' program, which is the code that should run when no
	  command line options specifies something else"
	  
	[ UI start ] fork! !

"June 5, 2007 -> 21:27:30"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
runScript: filename <Str>

	[	| file <FilePath> |
		file := FilePath for: filename.
		file exists
			ifFalse: [	Transcript show: 'Error: script file ''', filename, ''' not found.'; cr.
							^self	].
		file charInputStream fileIn
	] fork! !

"June 5, 2007 -> 21:27:31"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'library class initialization' !
run
	"This is the entry point for normal execution."
	
	| commands <OrdCltn[Str]> |

	self runBaseClassInitializers.
	self runNonCriticalClassInitializers.
	(self processCommandLineArguments)
		ifTrue: [ self runDefaultProgram ].
! !

"June 5, 2007 -> 21:27:32"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'library class initialization' !
runBaseClassInitializers
	"Initialize critical base library classes (run in the process scheduler)"

	Platform initialize.
	Transcript := TempTranscript new.
	SmallInteger initialize.
	Character initialize.
	CallBack initialize.
	IdleProcess initialize.
	InliningDatabase initialize.
! !

"June 5, 2007 -> 21:27:33"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'library class initialization' !
runNonCriticalClassInitializers
	"This is the root class initializer that is called when the system starts up.
		Any class initializers that must be called should be called from
		this method."

	Session initialize.

	Rectangle initialize.
	Paint initialize.
	Painter initialize.
	HPEN initialize.
	GeometricHPEN initialize.
	HBRUSH initialize.
	InfiniteRegion initialize.

	Smalltalk initialize.

	CodeEditor initialize.
	Workspace initialize.

	HTMLElement initialize.
	HTMLParser initialize.! !

"June 5, 2007 -> 21:41:46"!

"System saved" !
"June 5, 2007 -> 21:58:16"!

Delta define: #WinPOINT as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:58:16"!

(Delta mirrorFor: #WinPOINT)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.1 $
'!


"June 5, 2007 -> 21:58:18"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
asPoint ^<Point>
	^self x @ self y! !

"June 5, 2007 -> 21:58:18"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
structureSize ^<Int>
	^8! !

"June 5, 2007 -> 21:58:19"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
x ^<SmallInteger>

	^self smallIntegerAt: self xOffset! !

"June 5, 2007 -> 21:58:20"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
x: v <SmallInteger>

	self smallIntegerAt: self xOffset put: v! !

"June 5, 2007 -> 21:58:21"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
y ^<SmallInteger>

	^self smallIntegerAt: self yOffset! !

"June 5, 2007 -> 21:58:22"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
y: v <SmallInteger>

	self smallIntegerAt: self yOffset put: v! !

"June 5, 2007 -> 21:58:23"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'offsets' !
xOffset ^<Int>
	^0! !

"June 5, 2007 -> 21:58:23"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'offsets' !
yOffset ^<Int>
	^4! !

"June 5, 2007 -> 21:58:49"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:58:51"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:58:51"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:58:51"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:58:51"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:58:51"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:58:51"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:58:51"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:58:51"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:58:51"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:58:51"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:58:52"!

(Delta mirrorFor: #MINMAXINFO)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"June 5, 2007 -> 21:58:52"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'accessing' !
ptMaxSize ^<WinPOINT>

	^self subProxyAt: self ptMaxSizeOffset result: WinPOINT new! !

"June 5, 2007 -> 21:58:53"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'accessing' !
ptMaxTrackSize ^<WinPOINT>

	^self subProxyAt: self ptMaxTrackSizeOffset result: WinPOINT new! !

"June 5, 2007 -> 21:58:54"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'accessing' !
ptMinTrackSize ^<WinPOINT>

	^self subProxyAt: self ptMinTrackSizeOffset result: WinPOINT new! !

"June 5, 2007 -> 21:58:55"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'accessing' !
structureSize ^<Int>

	^40! !

"June 5, 2007 -> 21:58:55"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'offsets' !
ptMaxPositionOffset ^<Int>

	^16! !

"June 5, 2007 -> 21:58:56"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'offsets' !
ptMaxSizeOffset ^<Int>

	^8! !

"June 5, 2007 -> 21:58:57"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'offsets' !
ptMaxTrackSizeOffset ^<Int>

	^32! !

"June 5, 2007 -> 21:58:58"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'offsets' !
ptMinTrackSizeOffset ^<Int>

	^24! !

"June 5, 2007 -> 21:58:59"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'offsets' !
ptReservedOffset ^<Int>

	^0! !

"June 5, 2007 -> 21:59:46"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:59:48"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:59:49"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:59:50"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:59:50"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:59:51"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:59:51"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:59:51"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:59:52"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:59:52"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:59:52"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:59:53"!

(Delta mirrorFor: #Win32Control)
comment: 
'A Visual that has a corresponding native Win32 window.

%optional #commandWith: - should override to process any WM_COMMAND messages needed

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.5 $
'!


"June 5, 2007 -> 21:59:55"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'private' !
controlForHandle: hwnd <ExternalProxy> ifAbsent: b <[^X def]> ^<Win32Control | X>

	^self controlFor: (self controlIdFor: hwnd) ifAbsent: b! !

"June 5, 2007 -> 21:59:56"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'private' !
controls ^<VarDict[Int, Win32Control]>

	"Assumption: allers must be in a critical region for self"

	Controls isNil
		ifTrue: [ Controls := Dictionary[Int, Win32Control] new ].
	^Controls! !

"June 5, 2007 -> 21:59:57"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'private' !
dispatchMsgFor: hwnd <ExternalProxy>
msg: msg <SmallInteger>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^(self controlForHandle: hwnd ifAbsent: [ ^0 ])
		message: msg for: hwnd wParam: wParam lParam: lParam! !

"June 5, 2007 -> 21:59:58"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
assignId ^<Int>
	"Assign and return a unique control id number.  It is assumed that we are already in a
		critical region on the Win32Control."

	MaxControlId isNil
				ifTrue: [ MaxControlId := 1 ]
				ifFalse: [ MaxControlId := MaxControlId + 1].
	^MaxControlId! !

"June 5, 2007 -> 21:59:59"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
buttonColorMsg: hdc <ExternalProxy> for: control <Int> ^<ExternalData>

	^(self controlFor: control  ifAbsent: [ ^0 ]) buttonColorMsg: hdc! !

"June 5, 2007 -> 22:0:0"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
controlFor: id <Int> ifAbsent: b <[^X def]> ^<Win32Control | X>

	^Win32Control
		critical: [	self controls at: id ifAbsent: b ]! !

"June 5, 2007 -> 22:0:1"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
controlIdFor: hwnd <HWND> ^<Int>

	^{{<user ExternalProxy GetWindowLongA> hwnd: hwnd value: Win32 GWL_ID}} asSmallInteger.
! !

"June 5, 2007 -> 22:0:2"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
customWndProc ^<APICallback>

	"Don't need a critical region"
	CustomWndProc isNil
		ifTrue: [	CustomWndProc := APICallBack
							register:
								[ :hwnd <ExternalProxy> :msg <SmallInteger> :wParam <ExternalData> :lParam <ExternalData> |
									self dispatchMsgFor: hwnd msg: msg wParam: wParam lParam: lParam ]
							parameters: (OrderedCollection[Class]
								with: ExternalProxy with: SmallInteger with: ExternalProxy with: ExternalProxy).	].
	^CustomWndProc! !

"June 5, 2007 -> 22:0:3"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
drawItemMsg: data <DRAWITEMSTRUCT> for: control <Int> ^<ExternalData>

	^(self controlFor: control ifAbsent: [ ^0 ]) drawItemMsg: data! !

"June 5, 2007 -> 22:0:6"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
measureItemMsg: data <MEASUREITEMSTRUCT> for: control <Int> ^<ExternalData>

	^(self controlFor: control ifAbsent: [ ^0 ]) measureItemMsg: data! !

"June 5, 2007 -> 22:0:9"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
notificationMsg: notifyCode <ExternalData> for: control <Int>

	(self controlFor: control ifAbsent: [ ^0 ]) notificationMsg: notifyCode! !

"June 5, 2007 -> 22:0:10"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
registerControl: id <Int> for: inst <Win32Control>

	Win32Control critical: 
		[ self controls at: id put: inst	]! !

"June 5, 2007 -> 22:0:12"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
unregisterControl: id <Int>

	Win32Control critical: [ self controls removeKey: id ]! !

"June 5, 2007 -> 22:0:14"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'testing' !
debugEvents ^<Boolean>

	^Session debugEvents! !

"June 5, 2007 -> 22:0:15"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'testing' !
debugNotifications ^<Boolean>

	^false! !

"June 5, 2007 -> 22:0:16"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
backgroundPainter ^<Painter>

	backgroundPainter isNil
		ifTrue: [ ^super backgroundPainter ].
	^backgroundPainter! !

"June 5, 2007 -> 22:0:18"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
enabled ^<Boolean>

	^enabled! !

"June 5, 2007 -> 22:0:19"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
enabled: flag <Boolean>

	self enabled = flag
		ifFalse: [	self setEnabled: flag ].! !

"June 5, 2007 -> 22:0:21"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
fullyEnabled ^<Boolean>

	"is true if we are enabled and all parents are enabled"
	^self enabled and: [ super enabled ]! !

"June 5, 2007 -> 22:0:23"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
nativeWindow ^<Window | Win32Control>

	^self! !

"June 5, 2007 -> 22:0:25"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
redraw ^<Boolean>

	^redraw! !

"June 5, 2007 -> 22:0:26"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'control' !
changing

	"flush the cached background painter so that it updates"
	backgroundPainter := nil.
	
	super changing! !

"June 5, 2007 -> 22:0:28"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'control' !
deferringRedrawDo: blk <[^Object]>
	"defer redrawing during evaluation of blk.  If these calls are nested recursively,
	   redrawing is deferred until the outermost returns, at which point the entire control
	   is invalidated.  This can be used to surround a large number of changes to the receiver
	   that would otherwise cause redundant redrawing."

	| oldFlag <Boolean> |
	oldFlag := self redraw.
	self redraw: false.
	blk value.
	self redraw: oldFlag.
	oldFlag
		ifTrue: [ self invalidate ]! !

"June 5, 2007 -> 22:0:30"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'control' !
ignoreNextFocusSet: flag <Boolean>

	ignoreNextFocusSet := flag! !

"June 5, 2007 -> 22:0:31"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'control' !
release

	self hasWin32Handle
		ifTrue: [ self destroyWin32Handle ].
	super release.! !

"June 5, 2007 -> 22:0:34"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'control' !
visible: flag <Boolean>

	| data <ExternalData> |
	self assert: [ self hasWin32Handle ].

	data := flag ifTrue: [ Win32 SW_SHOW ] ifFalse: [ Win32 SW_HIDE ].
	{{<user ExternalProxy ShowWindow> hwnd: self win32Handle flag: data}}.! !

"June 5, 2007 -> 22:0:37"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'debugging' !
printAllocOn: strm <CharOutputStream>

	super printAllocOn: strm.
	self hasWin32Handle
		ifTrue: [	strm show: ' hwnd: '; print: self win32Handle ]
		ifFalse: [ strm show: ' (no hwnd)' ]! !

"June 5, 2007 -> 22:0:39"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'displaying' !
localDisplayOn: can <Canvas>

	can subwindowsToDisplay add: self! !

"June 5, 2007 -> 22:0:41"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'event handling' !
character: c <Character> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	^(self callOrigWndProcFor: ev msg) = 0! !

"June 5, 2007 -> 22:0:43"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'event handling' !
keyDown: key <Symbol> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	^(self callOrigWndProcFor: ev msg) = 0! !

"June 5, 2007 -> 22:0:45"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'event handling' !
keyUp: key <Symbol> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	^(self callOrigWndProcFor: ev msg) = 0! !

"June 5, 2007 -> 22:0:48"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'event handling' !
mouseEvent: type <Symbol> at: loc <Point> event: ev <UIEvent> ^<Boolean>

	| orig <Point> |

	"Translate location back into native window coordinates"
	orig := self allocation enclosingRect origin.
	^(self callOrigWndProcFor: ev msg withLParam: (ExternalProxy forHigh: loc y - orig y low: loc x - orig x)) = 0! !

"June 5, 2007 -> 22:0:50"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'geometry-local' !
allocation: r <Region> at: pos <Point>

	| oldAlloc <Region> alloc <Rect> oldLayoutStatus <Int> |
	oldLayoutStatus := self layoutStatus.
	oldAlloc := allocation.
	alloc := r enclosingRect.
	super allocation: r at: pos.

	oldAlloc isNil
		ifTrue: [ self win32Handle.		"Make sure window is created with the current allocation & position" ]
		ifFalse: [	| oldNativePos <Point> old <Rect> | 
						"We need to use a variable since pos...Window changes nativePos"
						old := oldAlloc enclosingRect.
						oldNativePos := nativePosition.
						self hasWin32Handle
							ifTrue: [	(old width ~= alloc width
													or: [ old height ~= alloc height
													or: [ oldNativePos ~= self nativePosition ]  ] )
												ifTrue: [  self updateWindowDimensions  ]	 ]
							ifFalse: [	self isAttached
												ifTrue: [ self win32Handle ]	] ].
	"Invalidate if we are relaying out as a %hack to solve the problems that a higher level
		relayoutAndInvalidate doesn't invalidate contained native windows like this one"
	oldLayoutStatus = Visual needsRelayout
		ifTrue: [ self invalidate ]! !

"June 5, 2007 -> 22:0:53"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'geometry-nonlocal' !
moveBy: positionDelta <Point>

	"We override this since moving a native visual will generate any needed invalidations
	  automatically."

	self adjustPositionBy: positionDelta! !

"June 5, 2007 -> 22:0:56"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'initialization' !
initialize

	super initialize.
	redraw := true.
	enabled := true.
	isFocus := false.
	self addNonLocalCount: 1.		"Receiver is non-local"
	ignoreNextFocusSet := false.

	self refreshInterval: self defaultRefreshInterval.
	self paintPending: false.
	self useDisplayBuffering: true.
	controls := IdentitySet[Win32Control] new.! !

"June 5, 2007 -> 22:0:59"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
checkPaintTime: t <Float>
	"If we have reached our refresh time, paint"

	(self hasWin32Handle and: [ self paintPending ])
		ifTrue: [ self nextPaintTime <= t
						ifTrue: [ self display ]
						ifFalse: [ self session needPaintAtTime: self nextPaintTime ]	 ]! !

"June 5, 2007 -> 22:1:0"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
controls ^<Extensible[Win32Control]>

	^controls! !

"June 5, 2007 -> 22:1:2"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
cursor ^<Cursor>

	^cursor! !

"June 5, 2007 -> 22:1:4"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
cursor: c <Cursor>

	cursor := c.! !

"June 5, 2007 -> 22:1:6"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
defaultRefreshInterval ^<Float>

	^0.25! !

"June 5, 2007 -> 22:1:8"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
globalFromLocalPosition: p <WinPOINT> ^<WinPOINT>

	| wp <WinPOINT> result <WinPOINT> |
	wp := WinPOINT new allocate.
	wp x: p x; y: p y.
	{{<user ExternalProxy ClientToScreen>
			handle: self win32Handle
			point: wp
	}} asBoolean
		ifFalse: [ Win32 handleError ].
	result := wp x @ wp y.
	wp free.
	^result! !

"June 5, 2007 -> 22:1:11"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
handleMouseEvent: type <Symbol> at: loc <Point> ^<Boolean>

	| ev <UIEvent> |

	"%todo: remove the dispatch block for all events; isn't needed anymore"
	ev := UIEvent
			forMsg: self session currentMsg
			dispatch:
				[ :e <UIEvent> :h <UIEventHandler> |
					h mouseEvent: type at: loc event: e ].
	Sampler notNil
		ifTrue: [ Sampler 
						in: self topWindow visual 
						sampleEvent: type 
						at: (loc translatedBy: self positionInTopWindow)
						event: ev ].
	^self mouseEvent: type at: loc event: ev! !

"June 5, 2007 -> 22:1:13"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
localFromGlobalPosition: p <WinPOINT> ^<WinPOINT>

	| wp <WinPOINT> result <WinPOINT> |
	wp := WinPOINT new allocate.
	wp x: p x; y: p y.
	{{<user ExternalProxy ScreenToClient>
			handle: self win32Handle
			point: wp
	}} asBoolean
		ifFalse: [ Win32 handleError ].
	result := wp x @ wp y.
	wp free.
	^result translatedBy: self allocation enclosingRect origin! !

"June 5, 2007 -> 22:1:15"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
nextPaintTime ^<Float>

	^nextPaintTime! !

"June 5, 2007 -> 22:1:17"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
nextPaintTime: t <Float>

	nextPaintTime := t! !

"June 5, 2007 -> 22:1:19"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
noPalette

	palette := nil! !

"June 5, 2007 -> 22:1:21"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
paintOccuring

	self nextPaintTime: Time clockValue + self refreshInterval.
	self paintPending: false.
	self session paintOccuredFor: self.! !

"June 5, 2007 -> 22:1:22"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
paintPending ^<Boolean>

	^paintPending! !

"June 5, 2007 -> 22:1:23"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
paintPending: b <Boolean>

	paintPending := b! !

"June 5, 2007 -> 22:1:24"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
palette ^<Palette>

	^palette! !

"June 5, 2007 -> 22:1:25"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
palette: p <Palette>

	p == palette
		ifTrue: [ ^self ].
	self assert: [ palette isNil ].
	palette := p! !

"June 5, 2007 -> 22:1:26"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
paletteChangedMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	wParam @= self win32Handle
		ifFalse: [ self recursiveRealizePaletteForeground: false updateColors: true.
						self palette isNil
							ifTrue: [ ^self callDefWndProcFor: hwnd
											msgCode: msg
											wParam: wParam
											lParam: lParam	].
					 ].
	^0! !

"June 5, 2007 -> 22:1:27"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
queryPaletteMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self recursiveRealizePaletteForeground: true updateColors: false.
	self palette isNil
		ifTrue: [ ^self callDefWndProcFor: hwnd
						msgCode: msg
						wParam: wParam
						lParam: lParam	].
	^0! !

"June 5, 2007 -> 22:1:28"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
recursiveRealizePaletteForeground: fore <Boolean> updateColors: update <Boolean>

	self palette isNil
		ifFalse: [	self withDCDo:
							[ :hdc <HDC> |
								| oldpal <Win32Handle> |
								oldpal := Palette select: self palette win32Handle into: hdc background: fore not.
								self palette unrealize.
								self palette realizeFor: hdc.
								Palette debugging
									ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
								Palette select: oldpal win32Handle into: hdc background: fore not.
							 ].
						self invalidate.
						].
	self controls do:
		[ :c <Win32Control> |
			c recursiveRealizePaletteForeground: fore updateColors: update ].! !

"June 5, 2007 -> 22:1:29"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
refreshInterval ^<Float>

	^refreshInterval! !

"June 5, 2007 -> 22:1:30"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
refreshInterval: d <Float>
	"Wait no longer than this amount of time (in seconds) between
		paint operations, if possible"

	refreshInterval := d! !

"June 5, 2007 -> 22:1:31"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
registerControl: c <Win32Control>

	self controls include: c! !

"June 5, 2007 -> 22:1:32"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
registerPaintTime

	self paintPending
		ifFalse: [	self paintPending: true.
						self nextPaintTime: Time clockValue + self refreshInterval.
						self session schedulePaintFor: self at: self nextPaintTime.	].! !

"June 5, 2007 -> 22:1:33"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
setCursor ^<ExternalData>

	^cursor isNil
		ifFalse: [	{{<user ExternalProxy SetCursor> handle: cursor win32Handle}}.
						1 ]
		ifTrue: [ 0 ]! !

"June 5, 2007 -> 22:1:35"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
setCursorMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^(cursor notNil
			and: [	| hitcode <Int> |
						hitcode := lParam asExternalProxy low.
						hitcode = 1 or: [ hitcode = 65534 ] "client area or disabled"  ])
		ifTrue: [ 	self setCursor.
						1 ]
		ifFalse: [ self callOrigWndProc: msg wParam: wParam lParam: lParam ]
! !

"June 5, 2007 -> 22:1:36"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
showTimes ^<Boolean>
	"Report preference, layout, and painting times on the transcript"

	^false! !

"June 5, 2007 -> 22:1:37"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
unregisterControl: c <Win32Control>

	self controls removeEvery: c! !

"June 5, 2007 -> 22:1:38"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
useDisplayBuffering ^<Boolean>

	^useDisplayBuffering! !

"June 5, 2007 -> 22:1:39"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
useDisplayBuffering: f <Boolean>

	useDisplayBuffering := f! !

"June 5, 2007 -> 22:1:40"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
withBufferedCanvasDo: drawing <[Canvas,^X def]> ^<X>

	^self withDirectCanvasDo:
		[ :directCanvas <Canvas> |
			| invalid <Rect> oldpal <Win32Handle> |
			invalid := directCanvas clippingRect.

			self session
				withBufferCanvasFor: invalid
				do: [ :bufferCanvas <Canvas> :buffer <HBITMAP> |
							self palette isNil
								ifFalse: [ oldpal := bufferCanvas win32Palette: self palette win32Handle ].

							"draw on the buffer canvas"
							drawing value: bufferCanvas.
							bufferCanvas shallowFlush.

							"Now, copy the buffer bits onto the screen"
							directCanvas atOffset: invalid origin
								do: [ bufferCanvas atOffset: invalid origin 
									do: [	directCanvas
													bitBlt: bufferCanvas
												extent: invalid extent
												op: UI ropCopy.		].	].
							oldpal notNil
								ifTrue: [ 	Palette debugging
													ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
												bufferCanvas win32Palette: oldpal ]. 
						].	
		]! !

"June 5, 2007 -> 22:1:41"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
withCanvasDo: drawing <[Canvas,^X def]> ^<X>

	^(self useDisplayBuffering and: [ Window bufferingPossible ])
		ifFalse: [	self withDirectCanvasDo: drawing ]
		ifTrue: [	self withBufferedCanvasDo: drawing ]! !

"June 5, 2007 -> 22:1:42"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
withDCDo: blk <[HDC]>
	"With the window's device context do the block (not for painting)"

	| hdc <HDC> |
	hdc := {{<user HDC GetDC> hwnd: self win32Handle}}.
	[ blk value: hdc ]
		ensure: [ hdc releaseDCFor: self win32Handle ]! !

"June 5, 2007 -> 22:1:44"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
withDirectCanvasDo: drawing <[Canvas,^X def]> ^<X>

	|	can <Canvas>
		ps <PAINTSTRUCT>
		paintBlk <[^Object]>
		result <X>
		oldpal <Win32Handle>  |

	"use a critical region to paint, since background painting might reuse the
	  same device context in the UI thread"
	^self critical:
		[	ps := PAINTSTRUCT new allocateZeroed.
			can := self beginPaint: self win32Handle paintStructure: ps.
			can isNull
				ifTrue: [ Win32 handleError ].
			can	initialize;
				toRelease: [ :dc <HDC> | "End paint will release the context" ];
				initClippingRectBeforeTranslation: ps rcPaint asRectangle;
				window: self.
			self palette isNil
				ifFalse: [ oldpal := can win32Palette: self palette win32Handle ].

			Session debugInvalidation
				ifTrue: [	can withPainter: (Painter new paint: Paint red)
									do: [ can displayFilledRectangle: ps rcPaint asRectangle; flush. ].
								Platform errorStream show: self class name, ' rendering: '; print: ps rcPaint asRectangle; cr.	].

			result := drawing value: can.
			oldpal notNil
				ifTrue: [ 	Palette debugging
									ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
								can win32Palette: oldpal ]. 
			can release. 

			self endPaint: self win32Handle paintStructure: ps.
			ps free.
			result	]! !

"June 5, 2007 -> 22:1:45"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Windows with mods' !
display

	"win32 controls do no Smalltalk level painting by default"! !

"June 5, 2007 -> 22:1:46"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'notification' !
detaching

	super detaching.
	self cleanUp! !

"June 5, 2007 -> 22:1:47"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'notification' !
isFocus: f <Boolean>

	isFocus := f.
	super isFocus: f.
! !

"June 5, 2007 -> 22:1:48"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'notification' !
nativePositionChanged

	"DON'T pass this message to super, since our children are native relative to us!!"

	(self checkForNativePositionChanging or: [ self isAttached ])
		ifTrue: [ self updateWindowDimensions ]! !

"June 5, 2007 -> 22:1:49"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
buildWin32Handle

	self subclassResponsibility! !

"June 5, 2007 -> 22:1:50"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
callOrigWndProc: msgCode <ExternalData> wParam: wParam <ExternalData> lParam: lParam <ExternalData>^<ExternalData>
	"Like callOrigWndProcFor:, but takes all args rather than using a MSG structure"

	"Note that we use the receiver's win32Handle below rather than the one in the message so
	 	 this works even when the event was generated during a grab"
	^{{<user ExternalProxy CallWindowProcA> 
		proc: self originalWndProc
		hwnd: self win32Handle
		msg: msgCode
		wparam: wParam
		lparam: lParam }}! !

"June 5, 2007 -> 22:1:51"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
callOrigWndProcFor: m <MSG> ^<ExternalData>

	"Note that we use the receiver's win32Handle below rather than the one in the message so
	 	 this works even when the event was generated during a grab"
	^{{<user ExternalProxy CallWindowProcA> 
		proc: self originalWndProc
		hwnd: self win32Handle
		msg: m message
		wparam: m wParam
		lparam: m lParam }}! !

"June 5, 2007 -> 22:1:52"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
callOrigWndProcFor: m <MSG> withLParam: lParam <ExternalData>^<ExternalData>
	"Like callOrigWndProcFor:, but overrides the lParam value from the msg"

	"Note that we use the receiver's win32Handle below rather than the one in the message so
	 	 this works even when the event was generated during a grab"
	^{{<user ExternalProxy CallWindowProcA> 
		proc: self originalWndProc
		hwnd: self win32Handle
		msg: m message
		wparam: m wParam
		lparam: lParam }}! !

"June 5, 2007 -> 22:1:53"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
canBeFocusCandidate ^<Boolean>
	"%optional: Subclasses that cannot be the input focus even when they are enabled should override this
	  to return false"

	^true! !

"June 5, 2007 -> 22:1:54"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
checkForNativePositionChanging ^<Boolean>
	"returns true if the native position has been changed"

	
	^self hasWin32Handle
			and: [	| oldpos <Point> |
						oldpos := nativePosition.
						oldpos ~= self nativePosition	]! !

"June 5, 2007 -> 22:1:55"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
cleanUp

	self isFocus
		ifTrue: [	self nativeWindow ignoreNextFocusSet: true.
						self session noInputFocus. ].
	self destroyWin32Handle.
! !

"June 5, 2007 -> 22:1:56"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
controlId ^<Int>

	^controlId! !

"June 5, 2007 -> 22:1:57"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
createNativeWindow

	"we need a critical region to protect the class variable:"
	Win32Control
		critical: [	controlId := self actualClass assignId.
							self actualClass registerControl: self controlId for: self.
							self paintPending: false.
							self buildWin32Handle.
							self palette notNil
								ifTrue: [ self recursiveRealizePaletteForeground: true updateColors: true. ].
							self nativeWindow registerControl: self.
	
							self originalWndProc: (self wndProc).
							self wndProc: self customWndProc.
							self isFocus
								ifTrue: [ self setFocus ].
						].! !

"June 5, 2007 -> 22:1:58"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
createVisible ^<Boolean>

	^true! !

"June 5, 2007 -> 22:1:59"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
customWndProc ^<APICallback>

	^self actualClass customWndProc! !

"June 5, 2007 -> 22:2:0"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
debugTest: msgCode <ExternalData> for: hwnd <ExternalData>

	Win32Control debugEvents
			ifTrue: [	Platform errorStream
									show: 'control winproc event: ';
									show: (MSG descriptionOf: msgCode asExternalProxy);
									show: ' window: ';
									print: hwnd;
									cr. 	].! !

"June 5, 2007 -> 22:2:2"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
destroyWin32Handle

	win32Handle notNil
		ifTrue: [	| hand <ExternalProxy> |
						self actualClass unregisterControl: self controlId.
						self nativeWindow unregisterControl: self.
						hand := self win32Handle.
						win32Handle := nil.		"We nil the handle before destroying so that we can tell
																we are dead if there is a focus shift caused by destroy"
						{{<user ExternalProxy DestroyWindow>
							handle: hand }}.		]! !

"June 5, 2007 -> 22:2:3"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
displayUpwardPopUpMenuAt: loc <Point> ^<Boolean>
	"Look up the parent chain for a popUp menu and display it, if there is one.
		Return true if one was found"

	| m <Menu> t <Timer> |
	m := self parent popUpMenuIfAbsent: [ ^false ].
	self	displayPopUpMenu: m
			at: loc
			forButton: #secondary.
	t := self session atIntervals: 1.0 do:
			[	m release.
				t release. ].
	^true! !

"June 5, 2007 -> 22:2:4"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
extendedWin32Style ^<ExternalData>

	^Win32 WS_EX_NOPARENTNOTIFY! !

"June 5, 2007 -> 22:2:5"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
handleMouseEvent: type <Symbol>
message: msgCode <ExternalData>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>

	| loc <Point> |
	"Translate to be relative to our origin"
	loc := (lParam low @ lParam high) + self allocation enclosingRect origin.
	self handleMouseEvent: type at: loc! !

"June 5, 2007 -> 22:2:6"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
hasWin32Handle ^<Boolean>

	^win32Handle notNil! !

"June 5, 2007 -> 22:2:7"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
invalidate: r <Region>

	self registerPaintTime.
	(self layoutStatus = Visual valid and: [ self hasWin32Handle ])
		ifTrue: [	| rect <Rect> nativerect <RECT> |

						nativerect := RECT new allocate.
						rect := r enclosingRect relativeTo: self allocation origin.
						nativerect
							left: rect left asInteger;
							right: rect right asInteger;
							top: rect top asInteger;
							bottom: rect bottom asInteger.
						{{<user ExternalProxy InvalidateRect>
							hwnd: self win32Handle
							RECT: nativerect
							erase: true}}.
						nativerect free.	]! !

"June 5, 2007 -> 22:2:8"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
nativePosition ^<Point>

	"We have to adjust for the fact that our allocation origin might not be 0@0"
	^nativePosition := self positionInContainingNativeWindow + self allocation enclosingRect origin! !

"June 5, 2007 -> 22:2:9"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
originalWndProc ^<HWND>

	^originalWndProc! !

"June 5, 2007 -> 22:2:10"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
originalWndProc: h <HWND>

	originalWndProc := h! !

"June 5, 2007 -> 22:2:11"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
redraw: flag <Boolean>
	"Tell the widget to start or stop redrawing (temporarily) when necessary.  This is usually used
		with a true arg before a large number of changes, followed by a send with a false arg."

	flag = self redraw
		ifFalse: [	redraw := flag.
						self hasWin32Handle
							ifTrue: [	self	sendMessage: Win32 WM_SETREDRAW
													wparam: flag asExternalData
													lparam: 0	]].! !

"June 5, 2007 -> 22:2:12"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
setEnabled: flag <Boolean>

	enabled := flag.
	win32Handle notNil
		ifTrue: [	{{<user ExternalProxy EnableWindow>
								handle: self win32Handle
								state: self fullyEnabled asExternalData}}.	].
! !

"June 5, 2007 -> 22:2:14"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
setWindowText: t <Str>

	| label <CString> |
	label := CString for: t.
	{{<user ExternalProxy SetWindowText>
		handle: self win32Handle
		str: label}}.
	label free.! !

"June 5, 2007 -> 22:2:15"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
updateWindowDimensions
	"set the control's native size and position"

	| pos <Point> |

	pos := self nativePosition.
	self paintPending: false.
	{{<user ExternalProxy MoveWindow>
		handle: self win32Handle
		x: pos x asInteger
		y: pos y asInteger
		width: self allocation enclosedRect width asInteger
		height: self allocation enclosedRect height asInteger
		repaint: true asExternalData
	 }} asBoolean
			ifFalse: [ Win32 handleError ]! !

"June 5, 2007 -> 22:2:16"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
win32Style ^<ExternalData>

	| s <ExternalData> |
	s := Win32 WS_CHILDWINDOW.
	self createVisible
		ifTrue: [ s := s externalBitOr: Win32 WS_VISIBLE. ].
	self fullyEnabled
		ifFalse: [ s := s externalBitOr: Win32 WS_DISABLED ].
	^s! !

"June 5, 2007 -> 22:2:17"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
wndProc ^<ExternalProxy>

	^Window wndProcOf: self win32Handle! !

"June 5, 2007 -> 22:2:18"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
wndProc: wp <ExternalProxy>

	Window wndProcOf: self win32Handle put: wp! !

"June 5, 2007 -> 22:2:19"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private-message handling' !
beforeKillFocus

	(self session hasInputFocus and: [ self session inputFocus nativeWindow = self ])
		ifTrue: [ self session noInputFocus ].! !

"June 5, 2007 -> 22:2:20"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private-message handling' !
beforeSetFocus

	ignoreNextFocusSet
		ifTrue: [	"We requested the focus, and have already recorded it, so
							ignore this."
						ignoreNextFocusSet := false.	]
		ifFalse: [	"We didn't request this, so windows must be requesting it, so
							record it"
						"We don't use becomeFocus here because that would cause another
							windows setFocus message"
						self session inputFocus: self.		]! !

"June 5, 2007 -> 22:2:21"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private-message handling' !
contextMenuMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<Boolean>

	^self displayUpwardPopUpMenuAt:
			(self localFromGlobalPosition: lParam low @ lParam high)! !

"June 5, 2007 -> 22:2:22"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private-testing' !
isFocusCandidate ^<Boolean>

	^self canBeFocusCandidate
		and: [ self hasWin32Handle
		and: [ self enabled ] ]! !

"June 5, 2007 -> 22:2:23"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private-testing' !
isRectangularAndOpaque ^<Boolean>

	^true! !

"June 5, 2007 -> 22:2:24"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-to session' !
blinkFocus: shown <Boolean>
	
! !

"June 5, 2007 -> 22:2:25"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
buttonColorMsg: hdc <ExternalProxy> ^<ExternalData>

	"Should only get sent to buttons, which override this"
	self shouldNotHappen! !

"June 5, 2007 -> 22:2:26"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
commandWith: notifyCode <ExternalData> ^<ExternalData>

	"Subclasses should override to process command msgs"! !

"June 5, 2007 -> 22:2:27"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
drawItemMsg: data <DRAWITEMSTRUCT> ^<ExternalData>

	self shouldNotHappen! !

"June 5, 2007 -> 22:2:28"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
hInstance ^<ExternalProxy>

	^self parent nativeWindow hInstance! !

"June 5, 2007 -> 22:2:29"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
measureItemMsg: data <MEASUREITEMSTRUCT> ^<ExternalData>

	self shouldNotHappen! !

"June 5, 2007 -> 22:2:31"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
message: msgCode <ExternalData>
for: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self debugTest: msgCode for: hwnd.

	(self session handleIfFocusMsg: msgCode for: self wParam: wParam lParam: lParam) = 0
		ifTrue: [ ^0 ].

	msgCode @= Win32 WM_LBUTTONDOWN 
		ifTrue: [	self handleMouseEvent: #primaryButtonDown
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_LBUTTONUP 
		ifTrue: [	self handleMouseEvent: #primaryButtonUp
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_LBUTTONDBLCLK
		ifTrue: [	self handleMouseEvent: #primaryButtonDoubleClick
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_RBUTTONDOWN 
		ifTrue: [	self handleMouseEvent: #secondaryButtonDown
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_RBUTTONUP 
		ifTrue: [	self handleMouseEvent: #secondaryButtonUp
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_RBUTTONDBLCLK
		ifTrue: [	self handleMouseEvent: #secondaryButtonDoubleClick
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_MOUSEMOVE 
		ifTrue: [	self handleMouseEvent: #mouseMove
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].

	msgCode @= Win32 WM_CTLCOLORBTN
		ifTrue: [ ^Win32Control buttonColorMsg: wParam asExternalProxy for: (Win32Control controlIdFor: lParam) ].

	msgCode @= Win32 WM_DRAWITEM
		ifTrue: [	^Win32Control drawItemMsg: (DRAWITEMSTRUCT forProxy: lParam) for: wParam asSmallInteger ].

	msgCode @= Win32 WM_MEASUREITEM
		ifTrue: [	| data <MEASUREITEMSTRUCT> |
						data := MEASUREITEMSTRUCT forProxy: lParam.
						data CtlType @= Win32 ODT_MENU
							ifFalse: [ ^Win32Control measureItemMsg: data for: data CtlID asSmallInteger ] ].

	(msgCode @= Win32 WM_COMMAND and: [ lParam @~= Win32 NULL ])
		ifTrue: [	"Then this is a control window notification, which should be forwarded back to the
						  smalltalk control object"
						Win32Control notificationMsg: wParam asExternalProxy high for: (Win32Control controlIdFor: lParam).
						^0 ].

	msgCode @= Win32 WM_SETFOCUS
		ifTrue: [ self beforeSetFocus ].
	msgCode @= Win32 WM_KILLFOCUS
		ifTrue: [ self beforeKillFocus ].

	msgCode @= Win32 WM_CONTEXTMENU
		ifTrue: [ (self contextMenuMsg: msgCode hwnd: hwnd wParam: wParam lParam: lParam)
						ifTrue: [ ^0 ]. ].

	msgCode @= Win32 WM_QUERYNEWPALETTE 
		ifTrue: [	self queryPaletteMsg: msgCode hwnd: hwnd
								wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_PALETTECHANGED 
		ifTrue: [	self paletteChangedMsg: msgCode hwnd: hwnd
								wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_SETCURSOR 
		ifTrue: [	^self setCursorMsg: msgCode hwnd: hwnd
								wParam: wParam lParam: lParam	 ].

	^{{<user ExternalProxy CallWindowProcA> 
		proc: self originalWndProc
		hwnd: hwnd
		msg: msgCode
		wparam: wParam
		lparam: lParam }}! !

"June 5, 2007 -> 22:2:32"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
notificationMsg: notifyCode <ExternalData>

	"Subclasses can extend to process notification msgs"

	Win32Control debugNotifications
			ifTrue: [ Platform errorStream
							show: 'control notification: ';
							print: notifyCode;
							show: ' window: ';
							print: self win32Handle;
							cr ].

	notifyCode @= Win32 BN_KILLFOCUS
		ifTrue: [ "%todo" ].
	notifyCode @= Win32 BN_SETFOCUS
		ifTrue: [ "%todo" ].
! !

"June 5, 2007 -> 22:2:33"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
sendMessage: msg <ExternalData>
wparam: wp <ExternalData>
lparam: lp <ExternalData>
^<ExternalProxy>

	^{{<user ExternalProxy SendMessageA>
			handle: self win32Handle
			msg: msg
			wparam: wp
			lparam: lp}}! !

"June 5, 2007 -> 22:2:34"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
setFocus

	ignoreNextFocusSet := true.
	 self win32Handle @= {{<user ExternalProxy GetFocus> call}}
		ifFalse: [  {{<user ExternalProxy SetFocus> hwnd: self win32Handle}} ]! !

"June 5, 2007 -> 22:2:35"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
win32Handle ^<HWND>

	win32Handle isNil	
		ifTrue: [ self createNativeWindow ].
	^win32Handle! !

"June 5, 2007 -> 22:2:37"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'testing' !
isFocus ^<Boolean>

	^isFocus! !

"June 5, 2007 -> 22:2:51"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 22:2:53"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 22:2:54"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 22:2:55"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 22:2:55"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 22:2:56"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 22:2:57"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 22:2:57"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 22:2:58"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 22:2:58"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 22:2:59"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 22:3:0"!

(Delta mirrorFor: #Window)
comment: 
'Native windows, with a fairly machine independent interface
(except for methods with ''win32'' in their names).

Tags: %User %UI

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.
'!


"June 5, 2007 -> 22:3:2"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'custom messages' !
LAYOUT ^<ExternalData>
	"This is by the UI thread to tell a window's session process to layout a window.  This has
	  to be done through the message queue so that the layout code runs in the window's session
	  process.  lParam low is width, and lParam high is height."

	^16r400! !

"June 5, 2007 -> 22:3:3"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'debugging' !
bufferingPossible ^<Boolean>

	BufferingPossible isNil
		ifTrue: [ BufferingPossible := true ].
	^BufferingPossible! !

"June 5, 2007 -> 22:3:4"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'debugging' !
bufferingPossible: f <Boolean>
	"If this is set to false, all double buffering will be disabled, usually for debugging
		purposes."

	BufferingPossible := f! !

"June 5, 2007 -> 22:3:5"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
defaultWin32Cursor ^<ExternalProxy>

	^{{<user ExternalProxy LoadCursorA> arg: 0 arg: Win32 IDC_ARROW}}! !

"June 5, 2007 -> 22:3:6"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
defaultWin32Icon ^<ExternalProxy>

	^{{<user ExternalProxy LoadIconA> arg: 0 arg: Win32 IDI_APPLICATION}}! !

"June 5, 2007 -> 22:3:7"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
defaultWndProc ^<ExternalProxy>

	"Don't need a critical region because duplicate inits are no problem"
	DefaultWndProc isNil
		ifTrue: [	DefaultWndProc := Platform DLLLookup: 'DefWindowProcA' in: 'user' ].
	^DefaultWndProc! !

"June 5, 2007 -> 22:3:8"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
parentOf: w <HWND> ^<HWND>

	^{{<user ExternalProxy GetParent> wnd: w}}! !

"June 5, 2007 -> 22:3:9"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
wndProcOf: w <HWND> ^<HWND>

	^{{<user ExternalProxy GetWindowLongA> wnd: w attr: Win32 GWL_WNDPROC}}! !

"June 5, 2007 -> 22:3:10"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
wndProcOf: w <HWND> put: newWinProc <HWND> ^<HWND>

	^{{<user ExternalProxy SetWindowLongA> wnd: w attr: Win32 GWL_WNDPROC value: newWinProc}}! !

"June 5, 2007 -> 22:3:11"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
addNonLocalCount: delta <Int>
	
	! !

"June 5, 2007 -> 22:3:12"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
containerBackgroundPainter ^<Painter>

	^Painter defaultBackground! !

"June 5, 2007 -> 22:3:13"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
containsFocus: flag <Boolean>

	flag
		ifTrue: [	self session activeWindow: self.
						self mostRecentInputFocus: session inputFocus.	].
	"We don't need to remove the active window ifFalse because the session does that"! !

"June 5, 2007 -> 22:3:14"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
displayNowIfInvalid
	"Redraw any invalid areas before proceeded"

	self display! !

"June 5, 2007 -> 22:3:16"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
displayPopUpMenu: menu <Menu> at: loc <Point> forButton: button <Symbol>

	| gloc <Point> flags <ExternalData> |
	popUpMenu := menu.

	flags := Win32 TPM_LEFTALIGN.
	button = #left
		ifTrue: [ flags := flags externalBitOr: Win32 TPM_LEFTBUTTON ]
		ifFalse: [ flags := flags externalBitOr: Win32 TPM_RIGHTBUTTON ].

	gloc := self globalFromLocalPosition: loc.
	{{<user ExternalProxy TrackPopupMenu>
		handle: menu win32Handle
		flags: flags
		x: gloc x
		y: gloc y
		reserved: 0
		window: self win32Handle
		rect: Win32 NULL
	}} asBoolean
		ifFalse: [ Win32 getLastError @= Win32 ERROR_POPUP_ALREADY_ACTIVE
							ifFalse: [ Win32 handleError ].
						].

	popUpMenu := nil.
! !

"June 5, 2007 -> 22:3:17"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
invalidate: r <Region> forChild: child <Visual>

	self invalidate: (r enclosingRect translatedBy: child position)! !

"June 5, 2007 -> 22:3:18"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
isAttached ^<Boolean>

	^true! !

"June 5, 2007 -> 22:3:19"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
nativeWindow ^<Window | Win32Control>

	^self! !

"June 5, 2007 -> 22:3:20"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
parentVisualOfChild ^<Visual>

	self shouldNotHappen! !

"June 5, 2007 -> 22:3:22"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
popUpMenuIfAbsent: f <[^X def]> ^<Menu | X>

	^f value! !

"June 5, 2007 -> 22:3:23"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
positionInContainingNativeWindowOf: child <Visual> ^<Point>

	^child position! !

"June 5, 2007 -> 22:3:24"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
positionInTopWindowOf: child <Visual>

	^child position! !

"June 5, 2007 -> 22:3:25"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
scrollIfNeededToMakeVisible: area <Rect>
relativeTo: v <Visual>
minimizeMotion: minimizeMotion <Boolean>


	! !

"June 5, 2007 -> 22:3:26"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
scrollMeOrAParentBy: distance <Int> vertical: vertical <Boolean>

	"do nothing"! !

"June 5, 2007 -> 22:3:28"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
topWindow ^<Window>

	^self! !

"June 5, 2007 -> 22:3:29"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
translate: p <Point> fromChild: child <Visual> ^<Point>

	"Translate p from the child's coordinates to ours"
	^p translatedBy: child position! !

"June 5, 2007 -> 22:3:30"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
translate: p <Point> toChild: child <Visual> ^<Point>

	"Translate p from our coordinates to the child's"
	^p relativeTo: child position! !

"June 5, 2007 -> 22:3:31"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
translateRect: r <Rect> fromChild: child <Visual> ^<Rect>

	"Translate p from the child's coordinates to ours"
	^r translatedBy: child position! !

"June 5, 2007 -> 22:3:32"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
translateRect: r <Rect> toChild: child <Visual> ^<Rect>

	"Translate p from the child's coordinates to ours"
	^r relativeTo: child position! !

"June 5, 2007 -> 22:3:34"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
allocation ^<Region>

	^Point origin corner: self extent! !

"June 5, 2007 -> 22:3:35"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
backgroundPainter ^<Painter>
	"The paint for the window background.  This can be automatically derived from the
	 background painter for the visual.  It can also be set explicitly."

	^self hasBackgroundPainter
		ifTrue: [ backgroundPainter ]
		ifFalse: [ backgroundPainter := self visual backgroundPainter ]! !

"June 5, 2007 -> 22:3:36"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
backgroundPainter: p <Painter>

	backgroundPainter := p! !

"June 5, 2007 -> 22:3:37"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
cursor ^<Cursor>

	^cursor! !

"June 5, 2007 -> 22:3:39"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
cursor: c <Cursor>

	cursor := c.! !

"June 5, 2007 -> 22:3:40"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
desiredPosition: p <Point>

	desiredPosition := p! !

"June 5, 2007 -> 22:3:41"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
enabled ^<Boolean>

	^enabled! !

"June 5, 2007 -> 22:3:42"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
enabled: flag <Boolean>

	self enabled = flag
		ifFalse: [	self setEnabled: flag ].! !

"June 5, 2007 -> 22:3:43"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
extent ^<Point>

	^extent! !

"June 5, 2007 -> 22:3:45"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
hasParent ^<Boolean>

	^parent notNil! !

"June 5, 2007 -> 22:3:46"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
hasSession ^<Session>

	^session notNil! !

"June 5, 2007 -> 22:3:47"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
hasWin32Handle ^<Boolean>

	^win32Handle notNil! !

"June 5, 2007 -> 22:3:48"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
initialInputFocus: v <Visual>

	initialInputFocus := v! !

"June 5, 2007 -> 22:3:49"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
max ^<Rect>

	^max! !

"June 5, 2007 -> 22:3:51"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
medium ^<Medium>

	^medium! !

"June 5, 2007 -> 22:3:52"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
menu ^<Menu>

	^menu! !

"June 5, 2007 -> 22:3:53"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
menu: m <Menu>

	menu isNil
		ifFalse: [ menu release ].
	menu := m.
	menu window: self.
	self hasWin32Handle
		ifTrue: [ self setNativeMenu ]! !

"June 5, 2007 -> 22:3:54"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
min ^<Rect>

	^min! !

"June 5, 2007 -> 22:3:55"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
mostRecentInputFocus: v  <Visual>

	mostRecentInputFocus := v! !

"June 5, 2007 -> 22:3:56"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
name: nm <Str>

	"By default, do nothing. Subclasses with a title bar can override this"! !

"June 5, 2007 -> 22:3:57"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
natural ^<Rect>

	^natural! !

"June 5, 2007 -> 22:3:59"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
noPalette

	palette := nil! !

"June 5, 2007 -> 22:4:0"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
optimizeIncrementalLayout ^<Boolean>
^false.
	^optimizeIncrementalLayout! !

"June 5, 2007 -> 22:4:1"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
optimizeIncrementalLayout: f <Boolean>

	(f ~= optimizeIncrementalLayout and: [ self hasWin32Handle ])
		ifTrue: [ self changing ].
	optimizeIncrementalLayout := f.! !

"June 5, 2007 -> 22:4:2"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
palette ^<Palette>

	^palette! !

"June 5, 2007 -> 22:4:3"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
palette: p <Palette>

	p == palette
		ifTrue: [ ^self ].
	self assert: [ palette isNil ].
	palette := p! !

"June 5, 2007 -> 22:4:4"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
parent ^<Window>

	^parent! !

"June 5, 2007 -> 22:4:6"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
parent: p <Window>
	"This message must be sent before the window handle is created"

	parent := p! !

"June 5, 2007 -> 22:4:7"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
refreshInterval ^<Float>

	^refreshInterval! !

"June 5, 2007 -> 22:4:8"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
refreshInterval: d <Float>
	"Wait no longer than this amount of time (in seconds) between
		paint operations, if possible"

	refreshInterval := d! !

"June 5, 2007 -> 22:4:10"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
session ^<Session>

	^session! !

"June 5, 2007 -> 22:4:11"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
setNativeMenu

	{{<user ExternalProxy SetMenu>
		wnd: self win32Handle
		menu: self menu win32Handle
	}} asBoolean
		ifFalse: [ Win32 handleError ]! !

"June 5, 2007 -> 22:4:12"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
toClose ^<[Window]>

	^toClose! !

"June 5, 2007 -> 22:4:13"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
toClose: blk <[Window]>

	toClose := blk! !

"June 5, 2007 -> 22:4:14"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
useDisplayBuffering ^<Boolean>

	^useDisplayBuffering! !

"June 5, 2007 -> 22:4:15"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
useDisplayBuffering: f <Boolean>

	useDisplayBuffering := f! !

"June 5, 2007 -> 22:4:17"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
visual ^<Visual>

	^visual! !

"June 5, 2007 -> 22:4:18"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
close
	"Close and destroy the window.  This causes release to be sent to the window and its visual"

	self session aboutToDestroyWindow: self.
	{{<user ExternalProxy DestroyWindow> arg: win32Handle}}.
! !

"June 5, 2007 -> 22:4:19"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
ignoreNextFocusSet: flag <Boolean>

	ignoreNextFocusSet := flag! !

"June 5, 2007 -> 22:4:21"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
invalidate

	self visual layoutStatus > Visual invalid
		ifTrue: [ self invalidate: self allocation enclosingRect	].! !

"June 5, 2007 -> 22:4:22"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
invalidate: r <Region>

	| rect <Rect> |

	self registerPaintTime.
	rect := r enclosingRect.
	(self scratchRECT)
		left: rect left asInteger;
		right: rect right asInteger;
		top: rect top asInteger;
		bottom: rect bottom asInteger.
	{{<user ExternalProxy InvalidateRect>
		hwnd: self win32Handle
		RECT: self scratchRECT
		erase: false asExternalData}}! !

"June 5, 2007 -> 22:4:23"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
makeActive
	"Make this the active window"

	{{<user ExternalProxy SetForegroundWindow> hwnd: self win32Handle }}.! !

"June 5, 2007 -> 22:4:24"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
release

	scratchRECT free.

	self session unregisterWindow: self.

	visual notNil
		ifTrue: [	visual detaching; release.
						visual := nil.	].

	win32Handle := nil.

	self hasMenu
		ifTrue: [ self menu release ].
	mostRecentInputFocus := nil.
	menu := nil.
	popUpMenu := nil.
	toClose := nil.
	controls := nil.
! !

"June 5, 2007 -> 22:4:25"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
requestClose

	self toClose value: self.! !

"June 5, 2007 -> 22:4:27"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
show
	"Make the window visible"

	{{<user ExternalProxy ShowWindow>
			window: self win32Handle
			nCmdShow: self nCmdShow}}.
	! !

"June 5, 2007 -> 22:4:28"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
showModal
	"Make the window visible as a modal window"

	self session addModalWindow: self.
	self show.
	! !

"June 5, 2007 -> 22:4:29"!

! (Delta mirrorFor: #Window) methodsFor: 'debugging' !
dumpOn: strm <CharOutputStream>

Transcript show: self class name, ' extent: '; print: self extent; show: ' hwnd: '; print: self win32Handle; cr.
	self visual dumpOn: strm indent: 1.! !

"June 5, 2007 -> 22:4:31"!

! (Delta mirrorFor: #Window) methodsFor: 'event handling' !
character: c <Character> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	^(self visual character: c focus: focus event: ev)
		or: [	c = Character tab
					onTrue: [ self handleTabEvent: ev ] ]! !

"June 5, 2007 -> 22:4:32"!

! (Delta mirrorFor: #Window) methodsFor: 'event handling' !
keyDown: key <Symbol> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	(self visual keyDown: key focus: focus event: ev)
		ifTrue: [ ^true ].
		
	(key = #TAB and: [ ev ctrlPressed ])
		ifTrue: [ self handleTabEvent: ev.	^true ].
	key = #F1 ifTrue: [ Profiler start.	^true ].
	key = #F2 ifTrue: [ Profiler stop.	^true ].
	^false	! !

"June 5, 2007 -> 22:4:33"!

! (Delta mirrorFor: #Window) methodsFor: 'event handling' !
keyUp: key <Symbol> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	^self visual keyUp: key focus: focus event: ev
! !

"June 5, 2007 -> 22:4:34"!

! (Delta mirrorFor: #Window) methodsFor: 'event handling' !
mouseEvent: type <Symbol> at: loc <Point> event: ev <UIEvent> ^<Boolean>

	^self visual layoutStatus = Visual valid
		and: [ 	| grabGotIt <Boolean> |
						grabGotIt := self session
												mouseEvent: type
												at: loc
												event: ev.
						grabGotIt or: [	(self visual renderingRegion inParentContainsPoint: loc)
												and: [	Sampler notNil
																ifTrue: [ Sampler in: self visual sampleEvent: type at: loc - self visual position event: ev ].
															self visual
																mouseEvent: type
																at: loc - self visual position
																event: ev	] ] ]
! !

"June 5, 2007 -> 22:4:36"!

! (Delta mirrorFor: #Window) methodsFor: 'initialization' !
initSession: sess <Session>
visual: vis <Visual>

	medium := sess medium.
	session := sess.
	visual := vis.

	(self visual)
		parent: self id: 1.

	self showTimes
		ifTrue: [ Transcript show: 'prefs: '; print: [ self computePreferences ] time; cr. ]
		ifFalse: [ self computePreferences ].

	scratchRECT := RECT new allocate.
	self optimizeIncrementalLayout: true.
	ignoreNextFocusSet := false.

	self refreshInterval: self defaultRefreshInterval.
	self paintPending: false.
	self useDisplayBuffering: true.

	self toClose: [ :w <Window> | w close ].
	self enabled: true.
	controls := IdentitySet[Win32Control] new.
	self haveErased: false.! !

"June 5, 2007 -> 22:4:37"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
activeMenu ^<Menu>
	"Returns the menu that is currently active, if there is one.  It may either be the top level menu,
	  or a popup menu over the window"

	^popUpMenu notNil
		ifTrue: [ popUpMenu ]
		ifFalse: [ menu ]! !

"June 5, 2007 -> 22:4:38"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
beforeQueuedMessage

	"%remove this and calls to it"! !

"June 5, 2007 -> 22:4:40"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
beforeSetFocus

	ignoreNextFocusSet
		ifTrue: [	"We requested the focus, and have already recorded it, so
							ignore this."
						ignoreNextFocusSet := false.	]
		ifFalse: [	self visual layoutValid
							ifTrue: [	"We didn't request this, so windows must be requesting it, so
												record it"
											self findInputFocus	]	].! !

"June 5, 2007 -> 22:4:41"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
beginPaint: hwnd <HWND>  paintStructure: ps <PAINTSTRUCT>  ^<HDC>

	^{{<user HDC BeginPaint> arg: hwnd arg: ps}}! !

"June 5, 2007 -> 22:4:42"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
buildWin32Handle
	"Subclasses must implement to create the appropriate type of window handle &
	  store it in win32Handle"

	self subclassResponsibility! !

"June 5, 2007 -> 22:4:44"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
callAsyncDefWndProcFor: hwnd <HWND>
msgCode: msgCode <ExternalData>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>
	"like callDefWndProcFor:msgCode:wParam:lParam:
			but is asynchronous"

	^{{<user ExternalProxy DefWindowProcA async>
			hwnd: hwnd
			value: msgCode
			value: wParam
			value: lParam
	  }}! !

"June 5, 2007 -> 22:4:45"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
callDefWndProcFor: hwnd <HWND>
msgCode: msgCode <ExternalData>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^{{<user ExternalProxy DefWindowProcA>
			hwnd: hwnd
			value: msgCode
			value: wParam
			value: lParam
	  }}! !

"June 5, 2007 -> 22:4:46"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
computePreferences

	natural := Point origin corner: self visual natural enclosingRect extent.
	min := Point origin corner: self visual min enclosingRect extent.
	max := Point origin corner: self visual max enclosingRect extent.! !

"June 5, 2007 -> 22:4:47"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
controls ^<Extensible[Win32Control]>

	^controls! !

"June 5, 2007 -> 22:4:48"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
defaultRefreshInterval ^<Float>

	^0.25! !

"June 5, 2007 -> 22:4:50"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
defaultWndProc ^<ExternalProxy>

	^self actualClass defaultWndProc! !

"June 5, 2007 -> 22:4:51"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
deferredPaintRegion ^<Rect>

	^deferredPaintRegion! !

"June 5, 2007 -> 22:4:52"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
deferredPaintRegion: r <Rect>

	deferredPaintRegion := r! !

"June 5, 2007 -> 22:4:53"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
desiredXPos ^<ExternalData>

	^desiredPosition isNil
		ifFalse: [ desiredPosition x asInteger ]
		ifTrue: [  Win32 CW_USEDEFAULT ]! !

"June 5, 2007 -> 22:4:55"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
desiredYPos ^<ExternalData>

	^desiredPosition isNil
		ifFalse: [ desiredPosition y asInteger ]
		ifTrue: [  Win32 CW_USEDEFAULT ]! !

"June 5, 2007 -> 22:4:56"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
display

	| subs <Cltn[Win32Control]> |
	self withCanvasDo:
			[ :can <Canvas> |
				| paintBlk <[^Object]> |	
				paintBlk := 
					[	self paintBackgroundOn: can.
						self displayVisualIfCanOn: can.
						can shallowFlush.  ].
				self showTimes
					ifTrue: [  Transcript show: 'paint: '; print: paintBlk time; cr. ]
					ifFalse: [ paintBlk value ].
				can hasSubwindowsToDisplay
					ifTrue: [ subs := can takeSubwindowsToDisplay ].
			].
	subs notNil
		ifTrue: [	subs do:
							[ :sub <Win32Control> |
								"%hack: the handle test should not be 
									necessary; something is screwed up"
								sub hasWin32Handle
									ifTrue: [	sub sendMessage: Win32 WM_PAINT
														wparam: 0 lparam: 0.
												].
							].
					 ]! !

"June 5, 2007 -> 22:4:57"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
displayVisualIfCanOn: canvas <Canvas>

	self session visualCriticalWouldBlock
		ifTrue: [ self recordDeferredPaint: canvas clippingRect ]
		ifFalse: [	self paintOccuring.
						self visual displayOn: canvas.	]! !

"June 5, 2007 -> 22:4:58"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
endPaint: hwnd <HWND>  paintStructure: ps <PAINTSTRUCT>

	^{{<user ExternalProxy EndPaint> arg: hwnd arg: ps}}! !

"June 5, 2007 -> 22:4:59"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
extent: e <Point>
	"Change the window's extent.  This will cause a relayout
		to happen later, which will record the extent."

	| pos <Point> adjusted <Rect> |
	adjusted := self fitToMedium: e.
	pos := self getPosition.
	{{<user ExternalProxy MoveWindow>
		hwnd: self win32Handle
		x: pos x
		y: pos y
		width: adjusted x
		height: adjusted y
		repaint: true asExternalData
	}} asBoolean 
		ifFalse: [ Win32 handleError ].! !

"June 5, 2007 -> 22:5:1"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
findInputFocus

	"find some non-native visual
	  within us to give the input focus to."

	"If there is already a focus, and it is in this window, then we are in a callback caused
	  by our own attempt to set the focus, so do nothing."
	(self session hasInputFocus and: [ self session inputFocus nativeWindow = self ])
		ifTrue: [ ^self ].

	"If we have a valid memory of what our input focus was last time, use it"
	self purgeMostRecentFocusIfNeeded.
	(mostRecentInputFocus notNil and: [ mostRecentInputFocus topWindow = self ])
		ifTrue: [ "Search to see if the most recent one is still a reachable, valid candidate"
					 "%todo: we could optimize this by adding another call to the heirarchy called
						verifyFocusCandidate which sends verifyFocusCandidate:self up the heirarchy,
						giving pacifiers etc. a chance to deny it the focus.  This would be MUCH faster
						than the following loop."
					"Also note that we use session inputFocus: rather than becomeFocus, because this
						 thing was previously the focus, so we don't want to do things like scroll it"
					 self visual focusCandidatesDo:
						[ :cand <Visual> |
							cand = mostRecentInputFocus
								ifTrue: [	self session inputFocus: cand.

												^self		"^^^^^^^^^^^^^"		] ]. ].

	"There is no valid previous focus to reuse, so just choose the first one"
	(self visual firstFocusCandidateIfAbsent: [ ^self ])
		becomeFocus.
! !

"June 5, 2007 -> 22:5:2"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
fitToMedium: clientExtent <Point>  ^<Point>
	"takes a client extent, and returns a window extent adjusted so that it will fit on the screen"

	| normal <Point> withoutCaption <Point> captionHeight <Int> adjClient <Point> |	
	normal := (self windowSizeForClientAreaSize: clientExtent) min: self medium extent.
	withoutCaption := (self windowSizeWithoutCaptionForClientAreaSize: clientExtent) min: self medium extent.
	captionHeight := normal y - withoutCaption y.
	^self windowSizeForClientAreaSize:
			 (clientExtent x min: self medium extent x)
		@ ((clientExtent y + captionHeight min: self medium extent y) - captionHeight).! !

"June 5, 2007 -> 22:5:4"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
getPosition ^<Point>

	{{<user ExternalProxy GetWindowRect>
		hwnd: self win32Handle
		rect: self scratchRECT
	}} asBoolean
		ifFalse: [ Win32 handleError ].
	^self scratchRECT left @ self scratchRECT top! !

"June 5, 2007 -> 22:5:5"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
globalFromLocalPosition: p <WinPOINT> ^<WinPOINT>

	| wp <WinPOINT> result <WinPOINT> |
	wp := WinPOINT new allocate.
	wp x: p x; y: p y.
	{{<user ExternalProxy ClientToScreen>
			handle: self win32Handle
			point: wp
	}} asBoolean
		ifFalse: [ Win32 handleError ].
	result := wp x @ wp y.
	wp free.
	^result! !

"June 5, 2007 -> 22:5:6"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
handleTabEvent: ev <UIEvent>

	ev shiftPressed
		ifTrue: [ self moveFocusBack ]
		ifFalse: [ self moveFocusForward ]! !

"June 5, 2007 -> 22:5:7"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
hasBackgroundPainter ^<Boolean>

	^backgroundPainter notNil! !

"June 5, 2007 -> 22:5:9"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
hasMenu ^<Boolean>
	"Returns the menu that is currently active, if there is one.  It may either be the top level menu,
	  or a popup menu over the window"

	^popUpMenu notNil or: [ menu notNil ]! !

"June 5, 2007 -> 22:5:10"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
haveErased ^<Boolean>

	^haveErased! !

"June 5, 2007 -> 22:5:11"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
haveErased: f <Boolean>

	haveErased := f! !

"June 5, 2007 -> 22:5:13"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
initWindowsMessageHandlers

	WindowsMessageHandlers
		at: Win32 WM_CLOSE	put:
				[ :w <Window> :msg  <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w closeMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_SETCURSOR	put:
				[ :w <Window> :msg  <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w setCursorMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_PAINT	put:
				[ :w <Window> :msg  <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w paintMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_ERASEBKGND	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w eraseBackgroundMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_CTLCOLORBTN	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w buttonColorMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_DRAWITEM	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w drawItemMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_KEYDOWN	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w keyDownMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_KEYUP	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w keyUpMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_CHAR	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w characterMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];

		"mouse events are handled by a common event routine"
		at: Win32 WM_LBUTTONDOWN put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #primaryButtonDown at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_LBUTTONUP	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #primaryButtonUp at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_LBUTTONDBLCLK	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #primaryButtonDoubleClick at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_MBUTTONDOWN	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #middleButtonDown at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_MBUTTONUP	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #middleButtonUp at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_RBUTTONDOWN put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #secondaryButtonDown at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_RBUTTONUP put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #secondaryButtonUp at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_RBUTTONDBLCLK put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #secondaryButtonDoubleClick at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_MOUSEMOVE put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #mouseMove at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];

		at: Win32 WM_MEASUREITEM	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w measureItemMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_SETFOCUS	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w setFocusMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_KILLFOCUS	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w killFocusMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_COMMAND	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w commandMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_GETMINMAXINFO	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w getMinMaxInfoMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_SIZE	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w sizeMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_NCDESTROY	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w ncDestroyMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_DESTROY	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w destroyMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_CAPTURECHANGED	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w captureChangedMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_INITMENUPOPUP	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w initMenuPopupMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_QUERYNEWPALETTE	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w queryPaletteMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_PALETTECHANGED	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w paletteChangedMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];

		"---------- Custom messages"
		at: Window LAYOUT	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w layoutMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];

		yourself! !

"June 5, 2007 -> 22:5:15"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
initialInputFocus ^ <Visual>

	^initialInputFocus! !

"June 5, 2007 -> 22:5:16"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
layout: extent <Point>

	| firstLayout <Boolean> |

	firstLayout := self visual layoutStatus = Visual invalid.
 	self showTimes
		ifTrue: [	Transcript show: 'layout: '; print: [ 
								self visual allocationInParent: (0@0 corner: extent).
						] time; cr. ]
		ifFalse: [	self visual allocationInParent: (0@0 corner: extent). ].

	"We have to do this now because we can't set the input focus until layout is
		complete, since the containing native window must be accessed, etc."
	firstLayout
		ifTrue: [	self palette notNil
							ifTrue: [ self recursiveRealizePaletteForeground: true updateColors: true. ].
						(self initialInputFocus notNil and: [ self initialInputFocus isFocusCandidate ])
							ifTrue: [		self initialInputFocus becomeFocus.
												self initialInputFocus: nil 	"Not needed anymore, prevent memory leak"	]
							ifFalse: [	self findInputFocus ]
					  ]! !

"June 5, 2007 -> 22:5:18"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
localFromGlobalPosition: p <WinPOINT> ^<WinPOINT>

	| wp <WinPOINT> result <WinPOINT> |
	wp := WinPOINT new allocate.
	wp x: p x; y: p y.
	{{<user ExternalProxy ScreenToClient>
			handle: self win32Handle
			point: wp
	}} asBoolean
		ifFalse: [ Win32 handleError ].
	result := wp x @ wp y.
	wp free.
	^result! !

"June 5, 2007 -> 22:5:19"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
menuCommandForItem: id <Int>

	(MenuItem itemFor: id)
		execute! !

"June 5, 2007 -> 22:5:20"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
moveFocusBack

	(self visual lastFocusCandidateBefore: self session inputFocus)
		becomeFocus! !

"June 5, 2007 -> 22:5:22"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
moveFocusForward

	(self visual nextFocusCandidateAfter: self session inputFocus)
		becomeFocus! !

"June 5, 2007 -> 22:5:23"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
nCmdShow ^<ExternalProxy>

	^{{primitiveWindowsNCmdShow}}! !

"June 5, 2007 -> 22:5:24"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
nextPaintTime ^<Float>

	^nextPaintTime! !

"June 5, 2007 -> 22:5:25"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
nextPaintTime: t <Float>

	nextPaintTime := t! !

"June 5, 2007 -> 22:5:27"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
paintBackgroundOn: can <Canvas>

	can withPainter: self backgroundPainter do:
		[ can displayFilledRectangle:
			(Point origin corner: self allocation enclosingRect extent) ].! !

"June 5, 2007 -> 22:5:28"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
paintOccuring

	self nextPaintTime: Time clockValue + self refreshInterval.
	self paintPending: false.
	self session paintOccuredFor: self.! !

"June 5, 2007 -> 22:5:29"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
parentHandle ^<ExternalData>

	^parent isNil
		ifFalse: [ parent win32Handle ]
		ifTrue: [ Win32 NULL ]! !

"June 5, 2007 -> 22:5:30"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
purgeMostRecentFocusIfNeeded

	"%kludge: This should be called occasionally (in user time) to avoid memory leaks caused by
	  a pointer to a zombie visual"
	"%todo: this isn't called yet.  Set up a scanner that sends this to all windows every ten seconds or
	   so."
	(mostRecentInputFocus notNil and: [ mostRecentInputFocus isAttached not ])
		ifTrue: [ mostRecentInputFocus := nil ]! !

"June 5, 2007 -> 22:5:31"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
recordDeferredPaint: region <Rect> 

	self deferredPaintRegion:
		(self deferredPaintRegion isNil
			ifTrue: [ region ]
			ifFalse: [ self deferredPaintRegion merge: region ]
		)! !

"June 5, 2007 -> 22:5:32"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
recordExtent

		self setExtent: self trueClientAreaExtent.! !

"June 5, 2007 -> 22:5:34"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
registerPaintTime

	self paintPending
		ifFalse: [	self paintPending: true.
						self nextPaintTime: Time clockValue + self refreshInterval.
						self session schedulePaintFor: self at: self nextPaintTime.	].! !

"June 5, 2007 -> 22:5:35"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
relayoutIfNeeded

	self relayoutIfNeededForExtent: self extent! !

"June 5, 2007 -> 22:5:36"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
relayoutIfNeededForExtent: e <Point>

	self visual needsRelayout
		ifTrue: [ self layout: (self visual max enclosingRect extent min: e) ].
	self invalidate.! !

"June 5, 2007 -> 22:5:37"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
scratchRECT ^<RECT>

	^scratchRECT! !

"June 5, 2007 -> 22:5:39"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
setCursor ^<ExternalData>

	^cursor isNil
		ifFalse: [	{{<user ExternalProxy SetCursor> handle: cursor win32Handle}}.
						1 ]
		ifTrue: [ 0 ]! !

"June 5, 2007 -> 22:5:40"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
setEnabled: flag <Boolean>

	enabled := flag.
	self hasWin32Handle
		ifTrue: [	{{<user ExternalProxy EnableWindow async>
								handle: self win32Handle
								state: enabled asExternalData}}.	].! !

"June 5, 2007 -> 22:5:41"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
setExtent: e <Point>

	extent := e! !

"June 5, 2007 -> 22:5:42"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
setName: nm <Str>

	self hasWin32Handle
		ifTrue: [	| title <CString> |
						title := CString for: nm.
						[	{{<user ExternalProxy SetWindowTextA>
											hwnd: self win32Handle
											title: title
							}} asBoolean
								ifFalse: [ Win32 handleError ].
						] ensure: [ title free ]
					 ]! !

"June 5, 2007 -> 22:5:44"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
shouldCallDefaultHandlerAsynchronouslyFor: msgCode <ExternalData>  ^<Boolean>

	^msgCode @= Win32 WM_SYSCOMMAND		"so that window moves let other sessions repaint"! !

"June 5, 2007 -> 22:5:45"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
showTimes ^<Boolean>
	"Report preference, layout, and painting times on the transcript"

	^false! !

"June 5, 2007 -> 22:5:46"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
trueClientAreaExtent ^<Point>

	^self trueClientAreaExtentFor: self win32Handle! !

"June 5, 2007 -> 22:5:47"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
trueClientAreaExtentFor: hwnd <ExternalData> ^<Point>

	| extent <Point> rect <RECT> |
	rect := RECT new allocate.
	{{<user RECT GetClientRect> arg: hwnd arg: rect}}.
	extent := (rect right - rect left) @ (rect bottom - rect top).
	rect free.
	^extent! !

"June 5, 2007 -> 22:5:49"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
win32Handle: h <HWND>

	win32Handle := h! !

"June 5, 2007 -> 22:5:50"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
win32Style ^<ExternalData>

	| s <ExternalData> |
	s := 0.
	self enabled
		ifFalse: [ s := s externalBitOr: Win32 WS_DISABLED ].
	^s
! !

"June 5, 2007 -> 22:5:51"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
windowSizeForClientAreaSize: extent <Point>  ^<Point>
	"returns an integral point that is the correct window size for a desired client area size"

	^self windowSizeForClientAreaSize: extent windowStyle: self win32Style! !

"June 5, 2007 -> 22:5:52"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
windowSizeForClientAreaSize: extent <Point> windowStyle: style <ExternalData>  ^<Point>
	"returns an integral point that is the correct window size for a desired client area size"

	| r <RECT> result <Point> |
	r := RECT new allocate.
	r top: 0; left: 0; right: extent x asInteger; bottom: extent y asInteger.
	{{<user ExternalProxy AdjustWindowRect>
				 rect: r style: style hasMenu: self hasMenu asExternalData}} asBoolean
		ifFalse: [ Win32 handleError ].
	result := (r right - r left) @ (r bottom - r top).
	r free.
	^result! !

"June 5, 2007 -> 22:5:54"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
windowSizeWithoutCaptionForClientAreaSize: extent <Point>  ^<Point>
	"returns an integral point that is the correct window size for a desired client area size"

	^self windowSizeForClientAreaSize: extent
			windowStyle: (self win32Style externalBitAnd: (Win32 WS_CAPTION asSmallInteger bitInvert))! !

"June 5, 2007 -> 22:5:55"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
windowsMessageHandlers ^<Dict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>

	"Don't need critical region since duplicate inits are no problem"
	WindowsMessageHandlers isNil
		ifTrue: [	WindowsMessageHandlers :=
							CustomDictionary[ExternalData,[Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData]]
									withCompareBlock: [ :k1 <ExternalData> :k2 <ExternalData> |    k1 @= k2 ]
									hashBlock: [ :k <ExternalData> |  k hash ].
						self initWindowsMessageHandlers.
						].
	^WindowsMessageHandlers! !

"June 5, 2007 -> 22:5:57"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
withBufferedCanvasDo: drawing <[Canvas,^X def]> ^<X>

	^self withDirectCanvasDo:
		[ :directCanvas <Canvas> |
			| invalid <Rect> oldpal <Win32Handle> |
			invalid := directCanvas clippingRect.

			self session
				withBufferCanvasFor: invalid
				do: [ :bufferCanvas <Canvas> :buffer <HBITMAP> |

						self palette isNil
							ifFalse: [ oldpal := bufferCanvas win32Palette: self palette win32Handle ].

						"draw on the buffer canvas"
						drawing value: bufferCanvas.
						bufferCanvas shallowFlush.

						"Now, copy the buffer bits onto the screen"
						directCanvas atOffset: invalid origin
							do: [ bufferCanvas atOffset: invalid origin 
								do: [	directCanvas
											bitBlt: bufferCanvas
											extent: invalid extent
											op: UI ropCopy.		].	].
						 oldpal notNil
								ifTrue: [ 	Palette debugging
													ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
												bufferCanvas win32Palette: oldpal ]. 
						].	
		]! !

"June 5, 2007 -> 22:5:58"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
withCanvasDo: drawing <[Canvas,^X def]> ^<X>

	^(self useDisplayBuffering and: [ Window bufferingPossible ])
		ifFalse: [	self withDirectCanvasDo: drawing ]
		ifTrue: [	self withBufferedCanvasDo: drawing ]! !

"June 5, 2007 -> 22:5:59"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
withDCDo: blk <[HDC]>
	"With the window's device context do the block (not for painting)"

	| hdc <HDC> |
	hdc := {{<user HDC GetDC> hwnd: self win32Handle}}.
	[ blk value: hdc ]
		ensure: [ hdc releaseDCFor: self win32Handle ]! !

"June 5, 2007 -> 22:6:1"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
withDirectCanvasDo: drawing <[Canvas,^X def]> ^<X>

	|	can <Canvas>
		ps <PAINTSTRUCT>
		paintBlk <[^Object]>
		result <X>
		oldpal <Win32Handle> |

	"use a critical region to paint, since background painting might reuse the
	  same device context in the UI thread"
	^self critical:
		[	ps := PAINTSTRUCT new allocateZeroed.
			can := self beginPaint: self win32Handle paintStructure: ps.
			can isNull
				ifTrue: [ Win32 handleError ].
			can	initialize;
				toRelease: [ :dc <HDC> | "End paint will release the context" ];
				initClippingRectBeforeTranslation: ps rcPaint asRectangle;
				window: self.
			self palette isNil
				ifFalse: [ oldpal := can win32Palette: self palette win32Handle ].

			Session debugInvalidation
				ifTrue: [	can withPainter: (Painter new paint: Paint red)
									do: [ can displayFilledRectangle: ps rcPaint asRectangle; flush. ].
								Platform errorStream show: self class name, ' rendering: '; print: ps rcPaint asRectangle; cr.	].

			result := drawing value: can.
			oldpal notNil
				ifTrue: [ 	Palette debugging
									ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
								can win32Palette: oldpal ]. 
			can release. 

			self endPaint: self win32Handle paintStructure: ps.
			ps free.
			result	]! !

"June 5, 2007 -> 22:6:2"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
wndProc ^<APICallback>

	^self session wndProc! !

"June 5, 2007 -> 22:6:3"!

! (Delta mirrorFor: #Window) methodsFor: 'private-testing' !
paintPending ^<Boolean>

	^paintPending! !

"June 5, 2007 -> 22:6:5"!

! (Delta mirrorFor: #Window) methodsFor: 'private-testing' !
paintPending: b <Boolean>

	paintPending := b! !

"June 5, 2007 -> 22:6:6"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
changing

	self session changing: self.
	self session recordPrefsFor: self.
	natural := min := max := nil.! !

"June 5, 2007 -> 22:6:8"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
checkLayout: oldPrefs <SeqCltn[Region]>

	| oldNat <Rect> alloc <Rect> nat <Rect> ext <Point> |
	oldNat := (oldPrefs at: 2) enclosingRect.
	self computePreferences.
	nat := self natural enclosingRect.
	alloc := self allocation enclosingRect.

	"We have to do the relayout eagerly, even before the size message
			comes back, because the caller assumes that layout is then done."

	((alloc contains: self min enclosingRect)
			and: [ self max enclosedRect contains: alloc ]
	)	ifFalse: [	"We definitely have to change our size"
							self relayoutIfNeededForExtent: nat extent.
							self extent: nat extent.
							^self	].

	(self optimizeIncrementalLayout
			or: [ nat = oldNat
			or: [	alloc contains: nat ] ])
		ifTrue: [	self relayoutIfNeededForExtent: self extent.
						^self ].

	ext := (nat width max: alloc width) @ (nat height max: alloc height).
	self relayoutIfNeededForExtent: ext.
	self extent: ext.! !

"June 5, 2007 -> 22:6:9"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
checkPaintTime: t <Float>
	"If we have reached our refresh time, paint"
	
"%todo: figure out how to remove the following %hack
		this should not be sent after the receiver is released)"	
visual isNil ifTrue: [ ^self ].

	(self hasWin32Handle and: [ self paintPending ])
		ifTrue: [ self nextPaintTime <= t
						ifTrue: [ self display ]
						ifFalse: [ self session needPaintAtTime: self nextPaintTime ]	 ]! !

"June 5, 2007 -> 22:6:11"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
oldcheckLayout: oldPrefs <SeqCltn[Region]>

	| oldNat <Rect> alloc <Rect> nat <Rect> |
	oldNat := (oldPrefs at: 2) enclosingRect.
	self computePreferences.
	nat := self natural enclosingRect.
	alloc := self allocation enclosingRect.

	"We have to do the relayout eagerly, even before the size message
			comes back, because the caller assumes that layout is then done."
	self relayoutIfNeeded.

	((alloc contains: self min enclosingRect)
			and: [ (self max enclosedRect contains: alloc)
			and: [ self optimizeIncrementalLayout
							or: [ nat = oldNat
							or: [	alloc contains: nat ] ] ] ]
	)	ifFalse: [	"We definitely have to change our size"
						self setExtent: nat extent.	].
! !

"June 5, 2007 -> 22:6:12"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
prefs ^<SeqCltn[Region]>

	^Array[Region] with: self min with: self natural with: self max! !

"June 5, 2007 -> 22:6:13"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
prefsStatus ^<Int>

	^Visual valid! !

"June 5, 2007 -> 22:6:14"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
prerecordPrefsIfNeeded

	"nothing to do"! !

"June 5, 2007 -> 22:6:15"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
processDeferredPainting

	self deferredPaintRegion notNil
		ifTrue: [	self invalidate: self deferredPaintRegion.
						self deferredPaintRegion: nil.		]! !

"June 5, 2007 -> 22:6:17"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
removeParentsFrom: leaves <Set[RelayoutTarget]>
alreadyChecked: checked <Set[RelayoutTarget]>

	"nothing to do"! !

"June 5, 2007 -> 22:6:18"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
hInstance ^<ExternalProxy>

	^self medium hInstance! !

"June 5, 2007 -> 22:6:19"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
message: msg <MSG>
	"This is invoked in the UI thread when a new message arrives in the queue."

	"Forward messages to the session, which will execute them in its thread"
	self session message: msg! !

"June 5, 2007 -> 22:6:21"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
message: msgCode <ExternalData>
for: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	"This is where all the win32 messages get converted to our semantics.  This
	  method executes in the window's session's thread for queued messages, and
	  either the session or UI thread for unqueued messages."

	"%note/%todo: each message below must call beforeQueuedMessage before processing
	     the message IFF the message is a queued (in session thread) message"

	^(self windowsMessageHandlers at: msgCode
		ifAbsent: [ ^self handleMiscMsg: msgCode hwnd: hwnd wParam: wParam lParam: lParam ]
     )	value: self
		value: msgCode
		value: hwnd
		value: wParam
		value: lParam! !

"June 5, 2007 -> 22:6:22"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
recursiveRealizePaletteForeground: fore <Boolean> updateColors: update <Boolean>

	self palette isNil
		ifFalse: [	self withDCDo:
							[ :hdc <HDC> |
								| oldpal <Win32Handle> |
								oldpal := Palette select: self palette win32Handle into: hdc background: fore not.
								self palette unrealize.
								self palette realizeFor: hdc.
								Palette debugging
									ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
								Palette select: oldpal win32Handle into: hdc background: fore not.
							 ].
						self invalidate.
						].
	self controls do:
		[ :c <Win32Control> |
			c recursiveRealizePaletteForeground: fore updateColors: update ].! !

"June 5, 2007 -> 22:6:23"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
registerControl: c <Win32Control>

	self controls include: c! !

"June 5, 2007 -> 22:6:24"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
releaseCapture

	{{<user ExternalProxy ReleaseCapture> noArgs}}! !

"June 5, 2007 -> 22:6:26"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
sendMessage: msg <ExternalData>
wparam: wp <ExternalData>
lparam: lp <ExternalData>
^<ExternalData>

	^{{<user ExternalProxy SendMessageA>
			handle: self win32Handle
			msg: msg
			wparam: wp
			lparam: lp}}! !

"June 5, 2007 -> 22:6:27"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
setCapture

	{{<user ExternalProxy SetCapture> hwnd: self win32Handle}}.
! !

"June 5, 2007 -> 22:6:28"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
setFocus

	 self win32Handle @= {{<user ExternalProxy GetFocus> call}}
		ifFalse: [  {{<user ExternalProxy SetFocus> hwnd: self win32Handle}} ]! !

"June 5, 2007 -> 22:6:29"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
unregisterControl: c <Win32Control>

	self controls removeEvery: c! !

"June 5, 2007 -> 22:6:31"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
win32Handle ^<HWND>

	win32Handle isNil
		ifTrue: [	self session creatingWindow: self do:
							[	self buildWin32Handle; recordExtent. ].  ].
	^win32Handle! !

"June 5, 2007 -> 22:6:32"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
characterMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self beforeQueuedMessage.
	^self session handleIfFocusMsg: msg for: self wParam: wParam lParam: lParam
! !

"June 5, 2007 -> 22:6:33"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
closeMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self requestClose.
	^0! !

"June 5, 2007 -> 22:6:34"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
commandMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	
	self beforeQueuedMessage.

	^lParam @~= Win32 NULL
		ifTrue: [	"Then this is a control window notification, which should be forwarded back to the
						  smalltalk control object"
						Win32Control notificationMsg: wParam asExternalProxy high for: (Win32Control controlIdFor: lParam).
						0 ]
		ifFalse: [ wParam asExternalProxy high = 0
							ifTrue: [	self menuCommandForItem: wParam low.
											0	]
							ifFalse: [ self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam ]	]! !

"June 5, 2007 -> 22:6:36"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
handleMiscMsg: msgCode <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	"This performs the default window system handling for a message"
	
	^(self shouldCallDefaultHandlerAsynchronouslyFor: msgCode)
		ifTrue: [	"Some messages should be handled asyncronously, so that for
							example, moving a window allows other sessions to refresh"
						self callAsyncDefWndProcFor: hwnd
							msgCode: msgCode
							wParam:  wParam
							lParam: lParam ]
		ifFalse: [	self callDefWndProcFor: hwnd
								msgCode: msgCode
								wParam:  wParam
								lParam: lParam	]! !

"June 5, 2007 -> 22:6:37"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
handleMouseEvent: type <Symbol>
at: loc <Point>
msg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	| ev <UIEvent> |
	self beforeQueuedMessage.

	"%todo: remove the dispatch block for all events; isn't needed anymore"
	ev := UIEvent
			forMsg: self session currentMsg
			dispatch:
				[ :e <UIEvent> :h <UIEventHandler> |
					h mouseEvent: type at: loc event: e ].
	self mouseEvent: type at: loc event: ev.

	"Mouse events are always passed through to the default wnd proc since their may be window system specific things
	  like bringing the window to the foreground that always have to happen. (I used to pass it through only when it
	  was a left button down msg, but this is cleaner)"
	^self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam! !

"June 5, 2007 -> 22:6:38"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
initMenuPopupMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self beforeQueuedMessage.
	self hasMenu 
		ifTrue: [ self activeMenu updateMenuWithHandle: wParam ].
	^0! !

"June 5, 2007 -> 22:6:40"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
keyDownMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self beforeQueuedMessage.
	^self session handleIfFocusMsg: msg for: self wParam: wParam lParam: lParam
! !

"June 5, 2007 -> 22:6:41"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
keyUpMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self beforeQueuedMessage.
	^self session handleIfFocusMsg: msg for: self wParam: wParam lParam: lParam
! !

"June 5, 2007 -> 22:6:42"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
layoutMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	| ext <Point> |
	ext := lParam low @ lParam high.
	(self visual layoutStatus < Visual valid
			or: [ self visual allocation enclosingRect extent ~= ext ])
		ifTrue: [ self layout: ext ].
	^0! !

"June 5, 2007 -> 22:6:44"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
paintMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self display.
	^0! !

"June 5, 2007 -> 22:6:45"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
setCursorMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^(cursor notNil
			and: [	| hitcode <Int> |
						hitcode := lParam asExternalProxy low.
						hitcode = 1 or: [ hitcode = 65534 ] "client area or disabled"  ])
		ifTrue: [ 	self setCursor.
						1 ]
		ifFalse: [ self callDefWndProcFor: hwnd
								msgCode: msg
								wParam: wParam
								lParam: lParam ]
! !

"June 5, 2007 -> 22:6:46"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
buttonColorMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^Win32Control buttonColorMsg: wParam asExternalProxy for: (Win32Control controlIdFor: lParam)! !

"June 5, 2007 -> 22:6:47"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
captureChangedMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self session lostCapture.
	
	^self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam! !

"June 5, 2007 -> 22:6:49"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
destroyMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^0! !

"June 5, 2007 -> 22:6:50"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
drawItemMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^Win32Control drawItemMsg: (DRAWITEMSTRUCT forProxy: lParam) for: wParam asSmallInteger! !

"June 5, 2007 -> 22:6:51"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
eraseBackgroundMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	| can <Canvas> |

	self haveErased
		ifTrue: [ ^1 ].
	self haveErased: true.

	"Don't paint background when a paint is pending to reduce flickering"
	self paintPending
		ifTrue: [ ^0 ].

	"Use a critical region because the window's thread might be drawing"
	self critical:
		[	can := HDC forProxy: wParam asExternalProxy.
			can initialize.
			self paintBackgroundOn: can. 	].
	^1! !

"June 5, 2007 -> 22:6:53"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
getMinMaxInfoMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	| info <MINMAXINFO> adjmin <Point> adjmax <Point> |
	info := MINMAXINFO forProxy: lParam asExternalProxy.
	adjmin := (self fitToMedium: self min extent) max: info ptMinTrackSize asPoint.
	adjmax := (self fitToMedium: self max extent) min: info ptMaxSize asPoint.
	info ptMaxSize x: adjmax x; y: adjmax y.
	info ptMaxTrackSize x: adjmax x; y: adjmax y.
	info ptMinTrackSize x: adjmin x; y: adjmin y.
	^0! !

"June 5, 2007 -> 22:6:54"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
killFocusMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	"This window is losing the input focus, which means that some non-native visual
	  within us probably has the focus, so we have to discard the focus."

	(self session hasInputFocus and: [ self session inputFocus nativeWindow = self ])
		ifTrue: [ self session noInputFocus ].

	^self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam! !

"June 5, 2007 -> 22:6:55"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
measureItemMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	| data <MEASUREITEMSTRUCT> |
	data := MEASUREITEMSTRUCT forProxy: lParam.
	^data CtlType @= Win32 ODT_MENU
		ifFalse: [ Win32Control measureItemMsg: data for: data CtlID asSmallInteger ]
		ifTrue: [ self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam ]! !

"June 5, 2007 -> 22:6:56"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
ncDestroyMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self release.
	^0! !

"June 5, 2007 -> 22:6:58"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
paletteChangedMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	wParam @= self win32Handle
		ifFalse: [ self recursiveRealizePaletteForeground: false updateColors: true.
						self palette isNil
							ifTrue: [ ^self callDefWndProcFor: hwnd
											msgCode: msg
											wParam: wParam
											lParam: lParam	].
					].
	^0! !

"June 5, 2007 -> 22:6:59"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
queryPaletteMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self recursiveRealizePaletteForeground: true updateColors: false.
	self palette isNil
		ifTrue: [ ^self callDefWndProcFor: hwnd
						msgCode: msg
						wParam: wParam
						lParam: lParam	].
	^0! !

"June 5, 2007 -> 22:7:0"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
setFocusMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	"This window is getting the input focus, which means that some non-native visual
	  within us will have to be chosen if possible."

	self beforeSetFocus.

	^self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam! !

"June 5, 2007 -> 22:7:2"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
sizeMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	"%todo: do we need to check the value of wParam first?"
	self critical:
		[ wParam @= Win32 SIZE_MINIMIZED
			ifFalse: [	| m <MSG> |
								self invalidate.
								m := MSG new allocate.
								[ m	hwnd: self win32Handle;
										message: Window LAYOUT;
										wParam: 0;
										lParam: lParam.
									self recordExtent.
									self session message: m.
								] ensure: [ m free ]
							]
		 ].
	^0! !

"June 5, 2007 -> 22:7:3"!

! (Delta mirrorFor: #Window) methodsFor: 'testing' !
isActive ^<Boolean>

	^self session hasActiveWindow and: [ self session activeWindow = self ]! !

"June 5, 2007 -> 22:7:46"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 22:7:48"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 22:7:48"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 22:7:48"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 22:7:48"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 22:7:48"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 22:7:48"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 22:7:48"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 22:7:48"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 22:7:48"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 22:7:48"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 22:7:49"!

(Delta mirrorFor: #SystemInitializer)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"June 5, 2007 -> 22:7:51"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
benchmarkDictionary
	| dict |
	dict := Dictionary new.

	"Benchmarks"
	dict at: #richards			put: [ :runner :repeat :inner | runner new runRichardsBenchmarks: 		repeat ].
	dict at: #smopstones	put: [ :runner :repeat :inner | runner new runSmopstoneBenchmarks:	repeat ].
	dict at: #slopstones		put: [ :runner :repeat :inner | runner new runSlopstoneBenchmarks:		repeat ].
	dict at: #stanford			put: [ :runner :repeat :inner | runner new runStanfordBenchmarks:		repeat ].
	dict at: #deltablue			put: [ :runner :repeat :inner | runner new runDeltaBlue:							repeat ].
	dict at: #benchmarks	put: [ :runner :repeat :inner | 
		runner new runStanfordBenchmarks:			repeat.
		runner new runRichardsBenchmarks:		repeat.
		runner new runDeltaBlue:								repeat.
		runner new runSlopstoneBenchmarks:		repeat.
		runner new runSmopstoneBenchmarks:	repeat.
	].
	
	dict at: #loop			put: [ :runner :repeat :inner | runner new runStanfordLoopBenchmarks: repeat ].
	
	"Individual Stanford Benchmarks"
	dict at: #bubblesort		put: [ :runner :repeat :inner | runner new runIndividualStanford: BubbleSortBenchmark repeat: repeat inner: inner].
	dict at: #bubblesort2	put: [ :runner :repeat :inner | runner new runIndividualStanford: BubbleSort2Benchmark repeat: repeat inner: inner].
	dict at: #intmm				put: [ :runner :repeat :inner | runner new runIndividualStanford: IntMMBenchmark repeat: repeat inner: inner].
	dict at: #intmm2			put: [ :runner :repeat :inner | runner new runIndividualStanford: IntMM2Benchmark repeat: repeat inner: inner].
	dict at: #mm					put: [ :runner :repeat :inner | runner new runIndividualStanford: MMBenchmark repeat: repeat inner: inner].
	dict at: #mm2				put: [ :runner :repeat :inner | runner new runIndividualStanford: MM2Benchmark repeat: repeat inner: inner].
	dict at: #perm				put: [ :runner :repeat :inner | runner new runIndividualStanford: PermBenchmark repeat: repeat inner: inner].
	dict at: #perm2				put: [ :runner :repeat :inner | runner new runIndividualStanford: Perm2Benchmark repeat: repeat inner: inner].
	dict at: #queens			put: [ :runner :repeat :inner | runner new runIndividualStanford: QueensBenchmark repeat: repeat inner: inner].
	dict at: #queens2			put: [ :runner :repeat :inner | runner new runIndividualStanford: Queens2Benchmark repeat: repeat inner: inner].
	dict at: #quicksort		put: [ :runner :repeat :inner | runner new runIndividualStanford: QuicksortBenchmark repeat: repeat inner: inner].
	dict at: #quicksort2		put: [ :runner :repeat :inner | runner new runIndividualStanford: Quicksort2Benchmark repeat: repeat inner: inner].
	dict at: #towers			put: [ :runner :repeat :inner | runner new runIndividualStanford: TowersBenchmark repeat: repeat inner: inner].
	dict at: #towers2			put: [ :runner :repeat :inner | runner new runIndividualStanford: Towers2Benchmark repeat: repeat inner: inner].
	dict at: #treesort			put: [ :runner :repeat :inner | runner new runIndividualStanford: TreeSortBenchmark repeat: repeat inner: inner].
	dict at: #treesort2		put: [ :runner :repeat :inner | runner new runIndividualStanford: TreeSort2Benchmark repeat: repeat inner: inner].
	dict at: #puzzle				put: [ :runner :repeat :inner | runner new runIndividualStanford: PuzzleBenchmark repeat: repeat inner: inner].
	dict at: #sieve				put: [ :runner :repeat :inner | runner new runIndividualStanford: SieveBenchmark repeat: repeat inner: inner].
	dict at: #sumto				put: [ :runner :repeat :inner | runner new runIndividualStanford: SumToBenchmark repeat: repeat inner: inner].
	dict at: #recurse			put: [ :runner :repeat :inner | runner new runIndividualStanford: RecurseBenchmark repeat: repeat inner: inner].
	dict at: #atallput			put: [ :runner :repeat :inner | runner new runIndividualStanford: AtAllPutBenchmark repeat: repeat inner: inner].
	dict at: #incrementall	put: [ :runner :repeat :inner | runner new runIndividualStanford: IncrementAllBenchmark repeat: repeat inner: inner].
	dict at: #nestedloop		put: [ :runner :repeat :inner | runner new runIndividualStanford: NestedLoopBenchmark repeat: repeat inner: inner].
	dict at: #tak					put: [ :runner :repeat :inner | runner new runIndividualStanford: TakBenchmark repeat: repeat inner: inner].
	dict at: #takl					put: [ :runner :repeat :inner | runner new runIndividualStanford: TaklBenchmark repeat: repeat inner: inner].
	dict at: #ordcol				put: [ :runner :repeat :inner | runner new runIndividualStanford: OrderedCollectionBenchmark repeat: repeat inner: inner].
	dict at: #dictionary		put: [ :runner :repeat :inner | runner new runIndividualStanford: DictionaryBenchmark repeat: repeat inner: inner].
	dict at: #dictatput		put: [ :runner :repeat :inner | runner new runIndividualStanford: DictionaryAtPutBenchmark repeat: repeat inner: inner].
	dict at: #livermore		put: [ :runner :repeat :inner | runner new runIndividualStanford: LivermoreBenchmark repeat: repeat inner: inner].

	"Individual Slopstone Benchmarks"
	dict at: #addint				put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 1 repeat: repeat inner: inner].
	dict at: #addfloat			put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 2 repeat: repeat inner: inner].
	dict at: #stringaccess	put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 3 repeat: repeat inner: inner].
	dict at: #createobject	put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 4 repeat: repeat inner: inner].
	dict at: #perform			put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 5 repeat: repeat inner: inner].
	dict at: #evaluate			put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 6 repeat: repeat inner: inner].
	
	"Individual Smopstone Benchmarks"
	dict at: #fractonacci	put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 1 repeat: repeat inner: inner].
	dict at: #primes   		put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 2 repeat: repeat inner: inner].
	dict at: #streams		put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 3 repeat: repeat inner: inner].
	dict at: #strings			put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 4 repeat: repeat inner: inner].
	dict at: #sets				put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 5 repeat: repeat inner: inner].
	dict at: #sorting 			put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 6 repeat: repeat inner: inner].
	dict at: #sorcerer		put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 7 repeat: repeat inner: inner].

	"Test Suites"
	dict at: #testsuite		put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new testBasicClasses] ].

	"Individual Tests"
	dict at: #string				put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: String title: 'String' ] ].
	dict at: #number			put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: Number title: 'Number' ] ].
	dict at: #sortedcol		put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: SortedCollection title: 'SortedCollection' ] ].
	dict at: #readstream	put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: SeqCltnReadStream title: 'SeqCltnReadStream' ] ].
	dict at: #writestream	put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: SeqCltnReadWriteStream title: 'SeqCltnReadWriteStream' ] ].
	dict at: #bag				put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: Bag title: 'Bag' ] ].
	dict at: #keyedset		put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: KeyedSet title: 'KeyedSet' ] ].
	dict at: #set					put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: Set title: 'Set' ] ].
	dict at: #orderedcol	put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: OrderedCollection title: 'OrderedCollection' ] ].
	dict at: #character		put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: Character title: 'Character' ] ].
	dict at: #readwrite		put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: ExternalReadWriteStream title: 'ExternalReadWriteStream' ] ].

	"Errors"
	dict at: #break				put: [ :runner :repeat :inner | {{primitiveBreak}} ].

	"Bootstrap"
	dict at: #boot				put: [ :runner :repeat :inner | Dumper fileOut ].

	"Test Suite for the VM people"
	dict at: #vmtest				put: [ :runner :repeat :inner | VMSuite run ].
	dict at: #vminterpreted	put: [ :runner :repeat :inner | VMSuite runInterpreted ].
	dict at: #vmcompiled	put: [ :runner :repeat :inner | VMSuite runCompiled ].
	dict at: #vmvanilla			put: [ :runner :repeat :inner | VMSuite runVanilla ].
	dict at: #dump					put: [  :runner :repeat :inner | InliningDatabase dump ].
	dict at: #compileAll		put: [  :runner :repeat :inner | InliningDatabase compileAll ].
	dict at: #gc						put: [  :runner :repeat :inner | VM collectGarbage ].
	dict at: #norecomp		put: [  :runner :repeat :inner | VM booleanAt: #UseRecompilation put: false ].

	"Misc."
	dict at: #zone					put: [ :runner :repeat :inner | {{primitivePrintZone}} ].
	dict at: #decode				put: [ :runner :repeat :inner | {{primitiveDecodeAllMethods}} ].
	dict at: #mandelbrot		put: [ :runner :repeat :inner | repeat timesRepeat: [ Mandelbrot new computeImageOnly ] ].
	dict at: #mandelprof		put: [ :runner :repeat :inner | Profiler do: [ Mandelbrot new computeImageOnly ] ].
	dict at: #mandeltest		put: [ :runner :repeat :inner | Mandelbrot new computeImageOnly ].
	dict at: #typecheck		put: [ :runner :repeat :inner | runner new runTypecheckerBenchmarks: repeat ].
	dict at: #genprims			put: [ :runner :repeat :inner | DeltaPrimitiveGenerator doit].

	^dict! !

"June 5, 2007 -> 22:7:53"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
findRunner: test ifAbsent: blk
	test = 'timer'
		ifTrue: [^BenchmarkRunner].
	test = 'nmethod'
		ifTrue: [^BenchmarkNMethodInvocationRunner].
	test = 'method'
		ifTrue: [^BenchmarkMethodInvocationRunner].
	test = 'prims'
		ifTrue: [^BenchmarkPrimitiveRunner].
	test = 'lookup'
		ifTrue: [^BenchmarkLookupCacheRunner].
	test = 'blocks'
		ifTrue: [^BenchmarkBlockRunner].
	blk value.! !

"June 5, 2007 -> 22:7:54"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
lower: str
	| result |
	result := String new: str size.
	1 to: str size do: [ :index |
		result at: index put: (str at: index) asLowercase
	].
	^result! !

"June 5, 2007 -> 22:7:55"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
parseInteger: str ifFail: blk
	| result |
	result := 0.
	str do: [ :c | | val |
		val := c asciiValue.
		(val >= $0 asciiValue and: [ val <= $9 asciiValue ])  ifTrue: [
			result := (result * 10) + ( val - $0 asciiValue)
		] ifFalse: [
			^blk value
		]
	].
	^result! !

"June 5, 2007 -> 22:7:56"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
processCommandLineArguments ^<Boolean>
	"process command line args, and return boolean indicating whether the 
		default program should be run (which is normally the GUI)"

	| args <ReadStream[Str]>  runDefault <Boolean> |
	args := Platform commandLineTokens.
	args next.  "Skip command"
	runDefault := true.
	
	[ args atEnd ] whileFalse: [  | arg <Str> |
		arg := args next.
		
		arg = '-benchmark'
			ifTrue: [	self runBenchmarks: args.
						runDefault := false ].
		arg = '-script'
			ifTrue: [	args atEnd
							ifTrue: [ Transcript show: 'Command line argument error: -script option must be followed by a filename';cr. ]
							ifFalse: [ self runScript: args next ].
						runDefault := false ].		].
	^runDefault
! !

"June 5, 2007 -> 22:7:57"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
runBenchmarks: args <InputStream[Str]>

	| dict runner repeat inner print |
	dict := self benchmarkDictionary.
	runner	:= BenchmarkRunner.
	repeat	:= 1.
	inner	:= 1.
	print		:= false.

	[ args atEnd ] whileFalse: [	| arg <Str> cmd options |
		arg := args next.
		options	:= false.
		arg = 'profile'	ifTrue: [ runner := BenchMarkProfileRunner.		options := true ].
		arg = 'prims'		ifTrue: [ runner := BenchmarkPrimTraceRunner.	options := true ].
		arg = 'inner'		ifTrue: [ inner := repeat. repeat := 1.						options := true ].
		arg = 'print'		ifTrue: [ print := true.												options := true ].
		options ifFalse: [
			repeat := self parseInteger: arg ifFail: [
				Transcript show: 'Processing '; show: arg; show: ' ('; show: repeat printString; show: ' times)'; cr.
				cmd := dict at: arg ifAbsent: [nil].
				cmd isNil ifTrue:  [ Transcript show: 'Command not found'; cr ]
							   ifFalse: [ cmd value: runner value: repeat value: inner ].
				repeat
			]
		]
	].

	print ifTrue: [
		{{primitivePrintMemory}}.
	]! !

"June 5, 2007 -> 22:7:58"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
runDefaultProgram
	"This starts the 'default' program, which is the code that should run when no
	  command line options specifies something else"
	  
	[ UI start ] fork! !

"June 5, 2007 -> 22:7:59"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
runScript: filename <Str>

	[	| file <FilePath> |
		file := FilePath for: filename.
		file exists
			ifFalse: [	Transcript show: 'Error: script file ''', filename, ''' not found.'; cr.
							^self	].
		file charInputStream fileIn
	] fork! !

"June 5, 2007 -> 22:8:0"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'library class initialization' !
run
	"This is the entry point for normal execution."
	
	| commands <OrdCltn[Str]> |

	self runBaseClassInitializers.
	self runNonCriticalClassInitializers.
	(self processCommandLineArguments)
		ifTrue: [ self runDefaultProgram ].
! !

"June 5, 2007 -> 22:8:1"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'library class initialization' !
runBaseClassInitializers
	"Initialize critical base library classes (run in the process scheduler)"

	Platform initialize.
	Transcript := TempTranscript new.
	SmallInteger initialize.
	Character initialize.
	CallBack initialize.
	IdleProcess initialize.
	InliningDatabase initialize.
! !

"June 5, 2007 -> 22:8:2"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'library class initialization' !
runNonCriticalClassInitializers
	"This is the root class initializer that is called when the system starts up.
		Any class initializers that must be called should be called from
		this method."

	Session initialize.

	Rectangle initialize.
	Paint initialize.
	Painter initialize.
	HPEN initialize.
	GeometricHPEN initialize.
	HBRUSH initialize.
	InfiniteRegion initialize.

	Smalltalk initialize.

	CodeEditor initialize.
	Workspace initialize.

	HTMLElement initialize.
	HTMLParser initialize.! !

"June 5, 2007 -> 22:9:22"!

"System saved" !
"June 6, 2007 -> 1:38:20"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"June 6, 2007 -> 1:38:22"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"June 6, 2007 -> 1:38:22"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"June 6, 2007 -> 1:38:22"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"June 6, 2007 -> 1:38:22"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"June 6, 2007 -> 1:38:22"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"June 6, 2007 -> 1:38:22"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"June 6, 2007 -> 1:38:22"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"June 6, 2007 -> 1:38:22"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"June 6, 2007 -> 1:38:22"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"June 6, 2007 -> 1:38:22"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"June 6, 2007 -> 1:38:23"!

(Delta mirrorFor: #Win32Platform)
comment: 
'The class side holds platform dependent constants and utilities.  Is also used
to get command line args, and other things like that.

Keywords: %machdep  %User

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.4 $
'!


"June 6, 2007 -> 1:38:23"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLInitialize
    DLLDict := Dictionary new.
    {{primitiveDLLSetupLookup: self selector: #DLLLookup:in: ifFail: [:err | self error: err]}}! !

"June 6, 2007 -> 1:38:24"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLLibrary: name
    ^DLLDict at: name ifAbsent: [
        DLLDict at: name put: (self DLLLoad: name)
    ]! !

"June 6, 2007 -> 1:38:25"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLLoad: name
    | r n |
    r := ExternalProxy new.
    n := (self DLLMapName: name) asSymbol.
    ^{{primitiveDLLLoad: n result: r ifFail: [ :err | self error: err]}}! !

"June 6, 2007 -> 1:38:26"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLLookup: name <Str> in: library <Str>
    "Convert library into proxy"
    | p r |
    p := self DLLLibrary: library.
    r := ExternalProxy new.
    {{primitiveDLLLookup: name asSymbol in: p result: r ifFail: [:err | self error: err]}}.
    ^r! !

"June 6, 2007 -> 1:38:27"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLMapName: name <Str> ^<Str>
    name = 'user'       ifTrue: [^'USER32.DLL'].
    name = 'gdi'            ifTrue: [^'GDI32.DLL'].
    name = 'kernel'     ifTrue: [^'KERNEL32.DLL'].
    name = 'comdlg'     ifTrue: [^'COMDLG32.DLL'].
    self error: 'Mapping ', name, ' not found'! !

"June 6, 2007 -> 1:38:28"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'clipboard access' !
clipboardText: str <Str>

    self openClipboard.
    [   | glob <HGLOBAL> strm <ReadWriteStream[Character]> xstr <Str> |
        self emptyClipboard.

        "transform string into a form with lfs inserted"
        strm := (String new: str size) readWriteStream.
        str do:
            [ :c <Character> |
                strm put: c.
                c = Character cr
                    ifTrue: [ strm put: Character lf ].
            ].
        xstr := String withAll: strm contentsWritten.

        glob := HGLOBAL new
                        allocate: xstr size + 1
                        attributes: (Win32 GMEM_MOVEABLE
                                            externalBitOr: Win32 GMEM_DDESHARE).
        glob withPointer: CString new
                do: [ :cs <CString> |
                            cs value: xstr   ].

        {{<user ExternalProxy SetClipboardData>
                format: Win32 CF_TEXT
                data: glob
        }} isNull
            ifTrue: [ Win32 handleError ].
    ] ensure:
        [ self closeClipboard ]! !

"June 6, 2007 -> 1:38:29"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'clipboard access' !
clipboardTextIfAbsent: blk <[^X def]> ^<Str | X>

    self openClipboard.
    [   | glob <HGLOBAL> strm <CharWriteStream> |

        {{<user ExternalProxy IsClipboardFormatAvailable> format: Win32 CF_TEXT}} asBoolean
            ifFalse: [ ^blk value ].
        glob := {{<user HGLOBAL GetClipboardData> format: Win32 CF_TEXT}}.
        glob isNull
            ifTrue: [ Win32 handleError ].
        strm := (String new: 100) writeStream.
        glob withPointer: CString new
                do: [ :cs <CString> |
                            cs asString do:
                                [ :c <Character> |
                                    c = Character lf
                                        ifFalse: [ strm put: c ]
                                ].
                            ^strm contentsWritten
                      ].
    ] ensure:
        [ self closeClipboard ]! !

"June 6, 2007 -> 1:38:30"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'command line' !
commandLine ^<Str>
    | p size result |
    p := {{<kernel ExternalProxy GetCommandLineA>getCommandLine}}.
    size := 0.
    [(p byteAt: size) == 0] whileFalse: [ size := size + 1 ].
    result := String new: size.
    1 to: size do: [:index |
       result at: index put: (Character value: (p byteAt: index - 1))
    ].
    ^result! !

"June 6, 2007 -> 1:38:31"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'command line' !
commandLineTokens ^<InputStream[Str]>
    "a stream of the input line tokens.  Tokens are sequences separated by whitespace; whitespace can be 
        included in a token by double quoting the arg.  (quotes can be imbedded by doubling, as with Smalltalk strings;
        the returned token has delimiting quotes removed and internal quotes undoubled. "

    | cstrm <CharInputStream> |
    cstrm := self commandLine readStream.
    self skipSpacesIn: cstrm.
    ^CustomInputStream[Str] new
            nextBlock: [    self parseArgFrom: cstrm ];
            atEndBlock: [ cstrm atEnd ].! !

"June 6, 2007 -> 1:38:32"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'constants' !
multipleMatchWildcardCharacter ^<Character>

    ^$*! !

"June 6, 2007 -> 1:38:33"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'constants' !
singleMatchWildcardCharacter ^<Character>

    ^$?! !

"June 6, 2007 -> 1:38:34"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'constants' !
wordSize ^<Int>
    ^4! !

"June 6, 2007 -> 1:38:35"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'environment' !
environmentVariableAt: key <Str> ifAbsent: blk <[^X def]> ^ <Str | X>

    | cKey <CString> cValue <CString> size <Int> cSize <ExternalProxy> result <Str> done <Boolean> found <Boolean> |
    size := 1024.
    cKey := CString for: key.
    done := false.
    [ done ] whileFalse: [
        cValue := CString for: (String new: size).
        cSize := {{<kernel ExternalProxy GetEnvironmentVariableA> key: cKey buffer: cValue bufSize: size}}.
        cSize asSmallInteger > size
            ifTrue: [   cValue free.                                                    "Buffer size too small for value of variable"
                            size := cSize asSmallInteger ]
            ifFalse: [  done := true.                                                   "Buffer size ok, check if variable was found"
                            (found := cSize asSmallInteger ~= 0)
                                ifTrue: [ result := cValue asString ] ] ].
    cKey free. 
    cValue free.
    ^found
        ifTrue: [ result ]
        ifFalse: blk ! !

"June 6, 2007 -> 1:38:36"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'initialization' !
initialize

    self DLLInitialize! !

"June 6, 2007 -> 1:38:37"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'os streams' !
errorStream ^<CharOutputStream>

    ErrorStream isNil
        ifTrue: [   ErrorStream := TempTranscript new ].
    ^ErrorStream! !

"June 6, 2007 -> 1:38:38"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'platform classes' !
pathClass ^<FilePath class>

    ^Win32FilePath! !

"June 6, 2007 -> 1:38:38"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'platform classes' !
patternClass ^<FilePattern class>

    ^Win32FilePattern! !

"June 6, 2007 -> 1:38:40"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'private' !
parseArgFrom: strm <CharInputStream>  ^<Str>
    "Parse an argument token from the strm.  Leading whitespace is assumed to have been removed already.
      Any whitespace following the token is consumed."

    | arg <Str> |
    (strm peekFor: $")
        ifTrue: [       | c <Character> buf <CharWriteStream> |
                        buf := String new writeStream.
                        [   c := strm next.
                            c ~= $" or: [ (strm peekIfAbsent: [ self skipSpacesIn: strm.  ^buf contentsWritten ]) = $" ]
                        ] whileTrue: 
                            [   c = $" ifTrue: [ strm next ].
                                buf put: c ].
                        arg := buf contentsWritten  ]
        ifFalse: [  arg := strm upTo: Character space ].
    self skipSpacesIn: strm.
    ^arg! !

"June 6, 2007 -> 1:38:41"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'private' !
skipSpacesIn: strm <CharInputStream>

    [ strm atEnd not and: [ strm peekFor: Character space] ] whileTrue.
! !

"June 6, 2007 -> 1:38:42"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'private-clipboard access' !
closeClipboard

    {{<user ExternalProxy CloseClipboard> call}}! !

"June 6, 2007 -> 1:38:42"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'private-clipboard access' !
emptyClipboard

    {{<user ExternalProxy EmptyClipboard> call}} asBoolean
        ifFalse: [ Win32 handleError ].
! !

"June 6, 2007 -> 1:38:43"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'private-clipboard access' !
openClipboard

    {{<user ExternalProxy OpenClipboard> hnd: Win32 NULL}} asBoolean
        ifFalse: [ Win32 handleError ].
! !

"June 6, 2007 -> 1:38:44"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'testing' !
usesCrLfConvention ^<Boolean>

    ^true! !

"June 6, 2007 -> 1:39:6"!

Delta define: #Launcher as: (
(Class subclassOf: 'ClassCritical |> Application' instanceVariables: 'menuBar <Menu>
sourceConsistencyHasBeenChecked <Boolean>
') classVariables: 'MenuRegistry <OrdCltn[LookupKey[Object,Menu]]>
Launchers <IdentitySet[Launcher]>
	"All unclosed instances of launcher, so that we
		can notify them when their menus change"') !


"June 6, 2007 -> 1:39:8"!

Delta define: #Launcher as: (
(Class subclassOf: 'ClassCritical |> Application' instanceVariables: 'menuBar <Menu>
sourceConsistencyHasBeenChecked <Boolean>
') classVariables: 'MenuRegistry <OrdCltn[LookupKey[Object,Menu]]>
Launchers <IdentitySet[Launcher]>
	"All unclosed instances of launcher, so that we
		can notify them when their menus change"') !


"June 6, 2007 -> 1:39:8"!

Delta define: #Launcher as: (
(Class subclassOf: 'ClassCritical |> Application' instanceVariables: 'menuBar <Menu>
sourceConsistencyHasBeenChecked <Boolean>
') classVariables: 'MenuRegistry <OrdCltn[LookupKey[Object,Menu]]>
Launchers <IdentitySet[Launcher]>
	"All unclosed instances of launcher, so that we
		can notify them when their menus change"') !


"June 6, 2007 -> 1:39:8"!

Delta define: #Launcher as: (
(Class subclassOf: 'ClassCritical |> Application' instanceVariables: 'menuBar <Menu>
sourceConsistencyHasBeenChecked <Boolean>
') classVariables: 'MenuRegistry <OrdCltn[LookupKey[Object,Menu]]>
Launchers <IdentitySet[Launcher]>
	"All unclosed instances of launcher, so that we
		can notify them when their menus change"') !


"June 6, 2007 -> 1:39:9"!

Delta define: #Launcher as: (
(Class subclassOf: 'ClassCritical |> Application' instanceVariables: 'menuBar <Menu>
sourceConsistencyHasBeenChecked <Boolean>
') classVariables: 'MenuRegistry <OrdCltn[LookupKey[Object,Menu]]>
Launchers <IdentitySet[Launcher]>
	"All unclosed instances of launcher, so that we
		can notify them when their menus change"') !


"June 6, 2007 -> 1:39:9"!

Delta define: #Launcher as: (
(Class subclassOf: 'ClassCritical |> Application' instanceVariables: 'menuBar <Menu>
sourceConsistencyHasBeenChecked <Boolean>
') classVariables: 'MenuRegistry <OrdCltn[LookupKey[Object,Menu]]>
Launchers <IdentitySet[Launcher]>
	"All unclosed instances of launcher, so that we
		can notify them when their menus change"') !


"June 6, 2007 -> 1:39:9"!

Delta define: #Launcher as: (
(Class subclassOf: 'ClassCritical |> Application' instanceVariables: 'menuBar <Menu>
sourceConsistencyHasBeenChecked <Boolean>
') classVariables: 'MenuRegistry <OrdCltn[LookupKey[Object,Menu]]>
Launchers <IdentitySet[Launcher]>
	"All unclosed instances of launcher, so that we
		can notify them when their menus change"') !


"June 6, 2007 -> 1:39:9"!

Delta define: #Launcher as: (
(Class subclassOf: 'ClassCritical |> Application' instanceVariables: 'menuBar <Menu>
sourceConsistencyHasBeenChecked <Boolean>
') classVariables: 'MenuRegistry <OrdCltn[LookupKey[Object,Menu]]>
Launchers <IdentitySet[Launcher]>
	"All unclosed instances of launcher, so that we
		can notify them when their menus change"') !


"June 6, 2007 -> 1:39:9"!

Delta define: #Launcher as: (
(Class subclassOf: 'ClassCritical |> Application' instanceVariables: 'menuBar <Menu>
sourceConsistencyHasBeenChecked <Boolean>
') classVariables: 'MenuRegistry <OrdCltn[LookupKey[Object,Menu]]>
Launchers <IdentitySet[Launcher]>
	"All unclosed instances of launcher, so that we
		can notify them when their menus change"') !


"June 6, 2007 -> 1:39:9"!

Delta define: #Launcher as: (
(Class subclassOf: 'ClassCritical |> Application' instanceVariables: 'menuBar <Menu>
sourceConsistencyHasBeenChecked <Boolean>
') classVariables: 'MenuRegistry <OrdCltn[LookupKey[Object,Menu]]>
Launchers <IdentitySet[Launcher]>
	"All unclosed instances of launcher, so that we
		can notify them when their menus change"') !


"June 6, 2007 -> 1:39:9"!

Delta define: #Launcher as: (
(Class subclassOf: 'ClassCritical |> Application' instanceVariables: 'menuBar <Menu>
sourceConsistencyHasBeenChecked <Boolean>
') classVariables: 'MenuRegistry <OrdCltn[LookupKey[Object,Menu]]>
Launchers <IdentitySet[Launcher]>
	"All unclosed instances of launcher, so that we
		can notify them when their menus change"') !


"June 6, 2007 -> 1:39:10"!

(Delta mirrorFor: #Launcher)
comment: 
'The launcher is the entry point application for the programming environment.
(c) 1996-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license. '!


"June 6, 2007 -> 1:39:11"!

! (Delta mirrorFor: #Launcher) classSide methodsFor: 'accessing' !
launchers ^<IdentitySet[Launcher]>
	"call only from a critical region"

	Launchers isNil
		ifTrue: [ Launchers := IdentitySet[Launcher] new ].
	^Launchers! !

"June 6, 2007 -> 1:39:12"!

! (Delta mirrorFor: #Launcher) classSide methodsFor: 'control' !
createUITranscript

	"Make sure the UI isn't already running"
	self assert: [ Transcript class ~~ Workspace ].
	
	Transcript := Workspace new.! !

"June 6, 2007 -> 1:39:14"!

! (Delta mirrorFor: #Launcher) classSide methodsFor: 'control' !
startProgEnv ^<Instance>

	| launcher <Instance> |
	self createUITranscript.
	
	"Register stophandler for process scheduler"
	Processor stopHandler: [ :p <Process> | (StackTraceInspector on: p) launch ].

	launcher := (self new) launch; yourself.

	"Don't launch start page if system is inconsistent so that it won't
		obscure the error messages in the transcript"
	SourceHandler systemIsConsistent
		ifTrue: [ [ launcher browseStartPage ] fork. ]. 

	^launcher
! !

"June 6, 2007 -> 1:39:14"!

! (Delta mirrorFor: #Launcher) classSide methodsFor: 'private' !
menuRegistry ^<OrdCltn[LookupKey[Object,Menu]]>
	"call only from a critical region"

	MenuRegistry isNil
		ifTrue: [ MenuRegistry := OrderedCollection[LookupKey[Object,Menu]] new ].
	^MenuRegistry! !

"June 6, 2007 -> 1:39:16"!

! (Delta mirrorFor: #Launcher) classSide methodsFor: 'private' !
mergedMenu ^<Menu>
	"Call only from critical region"

	| newMenu <Menu> |
	newMenu := Menu new.
	self menuRegistry do:
		[ :entry <LookupKey[Object,Menu]> |
			newMenu merge: entry value copy.	].
	^newMenu! !

"June 6, 2007 -> 1:39:16"!

! (Delta mirrorFor: #Launcher) classSide methodsFor: 'private' !
rebuildMenus
	"rebuild all the menus and notify the launchers.  Must
		be in a critical region on self"

	| newMenu <Menu> |
	newMenu := self mergedMenu.
	self launchers do:
		[ :l <Launcher> |
			l menuBar: newMenu copy	].! !

"June 6, 2007 -> 1:39:17"!

! (Delta mirrorFor: #Launcher) classSide methodsFor: 'private' !
registerLauncher: l <Launcher>

	self critical:
		[ self launchers include: l ]! !

"June 6, 2007 -> 1:39:18"!

! (Delta mirrorFor: #Launcher) classSide methodsFor: 'registering menus' !
registerMenu: m <Menu> for: owner <Object>
	"Merge m into the launcher menu.  It can be unregistered later.
		Any displayed launchers will update their menus dynamically."

	self critical:
		[	self menuRegistry addLast:
						(LookupKey[Object,Menu] key: owner value: m).
			self rebuildMenus	]! !

"June 6, 2007 -> 1:39:19"!

! (Delta mirrorFor: #Launcher) classSide methodsFor: 'registering menus' !
unregisterMenuFor: owner <Object>
	"Unmerge m from the launcher menu. "

	self critical:
		[	self menuRegistry remove: (LookupKey[Object,Menu] key: owner value: nil). "value doesn't matter"
			self rebuildMenus	]! !

"June 6, 2007 -> 1:39:20"!

! (Delta mirrorFor: #Launcher) methodsFor: 'accessing' !
docPath ^<FilePath>

	^FilePath currentDirectory, (FilePath for: 'documentation\index.html')! !

"June 6, 2007 -> 1:39:21"!

! (Delta mirrorFor: #Launcher) methodsFor: 'accessing' !
windowTitle ^ <Str>

	^'Strongtalk Launcher'! !

"June 6, 2007 -> 1:39:22"!

! (Delta mirrorFor: #Launcher) methodsFor: 'accessing' !
workspace ^<Workspace>

	^Workspace coerce: Transcript! !

"June 6, 2007 -> 1:39:23"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
browseStartPage

	self startPagePath exists
		ifFalse: [  self visual promptOk: 'Can''t open ',self startPagePath name
								title: 'Error'
								type: #exclamation
								action: [].
							^self
						].

	(HTMLView new model: (URL forFilePath: self startPagePath)) launch! !

"June 6, 2007 -> 1:39:24"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
findDefinition
	
	self 
		launchSingleLineTextDialogWithPainter: Painter default
		title: 'Open definition'
		caption: 'Matching expression' 
		default: '*'
		action: [ :s <Str> | self launchDefinitionsMatching: s ]
! !

"June 6, 2007 -> 1:39:25"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
findGlobalReferences

	self 
		launchSingleLineTextDialogWithPainter: Painter default
		title: 'Find references'
		caption: 'Name of global' 
		default: ''
		action: [ :s <Str> | self launchReferencesToGlobalName: s asSymbol ]
! !

"June 6, 2007 -> 1:39:26"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
findImplementors

	self 
		launchSingleLineTextDialogWithPainter: Painter default
		title: 'Find implementors'
		caption: 'Matching expression' 
		default: '*'
		action: [ :s <Str> | self launchImplementorsMatching: s ]

! !

"June 6, 2007 -> 1:39:27"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
findSenders

	self 
		launchSingleLineTextDialogWithPainter: Painter default
		title: 'Find senders'
		caption: 'Matching expression' 
		default: '*'
		action: [ :s <Str> | self launchSendersMatching: s ]
! !

"June 6, 2007 -> 1:39:28"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
launchDefinitionsMatching: s <Str>

	"THIS IS JUST A QUICK HACK!!!!!! REMOVE LATER!!!!!!"
	
	| definitions <AddableSequenceableCollection[Symbol]> mirror <Mirror> |
	definitions := OrderedCollection[Symbol] new.
	Smalltalk keysDo: [ :key <Symbol> | 
		(s platformMatch: key)
			ifTrue: [	definitions add: key ]
	].
	definitions isEmpty
		ifTrue: [	| pattern <Str> |
					pattern := s, Platform multipleMatchWildcardCharacter asString.
					Smalltalk keysDo: [ :key <Symbol> | 
						(pattern platformMatch: key)
							ifTrue: [	definitions add: key ]
					]
	].
	definitions := definitions asSortedCollection: [ :a <Symbol> :b <Symbol> | a <= b ].
	definitions isEmpty
		ifTrue: [		(Workspace coerce: Transcript) visual
								promptOk: 'No definitions matching ''', s, ''''
								title: 'Information'
								type: #info
								action: [] ].
	definitions size = 1
		ifTrue: [		mirror := Smalltalk mirrorFor: (definitions at: 1) ifAbsent: [ ^self ].
						(DefOutliner on: mirror) launch ]
		ifFalse: [	self 
								launchListDialogWithPainter: Painter default
								title: 'Definitions matching ', s
								modal: false
								contents: definitions
								multi: true
								action: [ :indices <Cltn[Int]> |
												indices do:
													[ :index <Int> |
														mirror := Smalltalk mirrorFor: (definitions at: index)
																			ifAbsent: [ ^self ].
														(DefOutliner on: mirror) launch 	]	].
							]! !

"June 6, 2007 -> 1:39:29"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
launchDoc

	(HTMLView new model: (URL forFilePath: self docPath)) launch! !

"June 6, 2007 -> 1:39:30"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
launchImplementorsMatching: s <Str>

	| implementors <SeqCltn[Tuple[Mirror, Symbol]]> |
	(implementors := Smalltalk implementorsMatching: s) isEmpty
		ifTrue: [		(Workspace coerce: Transcript) visual
								promptOk: 'No implementors matching ''', s, ''''
								title: 'Information'
								type: #info
								action: [] ]
		ifFalse: [	self 
								launchSelectorListWithPainter: Painter default 
								title: 'Implementors matching ''', s,	 '''' 
								contents: implementors ]
! !

"June 6, 2007 -> 1:39:31"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
launchListDialogWithPainter: p <Painter>
title: t <Str>
contents: strs <SeqCltn[Str]>
multi: b <Boolean>
action: blk <[Cltn[Int]]>

	self	launchListDialogWithPainter: p 
			title: t 
			modal: true
			contents: strs
			multi: b 
			action: blk 
! !

"June 6, 2007 -> 1:39:32"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
launchListDialogWithPainter: p <Painter>
title: t <Str>
modal: modal <Boolean>
contents: strs <SeqCltn[Str]>
multi: b <Boolean>
action: blk <[Cltn[Int]]>

	"THIS IS JUST A QUICK HACK!!!!!! REMOVE LATER!!!!!!"

		| listBox <ListBox> editor <TextView[Str]> glue <Visual> dialog <Window> |
	strs size > 0
		ifFalse: [ ^self ].
	listBox := b
		ifTrue: [	ListBox forMultipleSelections
						simpleMultiple: false ]
		ifFalse: [	ListBox forSingleSelection ].
	listBox
		stringList: strs;
		selections: #(1);
		onDoubleClick: [ :lb <ListBox> | dialog close. blk value: lb selections ].
	dialog := (Workspace coerce: Transcript) visual
		launchCustomDialog: t
		for: (listBox withBorder: (Border standard3DWithColor: Paint gray raised: false))
		showApply: true
		modal: modal
		toValidate: [ :continue <[]> | continue value ]
		action: [ blk value: listBox selections ].
! !

"June 6, 2007 -> 1:39:33"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
launchReferencesToGlobalName: name <Symbol>

	| refs <SeqCltn[Tuple[Mirror, Symbol]]> |
	(refs := Smalltalk referencesToGlobalName: name) isEmpty
		ifTrue: [		(Workspace coerce: Transcript) visual
								promptOk: 'No references to global ''', name, ''''
								title: 'Information'
								type: #info
								action: [] ]
		ifFalse: [	self 
								launchSelectorListWithPainter: Painter default 
								title: 'References to global ''', name,	 '''' 
								contents: refs ]
! !

"June 6, 2007 -> 1:39:35"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
launchSelectorListWithPainter: p <Painter> title: t <Str> contents: list <SeqCltn[Tuple[Mirror, Symbol]]>

	"THIS IS JUST A QUICK HACK!!!!!! REMOVE LATER!!!!!!"

	| listBox <ListBox> action <[ListBox]> win <Window> |
	list size > 0
		ifFalse: [ ^self ].
	list size = 1
		ifTrue: [	| mirror <Mirror> sel <Symbol> |
					mirror := (list at: 1) at1.
					sel := (list at: 1) at2.
					(DefWithMsgOutliner on: mirror instanceSide) launchOpenSide: mirror isMeta selector: sel.
					^self ].
	action := [ 	:lb <ListBox> |
						| index <Int> mirror <Mirror> sel <Symbol> |
						index := lb selections anElement.				"We use single selection"
						mirror := (list at: index) at1.
						sel := (list at: index) at2.
						(DefWithMsgOutliner on: mirror instanceSide) launchOpenSide: mirror isMeta selector: sel.
						].
	listBox := ListBox forSingleSelection.
	listBox
		stringList: (list collect: [ :t <Tuple[Mirror, Symbol]> | t at1 name, '>>', t at2 ]);
		selections: #(1);
		onDoubleClick: [ :lb <ListBox> | action value: lb ].
	win := (Workspace coerce: Transcript) visual
		launchCustomDialog: t
		for: (listBox withBorder: (Border standard3DWithColor: Paint gray raised: false))
		showApply: true
		modal: false
		toValidate: [ :continue <[]> | continue value ]
		action: [ 	action value: listBox ].
! !

"June 6, 2007 -> 1:39:36"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
launchSendersMatching: s <Str>

	| senders <SeqCltn[Tuple[Mirror, Symbol]]> |
	(senders := Smalltalk sendersMatching: s) isEmpty
		ifTrue: [		(Workspace coerce: Transcript) visual
								promptOk: 'No senders matching ''', s, ''''
								title: 'Information'
								type: #info
								action: [] ]
		ifFalse: [	self 
								launchSelectorListWithPainter: Painter default 
								title: 'Senders matching ''', s,	 '''' 
								contents: senders ]
! !

"June 6, 2007 -> 1:39:37"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
launchSingleLineTextDialogWithPainter: p <Painter> title: t <Str> caption: c <Str> default: d <Str> action: blk <[Str]>

	"THIS IS JUST A QUICK HACK!!!!!! REMOVE LATER!!!!!!"

	| caption <Visual> editor <TextView[Str]> glue <Visual> |
	caption := (StringGlyph for: c painter: p) asVisual.
	glue := Glue xRigid: 10.
	editor := CommonProgEnvOutliner new buildSingleLineTextViewWithPainter: p getModel: [ d ] setModelOnSuccess: [ :blk <[]> | blk value ].
	editor desiredColumns: (c size max: d size).
	(Workspace coerce: Transcript) visual
		launchCustomDialog: t
		for: (Row[Visual] holding: (OrderedCollection[Visual] with: caption with: glue with: (CommonProgEnvOutliner new editorBorderFor: editor)))
		showApply: false
		modal: true
		toValidate: [ :continue <[]> | continue value ]
		action: [ blk value: editor model ].
! !

"June 6, 2007 -> 1:39:38"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
openClassHierarchyOutliner

	(ClassHierarchyOutliner for: (ClassMirror on: Object))
		launch.! !

"June 6, 2007 -> 1:39:39"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
openGlobalVariableListOutliner

	GlobalVariableListOutliner forWorld launch! !

"June 6, 2007 -> 1:39:40"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
openMixinListOutliner

	MixinListOutliner forWorld launch! !

"June 6, 2007 -> 1:39:41"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
openProtocolListOutliner

	ProtocolListOutliner forWorld launch! !

"June 6, 2007 -> 1:39:41"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
openTypeAliasListOutliner

	TypeAliasListOutliner forWorld launch! !

"June 6, 2007 -> 1:39:42"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
openUserClassHierarchyOutliner

	(ClassHierarchyOutliner for: (ClassMirror on: Object))
		filterOnUserClasses
		launch.! !

"June 6, 2007 -> 1:39:43"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
showUnsavedChanges
	"Launch a read-only text view on the unsaved changes that have been made
	 during this session"

	SourceHandler unsavedChangesHaveBeenMade
		ifTrue: [	| tv <TextView[InputStream[Character]]> |
					tv := TextView[InputStream[Character]]  forCharStream.
					tv scrollable: true.
					tv model: (SourceHandler currentUnsavedChanges);
						doneBlock:
							[ :saveFlag <Boolean> :action <[]> |
								self visual
									promptOk: 'You can''t change the changes here!!'
									title: 'Error'
									type: #stop
									action: [  ]	 ].
					(tv bareVisualTop: false) launchWithTitle: 'Unsaved Changes'.		]
		ifFalse: [ self visual
						promptOk: 'There are no unsaved changes.'
						title: 'System Change Status'
						type: #info
						action: [ ]		]! !

"June 6, 2007 -> 1:39:44"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
startPagePath ^<FilePath>

	^FilePath currentDirectory, (FilePath for: 'startPage.html')! !

"June 6, 2007 -> 1:39:45"!

! (Delta mirrorFor: #Launcher) methodsFor: 'control' !
closeRequest: toClose <[]>

	SourceHandler unsavedChangesHaveBeenMade
		ifTrue: [ self promptForSave: toClose ]
		ifFalse: [ self promptForQuit: toClose ]! !

"June 6, 2007 -> 1:39:46"!

! (Delta mirrorFor: #Launcher) methodsFor: 'control' !
recompileWorld

	(Workspace coerce: Transcript) visual
		promptOkCancel: 'Recompile all methods in the system?'
		title: 'Please confirm'
		type: #question
		default: 2
		action: [ : b <Boolean> | b ifTrue: [ [ Smalltalk recompileAllMethods ] fork ] ]! !

"June 6, 2007 -> 1:39:47"!

! (Delta mirrorFor: #Launcher) methodsFor: 'control' !
saveSystem

	self visual promptOkCancel: 'Save System?'
				title: 'Save System'
				type: #exclamation
				default: 1
				action: [ :ok <Boolean> |
								ok ifTrue: [	Dumper saveSystem.
														self visual
																promptOk: 'System Saved.'
																title: 'Save System'
																type: #info
																action: [ ]
													]
							]
! !

"June 6, 2007 -> 1:39:49"!

! (Delta mirrorFor: #Launcher) methodsFor: 'control' !
typecheckWorld
 
	| vis <Visual> |
	vis := 	(Workspace coerce: Transcript) visual.
	vis	promptYesNo: 'Do you really want to typecheck all the source code in the system?'
		title: 'Typecheck world'
		type: #question
		default: 2
		action:	[: b <Boolean> |
							b ifTrue: [ Smalltalk typecheckWorld ].
						]
! !

"June 6, 2007 -> 1:39:50"!

! (Delta mirrorFor: #Launcher) methodsFor: 'control-private' !
doClose: toClose <[]>

	toClose value.
	VM quit.! !

"June 6, 2007 -> 1:39:51"!

! (Delta mirrorFor: #Launcher) methodsFor: 'control-private' !
promptForQuit: toClose <[]>

	self visual
				promptYesNo: 'Are you sure you want to quit?'
				title: 'Quit'
				type: #exclamation
				default: 2
				action: [ :ok <Boolean> |
								ok = true
									ifTrue: [ self doClose: toClose ]
								]! !

"June 6, 2007 -> 1:39:52"!

! (Delta mirrorFor: #Launcher) methodsFor: 'control-private' !
promptForSave: toClose <[]>

	self visual
				promptYesNoCancel: 'The system has been changed.  Save system before exiting? (''No'' will erase any changes and add them to the restore log)'
				title: 'Quit'
				type: #exclamation
				default: 3
				action: [ :ok <Boolean | Nil> |
								ok = nil
									ifFalse: [	ok
														ifTrue: [ Dumper saveSystem ]
														ifFalse: [ SourceHandler checkSystemConsistency at1
																		ifTrue: [ SourceHandler restoreBackup ]. ].
													self doClose: toClose		]
								]! !

"June 6, 2007 -> 1:39:53"!

! (Delta mirrorFor: #Launcher) methodsFor: 'filing in/out' !
fileIn

	(Workspace coerce: Transcript) visual
		userPickOpenFileWithAction: [ :file< FilePath> :readOnly <Boolean> | [ Smalltalk fileInFromFile: file ] fork ]
		fileTypes: (Array[Tuple[Str,Str]] with: 'Delta files (*.dlt)' ,, '*.dlt' with: 'All files (*.*)' ,, '*.*')
		defaultFile: nil
		defaultDir: nil
		title: 'Install file-in into image'
		allowReadOnly: false
		mustExist: true
! !

"June 6, 2007 -> 1:39:54"!

! (Delta mirrorFor: #Launcher) methodsFor: 'filing in/out' !
fileOutWorld

	(Workspace coerce: Transcript) visual
		userPickSaveFileWithAction: [ :file< FilePath> | [ Smalltalk fileOutWorldToFile: file ] fork ]
		fileTypes: (Array[Tuple[Str,Str]] with: 'Group files (*.gr)' ,, '*.gr' with: 'All files (*.*)' ,, '*.*')
		defaultFile: (FilePath for: 'world.gr')
		defaultDir: nil
		title: 'File out world and corresponding world group file'
! !

"June 6, 2007 -> 1:39:55"!

! (Delta mirrorFor: #Launcher) methodsFor: 'menus' !
docMenu ^<Menu>

	^Menu new name: '&Documentation';
				add: (MenuAction new
							name: '&Browse';
							action: [ self launchDoc ])! !

"June 6, 2007 -> 1:39:56"!

! (Delta mirrorFor: #Launcher) methodsFor: 'menus' !
fileMenu ^<Menu>

	^Menu new name: '&File';
		add: (MenuAction new
					name: '&Save System';
					action: [ self saveSystem ] );
		addSeparator;
		add: (MenuAction new
					name: 'File &in...';
					action: [ self fileIn ] );
		add: (MenuAction new
					name: 'File &out world...';
					action: [ self fileOutWorld ] );
		add: (MenuAction new
					name: '&Recompile world...';
					action: [ self recompileWorld ] );
		add: (MenuAction new
					name: 'Typecheck world...';
					action: [ self typecheckWorld ] );
		 addSeparator;
		 add: (MenuAction new
		            name:'Meta';
		            action:[Inspector launchOn: self]);
		addSeparator;
		add: (MenuAction new
					name: 'E&xit';
					action: [ self closeRequest: []  ] )! !

"June 6, 2007 -> 1:39:57"!

! (Delta mirrorFor: #Launcher) methodsFor: 'menus' !
hasMenu ^<Boolean>

	^true! !

"June 6, 2007 -> 1:39:58"!

! (Delta mirrorFor: #Launcher) methodsFor: 'menus' !
menuBar ^<Menu>

	menuBar isNil
		ifTrue: [ menuBar := Menu new 
															add: self fileMenu;
															add: self browsingMenu;
															merge: self class mergedMenu;
															add: self docMenu
					 ].
	^menuBar! !

"June 6, 2007 -> 1:39:59"!

! (Delta mirrorFor: #Launcher) methodsFor: 'menus to move elsewhere' !
browsingMenu ^<Menu>

	^Menu new name: '&Browse';
			add: (MenuAction new
					name: 'My &Start Page';
					action: [ self browseStartPage ] );
			addSeparator;
			add: (MenuAction new
					name: '&Definition...';
					action: [ self findDefinition] );
			add: (MenuAction new
					name: '&User Classes (i.e. classes useful to users)';
					action: [ self openUserClassHierarchyOutliner ] );
			add: (MenuAction new
					name: 'All &Classes';
					action: [ self openClassHierarchyOutliner ] );
			add: (MenuAction new
					name: '&Mixins';
					action: [ self openMixinListOutliner ] );
			add: (MenuAction new
					name: '&Protocols';
					action: [ self openProtocolListOutliner ] );
			add: (MenuAction new
					name: '&Type Aliases';
					action: [ self openTypeAliasListOutliner ] );
			add: (MenuAction new
					name: '&Global Variables';
					action: [ self openGlobalVariableListOutliner ] );
			addSeparator;
			add: (MenuAction new
					name: 'Message Implementors ...';
					action: [ self findImplementors ] );
			add: (MenuAction new
					name: 'Message Senders ...';
					action: [ self findSenders ] );
			add: (MenuAction new
					name: 'Global References ...';
					action: [ self findGlobalReferences ] );
			addSeparator;
			add: (MenuAction new
					name: 'Unsaved Changes From This Session';
					active: [ SourceHandler unsavedChangesHaveBeenMade ];
					action: [ self showUnsavedChanges ] );
			add: (MenuAction new
					name: 'Restore Log';
					active: [ (FilePath forElements: #('source' 'strongtalkrestore.log')) exists ];
					action: [ (CodeEditor on: (FilePath forElements: #('source' 'strongtalkrestore.log'))) launch ] );
			add: (MenuAction new
					name: 'Save Log';
					active: [ (FilePath forElements: #('source' 'strongtalkSave.log')) exists ];
					action: [ (CodeEditor on: (FilePath forElements: #('source' 'strongtalkSave.log'))) launch ] )
! !

"June 6, 2007 -> 1:40:0"!

! (Delta mirrorFor: #Launcher) methodsFor: 'notification' !
visualAllocated

	sourceConsistencyHasBeenChecked
		ifFalse: [	sourceConsistencyHasBeenChecked := true.
						"This is a gross %hack to make sure that the launcher
							window has appeared by the time we try to print
							any warning messages.  This is because I'm using
							fancy doitButtons in the warning message, and there
							is some kind of timing problem that hangs the system
							if the message arrives too soon, and I don't have time
							to find it."
						[	(Delay forMilliseconds: 250) wait.
							SourceHandler checkSystemConsistencyAndPrintMessagesIfNeeded.
							] fork.	].
! !

"June 6, 2007 -> 1:40:1"!

! (Delta mirrorFor: #Launcher) methodsFor: 'private' !
buildBareVisualTop: top <Boolean> ^ <Visual>

	^ApplicationInterceptor
			for: self workspace imbeddedVisual with3DBorder
			application: self! !

"June 6, 2007 -> 1:40:2"!

! (Delta mirrorFor: #Launcher) methodsFor: 'private-initialization' !
initialize

	super initialize.
	self actualClass registerLauncher: self.
	sourceConsistencyHasBeenChecked := false.
! !

"June 6, 2007 -> 1:40:3"!

! (Delta mirrorFor: #Launcher) methodsFor: 'restricted' !
menuBar: m <Menu>
	"Set or change the merged application menu.  We don't actually
		store this menu, since we have to change the window's menu
		in place; we simply replace all of the current menus elements
		with m's"

	self inSessionProcessDo: [ self menuBar 
																	removeAll;
																	add: self fileMenu;
																	add: self browsingMenu;
																	merge: m
														].! !

"June 6, 2007 -> 1:40:4"!

! (Delta mirrorFor: #Launcher) methodsFor: 'toolbar' !
hasToolBar ^<Boolean>

	^true! !

"June 6, 2007 -> 1:40:5"!

! (Delta mirrorFor: #Launcher) methodsFor: 'toolbar' !
toolBar ^<ToolBar>

	^ToolBar new
			addButtonWithImageFrom: 'resources/smallHome.bmp'
					action: [ :b <Button> |	self browseStartPage ];
			addSpace;
			addButtonWithImageFrom: 'resources/open.bmp'
					action: [ :b <Button> |	self findDefinition ];
			addButtonWithImageFrom: 'resources/implementors.bmp'
					action: [ :b <Button> |	self findImplementors ];
			addButtonWithImageFrom: 'resources/senders.bmp'
					action: [ :b <Button> |	self findSenders ];
			addSpace;
			addButtonWithImageFrom: 'resources/userHierarchy.bmp'
					action: [ :b <Button> |	self openUserClassHierarchyOutliner ];
			addButtonWithImageFrom: 'resources/hierarchy.bmp'
					action: [ :b <Button> |	self openClassHierarchyOutliner ];
			addButtonWithImageFrom: 'resources/blankSheet.bmp'
					action: [ :b <Button> |	Workspace new launch ];
			addSpace;
			addButtonWithImageFrom: 'resources/texteditor.bmp'
					action: [ :b <Button> |	CodeEditor new launch ];
			addButtonWithImageFrom: 'resources/documentation.bmp'
					action: [ :b <Button> |	self launchDoc ];
			yourself! !

"June 6, 2007 -> 1:44:24"!

Delta define: #SourceHandler as: (
(Class subclassOf: 'NotifyingObject mixin |> Object' instanceVariables: 'mirror dualHandler indexFile indexDict isNewIndex ') classVariables: 'ActiveHandlers ChangeLog <CharWriteStream> RawChangeLog <ExternalReadWriteStream> SourceDirectory InitialChangeLogSize <Int>') !


"June 6, 2007 -> 1:44:25"!

Delta define: #SourceHandler as: (
(Class subclassOf: 'NotifyingObject mixin |> Object' instanceVariables: 'mirror dualHandler indexFile indexDict isNewIndex ') classVariables: 'ActiveHandlers ChangeLog <CharWriteStream> RawChangeLog <ExternalReadWriteStream> SourceDirectory InitialChangeLogSize <Int>') !


"June 6, 2007 -> 1:44:26"!

Delta define: #SourceHandler as: (
(Class subclassOf: 'NotifyingObject mixin |> Object' instanceVariables: 'mirror dualHandler indexFile indexDict isNewIndex ') classVariables: 'ActiveHandlers ChangeLog <CharWriteStream> RawChangeLog <ExternalReadWriteStream> SourceDirectory InitialChangeLogSize <Int>') !


"June 6, 2007 -> 1:44:26"!

Delta define: #SourceHandler as: (
(Class subclassOf: 'NotifyingObject mixin |> Object' instanceVariables: 'mirror dualHandler indexFile indexDict isNewIndex ') classVariables: 'ActiveHandlers ChangeLog <CharWriteStream> RawChangeLog <ExternalReadWriteStream> SourceDirectory InitialChangeLogSize <Int>') !


"June 6, 2007 -> 1:44:26"!

Delta define: #SourceHandler as: (
(Class subclassOf: 'NotifyingObject mixin |> Object' instanceVariables: 'mirror dualHandler indexFile indexDict isNewIndex ') classVariables: 'ActiveHandlers ChangeLog <CharWriteStream> RawChangeLog <ExternalReadWriteStream> SourceDirectory InitialChangeLogSize <Int>') !


"June 6, 2007 -> 1:44:26"!

Delta define: #SourceHandler as: (
(Class subclassOf: 'NotifyingObject mixin |> Object' instanceVariables: 'mirror dualHandler indexFile indexDict isNewIndex ') classVariables: 'ActiveHandlers ChangeLog <CharWriteStream> RawChangeLog <ExternalReadWriteStream> SourceDirectory InitialChangeLogSize <Int>') !


"June 6, 2007 -> 1:44:26"!

Delta define: #SourceHandler as: (
(Class subclassOf: 'NotifyingObject mixin |> Object' instanceVariables: 'mirror dualHandler indexFile indexDict isNewIndex ') classVariables: 'ActiveHandlers ChangeLog <CharWriteStream> RawChangeLog <ExternalReadWriteStream> SourceDirectory InitialChangeLogSize <Int>') !


"June 6, 2007 -> 1:44:26"!

Delta define: #SourceHandler as: (
(Class subclassOf: 'NotifyingObject mixin |> Object' instanceVariables: 'mirror dualHandler indexFile indexDict isNewIndex ') classVariables: 'ActiveHandlers ChangeLog <CharWriteStream> RawChangeLog <ExternalReadWriteStream> SourceDirectory InitialChangeLogSize <Int>') !


"June 6, 2007 -> 1:44:27"!

Delta define: #SourceHandler as: (
(Class subclassOf: 'NotifyingObject mixin |> Object' instanceVariables: 'mirror dualHandler indexFile indexDict isNewIndex ') classVariables: 'ActiveHandlers ChangeLog <CharWriteStream> RawChangeLog <ExternalReadWriteStream> SourceDirectory InitialChangeLogSize <Int>') !


"June 6, 2007 -> 1:44:27"!

Delta define: #SourceHandler as: (
(Class subclassOf: 'NotifyingObject mixin |> Object' instanceVariables: 'mirror dualHandler indexFile indexDict isNewIndex ') classVariables: 'ActiveHandlers ChangeLog <CharWriteStream> RawChangeLog <ExternalReadWriteStream> SourceDirectory InitialChangeLogSize <Int>') !


"June 6, 2007 -> 1:44:27"!

Delta define: #SourceHandler as: (
(Class subclassOf: 'NotifyingObject mixin |> Object' instanceVariables: 'mirror dualHandler indexFile indexDict isNewIndex ') classVariables: 'ActiveHandlers ChangeLog <CharWriteStream> RawChangeLog <ExternalReadWriteStream> SourceDirectory InitialChangeLogSize <Int>') !


"June 6, 2007 -> 1:44:28"!

(Delta mirrorFor: #SourceHandler)
comment: 
'This class manages the source code database. 
Subclasses are specialized for specific source constructs.
An instance of such a subclass manages the source code for a particular definition. For example,
a MixinSourceHandler handles source code for a partiular mixin.

The database usually resides in the subdirectory ''source'' of the strongtalk directory. If you wish to have
it elsewhere, set the environment variable StrongtalkSourceDir.

The database contains an identification file, strongtalksource.id. This file consists of two "chunks"
in file in format. The first chunk is a path, that specifies what binary the source database is
associated with. The second chunk is the size of the file strongtalkchange.log, which contains the
entire source code history of the system from last creation.

The source DB also includes files for every class and metaclass in the system. If the class is named X, then its
instance side is represented in the file X in the source directory, and its class side is represented in the file X.class.

Whenever a change is made to the
source code, several things happen:

0. The binary representation IN MEMORY is modified to match the changed source.
1. If this is a new definition X, then a file X.new is created in the source directory.
2. Otherwise, if this is the first change to this definition  in the current session, then:
a. The original source file for the definition X being modified is backed up as X.bak.
b.  The original source code, in file in format, is appended to the restore log, strongtalkrestore.log.
3. The source file for X is modified accordingly.
4. The change is appended to the change log, strongtalkchange.log.

When the system is saved, the binary on disk is rewritten to reflect the memory image of the program.
All the .bak files are removed, and all the .new files have their .new suffix removed, making the new source 
permanent. In addition, a save comment is written to the change log, and the restore log is deleted. 
Finally, the id file is regenerated: it will now contain the path
of the binary that was used in this session, and the size of the change log just after the save.

Using this information, the system can detect if the change log size is greater than the size listed in the id file. This 
indicates unsaved source changes. The system then generates a warning that the source DB is inconsistent with 
the binary. The user is then asked to resync the two. This is accomplished by :

a. Rolling back the change log to the index
indicated by the id file.  
b. For all files X.bak, remove the file X and then rename X.bak to X.
c. Remove all .new files.

Any lost changes can be filed in from the restore log.

Other than the logs and id file, the source DB consists of files representing the code in individual classes and
metaclasses. These rely heavily on indices into the change log, and are known as index files. Every instance
of a source handler has its own index file. The index files are represented in file in format, using chunks.

For every construct, the appropriate source handler defines a series of attributes. The index file then encodes
these attributes. Some attributes are listed directly in the index file, while others point at an index in the change
log. As a rule, if an attribute needs to be available quickly, it is encoded directly into the index file. For example,
category names and type signatures are needed by browsers that have to display this information, even if
no method bodies are being viewed. Type information is also needed by the type checker. Therefore, this
data is directly available in the index file. On the other hand, method bodies are only needed when a browser
opens a view on a method. In that case, we can afford to look it up in the change log, so the index file contains
only a number, which is a character offser into the change log where the method body can be found.

 (c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"June 6, 2007 -> 1:44:30"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
activeHandlers ^ <IdentityDictionary>

	"Contains all currently active source handlers. These are canonicalized.
	The implementation should be changed to use a weak dictionary so that unused
	source handlers can be garbage collected."

	ActiveHandlers isNil
		ifTrue: [	ActiveHandlers := IdentityDictionary[Object, SourceHandler] new ].
	^ActiveHandlers
! !

"June 6, 2007 -> 1:44:31"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
addSectionToChangeLog: blk <[WriteStream,^Int]> ^ <Int>

	| pos <Int> |
	self changeLog
		setToEnd;
		cr;
		nextPut: $";
		nextPutAll: Date dateAndTimeNow printString;
		nextPut: $";
		nextPut: $!!;        
		cr; cr.
	pos := blk value: self changeLog.
	self changeLog flush.
	^pos
! !

"June 6, 2007 -> 1:44:32"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
changeLog ^ <CharWriteStream>

	ChangeLog isNil ifTrue: [
		RawChangeLog := self changeLogFile readWriteStream.
		InitialChangeLogSize isNil
			ifTrue: [ InitialChangeLogSize := RawChangeLog size ].
		ChangeLog := BootStrapping
							ifTrue: [		CharacterInputOutputConverter on: RawChangeLog ]
							ifFalse: [ 	self changeLogFile writeStream ] ].
	^ChangeLog
! !

"June 6, 2007 -> 1:44:33"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
changeLogFile ^ <FilePath>

	^BootStrapping
		ifTrue: [ 	self sourceDirectory, (FilePath for: self changeLogFileName) ]
		ifFalse: [ 	File open: self changeLogFileName in: self sourceDirectory ]! !

"June 6, 2007 -> 1:44:34"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
changeLogFileName ^ <Str>

    ^'strongtalkchange.log'! !

"June 6, 2007 -> 1:44:35"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
checkSystemConsistency ^<Tuple[Boolean,Boolean]>
	"Check  source database consistency, and move any orphaned code to the
	  restore log, but otherwise do not restore the db to a consistent state.  A pair of booleans
	  is returned. The first indicates whether a restore is needed, and the second
	  indicates whether there was orphaned code (and thus that a the restore option
	  message should be printed."

	| 	shouldRestore <Boolean>
		hadOrphanedCode <Boolean>
		oldID <Str> 
		newID <Str> 
		oldLogSize <Int> 
		idStream <CharInputStream>
		restoreStream <CharInputStream> |

	self identificationFile exists ifTrue: [
		BootStrapping
			ifTrue: [	idStream := self identificationFile charInputStream.
							newID := Platform commandLineTokens next ]
			ifFalse: [	idStream := self identificationFile readStream.
							newID := SessionModel current commandLineTokens next ].
		[	
			oldID := idStream nextChunk.
			oldLogSize := Integer readFrom: idStream.
		] ensure: [
			idStream close
		].
		"		newID = oldID
			ifFalse: [	self printImageChangeWarningFrom: oldID to: newID ]"
			"The intent is that when the system is run, it checks to see if the current binary is the same 
			as the one listed in the source identification file and issues a warning if this is not the case. 
			This provides a crude consistency check.  However, it may issue false warnings,if the entire 
			strongtalk directory is moved to a new location. It even gets  confused if the system is run from the 
			command line or from the windows GUI, because the pathnames are not literally identical."

			"12/6/01: commented out code above; otherwise everyone downloading the system will get
			an annoying message they will not readily understand. If you've downloaded this
			code, feel free to uncomment this part."
			 ].

	shouldRestore := false.
	hadOrphanedCode := false.
	
	BootStrapping
		ifTrue: [
			(self sourceDirectory, (FilePattern for: '*.new')) pathsDo: [ :file <FilePath> |
				shouldRestore := true ].
			(self sourceDirectory, (FilePattern for: '*.bak')) pathsDo: [ :file <FilePath> |
				shouldRestore := true ] ]
		ifFalse: [
			self sourceDirectory fileNamesDo: [ :filename <Str> |
				('*.bak' match: filename) 
					ifTrue: [ shouldRestore := true ].
				('*.new' match: filename) 
					ifTrue: [ shouldRestore := true ] ] ].

	shouldRestore
		ifTrue: [	 oldLogSize notNil 
							ifTrue: [	self changeLog setToEnd.
											(oldLogSize > 0 and: [ oldLogSize < self changeLog position ]) 
												ifTrue: [	self changeLog position: oldLogSize.
																restoreStream := BootStrapping
																	ifTrue: [ 	self restoreFile charOutputStream ]
																	ifFalse: [	self restoreFile writeStream ].
																[
																	[ self changeLog atEnd ]
																		whileFalse: [	restoreStream nextPut: self changeLog next ]
																] ensure: [
																	restoreStream close
																].
																hadOrphanedCode := true. ] ] ].
	^shouldRestore,, hadOrphanedCode! !

"June 6, 2007 -> 1:44:36"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
checkSystemConsistencyAndPrintMessagesIfNeeded

	| status <Tuple[Boolean,Boolean]> |
	status := self checkSystemConsistency.
	status at1
		ifTrue: [ self printRestoreWarning ].
	status at2
		ifTrue: [ self printRestoreOption ].! !

"June 6, 2007 -> 1:44:37"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
currentChangeLogSize ^<Int>

	^self rawChangeLog size! !

"June 6, 2007 -> 1:44:38"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
currentUnsavedChanges ^<CharInputStream>
	"Return a stream over the unsaved changes that have been made, in fileout format.  This is
	 a snapshot as of when this method is called and won't reflect future changes"

	| strm <CharInputStream> logPos <Int> |
	self changeLog flush.
	logPos := self changeLog position.  "remember starting position"

	self changeLog position: self initialChangeLogSize.
	strm := self changeLog contentsRemaining readStream.
	
	"restore change log position"
	self changeLog position: logPos.
	^strm! !

"June 6, 2007 -> 1:44:39"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
dualHandlerFor: h <Instance> ^ <Instance> 

	^h isMeta
		ifTrue: [ self for: h instanceSide ]
		ifFalse: [ self for: h classSide ]
! !

"June 6, 2007 -> 1:44:40"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
errorStreams ^ <Cltn[CharOutputStream]>

	^BootStrapping
		ifTrue: [	Array[CharOutputStream] with: Transcript with: Platform errorStream ]
		ifFalse: [	Array[CharOutputStream] with: Transcript ]
! !

"June 6, 2007 -> 1:44:41"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
flush

	ChangeLog notNil
		ifTrue: [	ChangeLog close.
						ChangeLog := nil ].
	SourceDirectory := nil.
	self activeHandlers do: 
		[ :h <SourceHandler> | h flush ].

! !

"June 6, 2007 -> 1:44:42"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
for: m <Mirror> ^ <Instance> 

	| newHandler <Instance> |
	^self activeHandlers at: m reflectee ifAbsent: [ 
		newHandler := self new mirror: m.
		self activeHandlers at: m reflectee put: newHandler.
		newHandler ].
! !

"June 6, 2007 -> 1:44:43"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
identificationFile ^ <FilePath>

	^BootStrapping
		ifTrue: [ 	self sourceDirectory, (FilePath for: self identificationFileName) ]
		ifFalse: [ 	self sourceDirectory fileNamed: self identificationFileName ]! !

"June 6, 2007 -> 1:44:43"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
identificationFileName ^ <Str>

	^'strongtalksource.id'! !

"June 6, 2007 -> 1:44:44"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
initialChangeLogSize ^<Int>

	^InitialChangeLogSize! !

"June 6, 2007 -> 1:44:45"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
printImageChangeWarningFrom: old <Str> to: new <Str>

	self errorStreams do: [ :stream <CharOutputStream> |
		stream
			cr;
			show: 'WARNING !!!!!! WARNING !!!!!! WARNING !!!!!!'; cr; cr;
			show: 'The source database was last used from '; cr;
			show: '  ', old; cr;
			show: 'and is now being used from '; cr;
			show: '  ', new; cr ]! !

"June 6, 2007 -> 1:44:46"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
printRestoreOption

	self errorStreams do: [ :stream <CharOutputStream> |
		stream
			cr;
			show: 'Changes made since the last save can be found by executing'; cr;
			tab; showDoIt: '"Edit Restore File"                (CodeEditor on: (FilePath for: ''', 
										self restoreFile name,
										''')) launch'; show: '.'; cr.
			 ]! !

"June 6, 2007 -> 1:44:47"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
printRestoreWarning

	self errorStreams do: [ :stream <CharOutputStream> |
		stream
			cr;
			show: 'WARNING !!!!!! WARNING !!!!!! WARNING !!!!!!'; cr; cr;
			show: 'The source database is in an inconsistent state. This can'; cr;
			show: 'be caused by exiting without saving changes. Please execute '; cr;
			tab; showDoIt: 'SourceHandler restoreBackup'; cr;
			show: 'to restore the source database to the state when it was'; cr;
			show: 'last saved.'; cr ]
! !

"June 6, 2007 -> 1:44:48"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
rawChangeLog ^ <ExternalReadWriteStream>

	RawChangeLog isNil
		ifTrue: [	self changeLog ].
	^RawChangeLog! !

"June 6, 2007 -> 1:44:50"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
restoreBackup

	| newName <Str> newFile <FilePath> |
	self flush.
	BootStrapping
		ifFalse: [
			self sourceDirectory fileNamesDo: [ :filename <Str> |
				('*.new' match: filename) 
					ifTrue: [ (self sourceDirectory fileNamed: filename) remove ] ].
			self sourceDirectory fileNamesDo: [ :filename <Str> |
				('*.bak' match: filename)
					ifTrue: [ 	newName := filename copyFrom: 1 to: filename size - 4.
									newFile := self sourceDirectory fileNamed: newName.
									newFile exists
										ifTrue: [	newFile remove ].
									(self sourceDirectory fileNamed: filename)  renameAs: newName ] ] ]
		ifTrue: [
			(self sourceDirectory, (FilePattern for: '*.new')) pathsDo: [ :file <FilePath> |
				file delete ].
			(self sourceDirectory, (FilePattern for: '*.bak')) pathsDo: [ :file <FilePath> |
				newName := file name copyFrom: 1 to: file name size - 4.
				newFile := FilePath for: newName.
				newFile exists
					ifTrue: [	newFile delete ].
				file moveAs: newFile ].
			Transcript show: 'Source Database backup restored.';cr.	 ].		

! !

"June 6, 2007 -> 1:44:51"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
restoreFile ^ <FilePath>

	^BootStrapping
		ifTrue: [ 	self sourceDirectory, (FilePath for: self restoreFileName) ]
		ifFalse: [ 	self sourceDirectory fileNamed: self restoreFileName ]! !

"June 6, 2007 -> 1:44:52"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
restoreFileName ^ <Str>

	^'strongtalkrestore.log'! !

"June 6, 2007 -> 1:44:53"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
saveLogFile ^ <FilePath>

	^self sourceDirectory, (FilePath for: 'strongtalkSave.log')! !

"June 6, 2007 -> 1:44:54"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
sourceDirectory ^ <FilePath>

	| path <FilePath> len <Int> |
	SourceDirectory isNil ifTrue: [
		BootStrapping
			ifTrue: [ 
				path := FilePath for: 
								(Platform 
									environmentVariableAt: self sourceDirectoryEnvVar 
									ifAbsent: [ 'source' ]).		
									"Use 'source'  in current directory as default"
				path exists ifFalse: [
					path createDirectoryIfFail: [ :err <Symbol> | Win32 handleError ] ] ]
			ifFalse: [ 
				path := String new: 1024.
				len := KernelLibrary getEnvironmentVariable: self sourceDirectoryEnvVar buffer: path length: path size.
				(len = 0 or: [ len > 1024])
					ifTrue: [ self error: 'Environment variable ', self sourceDirectoryEnvVar,' undefined' ].
				path := Directory fromPath: (path copyFrom: 1 to: len).
				path exists ifFalse: [
					path create ] ].
		SourceDirectory := path ].
	^SourceDirectory
! !

"June 6, 2007 -> 1:44:55"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
sourceDirectoryEnvVar ^ <Str>

	^'StrongtalkSourceDir'! !

"June 6, 2007 -> 1:44:56"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
systemBeingSaved

	| identification <Str> idStream <CharOutputStream> logSize <Int> newName <Str> newFile <FilePath> |
	self flush.
	BootStrapping
		ifTrue: [	
			"Rename .new files and remove .bak files"
			(self sourceDirectory, (FilePattern for: '*.new')) pathsDo: [ :file <FilePath> |
				newName := file name copyFrom: 1 to: file name size - 4.
				newFile := FilePath for: newName.
				newFile exists
					ifTrue: [	self shouldNotHappen ].
				file moveAs: newFile ].
			(self sourceDirectory, (FilePattern for: '*.bak')) pathsDo: [ :file <FilePath> |
				file delete ] ]
		ifFalse: [	
			self sourceDirectory fileNamesDo: [ :filename <Str> |
				('*.new' match: filename) 
					ifTrue: [	newName := filename copyFrom: 1 to: filename size - 4.
									newFile := self sourceDirectory fileNamed: newName.
									newFile exists
										ifTrue: [	self shouldNotHappen ].
									(self sourceDirectory fileNamed: filename)  renameAs: newName ] ].
			self sourceDirectory fileNamesDo: [ :filename <Str> |
				('*.bak' match: filename)
					ifTrue: [ (self sourceDirectory fileNamed: filename) remove ] ] ].

	"Stamp change log"
	self addSectionToChangeLog: [ :log <WriteStream> |
		log nextPutAll: '"System saved" !!' ].
	logSize := self changeLog position.

	"Write new identification file"
	BootStrapping
		ifTrue: [
			identification := Platform commandLineTokens next.
			idStream := self identificationFile charOutputStream ]
		ifFalse: [
			identification := SessionModel current commandLineTokens next.
			idStream := self identificationFile writeStream ].
	[ 	idStream 
			deltaNextChunkPut: identification; cr; 
			deltaNextChunkPut: logSize printString; cr
	] ensure: [
		idStream close
	].

	self flush.
	
	self updateSaveLogFile
! !

"June 6, 2007 -> 1:44:58"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
systemIsConsistent ^<Boolean>

	| 	oldID <Str> 
		newID <Str> 
		oldLogSize <Int> 
		idStream <CharInputStream>
		restoreStream <CharInputStream> |

	self identificationFile exists ifTrue: [
		BootStrapping
			ifTrue: [	idStream := self identificationFile charInputStream.
							newID := Platform commandLineTokens next ]
			ifFalse: [	idStream := self identificationFile readStream.
							newID := SessionModel current commandLineTokens next ].
		[	
			oldID := idStream nextChunk.
			oldLogSize := Integer readFrom: idStream.
		] ensure: [
			idStream close
		].
		"		newID = oldID
			ifFalse: [	self printImageChangeWarningFrom: oldID to: newID ]"
			"The intent is that when the system is run, it checks to see if the current binary is the same 
			as the one listed in the source identification file and issues a warning if this is not the case. 
			This provides a crude consistency check.  However, it may issue false warnings,if the entire 
			strongtalk directory is moved to a new location. It even gets  confused if the system is run from the 
			command line or from the windows GUI, because the pathnames are not literally identical."

			"12/6/01: commented out code above; otherwise everyone downloading the system will get
			an annoying message they will not readily understand. If you've downloaded this
			code, feel free to uncomment this part."
			 ].

	BootStrapping
		ifTrue: [
			(self sourceDirectory, (FilePattern for: '*.new')) pathsDo: [ :file <FilePath> |
				^false ].
			(self sourceDirectory, (FilePattern for: '*.bak')) pathsDo: [ :file <FilePath> |
				^false ] ]
		ifFalse: [
			self sourceDirectory fileNamesDo: [ :filename <Str> |
				('*.bak' match: filename) 
					ifTrue: [ ^false ].
				('*.new' match: filename) 
					ifTrue: [ ^false ] ] ].
	^true! !

"June 6, 2007 -> 1:44:58"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
test

	MixinSourceHandler test.! !

"June 6, 2007 -> 1:44:59"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
unsavedChangesHaveBeenMade ^<Boolean>

	"make sure the change log etc. has been initialized"
	self changeLog.
	
	^self initialChangeLogSize ~= self currentChangeLogSize! !

"June 6, 2007 -> 1:45:1"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
updateSaveLogFile
	"Update the save log, if there is one.  This is done during a system save ONLY.  
		%bootstrapping: WARNING: there must not be a save file during the interval between when
		this save file change handling code is filed in, and when the system is restarted after 
		saving it "
	self saveLogFile exists
		ifTrue: [	| ss <ExternalReadWriteStream> logSize <Int> |
					"copy everything written to the change log in this session to the save log"
					
					ss := self saveLogFile readWriteStream.
					ss setToEnd.
					self changeLog flush.
					logSize := self changeLog position.  "remember starting position"
				
					self changeLog position: self initialChangeLogSize.
					[ self rawChangeLog atEnd ]
						whileFalse: 
								[	| byte <Int> |
									ss put: self rawChangeLog next.
									InitialChangeLogSize := InitialChangeLogSize + 1.  ].
					ss close.
					
					"restore the change log position."
					self changeLog position: logSize.	].! !

"June 6, 2007 -> 1:45:2"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
addSectionToChangeLog: blk <[WriteStream,^Int]> ^ <Int>

	^self class addSectionToChangeLog: blk! !

"June 6, 2007 -> 1:45:3"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
attributeAt: k <Str> ^ <OrdCltn[Str]>

	^self indexDict at: k ifAbsent: [ ^OrderedCollection with: String new ]! !

"June 6, 2007 -> 1:45:4"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
attributeAt: k <Str> put: e <OrdCltn[Str]>

	| removeAttribute <Boolean> |
	removeAttribute := BootStrapping
		ifTrue: [ (e isEmpty or: [ e size = 1 and: [ (e at: 1) = '' ] ] ) ]
		ifFalse: [ (e isEmpty or: [ e size = 1 and: [ (e at: 1) trimBlanks = '' ] ] ) ].
	removeAttribute
		ifTrue: [
			self indexDict removeKey: k ifAbsent: [] ]
		ifFalse: [
			self indexDict at: k put: e ].
	self isPersistent ifTrue: [ self storeIndexFile ].! !

"June 6, 2007 -> 1:45:5"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
backupExtension ^ <Str>

	^'.bak'! !

"June 6, 2007 -> 1:45:6"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
booleanAttributeAt: k <Str> ^ <Boolean>

	| list <OrdCltn[Str]> |
	list := self attributeAt: k.
	list size ~= 1 ifTrue: [ self shouldNotHappen ].
	^list first = 'true'
! !

"June 6, 2007 -> 1:45:7"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
booleanAttributeAt: k <Str> put: b <Boolean>

	self attributeAt: k put: (OrderedCollection with: b printString).
! !

"June 6, 2007 -> 1:45:7"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
changeLog ^ <FilePath>

	^self class changeLog! !

"June 6, 2007 -> 1:45:9"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
convertFromFilename: src <Str> ^ <Str>

	"Convert a file name into a Smalltalk toplevel definition by mapping the following:

		$A maps from '_a'       (uppercase letters)
		$_ maps from $_$_	"

	| rs <ReadStream> ws <WriteStream> c <Character> |
	rs := src readStream.
	ws := String new writeStream.
	[ rs atEnd ] whileFalse: [
		(c := rs next) = $_
			ifTrue: [
				rs peek = $_
					ifTrue: [
						rs next.
						ws nextPut: $_ ]
					ifFalse: [
						c := rs next.
						ws nextPut: c asUppercase ] ]
			ifFalse: [
				ws nextPut: c ] ].
	^ws contents
! !

"June 6, 2007 -> 1:45:10"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
convertToFilename: src <Str> ^ <Str>

	"Convert a Smalltalk toplevel definition name into a valid file name by mapping the following:

		$A maps to '_a'       (uppercase letters)
		$_ maps to $_$_	"

	| ws <WriteStream> |
	ws := (String new: src size * 2) writeStream.
	src do: [ :c <Character> | 
		c = $_
			ifTrue: [
				ws nextPut: $_.
				ws nextPut: $_ ]
			ifFalse: [
				c isUppercase ifTrue: [ ws nextPut: $_ ].
				ws nextPut: c asLowercase ] ].
	^ws contents
! !

"June 6, 2007 -> 1:45:11"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
dualHandler ^ <Self>

	self hasDualHandler
		ifFalse: 	[ ^nil ].
	dualHandler isNil ifTrue: [ 
		self dualHandler: (self class dualHandlerFor: self mirror).
		self dualHandler dualHandler: self ].
	^dualHandler! !

"June 6, 2007 -> 1:45:12"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
dualHandler: h ^ <Self>

	dualHandler := h! !

"June 6, 2007 -> 1:45:13"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
flush

	"Flush cached information. No store operation is needed since this is currently done eagerly."

	self indexDict: nil.
	self indexFile: nil.
	self isNewIndex: nil.
	(dualHandler notNil and: [self mirror notNil and: [self isMeta not]]) 
		ifTrue: [ self dualHandler flush ].! !

"June 6, 2007 -> 1:45:14"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
handlerId ^ <Str>

	self subclassResponsibility! !

"June 6, 2007 -> 1:45:15"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
hasDualHandler ^ <Boolean>

	^true! !

"June 6, 2007 -> 1:45:16"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
indexDict ^ <Dictionary[Symbol,Cltn[Str]]>

	indexDict isNil ifTrue: [ 
		self indexDict: Dictionary[Symbol,Cltn[String]] new.
		self isPersistent ifTrue: [
			self parseIndexFile ] ].
	^indexDict! !

"June 6, 2007 -> 1:45:17"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
indexDict: i <Dictionary[Symbol,Cltn[Str]]>

	indexDict := i! !

"June 6, 2007 -> 1:45:18"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
indexFile ^ <FilePath>

	| name <Str> |
	indexFile isNil ifTrue: [
		indexFile := BootStrapping
							ifTrue: [ 	self sourceDirectory, (FilePath for: self indexFileName) ]
							ifFalse: [ 	self sourceDirectory fileNamed: self indexFileName ].
		self isNewIndex: indexFile exists not.
		self isNewIndex
			ifTrue: [
				indexFile := BootStrapping
									ifTrue: [ 	self sourceDirectory, (FilePath for: self indexFileName, self newExtension) ]
									ifFalse: [ 	self sourceDirectory fileNamed: self indexFileName, self newExtension ] ] ].
	^indexFile
! !

"June 6, 2007 -> 1:45:19"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
indexFile: fp <FilePath>

	indexFile := fp! !

"June 6, 2007 -> 1:45:20"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
indexFileName ^ <Str>

	| s <Str> |
	s := self convertToFilename: (self mirror name readStream upTo: $ ).	"Strip meta extension"
	^self isMeta
		ifTrue: [ s, self metaExtension ]
		ifFalse: [ s ]
! !

"June 6, 2007 -> 1:45:21"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
isMeta ^ <Boolean>

	^self mirror isMeta! !

"June 6, 2007 -> 1:45:22"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
isNewIndex ^ <Boolean>

	isNewIndex isNil
		ifTrue: [	self indexFile ].		"Sets flag depending on whether index existed or not"
	^isNewIndex
! !

"June 6, 2007 -> 1:45:23"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
isNewIndex: b <Boolean>

	isNewIndex := b! !

"June 6, 2007 -> 1:45:24"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
isPersistent ^ <Boolean>

	^self mirror name notNil! !

"June 6, 2007 -> 1:45:25"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
makeBackupIndex

	| backupIndexFile <FilePath> |
	self isNewIndex ifFalse: [ 
		BootStrapping
		ifTrue: [ 	
			backupIndexFile  :=self sourceDirectory, (FilePath for: self indexFileName, self backupExtension).
			backupIndexFile exists 
				ifFalse: [ self indexFile copyAs: backupIndexFile ] ]
		ifFalse: [ 	
			(self sourceDirectory fileNamed: self indexFileName, self backupExtension) exists
				ifFalse: [ self indexFile copyTo: self sourceDirectory as: self indexFileName, self backupExtension ] ] ]
! !

"June 6, 2007 -> 1:45:26"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
metaExtension ^ <Str>

	^'.class'! !

"June 6, 2007 -> 1:45:27"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
mirror ^ <Mirror>

	^mirror! !

"June 6, 2007 -> 1:45:28"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
mirror: m <Mirror>

	mirror := m! !

"June 6, 2007 -> 1:45:28"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
newExtension ^ <Str>

	^'.new'! !

"June 6, 2007 -> 1:45:30"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
parseIndexFile

	| file <FilePath> rs <ReadStream> attr <Symbol> s <Str> value <OrdCltn[Str]> id <Str> |

	(file := self indexFile) exists ifTrue: [ 
		BootStrapping
			ifTrue: [ rs :=file charInputStream ]
			ifFalse: [ rs :=file readStream ].
		[
			rs atEnd ifFalse: [
				BootStrapping
					ifTrue: [ id := rs upTo: Character cr ]
					ifFalse: [ id := rs nextLine trimBlanks ].
				id = self handlerId
					ifFalse: [ self error: 'Source database inconsistency: Attemping to have a ', self handlerId, ' hold source for a ', id ] ].
			[ rs atEnd ] whileFalse: [
				s := rs nextChunk.
				BootStrapping ifFalse: [ s := s trimBlanks ].
				self assert: [ s size > 0].
				attr := s asSymbol.
				value := OrderedCollection [Str] new.
				[ (s := rs nextChunk) isEmpty ] whileFalse: [ 
					value add: s ].
				self indexDict at: attr put: value ].
		] ensure: [
			rs close 
		]
	]! !

"June 6, 2007 -> 1:45:31"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
printOn: aStream  <Stream> 
	aStream 
		nextPutAll: self class name;
		nextPutAll: ' on ';
		nextPutAll: self mirror name! !

"June 6, 2007 -> 1:45:32"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
removeAttributeAt: k <Str> ifAbsent: blk <[]> ^ <Cltn[Str]>

	self indexDict removeKey: k ifAbsent: blk.
	self storeIndexFile.! !

"June 6, 2007 -> 1:45:33"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
removeIndex

	self flush.
	self removeIndexFile.
	(self hasDualHandler and: [self isMeta not]) 
		ifTrue: [	self dualHandler removeIndexFile ].
	
	(self hasDualHandler and: [self isMeta]) 
		ifTrue: [ self dualHandler logRemoveDefinition ]
		ifFalse: [ self logRemoveDefinition ].

	"Done, nil out remaining entries"
	(self hasDualHandler and: [self isMeta not]) 
		ifTrue: [	self dualHandler mirror: nil.
						self dualHandler dualHandler: nil ].
	self mirror: nil.
	self dualHandler: nil
! !

"June 6, 2007 -> 1:45:34"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
removeIndexFile

	self makeBackupIndex.
	BootStrapping
		ifTrue: [ self indexFile deleteIfFail: [ :err <Symbol> | Win32 handleError ] ]
		ifFalse: [ self indexFile exists ifTrue: [ self indexFile close; remove ] ]! !

"June 6, 2007 -> 1:45:35"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
setName: n <Str>

	self storeIndexFile.
	(self hasDualHandler and: [ dualHandler notNil ])
		ifTrue: [	self dualHandler storeIndexFile ].
! !

"June 6, 2007 -> 1:45:36"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
sourceDirectory ^ <FilePath>

	^self class sourceDirectory
! !

"June 6, 2007 -> 1:45:37"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
storeIndexFile

	| ws <CharOutputStream> |
	self makeBackupIndex.
	BootStrapping
		ifTrue: [ ws := self indexFile charOutputStream ]
		ifFalse: [  ws := self indexFile writeStream ].
	[
		ws nextPutAll: self handlerId; cr.
		self indexDict associationsDo: [ :a <Association[Symbol, Cltn[Str]]> |
	 		ws deltaNextChunkPut: a key.
			a value do: [ :e <Str> | 
				ws cr; deltaNextChunkPut: e ].
			ws nextPut: $ ; nextPut: $!!; cr ].
		BootStrapping ifFalse: [ ws truncate ]
	] ensure: [
		ws close
	]
! !

"June 6, 2007 -> 1:45:38"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
uniqueAttributeAt: k <Str> ^ <Str>

	| list <OrdCltn[Str]> |
	list := self attributeAt: k.
	list size ~= 1 ifTrue: [ self shouldNotHappen ].
	^list first
! !

"June 6, 2007 -> 1:46:19"!

Delta define: #WinPOINT as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 6, 2007 -> 1:46:19"!

(Delta mirrorFor: #WinPOINT)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.1 $
'!


"June 6, 2007 -> 1:46:21"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
asPoint ^<Point>
	^self x @ self y! !

"June 6, 2007 -> 1:46:22"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
structureSize ^<Int>
	^8! !

"June 6, 2007 -> 1:46:23"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
x ^<SmallInteger>

	^self smallIntegerAt: self xOffset! !

"June 6, 2007 -> 1:46:23"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
x: v <SmallInteger>

	self smallIntegerAt: self xOffset put: v! !

"June 6, 2007 -> 1:46:24"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
y ^<SmallInteger>

	^self smallIntegerAt: self yOffset! !

"June 6, 2007 -> 1:46:25"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
y: v <SmallInteger>

	self smallIntegerAt: self yOffset put: v! !

"June 6, 2007 -> 1:46:26"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'offsets' !
xOffset ^<Int>
	^0! !

"June 6, 2007 -> 1:46:27"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'offsets' !
yOffset ^<Int>
	^4! !

"June 6, 2007 -> 1:48:29"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 6, 2007 -> 1:48:30"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 6, 2007 -> 1:48:30"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 6, 2007 -> 1:48:31"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 6, 2007 -> 1:48:31"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 6, 2007 -> 1:48:31"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 6, 2007 -> 1:48:31"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 6, 2007 -> 1:48:31"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 6, 2007 -> 1:48:31"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 6, 2007 -> 1:48:31"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 6, 2007 -> 1:48:31"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 6, 2007 -> 1:48:31"!

(Delta mirrorFor: #MINMAXINFO)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"June 6, 2007 -> 1:48:32"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'accessing' !
ptMaxSize ^<WinPOINT>

	^self subProxyAt: self ptMaxSizeOffset result: WinPOINT new! !

"June 6, 2007 -> 1:48:33"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'accessing' !
ptMaxTrackSize ^<WinPOINT>

	^self subProxyAt: self ptMaxTrackSizeOffset result: WinPOINT new! !

"June 6, 2007 -> 1:48:33"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'accessing' !
ptMinTrackSize ^<WinPOINT>

	^self subProxyAt: self ptMinTrackSizeOffset result: WinPOINT new! !

"June 6, 2007 -> 1:48:34"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'accessing' !
structureSize ^<Int>

	^40! !

"June 6, 2007 -> 1:48:35"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'offsets' !
ptMaxPositionOffset ^<Int>

	^16! !

"June 6, 2007 -> 1:48:36"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'offsets' !
ptMaxSizeOffset ^<Int>

	^8! !

"June 6, 2007 -> 1:48:37"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'offsets' !
ptMaxTrackSizeOffset ^<Int>

	^32! !

"June 6, 2007 -> 1:48:38"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'offsets' !
ptMinTrackSizeOffset ^<Int>

	^24! !

"June 6, 2007 -> 1:48:38"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'offsets' !
ptReservedOffset ^<Int>

	^0! !

"June 6, 2007 -> 1:49:13"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 6, 2007 -> 1:49:15"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 6, 2007 -> 1:49:15"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 6, 2007 -> 1:49:16"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 6, 2007 -> 1:49:16"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 6, 2007 -> 1:49:16"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 6, 2007 -> 1:49:17"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 6, 2007 -> 1:49:17"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 6, 2007 -> 1:49:18"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 6, 2007 -> 1:49:18"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 6, 2007 -> 1:49:19"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 6, 2007 -> 1:49:19"!

(Delta mirrorFor: #Win32Control)
comment: 
'A Visual that has a corresponding native Win32 window.

%optional #commandWith: - should override to process any WM_COMMAND messages needed

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.5 $
'!


"June 6, 2007 -> 1:49:21"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'private' !
controlForHandle: hwnd <ExternalProxy> ifAbsent: b <[^X def]> ^<Win32Control | X>

	^self controlFor: (self controlIdFor: hwnd) ifAbsent: b! !

"June 6, 2007 -> 1:49:22"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'private' !
controls ^<VarDict[Int, Win32Control]>

	"Assumption: allers must be in a critical region for self"

	Controls isNil
		ifTrue: [ Controls := Dictionary[Int, Win32Control] new ].
	^Controls! !

"June 6, 2007 -> 1:49:23"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'private' !
dispatchMsgFor: hwnd <ExternalProxy>
msg: msg <SmallInteger>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^(self controlForHandle: hwnd ifAbsent: [ ^0 ])
		message: msg for: hwnd wParam: wParam lParam: lParam! !

"June 6, 2007 -> 1:49:24"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
assignId ^<Int>
	"Assign and return a unique control id number.  It is assumed that we are already in a
		critical region on the Win32Control."

	MaxControlId isNil
				ifTrue: [ MaxControlId := 1 ]
				ifFalse: [ MaxControlId := MaxControlId + 1].
	^MaxControlId! !

"June 6, 2007 -> 1:49:25"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
buttonColorMsg: hdc <ExternalProxy> for: control <Int> ^<ExternalData>

	^(self controlFor: control  ifAbsent: [ ^0 ]) buttonColorMsg: hdc! !

"June 6, 2007 -> 1:49:27"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
controlFor: id <Int> ifAbsent: b <[^X def]> ^<Win32Control | X>

	^Win32Control
		critical: [	self controls at: id ifAbsent: b ]! !

"June 6, 2007 -> 1:49:27"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
controlIdFor: hwnd <HWND> ^<Int>

	^{{<user ExternalProxy GetWindowLongA> hwnd: hwnd value: Win32 GWL_ID}} asSmallInteger.
! !

"June 6, 2007 -> 1:49:29"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
customWndProc ^<APICallback>

	"Don't need a critical region"
	CustomWndProc isNil
		ifTrue: [	CustomWndProc := APICallBack
							register:
								[ :hwnd <ExternalProxy> :msg <SmallInteger> :wParam <ExternalData> :lParam <ExternalData> |
									self dispatchMsgFor: hwnd msg: msg wParam: wParam lParam: lParam ]
							parameters: (OrderedCollection[Class]
								with: ExternalProxy with: SmallInteger with: ExternalProxy with: ExternalProxy).	].
	^CustomWndProc! !

"June 6, 2007 -> 1:49:30"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
drawItemMsg: data <DRAWITEMSTRUCT> for: control <Int> ^<ExternalData>

	^(self controlFor: control ifAbsent: [ ^0 ]) drawItemMsg: data! !

"June 6, 2007 -> 1:49:31"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
measureItemMsg: data <MEASUREITEMSTRUCT> for: control <Int> ^<ExternalData>

	^(self controlFor: control ifAbsent: [ ^0 ]) measureItemMsg: data! !

"June 6, 2007 -> 1:49:31"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
notificationMsg: notifyCode <ExternalData> for: control <Int>

	(self controlFor: control ifAbsent: [ ^0 ]) notificationMsg: notifyCode! !

"June 6, 2007 -> 1:49:32"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
registerControl: id <Int> for: inst <Win32Control>

	Win32Control critical: 
		[ self controls at: id put: inst	]! !

"June 6, 2007 -> 1:49:33"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
unregisterControl: id <Int>

	Win32Control critical: [ self controls removeKey: id ]! !

"June 6, 2007 -> 1:49:34"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'testing' !
debugEvents ^<Boolean>

	^Session debugEvents! !

"June 6, 2007 -> 1:49:35"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'testing' !
debugNotifications ^<Boolean>

	^false! !

"June 6, 2007 -> 1:49:36"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
backgroundPainter ^<Painter>

	backgroundPainter isNil
		ifTrue: [ ^super backgroundPainter ].
	^backgroundPainter! !

"June 6, 2007 -> 1:49:37"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
enabled ^<Boolean>

	^enabled! !

"June 6, 2007 -> 1:49:38"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
enabled: flag <Boolean>

	self enabled = flag
		ifFalse: [	self setEnabled: flag ].! !

"June 6, 2007 -> 1:49:39"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
fullyEnabled ^<Boolean>

	"is true if we are enabled and all parents are enabled"
	^self enabled and: [ super enabled ]! !

"June 6, 2007 -> 1:49:40"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
nativeWindow ^<Window | Win32Control>

	^self! !

"June 6, 2007 -> 1:49:41"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
redraw ^<Boolean>

	^redraw! !

"June 6, 2007 -> 1:49:43"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'control' !
changing

	"flush the cached background painter so that it updates"
	backgroundPainter := nil.
	
	super changing! !

"June 6, 2007 -> 1:49:44"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'control' !
deferringRedrawDo: blk <[^Object]>
	"defer redrawing during evaluation of blk.  If these calls are nested recursively,
	   redrawing is deferred until the outermost returns, at which point the entire control
	   is invalidated.  This can be used to surround a large number of changes to the receiver
	   that would otherwise cause redundant redrawing."

	| oldFlag <Boolean> |
	oldFlag := self redraw.
	self redraw: false.
	blk value.
	self redraw: oldFlag.
	oldFlag
		ifTrue: [ self invalidate ]! !

"June 6, 2007 -> 1:49:45"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'control' !
ignoreNextFocusSet: flag <Boolean>

	ignoreNextFocusSet := flag! !

"June 6, 2007 -> 1:49:46"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'control' !
release

	self hasWin32Handle
		ifTrue: [ self destroyWin32Handle ].
	super release.! !

"June 6, 2007 -> 1:49:47"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'control' !
visible: flag <Boolean>

	| data <ExternalData> |
	self assert: [ self hasWin32Handle ].

	data := flag ifTrue: [ Win32 SW_SHOW ] ifFalse: [ Win32 SW_HIDE ].
	{{<user ExternalProxy ShowWindow> hwnd: self win32Handle flag: data}}.! !

"June 6, 2007 -> 1:49:48"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'debugging' !
printAllocOn: strm <CharOutputStream>

	super printAllocOn: strm.
	self hasWin32Handle
		ifTrue: [	strm show: ' hwnd: '; print: self win32Handle ]
		ifFalse: [ strm show: ' (no hwnd)' ]! !

"June 6, 2007 -> 1:49:50"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'displaying' !
localDisplayOn: can <Canvas>

	can subwindowsToDisplay add: self! !

"June 6, 2007 -> 1:49:51"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'event handling' !
character: c <Character> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	^(self callOrigWndProcFor: ev msg) = 0! !

"June 6, 2007 -> 1:49:52"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'event handling' !
keyDown: key <Symbol> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	^(self callOrigWndProcFor: ev msg) = 0! !

"June 6, 2007 -> 1:49:53"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'event handling' !
keyUp: key <Symbol> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	^(self callOrigWndProcFor: ev msg) = 0! !

"June 6, 2007 -> 1:49:54"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'event handling' !
mouseEvent: type <Symbol> at: loc <Point> event: ev <UIEvent> ^<Boolean>

	| orig <Point> |

	"Translate location back into native window coordinates"
	orig := self allocation enclosingRect origin.
	^(self callOrigWndProcFor: ev msg withLParam: (ExternalProxy forHigh: loc y - orig y low: loc x - orig x)) = 0! !

"June 6, 2007 -> 1:49:56"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'geometry-local' !
allocation: r <Region> at: pos <Point>

	| oldAlloc <Region> alloc <Rect> oldLayoutStatus <Int> |
	oldLayoutStatus := self layoutStatus.
	oldAlloc := allocation.
	alloc := r enclosingRect.
	super allocation: r at: pos.

	oldAlloc isNil
		ifTrue: [ self win32Handle.		"Make sure window is created with the current allocation & position" ]
		ifFalse: [	| oldNativePos <Point> old <Rect> | 
						"We need to use a variable since pos...Window changes nativePos"
						old := oldAlloc enclosingRect.
						oldNativePos := nativePosition.
						self hasWin32Handle
							ifTrue: [	(old width ~= alloc width
													or: [ old height ~= alloc height
													or: [ oldNativePos ~= self nativePosition ]  ] )
												ifTrue: [  self updateWindowDimensions  ]	 ]
							ifFalse: [	self isAttached
												ifTrue: [ self win32Handle ]	] ].
	"Invalidate if we are relaying out as a %hack to solve the problems that a higher level
		relayoutAndInvalidate doesn't invalidate contained native windows like this one"
	oldLayoutStatus = Visual needsRelayout
		ifTrue: [ self invalidate ]! !

"June 6, 2007 -> 1:49:57"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'geometry-nonlocal' !
moveBy: positionDelta <Point>

	"We override this since moving a native visual will generate any needed invalidations
	  automatically."

	self adjustPositionBy: positionDelta! !

"June 6, 2007 -> 1:49:58"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'initialization' !
initialize

	super initialize.
	redraw := true.
	enabled := true.
	isFocus := false.
	self addNonLocalCount: 1.		"Receiver is non-local"
	ignoreNextFocusSet := false.

	self refreshInterval: self defaultRefreshInterval.
	self paintPending: false.
	self useDisplayBuffering: true.
	controls := IdentitySet[Win32Control] new.! !

"June 6, 2007 -> 1:49:59"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
checkPaintTime: t <Float>
	"If we have reached our refresh time, paint"

	(self hasWin32Handle and: [ self paintPending ])
		ifTrue: [ self nextPaintTime <= t
						ifTrue: [ self display ]
						ifFalse: [ self session needPaintAtTime: self nextPaintTime ]	 ]! !

"June 6, 2007 -> 1:50:1"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
controls ^<Extensible[Win32Control]>

	^controls! !

"June 6, 2007 -> 1:50:2"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
cursor ^<Cursor>

	^cursor! !

"June 6, 2007 -> 1:50:3"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
cursor: c <Cursor>

	cursor := c.! !

"June 6, 2007 -> 1:50:4"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
defaultRefreshInterval ^<Float>

	^0.25! !

"June 6, 2007 -> 1:50:5"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
globalFromLocalPosition: p <WinPOINT> ^<WinPOINT>

	| wp <WinPOINT> result <WinPOINT> |
	wp := WinPOINT new allocate.
	wp x: p x; y: p y.
	{{<user ExternalProxy ClientToScreen>
			handle: self win32Handle
			point: wp
	}} asBoolean
		ifFalse: [ Win32 handleError ].
	result := wp x @ wp y.
	wp free.
	^result! !

"June 6, 2007 -> 1:50:6"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
handleMouseEvent: type <Symbol> at: loc <Point> ^<Boolean>

	| ev <UIEvent> |

	"%todo: remove the dispatch block for all events; isn't needed anymore"
	ev := UIEvent
			forMsg: self session currentMsg
			dispatch:
				[ :e <UIEvent> :h <UIEventHandler> |
					h mouseEvent: type at: loc event: e ].
	Sampler notNil
		ifTrue: [ Sampler 
						in: self topWindow visual 
						sampleEvent: type 
						at: (loc translatedBy: self positionInTopWindow)
						event: ev ].
	^self mouseEvent: type at: loc event: ev! !

"June 6, 2007 -> 1:50:7"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
localFromGlobalPosition: p <WinPOINT> ^<WinPOINT>

	| wp <WinPOINT> result <WinPOINT> |
	wp := WinPOINT new allocate.
	wp x: p x; y: p y.
	{{<user ExternalProxy ScreenToClient>
			handle: self win32Handle
			point: wp
	}} asBoolean
		ifFalse: [ Win32 handleError ].
	result := wp x @ wp y.
	wp free.
	^result translatedBy: self allocation enclosingRect origin! !

"June 6, 2007 -> 1:50:8"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
nextPaintTime ^<Float>

	^nextPaintTime! !

"June 6, 2007 -> 1:50:9"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
nextPaintTime: t <Float>

	nextPaintTime := t! !

"June 6, 2007 -> 1:50:10"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
noPalette

	palette := nil! !

"June 6, 2007 -> 1:50:12"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
paintOccuring

	self nextPaintTime: Time clockValue + self refreshInterval.
	self paintPending: false.
	self session paintOccuredFor: self.! !

"June 6, 2007 -> 1:50:13"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
paintPending ^<Boolean>

	^paintPending! !

"June 6, 2007 -> 1:50:14"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
paintPending: b <Boolean>

	paintPending := b! !

"June 6, 2007 -> 1:50:15"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
palette ^<Palette>

	^palette! !

"June 6, 2007 -> 1:50:16"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
palette: p <Palette>

	p == palette
		ifTrue: [ ^self ].
	self assert: [ palette isNil ].
	palette := p! !

"June 6, 2007 -> 1:50:17"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
paletteChangedMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	wParam @= self win32Handle
		ifFalse: [ self recursiveRealizePaletteForeground: false updateColors: true.
						self palette isNil
							ifTrue: [ ^self callDefWndProcFor: hwnd
											msgCode: msg
											wParam: wParam
											lParam: lParam	].
					 ].
	^0! !

"June 6, 2007 -> 1:50:18"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
queryPaletteMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self recursiveRealizePaletteForeground: true updateColors: false.
	self palette isNil
		ifTrue: [ ^self callDefWndProcFor: hwnd
						msgCode: msg
						wParam: wParam
						lParam: lParam	].
	^0! !

"June 6, 2007 -> 1:50:19"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
recursiveRealizePaletteForeground: fore <Boolean> updateColors: update <Boolean>

	self palette isNil
		ifFalse: [	self withDCDo:
							[ :hdc <HDC> |
								| oldpal <Win32Handle> |
								oldpal := Palette select: self palette win32Handle into: hdc background: fore not.
								self palette unrealize.
								self palette realizeFor: hdc.
								Palette debugging
									ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
								Palette select: oldpal win32Handle into: hdc background: fore not.
							 ].
						self invalidate.
						].
	self controls do:
		[ :c <Win32Control> |
			c recursiveRealizePaletteForeground: fore updateColors: update ].! !

"June 6, 2007 -> 1:50:20"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
refreshInterval ^<Float>

	^refreshInterval! !

"June 6, 2007 -> 1:50:21"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
refreshInterval: d <Float>
	"Wait no longer than this amount of time (in seconds) between
		paint operations, if possible"

	refreshInterval := d! !

"June 6, 2007 -> 1:50:22"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
registerControl: c <Win32Control>

	self controls include: c! !

"June 6, 2007 -> 1:50:24"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
registerPaintTime

	self paintPending
		ifFalse: [	self paintPending: true.
						self nextPaintTime: Time clockValue + self refreshInterval.
						self session schedulePaintFor: self at: self nextPaintTime.	].! !

"June 6, 2007 -> 1:50:25"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
setCursor ^<ExternalData>

	^cursor isNil
		ifFalse: [	{{<user ExternalProxy SetCursor> handle: cursor win32Handle}}.
						1 ]
		ifTrue: [ 0 ]! !

"June 6, 2007 -> 1:50:26"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
setCursorMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^(cursor notNil
			and: [	| hitcode <Int> |
						hitcode := lParam asExternalProxy low.
						hitcode = 1 or: [ hitcode = 65534 ] "client area or disabled"  ])
		ifTrue: [ 	self setCursor.
						1 ]
		ifFalse: [ self callOrigWndProc: msg wParam: wParam lParam: lParam ]
! !

"June 6, 2007 -> 1:50:27"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
showTimes ^<Boolean>
	"Report preference, layout, and painting times on the transcript"

	^false! !

"June 6, 2007 -> 1:50:28"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
unregisterControl: c <Win32Control>

	self controls removeEvery: c! !

"June 6, 2007 -> 1:50:29"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
useDisplayBuffering ^<Boolean>

	^useDisplayBuffering! !

"June 6, 2007 -> 1:50:30"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
useDisplayBuffering: f <Boolean>

	useDisplayBuffering := f! !

"June 6, 2007 -> 1:50:32"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
withBufferedCanvasDo: drawing <[Canvas,^X def]> ^<X>

	^self withDirectCanvasDo:
		[ :directCanvas <Canvas> |
			| invalid <Rect> oldpal <Win32Handle> |
			invalid := directCanvas clippingRect.

			self session
				withBufferCanvasFor: invalid
				do: [ :bufferCanvas <Canvas> :buffer <HBITMAP> |
							self palette isNil
								ifFalse: [ oldpal := bufferCanvas win32Palette: self palette win32Handle ].

							"draw on the buffer canvas"
							drawing value: bufferCanvas.
							bufferCanvas shallowFlush.

							"Now, copy the buffer bits onto the screen"
							directCanvas atOffset: invalid origin
								do: [ bufferCanvas atOffset: invalid origin 
									do: [	directCanvas
													bitBlt: bufferCanvas
												extent: invalid extent
												op: UI ropCopy.		].	].
							oldpal notNil
								ifTrue: [ 	Palette debugging
													ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
												bufferCanvas win32Palette: oldpal ]. 
						].	
		]! !

"June 6, 2007 -> 1:50:33"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
withCanvasDo: drawing <[Canvas,^X def]> ^<X>

	^(self useDisplayBuffering and: [ Window bufferingPossible ])
		ifFalse: [	self withDirectCanvasDo: drawing ]
		ifTrue: [	self withBufferedCanvasDo: drawing ]! !

"June 6, 2007 -> 1:50:34"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
withDCDo: blk <[HDC]>
	"With the window's device context do the block (not for painting)"

	| hdc <HDC> |
	hdc := {{<user HDC GetDC> hwnd: self win32Handle}}.
	[ blk value: hdc ]
		ensure: [ hdc releaseDCFor: self win32Handle ]! !

"June 6, 2007 -> 1:50:36"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
withDirectCanvasDo: drawing <[Canvas,^X def]> ^<X>

	|	can <Canvas>
		ps <PAINTSTRUCT>
		paintBlk <[^Object]>
		result <X>
		oldpal <Win32Handle>  |

	"use a critical region to paint, since background painting might reuse the
	  same device context in the UI thread"
	^self critical:
		[	ps := PAINTSTRUCT new allocateZeroed.
			can := self beginPaint: self win32Handle paintStructure: ps.
			can isNull
				ifTrue: [ Win32 handleError ].
			can	initialize;
				toRelease: [ :dc <HDC> | "End paint will release the context" ];
				initClippingRectBeforeTranslation: ps rcPaint asRectangle;
				window: self.
			self palette isNil
				ifFalse: [ oldpal := can win32Palette: self palette win32Handle ].

			Session debugInvalidation
				ifTrue: [	can withPainter: (Painter new paint: Paint red)
									do: [ can displayFilledRectangle: ps rcPaint asRectangle; flush. ].
								Platform errorStream show: self class name, ' rendering: '; print: ps rcPaint asRectangle; cr.	].

			result := drawing value: can.
			oldpal notNil
				ifTrue: [ 	Palette debugging
									ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
								can win32Palette: oldpal ]. 
			can release. 

			self endPaint: self win32Handle paintStructure: ps.
			ps free.
			result	]! !

"June 6, 2007 -> 1:50:37"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Windows with mods' !
display

	"win32 controls do no Smalltalk level painting by default"! !

"June 6, 2007 -> 1:50:38"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'notification' !
detaching

	super detaching.
	self cleanUp! !

"June 6, 2007 -> 1:50:39"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'notification' !
isFocus: f <Boolean>

	isFocus := f.
	super isFocus: f.
! !

"June 6, 2007 -> 1:50:40"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'notification' !
nativePositionChanged

	"DON'T pass this message to super, since our children are native relative to us!!"

	(self checkForNativePositionChanging or: [ self isAttached ])
		ifTrue: [ self updateWindowDimensions ]! !

"June 6, 2007 -> 1:50:41"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
buildWin32Handle

	self subclassResponsibility! !

"June 6, 2007 -> 1:50:42"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
callOrigWndProc: msgCode <ExternalData> wParam: wParam <ExternalData> lParam: lParam <ExternalData>^<ExternalData>
	"Like callOrigWndProcFor:, but takes all args rather than using a MSG structure"

	"Note that we use the receiver's win32Handle below rather than the one in the message so
	 	 this works even when the event was generated during a grab"
	^{{<user ExternalProxy CallWindowProcA> 
		proc: self originalWndProc
		hwnd: self win32Handle
		msg: msgCode
		wparam: wParam
		lparam: lParam }}! !

"June 6, 2007 -> 1:50:43"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
callOrigWndProcFor: m <MSG> ^<ExternalData>

	"Note that we use the receiver's win32Handle below rather than the one in the message so
	 	 this works even when the event was generated during a grab"
	^{{<user ExternalProxy CallWindowProcA> 
		proc: self originalWndProc
		hwnd: self win32Handle
		msg: m message
		wparam: m wParam
		lparam: m lParam }}! !

"June 6, 2007 -> 1:50:45"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
callOrigWndProcFor: m <MSG> withLParam: lParam <ExternalData>^<ExternalData>
	"Like callOrigWndProcFor:, but overrides the lParam value from the msg"

	"Note that we use the receiver's win32Handle below rather than the one in the message so
	 	 this works even when the event was generated during a grab"
	^{{<user ExternalProxy CallWindowProcA> 
		proc: self originalWndProc
		hwnd: self win32Handle
		msg: m message
		wparam: m wParam
		lparam: lParam }}! !

"June 6, 2007 -> 1:50:46"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
canBeFocusCandidate ^<Boolean>
	"%optional: Subclasses that cannot be the input focus even when they are enabled should override this
	  to return false"

	^true! !

"June 6, 2007 -> 1:50:47"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
checkForNativePositionChanging ^<Boolean>
	"returns true if the native position has been changed"

	
	^self hasWin32Handle
			and: [	| oldpos <Point> |
						oldpos := nativePosition.
						oldpos ~= self nativePosition	]! !

"June 6, 2007 -> 1:50:48"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
cleanUp

	self isFocus
		ifTrue: [	self nativeWindow ignoreNextFocusSet: true.
						self session noInputFocus. ].
	self destroyWin32Handle.
! !

"June 6, 2007 -> 1:50:49"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
controlId ^<Int>

	^controlId! !

"June 6, 2007 -> 1:50:50"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
createNativeWindow

	"we need a critical region to protect the class variable:"
	Win32Control
		critical: [	controlId := self actualClass assignId.
							self actualClass registerControl: self controlId for: self.
							self paintPending: false.
							self buildWin32Handle.
							self palette notNil
								ifTrue: [ self recursiveRealizePaletteForeground: true updateColors: true. ].
							self nativeWindow registerControl: self.
	
							self originalWndProc: (self wndProc).
							self wndProc: self customWndProc.
							self isFocus
								ifTrue: [ self setFocus ].
						].! !

"June 6, 2007 -> 1:50:51"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
createVisible ^<Boolean>

	^true! !

"June 6, 2007 -> 1:50:52"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
customWndProc ^<APICallback>

	^self actualClass customWndProc! !

"June 6, 2007 -> 1:50:53"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
debugTest: msgCode <ExternalData> for: hwnd <ExternalData>

	Win32Control debugEvents
			ifTrue: [	Platform errorStream
									show: 'control winproc event: ';
									show: (MSG descriptionOf: msgCode asExternalProxy);
									show: ' window: ';
									print: hwnd;
									cr. 	].! !

"June 6, 2007 -> 1:50:55"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
destroyWin32Handle

	win32Handle notNil
		ifTrue: [	| hand <ExternalProxy> |
						self actualClass unregisterControl: self controlId.
						self nativeWindow unregisterControl: self.
						hand := self win32Handle.
						win32Handle := nil.		"We nil the handle before destroying so that we can tell
																we are dead if there is a focus shift caused by destroy"
						{{<user ExternalProxy DestroyWindow>
							handle: hand }}.		]! !

"June 6, 2007 -> 1:50:57"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
displayUpwardPopUpMenuAt: loc <Point> ^<Boolean>
	"Look up the parent chain for a popUp menu and display it, if there is one.
		Return true if one was found"

	| m <Menu> t <Timer> |
	m := self parent popUpMenuIfAbsent: [ ^false ].
	self	displayPopUpMenu: m
			at: loc
			forButton: #secondary.
	t := self session atIntervals: 1.0 do:
			[	m release.
				t release. ].
	^true! !

"June 6, 2007 -> 1:50:58"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
extendedWin32Style ^<ExternalData>

	^Win32 WS_EX_NOPARENTNOTIFY! !

"June 6, 2007 -> 1:50:59"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
handleMouseEvent: type <Symbol>
message: msgCode <ExternalData>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>

	| loc <Point> |
	"Translate to be relative to our origin"
	loc := (lParam low @ lParam high) + self allocation enclosingRect origin.
	self handleMouseEvent: type at: loc! !

"June 6, 2007 -> 1:51:0"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
hasWin32Handle ^<Boolean>

	^win32Handle notNil! !

"June 6, 2007 -> 1:51:1"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
invalidate: r <Region>

	self registerPaintTime.
	(self layoutStatus = Visual valid and: [ self hasWin32Handle ])
		ifTrue: [	| rect <Rect> nativerect <RECT> |

						nativerect := RECT new allocate.
						rect := r enclosingRect relativeTo: self allocation origin.
						nativerect
							left: rect left asInteger;
							right: rect right asInteger;
							top: rect top asInteger;
							bottom: rect bottom asInteger.
						{{<user ExternalProxy InvalidateRect>
							hwnd: self win32Handle
							RECT: nativerect
							erase: true}}.
						nativerect free.	]! !

"June 6, 2007 -> 1:51:2"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
nativePosition ^<Point>

	"We have to adjust for the fact that our allocation origin might not be 0@0"
	^nativePosition := self positionInContainingNativeWindow + self allocation enclosingRect origin! !

"June 6, 2007 -> 1:51:3"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
originalWndProc ^<HWND>

	^originalWndProc! !

"June 6, 2007 -> 1:51:4"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
originalWndProc: h <HWND>

	originalWndProc := h! !

"June 6, 2007 -> 1:51:5"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
redraw: flag <Boolean>
	"Tell the widget to start or stop redrawing (temporarily) when necessary.  This is usually used
		with a true arg before a large number of changes, followed by a send with a false arg."

	flag = self redraw
		ifFalse: [	redraw := flag.
						self hasWin32Handle
							ifTrue: [	self	sendMessage: Win32 WM_SETREDRAW
													wparam: flag asExternalData
													lparam: 0	]].! !

"June 6, 2007 -> 1:51:7"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
setEnabled: flag <Boolean>

	enabled := flag.
	win32Handle notNil
		ifTrue: [	{{<user ExternalProxy EnableWindow>
								handle: self win32Handle
								state: self fullyEnabled asExternalData}}.	].
! !

"June 6, 2007 -> 1:51:8"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
setWindowText: t <Str>

	| label <CString> |
	label := CString for: t.
	{{<user ExternalProxy SetWindowText>
		handle: self win32Handle
		str: label}}.
	label free.! !

"June 6, 2007 -> 1:51:9"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
updateWindowDimensions
	"set the control's native size and position"

	| pos <Point> |

	pos := self nativePosition.
	self paintPending: false.
	{{<user ExternalProxy MoveWindow>
		handle: self win32Handle
		x: pos x asInteger
		y: pos y asInteger
		width: self allocation enclosedRect width asInteger
		height: self allocation enclosedRect height asInteger
		repaint: true asExternalData
	 }} asBoolean
			ifFalse: [ Win32 handleError ]! !

"June 6, 2007 -> 1:51:10"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
win32Style ^<ExternalData>

	| s <ExternalData> |
	s := Win32 WS_CHILDWINDOW.
	self createVisible
		ifTrue: [ s := s externalBitOr: Win32 WS_VISIBLE. ].
	self fullyEnabled
		ifFalse: [ s := s externalBitOr: Win32 WS_DISABLED ].
	^s! !

"June 6, 2007 -> 1:51:11"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
wndProc ^<ExternalProxy>

	^Window wndProcOf: self win32Handle! !

"June 6, 2007 -> 1:51:12"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
wndProc: wp <ExternalProxy>

	Window wndProcOf: self win32Handle put: wp! !

"June 6, 2007 -> 1:51:13"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private-message handling' !
beforeKillFocus

	(self session hasInputFocus and: [ self session inputFocus nativeWindow = self ])
		ifTrue: [ self session noInputFocus ].! !

"June 6, 2007 -> 1:51:14"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private-message handling' !
beforeSetFocus

	ignoreNextFocusSet
		ifTrue: [	"We requested the focus, and have already recorded it, so
							ignore this."
						ignoreNextFocusSet := false.	]
		ifFalse: [	"We didn't request this, so windows must be requesting it, so
							record it"
						"We don't use becomeFocus here because that would cause another
							windows setFocus message"
						self session inputFocus: self.		]! !

"June 6, 2007 -> 1:51:16"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private-message handling' !
contextMenuMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<Boolean>

	^self displayUpwardPopUpMenuAt:
			(self localFromGlobalPosition: lParam low @ lParam high)! !

"June 6, 2007 -> 1:51:17"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private-testing' !
isFocusCandidate ^<Boolean>

	^self canBeFocusCandidate
		and: [ self hasWin32Handle
		and: [ self enabled ] ]! !

"June 6, 2007 -> 1:51:18"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private-testing' !
isRectangularAndOpaque ^<Boolean>

	^true! !

"June 6, 2007 -> 1:51:19"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-to session' !
blinkFocus: shown <Boolean>
	
! !

"June 6, 2007 -> 1:51:20"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
buttonColorMsg: hdc <ExternalProxy> ^<ExternalData>

	"Should only get sent to buttons, which override this"
	self shouldNotHappen! !

"June 6, 2007 -> 1:51:21"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
commandWith: notifyCode <ExternalData> ^<ExternalData>

	"Subclasses should override to process command msgs"! !

"June 6, 2007 -> 1:51:22"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
drawItemMsg: data <DRAWITEMSTRUCT> ^<ExternalData>

	self shouldNotHappen! !

"June 6, 2007 -> 1:51:23"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
hInstance ^<ExternalProxy>

	^self parent nativeWindow hInstance! !

"June 6, 2007 -> 1:51:24"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
measureItemMsg: data <MEASUREITEMSTRUCT> ^<ExternalData>

	self shouldNotHappen! !

"June 6, 2007 -> 1:51:26"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
message: msgCode <ExternalData>
for: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self debugTest: msgCode for: hwnd.

	(self session handleIfFocusMsg: msgCode for: self wParam: wParam lParam: lParam) = 0
		ifTrue: [ ^0 ].

	msgCode @= Win32 WM_LBUTTONDOWN 
		ifTrue: [	self handleMouseEvent: #primaryButtonDown
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_LBUTTONUP 
		ifTrue: [	self handleMouseEvent: #primaryButtonUp
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_LBUTTONDBLCLK
		ifTrue: [	self handleMouseEvent: #primaryButtonDoubleClick
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_RBUTTONDOWN 
		ifTrue: [	self handleMouseEvent: #secondaryButtonDown
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_RBUTTONUP 
		ifTrue: [	self handleMouseEvent: #secondaryButtonUp
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_RBUTTONDBLCLK
		ifTrue: [	self handleMouseEvent: #secondaryButtonDoubleClick
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_MOUSEMOVE 
		ifTrue: [	self handleMouseEvent: #mouseMove
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].

	msgCode @= Win32 WM_CTLCOLORBTN
		ifTrue: [ ^Win32Control buttonColorMsg: wParam asExternalProxy for: (Win32Control controlIdFor: lParam) ].

	msgCode @= Win32 WM_DRAWITEM
		ifTrue: [	^Win32Control drawItemMsg: (DRAWITEMSTRUCT forProxy: lParam) for: wParam asSmallInteger ].

	msgCode @= Win32 WM_MEASUREITEM
		ifTrue: [	| data <MEASUREITEMSTRUCT> |
						data := MEASUREITEMSTRUCT forProxy: lParam.
						data CtlType @= Win32 ODT_MENU
							ifFalse: [ ^Win32Control measureItemMsg: data for: data CtlID asSmallInteger ] ].

	(msgCode @= Win32 WM_COMMAND and: [ lParam @~= Win32 NULL ])
		ifTrue: [	"Then this is a control window notification, which should be forwarded back to the
						  smalltalk control object"
						Win32Control notificationMsg: wParam asExternalProxy high for: (Win32Control controlIdFor: lParam).
						^0 ].

	msgCode @= Win32 WM_SETFOCUS
		ifTrue: [ self beforeSetFocus ].
	msgCode @= Win32 WM_KILLFOCUS
		ifTrue: [ self beforeKillFocus ].

	msgCode @= Win32 WM_CONTEXTMENU
		ifTrue: [ (self contextMenuMsg: msgCode hwnd: hwnd wParam: wParam lParam: lParam)
						ifTrue: [ ^0 ]. ].

	msgCode @= Win32 WM_QUERYNEWPALETTE 
		ifTrue: [	self queryPaletteMsg: msgCode hwnd: hwnd
								wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_PALETTECHANGED 
		ifTrue: [	self paletteChangedMsg: msgCode hwnd: hwnd
								wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_SETCURSOR 
		ifTrue: [	^self setCursorMsg: msgCode hwnd: hwnd
								wParam: wParam lParam: lParam	 ].

	^{{<user ExternalProxy CallWindowProcA> 
		proc: self originalWndProc
		hwnd: hwnd
		msg: msgCode
		wparam: wParam
		lparam: lParam }}! !

"June 6, 2007 -> 1:51:28"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
notificationMsg: notifyCode <ExternalData>

	"Subclasses can extend to process notification msgs"

	Win32Control debugNotifications
			ifTrue: [ Platform errorStream
							show: 'control notification: ';
							print: notifyCode;
							show: ' window: ';
							print: self win32Handle;
							cr ].

	notifyCode @= Win32 BN_KILLFOCUS
		ifTrue: [ "%todo" ].
	notifyCode @= Win32 BN_SETFOCUS
		ifTrue: [ "%todo" ].
! !

"June 6, 2007 -> 1:51:29"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
sendMessage: msg <ExternalData>
wparam: wp <ExternalData>
lparam: lp <ExternalData>
^<ExternalProxy>

	^{{<user ExternalProxy SendMessageA>
			handle: self win32Handle
			msg: msg
			wparam: wp
			lparam: lp}}! !

"June 6, 2007 -> 1:51:30"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
setFocus

	ignoreNextFocusSet := true.
	 self win32Handle @= {{<user ExternalProxy GetFocus> call}}
		ifFalse: [  {{<user ExternalProxy SetFocus> hwnd: self win32Handle}} ]! !

"June 6, 2007 -> 1:51:31"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
win32Handle ^<HWND>

	win32Handle isNil	
		ifTrue: [ self createNativeWindow ].
	^win32Handle! !

"June 6, 2007 -> 1:51:32"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'testing' !
isFocus ^<Boolean>

	^isFocus! !

"June 6, 2007 -> 1:51:52"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 6, 2007 -> 1:51:54"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 6, 2007 -> 1:51:55"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 6, 2007 -> 1:51:56"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 6, 2007 -> 1:51:57"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 6, 2007 -> 1:51:57"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 6, 2007 -> 1:51:58"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 6, 2007 -> 1:51:59"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 6, 2007 -> 1:51:59"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 6, 2007 -> 1:52:0"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 6, 2007 -> 1:52:0"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 6, 2007 -> 1:52:2"!

(Delta mirrorFor: #Window)
comment: 
'Native windows, with a fairly machine independent interface
(except for methods with ''win32'' in their names).

Tags: %User %UI

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.
'!


"June 6, 2007 -> 1:52:3"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'custom messages' !
LAYOUT ^<ExternalData>
	"This is by the UI thread to tell a window's session process to layout a window.  This has
	  to be done through the message queue so that the layout code runs in the window's session
	  process.  lParam low is width, and lParam high is height."

	^16r400! !

"June 6, 2007 -> 1:52:4"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'debugging' !
bufferingPossible ^<Boolean>

	BufferingPossible isNil
		ifTrue: [ BufferingPossible := true ].
	^BufferingPossible! !

"June 6, 2007 -> 1:52:5"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'debugging' !
bufferingPossible: f <Boolean>
	"If this is set to false, all double buffering will be disabled, usually for debugging
		purposes."

	BufferingPossible := f! !

"June 6, 2007 -> 1:52:6"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
defaultWin32Cursor ^<ExternalProxy>

	^{{<user ExternalProxy LoadCursorA> arg: 0 arg: Win32 IDC_ARROW}}! !

"June 6, 2007 -> 1:52:7"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
defaultWin32Icon ^<ExternalProxy>

	^{{<user ExternalProxy LoadIconA> arg: 0 arg: Win32 IDI_APPLICATION}}! !

"June 6, 2007 -> 1:52:8"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
defaultWndProc ^<ExternalProxy>

	"Don't need a critical region because duplicate inits are no problem"
	DefaultWndProc isNil
		ifTrue: [	DefaultWndProc := Platform DLLLookup: 'DefWindowProcA' in: 'user' ].
	^DefaultWndProc! !

"June 6, 2007 -> 1:52:10"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
parentOf: w <HWND> ^<HWND>

	^{{<user ExternalProxy GetParent> wnd: w}}! !

"June 6, 2007 -> 1:52:11"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
wndProcOf: w <HWND> ^<HWND>

	^{{<user ExternalProxy GetWindowLongA> wnd: w attr: Win32 GWL_WNDPROC}}! !

"June 6, 2007 -> 1:52:11"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
wndProcOf: w <HWND> put: newWinProc <HWND> ^<HWND>

	^{{<user ExternalProxy SetWindowLongA> wnd: w attr: Win32 GWL_WNDPROC value: newWinProc}}! !

"June 6, 2007 -> 1:52:12"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
addNonLocalCount: delta <Int>
	
	! !

"June 6, 2007 -> 1:52:14"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
containerBackgroundPainter ^<Painter>

	^Painter defaultBackground! !

"June 6, 2007 -> 1:52:15"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
containsFocus: flag <Boolean>

	flag
		ifTrue: [	self session activeWindow: self.
						self mostRecentInputFocus: session inputFocus.	].
	"We don't need to remove the active window ifFalse because the session does that"! !

"June 6, 2007 -> 1:52:16"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
displayNowIfInvalid
	"Redraw any invalid areas before proceeded"

	self display! !

"June 6, 2007 -> 1:52:18"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
displayPopUpMenu: menu <Menu> at: loc <Point> forButton: button <Symbol>

	| gloc <Point> flags <ExternalData> |
	popUpMenu := menu.

	flags := Win32 TPM_LEFTALIGN.
	button = #left
		ifTrue: [ flags := flags externalBitOr: Win32 TPM_LEFTBUTTON ]
		ifFalse: [ flags := flags externalBitOr: Win32 TPM_RIGHTBUTTON ].

	gloc := self globalFromLocalPosition: loc.
	{{<user ExternalProxy TrackPopupMenu>
		handle: menu win32Handle
		flags: flags
		x: gloc x
		y: gloc y
		reserved: 0
		window: self win32Handle
		rect: Win32 NULL
	}} asBoolean
		ifFalse: [ Win32 getLastError @= Win32 ERROR_POPUP_ALREADY_ACTIVE
							ifFalse: [ Win32 handleError ].
						].

	popUpMenu := nil.
! !

"June 6, 2007 -> 1:52:19"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
invalidate: r <Region> forChild: child <Visual>

	self invalidate: (r enclosingRect translatedBy: child position)! !

"June 6, 2007 -> 1:52:20"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
isAttached ^<Boolean>

	^true! !

"June 6, 2007 -> 1:52:21"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
nativeWindow ^<Window | Win32Control>

	^self! !

"June 6, 2007 -> 1:52:22"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
parentVisualOfChild ^<Visual>

	self shouldNotHappen! !

"June 6, 2007 -> 1:52:24"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
popUpMenuIfAbsent: f <[^X def]> ^<Menu | X>

	^f value! !

"June 6, 2007 -> 1:52:25"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
positionInContainingNativeWindowOf: child <Visual> ^<Point>

	^child position! !

"June 6, 2007 -> 1:52:26"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
positionInTopWindowOf: child <Visual>

	^child position! !

"June 6, 2007 -> 1:52:28"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
scrollIfNeededToMakeVisible: area <Rect>
relativeTo: v <Visual>
minimizeMotion: minimizeMotion <Boolean>


	! !

"June 6, 2007 -> 1:52:29"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
scrollMeOrAParentBy: distance <Int> vertical: vertical <Boolean>

	"do nothing"! !

"June 6, 2007 -> 1:52:30"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
topWindow ^<Window>

	^self! !

"June 6, 2007 -> 1:52:31"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
translate: p <Point> fromChild: child <Visual> ^<Point>

	"Translate p from the child's coordinates to ours"
	^p translatedBy: child position! !

"June 6, 2007 -> 1:52:33"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
translate: p <Point> toChild: child <Visual> ^<Point>

	"Translate p from our coordinates to the child's"
	^p relativeTo: child position! !

"June 6, 2007 -> 1:52:34"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
translateRect: r <Rect> fromChild: child <Visual> ^<Rect>

	"Translate p from the child's coordinates to ours"
	^r translatedBy: child position! !

"June 6, 2007 -> 1:52:35"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
translateRect: r <Rect> toChild: child <Visual> ^<Rect>

	"Translate p from the child's coordinates to ours"
	^r relativeTo: child position! !

"June 6, 2007 -> 1:52:36"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
allocation ^<Region>

	^Point origin corner: self extent! !

"June 6, 2007 -> 1:52:38"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
backgroundPainter ^<Painter>
	"The paint for the window background.  This can be automatically derived from the
	 background painter for the visual.  It can also be set explicitly."

	^self hasBackgroundPainter
		ifTrue: [ backgroundPainter ]
		ifFalse: [ backgroundPainter := self visual backgroundPainter ]! !

"June 6, 2007 -> 1:52:39"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
backgroundPainter: p <Painter>

	backgroundPainter := p! !

"June 6, 2007 -> 1:52:40"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
cursor ^<Cursor>

	^cursor! !

"June 6, 2007 -> 1:52:42"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
cursor: c <Cursor>

	cursor := c.! !

"June 6, 2007 -> 1:52:43"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
desiredPosition: p <Point>

	desiredPosition := p! !

"June 6, 2007 -> 1:52:44"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
enabled ^<Boolean>

	^enabled! !

"June 6, 2007 -> 1:52:45"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
enabled: flag <Boolean>

	self enabled = flag
		ifFalse: [	self setEnabled: flag ].! !

"June 6, 2007 -> 1:52:46"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
extent ^<Point>

	^extent! !

"June 6, 2007 -> 1:52:48"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
hasParent ^<Boolean>

	^parent notNil! !

"June 6, 2007 -> 1:52:49"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
hasSession ^<Session>

	^session notNil! !

"June 6, 2007 -> 1:52:50"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
hasWin32Handle ^<Boolean>

	^win32Handle notNil! !

"June 6, 2007 -> 1:52:51"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
initialInputFocus: v <Visual>

	initialInputFocus := v! !

"June 6, 2007 -> 1:52:53"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
max ^<Rect>

	^max! !

"June 6, 2007 -> 1:52:54"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
medium ^<Medium>

	^medium! !

"June 6, 2007 -> 1:52:55"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
menu ^<Menu>

	^menu! !

"June 6, 2007 -> 1:52:56"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
menu: m <Menu>

	menu isNil
		ifFalse: [ menu release ].
	menu := m.
	menu window: self.
	self hasWin32Handle
		ifTrue: [ self setNativeMenu ]! !

"June 6, 2007 -> 1:52:58"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
min ^<Rect>

	^min! !

"June 6, 2007 -> 1:52:59"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
mostRecentInputFocus: v  <Visual>

	mostRecentInputFocus := v! !

"June 6, 2007 -> 1:53:0"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
name: nm <Str>

	"By default, do nothing. Subclasses with a title bar can override this"! !

"June 6, 2007 -> 1:53:1"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
natural ^<Rect>

	^natural! !

"June 6, 2007 -> 1:53:2"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
noPalette

	palette := nil! !

"June 6, 2007 -> 1:53:4"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
optimizeIncrementalLayout ^<Boolean>
^false.
	^optimizeIncrementalLayout! !

"June 6, 2007 -> 1:53:5"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
optimizeIncrementalLayout: f <Boolean>

	(f ~= optimizeIncrementalLayout and: [ self hasWin32Handle ])
		ifTrue: [ self changing ].
	optimizeIncrementalLayout := f.! !

"June 6, 2007 -> 1:53:6"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
palette ^<Palette>

	^palette! !

"June 6, 2007 -> 1:53:7"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
palette: p <Palette>

	p == palette
		ifTrue: [ ^self ].
	self assert: [ palette isNil ].
	palette := p! !

"June 6, 2007 -> 1:53:9"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
parent ^<Window>

	^parent! !

"June 6, 2007 -> 1:53:10"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
parent: p <Window>
	"This message must be sent before the window handle is created"

	parent := p! !

"June 6, 2007 -> 1:53:11"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
refreshInterval ^<Float>

	^refreshInterval! !

"June 6, 2007 -> 1:53:12"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
refreshInterval: d <Float>
	"Wait no longer than this amount of time (in seconds) between
		paint operations, if possible"

	refreshInterval := d! !

"June 6, 2007 -> 1:53:13"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
session ^<Session>

	^session! !

"June 6, 2007 -> 1:53:15"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
setNativeMenu

	{{<user ExternalProxy SetMenu>
		wnd: self win32Handle
		menu: self menu win32Handle
	}} asBoolean
		ifFalse: [ Win32 handleError ]! !

"June 6, 2007 -> 1:53:16"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
toClose ^<[Window]>

	^toClose! !

"June 6, 2007 -> 1:53:17"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
toClose: blk <[Window]>

	toClose := blk! !

"June 6, 2007 -> 1:53:19"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
useDisplayBuffering ^<Boolean>

	^useDisplayBuffering! !

"June 6, 2007 -> 1:53:20"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
useDisplayBuffering: f <Boolean>

	useDisplayBuffering := f! !

"June 6, 2007 -> 1:53:21"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
visual ^<Visual>

	^visual! !

"June 6, 2007 -> 1:53:22"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
close
	"Close and destroy the window.  This causes release to be sent to the window and its visual"

	self session aboutToDestroyWindow: self.
	{{<user ExternalProxy DestroyWindow> arg: win32Handle}}.
! !

"June 6, 2007 -> 1:53:24"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
ignoreNextFocusSet: flag <Boolean>

	ignoreNextFocusSet := flag! !

"June 6, 2007 -> 1:53:25"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
invalidate

	self visual layoutStatus > Visual invalid
		ifTrue: [ self invalidate: self allocation enclosingRect	].! !

"June 6, 2007 -> 1:53:27"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
invalidate: r <Region>

	| rect <Rect> |

	self registerPaintTime.
	rect := r enclosingRect.
	(self scratchRECT)
		left: rect left asInteger;
		right: rect right asInteger;
		top: rect top asInteger;
		bottom: rect bottom asInteger.
	{{<user ExternalProxy InvalidateRect>
		hwnd: self win32Handle
		RECT: self scratchRECT
		erase: false asExternalData}}! !

"June 6, 2007 -> 1:53:28"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
makeActive
	"Make this the active window"

	{{<user ExternalProxy SetForegroundWindow> hwnd: self win32Handle }}.! !

"June 6, 2007 -> 1:53:29"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
release

	scratchRECT free.

	self session unregisterWindow: self.

	visual notNil
		ifTrue: [	visual detaching; release.
						visual := nil.	].

	win32Handle := nil.

	self hasMenu
		ifTrue: [ self menu release ].
	mostRecentInputFocus := nil.
	menu := nil.
	popUpMenu := nil.
	toClose := nil.
	controls := nil.
! !

"June 6, 2007 -> 1:53:30"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
requestClose

	self toClose value: self.! !

"June 6, 2007 -> 1:53:31"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
show
	"Make the window visible"

	{{<user ExternalProxy ShowWindow>
			window: self win32Handle
			nCmdShow: self nCmdShow}}.
	! !

"June 6, 2007 -> 1:53:33"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
showModal
	"Make the window visible as a modal window"

	self session addModalWindow: self.
	self show.
	! !

"June 6, 2007 -> 1:53:34"!

! (Delta mirrorFor: #Window) methodsFor: 'debugging' !
dumpOn: strm <CharOutputStream>

Transcript show: self class name, ' extent: '; print: self extent; show: ' hwnd: '; print: self win32Handle; cr.
	self visual dumpOn: strm indent: 1.! !

"June 6, 2007 -> 1:53:36"!

! (Delta mirrorFor: #Window) methodsFor: 'event handling' !
character: c <Character> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	^(self visual character: c focus: focus event: ev)
		or: [	c = Character tab
					onTrue: [ self handleTabEvent: ev ] ]! !

"June 6, 2007 -> 1:53:37"!

! (Delta mirrorFor: #Window) methodsFor: 'event handling' !
keyDown: key <Symbol> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	(self visual keyDown: key focus: focus event: ev)
		ifTrue: [ ^true ].
		
	(key = #TAB and: [ ev ctrlPressed ])
		ifTrue: [ self handleTabEvent: ev.	^true ].
	key = #F1 ifTrue: [ Profiler start.	^true ].
	key = #F2 ifTrue: [ Profiler stop.	^true ].
	^false	! !

"June 6, 2007 -> 1:53:38"!

! (Delta mirrorFor: #Window) methodsFor: 'event handling' !
keyUp: key <Symbol> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	^self visual keyUp: key focus: focus event: ev
! !

"June 6, 2007 -> 1:53:40"!

! (Delta mirrorFor: #Window) methodsFor: 'event handling' !
mouseEvent: type <Symbol> at: loc <Point> event: ev <UIEvent> ^<Boolean>

	^self visual layoutStatus = Visual valid
		and: [ 	| grabGotIt <Boolean> |
						grabGotIt := self session
												mouseEvent: type
												at: loc
												event: ev.
						grabGotIt or: [	(self visual renderingRegion inParentContainsPoint: loc)
												and: [	Sampler notNil
																ifTrue: [ Sampler in: self visual sampleEvent: type at: loc - self visual position event: ev ].
															self visual
																mouseEvent: type
																at: loc - self visual position
																event: ev	] ] ]
! !

"June 6, 2007 -> 1:53:41"!

! (Delta mirrorFor: #Window) methodsFor: 'initialization' !
initSession: sess <Session>
visual: vis <Visual>

	medium := sess medium.
	session := sess.
	visual := vis.

	(self visual)
		parent: self id: 1.

	self showTimes
		ifTrue: [ Transcript show: 'prefs: '; print: [ self computePreferences ] time; cr. ]
		ifFalse: [ self computePreferences ].

	scratchRECT := RECT new allocate.
	self optimizeIncrementalLayout: true.
	ignoreNextFocusSet := false.

	self refreshInterval: self defaultRefreshInterval.
	self paintPending: false.
	self useDisplayBuffering: true.

	self toClose: [ :w <Window> | w close ].
	self enabled: true.
	controls := IdentitySet[Win32Control] new.
	self haveErased: false.! !

"June 6, 2007 -> 1:53:42"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
activeMenu ^<Menu>
	"Returns the menu that is currently active, if there is one.  It may either be the top level menu,
	  or a popup menu over the window"

	^popUpMenu notNil
		ifTrue: [ popUpMenu ]
		ifFalse: [ menu ]! !

"June 6, 2007 -> 1:53:44"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
beforeQueuedMessage

	"%remove this and calls to it"! !

"June 6, 2007 -> 1:53:45"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
beforeSetFocus

	ignoreNextFocusSet
		ifTrue: [	"We requested the focus, and have already recorded it, so
							ignore this."
						ignoreNextFocusSet := false.	]
		ifFalse: [	self visual layoutValid
							ifTrue: [	"We didn't request this, so windows must be requesting it, so
												record it"
											self findInputFocus	]	].! !

"June 6, 2007 -> 1:53:46"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
beginPaint: hwnd <HWND>  paintStructure: ps <PAINTSTRUCT>  ^<HDC>

	^{{<user HDC BeginPaint> arg: hwnd arg: ps}}! !

"June 6, 2007 -> 1:53:47"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
buildWin32Handle
	"Subclasses must implement to create the appropriate type of window handle &
	  store it in win32Handle"

	self subclassResponsibility! !

"June 6, 2007 -> 1:53:49"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
callAsyncDefWndProcFor: hwnd <HWND>
msgCode: msgCode <ExternalData>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>
	"like callDefWndProcFor:msgCode:wParam:lParam:
			but is asynchronous"

	^{{<user ExternalProxy DefWindowProcA async>
			hwnd: hwnd
			value: msgCode
			value: wParam
			value: lParam
	  }}! !

"June 6, 2007 -> 1:53:50"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
callDefWndProcFor: hwnd <HWND>
msgCode: msgCode <ExternalData>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^{{<user ExternalProxy DefWindowProcA>
			hwnd: hwnd
			value: msgCode
			value: wParam
			value: lParam
	  }}! !

"June 6, 2007 -> 1:53:51"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
computePreferences

	natural := Point origin corner: self visual natural enclosingRect extent.
	min := Point origin corner: self visual min enclosingRect extent.
	max := Point origin corner: self visual max enclosingRect extent.! !

"June 6, 2007 -> 1:53:52"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
controls ^<Extensible[Win32Control]>

	^controls! !

"June 6, 2007 -> 1:53:53"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
defaultRefreshInterval ^<Float>

	^0.25! !

"June 6, 2007 -> 1:53:55"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
defaultWndProc ^<ExternalProxy>

	^self actualClass defaultWndProc! !

"June 6, 2007 -> 1:53:56"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
deferredPaintRegion ^<Rect>

	^deferredPaintRegion! !

"June 6, 2007 -> 1:53:57"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
deferredPaintRegion: r <Rect>

	deferredPaintRegion := r! !

"June 6, 2007 -> 1:53:58"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
desiredXPos ^<ExternalData>

	^desiredPosition isNil
		ifFalse: [ desiredPosition x asInteger ]
		ifTrue: [  Win32 CW_USEDEFAULT ]! !

"June 6, 2007 -> 1:54:0"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
desiredYPos ^<ExternalData>

	^desiredPosition isNil
		ifFalse: [ desiredPosition y asInteger ]
		ifTrue: [  Win32 CW_USEDEFAULT ]! !

"June 6, 2007 -> 1:54:1"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
display

	| subs <Cltn[Win32Control]> |
	self withCanvasDo:
			[ :can <Canvas> |
				| paintBlk <[^Object]> |	
				paintBlk := 
					[	self paintBackgroundOn: can.
						self displayVisualIfCanOn: can.
						can shallowFlush.  ].
				self showTimes
					ifTrue: [  Transcript show: 'paint: '; print: paintBlk time; cr. ]
					ifFalse: [ paintBlk value ].
				can hasSubwindowsToDisplay
					ifTrue: [ subs := can takeSubwindowsToDisplay ].
			].
	subs notNil
		ifTrue: [	subs do:
							[ :sub <Win32Control> |
								"%hack: the handle test should not be 
									necessary; something is screwed up"
								sub hasWin32Handle
									ifTrue: [	sub sendMessage: Win32 WM_PAINT
														wparam: 0 lparam: 0.
												].
							].
					 ]! !

"June 6, 2007 -> 1:54:3"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
displayVisualIfCanOn: canvas <Canvas>

	self session visualCriticalWouldBlock
		ifTrue: [ self recordDeferredPaint: canvas clippingRect ]
		ifFalse: [	self paintOccuring.
						self visual displayOn: canvas.	]! !

"June 6, 2007 -> 1:54:4"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
endPaint: hwnd <HWND>  paintStructure: ps <PAINTSTRUCT>

	^{{<user ExternalProxy EndPaint> arg: hwnd arg: ps}}! !

"June 6, 2007 -> 1:54:5"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
extent: e <Point>
	"Change the window's extent.  This will cause a relayout
		to happen later, which will record the extent."

	| pos <Point> adjusted <Rect> |
	adjusted := self fitToMedium: e.
	pos := self getPosition.
	{{<user ExternalProxy MoveWindow>
		hwnd: self win32Handle
		x: pos x
		y: pos y
		width: adjusted x
		height: adjusted y
		repaint: true asExternalData
	}} asBoolean 
		ifFalse: [ Win32 handleError ].! !

"June 6, 2007 -> 1:54:6"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
findInputFocus

	"find some non-native visual
	  within us to give the input focus to."

	"If there is already a focus, and it is in this window, then we are in a callback caused
	  by our own attempt to set the focus, so do nothing."
	(self session hasInputFocus and: [ self session inputFocus nativeWindow = self ])
		ifTrue: [ ^self ].

	"If we have a valid memory of what our input focus was last time, use it"
	self purgeMostRecentFocusIfNeeded.
	(mostRecentInputFocus notNil and: [ mostRecentInputFocus topWindow = self ])
		ifTrue: [ "Search to see if the most recent one is still a reachable, valid candidate"
					 "%todo: we could optimize this by adding another call to the heirarchy called
						verifyFocusCandidate which sends verifyFocusCandidate:self up the heirarchy,
						giving pacifiers etc. a chance to deny it the focus.  This would be MUCH faster
						than the following loop."
					"Also note that we use session inputFocus: rather than becomeFocus, because this
						 thing was previously the focus, so we don't want to do things like scroll it"
					 self visual focusCandidatesDo:
						[ :cand <Visual> |
							cand = mostRecentInputFocus
								ifTrue: [	self session inputFocus: cand.

												^self		"^^^^^^^^^^^^^"		] ]. ].

	"There is no valid previous focus to reuse, so just choose the first one"
	(self visual firstFocusCandidateIfAbsent: [ ^self ])
		becomeFocus.
! !

"June 6, 2007 -> 1:54:8"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
fitToMedium: clientExtent <Point>  ^<Point>
	"takes a client extent, and returns a window extent adjusted so that it will fit on the screen"

	| normal <Point> withoutCaption <Point> captionHeight <Int> adjClient <Point> |	
	normal := (self windowSizeForClientAreaSize: clientExtent) min: self medium extent.
	withoutCaption := (self windowSizeWithoutCaptionForClientAreaSize: clientExtent) min: self medium extent.
	captionHeight := normal y - withoutCaption y.
	^self windowSizeForClientAreaSize:
			 (clientExtent x min: self medium extent x)
		@ ((clientExtent y + captionHeight min: self medium extent y) - captionHeight).! !

"June 6, 2007 -> 1:54:9"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
getPosition ^<Point>

	{{<user ExternalProxy GetWindowRect>
		hwnd: self win32Handle
		rect: self scratchRECT
	}} asBoolean
		ifFalse: [ Win32 handleError ].
	^self scratchRECT left @ self scratchRECT top! !

"June 6, 2007 -> 1:54:11"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
globalFromLocalPosition: p <WinPOINT> ^<WinPOINT>

	| wp <WinPOINT> result <WinPOINT> |
	wp := WinPOINT new allocate.
	wp x: p x; y: p y.
	{{<user ExternalProxy ClientToScreen>
			handle: self win32Handle
			point: wp
	}} asBoolean
		ifFalse: [ Win32 handleError ].
	result := wp x @ wp y.
	wp free.
	^result! !

"June 6, 2007 -> 1:54:12"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
handleTabEvent: ev <UIEvent>

	ev shiftPressed
		ifTrue: [ self moveFocusBack ]
		ifFalse: [ self moveFocusForward ]! !

"June 6, 2007 -> 1:54:13"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
hasBackgroundPainter ^<Boolean>

	^backgroundPainter notNil! !

"June 6, 2007 -> 1:54:14"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
hasMenu ^<Boolean>
	"Returns the menu that is currently active, if there is one.  It may either be the top level menu,
	  or a popup menu over the window"

	^popUpMenu notNil or: [ menu notNil ]! !

"June 6, 2007 -> 1:54:15"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
haveErased ^<Boolean>

	^haveErased! !

"June 6, 2007 -> 1:54:17"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
haveErased: f <Boolean>

	haveErased := f! !

"June 6, 2007 -> 1:54:19"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
initWindowsMessageHandlers

	WindowsMessageHandlers
		at: Win32 WM_CLOSE	put:
				[ :w <Window> :msg  <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w closeMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_SETCURSOR	put:
				[ :w <Window> :msg  <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w setCursorMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_PAINT	put:
				[ :w <Window> :msg  <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w paintMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_ERASEBKGND	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w eraseBackgroundMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_CTLCOLORBTN	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w buttonColorMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_DRAWITEM	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w drawItemMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_KEYDOWN	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w keyDownMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_KEYUP	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w keyUpMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_CHAR	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w characterMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];

		"mouse events are handled by a common event routine"
		at: Win32 WM_LBUTTONDOWN put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #primaryButtonDown at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_LBUTTONUP	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #primaryButtonUp at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_LBUTTONDBLCLK	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #primaryButtonDoubleClick at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_MBUTTONDOWN	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #middleButtonDown at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_MBUTTONUP	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #middleButtonUp at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_RBUTTONDOWN put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #secondaryButtonDown at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_RBUTTONUP put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #secondaryButtonUp at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_RBUTTONDBLCLK put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #secondaryButtonDoubleClick at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_MOUSEMOVE put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #mouseMove at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];

		at: Win32 WM_MEASUREITEM	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w measureItemMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_SETFOCUS	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w setFocusMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_KILLFOCUS	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w killFocusMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_COMMAND	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w commandMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_GETMINMAXINFO	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w getMinMaxInfoMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_SIZE	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w sizeMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_NCDESTROY	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w ncDestroyMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_DESTROY	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w destroyMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_CAPTURECHANGED	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w captureChangedMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_INITMENUPOPUP	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w initMenuPopupMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_QUERYNEWPALETTE	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w queryPaletteMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_PALETTECHANGED	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w paletteChangedMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];

		"---------- Custom messages"
		at: Window LAYOUT	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w layoutMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];

		yourself! !

"June 6, 2007 -> 1:54:21"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
initialInputFocus ^ <Visual>

	^initialInputFocus! !

"June 6, 2007 -> 1:54:22"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
layout: extent <Point>

	| firstLayout <Boolean> |

	firstLayout := self visual layoutStatus = Visual invalid.
 	self showTimes
		ifTrue: [	Transcript show: 'layout: '; print: [ 
								self visual allocationInParent: (0@0 corner: extent).
						] time; cr. ]
		ifFalse: [	self visual allocationInParent: (0@0 corner: extent). ].

	"We have to do this now because we can't set the input focus until layout is
		complete, since the containing native window must be accessed, etc."
	firstLayout
		ifTrue: [	self palette notNil
							ifTrue: [ self recursiveRealizePaletteForeground: true updateColors: true. ].
						(self initialInputFocus notNil and: [ self initialInputFocus isFocusCandidate ])
							ifTrue: [		self initialInputFocus becomeFocus.
												self initialInputFocus: nil 	"Not needed anymore, prevent memory leak"	]
							ifFalse: [	self findInputFocus ]
					  ]! !

"June 6, 2007 -> 1:54:23"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
localFromGlobalPosition: p <WinPOINT> ^<WinPOINT>

	| wp <WinPOINT> result <WinPOINT> |
	wp := WinPOINT new allocate.
	wp x: p x; y: p y.
	{{<user ExternalProxy ScreenToClient>
			handle: self win32Handle
			point: wp
	}} asBoolean
		ifFalse: [ Win32 handleError ].
	result := wp x @ wp y.
	wp free.
	^result! !

"June 6, 2007 -> 1:54:25"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
menuCommandForItem: id <Int>

	(MenuItem itemFor: id)
		execute! !

"June 6, 2007 -> 1:54:26"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
moveFocusBack

	(self visual lastFocusCandidateBefore: self session inputFocus)
		becomeFocus! !

"June 6, 2007 -> 1:54:27"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
moveFocusForward

	(self visual nextFocusCandidateAfter: self session inputFocus)
		becomeFocus! !

"June 6, 2007 -> 1:54:28"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
nCmdShow ^<ExternalProxy>

	^{{primitiveWindowsNCmdShow}}! !

"June 6, 2007 -> 1:54:30"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
nextPaintTime ^<Float>

	^nextPaintTime! !

"June 6, 2007 -> 1:54:31"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
nextPaintTime: t <Float>

	nextPaintTime := t! !

"June 6, 2007 -> 1:54:32"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
paintBackgroundOn: can <Canvas>

	can withPainter: self backgroundPainter do:
		[ can displayFilledRectangle:
			(Point origin corner: self allocation enclosingRect extent) ].! !

"June 6, 2007 -> 1:54:34"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
paintOccuring

	self nextPaintTime: Time clockValue + self refreshInterval.
	self paintPending: false.
	self session paintOccuredFor: self.! !

"June 6, 2007 -> 1:54:35"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
parentHandle ^<ExternalData>

	^parent isNil
		ifFalse: [ parent win32Handle ]
		ifTrue: [ Win32 NULL ]! !

"June 6, 2007 -> 1:54:36"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
purgeMostRecentFocusIfNeeded

	"%kludge: This should be called occasionally (in user time) to avoid memory leaks caused by
	  a pointer to a zombie visual"
	"%todo: this isn't called yet.  Set up a scanner that sends this to all windows every ten seconds or
	   so."
	(mostRecentInputFocus notNil and: [ mostRecentInputFocus isAttached not ])
		ifTrue: [ mostRecentInputFocus := nil ]! !

"June 6, 2007 -> 1:54:37"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
recordDeferredPaint: region <Rect> 

	self deferredPaintRegion:
		(self deferredPaintRegion isNil
			ifTrue: [ region ]
			ifFalse: [ self deferredPaintRegion merge: region ]
		)! !

"June 6, 2007 -> 1:54:38"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
recordExtent

		self setExtent: self trueClientAreaExtent.! !

"June 6, 2007 -> 1:54:40"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
registerPaintTime

	self paintPending
		ifFalse: [	self paintPending: true.
						self nextPaintTime: Time clockValue + self refreshInterval.
						self session schedulePaintFor: self at: self nextPaintTime.	].! !

"June 6, 2007 -> 1:54:41"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
relayoutIfNeeded

	self relayoutIfNeededForExtent: self extent! !

"June 6, 2007 -> 1:54:42"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
relayoutIfNeededForExtent: e <Point>

	self visual needsRelayout
		ifTrue: [ self layout: (self visual max enclosingRect extent min: e) ].
	self invalidate.! !

"June 6, 2007 -> 1:54:44"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
scratchRECT ^<RECT>

	^scratchRECT! !

"June 6, 2007 -> 1:54:45"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
setCursor ^<ExternalData>

	^cursor isNil
		ifFalse: [	{{<user ExternalProxy SetCursor> handle: cursor win32Handle}}.
						1 ]
		ifTrue: [ 0 ]! !

"June 6, 2007 -> 1:54:46"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
setEnabled: flag <Boolean>

	enabled := flag.
	self hasWin32Handle
		ifTrue: [	{{<user ExternalProxy EnableWindow async>
								handle: self win32Handle
								state: enabled asExternalData}}.	].! !

"June 6, 2007 -> 1:54:47"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
setExtent: e <Point>

	extent := e! !

"June 6, 2007 -> 1:54:49"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
setName: nm <Str>

	self hasWin32Handle
		ifTrue: [	| title <CString> |
						title := CString for: nm.
						[	{{<user ExternalProxy SetWindowTextA>
											hwnd: self win32Handle
											title: title
							}} asBoolean
								ifFalse: [ Win32 handleError ].
						] ensure: [ title free ]
					 ]! !

"June 6, 2007 -> 1:54:51"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
shouldCallDefaultHandlerAsynchronouslyFor: msgCode <ExternalData>  ^<Boolean>

	^msgCode @= Win32 WM_SYSCOMMAND		"so that window moves let other sessions repaint"! !

"June 6, 2007 -> 1:54:52"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
showTimes ^<Boolean>
	"Report preference, layout, and painting times on the transcript"

	^false! !

"June 6, 2007 -> 1:54:53"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
trueClientAreaExtent ^<Point>

	^self trueClientAreaExtentFor: self win32Handle! !

"June 6, 2007 -> 1:54:54"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
trueClientAreaExtentFor: hwnd <ExternalData> ^<Point>

	| extent <Point> rect <RECT> |
	rect := RECT new allocate.
	{{<user RECT GetClientRect> arg: hwnd arg: rect}}.
	extent := (rect right - rect left) @ (rect bottom - rect top).
	rect free.
	^extent! !

"June 6, 2007 -> 1:54:55"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
win32Handle: h <HWND>

	win32Handle := h! !

"June 6, 2007 -> 1:54:56"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
win32Style ^<ExternalData>

	| s <ExternalData> |
	s := 0.
	self enabled
		ifFalse: [ s := s externalBitOr: Win32 WS_DISABLED ].
	^s
! !

"June 6, 2007 -> 1:54:58"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
windowSizeForClientAreaSize: extent <Point>  ^<Point>
	"returns an integral point that is the correct window size for a desired client area size"

	^self windowSizeForClientAreaSize: extent windowStyle: self win32Style! !

"June 6, 2007 -> 1:54:59"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
windowSizeForClientAreaSize: extent <Point> windowStyle: style <ExternalData>  ^<Point>
	"returns an integral point that is the correct window size for a desired client area size"

	| r <RECT> result <Point> |
	r := RECT new allocate.
	r top: 0; left: 0; right: extent x asInteger; bottom: extent y asInteger.
	{{<user ExternalProxy AdjustWindowRect>
				 rect: r style: style hasMenu: self hasMenu asExternalData}} asBoolean
		ifFalse: [ Win32 handleError ].
	result := (r right - r left) @ (r bottom - r top).
	r free.
	^result! !

"June 6, 2007 -> 1:55:1"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
windowSizeWithoutCaptionForClientAreaSize: extent <Point>  ^<Point>
	"returns an integral point that is the correct window size for a desired client area size"

	^self windowSizeForClientAreaSize: extent
			windowStyle: (self win32Style externalBitAnd: (Win32 WS_CAPTION asSmallInteger bitInvert))! !

"June 6, 2007 -> 1:55:2"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
windowsMessageHandlers ^<Dict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>

	"Don't need critical region since duplicate inits are no problem"
	WindowsMessageHandlers isNil
		ifTrue: [	WindowsMessageHandlers :=
							CustomDictionary[ExternalData,[Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData]]
									withCompareBlock: [ :k1 <ExternalData> :k2 <ExternalData> |    k1 @= k2 ]
									hashBlock: [ :k <ExternalData> |  k hash ].
						self initWindowsMessageHandlers.
						].
	^WindowsMessageHandlers! !

"June 6, 2007 -> 1:55:4"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
withBufferedCanvasDo: drawing <[Canvas,^X def]> ^<X>

	^self withDirectCanvasDo:
		[ :directCanvas <Canvas> |
			| invalid <Rect> oldpal <Win32Handle> |
			invalid := directCanvas clippingRect.

			self session
				withBufferCanvasFor: invalid
				do: [ :bufferCanvas <Canvas> :buffer <HBITMAP> |

						self palette isNil
							ifFalse: [ oldpal := bufferCanvas win32Palette: self palette win32Handle ].

						"draw on the buffer canvas"
						drawing value: bufferCanvas.
						bufferCanvas shallowFlush.

						"Now, copy the buffer bits onto the screen"
						directCanvas atOffset: invalid origin
							do: [ bufferCanvas atOffset: invalid origin 
								do: [	directCanvas
											bitBlt: bufferCanvas
											extent: invalid extent
											op: UI ropCopy.		].	].
						 oldpal notNil
								ifTrue: [ 	Palette debugging
													ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
												bufferCanvas win32Palette: oldpal ]. 
						].	
		]! !

"June 6, 2007 -> 1:55:5"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
withCanvasDo: drawing <[Canvas,^X def]> ^<X>

	^(self useDisplayBuffering and: [ Window bufferingPossible ])
		ifFalse: [	self withDirectCanvasDo: drawing ]
		ifTrue: [	self withBufferedCanvasDo: drawing ]! !

"June 6, 2007 -> 1:55:6"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
withDCDo: blk <[HDC]>
	"With the window's device context do the block (not for painting)"

	| hdc <HDC> |
	hdc := {{<user HDC GetDC> hwnd: self win32Handle}}.
	[ blk value: hdc ]
		ensure: [ hdc releaseDCFor: self win32Handle ]! !

"June 6, 2007 -> 1:55:8"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
withDirectCanvasDo: drawing <[Canvas,^X def]> ^<X>

	|	can <Canvas>
		ps <PAINTSTRUCT>
		paintBlk <[^Object]>
		result <X>
		oldpal <Win32Handle> |

	"use a critical region to paint, since background painting might reuse the
	  same device context in the UI thread"
	^self critical:
		[	ps := PAINTSTRUCT new allocateZeroed.
			can := self beginPaint: self win32Handle paintStructure: ps.
			can isNull
				ifTrue: [ Win32 handleError ].
			can	initialize;
				toRelease: [ :dc <HDC> | "End paint will release the context" ];
				initClippingRectBeforeTranslation: ps rcPaint asRectangle;
				window: self.
			self palette isNil
				ifFalse: [ oldpal := can win32Palette: self palette win32Handle ].

			Session debugInvalidation
				ifTrue: [	can withPainter: (Painter new paint: Paint red)
									do: [ can displayFilledRectangle: ps rcPaint asRectangle; flush. ].
								Platform errorStream show: self class name, ' rendering: '; print: ps rcPaint asRectangle; cr.	].

			result := drawing value: can.
			oldpal notNil
				ifTrue: [ 	Palette debugging
									ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
								can win32Palette: oldpal ]. 
			can release. 

			self endPaint: self win32Handle paintStructure: ps.
			ps free.
			result	]! !

"June 6, 2007 -> 1:55:9"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
wndProc ^<APICallback>

	^self session wndProc! !

"June 6, 2007 -> 1:55:11"!

! (Delta mirrorFor: #Window) methodsFor: 'private-testing' !
paintPending ^<Boolean>

	^paintPending! !

"June 6, 2007 -> 1:55:12"!

! (Delta mirrorFor: #Window) methodsFor: 'private-testing' !
paintPending: b <Boolean>

	paintPending := b! !

"June 6, 2007 -> 1:55:13"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
changing

	self session changing: self.
	self session recordPrefsFor: self.
	natural := min := max := nil.! !

"June 6, 2007 -> 1:55:15"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
checkLayout: oldPrefs <SeqCltn[Region]>

	| oldNat <Rect> alloc <Rect> nat <Rect> ext <Point> |
	oldNat := (oldPrefs at: 2) enclosingRect.
	self computePreferences.
	nat := self natural enclosingRect.
	alloc := self allocation enclosingRect.

	"We have to do the relayout eagerly, even before the size message
			comes back, because the caller assumes that layout is then done."

	((alloc contains: self min enclosingRect)
			and: [ self max enclosedRect contains: alloc ]
	)	ifFalse: [	"We definitely have to change our size"
							self relayoutIfNeededForExtent: nat extent.
							self extent: nat extent.
							^self	].

	(self optimizeIncrementalLayout
			or: [ nat = oldNat
			or: [	alloc contains: nat ] ])
		ifTrue: [	self relayoutIfNeededForExtent: self extent.
						^self ].

	ext := (nat width max: alloc width) @ (nat height max: alloc height).
	self relayoutIfNeededForExtent: ext.
	self extent: ext.! !

"June 6, 2007 -> 1:55:16"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
checkPaintTime: t <Float>
	"If we have reached our refresh time, paint"
	
"%todo: figure out how to remove the following %hack
		this should not be sent after the receiver is released)"	
visual isNil ifTrue: [ ^self ].

	(self hasWin32Handle and: [ self paintPending ])
		ifTrue: [ self nextPaintTime <= t
						ifTrue: [ self display ]
						ifFalse: [ self session needPaintAtTime: self nextPaintTime ]	 ]! !

"June 6, 2007 -> 1:55:18"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
oldcheckLayout: oldPrefs <SeqCltn[Region]>

	| oldNat <Rect> alloc <Rect> nat <Rect> |
	oldNat := (oldPrefs at: 2) enclosingRect.
	self computePreferences.
	nat := self natural enclosingRect.
	alloc := self allocation enclosingRect.

	"We have to do the relayout eagerly, even before the size message
			comes back, because the caller assumes that layout is then done."
	self relayoutIfNeeded.

	((alloc contains: self min enclosingRect)
			and: [ (self max enclosedRect contains: alloc)
			and: [ self optimizeIncrementalLayout
							or: [ nat = oldNat
							or: [	alloc contains: nat ] ] ] ]
	)	ifFalse: [	"We definitely have to change our size"
						self setExtent: nat extent.	].
! !

"June 6, 2007 -> 1:55:19"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
prefs ^<SeqCltn[Region]>

	^Array[Region] with: self min with: self natural with: self max! !

"June 6, 2007 -> 1:55:20"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
prefsStatus ^<Int>

	^Visual valid! !

"June 6, 2007 -> 1:55:21"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
prerecordPrefsIfNeeded

	"nothing to do"! !

"June 6, 2007 -> 1:55:22"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
processDeferredPainting

	self deferredPaintRegion notNil
		ifTrue: [	self invalidate: self deferredPaintRegion.
						self deferredPaintRegion: nil.		]! !

"June 6, 2007 -> 1:55:24"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
removeParentsFrom: leaves <Set[RelayoutTarget]>
alreadyChecked: checked <Set[RelayoutTarget]>

	"nothing to do"! !

"June 6, 2007 -> 1:55:25"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
hInstance ^<ExternalProxy>

	^self medium hInstance! !

"June 6, 2007 -> 1:55:26"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
message: msg <MSG>
	"This is invoked in the UI thread when a new message arrives in the queue."

	"Forward messages to the session, which will execute them in its thread"
	self session message: msg! !

"June 6, 2007 -> 1:55:27"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
message: msgCode <ExternalData>
for: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	"This is where all the win32 messages get converted to our semantics.  This
	  method executes in the window's session's thread for queued messages, and
	  either the session or UI thread for unqueued messages."

	"%note/%todo: each message below must call beforeQueuedMessage before processing
	     the message IFF the message is a queued (in session thread) message"

	^(self windowsMessageHandlers at: msgCode
		ifAbsent: [ ^self handleMiscMsg: msgCode hwnd: hwnd wParam: wParam lParam: lParam ]
     )	value: self
		value: msgCode
		value: hwnd
		value: wParam
		value: lParam! !

"June 6, 2007 -> 1:55:29"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
recursiveRealizePaletteForeground: fore <Boolean> updateColors: update <Boolean>

	self palette isNil
		ifFalse: [	self withDCDo:
							[ :hdc <HDC> |
								| oldpal <Win32Handle> |
								oldpal := Palette select: self palette win32Handle into: hdc background: fore not.
								self palette unrealize.
								self palette realizeFor: hdc.
								Palette debugging
									ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
								Palette select: oldpal win32Handle into: hdc background: fore not.
							 ].
						self invalidate.
						].
	self controls do:
		[ :c <Win32Control> |
			c recursiveRealizePaletteForeground: fore updateColors: update ].! !

"June 6, 2007 -> 1:55:30"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
registerControl: c <Win32Control>

	self controls include: c! !

"June 6, 2007 -> 1:55:31"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
releaseCapture

	{{<user ExternalProxy ReleaseCapture> noArgs}}! !

"June 6, 2007 -> 1:55:33"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
sendMessage: msg <ExternalData>
wparam: wp <ExternalData>
lparam: lp <ExternalData>
^<ExternalData>

	^{{<user ExternalProxy SendMessageA>
			handle: self win32Handle
			msg: msg
			wparam: wp
			lparam: lp}}! !

"June 6, 2007 -> 1:55:34"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
setCapture

	{{<user ExternalProxy SetCapture> hwnd: self win32Handle}}.
! !

"June 6, 2007 -> 1:55:35"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
setFocus

	 self win32Handle @= {{<user ExternalProxy GetFocus> call}}
		ifFalse: [  {{<user ExternalProxy SetFocus> hwnd: self win32Handle}} ]! !

"June 6, 2007 -> 1:55:36"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
unregisterControl: c <Win32Control>

	self controls removeEvery: c! !

"June 6, 2007 -> 1:55:37"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
win32Handle ^<HWND>

	win32Handle isNil
		ifTrue: [	self session creatingWindow: self do:
							[	self buildWin32Handle; recordExtent. ].  ].
	^win32Handle! !

"June 6, 2007 -> 1:55:39"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
characterMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self beforeQueuedMessage.
	^self session handleIfFocusMsg: msg for: self wParam: wParam lParam: lParam
! !

"June 6, 2007 -> 1:55:40"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
closeMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self requestClose.
	^0! !

"June 6, 2007 -> 1:55:41"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
commandMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	
	self beforeQueuedMessage.

	^lParam @~= Win32 NULL
		ifTrue: [	"Then this is a control window notification, which should be forwarded back to the
						  smalltalk control object"
						Win32Control notificationMsg: wParam asExternalProxy high for: (Win32Control controlIdFor: lParam).
						0 ]
		ifFalse: [ wParam asExternalProxy high = 0
							ifTrue: [	self menuCommandForItem: wParam low.
											0	]
							ifFalse: [ self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam ]	]! !

"June 6, 2007 -> 1:55:43"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
handleMiscMsg: msgCode <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	"This performs the default window system handling for a message"
	
	^(self shouldCallDefaultHandlerAsynchronouslyFor: msgCode)
		ifTrue: [	"Some messages should be handled asyncronously, so that for
							example, moving a window allows other sessions to refresh"
						self callAsyncDefWndProcFor: hwnd
							msgCode: msgCode
							wParam:  wParam
							lParam: lParam ]
		ifFalse: [	self callDefWndProcFor: hwnd
								msgCode: msgCode
								wParam:  wParam
								lParam: lParam	]! !

"June 6, 2007 -> 1:55:44"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
handleMouseEvent: type <Symbol>
at: loc <Point>
msg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	| ev <UIEvent> |
	self beforeQueuedMessage.

	"%todo: remove the dispatch block for all events; isn't needed anymore"
	ev := UIEvent
			forMsg: self session currentMsg
			dispatch:
				[ :e <UIEvent> :h <UIEventHandler> |
					h mouseEvent: type at: loc event: e ].
	self mouseEvent: type at: loc event: ev.

	"Mouse events are always passed through to the default wnd proc since their may be window system specific things
	  like bringing the window to the foreground that always have to happen. (I used to pass it through only when it
	  was a left button down msg, but this is cleaner)"
	^self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam! !

"June 6, 2007 -> 1:55:45"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
initMenuPopupMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self beforeQueuedMessage.
	self hasMenu 
		ifTrue: [ self activeMenu updateMenuWithHandle: wParam ].
	^0! !

"June 6, 2007 -> 1:55:47"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
keyDownMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self beforeQueuedMessage.
	^self session handleIfFocusMsg: msg for: self wParam: wParam lParam: lParam
! !

"June 6, 2007 -> 1:55:48"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
keyUpMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self beforeQueuedMessage.
	^self session handleIfFocusMsg: msg for: self wParam: wParam lParam: lParam
! !

"June 6, 2007 -> 1:55:49"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
layoutMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	| ext <Point> |
	ext := lParam low @ lParam high.
	(self visual layoutStatus < Visual valid
			or: [ self visual allocation enclosingRect extent ~= ext ])
		ifTrue: [ self layout: ext ].
	^0! !

"June 6, 2007 -> 1:55:51"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
paintMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self display.
	^0! !

"June 6, 2007 -> 1:55:52"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
setCursorMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^(cursor notNil
			and: [	| hitcode <Int> |
						hitcode := lParam asExternalProxy low.
						hitcode = 1 or: [ hitcode = 65534 ] "client area or disabled"  ])
		ifTrue: [ 	self setCursor.
						1 ]
		ifFalse: [ self callDefWndProcFor: hwnd
								msgCode: msg
								wParam: wParam
								lParam: lParam ]
! !

"June 6, 2007 -> 1:55:54"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
buttonColorMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^Win32Control buttonColorMsg: wParam asExternalProxy for: (Win32Control controlIdFor: lParam)! !

"June 6, 2007 -> 1:55:55"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
captureChangedMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self session lostCapture.
	
	^self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam! !

"June 6, 2007 -> 1:55:56"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
destroyMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^0! !

"June 6, 2007 -> 1:55:58"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
drawItemMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^Win32Control drawItemMsg: (DRAWITEMSTRUCT forProxy: lParam) for: wParam asSmallInteger! !

"June 6, 2007 -> 1:55:59"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
eraseBackgroundMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	| can <Canvas> |

	self haveErased
		ifTrue: [ ^1 ].
	self haveErased: true.

	"Don't paint background when a paint is pending to reduce flickering"
	self paintPending
		ifTrue: [ ^0 ].

	"Use a critical region because the window's thread might be drawing"
	self critical:
		[	can := HDC forProxy: wParam asExternalProxy.
			can initialize.
			self paintBackgroundOn: can. 	].
	^1! !

"June 6, 2007 -> 1:56:1"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
getMinMaxInfoMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	| info <MINMAXINFO> adjmin <Point> adjmax <Point> |
	info := MINMAXINFO forProxy: lParam asExternalProxy.
	adjmin := (self fitToMedium: self min extent) max: info ptMinTrackSize asPoint.
	adjmax := (self fitToMedium: self max extent) min: info ptMaxSize asPoint.
	info ptMaxSize x: adjmax x; y: adjmax y.
	info ptMaxTrackSize x: adjmax x; y: adjmax y.
	info ptMinTrackSize x: adjmin x; y: adjmin y.
	^0! !

"June 6, 2007 -> 1:56:3"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
killFocusMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	"This window is losing the input focus, which means that some non-native visual
	  within us probably has the focus, so we have to discard the focus."

	(self session hasInputFocus and: [ self session inputFocus nativeWindow = self ])
		ifTrue: [ self session noInputFocus ].

	^self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam! !

"June 6, 2007 -> 1:56:4"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
measureItemMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	| data <MEASUREITEMSTRUCT> |
	data := MEASUREITEMSTRUCT forProxy: lParam.
	^data CtlType @= Win32 ODT_MENU
		ifFalse: [ Win32Control measureItemMsg: data for: data CtlID asSmallInteger ]
		ifTrue: [ self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam ]! !

"June 6, 2007 -> 1:56:6"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
ncDestroyMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self release.
	^0! !

"June 6, 2007 -> 1:56:7"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
paletteChangedMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	wParam @= self win32Handle
		ifFalse: [ self recursiveRealizePaletteForeground: false updateColors: true.
						self palette isNil
							ifTrue: [ ^self callDefWndProcFor: hwnd
											msgCode: msg
											wParam: wParam
											lParam: lParam	].
					].
	^0! !

"June 6, 2007 -> 1:56:9"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
queryPaletteMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self recursiveRealizePaletteForeground: true updateColors: false.
	self palette isNil
		ifTrue: [ ^self callDefWndProcFor: hwnd
						msgCode: msg
						wParam: wParam
						lParam: lParam	].
	^0! !

"June 6, 2007 -> 1:56:10"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
setFocusMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	"This window is getting the input focus, which means that some non-native visual
	  within us will have to be chosen if possible."

	self beforeSetFocus.

	^self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam! !

"June 6, 2007 -> 1:56:12"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
sizeMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	"%todo: do we need to check the value of wParam first?"
	self critical:
		[ wParam @= Win32 SIZE_MINIMIZED
			ifFalse: [	| m <MSG> |
								self invalidate.
								m := MSG new allocate.
								[ m	hwnd: self win32Handle;
										message: Window LAYOUT;
										wParam: 0;
										lParam: lParam.
									self recordExtent.
									self session message: m.
								] ensure: [ m free ]
							]
		 ].
	^0! !

"June 6, 2007 -> 1:56:13"!

! (Delta mirrorFor: #Window) methodsFor: 'testing' !
isActive ^<Boolean>

	^self session hasActiveWindow and: [ self session activeWindow = self ]! !

"June 6, 2007 -> 1:56:32"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 1:56:34"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 1:56:34"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 1:56:34"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 1:56:34"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 1:56:34"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 1:56:34"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 1:56:34"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 1:56:34"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 1:56:34"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 1:56:34"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 1:56:34"!

(Delta mirrorFor: #SystemInitializer)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"June 6, 2007 -> 1:56:37"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
benchmarkDictionary
	| dict |
	dict := Dictionary new.

	"Benchmarks"
	dict at: #richards			put: [ :runner :repeat :inner | runner new runRichardsBenchmarks: 		repeat ].
	dict at: #smopstones	put: [ :runner :repeat :inner | runner new runSmopstoneBenchmarks:	repeat ].
	dict at: #slopstones		put: [ :runner :repeat :inner | runner new runSlopstoneBenchmarks:		repeat ].
	dict at: #stanford			put: [ :runner :repeat :inner | runner new runStanfordBenchmarks:		repeat ].
	dict at: #deltablue			put: [ :runner :repeat :inner | runner new runDeltaBlue:							repeat ].
	dict at: #benchmarks	put: [ :runner :repeat :inner | 
		runner new runStanfordBenchmarks:			repeat.
		runner new runRichardsBenchmarks:		repeat.
		runner new runDeltaBlue:								repeat.
		runner new runSlopstoneBenchmarks:		repeat.
		runner new runSmopstoneBenchmarks:	repeat.
	].
	
	dict at: #loop			put: [ :runner :repeat :inner | runner new runStanfordLoopBenchmarks: repeat ].
	
	"Individual Stanford Benchmarks"
	dict at: #bubblesort		put: [ :runner :repeat :inner | runner new runIndividualStanford: BubbleSortBenchmark repeat: repeat inner: inner].
	dict at: #bubblesort2	put: [ :runner :repeat :inner | runner new runIndividualStanford: BubbleSort2Benchmark repeat: repeat inner: inner].
	dict at: #intmm				put: [ :runner :repeat :inner | runner new runIndividualStanford: IntMMBenchmark repeat: repeat inner: inner].
	dict at: #intmm2			put: [ :runner :repeat :inner | runner new runIndividualStanford: IntMM2Benchmark repeat: repeat inner: inner].
	dict at: #mm					put: [ :runner :repeat :inner | runner new runIndividualStanford: MMBenchmark repeat: repeat inner: inner].
	dict at: #mm2				put: [ :runner :repeat :inner | runner new runIndividualStanford: MM2Benchmark repeat: repeat inner: inner].
	dict at: #perm				put: [ :runner :repeat :inner | runner new runIndividualStanford: PermBenchmark repeat: repeat inner: inner].
	dict at: #perm2				put: [ :runner :repeat :inner | runner new runIndividualStanford: Perm2Benchmark repeat: repeat inner: inner].
	dict at: #queens			put: [ :runner :repeat :inner | runner new runIndividualStanford: QueensBenchmark repeat: repeat inner: inner].
	dict at: #queens2			put: [ :runner :repeat :inner | runner new runIndividualStanford: Queens2Benchmark repeat: repeat inner: inner].
	dict at: #quicksort		put: [ :runner :repeat :inner | runner new runIndividualStanford: QuicksortBenchmark repeat: repeat inner: inner].
	dict at: #quicksort2		put: [ :runner :repeat :inner | runner new runIndividualStanford: Quicksort2Benchmark repeat: repeat inner: inner].
	dict at: #towers			put: [ :runner :repeat :inner | runner new runIndividualStanford: TowersBenchmark repeat: repeat inner: inner].
	dict at: #towers2			put: [ :runner :repeat :inner | runner new runIndividualStanford: Towers2Benchmark repeat: repeat inner: inner].
	dict at: #treesort			put: [ :runner :repeat :inner | runner new runIndividualStanford: TreeSortBenchmark repeat: repeat inner: inner].
	dict at: #treesort2		put: [ :runner :repeat :inner | runner new runIndividualStanford: TreeSort2Benchmark repeat: repeat inner: inner].
	dict at: #puzzle				put: [ :runner :repeat :inner | runner new runIndividualStanford: PuzzleBenchmark repeat: repeat inner: inner].
	dict at: #sieve				put: [ :runner :repeat :inner | runner new runIndividualStanford: SieveBenchmark repeat: repeat inner: inner].
	dict at: #sumto				put: [ :runner :repeat :inner | runner new runIndividualStanford: SumToBenchmark repeat: repeat inner: inner].
	dict at: #recurse			put: [ :runner :repeat :inner | runner new runIndividualStanford: RecurseBenchmark repeat: repeat inner: inner].
	dict at: #atallput			put: [ :runner :repeat :inner | runner new runIndividualStanford: AtAllPutBenchmark repeat: repeat inner: inner].
	dict at: #incrementall	put: [ :runner :repeat :inner | runner new runIndividualStanford: IncrementAllBenchmark repeat: repeat inner: inner].
	dict at: #nestedloop		put: [ :runner :repeat :inner | runner new runIndividualStanford: NestedLoopBenchmark repeat: repeat inner: inner].
	dict at: #tak					put: [ :runner :repeat :inner | runner new runIndividualStanford: TakBenchmark repeat: repeat inner: inner].
	dict at: #takl					put: [ :runner :repeat :inner | runner new runIndividualStanford: TaklBenchmark repeat: repeat inner: inner].
	dict at: #ordcol				put: [ :runner :repeat :inner | runner new runIndividualStanford: OrderedCollectionBenchmark repeat: repeat inner: inner].
	dict at: #dictionary		put: [ :runner :repeat :inner | runner new runIndividualStanford: DictionaryBenchmark repeat: repeat inner: inner].
	dict at: #dictatput		put: [ :runner :repeat :inner | runner new runIndividualStanford: DictionaryAtPutBenchmark repeat: repeat inner: inner].
	dict at: #livermore		put: [ :runner :repeat :inner | runner new runIndividualStanford: LivermoreBenchmark repeat: repeat inner: inner].

	"Individual Slopstone Benchmarks"
	dict at: #addint				put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 1 repeat: repeat inner: inner].
	dict at: #addfloat			put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 2 repeat: repeat inner: inner].
	dict at: #stringaccess	put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 3 repeat: repeat inner: inner].
	dict at: #createobject	put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 4 repeat: repeat inner: inner].
	dict at: #perform			put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 5 repeat: repeat inner: inner].
	dict at: #evaluate			put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 6 repeat: repeat inner: inner].
	
	"Individual Smopstone Benchmarks"
	dict at: #fractonacci	put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 1 repeat: repeat inner: inner].
	dict at: #primes   		put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 2 repeat: repeat inner: inner].
	dict at: #streams		put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 3 repeat: repeat inner: inner].
	dict at: #strings			put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 4 repeat: repeat inner: inner].
	dict at: #sets				put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 5 repeat: repeat inner: inner].
	dict at: #sorting 			put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 6 repeat: repeat inner: inner].
	dict at: #sorcerer		put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 7 repeat: repeat inner: inner].

	"Test Suites"
	dict at: #testsuite		put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new testBasicClasses] ].

	"Individual Tests"
	dict at: #string				put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: String title: 'String' ] ].
	dict at: #number			put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: Number title: 'Number' ] ].
	dict at: #sortedcol		put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: SortedCollection title: 'SortedCollection' ] ].
	dict at: #readstream	put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: SeqCltnReadStream title: 'SeqCltnReadStream' ] ].
	dict at: #writestream	put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: SeqCltnReadWriteStream title: 'SeqCltnReadWriteStream' ] ].
	dict at: #bag				put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: Bag title: 'Bag' ] ].
	dict at: #keyedset		put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: KeyedSet title: 'KeyedSet' ] ].
	dict at: #set					put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: Set title: 'Set' ] ].
	dict at: #orderedcol	put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: OrderedCollection title: 'OrderedCollection' ] ].
	dict at: #character		put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: Character title: 'Character' ] ].
	dict at: #readwrite		put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: ExternalReadWriteStream title: 'ExternalReadWriteStream' ] ].

	"Errors"
	dict at: #break				put: [ :runner :repeat :inner | {{primitiveBreak}} ].

	"Bootstrap"
	dict at: #boot				put: [ :runner :repeat :inner | Dumper fileOut ].

	"Test Suite for the VM people"
	dict at: #vmtest				put: [ :runner :repeat :inner | VMSuite run ].
	dict at: #vminterpreted	put: [ :runner :repeat :inner | VMSuite runInterpreted ].
	dict at: #vmcompiled	put: [ :runner :repeat :inner | VMSuite runCompiled ].
	dict at: #vmvanilla			put: [ :runner :repeat :inner | VMSuite runVanilla ].
	dict at: #dump					put: [  :runner :repeat :inner | InliningDatabase dump ].
	dict at: #compileAll		put: [  :runner :repeat :inner | InliningDatabase compileAll ].
	dict at: #gc						put: [  :runner :repeat :inner | VM collectGarbage ].
	dict at: #norecomp		put: [  :runner :repeat :inner | VM booleanAt: #UseRecompilation put: false ].

	"Misc."
	dict at: #zone					put: [ :runner :repeat :inner | {{primitivePrintZone}} ].
	dict at: #decode				put: [ :runner :repeat :inner | {{primitiveDecodeAllMethods}} ].
	dict at: #mandelbrot		put: [ :runner :repeat :inner | repeat timesRepeat: [ Mandelbrot new computeImageOnly ] ].
	dict at: #mandelprof		put: [ :runner :repeat :inner | Profiler do: [ Mandelbrot new computeImageOnly ] ].
	dict at: #mandeltest		put: [ :runner :repeat :inner | Mandelbrot new computeImageOnly ].
	dict at: #typecheck		put: [ :runner :repeat :inner | runner new runTypecheckerBenchmarks: repeat ].
	dict at: #genprims			put: [ :runner :repeat :inner | DeltaPrimitiveGenerator doit].

	^dict! !

"June 6, 2007 -> 1:56:38"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
findRunner: test ifAbsent: blk
	test = 'timer'
		ifTrue: [^BenchmarkRunner].
	test = 'nmethod'
		ifTrue: [^BenchmarkNMethodInvocationRunner].
	test = 'method'
		ifTrue: [^BenchmarkMethodInvocationRunner].
	test = 'prims'
		ifTrue: [^BenchmarkPrimitiveRunner].
	test = 'lookup'
		ifTrue: [^BenchmarkLookupCacheRunner].
	test = 'blocks'
		ifTrue: [^BenchmarkBlockRunner].
	blk value.! !

"June 6, 2007 -> 1:56:39"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
lower: str
	| result |
	result := String new: str size.
	1 to: str size do: [ :index |
		result at: index put: (str at: index) asLowercase
	].
	^result! !

"June 6, 2007 -> 1:56:41"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
parseInteger: str ifFail: blk
	| result |
	result := 0.
	str do: [ :c | | val |
		val := c asciiValue.
		(val >= $0 asciiValue and: [ val <= $9 asciiValue ])  ifTrue: [
			result := (result * 10) + ( val - $0 asciiValue)
		] ifFalse: [
			^blk value
		]
	].
	^result! !

"June 6, 2007 -> 1:56:42"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
processCommandLineArguments ^<Boolean>
	"process command line args, and return boolean indicating whether the 
		default program should be run (which is normally the GUI)"

	| args <ReadStream[Str]>  runDefault <Boolean> |
	args := Platform commandLineTokens.
	args next.  "Skip command"
	runDefault := true.
	
	[ args atEnd ] whileFalse: [  | arg <Str> |
		arg := args next.
		
		arg = '-benchmark'
			ifTrue: [	self runBenchmarks: args.
						runDefault := false ].
		arg = '-script'
			ifTrue: [	args atEnd
							ifTrue: [ Transcript show: 'Command line argument error: -script option must be followed by a filename';cr. ]
							ifFalse: [ self runScript: args next ].
						runDefault := false ].		].
	^runDefault
! !

"June 6, 2007 -> 1:56:43"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
runBenchmarks: args <InputStream[Str]>

	| dict runner repeat inner print |
	dict := self benchmarkDictionary.
	runner	:= BenchmarkRunner.
	repeat	:= 1.
	inner	:= 1.
	print		:= false.

	[ args atEnd ] whileFalse: [	| arg <Str> cmd options |
		arg := args next.
		options	:= false.
		arg = 'profile'	ifTrue: [ runner := BenchMarkProfileRunner.		options := true ].
		arg = 'prims'		ifTrue: [ runner := BenchmarkPrimTraceRunner.	options := true ].
		arg = 'inner'		ifTrue: [ inner := repeat. repeat := 1.						options := true ].
		arg = 'print'		ifTrue: [ print := true.												options := true ].
		options ifFalse: [
			repeat := self parseInteger: arg ifFail: [
				Transcript show: 'Processing '; show: arg; show: ' ('; show: repeat printString; show: ' times)'; cr.
				cmd := dict at: arg ifAbsent: [nil].
				cmd isNil ifTrue:  [ Transcript show: 'Command not found'; cr ]
							   ifFalse: [ cmd value: runner value: repeat value: inner ].
				repeat
			]
		]
	].

	print ifTrue: [
		{{primitivePrintMemory}}.
	]! !

"June 6, 2007 -> 1:56:44"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
runDefaultProgram
	"This starts the 'default' program, which is the code that should run when no
	  command line options specifies something else"
	  
	[ UI start ] fork! !

"June 6, 2007 -> 1:56:45"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
runScript: filename <Str>

	[	| file <FilePath> |
		file := FilePath for: filename.
		file exists
			ifFalse: [	Transcript show: 'Error: script file ''', filename, ''' not found.'; cr.
							^self	].
		file charInputStream fileIn
	] fork! !

"June 6, 2007 -> 1:56:46"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'library class initialization' !
run
	"This is the entry point for normal execution."
	
	| commands <OrdCltn[Str]> |

	self runBaseClassInitializers.
	self runNonCriticalClassInitializers.
	(self processCommandLineArguments)
		ifTrue: [ self runDefaultProgram ].
! !

"June 6, 2007 -> 1:56:47"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'library class initialization' !
runBaseClassInitializers
	"Initialize critical base library classes (run in the process scheduler)"

	Platform initialize.
	Transcript := TempTranscript new.
	SmallInteger initialize.
	Character initialize.
	CallBack initialize.
	IdleProcess initialize.
	InliningDatabase initialize.
! !

"June 6, 2007 -> 1:56:48"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'library class initialization' !
runNonCriticalClassInitializers
	"This is the root class initializer that is called when the system starts up.
		Any class initializers that must be called should be called from
		this method."

	Session initialize.

	Rectangle initialize.
	Paint initialize.
	Painter initialize.
	HPEN initialize.
	GeometricHPEN initialize.
	HBRUSH initialize.
	InfiniteRegion initialize.

	Smalltalk initialize.

	CodeEditor initialize.
	Workspace initialize.

	HTMLElement initialize.
	HTMLParser initialize.! !

"June 6, 2007 -> 1:59:45"!

"System saved" !
"June 6, 2007 -> 2:11:44"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'command line' !
commandLine ^<Str>
    | p size result |
    p := {{<kernel ExternalProxy GetCommandLineA>getCommandLine}}.
    size := 0.
    [(p byteAt: size) == 0] whileFalse: [ size := size + 1 ].
    result := String new: size.
    1 to: size do: [:index |
       result at: index put: (Character value: (p byteAt: index - 1))
    ].
    ^result! !

"June 6, 2007 -> 2:12:11"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'command line' !
commandLine ^<Str>
    | p size result |
    p := {{<kernel ExternalProxy GetCommandLineA>getCommandLine}}.
    size := 0.
    [(p byteAt: size) == 0] whileFalse: [ size := size + 1 ].
    result := String new: size.
    1 to: size do: [:index |
       result at: index put: (Character value: (p byteAt: index - 1))
    ].
    ^result! !

"June 6, 2007 -> 2:13:2"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'command line' !
commandLineTokens ^<InputStream[Str]>
    "a stream of the input line tokens.  Tokens are sequences separated by whitespace; whitespace can be 
        included in a token by double quoting the arg.  (quotes can be imbedded by doubling, as with Smalltalk strings;
        the returned token has delimiting quotes removed and internal quotes undoubled. "

    | cstrm <CharInputStream> |
    cstrm := self commandLine readStream.
    self skipSpacesIn: cstrm.
    ^CustomInputStream[Str] new
            nextBlock: [    self parseArgFrom: cstrm ];
            atEndBlock: [ cstrm atEnd ].! !

"June 6, 2007 -> 2:24:34"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'command line' !
commandLine ^<Str>
   ^self getCommandLine! !

"June 6, 2007 -> 2:40:18"!

"System saved" !
"June 6, 2007 -> 2:52:16"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'private' !
skipSpacesIn: strm <CharInputStream>

    [ strm atEnd not and: [ strm peekFor: Character space] ] whileTrue.
! !

"June 6, 2007 -> 2:54:14"!

"System saved" !
"June 6, 2007 -> 18:22:24"!

Delta define: #Bootstrap as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 18:22:25"!

Delta define: #Bootstrap as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 18:22:25"!

Delta define: #Bootstrap as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 18:22:25"!

Delta define: #Bootstrap as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 18:22:25"!

Delta define: #Bootstrap as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 18:22:25"!

Delta define: #Bootstrap as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 18:22:25"!

Delta define: #Bootstrap as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 18:22:25"!

Delta define: #Bootstrap as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 18:22:25"!

Delta define: #Bootstrap as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 18:22:25"!

Delta define: #Bootstrap as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 18:22:25"!

Delta define: #Bootstrap as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 18:22:26"!

(Delta mirrorFor: #Bootstrap)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.
'!


"June 6, 2007 -> 18:22:27"!

! (Delta mirrorFor: #Bootstrap) classSide methodsFor: 'notification' !
checkNotification
	[ 
		{{primitiveNotificationQueueGetIfFail: [ :err |^self]}}  notify.
	] repeat.! !

"June 6, 2007 -> 18:22:28"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'dave''s benchmarks' !
dictAtBenchmark
"	Foo isNil
		ifTrue: [ Dictionary performanceTestPrep. Foo := 1 ]."
	2 timesRepeat: [ Dictionary  atPerformanceTest ].
Transcript show: '-------------------------------------- starting Dict>>at: benchmark'; cr.
	Transcript print:
		[ Dictionary atPerformanceTest ] time; cr.! !

"June 6, 2007 -> 18:22:29"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'dave''s benchmarks' !
dictAtPutBenchmark
"	Foo isNil
		ifTrue: [ Dictionary performanceTestPrep. Foo := 1 ]."
	2 timesRepeat: [ Dictionary  atPutPerformanceTest ].
Transcript show: '-------------------------------------- starting Dict>>at:put: benchmark'; cr.
	Transcript print:
		[ Dictionary atPutPerformanceTest ] time; cr.! !

"June 6, 2007 -> 18:22:30"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'dave''s benchmarks' !
dictBenchmark
"	Foo isNil
		ifTrue: [ Dictionary performanceTestPrep. Foo := 1 ]."
	2 timesRepeat: [ Dictionary  performanceTest ].
Transcript show: '-------------------------------------- starting benchmark'; cr.
	Transcript print:
		[ Dictionary performanceTest ] time; cr.! !

"June 6, 2007 -> 18:22:31"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'dave''s benchmarks' !
hashingBenchmarks

	self dictAtBenchmark; dictAtPutBenchmark; setIncludeBenchmark; setIncludesBenchmark! !

"June 6, 2007 -> 18:22:32"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'dave''s benchmarks' !
setIncludeBenchmark

	2 timesRepeat: [ Set  includePerformanceTest ].
Transcript show: '-------------------------------------- starting Set>>include: benchmark'; cr.
	Transcript print:
		[ Set includePerformanceTest ] time; cr.! !

"June 6, 2007 -> 18:22:33"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'dave''s benchmarks' !
setIncludesBenchmark

	2 timesRepeat: [ Set  includesPerformanceTest ].
Transcript show: '-------------------------------------- starting Set>>includes: benchmark'; cr.
	Transcript print:
		[ Set includesPerformanceTest ] time; cr.! !

"June 6, 2007 -> 18:22:34"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'library testing' !
deterministicallyTestSystem
	"As many tests as we can do deterministically (i.e. without requiring UI interaction, for now)."

	self testLibrary.
	Smalltalk recompileAllMethods.
	Transcript show: 'Testing completed.'; cr.! !

"June 6, 2007 -> 18:22:35"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'library testing' !
testBlueBookCPUBoundClasses

	Number test.
    SeqCltnReadWriteStream test.
     SeqCltnReadStream  test.
    Bag test.
    KeyedSet  test.
   Set  test.
	 Dictionary test.
   SortedCollection test.
     OrderedCollection  test.
   String  test.
   Character  test.
	 Interval test.
	 Behavior test.
	 Random test.
	 BlockWithoutArguments  test.
	 Queue test.

	
! !

"June 6, 2007 -> 18:22:36"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'library testing' !
testBlueBookClasses

    self test: Number title: 'Number'.
    self test: SmallInteger title: 'SmallInteger'.
    self test: SeqCltnReadWriteStream title: 'SeqCltnReadWriteStream'.
    self test: SeqCltnReadStream   title: 'SeqCltnReadStream'.
    self test: Bag title: 'Bag'.
    self test: KeyedSet title: 'KeyedSet'.
    self test: Set title: 'Set'.
	self test: Dictionary title: 'Dictionary'.
    self test: SortedCollection title: 'SortedCollection'.
    self test: OrderedCollection title: 'OrderedCollection'.
    self test: String title: 'String'.
    self test: Character title: 'Character'.
	self test: Interval title: 'Interval'.
	self test: Behavior title: 'Behavior'.
	self test: Random title: 'Random'.
	self test: BlockWithoutArguments title: 'BlockWithoutArguments'.

    self test: ExternalReadWriteStream title: 'ExternalReadWriteStream'.
    self test: SharedQueue title: 'SharedQueue'.
	
! !

"June 6, 2007 -> 18:22:37"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'library testing' !
testLibrary
	
	| t <Int> |
	t := [	self testBlueBookClasses.
    		self test: FilePath title: 'FilePath'.
			self test: CharacterReadConverter title: 'CharacterReadConverter'.	] time.
	Transcript show: 'Time = '; print: t; cr.
! !

"June 6, 2007 -> 18:22:38"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'new menus' !
benchmarkMenu ^<Menu>

	^Menu new
		add: (Menu new name: '&Benchmarks';
					add: (MenuAction new
							name: 'Livermore &Benchmark';
							action: [ self livermoreBenchmark ] );
					add: (MenuAction new
							name: 'Livermore Benchmark (w/FloatValues)';
							action: [ self livermoreFloatValueBenchmark ] );
					add: (MenuAction new
							name: 'CPU benchmark';
							action: [ self cpuBenchmark ] );
					add: (MenuAction new
							name: 'Stream write';
							action: [ self streamWrite ] );
					add: (MenuAction new
							name: 'Stream read';
							action: [ self streamRead ] );
					add: (MenuAction new
							name: 'Stream lines write';
							action: [ self streamWrite2 ] );
					add: (MenuAction new
							name: 'Stream lines read';
							action: [ self streamRead2 ] );
					add: (MenuAction new
							name: '&Hashing Benchmarks';
							action: [ self hashingBenchmarks ] );
					add: (MenuAction new
							name: 'OrderedCollection Benchmark';
							action: [ self ocBenchmark ] );
					add: (MenuAction new
							name: 'Array Benchmark';
							action: [ self arrayBenchmark ] );
					add: (MenuAction new
							name: 'Random Benchmark';
							action: [ Transcript print: [ 10 timesRepeat: [ Random test ] ] time; cr. ] )
					)! !

"June 6, 2007 -> 18:22:39"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'new menus' !
compilationMenu ^<Menu>

	^Menu new name: '&Compiler';
					add: (MenuAction new
							name: '&Compiler Enabled';
							checked: [ VM recompilation ];
							action: [ VM recompilation: VM recompilation not ]	);
					add: (MenuAction new
							name: '&Print Compilations';
							checked: [ VM printCompilation ];
							action: [ VM printCompilation: VM printCompilation not ]	);
					add: (MenuAction new
							name: 'Print Compiled Code Space Usage (Zone)';
							action: [	VM printZone ] );
					addSeparator;
					add: (MenuAction new
							name: 'Use &Inlining Database as needed';
							checked: [ VM useInliningDatabase ];
							action: [	InliningDatabase checkLookupTable.
											VM useInliningDatabase: VM useInliningDatabase not.
										  ]	);
					add: (MenuAction new
							name: 'Compile Whole Inlining Database';
							action: [ InliningDatabase compileAll ]	);
					add: (MenuAction new
							name: 'Create &Inlining Database';
							action: [ InliningDatabase dump ]	);
					addSeparator;
					add: (MenuAction new
							name: '&Flush Inline Caches';
							action: [ {{primitiveClearInlineCaches}} ]	)! !

"June 6, 2007 -> 18:22:40"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'new menus' !
developmentMenu ^<Menu>

	^Menu new
		add: (Menu new name: '&System';
					add: self compilationMenu;
					add: self gcMenu;
					add: self uiMenu;
					add: self typeSystemMenu;
					add: self profilingMenu)! !

"June 6, 2007 -> 18:22:41"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'new menus' !
gcMenu ^<Menu>

	^Menu new name: '&Object Memory';
					add: (MenuAction new
							name: '&Collect Garbage';
							action: [ VM collectGarbage ]	);
					add: (MenuAction new
							name: '&Scavenge';
							action: [ VM scavengeGarbage ]	);
					addSeparator;
					add: (MenuAction new
							name: 'Print Scavenges';
							checked: [ VM printScavenge ];
							action: [ VM printScavenge: VM printScavenge not ]	);
					add: (MenuAction new
							name: 'Print Allocated Object &Histogram';
							action: [ {{primitivePrintObjectHistogram}} ]	)! !

"June 6, 2007 -> 18:22:42"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'new menus' !
profilingMenu ^<Menu>

	^Menu new name: '&Profiling and Debugging';
					add: (MenuAction new
							name: '&Profiling';
							checked: [ Profiler profiling ];
							action: [ Profiler profiling: Profiler profiling not ]	);
					add: (MenuAction new
							name: '&Print Profile';
							action: [ Profiler profiling: false.
										  Profiler printStats. ]	);
					add: (MenuAction new
							name: '&Reset Profile Stats';
							action: [ Profiler resetStats. ]	);
					addSeparator;
					add: (MenuAction new
							name: '&Time Menu Actions';
							checked: [ MenuAction timeActions ];
							action: [ MenuAction timeActions: MenuAction timeActions not ]	);
					addSeparator;
					add: (MenuAction new
							name: '&Temp Debug';
							checked: [ TempDebug == true ];
							action: [	TempDebug isNil ifTrue: [ TempDebug := false ].
											TempDebug := TempDebug not.	]	)
				! !

"June 6, 2007 -> 18:22:43"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'new menus' !
registerTmpMenus

	Launcher registerMenu: self developmentMenu for: #Development.! !

"June 6, 2007 -> 18:22:44"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'new menus' !
testMenu ^<Menu>

	^Menu new
		add: (Menu new name: '&Testing';
					add: (MenuAction new
							name: 'Text Editor';
							action: [ self textEditor ] );
					add: (MenuAction new
							name: 'Test Library';
							action: [ self testLibrary ] );
					add: (MenuAction new
							name: 'Test Dialog';
							action: [ self testDialog ] );
					add: (MenuAction new
							name: 'Mandelbrot';
							action: [ self mandelbrot ] );
					add: (MenuAction new
							name: 'Transcript test';
							action: [	[	1 to: 100 do: [ :i | Transcript print: i; cr. ]. ] fork
										] );
					add: (MenuAction new
							name: 'Transcript test 2';
							action: [	[	1 to: 100 do: [ :i | Transcript print: i; cr; flush. ]. ] fork
										] );
					add: (MenuAction new
							name: 'Transcript test 3';
							action: [	[	1 to: 100 do: [ :i | i = 50 ifTrue: [ TempDebug := true ]. Transcript print: i; cr; flush. ]. ] fork.
											[	100 to: 1 by: -1 do: [ :i | Transcript print: i; cr; flush. ]. ] fork.
										] )
					)! !

"June 6, 2007 -> 18:22:45"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'new menus' !
typeSystemMenu ^<Menu>

	^Menu new name: '&Type System';
					add: (MenuAction new
							name: '&Report Type Loading';
							checked: [ ReportTypeLoading == true ];
							action: [ ReportTypeLoading := ReportTypeLoading not ]	);
					add: (MenuAction new
							name: 'Zap all Type data';
							action: [ Type zapAllTypes]	)! !

"June 6, 2007 -> 18:22:47"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'new menus' !
uiMenu ^<Menu>

	^Menu new name: '&UI';
					add: (MenuAction new
							name: 'Double Buffering';
							checked: [ Window bufferingPossible ];
							action: [	Window bufferingPossible: Window bufferingPossible not]	);
					add: (MenuAction new
							name: '&Smooth Scrolling';
							checked: [ ScrollState smoothScroll ];
							action: [	ScrollState smoothScroll: ScrollState smoothScroll not]	);
					addSeparator;
					add: (MenuAction new
							name: 'Debug UI &Invalidation';
							checked: [ Session debugInvalidation ];
							action: [	Session debugInvalidation: Session debugInvalidation not	]	);
					add: (MenuAction new
							name: '&Debug Events';
							checked: [ Session debugEvents ];
							action: [ Session debugEvents: Session debugEvents not ]	);
					add: (MenuAction new
							name: '&Debug Incremental Layout';
							checked: [ Session debugIncrementalLayout ];
							action: [	Session debugIncrementalLayout: Session debugIncrementalLayout not]	)! !

"June 6, 2007 -> 18:22:48"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'private' !
cpuBenchmark

	Transcript print: [ 3 timesRepeat: [ self testBlueBookCPUBoundClasses ] ] time; cr.! !

"June 6, 2007 -> 18:22:49"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'private' !
newListBox
	| lb |
	lb := ListBox forMultipleSelections" forSingleSelection".
													lb xStretchy: true; variableItemHeight: false.
													lb stringList: #(hello goodbye atest andanotherstring 'Hi Urs' lsdfsdfsdfsdfsd sdkfljsdlkfjsdlkjf lksdfjlksdjfklsdjfklsdf lksdfj kksdlf lksdfj sdflj lsdjflksjdkfjlk ksldfjlksdfjklsjdf sdkfjl sdklfjkljlksdj lksdjfl ksdjf sdfsdfsf sdfsdfsdfsf sdfsdfsdfsf) .
													lb onSelChange: [ :lb | Transcript print: lb selections; cr. ].
													lb onDoubleClick: [ :lb | Transcript show: 'DOUBLE!!'; print: lb selections; cr. ].
													lb simpleMultiple: false.
													lb resetNaturalHeight: 10.
													lb selections: (Set withAll: #(2)).
	^lb withBorder: (Border standard3DRaised: false)
! !

"June 6, 2007 -> 18:22:50"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'private' !
newWidget

	^self newListBox! !

"June 6, 2007 -> 18:22:51"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'private' !
streamRead

	| p s c |
	p := FilePath for: 'foo.dat'.
	Transcript print: [
	s := p charInputStream.
	c := 0.
	[ s atEnd ]
		whileFalse: [ self assert: [ s next == $a ].
								c := c + 1. ].
	self assert: [ c = 1000000 ].
	s close. ] time; cr.! !

"June 6, 2007 -> 18:22:52"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'private' !
streamRead2

	| p s c v |
	p := FilePath for: 'foo.dat'.
	Transcript print: [
	s := p charInputStream.
	c := 0.
	[ s atEnd ]
		whileFalse: [ c = 10000 ifTrue: [ self halt. ].	v := s upTo: Character cr.
								self assert: [  v size = 98 ].
								c := c + 1. ].
	self assert: [ c = 10000 ].
	s close. ] time; cr.! !

"June 6, 2007 -> 18:22:53"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'private' !
streamWrite

	| p s |
	p := FilePath for: 'foo.dat'.
	Transcript print: [
	s := p charOutputStream.
	1000000 timesRepeat:
		[ s put: $a ].
	s close. ] time; cr.! !

"June 6, 2007 -> 18:22:54"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'private' !
streamWrite2

	| p s |
	p := FilePath for: 'foo.dat'.
	Transcript print: [
	s := p charOutputStream.
	10000 timesRepeat:
		[	98 timesRepeat: [ s put: $a ].
			s cr. ].
	s close. ] time; cr.! !

"June 6, 2007 -> 18:22:55"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'startup' !
arrayBenchmark

	1 timesRepeat: [ Array performanceTest ].
Transcript show: '-------------------------------------- starting benchmark'; cr.
	Transcript print:
		[ Array performanceTest ] time; cr.! !

"June 6, 2007 -> 18:22:56"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'startup' !
livermoreBenchmark

	|	n		
		size
		x		
		y		
		q 		
		r 		
		z 		
		t 		
		|

	n := 1001.
	size := n + 12.
	x := Array new: size.
	y := (Array new: size) atAllPut: 1.1234.
	z := (Array new: size) atAllPut: 1.1234.
	q := r := t := 1.234.

	Transcript show: 'Livermore seconds equivalent:', (((Time millisecondsToRun: 
		[	1000 timesRepeat:
				[	1 to: n do:
						[ :k  |
							x at: k put: 
								(q + ( (y at: k) * (r*(z at: k + 10)) + (t*(z at: k + 11)) ))
						]
				]
		]) * 10) asFloat / 1000.0) printString; cr.! !

"June 6, 2007 -> 18:22:57"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'startup' !
livermoreFloatValueBenchmark

	|	n		
		size
		x		
		y		
		q 		
		r 		
		z 		
		t 		
		|

	n := 1001.
	size := n + 12.
	x := Array new: size.
	y := (Array new: size) atAllPut: 1.1234.
	z := (Array new: size) atAllPut: 1.1234.
	q := r := t := 1.234.

	Transcript show: 'Livermore seconds equivalent:', (((Time millisecondsToRun: 
		[	1000 timesRepeat:
				[	self livermoreFloatValueInner: x y: y z: z ]
		]) * 10) asFloat / 1000.0) printString; cr.! !

"June 6, 2007 -> 18:22:58"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'startup' !
livermoreFloatValueInner: x y: y z: z

	|	n		
		size
		q 		<FloatValue>
		r 		<FloatValue>
		t 		<FloatValue>
		|

	n := 1001.
	size := n + 12.
	q := r := t := 1.234.

	1 to: n do:
		[ :k  |
			x at: k put: 
					(q + ( (y at: k) asFloatValue * (r*(z at: k + 10) asFloatValue) + (t*(z at: k + 11) asFloatValue) )) asFloat
		]! !

"June 6, 2007 -> 18:23:0"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'startup' !
ocBenchmark

	1 timesRepeat: [ OrderedCollection performanceTest ].
Transcript show: '-------------------------------------- starting benchmark'; cr.
	Transcript print:
		[ OrderedCollection performanceTest ] time; cr.! !

"June 6, 2007 -> 18:23:0"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'startup' !
test: class title: title
    Transcript show: 'Testing '; show: title; cr.
    class test.
    Transcript show: 'end'; cr
! !

"June 6, 2007 -> 18:23:2"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'test code' !
doubleOverflowCheck
	| number |
	number := 2.0.
	[ number isFinite ] whileTrue: [
		Transcript print: number; cr.
		number := number * number.
	]! !

"June 6, 2007 -> 18:23:3"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'test code' !
indexTest
	   'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1.
        'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1.
        'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1.
        'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1.
        'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1.
        'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1.
        'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1.
        'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1.
        'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1.
        'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1! !

"June 6, 2007 -> 18:23:3"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'test code' !
testContext
	self testContext: 1 and: 2 and: 3! !

"June 6, 2007 -> 18:23:4"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'test code' !
testContext: a and: b and: c
	[ (a + b) printString. self deoptimize ] value! !

"June 6, 2007 -> 18:23:5"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'test code' !
testNLR
	| f |
	f := self testNLRBlock.
	f value.
	
! !

"June 6, 2007 -> 18:23:6"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'test code' !
testNLRBlock
	^[^self]! !

"June 6, 2007 -> 18:23:7"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'typechecker tests' !
displayErrorsFromHandler: eh  <DeltaTypeErrorHandler>  

eh reportedErrors isEmpty 
   ifTrue:[Transcript  show: 'No type errors'; cr.]
   ifFalse:[eh reportedErrors do:[: e <TypeError> | Transcript show: e errorMessage; cr.]].! !

"June 6, 2007 -> 18:23:8"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'typechecker tests' !
tryNewClass! !

"June 6, 2007 -> 18:23:8"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'typechecker tests' !
tryNewMixin! !

"June 6, 2007 -> 18:23:9"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'typechecker tests' !
typecheckMinWorld! !

"June 6, 2007 -> 18:23:10"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'typechecker tests' !
typecheckMirror: m <Mirror>

m typecheck. 
m classSide typecheck
! !

"June 6, 2007 -> 18:23:11"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'utilities' !
clearLookupCache
	{{primitiveClearLookupCache}}! !

"June 6, 2007 -> 18:23:12"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'utilities' !
decodeAllMethods
	{{primitiveDecodeAllMethods}}.! !

"June 6, 2007 -> 18:23:13"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'utilities' !
printObjectHistogram
	{{primitivePrintObjectHistogram}}! !

"June 6, 2007 -> 18:23:14"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'utilities' !
setupInlining
	"Set inlining flags for helping the inlining compiler. Experimental"
	
	((Mirror on: HashedCollection) 	compiledMethodAt: #at: 					ifFail: []) neverInline.
	((Mirror on: Dictionary) 					compiledMethodAt: #at:put:				ifFail: []) neverInline.
	((Mirror on: Dictionary) 					compiledMethodAt: #at:put:ifNew:	ifFail: []) alwaysInline.
	((Mirror on: OutputStreamView) 	compiledMethodAt: #cr						ifFail: []) neverInline.
	((Mirror on: Object) 							compiledMethodAt: #assert:				ifFail: []) alwaysInline.
! !

"June 6, 2007 -> 18:24:30"!

"System saved" !
"June 6, 2007 -> 22:15:39"!

"System saved" !
"June 7, 2007 -> 1:20:56"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'library testing' !
deterministicallyTestSystem
	"As many tests as we can do deterministically (i.e. without requiring UI interaction, for now)."

	self testLibrary.
	"Smalltalk recompileAllMethods."
	Transcript show: 'Testing completed.'; cr.! !

"June 7, 2007 -> 1:22:11"!

"System saved" !
"June 8, 2007 -> 2:6:29"!

! (Delta mirrorFor: #Process) methodsFor: 'private-initialization' !
recordId

	"win32Handle := {{<kernel Win32Handle GetCurrentThreadId> call}}"! !

"June 8, 2007 -> 2:42:42"!

"System saved" !
"June 8, 2007 -> 3:4:34"!

! (Delta mirrorFor: #Process) methodsFor: 'private-initialization' !
recordId

	win32Handle := {{<kernel Win32Handle GetCurrentThreadId> call}}! !

"June 8, 2007 -> 3:7:4"!

"System saved" !
"June 8, 2007 -> 21:54:37"!

Delta define: #Win32Process as: (
(Class subclassOf: 'Process' instanceVariables: '')) !


"June 8, 2007 -> 21:55:45"!

Delta define: #Win32Process as: (
(Class subclassOf: 'Process' instanceVariables: 'win32Handle')) !


"June 8, 2007 -> 21:56:53"!

! (Delta mirrorFor: #Win32Process) methodsFor: 'private-initialization' !
recordId

	win32Handle := {{<kernel Win32Handle GetCurrentThreadId> call}}! !

"June 8, 2007 -> 21:57:8"!

Delta define: #Win32Process as: (
(Class subclassOf: 'Process' instanceVariables: 'win32Handle <Win32Handle>
	"the thread id"')) !


"June 8, 2007 -> 22:3:55"!

! (Delta mirrorFor: #Win32Process) methodsFor: 'restricted' !
win32Handle ^<Win32Handle>
	"This is valid only after the process has begun to actually execute"

	^win32Handle! !

"June 8, 2007 -> 22:8:45"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'platform classes' !
processClass
	^Win32Process! !

"June 8, 2007 -> 22:31:45"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'platform classes' !
processClass
	^Win32Process! !

"June 8, 2007 -> 22:33:49"!

Delta define: #Win32Process as: (
(Class subclassOf: 'Process' instanceVariables: '')) !


"June 8, 2007 -> 22:34:2"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'platform classes' !
processClass
	^Win32Process! !

"June 9, 2007 -> 0:29:57"!

Delta define: #Win32Process as: (
(Class subclassOf: 'Process' instanceVariables: 'win32Handle <Win32Handle>
	"the thread id"')) !


"June 9, 2007 -> 0:30:47"!

! (Delta mirrorFor: #Win32Process) methodsFor: 'private-initialization' !
recordId

	win32Handle := {{<kernel Win32Handle GetCurrentThreadId> call}}! !

"June 9, 2007 -> 0:31:37"!

! (Delta mirrorFor: #Win32Process) methodsFor: 'restricted' !
win32Handle ^<Win32Handle>
	"This is valid only after the process has begun to actually execute"

	^win32Handle! !

"June 9, 2007 -> 0:35:33"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'platform classes' !
processClass
	^Process! !

"June 9, 2007 -> 0:50:14"!

! (Delta mirrorFor: #Process) classSide methodsFor: 'instance creation' !
primitiveCreate: block

	^{{ self primitiveProcessCreate: block
				ifFail: [ :err <Symbol> | self error: err ]
		}}! !

"June 9, 2007 -> 0:52:6"!

! (Delta mirrorFor: #Process) classSide methodsFor: 'instance creation' !
for: block <[]> ^<Instance>
	"Create and return a new process that will execute the block at the
	 specified priority.  The new process is suspended."

	| i <Instance> |
	i := (guaranteed <Instance>
		(Platform processClass primitiveCreate: [ i recordId. block value ])
	  ) initFor: block.
	^i! !

"June 9, 2007 -> 0:53:30"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'platform classes' !
processClass
	^Win32Process! !

"June 9, 2007 -> 0:54:29"!

Delta define: #UnixProcess as: (
(Class subclassOf: 'Process' instanceVariables: '')) !


"June 9, 2007 -> 0:55:3"!

! (Delta mirrorFor: #UnixProcess) methodsFor: 'private-initialization' !
recordId! !

"June 9, 2007 -> 1:0:15"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'platform classes' !
processClass

	^UnixProcess! !

"June 9, 2007 -> 1:8:57"!

"System saved" !
"June 9, 2007 -> 14:1:17"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"June 9, 2007 -> 14:1:19"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"June 9, 2007 -> 14:1:19"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"June 9, 2007 -> 14:1:19"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"June 9, 2007 -> 14:1:19"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"June 9, 2007 -> 14:1:19"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"June 9, 2007 -> 14:1:19"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"June 9, 2007 -> 14:1:19"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"June 9, 2007 -> 14:1:19"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"June 9, 2007 -> 14:1:19"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"June 9, 2007 -> 14:1:19"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"June 9, 2007 -> 14:1:20"!

(Delta mirrorFor: #Process)
comment: 
'Tags: %BlueBook %User

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license
'!


"June 9, 2007 -> 14:1:21"!

! (Delta mirrorFor: #Process) classSide methodsFor: 'instance creation' !
for: block <[]> ^<Instance>
	"Create and return a new process that will execute the block at the
	 specified priority.  The new process is suspended."

	| i <Instance> |
	i := (guaranteed <Instance>
		{{self primitiveProcessCreate: [ i recordId. block value ]
				ifFail: [ :err <Symbol> | self error: err ]
		}}
	  ) initFor: block.
	^i! !

"June 9, 2007 -> 14:1:22"!

! (Delta mirrorFor: #Process) classSide methodsFor: 'file out' !
fileOutSignature ^<Integer>
    ^80! !

"June 9, 2007 -> 14:1:23"!

! (Delta mirrorFor: #Process) methodsFor: 'private-initialization' !
initFor: block <[]>

	body := block.

	self register.
	
! !

"June 9, 2007 -> 14:1:24"!

! (Delta mirrorFor: #Process) methodsFor: 'private-initialization' !
recordId

	win32Handle := {{<kernel Win32Handle GetCurrentThreadId> call}}! !

"June 9, 2007 -> 14:1:25"!

! (Delta mirrorFor: #Process) methodsFor: 'accessing' !
priority ^<Int>

	^priority! !

"June 9, 2007 -> 14:1:26"!

! (Delta mirrorFor: #Process) methodsFor: 'accessing' !
priority: prio <Int>

	priority := prio! !

"June 9, 2007 -> 14:1:27"!

! (Delta mirrorFor: #Process) methodsFor: 'accessing' !
processError ^ <ProcessError>

	^processError
! !

"June 9, 2007 -> 14:1:28"!

! (Delta mirrorFor: #Process) methodsFor: 'accessing' !
status ^<Symbol>
	"One of:
		#Initialized				- State right after creation.
		#Yielded					- Gave up control by calling yield.
		#InAsyncDLL			- Gave up control but continues to execute asynchronous DLL.
		#Stopped				- Gave up control by calling stop.
		#Preempted			- Was preempted by system.
		#Running					- Currently running
		#Completed			- Ran to completion.
		#Killed						- The process has been terminated.
		#BooleanError		- A boolean was expected at hardcoded control structure.
		#LookupError			- The receiver does not understand doesNotUnderstand:.
		#PrimitiveLookupError	- Binding a primitive failed.
		#DLLLookupError				 - Binding a DLL function failed.
		#NLRError				- Context for NLR did not exist.
		#StackOverflow		- Stack exhausted.
	"

	^{{self primitiveProcessStatus}}! !

"June 9, 2007 -> 14:1:29"!

! (Delta mirrorFor: #Process) methodsFor: 'testing' !
running ^<Boolean>
	"Not suspended, dying, or dead. (This includes processes blocked in async dll calls)"

	^Processor isRunning: self! !

"June 9, 2007 -> 14:1:30"!

! (Delta mirrorFor: #Process) methodsFor: 'testing' !
suspended ^<Boolean>
	"Not on the running list, but can be resumed"

	| s <Symbol> |
	self running
		ifTrue: [ ^false ].
	s := self status.
	^s == #Yielded
		or: [ s == #InAsyncDLL
		or: [ s == #Initialized
		or: [ s == #Preempted
		or: [ s == #Stopped ]   ]]]! !

"June 9, 2007 -> 14:1:31"!

! (Delta mirrorFor: #Process) methodsFor: 'control' !
resume

	Processor resume: self! !

"June 9, 2007 -> 14:1:32"!

! (Delta mirrorFor: #Process) methodsFor: 'control' !
suspend

	Processor suspend: self.
	Processor activeProcess = self
		ifTrue: [ self yield ]! !

"June 9, 2007 -> 14:1:34"!

! (Delta mirrorFor: #Process) methodsFor: 'control' !
terminate

	Processor terminating: self.
	self vmTerminate.	! !

"June 9, 2007 -> 14:1:35"!

! (Delta mirrorFor: #Process) methodsFor: 'control' !
waitUntilDead
	"can be called after a process has been terminated to wait until it has completed
		unwinding its stack etc, and is truly dead.  This loops currently, so it is not
		a good way for waiting for the death of a process that has not been terminated.
		This may never return if the process that has been terminated does not ever
		finish cleaning up."
	
	[ self running ]
		whileTrue: [ Processor yield ]! !

"June 9, 2007 -> 14:1:36"!

! (Delta mirrorFor: #Process) methodsFor: 'restricted' !
activationStack ^ <Array[Activation]>

	^{{self primitiveProcessStackLimit: 100 ifFail: [ :err <CompressedSymbol>  | self error: err]}}! !

"June 9, 2007 -> 14:1:37"!

! (Delta mirrorFor: #Process) methodsFor: 'restricted' !
processError: e <ProcessError>

	processError := e
! !

"June 9, 2007 -> 14:1:38"!

! (Delta mirrorFor: #Process) methodsFor: 'restricted' !
stopInEvaluator

	Processor stopInEvaluator: self! !

"June 9, 2007 -> 14:1:39"!

! (Delta mirrorFor: #Process) methodsFor: 'restricted' !
traceStack

	{{self primitiveProcessTraceStack: 20 ifFail: [ :err <Symbol> | self error: err]}}
! !

"June 9, 2007 -> 14:1:40"!

! (Delta mirrorFor: #Process) methodsFor: 'restricted' !
win32Handle ^<Win32Handle>
	"This is valid only after the process has begun to actually execute"

	^win32Handle! !

"June 9, 2007 -> 14:1:41"!

! (Delta mirrorFor: #Process) methodsFor: 'restricted' !
yield
	{{primitiveProcessYield}}! !

"June 9, 2007 -> 14:1:42"!

! (Delta mirrorFor: #Process) methodsFor: 'file out' !
fileOutSignature ^<Integer>
    ^112! !

"June 9, 2007 -> 14:1:43"!

! (Delta mirrorFor: #Process) methodsFor: 'private' !
register

	Processor register: self.! !

"June 9, 2007 -> 14:1:44"!

! (Delta mirrorFor: #Process) methodsFor: 'private' !
vmTerminate

	{{self primitiveProcessTerminateIfFail: [ :err <Symbol> | self error: err ]}}! !

"June 9, 2007 -> 14:6:45"!

! (Delta mirrorFor: #Process) classSide methodsFor: 'instance creation' !
primitiveCreate: block! !

"June 9, 2007 -> 14:31:1"!

"System saved" !
"June 9, 2007 -> 15:17:24"!

! (Delta mirrorFor: #IdleProcess) classSide methodsFor: 'accessing' !
hasIdleActions

	^self theIdleProcess hasIdleActions! !

"June 9, 2007 -> 15:17:49"!

! (Delta mirrorFor: #ProcessorScheduler) methodsFor: 'private' !
hasIdleActions ^<Boolean>

	^IdleProcess hasIdleActions! !

"June 9, 2007 -> 17:42:19"!

Delta define: #TestA as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 9, 2007 -> 17:42:50"!

Delta define: #TestA as: (
(Class subclassOf: 'Object' instanceVariables: 'one two three')) !


"June 9, 2007 -> 17:43:43"!

Delta define: #TestA as: (
(Class subclassOf: 'Object' instanceVariables: 'one three')) !


"June 9, 2007 -> 17:44:17"!

Delta define: #TestA as: (
(Class subclassOf: 'Object' instanceVariables: 'one two three')) !


"June 9, 2007 -> 17:44:48"!

! (Delta mirrorFor: #TestA) methodsFor: 'accessing' !
one: aValue

	one := aValue! !

"June 9, 2007 -> 17:45:6"!

! (Delta mirrorFor: #TestA) methodsFor: 'accessing' !
two: aValue

	two := aValue! !

"June 9, 2007 -> 17:45:18"!

! (Delta mirrorFor: #TestA) methodsFor: 'accessing' !
three: aValue

	three := aValue! !

"June 9, 2007 -> 17:47:0"!

(Delta mirrorFor: #TestA) removeMethod: #two: ifAbsent: [] !


"June 9, 2007 -> 17:47:23"!

Delta define: #TestA as: (
(Class subclassOf: 'Object' instanceVariables: 'one three')) !


"June 9, 2007 -> 17:51:37"!

(Delta mirrorFor: #TestA) removeDefinitionIfFail: [] !


"June 9, 2007 -> 18:34:20"!

! (Delta mirrorFor: #IdleProcess) methodsFor: 'private' !
process

	^self! !

"June 9, 2007 -> 21:39:47"!

(Delta mirrorFor: #IdleProcess) removeMethod: #process ifAbsent: [] !


"June 9, 2007 -> 21:42:19"!

! (Delta mirrorFor: #Process) classSide methodsFor: 'os-specific' !
processClass ! !

"June 9, 2007 -> 21:42:48"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'os-specific' !
processClass ! !

"June 9, 2007 -> 21:43:17"!

(Delta mirrorFor: #Win32Platform) classSide removeMethod: #processClass ifAbsent: [] !


"June 9, 2007 -> 21:44:8"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'os specific' !
currentThreadId

	^{{<kernel Win32Handle GetCurrentThreadId> call}}! !

"June 9, 2007 -> 21:44:31"!

! (Delta mirrorFor: #Process) methodsFor: 'private-initialization' !
recordId

	win32Handle := Platform currentThreadId! !

"June 9, 2007 -> 21:45:0"!

(Delta mirrorFor: #Process) classSide removeMethod: #processClass ifAbsent: [] !


"June 9, 2007 -> 21:45:57"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'os specific' !
currentThreadId

	^0! !

"June 9, 2007 -> 21:50:6"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'os specific' !
currentThreadId
	" stub to allow compatibility with Win32 "
	self deltaHack.
	^0! !

"June 9, 2007 -> 21:51:28"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'os specific' !
currentThreadId
	" stub to allow compatibility with Win32 specifics of process "
	self deltaHack.
	^0! !

"June 9, 2007 -> 21:52:38"!

(Delta mirrorFor: #Process) classSide removeMethod: #primitiveCreate: ifAbsent: [] !


"June 9, 2007 -> 22:6:12"!

"System saved" !
"June 10, 2007 -> 0:57:19"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLMapName: name <Str> ^<Str>
    ^name , '.so'! !

"June 10, 2007 -> 1:4:51"!

! (Delta mirrorFor: #UnixPlatform) methodsFor: 'instance creation' !
processClass! !

"June 10, 2007 -> 1:5:35"!

! (Delta mirrorFor: #UnixPlatform) methodsFor: 'instance creation' !
processClass 
! !

"June 10, 2007 -> 1:6:35"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'platform classes' !
processClass 
! !

"June 10, 2007 -> 1:6:53"!

(Delta mirrorFor: #UnixPlatform) classSide removeMethod: #processClass ifAbsent: [] !


"June 10, 2007 -> 1:6:59"!

(Delta mirrorFor: #UnixPlatform) removeMethod: #processClass ifAbsent: [] !


"June 10, 2007 -> 1:17:21"!

Delta define: #UnixFilePattern as: (
(Class subclassOf: 'FilePattern' instanceVariables: '')) !


"June 10, 2007 -> 1:17:21"!

(Delta mirrorFor: #UnixFilePattern)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"June 10, 2007 -> 1:17:23"!

! (Delta mirrorFor: #UnixFilePattern) classSide methodsFor: 'instance creation' !
for: pat <Str>  ^<FilePattern>

    self assert: [ self validPattern: pat ].
    ^self new pattern: pat! !

"June 10, 2007 -> 1:17:24"!

! (Delta mirrorFor: #UnixFilePattern) classSide methodsFor: 'testing' !
validPattern: pat <Str> ^<Boolean>

    "Make sure this is a valid syntactic pattern (should be valid even if no *s)"
    self unimplemented! !

"June 10, 2007 -> 1:17:25"!

! (Delta mirrorFor: #UnixFilePattern) classSide methodsFor: 'restricted' !
patternHasWildcards: pat <Str> ^<Boolean>

    ^(pat includes: Platform multipleMatchWildcardCharacter)
        or: [ pat includes: Platform singleMatchWildcardCharacter ]! !

"June 10, 2007 -> 1:17:26"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'private' !
firstWildElementOf: els <SeqCltn[FilePattern]> ifFail: fail <[^X def]> ^<Int | X>

    1 to: els size do:
        [ :i <Int> |
            (els at: i) isPath
                ifFalse: [ ^i ]
        ].
    ^fail value! !

"June 10, 2007 -> 1:17:27"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'private' !
patternExtending: pat <FilePattern> ^<Str>

    ^pat pattern last = $\
        ifTrue: [ pat pattern, self pattern ]
        ifFalse: [ pat pattern,'\', self pattern ]! !

"June 10, 2007 -> 1:17:29"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'private' !
terminalPathsDo: blk <[FilePath]>

    "assumes that the last element of the receiver is the only one that contains wildcards"
    | data <WIN32_FIND_DATA> hnd <Win32Handle> allpat <CString> pat <Str> els <SeqCltn[FilePattern]> prefix <Str> |
    data := WIN32_FIND_DATA new allocate.
    els := self elements.
    "%todo %opt - should check to see if the pattern is suitable for the windows call directly, so that the 
        elements are prefiltered.  Rule would be: use pattern directly if * appears only just before a dot or at the
        end, and contains no other wildcards"
    els size = 1
        ifTrue: [   allpat := CString for: '*.*'.
                        prefix := ''. ]
        ifFalse: [  allpat := CString for: self containingDirectory pattern, '\*.*'.
                            prefix := (FilePattern forAll: (els copyFrom: 1 to: els size - 1)) pattern,'\'.  ].
    pat := els last pattern.
    [   hnd := {{<kernel Win32Handle FindFirstFileA>
                        pattern: allpat
                        data: data
                    }}.
        hnd @= Win32 INVALID_HANDLE_VALUE
            ifTrue: [ Win32 getLastError @= Win32 ERROR_NO_MORE_FILES
                            ifFalse: [ Win32 handleError ]
                            ifTrue: [ ^self ]
                        ]
            ifFalse: [  [   | next <Str> |
                                next := data cFileName asString.
                                ((pat platformMatch: next) and: [ next ~= '.' and: [ next ~= '..' ]])
                                    ifTrue: [ blk value: (FilePath for: prefix,next) ].
                                [   {{<kernel Win32Handle FindNextFileA>
                                        hnd: hnd
                                        data: data
                                    }} asBoolean
                                        ifFalse: [ Win32 getLastError @= Win32 ERROR_NO_MORE_FILES
                                                            ifFalse: [ Win32 handleError ]
                                                            ifTrue: [ ^self ]
                                                     ]
                                        ifTrue: [   next := data cFileName asString.
                                                        ((pat platformMatch: next) and: [ next ~= '.' and: [ next ~= '..' ]])
                                                            ifTrue: [ blk value: (FilePath for: prefix,next) ].
                                                    ]
                                ] repeat.
                            ] ensure:
                                [   {{<kernel Win32Handle FindClose> hnd: hnd}} asBoolean
                                        ifFalse: [ Win32 handleError ].
                                ]
                        ]                                       
    ] ensure:
        [   data free.
            allpat free.        ]! !

"June 10, 2007 -> 1:17:30"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'testing' !
isAbsolute ^<Boolean>

    ^self pattern includes: $:! !

"June 10, 2007 -> 1:17:31"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'iterating' !
elementsDo: blk <[FilePattern]>

    | s <CharacterReadStream> |

    s := self pattern readStream.
    [ s atEnd ]
        whileFalse:
            [   | next <Str> |
                next := s upTo: $\.
                (next includes: $:)
                    ifTrue: [ next := next,'\' ].
                blk value: (FilePattern for: next)  ].! !

"June 10, 2007 -> 1:17:32"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'iterating' !
pathsDo: blk <[FilePath]>

    | els <SeqCltn[FilePattern]> i <Int> |
    els := self elements.
    i := self firstWildElementOf: els
                ifFail: [ ^self shouldNotHappen ].
    i = els size
        ifTrue: [ self terminalPathsDo: blk ]
        ifFalse: [  | rest <FilePattern> |
                        i + 1 = els size
                            ifTrue: [ rest := els last ]
                            ifFalse: [ rest := FilePattern forAll: (els copyFrom: i + 1 to: els size) ].
                        (FilePattern forAll: (els copyFrom: 1 to: i))
                            pathsDo:
                                [ :fp <FilePath> |
                                    fp isDirectory
                                        ifTrue: [ (fp, rest) pathsDo: blk ]     ]
                     ]! !

"June 10, 2007 -> 1:17:33"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'accessing' !
extensions ^<FilePattern>

    ^self , (FilePattern for: '*')! !

"June 10, 2007 -> 1:17:53"!

Delta define: #UnixFilePath as: (
(Class subclassOf: 'FilePath mixin |>(ExternalStreamableObject mixin |>(ExternalObject mixin |>UnixFilePattern))' instanceVariables: '')) !


"June 10, 2007 -> 1:17:53"!

(Delta mirrorFor: #UnixFilePath)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"June 10, 2007 -> 1:17:55"!

! (Delta mirrorFor: #UnixFilePath) classSide methodsFor: 'instance creation' !
currentDirectory ^<FilePath>

    | buf <CString> buflen <Int> |
    buflen := 1000.
    buf := CString new malloc: buflen.
    ^[      {{<kernel ExternalProxy GetCurrentDirectoryA>
                size: buflen
                buf: buf
            }} isNull
                ifTrue: [ Win32 handleError ]
                ifFalse: [ self new pattern: buf asString ]
      ] ensure: [ buf free ]! !

"June 10, 2007 -> 1:17:56"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
exists ^<Boolean>

    self win32FileAttributesIfFail: [ ^false ].
    ^true! !

"June 10, 2007 -> 1:17:57"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
isDirectory ^<Boolean>

    ^((self win32FileAttributesIfFail: [ ^false ])
            externalBitAnd: Win32 FILE_ATTRIBUTE_DIRECTORY
      ) @~= 0! !

"June 10, 2007 -> 1:17:58"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
isReadOnly ^<Boolean>

    ^((self win32FileAttributesIfFail: [ ^false ])
            externalBitAnd: Win32 FILE_ATTRIBUTE_READONLY
      ) @~= 0! !

"June 10, 2007 -> 1:17:59"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
isSyntaxValid ^<Boolean>

    "Extend inherited version to ensure no wildcard characters"
    ^super isSyntaxValid and: [ self unimplemented ]! !

"June 10, 2007 -> 1:18:0"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
createValueFor: mode <Symbol>  ^<ExternalData>

    mode = #read
        ifTrue: [ ^3        "OPEN_EXISTING" ].
    mode = #write
        ifTrue: [ ^2        "CREATE_ALWAYS" ].
    mode = #readWrite
        ifTrue: [ ^4        "OPEN_ALWAYS" ].
    self shouldNotHappen! !

"June 10, 2007 -> 1:18:1"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
deleteDirectoryIfFail: blk <[Symbol]>

    | name <CString> |
    name := CString for: self name.
    [   {{<kernel ExternalProxy RemoveDirectoryA>
                name: name
        }} asBoolean
            ifFalse: [ blk value: #ErrorDeletingDirectory ]
    ] ensure: [ name free ]! !

"June 10, 2007 -> 1:18:2"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
deleteFileIfFail: blk <[Symbol]>

    | name <CString> |
    name := CString for: self name.
    [   {{<kernel ExternalProxy DeleteFileA>
                name: name
        }} asBoolean
            ifFalse: [ blk value: #ErrorDeletingFile ]
    ] ensure: [ name free ]! !

"June 10, 2007 -> 1:18:3"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
fileAttributesFor: mode <Symbol>  ^<ExternalData>
    
    mode = #read
        ifTrue: [ ^ExternalProxy new
                    setHigh:    16r0800        "FILE_FLAG_SEQUENTIAL_SCAN"
                    low:            16r80        "FILE_ATTRIBUTE_NORMAL"    ].
    (mode = #write)
        ifTrue: [ ^ExternalProxy new
                    setHigh:    16r0000
                    low:            16r80        "FILE_ATTRIBUTE_NORMAL"    ].
    (mode = #readWrite)
        ifTrue: [ ^ExternalProxy new
                    setHigh:    16r0000    
                    low:            16r80        "FILE_ATTRIBUTE_NORMAL"    ].
    self shouldNotHappen.! !

"June 10, 2007 -> 1:18:4"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
fileDescriptorClass ^<FileDescriptor class>

    ^Win32FileDescriptor! !

"June 10, 2007 -> 1:18:5"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
modeProxyFor: mode <Symbol> ^<ExternalData>

    mode = #read
        ifTrue: [ ^ExternalProxy new setHigh: 16r8000 low: 0 ].
    mode = #write
        ifTrue: [ ^ExternalProxy new setHigh: (16r4000 bitOr: 16r8000) low: 0 ].
    mode = #readWrite
        ifTrue: [ ^ExternalProxy new setHigh: (16r4000 bitOr: 16r8000) low: 0 ].! !

"June 10, 2007 -> 1:18:6"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
sharingValueFor: mode <Symbol> ^<ExternalData>

    mode = #read
        ifTrue: [ ^1    "FILE_SHARE_WRITE" ].
    "in all other cases"
    ^0 "no sharing"! !

"June 10, 2007 -> 1:18:7"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
win32FileAttributesIfFail: blk <[^X def]> ^<ExternalProxy | X>

    | name <CString> |
    name := CString for: self name.
    ^[  | result <ExternalProxy> |
        result := {{<kernel ExternalProxy GetFileAttributesA>
                            name: name
                        }}.
        result @= (ExternalProxy forHigh: 16rFFFF low: 16rFFFF)
            ifTrue: [ blk value ]
            ifFalse: [ result ]
     ] ensure: [ name free ]! !

"June 10, 2007 -> 1:18:8"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'restricted' !
openInternalFor: mode <Symbol> ifFail: err <[ExternalError, ^X def]>  ^<ExternalProxy | X>

    "%todo: use overlapped io"
    |   dname <ExternalProxy>
        dmode <ExternalData>
        dsharing <ExternalData>
        dcreate <ExternalData>
        dattributes <ExternalData>
        proxy <ExternalProxy> |
    dname := self nameProxy.
    dmode := self modeProxyFor: mode.
    dsharing := self sharingValueFor: mode.
    dcreate := self createValueFor: mode.
    dattributes := self fileAttributesFor: mode.

    proxy := self win32CreateFile_name: dname
        mode: dmode
        sharing: dsharing
        security: 0
        create: dcreate
        attributes: dattributes
        template: 0.

    dname free.
    ^proxy isAllOnes
        ifFalse: [ proxy ]
        ifTrue: [ err value: #cannotOpenFile ]! !

"June 10, 2007 -> 1:18:9"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'restricted' !
win32CreateFile_name: dname    <ExternalData>
mode: dmode            <ExternalData>
sharing: dsharing        <ExternalData>
security: dsecurity        <ExternalData>
create: dcreate            <ExternalData>
attributes: dattributes    <ExternalData>
template: dtemplate        <ExternalData>
^<ExternalProxy>
    ^{{<kernel ExternalProxy CreateFileA>
        name: dname
        mode: dmode
        sharing: dsharing
        security: dsecurity
        create: dcreate
        attributes: dattributes
        template: dtemplate}}! !

"June 10, 2007 -> 1:18:11"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'control' !
createDirectoryIfFail: fail <[Symbol]>

    | name <CString> sec <SECURITY_ATTRIBUTES> |
    name := CString for: self name.
    sec := SECURITY_ATTRIBUTES new allocateZeroed.
    sec nLength: sec structureSize.

    [   {{<kernel ExternalProxy CreateDirectoryA>
            name: name
            security: sec
        }} asBoolean
            ifFalse: [ Win32 getLastError @= Win32 ERROR_ALREADY_EXISTS
                                ifFalse: [ fail value: #CannotCreateFile ] ]
    ] ensure: [ name free.
                        sec free.    ]! !

"June 10, 2007 -> 1:18:12"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'restricted-double dispatching' !
deletePathIfFail: blk <[Symbol]>

    self exists
        ifFalse: [  blk value: #NoSuchFileOrDirectory.
                        ^self       ].
    self isDirectory
        ifTrue: [ self deleteDirectoryIfFail: blk ]
        ifFalse: [ self deleteFileIfFail: blk ]! !

"June 10, 2007 -> 1:18:13"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'copying-moving' !
copyAs: newPath <FilePath> ifFail: fail <[ExternalError]>

    | csrc <CString> cdest <CString> |
    csrc := CString for: self name.
    cdest := CString for: newPath name.
    [   {{<kernel ExternalProxy CopyFileA>
                source: csrc
                dest: cdest
                failIfExists: false asExternalData
        }} asBoolean
            ifFalse: [  fail value:
                                ('Error copying file: ', Win32 getLastError printString) asSymbol ]
    ] ensure:
        [   csrc free.
            cdest free  ]! !

"June 10, 2007 -> 1:18:14"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'copying-moving' !
moveAs: newPath <FilePath> ifFail: fail <[ExternalError]>

    | csrc <CString> cdest <CString> |
    csrc := CString for: self name.
    cdest := CString for: newPath name.
    [   {{<kernel ExternalProxy MoveFileA>
                source: csrc
                dest: cdest
        }} asBoolean
            ifFalse: [  | err <ExternalData> |
                            err := Win32 getLastError.
                            err @= Win32 ERROR_ALREADY_EXISTS
                                ifTrue: [   fail value: #AlreadyExists.
                                                 ^self.  ].
                            err @= Win32 ERROR_SHARING_VIOLATION
                                ifTrue: [   fail value: #SharingViolation.
                                                 ^self.  ].
                            fail value:
                                ('Error moving file: ', Win32 getLastError printString) asSymbol ]
    ] ensure:
        [   csrc free.
            cdest free  ]! !

"June 10, 2007 -> 1:18:15"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'accessing' !
type ^<Str>
    "The file type (on most platforms this is the part after the $. at the end)"

    | indices <SeqCltn[Int]> |
    indices := self name indicesOfSubCollection: '.'.
    indices isEmpty
        ifTrue: [ ^'' ].
    ^self name
            copyFrom: indices last + 1
            to: self name size! !

"June 10, 2007 -> 1:19:17"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'platform classes' !
pathClass ^<FilePath class>

    ^UnixFilePath! !

"June 10, 2007 -> 1:19:25"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'platform classes' !
patternClass ^<FilePattern class>

    ^UnixFilePattern! !

"June 10, 2007 -> 1:51:59"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
exists ^<Boolean>
	| name result |
	name := CString for: self name.
    [ result := {{<libc ExternalProxy open>
   	 					name: name
    					flags: 0}}.
     	^result asSmallInteger >= 0]
     	ensure: [ name free.
     				{{<libc ExternalProxy close>
   	 					fd: result}} ]! !

"June 10, 2007 -> 1:53:55"!

"System saved" !
"June 11, 2007 -> 21:19:33"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
modeProxyFor: mode <Symbol> ^<ExternalData>

    mode = #read
        ifTrue: [ ^ExternalProxy new set: 0 ].
    mode = #write
        ifTrue: [ ^ExternalProxy new set: 1 ].
    mode = #readWrite
        ifTrue: [ ^ExternalProxy new set: 2 ]! !

"June 11, 2007 -> 21:20:50"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
modeProxyFor: mode <Symbol> ^<SmallInt>

    mode = #read
        ifTrue: [ ^0 ].
    mode = #write
        ifTrue: [ ^1 ].
    mode = #readWrite
        ifTrue: [ ^2 ]! !

"June 11, 2007 -> 21:21:29"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
modeFor: mode <Symbol> ^<SmallInt>

    mode = #read
        ifTrue: [ ^0 ].
    mode = #write
        ifTrue: [ ^1 ].
    mode = #readWrite
        ifTrue: [ ^2 ]! !

"June 11, 2007 -> 21:21:45"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'restricted' !
openInternalFor: mode <Symbol> ifFail: err <[ExternalError, ^X def]>  ^<ExternalProxy | X>

    "%todo: use overlapped io"
    |   dname <ExternalProxy>
        dmode <ExternalData>
        dsharing <ExternalData>
        dcreate <ExternalData>
        dattributes <ExternalData>
        proxy <ExternalProxy> |
    dname := self nameProxy.
    dmode := self modeFor: mode.

    proxy := {{<libc ExternalProxy open>
    					name: dname
    					flags: dmode }}

    dname free.
    ^proxy isAllOnes
        ifFalse: [ proxy ]
        ifTrue: [ err value: #cannotOpenFile ]! !

"June 11, 2007 -> 21:22:10"!

(Delta mirrorFor: #UnixFilePath) removeMethod: #win32CreateFile_name:mode:sharing:security:create:attributes:template: ifAbsent: [] !


"June 11, 2007 -> 21:23:10"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'restricted' !
openInternalFor: mode <Symbol> ifFail: err <[ExternalError, ^X def]>  ^<ExternalProxy | X>

    "%todo: use overlapped io"
    |   dname <ExternalProxy>
        dmode <SmallInt>
        proxy <ExternalProxy> |
    dname := self nameProxy.
    dmode := self modeFor: mode.

    proxy := {{<libc ExternalProxy open>
    					name: dname
    					flags: dmode }}

    dname free.
    ^proxy isAllOnes
        ifFalse: [ proxy ]
        ifTrue: [ err value: #cannotOpenFile ]! !

"June 11, 2007 -> 21:25:15"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'restricted' !
openInternalFor: mode <Symbol> ifFail: err <[ExternalError, ^X def]>  ^<ExternalProxy | X>

    |   dname <ExternalProxy>
        dmode <SmallInt>
        proxy <ExternalProxy> |
    dname := self nameProxy.
    dmode := self modeFor: mode.

    proxy := {{<libc ExternalProxy open>
    					name: dname
    					flags: dmode }}

    dname free.
    ^proxy isAllOnes
        ifFalse: [ proxy ]
        ifTrue: [ err value: #cannotOpenFile ]! !

"June 11, 2007 -> 21:27:42"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'restricted' !
openInternalFor: mode <Symbol> ifFail: err <[ExternalError, ^X def]>  ^<ExternalProxy | X>

    |   dname <ExternalProxy>
        dmode <SmallInt>
        proxy <ExternalProxy> |
    dname := self nameProxy.
    dmode := self modeFor: mode.

    [ proxy := {{<libc ExternalProxy open>
    					name: dname
    					flags: dmode }} ]
    		ensure: [ dname free ].

    ^proxy isAllOnes
        ifFalse: [ proxy ]
        ifTrue: [ err value: #cannotOpenFile ]! !

"June 11, 2007 -> 21:28:44"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'restricted' !
openInternalFor: mode <Symbol> ifFail: err <[ExternalError, ^X def]>  ^<ExternalProxy | X>

    |   dname <ExternalProxy>
        dmode <SmallInt>
        proxy <ExternalProxy> |
    dname := self nameProxy.

    [ dmode := self modeFor: mode.
    	proxy := {{<libc ExternalProxy open>
    					name: dname
    					flags: dmode }} ]
    		ensure: [ dname free ].

    ^proxy isAllOnes
        ifFalse: [ proxy ]
        ifTrue: [ err value: #cannotOpenFile ]! !

"June 11, 2007 -> 21:30:9"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
win32FileAttributesIfFail: blk <[^X def]> ^<ExternalProxy | X>

    | name <CString> |
    self halt.
    name := CString for: self name.
    ^[  | result <ExternalProxy> |
        result := {{<kernel ExternalProxy GetFileAttributesA>
                            name: name
                        }}.
        result @= (ExternalProxy forHigh: 16rFFFF low: 16rFFFF)
            ifTrue: [ blk value ]
            ifFalse: [ result ]
     ] ensure: [ name free ]! !

"June 11, 2007 -> 22:28:5"!

Delta define: #UnixFileDescriptor as: (
(Class subclassOf: 'FileDescriptor' instanceVariables: 'ioCount <ExternalProxy>
            "Used to hold the count of bytes read/written, & other temporary results, for speed"
        ')) !


"June 11, 2007 -> 22:28:5"!

(Delta mirrorFor: #UnixFileDescriptor)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.2 $
'!


"June 11, 2007 -> 22:28:7"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
initializeIOCount
    ioCount := ExternalProxy new.
    ioCount malloc: 4.! !

"June 11, 2007 -> 22:28:7"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
ioCount ^<ExternalProxy>

    ^ioCount! !

"June 11, 2007 -> 22:28:8"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
postCopy
    super postCopy.
    self initializeIOCount.! !

"June 11, 2007 -> 22:28:9"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
printLastError
    | result |
    "Dump the error message for the last windows call"
    "%temporary"
    result := {{<kernel ExternalProxy GetLastError>geterror}}.
    Platform errorStream show: 'Last error from windows: ', result asSmallInteger printString; cr! !

"June 11, 2007 -> 22:28:10"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
setExternalPosition: p <Int>
    "%todo: support large integer positions for extremely large files"
    {{<kernel ExternalProxy SetFilePointer>
        handle: self handle
        distanceLow: p
        distanceHigh: 0
        moveMethod: 0 }}    "FILE_BEGIN"! !

"June 11, 2007 -> 22:28:11"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'i/o' !
readAt: pos <Int> ifFail: errf <[ExternalError]> ^<Int>
    | result <ExternalProxy> count <Int> |
    self position = pos
        ifFalse: [ self position: pos ].
    self knowAtEnd
        ifTrue: [        count := 0 ]
        ifFalse: [
                    result := {{<kernel ExternalProxy ReadFile>
                        handle: self handle
                        buffer: self buffer
                        count: self bufferSize
                        numberRead: self ioCount
                        overlapped: 0    }}.
                    result isNull
                        ifTrue: [ 
                        self printLastError.
                        errf value: #IOError.
                                ^0    ].
                    count := self ioCount smallIntegerAt: 0.    ].
    self setPosition: self position + count.
    ^count! !

"June 11, 2007 -> 22:28:12"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'i/o' !
write: nBytes <Int> at: pos <Int> ifFail: errf <[ExternalError]>
    | result <ExternalProxy> count <Int> |
    self position ~= pos
        ifTrue: [ self position: pos ].
    result := {{<kernel ExternalProxy WriteFile>
        handle: self handle
        buffer: self buffer
        count: nBytes
        numberWritten: self ioCount
        overlapped: 0 }}.
    result isNull
        ifTrue: [ errf value: #IOError.
                ^0    ].
    count := self ioCount smallIntegerAt: 0.
    self setPosition: self position + count.! !

"June 11, 2007 -> 22:28:14"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'accessing' !
getBufferSize ^<Int>

    "Use the sector size"
    ^self sectorSize * 8! !

"June 11, 2007 -> 22:28:15"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'accessing' !
sectorSize ^<Int>
    "Use the sector size"
    | junk <ExternalProxy> bytesPerSector <ExternalProxy> status <ExternalProxy> result <Int> |
    junk := ExternalProxy new malloc: Platform wordSize.
    bytesPerSector := ExternalProxy new malloc: Platform wordSize.
    status := {{<kernel ExternalProxy GetDiskFreeSpaceA>
            rootPath: 0
            sectorsPerCluster: junk
            bytesPerSector: bytesPerSector
            freeClusters: junk
            clusters: junk    }}.
    status isNull
        ifTrue: [ self error: 'Cannot get disk sector size' ]
        ifFalse: [ result := bytesPerSector smallIntegerAt: 0 ].
    junk free.
    bytesPerSector free.
    ^result! !

"June 11, 2007 -> 22:28:16"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'accessing' !
size ^<Int>
    | result <ExternalProxy> |
    result := {{<kernel ExternalProxy GetFileSize>
                handle: self handle
                sizeHigh: self ioCount    }}.
    self ioCount isAllOnes
        ifTrue: [ "must check for possible error status"
                | status <ExternalProxy> |
                "status := {<kernel ExternalProxy GetLastError>}."
                status isNull    "NO_ERROR"
                    ifFalse: [ self error: 'Can''t get file size' ].    ].
    ^(ioCount smallIntegerAt: 0) = 0
        ifFalse: [    "%todo: construct a large integer from the high&low words"
                    self unimplemented    ]
        ifTrue: [ result asSmallInteger ]! !

"June 11, 2007 -> 22:28:17"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'control' !
flushIfFail: errf <[ExternalError]>

    | result <ExternalProxy> |
    "%todo: uncomment"
    "result := {<kernel ExternalProxy FlushFileBuffers async>
        handle: self handle }."
    result isNull
        ifTrue: [ errf value: 'I/O Error flushing file information' ].! !

"June 11, 2007 -> 22:28:18"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'control' !
openIfFail: err <[ExternalError]>
    super openIfFail: err.
    self ioCount malloc: Platform wordSize.! !

"June 11, 2007 -> 22:28:19"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'control' !
severExternalConnections
    | result <ExternalProxy> |
    
    super severExternalConnections.
    self ioCount free.
    result := {{<kernel ExternalProxy CloseHandle>
        handle: self handle }}.
    result isNull
        ifTrue: [ self error: 'Error closing file handle' ].! !

"June 11, 2007 -> 22:28:20"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'initialization' !
mode: m <Symbol>
    super mode: m.
    self initializeIOCount.! !

"June 11, 2007 -> 22:29:30"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
fileDescriptorClass ^<FileDescriptor class>

    ^UnixFileDescriptor! !

"June 11, 2007 -> 22:32:37"!

"System saved" !
"June 12, 2007 -> 1:35:32"!

Delta define: #StatBuffer as: (
(Class subclassOf: 'CStructure' instanceVariables: '')) !


"June 12, 2007 -> 2:14:23"!

(Delta mirrorFor: #StatBuffer)
comment: 
'Represents the buffer in which stat
returns file attributes'!


"June 12, 2007 -> 2:15:42"!

! (Delta mirrorFor: #StatBuffer) methodsFor: 'accessing' !
blockSize

	^self smallIntegerAt: self blockSizeOffset! !

"June 12, 2007 -> 2:15:59"!

! (Delta mirrorFor: #StatBuffer) methodsFor: 'accessing' !
structureSize

	^88! !

"June 12, 2007 -> 2:16:24"!

! (Delta mirrorFor: #StatBuffer) methodsFor: 'offsets' !
blockSizeOffset

	^48! !

"June 12, 2007 -> 2:38:52"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'accessing' !
blockSize ^<Int>
    "Use the sector size"
    | statBuffer <StatBuffer> 
    	status <ExternalProxy> |
    statBuffer := StatBuffer new allocate.
    [ status := {{<libc ExternalProxy fstat>
            			name: self handle
            			buffer: statBuffer    }}.
	^status asSmallInteger == -1
		ifTrue: [4096]
		ifFalse: [ statBuffer blockSize ]]
		ensure: [ statBuffer free]! !

"June 12, 2007 -> 2:39:9"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'accessing' !
getBufferSize ^<Int>

    "Use the block size"
    ^self blockSize * 8! !

"June 12, 2007 -> 2:42:57"!

"System saved" !
"June 12, 2007 -> 11:26:54"!

! (Delta mirrorFor: #StatBuffer) methodsFor: 'accessing' !
version

	^3! !

"June 12, 2007 -> 11:27:24"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'accessing' !
blockSize ^<Int>
    "Use the sector size"
    | statBuffer <StatBuffer> 
    	status <ExternalProxy> |
    statBuffer := StatBuffer new allocate.
    [ status := {{<libc ExternalProxy __fxstat>
    					version: statBuffer version
            			name: self handle
            			buffer: statBuffer    }}.
	^status asSmallInteger == -1
		ifTrue: [4096]
		ifFalse: [ statBuffer blockSize ]]
		ensure: [ statBuffer free]! !

"June 12, 2007 -> 11:28:12"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'accessing' !
blockSize ^<Int>
    "Use the sector size"
    | statBuffer <StatBuffer> 
    	status <ExternalProxy> |
    statBuffer := StatBuffer new.
    statBuffer allocate.
    [ status := {{<libc ExternalProxy __fxstat>
    					version: statBuffer version
            			name: self handle
            			buffer: statBuffer    }}.
	^status asSmallInteger == -1
		ifTrue: [4096]
		ifFalse: [ statBuffer blockSize ]]
		ensure: [ statBuffer free]! !

"June 12, 2007 -> 11:29:46"!

"System saved" !
"June 12, 2007 -> 18:29:46"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
setExternalPosition: p <Int>
    "%todo: support large integer positions for extremely large files"
    {{<libc ExternalProxy libc>
        fd: self handle
        offset: p
        whence: self SEEK_SET }}    "FILE_BEGIN"! !

"June 12, 2007 -> 18:33:18"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
SEEK_SET

	^0! !

"June 12, 2007 -> 18:52:44"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'i/o' !
readAt: pos <Int> ifFail: errf <[ExternalError]> ^<Int>
    | result <ExternalProxy> count <Int> |
    self position = pos
        ifFalse: [ self position: pos ].
    self knowAtEnd
        ifTrue: [        count := 0 ]
        ifFalse: [
                    count := {{<libc ExternalProxy read>
                        fd: self handle
                        buffer: self buffer
                        count: self bufferSize    }}.
                    count := self ioCount smallIntegerAt: 0.    ].
    self setPosition: self position + count.
    ^count! !

"June 12, 2007 -> 19:29:4"!

! (Delta mirrorFor: #StatBuffer) methodsFor: 'offsets' !
fileSizeOffset

	^44! !

"June 12, 2007 -> 19:29:18"!

! (Delta mirrorFor: #StatBuffer) methodsFor: 'accessing' !
fileSize
! !

"June 12, 2007 -> 19:29:40"!

! (Delta mirrorFor: #StatBuffer) methodsFor: 'accessing' !
fileSize

	^self smallIntegerAt: self fileSizeOffset! !

"June 12, 2007 -> 19:33:36"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'accessing' !
size ^<Int>
    "Use the sector size"
    | statBuffer <StatBuffer> 
    	status <ExternalProxy> |
    statBuffer := StatBuffer new.
    statBuffer allocate.
    [ status := {{<libc ExternalProxy __fxstat>
    					version: statBuffer version
            			name: self handle
            			buffer: statBuffer    }}.
	^status asSmallInteger == -1
		ifTrue: [0]
		ifFalse: [ statBuffer fileSize ]]
		ensure: [ statBuffer free]! !

"June 12, 2007 -> 19:43:26"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'i/o' !
readAt: pos <Int> ifFail: errf <[ExternalError]> ^<Int>
    | result <ExternalProxy> count <Int> |
    self position = pos
        ifFalse: [ self position: pos ].
    self knowAtEnd
        ifTrue: [ count := 0 ]
        ifFalse: [ count := {{<libc ExternalProxy read>
                        fd: self handle
                        buffer: self buffer
                        count: self bufferSize    }} ].
    self setPosition: self position + count.
    ^count! !

"June 12, 2007 -> 19:47:14"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'i/o' !
write: nBytes <Int> at: pos <Int> ifFail: errf <[ExternalError]>
    | result <ExternalProxy> count <Int> |
    self position = pos
        ifFalse: [ self position: pos ].
    count := {{<libc ExternalProxy write>
                        fd: self handle
                        buffer: self buffer
                        count: nBytes    }}.
    self setPosition: self position + count! !

"June 12, 2007 -> 19:53:7"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'control' !
severExternalConnections
    | result <ExternalProxy> |
    
    super severExternalConnections.
    self ioCount free.
    result := {{<libc ExternalProxy close>
        handle: self handle }}.
    result asSmallInteger == -1
        ifTrue: [ self error: 'Error closing file handle' ].! !

"June 12, 2007 -> 20:19:23"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'control' !
createDirectoryIfFail: fail <[Symbol]>

    | name <CString> |
    name := CString for: self name.

    [{{<libc ExternalProxy mkdir>
            name: name
            mode: 0
        }} asSmallInteger == -1
            ifFalse: [  fail value: #CannotCreateFile ]
    ] ensure: [ name free ]! !

"June 12, 2007 -> 20:22:33"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
deleteDirectoryIfFail: blk <[Symbol]>

    | name <CString> |
    name := CString for: self name.
    [ {{<libc ExternalProxy rmdir>
             name: name
        }} asSmallInteger == -1
            ifFalse: [ blk value: #ErrorDeletingDirectory ]
    ] ensure: [ name free ]! !

"June 12, 2007 -> 20:31:1"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
deleteFileIfFail: blk <[Symbol]>

    | name <CString> |
    name := CString for: self name.
    [   {{<libc ExternalProxy unlink>
                name: name
        }} asSmallInteger == -1
            ifFalse: [ blk value: #ErrorDeletingFile ]
    ] ensure: [ name free ]! !

"June 12, 2007 -> 20:33:38"!

"System saved" !
"June 12, 2007 -> 20:47:28"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
setExternalPosition: p <Int>
    "%todo: support large integer positions for extremely large files"
    {{<libc ExternalProxy lseek>
        fd: self handle
        offset: p
        whence: self SEEK_SET }}    "FILE_BEGIN"! !

"June 12, 2007 -> 20:49:30"!

"System saved" !
"June 12, 2007 -> 21:54:15"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'i/o' !
readAt: pos <Int> ifFail: errf <[ExternalError]> ^<Int>
    | result <ExternalProxy> count <Int> |
    self position = pos
        ifFalse: [ self position: pos ].
    self knowAtEnd
        ifTrue: [ count := 0 ]
        ifFalse: [ count := {{<libc ExternalProxy read>
        				                fd: self handle
                        				buffer: self buffer
                        				count: self bufferSize }} asSmallInteger ].
    self setPosition: self position + count.
    ^count! !

"June 12, 2007 -> 21:55:36"!

"System saved" !
"June 13, 2007 -> 0:13:15"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
O_RDONLY

	^0! !

"June 13, 2007 -> 0:13:32"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
O_WRONLY

	^1! !

"June 13, 2007 -> 0:13:49"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
O_RDWR

	^2! !

"June 13, 2007 -> 0:16:45"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
O_CREAT

	^64! !

"June 13, 2007 -> 0:18:33"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
modeFor: mode <Symbol> ^<SmallInt>

    mode = #read
        ifTrue: [ ^self O_RDONLY ].
    mode = #write
        ifTrue: [ ^self O_WRONLY bitOr: self O_CREAT ].
    mode = #readWrite
        ifTrue: [ ^self O_RDWR bitOr: self O_CREAT ]
    self error: 'Unrecognised mode: ' , mode! !

"June 13, 2007 -> 0:21:27"!

"System saved" !
"June 13, 2007 -> 0:37:58"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'i/o' !
write: nBytes <Int> at: pos <Int> ifFail: errf <[ExternalError]>
    | result <ExternalProxy> count <Int> |
    self position = pos
        ifFalse: [ self position: pos ].
    count := {{<libc ExternalProxy write>
                        fd: self handle
                        buffer: self buffer
                        count: nBytes    }} asSmallInteger.
    self setPosition: self position + count! !

"June 13, 2007 -> 0:39:18"!

"System saved" !
"June 13, 2007 -> 0:49:47"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
modeFor: mode <Symbol> ^<SmallInt>

    mode = #read
        ifTrue: [ ^self O_RDONLY ].
    mode = #write
        ifTrue: [ ^self O_WRONLY bitOr: self O_CREAT ].
    mode = #readWrite
        ifTrue: [ ^self O_RDWR bitOr: self O_CREAT ].
    self error: 'Unrecognised mode: ' , mode! !

"June 13, 2007 -> 0:51:7"!

"System saved" !
"June 13, 2007 -> 16:56:15"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'restricted' !
openInternalFor: mode <Symbol> ifFail: err <[ExternalError, ^X def]>  ^<ExternalProxy | X>

    |   dname <ExternalProxy>
        dmode <SmallInt>
        proxy <ExternalProxy> |
    dname := self nameProxy.

    [ dmode := self modeFor: mode.
    	proxy := {{<libc ExternalProxy open>
    					name: dname
    					flags: dmode
    					create: 8r777 }} ]
    		ensure: [ dname free ].

    ^proxy isAllOnes
        ifFalse: [ proxy ]
        ifTrue: [ err value: #cannotOpenFile ]! !

"June 13, 2007 -> 16:58:7"!

"System saved" !
"June 13, 2007 -> 17:9:33"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
O_CREAT

	^8r100! !

"June 13, 2007 -> 17:9:53"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
O_TRUNC

	^8r1000! !

"June 13, 2007 -> 17:10:28"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
modeFor: mode <Symbol> ^<SmallInt>

    mode = #read
        ifTrue: [ ^self O_RDONLY ].
    mode = #write
        ifTrue: [ ^(self O_WRONLY bitOr: self O_CREAT) bitOr: self O_TRUNC ].
    mode = #readWrite
        ifTrue: [ ^self O_RDWR bitOr: self O_CREAT ].
    self error: 'Unrecognised mode: ' , mode! !

"June 13, 2007 -> 17:11:49"!

"System saved" !
"June 13, 2007 -> 18:37:47"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'control' !
createDirectoryIfFail: fail <[Symbol]>

    | name <CString> |
    name := CString for: self name.

    [{{<libc ExternalProxy mkdir>
            name: name
            mode: 0
        }} asSmallInteger == -1
            ifTrue: [  fail value: #CannotCreateFile ]
    ] ensure: [ name free ]! !

"June 13, 2007 -> 18:39:4"!

"System saved" !
"June 13, 2007 -> 20:2:58"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'control' !
createDirectoryIfFail: fail <[Symbol]>

    | name <CString> |
    name := CString for: self name.

    [{{<libc ExternalProxy mkdir>
            name: name
            mode: 8r777
        }} asSmallInteger == -1
            ifTrue: [  fail value: #CannotCreateFile ]
    ] ensure: [ name free ]! !

"June 13, 2007 -> 20:4:21"!

"System saved" !
"June 13, 2007 -> 20:49:28"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
fstat: statBlock ifFail: failBlock

    | statBuffer <StatBuffer> 
    	status <ExternalProxy> |
    statBuffer := StatBuffer new.
    statBuffer allocate.
    [ status := {{<libc ExternalProxy __fxstat>
    					version: statBuffer version
            			name: self handle
            			buffer: statBuffer    }}.
	status asSmallInteger == -1
		ifTrue: [ failBlock value ]
		ifFalse: [ statBlock value: statBuffer ]]
		ensure: [ statBuffer free]! !

"June 13, 2007 -> 20:54:50"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
stat: testBlock ifFail: failBlock

    | statBuffer <StatBuffer> 
    	status <ExternalProxy>
    	name <CString> |
    statBuffer := StatBuffer new.
    statBuffer allocate.
    name := CString for: self name.
    [ status := {{<libc ExternalProxy __xstat>
    					version: statBuffer version
            			name: name
            			buffer: statBuffer    }}.
	status asSmallInteger == -1
		ifTrue: [ failBlock value ]
		ifFalse: [ ^testBlock value: statBuffer ]]
		ensure: [ statBuffer free]! !

"June 13, 2007 -> 20:55:0"!

(Delta mirrorFor: #UnixFilePath) removeMethod: #fstat:ifFail: ifAbsent: [] !


"June 13, 2007 -> 20:56:9"!

! (Delta mirrorFor: #StatBuffer) methodsFor: 'accessing' !
mode

	^self smallIntegerAt: self modeOffset! !

"June 13, 2007 -> 20:56:32"!

! (Delta mirrorFor: #StatBuffer) methodsFor: 'offsets' !
modeOffset

	^8! !

"June 13, 2007 -> 20:57:48"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
isDirectory ^<Boolean>

    ^self stat: [:stat| (stat bitAnd: self S_IFDIR) == self S_IFDIR]
    	ifFail: [ self error: 'could not stat file' ]! !

"June 13, 2007 -> 21:39:33"!

! (Delta mirrorFor: #StatBuffer) methodsFor: 'offsets' !
modeOffset

	^16! !

"June 13, 2007 -> 21:39:50"!

! (Delta mirrorFor: #StatBuffer) methodsFor: 'offsets' !
uidOffset

	^24! !

"June 13, 2007 -> 21:40:1"!

! (Delta mirrorFor: #StatBuffer) methodsFor: 'offsets' !
gidOffset

	^28! !

"June 13, 2007 -> 21:45:56"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
S_IFDIR

	^8r40000! !

"June 13, 2007 -> 21:58:0"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
S_IRUSR

	^8r4000! !

"June 13, 2007 -> 21:58:20"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
S_IWUSR

	^8r2000! !

"June 13, 2007 -> 21:58:34"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
S_IXUSR

	^8r1000! !

"June 13, 2007 -> 21:59:36"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
S_IXGRP

	^8r100! !

"June 13, 2007 -> 21:59:54"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
S_IWGRP

	^8r200! !

"June 13, 2007 -> 22:0:2"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
S_IRGRP

	^8r400! !

"June 13, 2007 -> 22:0:25"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
S_IROTH

	^8r40! !

"June 13, 2007 -> 22:0:34"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
S_IWOTH

	^8r20! !

"June 13, 2007 -> 22:0:43"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
S_IXOTH

	^8r10! !

"June 13, 2007 -> 22:6:56"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
geteuid

	^{{<libc ExternalProxy geteuid> call}} asSmallInteger! !

"June 13, 2007 -> 22:7:11"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
getguid

	^{{<libc ExternalProxy getguid> call}} asSmallInteger! !

"June 13, 2007 -> 22:7:48"!

! (Delta mirrorFor: #StatBuffer) methodsFor: 'accessing' !
uid

	^self smallIntegerAt: self uidOffset! !

"June 13, 2007 -> 22:8:3"!

! (Delta mirrorFor: #StatBuffer) methodsFor: 'accessing' !
gid

	^self smallIntegerAt: self gidOffset! !

"June 13, 2007 -> 22:15:58"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
isReadOnly ^<Boolean>

    ^self stat: [:stat| 
    				(stat uid == self geteuid and: [(stat mode bitAnd: self S_IWUSR) == 0])
    					or: [(stat gid == self getegid and: [(stat mode bitAnd: self S_IWGRP) == 0])
    					or: [(stat mode bitAnd: self S_IWOTH) == 0]]]
    	ifFail: [ self error: 'could not stat file' ]! !

"June 13, 2007 -> 22:28:23"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
stat: testBlock ifFail: failBlock

    | statBuffer <StatBuffer> 
    	status <ExternalProxy>
    	name <CString> |
    statBuffer := StatBuffer new.
    statBuffer allocate.
    name := CString for: self name.
    [ status := {{<libc ExternalProxy __xstat>
    					version: statBuffer version
            			name: name
            			buffer: statBuffer    }}.
	status asSmallInteger == -1
		ifTrue: [ failBlock value ]
		ifFalse: [ ^testBlock value: statBuffer ]]
		ensure: [ statBuffer free.
						name free]! !

"June 13, 2007 -> 22:31:18"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
exists ^<Boolean>
	| name result |
	name := self nameProxy.
    [ result := {{<libc ExternalProxy open>
   	 					name: name
    					flags: 0}}.
     	^result asSmallInteger >= 0]
     	ensure: [ name free.
     				{{<libc ExternalProxy close>
   	 					fd: result}} ]! !

"June 13, 2007 -> 22:31:23"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
isDirectory ^<Boolean>

    ^self stat: [:stat| (stat mode bitAnd: self S_IFDIR) == self S_IFDIR]
    	ifFail: [ self error: 'could not stat file' ]! !

"June 13, 2007 -> 22:39:36"!

"System saved" !
"June 13, 2007 -> 22:55:42"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'private' !
patternExtending: pat <FilePattern> ^<Str>

    ^pat pattern last = $/
        ifTrue: [ pat pattern, self pattern ]
        ifFalse: [ pat pattern,'/', self pattern ]! !

"June 13, 2007 -> 22:57:18"!

"System saved" !
"June 13, 2007 -> 23:5:33"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
verify: message
	"Evaluate the receiver, and generate an error if it does not return true.  This is different than
	  Object>>#assert: in that 1) it is a boolean block message, and 2) it ALWAYS evaluates, whereas
	  #assert: does not guarantee that it will evaluate the predicate.

	  Use verify in situations where you must ensure that the test is performed, for example when there
	  are side-effects that must take place, or if it is testing code that should always be performed.

	  Note that this message is only valid for blocks that return boolean values."

	"Note: we don't use self as the receiver for #error: below because it will currently
		prevent the block from being optimized away by the inliner"
	self value
		ifFalse: [ BlockWithoutArguments[Object] error: 'Assertion failed: ', message ].

	"%hack %todo: remove this when compiler bug fixed"
	^nil! !

"June 13, 2007 -> 23:8:45"!

! (Delta mirrorFor: #FilePath) classSide methodsFor: 'testing' !
test

	| f <FilePath> f2 <FilePath> |

	f := FilePath for: 'tmpDir'.
	[ f exists not ] verify.

	f createDirectoryIfFail: [ :err <Symbol> | Win32 handleError ].
	[ f exists ] verify: 'tmpDir exists'.
	[ f isDirectory ] verify: 'tmpDir isDirectory'.
	[ f isWriteable ] verify: 'tmpDir isWriteable'.

	f2 := f , (FilePath for: 'sub').
	[ f2 exists not ] verify: 'tmpDir/sub exists not'.

	f2 createDirectoryIfFail: [ :err <Symbol> | Win32 handleError ].
	[ f2 exists ] verify: 'tmpDir/sub exists'.
	[ f isDirectory ] verify: 'tmpDir/sub isDirectory'.
	[ f isWriteable ] verify: 'tmpDir/sub isWriteable'.

	[ (self tryToDeleteTestDir: f) not ] verify: 'delete tmpDir should fail'.
	[ self tryToDeleteTestDir: f2 ] verify: 'delete tmpDir/sub'.
	[ self tryToDeleteTestDir: f ] verify: 'delete tmpDir'.

	[ f2 exists not ] verify: 'tmpDir/sub should not exist'.
	[ f exists not ] verify: 'tmpDir should not exist'.
! !

"June 13, 2007 -> 23:10:6"!

"System saved" !
"June 14, 2007 -> 0:9:58"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
getegid

	^{{<libc ExternalProxy getegid> call}} asSmallInteger! !

"June 14, 2007 -> 0:10:13"!

(Delta mirrorFor: #UnixFilePath) removeMethod: #getguid ifAbsent: [] !


"June 14, 2007 -> 0:42:20"!

"System saved" !
"June 14, 2007 -> 20:20:37"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
isReadOnly ^<Boolean>

    ^self isWriteable not! !

"June 14, 2007 -> 20:20:40"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
isWriteable

    ^self stat: [:stat| 
    				(stat uid == self geteuid and: [(stat mode bitAnd: self S_IWUSR) == self S_IWUSR])
    					or: [(stat gid == self getegid and: [(stat mode bitAnd: self S_IWGRP) == self S_IWGRP])
    					or: [(stat mode bitAnd: self S_IWOTH) == self S_IWOTH]]]
    	ifFail: [ self error: 'could not stat file' ]! !

"June 14, 2007 -> 20:22:57"!

"System saved" !
"June 15, 2007 -> 17:41:22"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
deleteDirectoryIfFail: blk <[Symbol]>

    | name <CString> |
    name := CString for: self name.
    [ {{<libc ExternalProxy rmdir>
             name: name
        }} asSmallInteger == -1
            ifTrue: [ blk value: #ErrorDeletingDirectory ]
    ] ensure: [ name free ]! !

"June 15, 2007 -> 17:41:29"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
deleteFileIfFail: blk <[Symbol]>

    | name <CString> |
    name := CString for: self name.
    [   {{<libc ExternalProxy unlink>
                name: name
        }} asSmallInteger == -1
            ifTrue: [ blk value: #ErrorDeletingFile ]
    ] ensure: [ name free ]! !

"June 15, 2007 -> 17:43:12"!

"System saved" !
"June 17, 2007 -> 12:21:49"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLMapName: name <Str> ^<Str>
    name = 'libc' ifTrue: [^'libc.so.6']
    self error: 'Unrecognised shared library'! !

"June 18, 2007 -> 10:26:43"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'library testing' !
deterministicallyTestSystem
	"As many tests as we can do deterministically (i.e. without requiring UI interaction, for now)."

	self testLibrary.
	Smalltalk recompileAllMethods.
	Transcript show: 'Testing completed.'; cr.! !

"June 18, 2007 -> 10:27:57"!

"System saved" !
"June 18, 2007 -> 18:51:20"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLMapName: name <Str> ^<Str>
    name = 'libc' ifTrue: [^'libc.so.6'].
    self error: 'Mapping ', name, ' not found'! !

"June 18, 2007 -> 18:53:50"!

"System saved" !
"June 18, 2007 -> 19:20:57"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'environment' !
environmentVariableAt: key <Str> ifAbsent: blk <[^X def]> ^ <Str | X>

    | cKey <CString> cValue <CString> |
    cKey := CString for: key.
    [cValue := {{<libc CString getenv> key: cKey}}.
    ^cValue isNull
    	ifTrue: [blk value]
    	ifFalse: [cValue asString]]
    	ensure: [cKey free]! !

"June 18, 2007 -> 19:21:41"!

"System saved" !
"June 18, 2007 -> 21:1:8"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'library testing' !
deterministicallyTestSystem
	"As many tests as we can do deterministically (i.e. without requiring UI interaction, for now)."

	self testLibrary.
	"Smalltalk recompileAllMethods."
	Transcript show: 'Testing completed.'; cr.! !

"June 18, 2007 -> 21:1:37"!

"System saved" !
"December 2, 2007 -> 19:16:6"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'copying-moving' !
copyAs: newPath <FilePath> ifFail: fail <[ExternalError]>

    | source target	|
	source := self readStream.
	target := newPath writeStream.
	[[source atEnd]	 whileFalse: [
		target nextPut: source next]]
			ensure: [source close.
							target close]! !

"December 2, 2007 -> 19:41:10"!

"System saved" !
"December 3, 2007 -> 0:25:40"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'iterating' !
elementsDo: blk <[FilePattern]>

    | s <CharacterReadStream> |

    s := self pattern readStream.
    [ s atEnd ]
        whileFalse:
            [   | next <Str> |
                next := s upTo: $/.
                (next includes: $:)
                    ifTrue: [ next := next,'/' ].
                blk value: (FilePattern for: next)  ].! !

"December 3, 2007 -> 0:28:2"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t <SYSTEMTIME> |
	t := SYSTEMTIME new allocate.
	{{<kernel ExternalProxy GetLocalTime> struct: t}}.
	^t! !

"December 3, 2007 -> 0:28:34"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t <SYSTEMTIME> |
	t := SYSTEMTIME new allocate.
	{{<kernel ExternalProxy GetLocalTime> struct: t}}.
	^t
! !

"December 3, 2007 -> 0:29:15"!

! (Delta mirrorFor: #Time) classSide methodsFor: 'restricted-win32' !
localSYSTEMTIME ^<SYSTEMTIME>

	^Platform localSYSTEMTIME
! !

"December 3, 2007 -> 0:53:24"!

Delta define: #TimeT as: (
(Class subclassOf: 'CStructure' instanceVariables: '')) !


"December 3, 2007 -> 0:53:52"!

! (Delta mirrorFor: #TimeT) methodsFor: 'accessing' !
structureSize

	^4! !

"December 3, 2007 -> 1:11:44"!

Delta define: #TM as: (
(Class subclassOf: 'CStructure' instanceVariables: '')) !


"December 3, 2007 -> 1:32:8"!

"System saved" !
"December 3, 2007 -> 1:34:28"!

! (Delta mirrorFor: #TM) methodsFor: 'accessing' !
structureSize

	^32! !

"December 3, 2007 -> 1:37:36"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t tm st |
	t := TimeT new allocate.
	tm := TM new allocate.
	st := SYSTEMTIME new allocate.
	{{<libc ExternalProxy time> struct: t}}.
	{{<libc ExternalProxy time> struct: t}}.
	^t
! !

"December 3, 2007 -> 1:50:4"!

! (Delta mirrorFor: #TM) methodsFor: 'offsets' !
mSecondOffset

	^0! !

"December 3, 2007 -> 1:50:37"!

! (Delta mirrorFor: #TM) methodsFor: 'offsets' !
mMinuteOffset

	^2! !

"December 3, 2007 -> 1:51:3"!

! (Delta mirrorFor: #TM) methodsFor: 'offsets' !
mHourOffset

	^4! !

"December 3, 2007 -> 1:51:35"!

! (Delta mirrorFor: #TM) methodsFor: 'offsets' !
mDayOffset

	^6! !

"December 3, 2007 -> 1:51:57"!

! (Delta mirrorFor: #TM) methodsFor: 'offsets' !
mMonthOffset

	^8! !

"December 3, 2007 -> 1:52:13"!

! (Delta mirrorFor: #TM) methodsFor: 'offsets' !
mYearOffset

	^10! !

"December 3, 2007 -> 1:54:6"!

! (Delta mirrorFor: #TM) methodsFor: 'converting' !
asSYSTEMTIME

	| st |
	st := SYSTEMTIME new allocate.
	st doubleByteAt: st wSecondOffset put: self mSecond.
	st doubleByteAt: st wMinuteOffset put: self mMinute.
	st doubleByteAt: st wHourOffset put: self mHour.
	st doubleByteAt: st wDayOffset put: self mDay.
	st doubleByteAt: st wMonthOffset put: self mMonth.
	st doubleByteAt: st wYearOffset put: self mYear.
	^st! !

"December 3, 2007 -> 1:55:4"!

! (Delta mirrorFor: #TM) methodsFor: 'accessing' !
mDay

	^self doubleByteAt: self mDayOffset! !

"December 3, 2007 -> 1:55:22"!

! (Delta mirrorFor: #TM) methodsFor: 'accessing' !
mSecond

	^self doubleByteAt: self mSecondOffset! !

"December 3, 2007 -> 1:55:33"!

! (Delta mirrorFor: #TM) methodsFor: 'accessing' !
mMinute

	^self doubleByteAt: self mMinuteOffset! !

"December 3, 2007 -> 1:55:46"!

! (Delta mirrorFor: #TM) methodsFor: 'accessing' !
mHour

	^self doubleByteAt: self mHourOffset! !

"December 3, 2007 -> 1:56:2"!

! (Delta mirrorFor: #TM) methodsFor: 'accessing' !
mMonth

	^self doubleByteAt: self mMonthOffset! !

"December 3, 2007 -> 1:56:11"!

! (Delta mirrorFor: #TM) methodsFor: 'accessing' !
mYear

	^self doubleByteAt: self mYearOffset! !

"December 3, 2007 -> 1:57:43"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t tm st |
	t := TimeT new allocate.
	tm := TM new allocate.
	[{{<libc ExternalProxy time> struct: t}}.
	{{<libc ExternalProxy gmtime>
		struct: t
		result: tm}}.
	^tm asSYSTEMTIME] ensure: [t free. tm free]
! !

"December 3, 2007 -> 1:58:47"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t tm |
	t := TimeT new allocate.
	tm := TM new allocate.
	[{{<libc ExternalProxy time> struct: t}}.
	{{<libc ExternalProxy gmtime>
		struct: t
		result: tm}}.
	^tm asSYSTEMTIME] ensure: [t free. tm free]
! !

"December 3, 2007 -> 2:5:10"!

"System saved" !
"December 3, 2007 -> 2:43:59"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t tm |
	t := TimeT new allocate.
	tm := TM new allocate.
	[{{<libc ExternalProxy time> struct: t}} asInteger == -1
		ifTrue: [self error: 'Invalid time'].
	{{<libc ExternalProxy gmtime>
		struct: t
		result: tm}}.
	^tm asSYSTEMTIME] ensure: [t free. tm free]
! !

"December 3, 2007 -> 2:45:44"!

"System saved" !
"December 3, 2007 -> 2:50:59"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t tm |
	t := TimeT new allocate.
	tm := TM new allocate.
	[{{<libc ExternalProxy time> struct: t}} isAllOnes
		ifTrue: [self error: 'Invalid time'].
	{{<libc ExternalProxy gmtime>
		struct: t
		result: tm}}.
	^tm asSYSTEMTIME] ensure: [t free. tm free]
! !

"December 3, 2007 -> 2:53:25"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t tm |
	t := TimeT new allocate.
	[{{<libc ExternalProxy time> struct: t}} isAllOnes
		ifTrue: [self error: 'Invalid time'].
	tm := {{<libc ExternalProxy gmtime>
					struct: t}}.
	^tm asSYSTEMTIME] ensure: [t free. tm free]
! !

"December 3, 2007 -> 2:53:57"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t tm |
	t := TimeT new allocate.
	[{{<libc ExternalProxy time> struct: t}} isAllOnes
		ifTrue: [self error: 'Invalid time'].
	tm := {{<libc TM gmtime>
					struct: t}}.
	^tm asSYSTEMTIME] ensure: [t free. tm free]
! !

"December 3, 2007 -> 2:54:29"!

"System saved" !
"December 3, 2007 -> 3:3:30"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t tm |
	t := TimeT new allocate.
	Transcript show: 'stage1'.
	[{{<libc ExternalProxy time> struct: t}} isAllOnes
		ifTrue: [self error: 'Invalid time'].
	Transcript show: 'stage2'.
	tm := {{<libc TM gmtime>
					struct: t}}.
	Transcript show: 'stage3'.
	^tm asSYSTEMTIME] ensure: [t free. tm free]
! !

"December 3, 2007 -> 3:3:50"!

"System saved" !
"December 3, 2007 -> 3:5:34"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t tm |
	t := TimeT new allocate.
	Transcript show: 'stage1'.
	[{{<libc ExternalProxy time> struct: t}} isAllOnes
		ifTrue: [self error: 'Invalid time'].
	Transcript show: 'stage2'.
	tm := {{<libc TM gmtime>
					struct: t}}.
	Transcript show: 'stage3'.
	^tm asSYSTEMTIME] ensure: [t free]
! !

"December 3, 2007 -> 3:6:5"!

"System saved" !
"December 3, 2007 -> 3:8:54"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t tm |
	t := TimeT new allocate.
	[{{<libc ExternalProxy time> struct: t}} isAllOnes
		ifTrue: [self error: 'Invalid time'].
	tm := {{<libc TM gmtime>
					struct: t}}.
	Transcript show: tm mDay printString.
	^tm asSYSTEMTIME] ensure: [t free]
! !

"December 3, 2007 -> 3:11:51"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t tm |
	t := TimeT new allocate.
	[{{<libc ExternalProxy time> struct: t}} isAllOnes
		ifTrue: [self error: 'Invalid time'].
	tm := {{<libc TM gmtime>
					struct: t}}.
	Transcript
		show: tm mYear printString; space;
		show: tm mMonth printString; space;
		show: tm mDay printString; space;
		show: tm mHour printString; space;
		show: tm mMinute printString; space;
		show: tm mSecond printString.
	^tm asSYSTEMTIME] ensure: [t free]
! !

"December 3, 2007 -> 3:14:11"!

"System saved" !
"December 3, 2007 -> 3:16:47"!

! (Delta mirrorFor: #TM) methodsFor: 'accessing' !
structureSize

	^64! !

"December 3, 2007 -> 3:16:57"!

! (Delta mirrorFor: #TM) methodsFor: 'offsets' !
mDayOffset

	^12! !

"December 3, 2007 -> 3:17:2"!

! (Delta mirrorFor: #TM) methodsFor: 'offsets' !
mHourOffset

	^8! !

"December 3, 2007 -> 3:17:7"!

! (Delta mirrorFor: #TM) methodsFor: 'offsets' !
mMinuteOffset

	^4! !

"December 3, 2007 -> 3:17:17"!

! (Delta mirrorFor: #TM) methodsFor: 'offsets' !
mMonthOffset

	^16! !

"December 3, 2007 -> 3:17:33"!

! (Delta mirrorFor: #TM) methodsFor: 'offsets' !
mYearOffset

	^20! !

"December 3, 2007 -> 3:18:8"!

"System saved" !
"December 3, 2007 -> 3:20:15"!

! (Delta mirrorFor: #TM) methodsFor: 'converting' !
asSYSTEMTIME

	| st |
	st := SYSTEMTIME new allocate.
	st doubleByteAt: st wSecondOffset put: self mSecond.
	st doubleByteAt: st wMinuteOffset put: self mMinute.
	st doubleByteAt: st wHourOffset put: self mHour.
	st doubleByteAt: st wDayOffset put: self mDay.
	st doubleByteAt: st wMonthOffset put: self mMonth.
	st doubleByteAt: st wYearOffset put: self mYear + 1900.
	^st! !

"December 3, 2007 -> 3:20:42"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t tm |
	t := TimeT new allocate.
	[{{<libc ExternalProxy time> struct: t}} isAllOnes
		ifTrue: [self error: 'Invalid time'].
	tm := {{<libc TM gmtime>
					struct: t}}.
	^tm asSYSTEMTIME] ensure: [t free]
! !

"December 3, 2007 -> 3:21:2"!

"System saved" !
"December 3, 2007 -> 3:27:49"!

! (Delta mirrorFor: #TM) methodsFor: 'converting' !
asSYSTEMTIME

	| st |
	st := SYSTEMTIME new allocate.
	st doubleByteAt: st wSecondOffset put: self mSecond.
	st doubleByteAt: st wMinuteOffset put: self mMinute.
	st doubleByteAt: st wHourOffset put: self mHour.
	st doubleByteAt: st wDayOffset put: self mDay.
	st doubleByteAt: st wMonthOffset put: self mMonth + 1.
	st doubleByteAt: st wYearOffset put: self mYear + 1900.
	^st! !

"December 3, 2007 -> 3:28:8"!

"System saved" !
"December 3, 2007 -> 23:52:19"!

Delta define: #TestA as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"December 3, 2007 -> 23:52:37"!

Delta define: #TestA as: (
(Class subclassOf: 'Object' instanceVariables: 'one two')) !


"December 3, 2007 -> 23:53:23"!

! (Delta mirrorFor: #TestA) classSide methodsFor: 'instance creation' !
one: one two: two

	^self new
		one: one
		two: two! !

"December 3, 2007 -> 23:54:26"!

! (Delta mirrorFor: #TestA) methodsFor: 'initialization' !
one: value1 two: value2

	one := value1.
	two := value2! !

"December 3, 2007 -> 23:59:24"!

Delta define: #TestA as: (
(Class subclassOf: 'Object' instanceVariables: 'one two three')) !


"December 4, 2007 -> 0:2:49"!

(Delta mirrorFor: #TestA) removeDefinitionIfFail: [] !


"December 4, 2007 -> 2:42:29"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'private' !
terminalPathsDo: blk <[FilePath]>

    | glob |
    glob := nil! !

"December 4, 2007 -> 2:43:25"!

Delta define: #GlobT as: (
(Class subclassOf: 'CStructure' instanceVariables: '')) !


"December 4, 2007 -> 2:44:4"!

! (Delta mirrorFor: #GlobT) methodsFor: 'accessing' !
structureSize

	^36! !

"December 4, 2007 -> 2:47:20"!

! (Delta mirrorFor: #GlobT) methodsFor: 'offsets' !
glPathc

	^0! !

"December 4, 2007 -> 2:47:47"!

! (Delta mirrorFor: #GlobT) methodsFor: 'offsets' !
glPathv

	^4! !

"December 4, 2007 -> 2:48:1"!

! (Delta mirrorFor: #GlobT) methodsFor: 'offsets' !
glPathvOffset

	^4! !

"December 4, 2007 -> 2:48:13"!

! (Delta mirrorFor: #GlobT) methodsFor: 'offsets' !
glPathcOffset

	^0! !

"December 4, 2007 -> 2:54:13"!

! (Delta mirrorFor: #GlobT) methodsFor: 'accessing' !
glPathc

	^self smallIntegerAt: self glPathcOffset! !

"December 4, 2007 -> 2:56:6"!

! (Delta mirrorFor: #GlobT) methodsFor: 'accessing' !
glPathv

	^self subProxyAt: self glPathvOffset! !

"December 4, 2007 -> 3:8:30"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'private' !
terminalPathsDo: blk <[FilePath]>

    | glob pathArray strings |
    glob := GlobT new allocate.
   {{<libc ExternalProxy glob>
    	pattern: self pattern
    	flags: 0
    	ignore: 0
    	glob: glob}}.
    [pathArray := glob glPathv.
    strings := OrderedCollection new.
    1 to: glob glPathc do: [:index| |cstring|
    	cstring := (pathArray cStringAt: (index - 1) * 4).
    	blk value: cstring asString.
    	strings add: cstring]] ensure: [
   			strings do: [:string| string free].
   			pathArray free.
    		glob free]! !

"December 4, 2007 -> 3:10:10"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'private' !
terminalPathsDo: blk <[FilePath]>

    | glob pathArray strings patternString |
   glob := GlobT new allocate.
   patternString := CString for: self pattern.
   {{<libc ExternalProxy glob>
    	pattern: patternString
    	flags: 0
    	ignore: 0
    	glob: glob}}.
    [pathArray := glob glPathv.
    strings := OrderedCollection new.
    1 to: glob glPathc do: [:index| |cstring|
    	cstring := (pathArray cStringAt: (index - 1) * 4).
    	blk value: cstring asString.
    	strings add: cstring]] ensure: [
   			strings do: [:string| string free].
   			pathArray free.
    		glob free.
    		patternString free]! !

"December 4, 2007 -> 3:13:55"!

! (Delta mirrorFor: #GlobT) methodsFor: 'iterating' !
pathsDo: blk

	| pathArray |
	pathArray := self glPathv.
	1 to: self glPathc do: [:index| |cstring|
    	cstring := (pathArray cStringAt: (index - 1) * 4).
    	blk value: cstring asString]! !

"December 4, 2007 -> 3:15:39"!

! (Delta mirrorFor: #GlobT) methodsFor: 'allocating' !
free
	
	| pathArray |
	pathArray := self glPathv.
	1 to: self glPathc do: [:index| |cstring|
    	(pathArray cStringAt: (index - 1) * 4) free].
    pathArray free.
    super free! !

"December 4, 2007 -> 3:16:55"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'private' !
terminalPathsDo: blk <[FilePath]>

    | glob pathArray strings patternString |
   glob := GlobT new allocate.
   patternString := CString for: self pattern.
   {{<libc ExternalProxy glob>
    	pattern: patternString
    	flags: 0
    	ignore: 0
    	glob: glob}}.
	[glob pathsDo: blk]
		ensure: [glob free]! !

"December 4, 2007 -> 3:17:18"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'private' !
terminalPathsDo: blk <[FilePath]>

    | glob pathArray strings patternString |
   glob := GlobT new allocate.
   patternString := CString for: self pattern.
   {{<libc ExternalProxy glob>
    	pattern: patternString
    	flags: 0
    	ignore: 0
    	glob: glob}}.
	[glob pathsDo: blk]
		ensure: [
			glob free.
			patternString free.]! !

"December 4, 2007 -> 3:19:36"!

"System saved" !
"December 4, 2007 -> 3:30:24"!

! (Delta mirrorFor: #GlobT) methodsFor: 'accessing' !
glPathv

	^self proxyAt: self glPathvOffset! !

"December 4, 2007 -> 3:36:17"!

! (Delta mirrorFor: #GlobT) methodsFor: 'iterating' !
pathsDo: blk

	| pathArray |
	pathArray := self glPathv.
	1 to: self glPathc do: [:index| |cstring|
    	cstring := (pathArray
    		proxyAt: (index - 1) * 4
    		result: CString new).
    	blk value: cstring asString]! !

"December 4, 2007 -> 3:37:26"!

"System saved" !
"December 4, 2007 -> 3:43:41"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'private' !
terminalPathsDo: blk <[FilePath]>

    | glob pathArray strings patternString |
   glob := GlobT new allocate.
   patternString := CString for: self pattern.
   {{<libc ExternalProxy glob>
    	pattern: patternString
    	flags: 0
    	ignore: 0
    	glob: glob}}.
	[glob pathsDo: [:pathString| blk value: (FilePath for: pathString)]]
		ensure: [
			glob free.
			patternString free.]! !

"December 4, 2007 -> 3:44:19"!

(Delta mirrorFor: #GlobT) removeMethod: #free ifAbsent: [] !


"December 4, 2007 -> 3:44:52"!

"System saved" !
"December 4, 2007 -> 23:44:58"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'testing' !
isAbsolute ^<Boolean>

    ^self pattern first == $/! !

"December 4, 2007 -> 23:52:13"!

(Delta mirrorFor: #UnixFilePath) removeMethod: #win32FileAttributesIfFail: ifAbsent: [] !


"December 4, 2007 -> 23:58:6"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'copying-moving' !
moveAs: newPath <FilePath> ifFail: fail <[ExternalError]>

    | csrc <CString> cdest <CString> |
    csrc := CString for: self name.
    cdest := CString for: newPath name.
    [   {{<libc ExternalProxy rename>
                source: csrc
                dest: cdest
        }} isAllOnes
            ifTrue: [ fail value: 'Error moving file.' asSymbol ]
    ] ensure:
        [   csrc free.
            cdest free  ]! !

"December 4, 2007 -> 23:59:30"!

"System saved" !
"December 5, 2007 -> 0:8:45"!

(Delta mirrorFor: #UnixFileDescriptor) removeMethod: #printLastError ifAbsent: [] !


"December 5, 2007 -> 0:9:29"!

(Delta mirrorFor: #UnixFileDescriptor) removeMethod: #sectorSize ifAbsent: [] !


"December 5, 2007 -> 0:13:28"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'testing' !
usesCrLfConvention ^<Boolean>

    ^false! !

"December 5, 2007 -> 0:15:9"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLMapName: name <Str> ^<Str>
    name = 'libc' ifTrue: [^'libc.so.6'].
    ^name! !

"December 5, 2007 -> 0:37:10"!

"System saved" !
"December 6, 2007 -> 0:31:8"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'iterating' !
elementsDo: blk <[FilePattern]>

    | s <CharacterReadStream> |

    s := self pattern readStream.
    [ s atEnd ]
        whileFalse:
            [   | next <Str> |
                next := s upTo: $/.
                next isEmpty
                    ifFalse: [ blk value: (FilePattern for: next)] ]! !

"December 6, 2007 -> 0:31:10"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'iterating' !
elementsDo: blk <[FilePattern]>

    | s <CharacterReadStream> |

    s := self pattern readStream.
    [ s atEnd ]
        whileFalse:
            [   | next <Str> |
                next := s upTo: $/.
                next isEmpty
                    ifFalse: [ blk value: (FilePattern for: next)] ]! !

"December 6, 2007 -> 0:31:39"!

"System saved" !
"December 6, 2007 -> 0:42:53"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'iterating' !
pathsDo: blk <[FilePath]>

	self terminalPathsDo: blk
    "| els <SeqCltn[FilePattern]> i <Int> |
    els := self elements.
    i := self firstWildElementOf: els
                ifFail: [ ^self shouldNotHappen ].
    i = els size
        ifTrue: [ self terminalPathsDo: blk ]
        ifFalse: [  | rest <FilePattern> |
                        i + 1 = els size
                            ifTrue: [ rest := els last ]
                            ifFalse: [ rest := FilePattern forAll: (els copyFrom: i + 1 to: els size) ].
                        (FilePattern forAll: (els copyFrom: 1 to: i))
                            pathsDo:
                                [ :fp <FilePath> |
                                    fp isDirectory
                                        ifTrue: [ (fp, rest) pathsDo: blk ]     ]
                     ]"! !

"December 6, 2007 -> 0:43:35"!

"System saved" !
"December 6, 2007 -> 1:7:16"!

! (Delta mirrorFor: #BasicReadStream) methodsFor: 'smalltalk filein' !
fileIn

	(CharacterReadConverter on: self) fileIn! !

"December 6, 2007 -> 1:9:23"!

"System saved" !"December 6, 2007 -> 2:16:15"!Delta define: #SimpleTest as: ((Class subclassOf: 'Object' instanceVariables: '')) !"December 6, 2007 -> 2:16:21"!"System saved" !
"December 6, 2007 -> 2:17:32"!

(Delta mirrorFor: #SimpleTest) removeDefinitionIfFail: [] !


"December 6, 2007 -> 2:17:53"!

"System saved" !"December 6, 2007 -> 2:25:14"!Delta define: #SimpleTest as: ((Class subclassOf: 'Object' instanceVariables: '')) !"December 6, 2007 -> 2:25:20"!"System saved" !
"December 7, 2007 -> 0:33:55"!

(Delta mirrorFor: #SimpleTest) removeDefinitionIfFail: [] !


"December 7, 2007 -> 0:39:42"!

"System saved" !
"December 8, 2007 -> 17:50:0"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLMapName: name <Str> ^<Str>
    name = 'libc' ifTrue: [^'libc.so.6'].
    ^name, '.so'! !

"December 8, 2007 -> 17:50:33"!

"System saved" !
"December 8, 2007 -> 22:34:23"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'os specific' !
currentThreadId
	" stub to allow compatibility with Win32 specifics of process "
	self deltaHack.
	^ {{ primitiveCurrentThreadId }}! !

"December 8, 2007 -> 22:34:56"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'os specific' !
currentThreadId
	" stub to allow compatibility with Win32 specifics of process "
	^ {{ primitiveCurrentThreadId }}! !

"December 8, 2007 -> 22:35:5"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'os specific' !
currentThreadId

	^ {{ primitiveCurrentThreadId }}! !

"December 8, 2007 -> 22:35:23"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'os specific' !
currentThreadId

	^ {{ primitiveCurrentThreadId }}! !

"December 8, 2007 -> 22:36:14"!

"System saved" !
"December 8, 2007 -> 22:49:41"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'os specific' !
currentThreadId
	^ 0
	"^ {{ primitiveCurrentThreadId }}"! !

"December 8, 2007 -> 22:50:4"!

"System saved" !
"December 8, 2007 -> 22:57:3"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'os specific' !
currentThreadId
	"^ 0"
	^ {{ primitiveCurrentThreadId }}! !

"December 8, 2007 -> 22:57:33"!

"System saved" !
"December 9, 2007 -> 19:45:6"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLMapName: name <Str> ^<Str>
    name = 'libc' ifTrue: [^'libc.so'].
    ^name, '.so'! !

"December 9, 2007 -> 19:45:26"!

"System saved" !
"December 9, 2007 -> 20:21:22"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLMapName: name <Str> ^<Str>
    name = 'libc' ifTrue: [^'libc.so.6'].
    ^name, '.so'! !

"December 9, 2007 -> 20:23:17"!

"System saved" !
"April 29, 2008 -> 19:10:19"!

! (Delta mirrorFor: #DeltaProtocol) methodsFor: 'Unclassified' !
isRelevantSubstitution: s <Substitution> ^ <Boolean>
" In our system, substitutions are constructed in a structured fashion.
Consequently, either all the keys of a substitution are relevant, or none are.
We choose an arbitrary key, check if it is relevant, and return the result.
"
| res |

s keys do:[: k <Symbol> | 
                     ^self relevantTypeVars includes: k.
                    ].
^false! !

"April 29, 2008 -> 19:10:37"!

"System saved" !
"April 30, 2008 -> 0:16:41"!

! (Delta mirrorFor: #Set) methodsFor: 'adding' !
add: anElement

	anElement isNil ifTrue: [^self].
	super add: anElement! !

"April 30, 2008 -> 0:16:41"!

! (Delta mirrorFor: #Set) methodsFor: 'adding' !
add: anElement
"workaround for problem with adding nil to a set"
self deltaHack.
	anElement isNil ifTrue: [^self].
	super add: anElement! !

"April 30, 2008 -> 0:17:4"!

"System saved" !
"May 2, 2008 -> 2:39:7"!

! (Delta mirrorFor: #Set) methodsFor: 'adding' !
include: anElement
"workaround for problem with adding nil to a set"
self deltaHack.
	anElement isNil ifTrue: [^self].
	super include: anElement! !

"May 2, 2008 -> 9:56:38"!

"System saved" !
"May 18, 2008 -> 2:18:6"!

Delta define: #ExceptionSelector as: (
Protocol superProtocol: '<Object>') !


"May 18, 2008 -> 2:18:6"!

(Delta mirrorFor: #ExceptionSelector)
comment: 
'Defines the <exceptionSelector> protocol from the ANSI standard.'!


"May 18, 2008 -> 2:18:6"!

! (Delta mirrorFor: #ExceptionSelector) methodsFor: 'exception selector' !
handles: anException ! !

"May 18, 2008 -> 2:18:14"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 18, 2008 -> 2:18:14"!

(Delta mirrorFor: #BlockExceptionSelector)
comment: 
'Determines whether an exception can be handled by evaluating the handlesBlock.'!


"May 18, 2008 -> 2:18:14"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'test' !
test	self testShouldHandleWhenHandleBlockReturnsTrue;		testShouldPassExceptionToHandlesBlock! !

"May 18, 2008 -> 2:18:14"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'test' !
testShouldPassExceptionToHandlesBlock	|exception selector|	exception := Object new.	selector := BlockExceptionSelector handlesBlock: [:ex| [ex == exception] verify].	selector handles: exception! !

"May 18, 2008 -> 2:18:14"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'test' !
testShouldHandleWhenHandleBlockReturnsTrue	|canHandle selector|		selector := BlockExceptionSelector					handlesBlock: [:ex| canHandle].	canHandle := true.	[selector handles: nil] verify.	canHandle := false.	[(selector handles: nil) not] verify! !

"May 18, 2008 -> 2:18:14"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'instantiation' !
handlesBlock: block 	^self new		handlesBlock: block;		yourself! !

"May 18, 2008 -> 2:18:14"!

! (Delta mirrorFor: #BlockExceptionSelector) methodsFor: 'initialization' !
handlesBlock: block	handlesBlock := block ! !

"May 18, 2008 -> 2:18:14"!

! (Delta mirrorFor: #BlockExceptionSelector) methodsFor: 'exception selector' !
handles: exceptionDescriptor	^handlesBlock value: exceptionDescriptor! !

"May 18, 2008 -> 2:18:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 18, 2008 -> 2:18:22"!

(Delta mirrorFor: #BlockExceptionHandler)
comment: 
'Exception handler for an exception. Handles the exception by invoking its handleBlock.'!


"May 18, 2008 -> 2:18:22"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'tests' !
test	self testShouldInvokeHandlerBlockWithException! !

"May 18, 2008 -> 2:18:22"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'tests' !
testShouldInvokeHandlerBlockWithException	|handled exception|	handled := false.	exception = Object new.	(BlockExceptionHandler		handleBlock: [:ex| [ex == exception] verify.			handled := true])		handle: exception.	[handled] verify! !

"May 18, 2008 -> 2:18:22"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
handleBlock: block	^self new		handleBlock: block;		yourself! !

"May 18, 2008 -> 2:18:22"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
new	^super new initialize! !

"May 18, 2008 -> 2:18:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'private initialization' !
initialize	handleBlock := [:exception|].	passBlock := [:exception|].! !

"May 18, 2008 -> 2:18:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'private initialization' !
handleBlock: block	handleBlock := block! !

"May 18, 2008 -> 2:18:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
canHandleSignal: exception	^false! !

"May 18, 2008 -> 2:18:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
handle: exception return: aBlock	^aBlock value: (handleBlock value: exception)! !

"May 18, 2008 -> 2:18:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
handle: exception	^handleBlock value: exception! !

"May 18, 2008 -> 2:18:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
passBlock: block	passBlock := block! !

"May 18, 2008 -> 2:18:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
pass: exception	passBlock value: exception! !

"May 18, 2008 -> 2:18:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
nextHandler	^nil! !

"May 18, 2008 -> 2:18:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
nextHandler: ignored! !

"May 18, 2008 -> 2:18:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
returnBlock: block	returnBlock := block! !

"May 18, 2008 -> 2:18:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
return: value	returnBlock value: value! !

"May 18, 2008 -> 2:18:30"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 18, 2008 -> 2:18:30"!

(Delta mirrorFor: #BlockExceptionDescriptor)
comment: 
'Implements the <exceptionDescriptor> protocol from the ANSI standard using configurable actionsdefined as blocks. Intended to be used primarily as a testing aid.'!


"May 18, 2008 -> 2:18:30"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'instantiation' !
new	^super new		initialize;		yourself! !

"May 18, 2008 -> 2:18:30"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'test' !
test	self testDefaultActionShouldInvokeDefaultActionBlock;		testDefaultDefault;		testHandlerShouldDelegateToHandlerBlock! !

"May 18, 2008 -> 2:18:30"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'test' !
testDefaultDefault	|exception wasInvoked|	exception := BlockExceptionDescriptor new.	exception defaultAction! !

"May 18, 2008 -> 2:18:30"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'test' !
testDefaultActionShouldInvokeDefaultActionBlock	|exception wasInvoked|	exception := BlockExceptionDescriptor new.	wasInvoked := false.	exception defaultActionBlock: [wasInvoked := true].	exception defaultAction.	[wasInvoked] verify! !

"May 18, 2008 -> 2:18:30"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'test' !
testHandlerShouldDelegateToHandlerBlock	|descriptor actualHandler|		descriptor := BlockExceptionDescriptor new.	descriptor handlerBlock: [:handler| actualHandler := handler].	descriptor handler: #handler.	[actualHandler == #handler] verify! !

"May 18, 2008 -> 2:18:30"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
defaultActionBlock: block	defaultBlock := block! !

"May 18, 2008 -> 2:18:30"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
handlerBlock: block	handlerBlock := block ! !

"May 18, 2008 -> 2:18:30"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
handler: handler	handlerBlock value: handler ! !

"May 18, 2008 -> 2:18:30"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'initialization' !
initialize	defaultBlock := [].	handlerBlock := [:ignore|]! !

"May 18, 2008 -> 2:18:30"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'exception descriptor' !
defaultAction	defaultBlock value! !

"May 18, 2008 -> 2:18:37"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 18, 2008 -> 2:18:38"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 18, 2008 -> 2:18:38"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 18, 2008 -> 2:18:38"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 18, 2008 -> 2:18:38"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 18, 2008 -> 2:18:38"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 18, 2008 -> 2:18:38"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 18, 2008 -> 2:18:38"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 18, 2008 -> 2:18:38"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 18, 2008 -> 2:18:38"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 18, 2008 -> 2:18:38"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 18, 2008 -> 2:18:38"!

(Delta mirrorFor: #BlockExceptionHandler)
comment: 
'Exception handler for an exception. Handles the exception by invoking its handleBlock.'!


"May 18, 2008 -> 2:18:38"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'tests' !
test	self testShouldInvokeHandlerBlockWithException! !

"May 18, 2008 -> 2:18:38"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'tests' !
testShouldInvokeHandlerBlockWithException	|handled exception|	handled := false.	exception = Object new.	(BlockExceptionHandler		handleBlock: [:ex| [ex == exception] verify.			handled := true])		handle: exception.	[handled] verify! !

"May 18, 2008 -> 2:18:38"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
handleBlock: block	^self new		handleBlock: block;		yourself! !

"May 18, 2008 -> 2:18:38"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
new	^super new initialize! !

"May 18, 2008 -> 2:18:38"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'private initialization' !
initialize	handleBlock := [:exception|].	passBlock := [:exception|].! !

"May 18, 2008 -> 2:18:38"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'private initialization' !
handleBlock: block	handleBlock := block! !

"May 18, 2008 -> 2:18:38"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
canHandleSignal: exception	^false! !

"May 18, 2008 -> 2:18:38"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
handle: exception return: aBlock	^aBlock value: (handleBlock value: exception)! !

"May 18, 2008 -> 2:18:38"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
handle: exception	^handleBlock value: exception! !

"May 18, 2008 -> 2:18:38"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
passBlock: block	passBlock := block! !

"May 18, 2008 -> 2:18:38"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
pass: exception	passBlock value: exception! !

"May 18, 2008 -> 2:18:38"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
nextHandler	^nil! !

"May 18, 2008 -> 2:18:38"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
nextHandler: ignored! !

"May 18, 2008 -> 2:18:38"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
returnBlock: block	returnBlock := block! !

"May 18, 2008 -> 2:18:38"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
return: value	returnBlock value: value! !

"May 18, 2008 -> 2:18:43"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 18, 2008 -> 2:18:43"!

(Delta mirrorFor: #LinkedExceptionHandler)
comment: 
'Exception handler for an exception. Invokes its handleBlock when asked to handle an exceptionthat matches its exceptionSelector. If the exception does not match its exceptionSelector it passesthe exception on to the nextHandler. If the nextHandler is undefined signal an UnhandledExceptionError.This class is internal to the exception handling framework. There should be no need for code outside of thisframework to interact with instances of ExceptionHandler.'!


"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
test	self testShouldInvokeHandleBlockWhenExceptionMatches;		testShouldInvokeExceptionsDefaultActionWhenNoNextHandler;		testShouldDelegateToNextHandlerWhenNoMatch;		testHandlerShouldSetHandlerOnException;		testPassShouldDeferToNextHandler;		testReturnShouldEvaluateReturnBlock! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testShouldInvokeHandleBlockWhenExceptionMatches	|handled trueSelector exception|	handled := false.	exception := BlockExceptionDescriptor new.	trueSelector := BlockExceptionSelector handlesBlock: [:ex| true].	(LinkedExceptionHandler		on: trueSelector		do: [:ex| [ex == exception] verify.			handled := true])		handle: exception.	[handled] verify! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testShouldDelegateToNextHandlerWhenNoMatch	|handled falseSelector exception nextHandler|	handled := false.	falseSelector := BlockExceptionSelector handlesBlock: [:ex| false].	exception := BlockExceptionDescriptor new.	nextHandler := (BlockExceptionHandler						handleBlock: [:ex| [ex == exception] verify.										handled := true]).	(LinkedExceptionHandler on: falseSelector do: [:ex| self shouldNotHappen])		nextHandler: nextHandler;		handle: exception.	[handled] verify! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testShouldInvokeExceptionsDefaultActionWhenNoNextHandler	|handled falseSelector exception|	handled := false.	falseSelector := BlockExceptionSelector handlesBlock: [:ex| false].	exception := BlockExceptionDescriptor new.	exception defaultActionBlock: [handled := true].	(LinkedExceptionHandler on: falseSelector do: [:ex| self shouldNotHappen])		handle: exception.	[handled] verify! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testPassShouldDeferToNextHandler	|handler trueSelector exception wasPassed nextHandler|	trueSelector := BlockExceptionSelector handlesBlock: [:ex| true].	exception := BlockExceptionDescriptor new.		handler := LinkedExceptionHandler on: trueSelector do: [:ex| ].	nextHandler := BlockExceptionHandler handleBlock: [:ex| wasPassed := true].	handler nextHandler: nextHandler.		wasPassed := false.	handler pass: exception.	[wasPassed] verify	! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testReturnShouldEvaluateReturnBlock	|handler result |	handler := LinkedExceptionHandler					on: nil					do: [:ex| ]					return: [:returnValue| result := returnValue].	handler return: #value.	[result == #value] verify! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testHandlerShouldSetHandlerOnException	|handler trueSelector exception assignedHandler|	trueSelector := BlockExceptionSelector handlesBlock: [:ex| true].	exception := BlockExceptionDescriptor new.	exception handlerBlock: [:handler| assignedHandler := handler].	handler := LinkedExceptionHandler on: trueSelector do: [:ex| ].	[assignedHandler ~~ handler] verify.	handler handle: exception.	[assignedHandler == handler] verify! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'exceptionBuilder' !
on: anExceptionSelector do: handleBlock	^self new		on: anExceptionSelector do: handleBlock return: [:value|] outer: nil;		yourself! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'exceptionBuilder' !
on: anExceptionSelector do: handleBlock return: returnBlock	^self new		on: anExceptionSelector do: handleBlock return: returnBlock outer: nil;		yourself! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'exceptionBuilder' !
on: anExceptionSelector do: handleBlock return: returnBlock outer: outerBlock	^self new		on: anExceptionSelector do: handleBlock return: returnBlock outer: outerBlock;		yourself! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock	exceptionSelector := anExceptionSelector.	handleBlock := block.	returnBlock := aReturnBlock.	nextHandler := BlockExceptionHandler handleBlock: [:ex| ex defaultAction] ! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
nextHandler: exceptionHandler	nextHandler := exceptionHandler ! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
handle: exception	self handle: exception		return: returnBlock! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
protect: aBlock	Processor activeProcess pushHandler: self.	^[(self evaluateProtectee: aBlock) value]		ensure: [Processor activeProcess popHandler]! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock	|result|	protectee := aBlock.	retryBlock := [^[self evaluateProtectee: protectee]].	result := protectee value.	^[result]! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
retry		retryBlock value! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
retryUsing: aBlock		protectee := aBlock.	retryBlock value! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
canHandleSignal: exception	^(exceptionSelector handles: exception)		or: [nextHandler notNil 		and: [nextHandler canHandleSignal: exception]]! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
handle: exception return: aReturnBlock	exception handler: self.	^(exceptionSelector handles: exception)		ifTrue: [aReturnBlock value: (handleBlock value: exception)]		ifFalse: [nextHandler handle: exception return: aReturnBlock]! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
outer: exception return: aReturnBlock	^nextHandler handle: exception return: aReturnBlock! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
pass: exception	^nextHandler handle: exception! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
return: aValue	returnBlock value: aValue! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
nextHandler	^nextHandler! !

"May 18, 2008 -> 2:18:50"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"May 18, 2008 -> 2:18:50"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"May 18, 2008 -> 2:18:50"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"May 18, 2008 -> 2:18:50"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"May 18, 2008 -> 2:18:50"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"May 18, 2008 -> 2:18:50"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"May 18, 2008 -> 2:18:50"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"May 18, 2008 -> 2:18:50"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"May 18, 2008 -> 2:18:50"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"May 18, 2008 -> 2:18:50"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"May 18, 2008 -> 2:18:50"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"May 18, 2008 -> 2:18:50"!

(Delta mirrorFor: #Process)
comment: 
'Tags: %BlueBook %User

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license
'!


"May 18, 2008 -> 2:18:50"!

! (Delta mirrorFor: #Process) classSide methodsFor: 'file out' !
fileOutSignature ^<Integer>
    ^80! !

"May 18, 2008 -> 2:18:50"!

! (Delta mirrorFor: #Process) classSide methodsFor: 'instance creation' !
for: block <[]> ^<Instance>
	"Create and return a new process that will execute the block at the
	 specified priority.  The new process is suspended."

	| i <Instance> |
	i := (guaranteed <Instance>
		{{self primitiveProcessCreate: [ i recordId. block value ]
				ifFail: [ :err <Symbol> | self error: err ]
		}}
	  ) initFor: block.
	^i! !

"May 18, 2008 -> 2:18:50"!

! (Delta mirrorFor: #Process) classSide methodsFor: 'instance creation' !
primitiveCreate: block! !

"May 18, 2008 -> 2:18:50"!

! (Delta mirrorFor: #Process) classSide methodsFor: 'testing' !
test

	self testHandleShouldInvokeDefaultAction;
		 testPushHandlerShouldReplaceDefaultHandler;
		 testPushHandlerShouldDeferToOuterHandlerWhenExceptionDoesntMatch;
		 testPushHandlerShouldDeferToDefaultHandlerWhenExceptionDoesntMatch! !

"May 18, 2008 -> 2:18:50"!

! (Delta mirrorFor: #Process) classSide methodsFor: 'testing' !
testHandleShouldInvokeDefaultAction

	|exception wasInvoked|
	wasInvoked := false.
	exception := BlockExceptionDescriptor new.
	exception defaultActionBlock: [wasInvoked := true].
	Processor activeProcess handle: exception.
	[wasInvoked] verify.! !

"May 18, 2008 -> 2:18:50"!

! (Delta mirrorFor: #Process) classSide methodsFor: 'testing' !
testPushHandlerShouldReplaceDefaultHandler

	|process exceptionSelector wasInvoked exception|
	process := Processor activeProcess.
	exception := BlockExceptionDescriptor new.
	wasInvoked := false.
	exceptionSelector := BlockExceptionSelector handlesBlock: [:ex| true].
	[process pushHandler: (LinkedExceptionHandler
							on: exceptionSelector
							do: [:ex| wasInvoked := true]).
	process handle: exception.
	[wasInvoked] verify]
		ensure: [process popHandler]! !

"May 18, 2008 -> 2:18:50"!

! (Delta mirrorFor: #Process) classSide methodsFor: 'testing' !
testPushHandlerShouldDeferToDefaultHandlerWhenExceptionDoesntMatch

	|process exceptionSelector wasInvoked exception|
	wasInvoked := false.
	exception := BlockExceptionDescriptor new.
	exception defaultActionBlock: [wasInvoked := true].
	exceptionSelector := BlockExceptionSelector handlesBlock: [:ex| false].
	process := Processor activeProcess.
	[process pushHandler: (LinkedExceptionHandler
							on: exceptionSelector
							do: [:ex| ]).
	process handle: exception.
	[wasInvoked] verify]
		ensure: [process popHandler]! !

"May 18, 2008 -> 2:18:50"!

! (Delta mirrorFor: #Process) classSide methodsFor: 'testing' !
testPushHandlerShouldDeferToOuterHandlerWhenExceptionDoesntMatch

	|process trueSelector falseSelector wasInvoked exception outerHandler|
	wasInvoked := false.
	exception := BlockExceptionDescriptor new.
	exception defaultActionBlock: [].
	trueSelector := BlockExceptionSelector handlesBlock: [:ex| true].
	falseSelector := BlockExceptionSelector handlesBlock: [:ex| false].
	process := Processor activeProcess.
	outerHandler := (LinkedExceptionHandler
							on: trueSelector
							do: [:ex| wasInvoked := true]).
	[process pushHandler: outerHandler.
	process pushHandler: (LinkedExceptionHandler
							on: falseSelector
							do: [:ex| ]).
	process handle: exception.
	[wasInvoked] verify]
		ensure: [process popHandler.
			process popHandler]
! !

"May 18, 2008 -> 2:18:50"!

! (Delta mirrorFor: #Process) methodsFor: 'accessing' !
priority ^<Int>

	^priority! !

"May 18, 2008 -> 2:18:50"!

! (Delta mirrorFor: #Process) methodsFor: 'accessing' !
priority: prio <Int>

	priority := prio! !

"May 18, 2008 -> 2:18:50"!

! (Delta mirrorFor: #Process) methodsFor: 'accessing' !
processError ^ <ProcessError>

	^processError
! !

"May 18, 2008 -> 2:18:50"!

! (Delta mirrorFor: #Process) methodsFor: 'accessing' !
status ^<Symbol>
	"One of:
		#Initialized				- State right after creation.
		#Yielded					- Gave up control by calling yield.
		#InAsyncDLL			- Gave up control but continues to execute asynchronous DLL.
		#Stopped				- Gave up control by calling stop.
		#Preempted			- Was preempted by system.
		#Running					- Currently running
		#Completed			- Ran to completion.
		#Killed						- The process has been terminated.
		#BooleanError		- A boolean was expected at hardcoded control structure.
		#LookupError			- The receiver does not understand doesNotUnderstand:.
		#PrimitiveLookupError	- Binding a primitive failed.
		#DLLLookupError				 - Binding a DLL function failed.
		#NLRError				- Context for NLR did not exist.
		#StackOverflow		- Stack exhausted.
	"

	^{{self primitiveProcessStatus}}! !

"May 18, 2008 -> 2:18:50"!

! (Delta mirrorFor: #Process) methodsFor: 'control' !
resume

	Processor resume: self! !

"May 18, 2008 -> 2:18:50"!

! (Delta mirrorFor: #Process) methodsFor: 'control' !
suspend

	Processor suspend: self.
	Processor activeProcess = self
		ifTrue: [ self yield ]! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'control' !
terminate

	Processor terminating: self.
	self vmTerminate.	! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'control' !
waitUntilDead
	"can be called after a process has been terminated to wait until it has completed
		unwinding its stack etc, and is truly dead.  This loops currently, so it is not
		a good way for waiting for the death of a process that has not been terminated.
		This may never return if the process that has been terminated does not ever
		finish cleaning up."
	
	[ self running ]
		whileTrue: [ Processor yield ]! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handle: exception

	^self handlerChain handle: exception! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler handleBlock: [:ex| ex defaultAction]].
	^handlerChain! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
pushHandler: handler

	handler nextHandler: self handlerChain.
	handlerChain := handler ! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
popHandler

	handlerChain := self handlerChain nextHandler ! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
resetHandlers

	handlerChain := nil

! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'file out' !
fileOutSignature ^<Integer>
    ^112! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'private' !
register

	Processor register: self.! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'private' !
vmTerminate

	{{self primitiveProcessTerminateIfFail: [ :err <Symbol> | self error: err ]}}! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'private-initialization' !
initFor: block <[]>

	body := block.

	self register.
	
! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'private-initialization' !
recordId

	win32Handle := Platform currentThreadId! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'restricted' !
activationStack ^ <Array[Activation]>

	^{{self primitiveProcessStackLimit: 100 ifFail: [ :err <CompressedSymbol>  | self error: err]}}! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'restricted' !
processError: e <ProcessError>

	processError := e
! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'restricted' !
stopInEvaluator

	Processor stopInEvaluator: self! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'restricted' !
traceStack

	{{self primitiveProcessTraceStack: 20 ifFail: [ :err <Symbol> | self error: err]}}
! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'restricted' !
win32Handle ^<Win32Handle>
	"This is valid only after the process has begun to actually execute"

	^win32Handle! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'restricted' !
yield
	{{primitiveProcessYield}}! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'testing' !
running ^<Boolean>
	"Not suspended, dying, or dead. (This includes processes blocked in async dll calls)"

	^Processor isRunning: self! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'testing' !
suspended ^<Boolean>
	"Not on the running list, but can be resumed"

	| s <Symbol> |
	self running
		ifTrue: [ ^false ].
	s := self status.
	^s == #Yielded
		or: [ s == #InAsyncDLL
		or: [ s == #Initialized
		or: [ s == #Preempted
		or: [ s == #Stopped ]   ]]]! !

"May 18, 2008 -> 2:19:14"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 18, 2008 -> 2:19:14"!

Delta define: #TestException as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultActionBlock')) !


"May 18, 2008 -> 2:19:14"!

(Delta mirrorFor: #Exception)
comment: 
'Base class of the exception hierarchy. Implements the core of the ANSI exception handling protocols'!


"May 18, 2008 -> 2:19:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
test	self testSignalShouldInvokeProcessHandler;		testPassShouldDeferToOuterHandler;		testPassShouldNotReturn;		testPassShouldInvokeDefaultActionWithoutReturning;		testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable;		testOuterShouldInvokeAndReturnDefaultActionWhenResumable;		testOuterTwiceShouldInvokeSurroundingHandlerTwice;		testResumeShouldReturnAsValueOfOuter;		testResumeShouldReturnFromSignal;		testResumeWithValueShouldReturnFromSignal;		testReturnShouldDelegateToHandler;		testIsNestedShouldBeFalseWithNoHandler;		testIsNestedShouldBeTrueWhenOuterHandlerHandles;		testIsNestedShouldBeFalseWhenOuterHandlerDoesntHandle;		testIsNestedShouldBeTrueWhenOuterOuterHandlerHandles;		testResignalAsShouldRestoreSignalEnvironment;		testRetryShouldReevaluateProtectee;		testRetryUsingShouldReplaceProtectee! !

"May 18, 2008 -> 2:19:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testPassShouldDeferToOuterHandler	|wasPassed|	wasPassed := false.	[[Exception signal]		on: Exception		do: [:ex| ex pass]]			on: Exception			do: [:ex| wasPassed := true].	[wasPassed] verify! !

"May 18, 2008 -> 2:19:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testPassShouldNotReturn	[([[Exception signal]		on: Exception		do: [:ex| ex pass.			self shouldNotHappen]]			on: Exception			do: [:ex| #result]) == #result] verify! !

"May 18, 2008 -> 2:19:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testPassShouldInvokeDefaultActionWithoutReturning	[([|result|		result := (TestException defaultActionBlock: [#result])						signal.		[result == #result] verify.		result]			on: TestException			do: [:ex| ex pass.				self shouldNotHappen]) == #result] verify! !

"May 18, 2008 -> 2:19:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable	[([|result|		result := (TestException defaultActionBlock: [#result])						signal.		[result == #result] verify.		result]			on: TestException			do: [:ex| ex outer.				self shouldNotHappen]) == #result] verify! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable	|outer result|	[(TestException defaultActionBlock: [#result])		resumable: true;		signal]			on: TestException			do: [:ex| outer := ex outer.				result := #returned].	[result == #returned] verify.	[outer == #result] verify.! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testOuterTwiceShouldInvokeSurroundingHandlerTwice	|count|	count := 0.	[[(TestException defaultActionBlock: [-1])			resumable: true;			signal]		on: TestException		do: [:ex| ex outer.				ex outer]]			on: TestException			do: [:ex| count := count + 1].	[count == 2] verify! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testResumeShouldReturnAsValueOfOuter	|result|	[[Exception signal]	 	on: Exception	 	do: [:ex| result := ex outer]]	 		on: Exception	 		do: [:ex| ex resume: #result].	[result == #result] verify! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testResumeWithValueShouldReturnFromSignal	|result|	[result := Exception signal]	 	on: Exception	 	do: [:ex| ex resume: #result].	[result == #result] verify! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testResumeShouldReturnFromSignal	|wasResumed|	wasResumed := false.	[Exception signal.	 wasResumed := true]	 	on: Exception	 	do: [:ex| ex resume].	[wasResumed] verify! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testSignalShouldInvokeProcessHandler		|wasInvoked|	wasInvoked := false.	Processor activeProcess 		pushHandler: (BlockExceptionHandler 						handleBlock: [:ex| wasInvoked := true]).	Exception signal.	[[wasInvoked] verify]		ensure: [Processor activeProcess popHandler]! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testReturnShouldDelegateToHandler		|exception handler result|	exception := Exception new.	handler := BlockExceptionHandler new.	result := #invalid.	handler returnBlock: [:value| result := value].	exception handler: handler.	exception return.	[result isNil] verify! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testIsNestedShouldBeFalseWithNoHandler		|exception|	exception := Exception new.	[exception isNested not] verify! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testIsNestedShouldBeTrueWhenOuterHandlerHandles		|result|	[[Exception signal]		on: Exception		do: [:ex| result := ex isNested]]			on: Exception			do: [:ex| self shouldNotHappen]. 	[result] verify! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testRetryUsingShouldReplaceProtectee		|log count|	log := String new writeStream.	count := 0.	[[Exception signal] ensure: [log nextPutAll: 'unwind ']]		on: Exception		do: [:ex|			log nextPutAll: 'handle '.			count := count + 1.			count = 1 ifTrue: [ex retryUsing: [log nextPutAll: 'using '.												Exception signal]]].	[log contents = 'handle unwind using handle '] verify! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testRetryShouldReevaluateProtectee		|count|	count := 0.	[count := count + 1.	count == 1 ifTrue:[Exception signal]]		on: Exception		do: [:ex| ex retry].	[count == 2] verify! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testResignalAsShouldRestoreSignalEnvironment		|log|	log := String new writeStream.	[[Exception signal]		on: TestException		do: [:ex| log nextPutAll: 'resignal']]			on: Exception			do: [:ex|				[log nextPutAll: 'signal '. 				ex resignalAs: TestException new]					ifCurtailed: [log nextPutAll: 'curtail ']].	[log contents = 'signal curtail resignal'] verify! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testIsNestedShouldBeTrueWhenOuterOuterHandlerHandles		|result|	[[[Exception signal]		on: Exception		do: [:ex| result := ex isNested]]			on: TestException			do: [:ex|]]				on: Exception				do: [:ex|]. 	[result] verify! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testIsNestedShouldBeFalseWhenOuterHandlerDoesntHandle		|result|	[[Exception signal]		on: Exception		do: [:ex| result := ex isNested]]			on: TestException			do: [:ex|]. 	[result not] verify! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'exceptionBuilder' !
tag: t	"This message is not specified in the ANSI protocol, but that looks like an oversight because #tag is specified, and the spec states that the signaler may store the tag value."	tag := t! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'exceptionDescription' !
tag	"Return an exception's tag value."	^tag == nil		ifTrue: [self messageText]		ifFalse: [tag]! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
isNested	"Determine whether the current exception handler is within the scope of another handler for the same exception."	^ handler notNil and: [handler nextHandler canHandleSignal: self]! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
outer	"Evaluate the enclosing exception action and return to here instead of signal if it resumes (see #resumeUnchecked:)."	| oldHandler oldResume |	self isResumable ifFalse: [		self pass.	].		[oldResume := resumeBlock.	resumeBlock := [:value| ^value].	(oldHandler := handler) outer: self return: [:value| ^value]]		ensure: [handler := oldHandler.				resumeBlock := oldResume]! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
pass	"Yield control to the enclosing exception action for the receiver."	passBlock value! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resignalAs: replacementException	"Signal an alternative exception in place of the receiver."	resignalBlock value: replacementException! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resume	"Return from the message that signaled the receiver."	self resume: nil! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resume: resumptionValue	"Return resumptionValue as the value of the signal message."	resumeBlock value: resumptionValue! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
retry	"Abort an exception handler and re-evaluate its protected block."	handler retry! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
retryUsing: alternativeBlock	"Abort an exception handler and evaluate a new block in place of the handler's protected block."	handler retryUsing: alternativeBlock! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
return	"Return nil as the value of the block protected by the active exception handler."	self return: nil! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
return: returnValue	"Return the argument as the value of the block protected by the active exception handler."	handler return: returnValue! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
description	"Return a textual description of the exception."	| desc mt |	desc := self class name asString.	^(mt := self messageText) == nil		ifTrue: [desc]		ifFalse: [desc, ': ', mt]! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
messageText	"Return an exception's message text."	^messageText! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
printOn: stream	stream nextPutAll: self description! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
messageText: signalerText	"Set an exception's message text."	messageText := signalerText! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
signal	^self privateSignal value! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
privateSignal	"Ask ContextHandlers in the sender chain to handle this signal.  The default is to execute and return my defaultAction."		resignalBlock := [:ex| ^[ex signal]].	resumeBlock := [:result| ^[result]].	passBlock := [^[handler pass: self]].	Processor activeProcess handle: self.	^[]! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
signal: signalerText	"Signal the occurrence of an exceptional condition with a specified textual description."	self messageText: signalerText.	^ self signal! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
defaultAction	"The default action taken if the exception is signaled."	self subclassResponsibility! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
isResumable	"Determine whether an exception is resumable."	^ true! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
handler: aHandler	handler := aHandler! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionInstantiator' !
signal	"Signal the occurrence of an exceptional condition."	^ self new signal! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionInstantiator' !
signal: signalerText	"Signal the occurrence of an exceptional condition with a specified textual description."	^ self new signal: signalerText! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionSelector' !
, anotherException	"Create an exception set.""	^ExceptionSet new		add: self;		add: anotherException;		yourself"! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionSelector' !
handles: exception	"Determine whether an exception handler will accept a signaled exception."	^ exception isKindOf: self! !

"May 18, 2008 -> 2:19:21"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock')) !


"May 18, 2008 -> 2:19:21"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock')) !


"May 18, 2008 -> 2:19:21"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock')) !


"May 18, 2008 -> 2:19:21"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock')) !


"May 18, 2008 -> 2:19:21"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock')) !


"May 18, 2008 -> 2:19:21"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock')) !


"May 18, 2008 -> 2:19:21"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock')) !


"May 18, 2008 -> 2:19:21"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"May 18, 2008 -> 2:19:21"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"May 18, 2008 -> 2:19:21"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"May 18, 2008 -> 2:19:21"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"May 18, 2008 -> 2:19:21"!

(Delta mirrorFor: #TestException)
comment: 
'Concrete exception class that can be used for testing'!


"May 18, 2008 -> 2:19:21"!

! (Delta mirrorFor: #TestException) classSide methodsFor: 'test support' !
defaultActionBlock: block	^self new		defaultActionBlock: block;		yourself! !

"May 18, 2008 -> 2:19:21"!

! (Delta mirrorFor: #TestException) methodsFor: 'test support' !
defaultActionBlock: block	defaultActionBlock := block! !

"May 18, 2008 -> 2:19:21"!

! (Delta mirrorFor: #TestException) methodsFor: 'test support' !
resumable: boolean	^resumable := boolean! !

"May 18, 2008 -> 2:19:21"!

! (Delta mirrorFor: #TestException) methodsFor: 'test support' !
isResumable	^resumable isNil		ifTrue: [false]		ifFalse: [resumable]! !

"May 18, 2008 -> 2:19:21"!

! (Delta mirrorFor: #TestException) methodsFor: 'test support' !
defaultAction	^defaultActionBlock value! !

"May 18, 2008 -> 2:19:36"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"May 18, 2008 -> 2:19:36"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"May 18, 2008 -> 2:19:36"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"May 18, 2008 -> 2:19:36"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"May 18, 2008 -> 2:19:36"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"May 18, 2008 -> 2:19:36"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"May 18, 2008 -> 2:19:36"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"May 18, 2008 -> 2:19:36"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"May 18, 2008 -> 2:19:36"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"May 18, 2008 -> 2:19:36"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"May 18, 2008 -> 2:19:36"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"May 18, 2008 -> 2:19:36"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"May 18, 2008 -> 2:19:36"!

(Delta mirrorFor: #BlockWithoutArguments)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.4 $
'!


"May 18, 2008 -> 2:19:36"!

! (Delta mirrorFor: #BlockWithoutArguments) classSide methodsFor: 'testing' !
test

	| v <Boolean> |
	
	[ v := false ] ensure: [ v := true ].
	self assert: [ v ].

	[ v := false ] ifCurtailed: [ v := true ].
	self assert: [ v not ].

	self testForUnwind: [ v := false ] onUnwind: [ v := true ].
	self assert: [ v ].

	self testForEnsure: [ v := false ] onUnwind: [ v := true ].
	self assert: [ v ].
	self testOnDoShouldInvokeDoWhenExceptionSignalled;
		testOnDoShouldPopHandler;
		testOnDoShouldInvokeNestedHandler! !

"May 18, 2008 -> 2:19:36"!

! (Delta mirrorFor: #BlockWithoutArguments) classSide methodsFor: 'testing' !
testOnDoShouldInvokeDoWhenExceptionSignalled

	|wasHandled|
	wasHandled := false.
	[Exception signal]
		on: Exception
		do: [:ex| wasHandled := true].
	[wasHandled] verify
! !

"May 18, 2008 -> 2:19:36"!

! (Delta mirrorFor: #BlockWithoutArguments) classSide methodsFor: 'testing' !
testOnDoShouldPopHandler

	|handlerInvoked descriptor selector defaultInvoked|
	Processor activeProcess resetHandlers.
	descriptor := BlockExceptionDescriptor new.
	descriptor defaultActionBlock: [defaultInvoked := true].
	selector := BlockExceptionSelector handlesBlock: [:ex| true].
	[Exception signal]
		on: selector
		do: [:ex| handlerInvoked := true].
	defaultInvoked := false.
	handlerInvoked := false.
	Processor activeProcess handle: descriptor.
	[handlerInvoked not] verify.
	[defaultInvoked] verify	
! !

"May 18, 2008 -> 2:19:36"!

! (Delta mirrorFor: #BlockWithoutArguments) classSide methodsFor: 'testing' !
testOnDoShouldInvokeNestedHandler

	|innerInvoked falseSelector outerInvoked|
	falseSelector := BlockExceptionSelector handlesBlock: [:ex| false].
	innerInvoked := false.
	outerInvoked := false.
	[[[Exception signal]
		on: falseSelector
		do: [:ex| innerInvoked := true]]
			on: Exception
			do: [:ex| outerInvoked := true].
	[innerInvoked not] verify.
	[outerInvoked] verify]
		ensure: [Processor activeProcess resetHandlers]
! !

"May 18, 2008 -> 2:19:36"!

! (Delta mirrorFor: #BlockWithoutArguments) classSide methodsFor: 'testing' !
testForEnsure: b <[]> onUnwind: b2 <[]> ^<Object>

	[ ^b value ] ensure: b2! !

"May 18, 2008 -> 2:19:36"!

! (Delta mirrorFor: #BlockWithoutArguments) classSide methodsFor: 'testing' !
testForUnwind: b <[]> onUnwind: b2 <[]> ^<Object>

	[ ^b value ] ifCurtailed: b2! !

"May 18, 2008 -> 2:19:36"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
critical ^<R>
	"This is used for very short, fast critical regions where the overhead or inconvenience
	  of a semaphore is not desired.  The argument is evaluated without any process context
	  switches taking place, so that it can perform atomic operations.  WARNING: the blk MUST
	  NOT do anything that might cause the process to block, such as any kind of I/O.  This
	  method is only appropriate for very fast atomic operations that are extremely reliable, since
	  no other processes will get a chance to run while it is being evaluated, and if it crashes,
	  it will not be debuggable, since the development & debugger processes will not be able to run."

	"%todo: implement this right.  NOTE: an interesting semantic idea: we could dramatically improve
	  the usefulnes of this if it was a critical region on the receiver, not on the system as a whole."

	^self value! !

"May 18, 2008 -> 2:19:36"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
ensure: f <[]> ^<R>

	"Use the following impl when vm bug fixed"
	"[ ^self value ] ifCurtailed: f"

	| result <R> |
	[ result := self value ] ifCurtailed: f.
	f value.
	^result! !

"May 18, 2008 -> 2:19:36"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
fork ^<Process>

	^self forkAt: Processor activePriority! !

"May 18, 2008 -> 2:19:36"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
forkAt: priority <Int> ^<Process>

	^self newProcess priority: priority; resume! !

"May 18, 2008 -> 2:19:36"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
ifCurtailed: protect <[]> ^<R>

	^guaranteed <R>
		  {{self primitiveUnwindProtect: protect
				ifFail: [ :err <Symbol> |	self shouldNotHappen ]
		  }}
! !

"May 18, 2008 -> 2:19:36"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
newProcess ^<Process>

	^Process for: self! !

"May 18, 2008 -> 2:19:36"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
on: exception do: handlerBlock

	^(LinkedExceptionHandler
		on: exception
		do: handlerBlock
		return: [:value | ^ value]) protect: self
! !

"May 18, 2008 -> 2:19:36"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
profile

	Profiler do: self! !

"May 18, 2008 -> 2:19:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
repeat ^<BottomType>

	[ true ] whileTrue: [ self value ].
	self shouldNotHappen.! !

"May 18, 2008 -> 2:19:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
time ^<Int>

	^Time millisecondsToRun: self! !

"May 18, 2008 -> 2:19:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
userTime ^<Int>

	^Time userMillisecondsToRun: self! !

"May 18, 2008 -> 2:19:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
value ^<R>

    ^{{self primitiveValue}}! !

"May 18, 2008 -> 2:19:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
valueIfFail: fail <[^X def]>  ^<R | X>

	^self value! !

"May 18, 2008 -> 2:19:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
verify
	"Evaluate the receiver, and generate an error if it does not return true.  This is different than
	  Object>>#assert: in that 1) it is a boolean block message, and 2) it ALWAYS evaluates, whereas
	  #assert: does not guarantee that it will evaluate the predicate.

	  Use verify in situations where you must ensure that the test is performed, for example when there
	  are side-effects that must take place, or if it is testing code that should always be performed.

	  Note that this message is only valid for blocks that return boolean values."

	"Note: we don't use self as the receiver for #error: below because it will currently
		prevent the block from being optimized away by the inliner"
	self value
		ifFalse: [ BlockWithoutArguments[Object] error: 'Assertion failed' ].

	"%hack %todo: remove this when compiler bug fixed"
	^nil! !

"May 18, 2008 -> 2:19:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
verify: message
	"Evaluate the receiver, and generate an error if it does not return true.  This is different than
	  Object>>#assert: in that 1) it is a boolean block message, and 2) it ALWAYS evaluates, whereas
	  #assert: does not guarantee that it will evaluate the predicate.

	  Use verify in situations where you must ensure that the test is performed, for example when there
	  are side-effects that must take place, or if it is testing code that should always be performed.

	  Note that this message is only valid for blocks that return boolean values."

	"Note: we don't use self as the receiver for #error: below because it will currently
		prevent the block from being optimized away by the inliner"
	self value
		ifFalse: [ BlockWithoutArguments[Object] error: 'Assertion failed: ', message ].

	"%hack %todo: remove this when compiler bug fixed"
	^nil! !

"May 18, 2008 -> 2:19:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
whileFalse ^<Object>

	^self whileFalse: []! !

"May 18, 2008 -> 2:19:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
whileFalse: blk <[]> ^<Object>

	"We can guarantee that self value is a Boolean in typesafe programs because the typechecker removes this
		  message from the protocol of blocks that don't return Booleans"
	(guaranteed <Boolean> (self value))
		ifFalse: [	blk value.
					[ (guaranteed <Boolean> (self value)) ]
						whileFalse: [ blk value ]	].
	^nil! !

"May 18, 2008 -> 2:19:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
whileTrue ^<Object>

	^self whileTrue: []! !

"May 18, 2008 -> 2:19:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
whileTrue: blk <[]> ^<Object>

	"We can guarantee that self value is a Boolean in typesafe programs because the typechecker removes this
		  message from the protocol of blocks that don't return Booleans"


	(guaranteed <Boolean> (self value))
		ifTrue: [	blk value.
					[ (guaranteed <Boolean> (self value)) ]
						whileTrue: [ blk value ]	].

	^nil! !

"May 18, 2008 -> 2:23:36"!

! (Delta mirrorFor: #Set) methodsFor: 'adding' !
include: anElement
"workaround for problem with adding nil to a set"
self deltaHack.
	anElement isNil ifTrue: [^self].
	super include: anElement! !

"May 18, 2008 -> 2:24:59"!

! (Delta mirrorFor: #Set) methodsFor: 'adding' !
include: anElement ifNew: ifNew
"workaround for problem with adding nil to a set"
self deltaHack.
	anElement isNil ifTrue: [^self].
	super include: anElement ifNew: ifNew! !

"May 18, 2008 -> 2:25:3"!

(Delta mirrorFor: #Set) removeMethod: #include: ifAbsent: [] !


"May 18, 2008 -> 2:25:5"!

(Delta mirrorFor: #Set) removeMethod: #add: ifAbsent: [] !


"May 18, 2008 -> 2:26:4"!

! (Delta mirrorFor: #Set) methodsFor: 'adding' !
include: anElement ifNew: ifNew
"workaround for problem with adding nil to a set"
self deltaHack.
	anElement isNil ifTrue: [^anElement].
	^super include: anElement ifNew: ifNew! !

"May 18, 2008 -> 2:36:12"!

"System saved" !
"May 18, 2008 -> 6:44:16"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 18, 2008 -> 6:44:27"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 18, 2008 -> 6:44:45"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 18, 2008 -> 6:46:42"!

Delta define: #SUnitDelay as: (
(Class subclassOf: 'Delay' instanceVariables: '')) !


"May 18, 2008 -> 6:46:42"!

Delta define: #SUnitNameResolver as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 18, 2008 -> 6:46:42"!

Delta define: #TestFailure as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 18, 2008 -> 6:47:22"!

Delta define: #CommentReader as: (
(Class subclassOf: 'DefinitionReader' instanceVariables: '')) !


"May 18, 2008 -> 6:48:43"!

! (Delta mirrorFor: #CommentReader) methodsFor: 'a new category' !
fileInFrom: stream <ReadStream>

	self mirror comment: stream nextChunk! !

"May 18, 2008 -> 6:49:56"!

! (Delta mirrorFor: #Class) methodsFor: 'file-in compatibility' !
comment:  aString

	(ClassMirror on: self) comment: aString! !

"May 18, 2008 -> 6:51:25"!

! (Delta mirrorFor: #Class) methodsFor: 'file-in compatibility' !
commentStamp: ignore prior: ignore2

	^(CommentReader for: (ClassMirror on: self))! !

"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitDelay as: (
(Class subclassOf: 'Delay' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitDelay as: (
(Class subclassOf: 'Delay' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitDelay as: (
(Class subclassOf: 'Delay' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitDelay as: (
(Class subclassOf: 'Delay' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitDelay as: (
(Class subclassOf: 'Delay' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitDelay as: (
(Class subclassOf: 'Delay' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitDelay as: (
(Class subclassOf: 'Delay' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitDelay as: (
(Class subclassOf: 'Delay' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitDelay as: (
(Class subclassOf: 'Delay' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitDelay as: (
(Class subclassOf: 'Delay' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitDelay as: (
(Class subclassOf: 'Delay' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitNameResolver as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitNameResolver as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitNameResolver as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitNameResolver as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitNameResolver as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitNameResolver as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitNameResolver as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitNameResolver as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitNameResolver as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitNameResolver as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitNameResolver as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #TestFailure as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #TestFailure as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #TestFailure as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #TestFailure as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #TestFailure as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #TestFailure as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #TestFailure as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #TestFailure as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #TestFailure as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #TestFailure as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #TestFailure as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

(Delta mirrorFor: #TestFailure)
comment: 
'Signaled in case of a failed test (failure). The test framework distinguishes between failures and errors. A failure is anticipated and checked for with assertions. Errors are unanticipated problems like a division by 0 or an index out of bounds ...'!


"May 18, 2008 -> 6:52:32"!

Delta define: #ResumableTestFailure as: (
(Class subclassOf: 'TestFailure' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

(Delta mirrorFor: #ResumableTestFailure)
comment: 
'A ResumableTestFailure triggers a TestFailure, but lets execution of the TestCase continue. this is useful when iterating through collections, and #assert: ing on each element. in combination with methods like testcase>>#assert:description:, this lets you run through a whole collection and note which tests pass.

here''''s an example:

	

	(1 to: 30) do: [ :each |
		self assert: each odd description: each printString, '' is even'' resumable: true]

for each element where #odd returns <false>, the element will be printed to the Transcript. '!


"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #Object) methodsFor: 'Camp Smalltalk' !
sunitAddDependent: anObject
 
        self addDependent: anObject! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #Object) methodsFor: 'Camp Smalltalk' !
sunitChanged: anAspect
 
        self changed: anAspect! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #Object) methodsFor: 'Camp Smalltalk' !
sunitRemoveDependent: anObject
 
        self removeDependent: anObject! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #Behavior) methodsFor: 'Camp Smalltalk' !
sunitAllSelectors 

        ^self allSelectors asSortedCollection asOrderedCollection! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #Behavior) methodsFor: 'Camp Smalltalk' !
sunitSelectors
 
        ^self selectors asSortedCollection asOrderedCollection! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'Camp Smalltalk' !
sunitEnsure: aBlock
 
        ^self ensure: aBlock! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'Camp Smalltalk' !
sunitOn: anException do: aHandlerBlock
 
        ^self on: anException do: aHandlerBlock! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #Class) methodsFor: 'Camp Smalltalk' !
sunitName
 
        ^self name! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #Exception) methodsFor: 'Camp Smalltalk' !
sunitExitWith: aValue
 
        self return: aValue! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'Camp Smalltalk' !
sunitSignalWith: aString
  
        ^self signal: aString! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #SUnitNameResolver) classSide methodsFor: 'Camp Smalltalk' !
classNamed: aSymbol

        ^Smalltalk
                at: aSymbol
                ifAbsent: [nil].! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #SUnitNameResolver) classSide methodsFor: 'Camp Smalltalk' !
defaultLogDevice
	^ Transcript! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #SUnitNameResolver) classSide methodsFor: 'Camp Smalltalk' !
errorObject
	^Error! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #SUnitNameResolver) classSide methodsFor: 'Camp Smalltalk' !
mnuExceptionObject
	^MessageNotUnderstood new! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #SUnitNameResolver) classSide methodsFor: 'Camp Smalltalk' !
notificationObject
	^Notification new! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #String) methodsFor: 'Camp Smalltalk' !
sunitAsSymbol
 
        ^self asSymbol! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #String) methodsFor: 'Camp Smalltalk' !
sunitMatch: aString
 
        ^self match: aString! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #String) methodsFor: 'Camp Smalltalk' !
sunitSubStrings
 
        ^self substrings! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #Symbol) methodsFor: 'Camp Smalltalk' !
sunitAsClass
 
        ^SUnitNameResolver classNamed: self! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #TestFailure) methodsFor: 'Camp Smalltalk' !
defaultAction

self halt.
        "Debugger
                openContext: initialContext
                label: messageText
                contents: initialContext shortStack"! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #ResumableTestFailure) methodsFor: 'Camp Smalltalk' !
isResumable
	"Of course a ResumableTestFailure is resumable ;-)"

	^true! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #ResumableTestFailure) methodsFor: 'Camp Smalltalk' !
sunitExitWith: aValue
	self resume: aValue! !

"May 18, 2008 -> 7:11:18"!

! (Delta mirrorFor: #Behavior) methodsFor: 'Camp Smalltalk' !
allSelectors

	|selectors|
	selectors := Set new.
	(ClassMirror on: self)
		methodsDo: [:method| selectors add: method selector].
	^selectors! !

"May 18, 2008 -> 7:12:14"!

! (Delta mirrorFor: #Behavior) methodsFor: 'Camp Smalltalk' !
selectors

	|selectors|
	selectors := Set new.
	(ClassMirror on: self)
		methodsDo: [:method| selectors add: method selector].
	^selectors! !

"May 18, 2008 -> 7:13:3"!

"System saved" !
"May 18, 2008 -> 7:17:42"!

! (Delta mirrorFor: #Behavior) methodsFor: 'Camp Smalltalk' !
superclassesDo: block

	|current|
	current := self superclass.
	[current = nil]
		whileFalse: [
			block value: current.
			current := current superclass]! !

"May 18, 2008 -> 7:18:25"!

! (Delta mirrorFor: #Behavior) methodsFor: 'Camp Smalltalk' !
allSelectors

	|selectors|
	selectors := Set new.
	self superclassesDo: [:class| selectors add: class selectors].
	^selectors! !

"May 18, 2008 -> 7:19:37"!

! (Delta mirrorFor: #Behavior) methodsFor: 'Camp Smalltalk' !
superclassesDo: block

	|current|
	current := self superclassIfAbsent: [^self].
	[current = nil]
		whileFalse: [
			block value: current.
			current := current superclassIfAbsent: [^self]]! !

"May 18, 2008 -> 7:19:55"!

! (Delta mirrorFor: #Behavior) methodsFor: 'Camp Smalltalk' !
allSelectors

	|selectors|
	selectors := Set new.
	self superclassesDo: [:class| selectors addAll: class selectors].
	^selectors! !

"May 18, 2008 -> 7:20:40"!

"System saved" !
"May 18, 2008 -> 7:28:15"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:28:15"!

(Delta mirrorFor: #TestCase)
comment: 
'A TestCase is a Command representing the future running of a test case. Create one with the class method #selector: aSymbol, passing the name of the method to be run when the test case runs.

When you discover a new fixture, subclass TestCase, declare instance variables for the objects in the fixture, override #setUp to initialize the variables, and possibly override# tearDown to deallocate any external resources allocated in #setUp.

When you are writing a test case method, send #assert: aBoolean when you want to check for an expected value. For example, you might say "self assert: socket isOpen" to test whether or not a socket is open at a point in a test.'!


"May 18, 2008 -> 7:28:15"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description')) !


"May 18, 2008 -> 7:28:15"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:28:15"!

(Delta mirrorFor: #TestResult)
comment: 
'This is a Collecting Parameter for the running of a bunch of tests. TestResult is an interesting object to subclass or substitute. #runCase: is the external protocol you need to reproduce. Kent has seen TestResults that recorded coverage information and that sent email when they were done.'!


"May 18, 2008 -> 7:28:15"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:28:15"!

(Delta mirrorFor: #TestSuite)
comment: 
'This is a Composite of Tests, either TestCases or other TestSuites. The common protocol is #run: aTestResult and the dependencies protocol'!


"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Dependencies' !
addDependentToHierachy: anObject 
	"an empty method. for Composite compability with TestSuite"


			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
assert: aBoolean

	aBoolean ifFalse: [self signalFailure: 'Assertion failed']
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
assert: aBoolean description: aString
	aBoolean ifFalse: [
		self logFailure: aString.
		TestResult failure sunitSignalWith: aString]
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
assert: aBoolean description: aString resumable: resumableBoolean 
	| exception |
	aBoolean
		ifFalse: 
			[self logFailure: aString.
			exception := resumableBoolean
						ifTrue: [TestResult resumableFailure]
						ifFalse: [TestResult failure].
			exception sunitSignalWith: aString]
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
debug
	self resources do: [:res | 
		res isAvailable ifFalse: [^res signalInitializationError]].
	[(self class selector: testSelector) runCase] 
		sunitEnsure: [self resources do: [:each | each reset]]
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
debugAsFailure
	| semaphore |
	semaphore := Semaphore new.
	self resources do: [:res | 
		res isAvailable ifFalse: [^res signalInitializationError]].
	[semaphore wait. self resources do: [:each | each reset]] fork.
	(self class selector: testSelector) runCaseAsFailure: semaphore.

			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
deny: aBoolean

	self assert: aBoolean not
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
deny: aBoolean description: aString
	self assert: aBoolean not description: aString
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
deny: aBoolean description: aString resumable: resumableBoolean 
	self
		assert: aBoolean not
		description: aString
		resumable: resumableBoolean
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Private' !
executeShould: aBlock inScopeOf: anExceptionalEvent 
	^[aBlock value.
 	false] sunitOn: anExceptionalEvent
		do: [:ex | ex sunitExitWith: true]
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
failureLog	
	^SUnitNameResolver defaultLogDevice

			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
isLogging
	"By default, we're not logging failures. If you override this in 
	a subclass, make sure that you override #failureLog"
	^false
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
logFailure: aString
	self isLogging ifTrue: [
		self failureLog 
			cr; 
			nextPutAll: aString; 
			flush]
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
openDebuggerOnFailingTestMethod
	"SUnit has halted one step in front of the failing test method. Step over the 'self halt' and 
	 send into 'self perform: testSelector' to see the failure from the beginning"

	self
		halt;
		performTest
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Private' !
performTest

	self perform: testSelector sunitAsSymbol
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Printing' !
printOn: aStream

	aStream
		nextPutAll: self class printString;
		nextPutAll: '>>#';
		nextPutAll: testSelector
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Dependencies' !
removeDependentFromHierachy: anObject 
	"an empty method. for Composite compability with TestSuite"


			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
resources
	| allResources resourceQueue |
	allResources := Set new.
	resourceQueue := OrderedCollection new.
	resourceQueue addAll: self class resources.
	[resourceQueue isEmpty] whileFalse: [
		| next |
		next := resourceQueue removeFirst.
		allResources add: next.
		resourceQueue addAll: next resources].
	^allResources
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
run
	| result |
	result := TestResult new.
	self run: result.
	^result
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
run: aResult
	aResult runCase: self
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
runCase

	[self setUp.
	self performTest] sunitEnsure: [self tearDown]
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
runCaseAsFailure: aSemaphore
	[self setUp.
	self openDebuggerOnFailingTestMethod] sunitEnsure: [
		self tearDown.
		aSemaphore signal]
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
selector
	^testSelector
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Private' !
setTestSelector: aSymbol
	testSelector := aSymbol
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
setUp
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
should: aBlock
	self assert: aBlock value
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
should: aBlock description: aString
	self assert: aBlock value description: aString
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
should: aBlock raise: anExceptionalEvent 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent)
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
should: aBlock raise: anExceptionalEvent description: aString 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent)
		description: aString
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
shouldnt: aBlock
	self deny: aBlock value
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
shouldnt: aBlock description: aString
	self deny: aBlock value description: aString
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
shouldnt: aBlock raise: anExceptionalEvent 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent) not
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
shouldnt: aBlock raise: anExceptionalEvent description: aString 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent) not 		description: aString
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
signalFailure: aString
	TestResult failure sunitSignalWith: aString! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
tearDown
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Accessing' !
description

	description isNil
		ifTrue: [^''].

	^description
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Accessing' !
description: aString

	description := aString
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Init / Release' !
initialize
	self setUp

			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Testing' !
isAvailable
	"override to provide information on the
	readiness of the resource"
	
	^true
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Testing' !
isUnavailable
	"override to provide information on the
	readiness of the resource"
	
	^self isAvailable not
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Accessing' !
name

	name isNil
		ifTrue: [^self printString].

	^name
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Accessing' !
name: aString

	name := aString
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Printing' !
printOn: aStream

	aStream nextPutAll: self class printString
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Accessing' !
resources
	^self class resources
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Running' !
setUp
	"Does nothing. Subclasses should override this
	to initialize their resource"
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Running' !
signalInitializationError
	^self class signalInitializationError
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Running' !
tearDown
	"Does nothing. Subclasses should override this
	to tear down their resource"
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
correctCount
	"depreciated - use #passedCount"

	^self passedCount
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
defects
	^OrderedCollection new
		addAll: self errors;
		addAll: self failures; yourself
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
errorCount

	^self errors size
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
errors

	errors isNil
		ifTrue: [errors := OrderedCollection new].
	^errors
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
failureCount

	^self failures size
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
failures
	failures isNil
		ifTrue: [failures := Set new].
	^failures
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
hasErrors

	^self errors size > 0
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
hasFailures

	^self failures size > 0
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
hasPassed

	^self hasErrors not and: [self hasFailures not]
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Init / Release' !
initialize
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
isError: aTestCase

	^self errors includes: aTestCase
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
isFailure: aTestCase
	^self failures includes: aTestCase
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
isPassed: aTestCase

	^self passed includes: aTestCase
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
passed

	passed isNil
		ifTrue: [passed := OrderedCollection new].

	^passed
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
passedCount

	^self passed size
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Printing' !
printOn: aStream

	aStream
		nextPutAll: self runCount printString;
		nextPutAll: ' run, ';
		nextPutAll: self correctCount printString;
		nextPutAll: ' passed, ';
		nextPutAll: self failureCount printString;
		nextPutAll: ' failed, ';
		nextPutAll: self errorCount printString;
		nextPutAll: ' error'.

	self errorCount ~= 1
		ifTrue: [aStream nextPut: $s]
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[
			[
				aTestCase runCase.
				true]
					sunitOn: self class failure
					do: [:signal |
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
								self errors add: aTestCase.
								signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
runCount

	^self passedCount + self failureCount + self errorCount
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
tests

	^(OrderedCollection new: self runCount)
		addAll: self passed;
		addAll: self errors;
		addAll: self failures;
		yourself
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Dependencies' !
addDependentToHierachy: anObject
	self sunitAddDependent: anObject.
	self tests do: [ :each | each addDependentToHierachy: anObject]
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
addTest: aTest
	self tests add: aTest
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
addTests: aCollection 
	aCollection do: [:eachTest | self addTest: eachTest]
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
defaultResources
	^self tests 
		inject: Set new
		into: [:coll :testCase | 
			coll
				addAll: testCase resources;
				yourself]
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
name

	^name
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
name: aString

	name := aString
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Dependencies' !
removeDependentFromHierachy: anObject
	self sunitRemoveDependent: anObject.
	self tests do: [ :each | each removeDependentFromHierachy: anObject]
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
resources
	resources isNil ifTrue: [resources := self defaultResources].
	^resources
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
resources: anObject
	resources := anObject
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Running' !
run
	| result |
 	result := TestResult new.
	self resources do: [ :res |
		res isAvailable ifFalse: [^res signalInitializationError]].
	[self run: result] sunitEnsure: [self resources do: [:each | each reset]].
	^result
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Running' !
run: aResult 
	self tests do: [:each | 
		self sunitChanged: each.
		each run: aResult]
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
tests
	tests isNil ifTrue: [tests := OrderedCollection new].
	^tests
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Accessing' !
allTestSelectors

	^self sunitAllSelectors select: [:each | 'test*' sunitMatch: each]
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
buildSuite
	| suite |
	^self isAbstract
		ifTrue: 
			[suite := self suiteClass named: self name asString.
			self allSubclasses 
				do: [:each | each isAbstract ifFalse: [suite addTest: each buildSuiteFromSelectors]].
			suite]
		ifFalse: [self buildSuiteFromSelectors]
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
buildSuiteFromAllSelectors

	^self buildSuiteFromMethods: self allTestSelectors
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
buildSuiteFromLocalSelectors

	^self buildSuiteFromMethods: self testSelectors
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
buildSuiteFromMethods: testMethods

	^testMethods
		inject: (self suiteClass named: self name asString)
		into: [:suite :selector |
			suite
				addTest: (self selector: selector);
				yourself]
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
buildSuiteFromSelectors

	^self shouldInheritSelectors
		ifTrue: [self buildSuiteFromAllSelectors]
		ifFalse: [self buildSuiteFromLocalSelectors]
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Instance Creation' !
debug: aSymbol

	^(self selector: aSymbol) debug
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Testing' !
isAbstract
	"Override to true if a TestCase subclass is Abstract and should not have
	TestCase instances built from it"

	^self sunitName = #TestCase
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Accessing' !
resources

	^#()
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Instance Creation' !
run: aSymbol

	^(self selector: aSymbol) run
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Instance Creation' !
selector: aSymbol

	^self new setTestSelector: aSymbol
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Testing' !
shouldInheritSelectors
	"I should inherit from an Abstract superclass but not from a concrete one by default, unless I have no testSelectors in which case I must be expecting to inherit them from my superclass.  If a test case with selectors wants to inherit selectors from a concrete superclass, override this to true in that subclass."

	^self superclass isAbstract
		or: [self testSelectors isEmpty]

"$QA Ignore:Sends system method(superclass)$"
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Instance Creation' !
suite

	^self buildSuite
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
suiteClass
	^TestSuite
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Accessing' !
testSelectors

	^self sunitSelectors select: [:each | 'test*' sunitMatch: each]
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Accessing' !
sunitVersion
	^'3.1'
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Accessing' !
currentDictionary

	CurrentDictionary isNil
		ifTrue: [CurrentDictionary := Dictionary new].

	^CurrentDictionary
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Accessing' !
current

	^self currentDictionary
		at: self
		ifPresent: [:current|]
		ifAbsentPut: [self new].

			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Accessing' !
current: aTestResource

	self currentDictionary
		at: self
		put: aTestResource
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Testing' !
isAbstract
	"Override to true if a TestResource subclass is Abstract and should not have
	TestCase instances built from it"

	^self sunitName = #TestResource
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Testing' !
isAvailable
	^self current notNil and: [self current isAvailable]
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Testing' !
isUnavailable

	^self isAvailable not
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Creation' !
new

	^super new initialize
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Creation' !
reset
	|current|
	current := self currentDictionary
		at: self
		ifAbsent: [^nil].
	[current tearDown] ensure: [
		self current: nil]
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Accessing' !
resources
	^#()
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Creation' !
signalInitializationError
	^TestResult signalErrorWith: 'Resource ' , self name , ' could not be initialized'
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResult) classSide methodsFor: 'Exceptions' !
error
	^self exError
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResult) classSide methodsFor: 'Exceptions' !
exError
	^SUnitNameResolver errorObject
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResult) classSide methodsFor: 'Exceptions' !
failure
	^TestFailure
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResult) classSide methodsFor: 'Init / Release' !
new
	^super new initialize
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResult) classSide methodsFor: 'Exceptions' !
resumableFailure
	^ResumableTestFailure
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResult) classSide methodsFor: 'Exceptions' !
signalErrorWith: aString 
	self error sunitSignalWith: aString
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResult) classSide methodsFor: 'Exceptions' !
signalFailureWith: aString 
	self failure sunitSignalWith: aString
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestSuite) classSide methodsFor: 'Creation' !
named: aString

	^self new
		name: aString;
		yourself
			! !

"May 18, 2008 -> 7:32:49"!

! (Delta mirrorFor: #Class) methodsFor: 'file-in compatibility' !
subclass: clsName <Symbol>
instanceVariableNames: iVars <Str>
classVariableNames: cVars <Str>
poolDictionaries: pVars <Str>
category: cat <Str>
^<Class>

	| mirror <ClassMirror> |
	[ pVars isEmpty ] verify.
	mirror := Class subclassOf: self name instanceVariables: iVars.
	mirror classVariables: cVars.
	Delta define: clsName as: mirror.
	^mirror reflectee! !

"May 18, 2008 -> 7:34:24"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:24"!

(Delta mirrorFor: #TestCase)
comment: 
'A TestCase is a Command representing the future running of a test case. Create one with the class method #selector: aSymbol, passing the name of the method to be run when the test case runs.

When you discover a new fixture, subclass TestCase, declare instance variables for the objects in the fixture, override #setUp to initialize the variables, and possibly override# tearDown to deallocate any external resources allocated in #setUp.

When you are writing a test case method, send #assert: aBoolean when you want to check for an expected value. For example, you might say "self assert: socket isOpen" to test whether or not a socket is open at a point in a test.'!


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:24"!

(Delta mirrorFor: #TestResult)
comment: 
'This is a Collecting Parameter for the running of a bunch of tests. TestResult is an interesting object to subclass or substitute. #runCase: is the external protocol you need to reproduce. Kent has seen TestResults that recorded coverage information and that sent email when they were done.'!


"May 18, 2008 -> 7:34:24"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:24"!

(Delta mirrorFor: #TestSuite)
comment: 
'This is a Composite of Tests, either TestCases or other TestSuites. The common protocol is #run: aTestResult and the dependencies protocol'!


"May 18, 2008 -> 7:34:24"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Dependencies' !
addDependentToHierachy: anObject 
	"an empty method. for Composite compability with TestSuite"


			! !

"May 18, 2008 -> 7:34:24"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
assert: aBoolean

	aBoolean ifFalse: [self signalFailure: 'Assertion failed']
			! !

"May 18, 2008 -> 7:34:24"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
assert: aBoolean description: aString
	aBoolean ifFalse: [
		self logFailure: aString.
		TestResult failure sunitSignalWith: aString]
			! !

"May 18, 2008 -> 7:34:24"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
assert: aBoolean description: aString resumable: resumableBoolean 
	| exception |
	aBoolean
		ifFalse: 
			[self logFailure: aString.
			exception := resumableBoolean
						ifTrue: [TestResult resumableFailure]
						ifFalse: [TestResult failure].
			exception sunitSignalWith: aString]
			! !

"May 18, 2008 -> 7:34:24"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
debug
	self resources do: [:res | 
		res isAvailable ifFalse: [^res signalInitializationError]].
	[(self class selector: testSelector) runCase] 
		sunitEnsure: [self resources do: [:each | each reset]]
			! !

"May 18, 2008 -> 7:34:24"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
debugAsFailure
	| semaphore |
	semaphore := Semaphore new.
	self resources do: [:res | 
		res isAvailable ifFalse: [^res signalInitializationError]].
	[semaphore wait. self resources do: [:each | each reset]] fork.
	(self class selector: testSelector) runCaseAsFailure: semaphore.

			! !

"May 18, 2008 -> 7:34:24"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
deny: aBoolean

	self assert: aBoolean not
			! !

"May 18, 2008 -> 7:34:24"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
deny: aBoolean description: aString
	self assert: aBoolean not description: aString
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
deny: aBoolean description: aString resumable: resumableBoolean 
	self
		assert: aBoolean not
		description: aString
		resumable: resumableBoolean
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Private' !
executeShould: aBlock inScopeOf: anExceptionalEvent 
	^[aBlock value.
 	false] sunitOn: anExceptionalEvent
		do: [:ex | ex sunitExitWith: true]
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
failureLog	
	^SUnitNameResolver defaultLogDevice

			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
isLogging
	"By default, we're not logging failures. If you override this in 
	a subclass, make sure that you override #failureLog"
	^false
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
logFailure: aString
	self isLogging ifTrue: [
		self failureLog 
			cr; 
			nextPutAll: aString; 
			flush]
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
openDebuggerOnFailingTestMethod
	"SUnit has halted one step in front of the failing test method. Step over the 'self halt' and 
	 send into 'self perform: testSelector' to see the failure from the beginning"

	self
		halt;
		performTest
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Private' !
performTest

	self perform: testSelector sunitAsSymbol
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Printing' !
printOn: aStream

	aStream
		nextPutAll: self class printString;
		nextPutAll: '>>#';
		nextPutAll: testSelector
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Dependencies' !
removeDependentFromHierachy: anObject 
	"an empty method. for Composite compability with TestSuite"


			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
resources
	| allResources resourceQueue |
	allResources := Set new.
	resourceQueue := OrderedCollection new.
	resourceQueue addAll: self class resources.
	[resourceQueue isEmpty] whileFalse: [
		| next |
		next := resourceQueue removeFirst.
		allResources add: next.
		resourceQueue addAll: next resources].
	^allResources
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
run
	| result |
	result := TestResult new.
	self run: result.
	^result
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
run: aResult
	aResult runCase: self
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
runCase

	[self setUp.
	self performTest] sunitEnsure: [self tearDown]
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
runCaseAsFailure: aSemaphore
	[self setUp.
	self openDebuggerOnFailingTestMethod] sunitEnsure: [
		self tearDown.
		aSemaphore signal]
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
selector
	^testSelector
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Private' !
setTestSelector: aSymbol
	testSelector := aSymbol
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
setUp
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
should: aBlock
	self assert: aBlock value
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
should: aBlock description: aString
	self assert: aBlock value description: aString
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
should: aBlock raise: anExceptionalEvent 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent)
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
should: aBlock raise: anExceptionalEvent description: aString 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent)
		description: aString
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
shouldnt: aBlock
	self deny: aBlock value
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
shouldnt: aBlock description: aString
	self deny: aBlock value description: aString
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
shouldnt: aBlock raise: anExceptionalEvent 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent) not
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
shouldnt: aBlock raise: anExceptionalEvent description: aString 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent) not 		description: aString
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
signalFailure: aString
	TestResult failure sunitSignalWith: aString! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
tearDown
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Accessing' !
description

	description isNil
		ifTrue: [^''].

	^description
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Accessing' !
description: aString

	description := aString
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Init / Release' !
initialize
	self setUp

			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Testing' !
isAvailable
	"override to provide information on the
	readiness of the resource"
	
	^true
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Testing' !
isUnavailable
	"override to provide information on the
	readiness of the resource"
	
	^self isAvailable not
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Accessing' !
name

	name isNil
		ifTrue: [^self printString].

	^name
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Accessing' !
name: aString

	name := aString
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Printing' !
printOn: aStream

	aStream nextPutAll: self class printString
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Accessing' !
resources
	^self class resources
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Running' !
setUp
	"Does nothing. Subclasses should override this
	to initialize their resource"
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Running' !
signalInitializationError
	^self class signalInitializationError
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Running' !
tearDown
	"Does nothing. Subclasses should override this
	to tear down their resource"
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
correctCount
	"depreciated - use #passedCount"

	^self passedCount
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
defects
	^OrderedCollection new
		addAll: self errors;
		addAll: self failures; yourself
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
errorCount

	^self errors size
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
errors

	errors isNil
		ifTrue: [errors := OrderedCollection new].
	^errors
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
failureCount

	^self failures size
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
failures
	failures isNil
		ifTrue: [failures := Set new].
	^failures
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
hasErrors

	^self errors size > 0
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
hasFailures

	^self failures size > 0
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
hasPassed

	^self hasErrors not and: [self hasFailures not]
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Init / Release' !
initialize
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
isError: aTestCase

	^self errors includes: aTestCase
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
isFailure: aTestCase
	^self failures includes: aTestCase
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
isPassed: aTestCase

	^self passed includes: aTestCase
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
passed

	passed isNil
		ifTrue: [passed := OrderedCollection new].

	^passed
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
passedCount

	^self passed size
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Printing' !
printOn: aStream

	aStream
		nextPutAll: self runCount printString;
		nextPutAll: ' run, ';
		nextPutAll: self correctCount printString;
		nextPutAll: ' passed, ';
		nextPutAll: self failureCount printString;
		nextPutAll: ' failed, ';
		nextPutAll: self errorCount printString;
		nextPutAll: ' error'.

	self errorCount ~= 1
		ifTrue: [aStream nextPut: $s]
			! !

"May 18, 2008 -> 7:34:52"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:52"!

(Delta mirrorFor: #TestCase)
comment: 
'A TestCase is a Command representing the future running of a test case. Create one with the class method #selector: aSymbol, passing the name of the method to be run when the test case runs.

When you discover a new fixture, subclass TestCase, declare instance variables for the objects in the fixture, override #setUp to initialize the variables, and possibly override# tearDown to deallocate any external resources allocated in #setUp.

When you are writing a test case method, send #assert: aBoolean when you want to check for an expected value. For example, you might say "self assert: socket isOpen" to test whether or not a socket is open at a point in a test.'!


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:52"!

(Delta mirrorFor: #TestResult)
comment: 
'This is a Collecting Parameter for the running of a bunch of tests. TestResult is an interesting object to subclass or substitute. #runCase: is the external protocol you need to reproduce. Kent has seen TestResults that recorded coverage information and that sent email when they were done.'!


"May 18, 2008 -> 7:34:52"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:52"!

(Delta mirrorFor: #TestSuite)
comment: 
'This is a Composite of Tests, either TestCases or other TestSuites. The common protocol is #run: aTestResult and the dependencies protocol'!


"May 18, 2008 -> 7:34:52"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Dependencies' !
addDependentToHierachy: anObject 
	"an empty method. for Composite compability with TestSuite"


			! !

"May 18, 2008 -> 7:34:52"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
assert: aBoolean

	aBoolean ifFalse: [self signalFailure: 'Assertion failed']
			! !

"May 18, 2008 -> 7:34:52"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
assert: aBoolean description: aString
	aBoolean ifFalse: [
		self logFailure: aString.
		TestResult failure sunitSignalWith: aString]
			! !

"May 18, 2008 -> 7:34:52"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
assert: aBoolean description: aString resumable: resumableBoolean 
	| exception |
	aBoolean
		ifFalse: 
			[self logFailure: aString.
			exception := resumableBoolean
						ifTrue: [TestResult resumableFailure]
						ifFalse: [TestResult failure].
			exception sunitSignalWith: aString]
			! !

"May 18, 2008 -> 7:34:52"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
debug
	self resources do: [:res | 
		res isAvailable ifFalse: [^res signalInitializationError]].
	[(self class selector: testSelector) runCase] 
		sunitEnsure: [self resources do: [:each | each reset]]
			! !

"May 18, 2008 -> 7:34:52"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
debugAsFailure
	| semaphore |
	semaphore := Semaphore new.
	self resources do: [:res | 
		res isAvailable ifFalse: [^res signalInitializationError]].
	[semaphore wait. self resources do: [:each | each reset]] fork.
	(self class selector: testSelector) runCaseAsFailure: semaphore.

			! !

"May 18, 2008 -> 7:34:52"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
deny: aBoolean

	self assert: aBoolean not
			! !

"May 18, 2008 -> 7:34:52"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
deny: aBoolean description: aString
	self assert: aBoolean not description: aString
			! !

"May 18, 2008 -> 7:34:52"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
deny: aBoolean description: aString resumable: resumableBoolean 
	self
		assert: aBoolean not
		description: aString
		resumable: resumableBoolean
			! !

"May 18, 2008 -> 7:35:7"!

"System saved" !
"May 18, 2008 -> 7:35:45"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:35:45"!

(Delta mirrorFor: #TestCase)
comment: 
'A TestCase is a Command representing the future running of a test case. Create one with the class method #selector: aSymbol, passing the name of the method to be run when the test case runs.

When you discover a new fixture, subclass TestCase, declare instance variables for the objects in the fixture, override #setUp to initialize the variables, and possibly override# tearDown to deallocate any external resources allocated in #setUp.

When you are writing a test case method, send #assert: aBoolean when you want to check for an expected value. For example, you might say "self assert: socket isOpen" to test whether or not a socket is open at a point in a test.'!


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:35:45"!

(Delta mirrorFor: #TestResult)
comment: 
'This is a Collecting Parameter for the running of a bunch of tests. TestResult is an interesting object to subclass or substitute. #runCase: is the external protocol you need to reproduce. Kent has seen TestResults that recorded coverage information and that sent email when they were done.'!


"May 18, 2008 -> 7:35:46"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:35:46"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:35:46"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:35:46"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:35:46"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:35:46"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:35:46"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:35:46"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:35:46"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:35:46"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:35:46"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:35:46"!

(Delta mirrorFor: #TestSuite)
comment: 
'This is a Composite of Tests, either TestCases or other TestSuites. The common protocol is #run: aTestResult and the dependencies protocol'!


"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Dependencies' !
addDependentToHierachy: anObject 
	"an empty method. for Composite compability with TestSuite"


			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
assert: aBoolean

	aBoolean ifFalse: [self signalFailure: 'Assertion failed']
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
assert: aBoolean description: aString
	aBoolean ifFalse: [
		self logFailure: aString.
		TestResult failure sunitSignalWith: aString]
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
assert: aBoolean description: aString resumable: resumableBoolean 
	| exception |
	aBoolean
		ifFalse: 
			[self logFailure: aString.
			exception := resumableBoolean
						ifTrue: [TestResult resumableFailure]
						ifFalse: [TestResult failure].
			exception sunitSignalWith: aString]
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
debug
	self resources do: [:res | 
		res isAvailable ifFalse: [^res signalInitializationError]].
	[(self class selector: testSelector) runCase] 
		sunitEnsure: [self resources do: [:each | each reset]]
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
debugAsFailure
	| semaphore |
	semaphore := Semaphore new.
	self resources do: [:res | 
		res isAvailable ifFalse: [^res signalInitializationError]].
	[semaphore wait. self resources do: [:each | each reset]] fork.
	(self class selector: testSelector) runCaseAsFailure: semaphore.

			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
deny: aBoolean

	self assert: aBoolean not
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
deny: aBoolean description: aString
	self assert: aBoolean not description: aString
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
deny: aBoolean description: aString resumable: resumableBoolean 
	self
		assert: aBoolean not
		description: aString
		resumable: resumableBoolean
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Private' !
executeShould: aBlock inScopeOf: anExceptionalEvent 
	^[aBlock value.
 	false] sunitOn: anExceptionalEvent
		do: [:ex | ex sunitExitWith: true]
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
failureLog	
	^SUnitNameResolver defaultLogDevice

			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
isLogging
	"By default, we're not logging failures. If you override this in 
	a subclass, make sure that you override #failureLog"
	^false
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
logFailure: aString
	self isLogging ifTrue: [
		self failureLog 
			cr; 
			nextPutAll: aString; 
			flush]
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
openDebuggerOnFailingTestMethod
	"SUnit has halted one step in front of the failing test method. Step over the 'self halt' and 
	 send into 'self perform: testSelector' to see the failure from the beginning"

	self
		halt;
		performTest
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Private' !
performTest

	self perform: testSelector sunitAsSymbol
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Printing' !
printOn: aStream

	aStream
		nextPutAll: self class printString;
		nextPutAll: '>>#';
		nextPutAll: testSelector
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Dependencies' !
removeDependentFromHierachy: anObject 
	"an empty method. for Composite compability with TestSuite"


			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
resources
	| allResources resourceQueue |
	allResources := Set new.
	resourceQueue := OrderedCollection new.
	resourceQueue addAll: self class resources.
	[resourceQueue isEmpty] whileFalse: [
		| next |
		next := resourceQueue removeFirst.
		allResources add: next.
		resourceQueue addAll: next resources].
	^allResources
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
run
	| result |
	result := TestResult new.
	self run: result.
	^result
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
run: aResult
	aResult runCase: self
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
runCase

	[self setUp.
	self performTest] sunitEnsure: [self tearDown]
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
runCaseAsFailure: aSemaphore
	[self setUp.
	self openDebuggerOnFailingTestMethod] sunitEnsure: [
		self tearDown.
		aSemaphore signal]
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
selector
	^testSelector
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Private' !
setTestSelector: aSymbol
	testSelector := aSymbol
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
setUp
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
should: aBlock
	self assert: aBlock value
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
should: aBlock description: aString
	self assert: aBlock value description: aString
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
should: aBlock raise: anExceptionalEvent 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent)
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
should: aBlock raise: anExceptionalEvent description: aString 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent)
		description: aString
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
shouldnt: aBlock
	self deny: aBlock value
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
shouldnt: aBlock description: aString
	self deny: aBlock value description: aString
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
shouldnt: aBlock raise: anExceptionalEvent 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent) not
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
shouldnt: aBlock raise: anExceptionalEvent description: aString 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent) not 		description: aString
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
signalFailure: aString
	TestResult failure sunitSignalWith: aString! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
tearDown
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Accessing' !
description

	description isNil
		ifTrue: [^''].

	^description
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Accessing' !
description: aString

	description := aString
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Init / Release' !
initialize
	self setUp

			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Testing' !
isAvailable
	"override to provide information on the
	readiness of the resource"
	
	^true
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Testing' !
isUnavailable
	"override to provide information on the
	readiness of the resource"
	
	^self isAvailable not
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Accessing' !
name

	name isNil
		ifTrue: [^self printString].

	^name
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Accessing' !
name: aString

	name := aString
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Printing' !
printOn: aStream

	aStream nextPutAll: self class printString
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Accessing' !
resources
	^self class resources
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Running' !
setUp
	"Does nothing. Subclasses should override this
	to initialize their resource"
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Running' !
signalInitializationError
	^self class signalInitializationError
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Running' !
tearDown
	"Does nothing. Subclasses should override this
	to tear down their resource"
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
correctCount
	"depreciated - use #passedCount"

	^self passedCount
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
defects
	^OrderedCollection new
		addAll: self errors;
		addAll: self failures; yourself
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
errorCount

	^self errors size
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
errors

	errors isNil
		ifTrue: [errors := OrderedCollection new].
	^errors
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
failureCount

	^self failures size
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
failures
	failures isNil
		ifTrue: [failures := Set new].
	^failures
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
hasErrors

	^self errors size > 0
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
hasFailures

	^self failures size > 0
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
hasPassed

	^self hasErrors not and: [self hasFailures not]
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Init / Release' !
initialize
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
isError: aTestCase

	^self errors includes: aTestCase
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
isFailure: aTestCase
	^self failures includes: aTestCase
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
isPassed: aTestCase

	^self passed includes: aTestCase
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
passed

	passed isNil
		ifTrue: [passed := OrderedCollection new].

	^passed
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
passedCount

	^self passed size
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Printing' !
printOn: aStream

	aStream
		nextPutAll: self runCount printString;
		nextPutAll: ' run, ';
		nextPutAll: self correctCount printString;
		nextPutAll: ' passed, ';
		nextPutAll: self failureCount printString;
		nextPutAll: ' failed, ';
		nextPutAll: self errorCount printString;
		nextPutAll: ' error'.

	self errorCount ~= 1
		ifTrue: [aStream nextPut: $s]
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[
			[
				aTestCase runCase.
				true]
					sunitOn: self class failure
					do: [:signal |
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
								self errors add: aTestCase.
								signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
runCount

	^self passedCount + self failureCount + self errorCount
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
tests

	^(OrderedCollection new: self runCount)
		addAll: self passed;
		addAll: self errors;
		addAll: self failures;
		yourself
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Dependencies' !
addDependentToHierachy: anObject
	self sunitAddDependent: anObject.
	self tests do: [ :each | each addDependentToHierachy: anObject]
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
addTest: aTest
	self tests add: aTest
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
addTests: aCollection 
	aCollection do: [:eachTest | self addTest: eachTest]
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
defaultResources
	^self tests 
		inject: Set new
		into: [:coll :testCase | 
			coll
				addAll: testCase resources;
				yourself]
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
name

	^name
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
name: aString

	name := aString
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Dependencies' !
removeDependentFromHierachy: anObject
	self sunitRemoveDependent: anObject.
	self tests do: [ :each | each removeDependentFromHierachy: anObject]
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
resources
	resources isNil ifTrue: [resources := self defaultResources].
	^resources
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
resources: anObject
	resources := anObject
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Running' !
run
	| result |
 	result := TestResult new.
	self resources do: [ :res |
		res isAvailable ifFalse: [^res signalInitializationError]].
	[self run: result] sunitEnsure: [self resources do: [:each | each reset]].
	^result
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Running' !
run: aResult 
	self tests do: [:each | 
		self sunitChanged: each.
		each run: aResult]
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
tests
	tests isNil ifTrue: [tests := OrderedCollection new].
	^tests
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Accessing' !
allTestSelectors

	^self sunitAllSelectors select: [:each | 'test*' sunitMatch: each]
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
buildSuite
	| suite |
	^self isAbstract
		ifTrue: 
			[suite := self suiteClass named: self name asString.
			self allSubclasses 
				do: [:each | each isAbstract ifFalse: [suite addTest: each buildSuiteFromSelectors]].
			suite]
		ifFalse: [self buildSuiteFromSelectors]
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
buildSuiteFromAllSelectors

	^self buildSuiteFromMethods: self allTestSelectors
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
buildSuiteFromLocalSelectors

	^self buildSuiteFromMethods: self testSelectors
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
buildSuiteFromMethods: testMethods

	^testMethods
		inject: (self suiteClass named: self name asString)
		into: [:suite :selector |
			suite
				addTest: (self selector: selector);
				yourself]
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
buildSuiteFromSelectors

	^self shouldInheritSelectors
		ifTrue: [self buildSuiteFromAllSelectors]
		ifFalse: [self buildSuiteFromLocalSelectors]
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Instance Creation' !
debug: aSymbol

	^(self selector: aSymbol) debug
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Testing' !
isAbstract
	"Override to true if a TestCase subclass is Abstract and should not have
	TestCase instances built from it"

	^self sunitName = #TestCase
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Accessing' !
resources

	^#()
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Instance Creation' !
run: aSymbol

	^(self selector: aSymbol) run
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Instance Creation' !
selector: aSymbol

	^self new setTestSelector: aSymbol
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Testing' !
shouldInheritSelectors
	"I should inherit from an Abstract superclass but not from a concrete one by default, unless I have no testSelectors in which case I must be expecting to inherit them from my superclass.  If a test case with selectors wants to inherit selectors from a concrete superclass, override this to true in that subclass."

	^self superclass isAbstract
		or: [self testSelectors isEmpty]

"$QA Ignore:Sends system method(superclass)$"
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Instance Creation' !
suite

	^self buildSuite
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
suiteClass
	^TestSuite
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Accessing' !
testSelectors

	^self sunitSelectors select: [:each | 'test*' sunitMatch: each]
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Accessing' !
sunitVersion
	^'3.1'
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Accessing' !
currentDictionary

	CurrentDictionary isNil
		ifTrue: [CurrentDictionary := Dictionary new].

	^CurrentDictionary
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Accessing' !
current

	^self currentDictionary
		at: self
		ifPresent: [:current|]
		ifAbsentPut: [self new].

			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Accessing' !
current: aTestResource

	self currentDictionary
		at: self
		put: aTestResource
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Testing' !
isAbstract
	"Override to true if a TestResource subclass is Abstract and should not have
	TestCase instances built from it"

	^self sunitName = #TestResource
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Testing' !
isAvailable
	^self current notNil and: [self current isAvailable]
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Testing' !
isUnavailable

	^self isAvailable not
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Creation' !
new

	^super new initialize
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Creation' !
reset
	|current|
	current := self currentDictionary
		at: self
		ifAbsent: [^nil].
	[current tearDown] ensure: [
		self current: nil]
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Accessing' !
resources
	^#()
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Creation' !
signalInitializationError
	^TestResult signalErrorWith: 'Resource ' , self name , ' could not be initialized'
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResult) classSide methodsFor: 'Exceptions' !
error
	^self exError
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResult) classSide methodsFor: 'Exceptions' !
exError
	^SUnitNameResolver errorObject
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResult) classSide methodsFor: 'Exceptions' !
failure
	^TestFailure
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResult) classSide methodsFor: 'Init / Release' !
new
	^super new initialize
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResult) classSide methodsFor: 'Exceptions' !
resumableFailure
	^ResumableTestFailure
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResult) classSide methodsFor: 'Exceptions' !
signalErrorWith: aString 
	self error sunitSignalWith: aString
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResult) classSide methodsFor: 'Exceptions' !
signalFailureWith: aString 
	self failure sunitSignalWith: aString
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestSuite) classSide methodsFor: 'Creation' !
named: aString

	^self new
		name: aString;
		yourself
			! !

"May 18, 2008 -> 7:36:43"!

"System saved" !
"May 18, 2008 -> 7:36:56"!

Delta define: #ExampleSetTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'full empty')) !


"May 18, 2008 -> 7:36:56"!

Delta define: #ResumableTestFailureTestCase as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"May 18, 2008 -> 7:36:56"!

Delta define: #SimpleTestResourceTestCase as: (
(Class subclassOf: 'TestCase' instanceVariables: 'resource')) !


"May 18, 2008 -> 7:36:56"!

Delta define: #SUnitTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'hasRun hasSetup hasRanOnce')) !


"May 18, 2008 -> 7:36:56"!

(Delta mirrorFor: #SUnitTest)
comment: 
'This is both an example of writing tests and a self test for the SUnit. The tests 
here are pretty strange, since you want to make sure things blow up. You should 
not generally have to write tests this complicated in structure, although they 
will be far more complicated in terms of your own objects- more assertions, more 
complicated setup. Kent says: "Never forget, however, that if the tests are hard 
to write, something is probably wrong with the design".'!


"May 18, 2008 -> 7:36:56"!

Delta define: #SimpleTestResource as: (
(Class subclassOf: 'TestResource' instanceVariables: 'runningState hasRun hasSetup hasRanOnce')) !


"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #ExampleSetTest) methodsFor: 'Running' !
setUp
	empty := Set new.
	full := Set with: 5 with: #abc
			! !

"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #ExampleSetTest) methodsFor: 'Testing' !
testAdd
	empty add: 5.
	self assert: (empty includes: 5)
			! !

"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #ExampleSetTest) methodsFor: 'Testing' !
testGrow
	empty addAll: (1 to: 100).
	self assert: empty size = 100
			! !

"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #ExampleSetTest) methodsFor: 'Testing' !
testIllegal
	self 
		should: [empty at: 5] 
		raise: TestResult error.
	self 
		should: [empty at: 5 put: #abc] 
		raise: TestResult error
			! !

"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #ExampleSetTest) methodsFor: 'Testing' !
testIncludes
	self assert: (full includes: 5).
	self assert: (full includes: #abc)
			! !

"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #ExampleSetTest) methodsFor: 'Testing' !
testOccurrences
	self assert: (empty occurrencesOf: 0) = 0.
	self assert: (full occurrencesOf: 5) = 1.
	full add: 5.
	self assert: (full occurrencesOf: 5) = 1
			! !

"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #ExampleSetTest) methodsFor: 'Testing' !
testRemove
	full remove: 5.
	self assert: (full includes: #abc).
	self deny: (full includes: 5)
			! !

"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #ResumableTestFailureTestCase) methodsFor: 'Not categorized' !
errorTest
	1 zork
			! !

"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #ResumableTestFailureTestCase) methodsFor: 'Not categorized' !
failureLog
	^SUnitNameResolver defaultLogDevice
			! !

"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #ResumableTestFailureTestCase) methodsFor: 'Not categorized' !
failureTest
	self
		assert: false description: 'You should see me' resumable: true; 
		assert: false description: 'You should see me too' resumable: true; 
		assert: false description: 'You should see me last' resumable: false; 
		assert: false description: 'You should not see me' resumable: true
			! !

"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #ResumableTestFailureTestCase) methodsFor: 'Not categorized' !
isLogging
	^false
			! !

"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #ResumableTestFailureTestCase) methodsFor: 'Not categorized' !
okTest
	self assert: true
			! !

"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #ResumableTestFailureTestCase) methodsFor: 'Not categorized' !
regularTestFailureTest
	self assert: false description: 'You should see me'
			! !

"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #ResumableTestFailureTestCase) methodsFor: 'Not categorized' !
resumableTestFailureTest
	self
		assert: false description: 'You should see me' resumable: true; 
		assert: false description: 'You should see me too' resumable: true; 
		assert: false description: 'You should see me last' resumable: false; 
		assert: false description: 'You should not see me' resumable: true
			! !

"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #ResumableTestFailureTestCase) methodsFor: 'Not categorized' !
testResumable
	| result suite |
	suite := TestSuite new.
	suite addTest: (self class selector: #errorTest).
	suite addTest: (self class selector: #regularTestFailureTest).
	suite addTest: (self class selector: #resumableTestFailureTest).
	suite addTest: (self class selector: #okTest).
	result := suite run.
	self assert: result failures size = 2;
		assert: result errors size = 1
			! !

"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #SimpleTestResource) methodsFor: 'testing' !
hasRun
	^hasRun
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResource) methodsFor: 'testing' !
hasSetup
	^hasSetup
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResource) methodsFor: 'testing' !
isAvailable
	
	^self runningState == self startedStateSymbol
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResource) methodsFor: 'accessing' !
runningState

	^runningState
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResource) methodsFor: 'accessing' !
runningState: aSymbol

	runningState := aSymbol
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResource) methodsFor: 'running' !
setRun
	hasRun := true
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResource) methodsFor: 'running' !
setUp
	
	self runningState: self startedStateSymbol.
	hasSetup := true
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResource) methodsFor: 'running' !
startedStateSymbol

	^#started
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResource) methodsFor: 'running' !
stoppedStateSymbol

	^#stopped
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResource) methodsFor: 'running' !
tearDown

	self runningState: self stoppedStateSymbol
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResourceTestCase) methodsFor: 'Not categorized' !
dummy
	self assert: true
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResourceTestCase) methodsFor: 'Not categorized' !
error
	'foo' odd
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResourceTestCase) methodsFor: 'Not categorized' !
fail
	self assert: false
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResourceTestCase) methodsFor: 'Not categorized' !
setRun
	resource setRun
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResourceTestCase) methodsFor: 'Not categorized' !
setUp
	resource := SimpleTestResource current
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResourceTestCase) methodsFor: 'Not categorized' !
testRan
	| case |

	case := self class selector: #setRun.
	case run.
	self assert: resource hasSetup.
	self assert: resource hasRun
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResourceTestCase) methodsFor: 'Not categorized' !
testResourceInitRelease
	| result suite error failure |
	suite := TestSuite new.
	suite addTest: (error := self class selector: #error).
	suite addTest: (failure := self class selector: #fail).
	suite addTest: (self class selector: #dummy).
	result := suite run.
	self assert: resource hasSetup
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResourceTestCase) methodsFor: 'Not categorized' !
testResourcesCollection
	| collection |
	collection := self resources.
	self assert: collection size = 1
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Private' !
assertForTestResult: aResult runCount: aRunCount passed: aPassedCount failed: aFailureCount errors: anErrorCount

	self
		assert: aResult runCount = aRunCount;
		assert: aResult passedCount = aPassedCount;
		assert: aResult failureCount = aFailureCount;
		assert: aResult errorCount = anErrorCount
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Private' !
error
	3 zork
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Testing' !
errorShouldntRaise
	self 
		shouldnt: [self someMessageThatIsntUnderstood] 
		raise: SUnitNameResolver notificationObject
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Private' !
fail
	self assert: false
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Accessing' !
hasRun
	^hasRun
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Accessing' !
hasSetup
	^hasSetup
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Private' !
noop
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Private' !
setRun
	hasRun := true
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Running' !
setUp
	hasSetup := true
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Testing' !
testAssert
	self assert: true.
	self deny: false
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Testing' !
testDefects
	| result suite error failure |
	suite := TestSuite new.
	suite addTest: (error := self class selector: #error).
	suite addTest: (failure := self class selector: #fail).
	result := suite run.
	self assert: result defects asArray = (Array with: error with: failure).
	self
		assertForTestResult: result
		runCount: 2
		passed: 0
		failed: 1
		errors: 1
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Testing' !
testDialectLocalizedException

	self
		should: [TestResult signalFailureWith: 'Foo']
		raise: TestResult failure.
	self
		should: [TestResult signalErrorWith: 'Foo']
		raise: TestResult error.

			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Testing' !
testError

	| case result |

	case := self class selector: #error.
	result := case run.
	self
		assertForTestResult: result
		runCount: 1
		passed: 0
		failed: 0
		errors: 1.

	case := self class selector: #errorShouldntRaise.
	result := case run.
	self 
		assertForTestResult: result
		runCount: 1
		passed: 0
		failed: 0
		errors: 1
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Testing' !
testException

	self
		should: [self error: 'foo']
		raise: TestResult error
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Testing' !
testFail

	| case result |

	case := self class selector: #fail.
	result := case run.

	self
		assertForTestResult: result
		runCount: 1
		passed: 0
		failed: 1
		errors: 0
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Testing' !
testIsNotRerunOnDebug

	| case |

	case := self class selector: #testRanOnlyOnce.
	case run.
	case debug
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Testing' !
testRan

	| case |

	case := self class selector: #setRun.
	case run.
	self assert: case hasSetup.
	self assert: case hasRun
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Testing' !
testRanOnlyOnce

	self assert: hasRanOnce ~= true.
	hasRanOnce := true
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Testing' !
testResult

	| case result |

	case := self class selector: #noop.
	result := case run.

	self
		assertForTestResult: result
		runCount: 1
		passed: 1
		failed: 0
		errors: 0
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Testing' !
testRunning

	(SUnitDelay forSeconds: 2) wait
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Testing' !
testShould

	self
		should: [true];
		shouldnt: [false]
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Testing' !
testSuite

	| suite result |

	suite := TestSuite new.
	suite 
		addTest: (self class selector: #noop);
		addTest: (self class selector: #fail);
		addTest: (self class selector: #error).

	result := suite run.

	self
		assertForTestResult: result
		runCount: 3
		passed: 1
		failed: 1
		errors: 1
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResourceTestCase) classSide methodsFor: 'Not categorized' !
resources
	^Set new add: SimpleTestResource; yourself
			! !

"May 18, 2008 -> 7:37:18"!

"System saved" !
"May 18, 2008 -> 7:42:28"!

! (Delta mirrorFor: #Behavior) methodsFor: 'Camp Smalltalk' !
selectors

	|selectors|
	selectors := Set new.
	(ClassMirror on: self)
		methodsDo: [:method| selectors add: method selector asString].
	^selectors! !

"May 18, 2008 -> 7:43:55"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Accessing' !
allTestSelectors

	^self sunitAllSelectors select: [:each | 'test*' asString sunitMatch: each]
			! !

"May 18, 2008 -> 7:45:6"!

"System saved" !
"May 18, 2008 -> 14:22:54"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestSuite as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestSuite as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestSuite as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestSuite as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestSuite as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestSuite as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestSuite as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestSuite as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestSuite as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestSuite as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestSuite as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 14:23:20"!

"System saved" !
"May 18, 2008 -> 19:15:28"!

! (Delta mirrorFor: #DefinitionWriter) methodsFor: 'Unclassified' !
fileOutHeaderOn: stream <WriteStream> ^ <Int>

	self fileOutDefinition: self mirror definitionString on: stream.
	self fileOutRevision: self mirror revision on: stream.
	self fileOutGroup: self mirror group on: stream.
	self fileOutComment: self mirror comment on: stream.
! !

"May 18, 2008 -> 19:15:28"!

! (Delta mirrorFor: #DefinitionWriter) methodsFor: 'Unclassified' !
fileOutOn: stream <WriteStream> ^ <Int>

	| pos <Int> |
	self assert: [ self mirror isMeta not ].
	pos := stream position.
	self fileOutHeaderOn: stream.
	(self class for: self mirror classSide) fileOutBodyOn: stream.
	self fileOutBodyOn: stream.
	^pos
! !

"May 18, 2008 -> 19:15:28"!

! (Delta mirrorFor: #DefinitionWriter) methodsFor: 'Unclassified' !
fileOutMethodsOn: stream <WriteStream> ^ <Int>

	(self class for: self mirror classSide) fileOutBodyOn: stream.
	self fileOutBodyOn: stream! !

"May 18, 2008 -> 19:15:28"!

! (Delta mirrorFor: #DefinitionWriter) methodsFor: 'Unclassified' !
fileOutOn: stream <WriteStream> ^ <Int>

	| pos <Int> |
	self assert: [ self mirror isMeta not ].
	pos := stream position.
	self fileOutHeaderOn: stream.
	self fileOutMethodsOn: stream.
	^pos
! !

"May 18, 2008 -> 19:41:37"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Accessing' !
testSelectors

	^(self sunitSelectors 
		select: [:each | 'test*' sunitMatch: each])
		reject: [:each| each includes: $:]
			! !

"May 18, 2008 -> 19:42:10"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Accessing' !
allTestSelectors

	^(self sunitAllSelectors
		select: [:each | 'test*' asString sunitMatch: each])
		reject: [:each| each includes: $:]! !

"May 18, 2008 -> 19:44:51"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Accessing' !
allTestSelectors

	^(self sunitAllSelectors
		select: [:each | 'test*' sunitMatch: each])
		reject: [:each| each includes: $:]! !

"May 18, 2008 -> 19:46:20"!

! (Delta mirrorFor: #ReadString) methodsFor: 'Camp Smalltalk' !
sunitMatch: aString
 
        ^self match: aString! !

"May 18, 2008 -> 19:46:20"!

! (Delta mirrorFor: #ReadString) methodsFor: 'Camp Smalltalk' !
sunitSubStrings
 
        ^self substrings! !

"May 18, 2008 -> 19:59:43"!

! (Delta mirrorFor: #Class) methodsFor: 'Camp Smalltalk' !
allSubclasses

	^((ClassMirror on: self) subclasses
		collect: [:mirror| mirror reflectee])
		remove: self! !

"May 18, 2008 -> 20:0:5"!

! (Delta mirrorFor: #Class) methodsFor: 'Camp Smalltalk' !
allSubclasses

	^((ClassMirror on: self) subclasses
		collect: [:mirror| mirror reflectee])
		remove: self;
		yourself! !

"May 18, 2008 -> 20:13:18"!

Delta define: #FileOutSet as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 18, 2008 -> 20:13:47"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'adding' !
addClass: class

	! !

"May 18, 2008 -> 20:14:4"!

Delta define: #FileOutSet as: (
(Class subclassOf: 'Object' instanceVariables: 'classes
classCategories')) !


"May 18, 2008 -> 20:14:48"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'adding' !
initialize

	classes := OrderedCollection new.
	classCategories := Dictionary new! !

"May 18, 2008 -> 20:15:43"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'adding' !
addClass: class

	classes add: class! !

"May 18, 2008 -> 20:15:52"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'initialization' !
initialize

	classes := Set new.
	classCategories := Dictionary new! !

"May 18, 2008 -> 20:18:43"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'adding' !
addClass: class category: category

	(classes includes: class)
		ifTrue: [^self].
	classCategories
		at: class
		ifPresent: [:categories| categories add: category]
		ifAbsentPut: [Set with: category]! !

"May 18, 2008 -> 20:20:54"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
fileOutOn: stream

	self fileOutClassHeadersOn: stream.
	self fileOutClassMethodsOn: stream.
	self fileOutCategoriesOn: stream! !

"May 18, 2008 -> 20:21:49"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
fileOutClassHeadersOn: stream

	classes do: [:class|
		(self definitionWriterFor: class)
			fileOutHeaderOn: stream]! !

"May 18, 2008 -> 20:22:19"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
definitionWriterFor: class

	^(DefinitionWriter for: (ClassMirror on: class))! !

"May 18, 2008 -> 20:23:32"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
fileOutClassMethodsOn: stream

	classes do: [:class|
		(self definitionWriterFor: class)
			fileOutMethodsOn: stream]! !

"May 18, 2008 -> 20:24:28"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
fileOutCategoriesOn: stream

	classCategories keysAndValuesDo: [:class :category|
		(self definitionWriterFor: class)
			fileOutCategory: category on: stream]! !

"May 18, 2008 -> 20:26:59"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'adding' !
addClass: class

	classes add: class.
	classCategories remove: class! !

"May 18, 2008 -> 20:28:7"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'adding' !
addClass: class

	classes add: class.
	classCategories
		removeKey: class
		ifAbsent: []! !

"May 18, 2008 -> 20:31:16"!

! (Delta mirrorFor: #FileOutSet) classSide methodsFor: 'instance creation' !
new

	^(super new)
		initialize;
		yourself! !

"May 18, 2008 -> 20:43:39"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
fileOutCategoriesOn: stream

	classCategories keysAndValuesDo: [:class :categories|
		| definitionWriter |
		definitionWriter := self definitionWriterFor: class.
		categories do: [:category|
			Transcript show: class name, ' ', category.
			definitionWriter fileOutCategory: category on: stream]]! !

"May 18, 2008 -> 20:44:8"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
fileOutCategoriesOn: stream

	classCategories keysAndValuesDo: [:class :categories|
		| definitionWriter |
		definitionWriter := self definitionWriterFor: class.
		categories do: [:category|
			Transcript show: (class name, ' ', category); cr.
			definitionWriter fileOutCategory: category on: stream]]! !

"May 18, 2008 -> 20:45:17"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
fileOutCategoriesOn: stream

	classCategories keysAndValuesDo: [:class :categories|
		| definitionWriter |
		definitionWriter := self definitionWriterFor: class.
		categories do: [:category|
			definitionWriter fileOutCategory: category on: stream]]! !

"May 18, 2008 -> 20:51:49"!

"System saved" !
"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:20:22"!

(Delta mirrorFor: #BlockExceptionSelector)
comment: 
'Determines whether an exception can be handled by evaluating the handlesBlock.'!


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:20:22"!

(Delta mirrorFor: #BlockExceptionHandler)
comment: 
'Exception handler for an exception. Handles the exception by invoking its handleBlock.'!


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:20:22"!

(Delta mirrorFor: #BlockExceptionDescriptor)
comment: 
'Implements the <exceptionDescriptor> protocol from the ANSI standard using configurable actionsdefined as blocks. Intended to be used primarily as a testing aid.'!


"May 19, 2008 -> 4:20:22"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:20:23"!

(Delta mirrorFor: #LinkedExceptionHandler)
comment: 
'Exception handler for an exception. Invokes its handleBlock when asked to handle an exceptionthat matches its exceptionSelector. If the exception does not match its exceptionSelector it passesthe exception on to the nextHandler. If the nextHandler is undefined signal an UnhandledExceptionError.This class is internal to the exception handling framework. There should be no need for code outside of thisframework to interact with instances of ExceptionHandler.'!


"May 19, 2008 -> 4:20:23"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:20:23"!

(Delta mirrorFor: #Exception)
comment: 
'Base class of the exception hierarchy. Implements the core of the ANSI exception handling protocols'!


"May 19, 2008 -> 4:20:23"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

(Delta mirrorFor: #Error)
comment: 
''!


"May 19, 2008 -> 4:20:23"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

(Delta mirrorFor: #Notification)
comment: 
''!


"May 19, 2008 -> 4:20:23"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

(Delta mirrorFor: #MessageNotUnderstood)
comment: 
''!


"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'instantiation' !
handlesBlock: block

	^self new
		handlesBlock: block;
		yourself! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'test' !
test

	self testShouldHandleWhenHandleBlockReturnsTrue;
		testShouldPassExceptionToHandlesBlock! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'test' !
testShouldHandleWhenHandleBlockReturnsTrue

	|canHandle selector|
	selector := BlockExceptionSelector handlesBlock: [:ex| canHandle].
	canHandle := true.
	[selector handles: nil] verify.
	canHandle := false.
	[(selector handles: nil) not] verify! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'test' !
testShouldPassExceptionToHandlesBlock

	|exception selector|
	exception := Object new.
	selector := BlockExceptionSelector handlesBlock: [:ex| [ex == exception] verify].
	selector handles: exception! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionSelector) methodsFor: 'exception selector' !
handles: exceptionDescriptor

	^handlesBlock value: exceptionDescriptor! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionSelector) methodsFor: 'initialization' !
handlesBlock: block

	handlesBlock := block ! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
handleBlock: block

	^self new
		handleBlock: block;
		yourself! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
new

	^super new initialize! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'tests' !
test

	self testShouldInvokeHandlerBlockWithException! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'tests' !
testShouldInvokeHandlerBlockWithException

	|handled exception|
	handled := false.
	exception = Object new.
	(BlockExceptionHandler
		handleBlock: [:ex| [ex == exception] verify.
			handled := true])
		handle: exception.
	[handled] verify! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
canHandleSignal: exception

	^false! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
handle: exception

	^handleBlock value: exception! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
handle: exception return: aBlock

	^aBlock value: (handleBlock value: exception)! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
nextHandler

	^nil! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
nextHandler: ignored! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
pass: exception

	passBlock value: exception! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
passBlock: block

	passBlock := block! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
return: value

	returnBlock value: value! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
returnBlock: block

	returnBlock := block! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'private initialization' !
handleBlock: block

	handleBlock := block! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'private initialization' !
initialize

	handleBlock := [:exception|].
	passBlock := [:exception|].! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'instantiation' !
new

	^super new
		initialize;
		yourself! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'test' !
test

	self testDefaultActionShouldInvokeDefaultActionBlock;
		testDefaultDefault;
		testHandlerShouldDelegateToHandlerBlock! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'test' !
testDefaultActionShouldInvokeDefaultActionBlock

	|exception wasInvoked|
	exception := BlockExceptionDescriptor new.
	wasInvoked := false.
	exception defaultActionBlock: [wasInvoked := true].
	exception defaultAction.
	[wasInvoked] verify! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'test' !
testDefaultDefault

	|exception wasInvoked|
	exception := BlockExceptionDescriptor new.
	exception defaultAction! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'test' !
testHandlerShouldDelegateToHandlerBlock

	|descriptor actualHandler|
	descriptor := BlockExceptionDescriptor new.
	descriptor handlerBlock: [:handler| actualHandler := handler].
	descriptor handler: #handler.
	[actualHandler == #handler] verify! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
defaultActionBlock: block

	defaultBlock := block! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
handler: handler

	handlerBlock value: handler ! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
handlerBlock: block

	handlerBlock := block ! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'exception descriptor' !
defaultAction

	defaultBlock value! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'initialization' !
initialize

	defaultBlock := [].
	handlerBlock := [:ignore|]! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'exceptionBuilder' !
on: anExceptionSelector do: handleBlock

	^self new
		on: anExceptionSelector
		do: handleBlock
		return: [:value|]
		outer: nil;
		yourself! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'exceptionBuilder' !
on: anExceptionSelector do: handleBlock return: returnBlock

	^self new
		on: anExceptionSelector
		do: handleBlock
		return: returnBlock
		outer: nil;
		yourself! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'exceptionBuilder' !
on: anExceptionSelector do: handleBlock return: returnBlock outer: outerBlock

	^self new
		on: anExceptionSelector
		do: handleBlock
		return: returnBlock
		outer: outerBlock;
		yourself! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
test

	self testShouldInvokeHandleBlockWhenExceptionMatches;
		testShouldInvokeExceptionsDefaultActionWhenNoNextHandler;
		testShouldDelegateToNextHandlerWhenNoMatch;
		testHandlerShouldSetHandlerOnException;
		testPassShouldDeferToNextHandler;
		testReturnShouldEvaluateReturnBlock! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testHandlerShouldSetHandlerOnException

	|handler trueSelector exception assignedHandler|
	trueSelector := BlockExceptionSelector handlesBlock: [:ex| true].
	exception := BlockExceptionDescriptor new.
	exception handlerBlock: [:handler| assignedHandler := handler].
	handler := LinkedExceptionHandler on: trueSelector do: [:ex| ].
	[assignedHandler ~~ handler] verify.
	handler handle: exception.
	[assignedHandler == handler] verify! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testPassShouldDeferToNextHandler

	|handler trueSelector exception wasPassed nextHandler|
	trueSelector := BlockExceptionSelector handlesBlock: [:ex| true].
	exception := BlockExceptionDescriptor new.
	handler := LinkedExceptionHandler on: trueSelector do: [:ex| ].
	nextHandler := BlockExceptionHandler handleBlock: [:ex| wasPassed := true].
	handler nextHandler: nextHandler.
	wasPassed := false.
	handler pass: exception.
	[wasPassed] verify	! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testReturnShouldEvaluateReturnBlock

	|handler result |
	handler := LinkedExceptionHandler
			on: nil
			do: [:ex| ]
			return: [:returnValue| result := returnValue].
	handler return: #value.
	[result == #value] verify! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testShouldDelegateToNextHandlerWhenNoMatch

	|handled falseSelector exception nextHandler|
	handled := false.
	falseSelector := BlockExceptionSelector handlesBlock: [:ex| false].
	exception := BlockExceptionDescriptor new.
	nextHandler := (BlockExceptionHandler
				handleBlock: [:ex| [ex == exception] verify.
					handled := true]).
	(LinkedExceptionHandler on: falseSelector do: [:ex| self shouldNotHappen])
		nextHandler: nextHandler;
		handle: exception.
	[handled] verify! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testShouldInvokeExceptionsDefaultActionWhenNoNextHandler

	|handled falseSelector exception|
	handled := false.
	falseSelector := BlockExceptionSelector handlesBlock: [:ex| false].
	exception := BlockExceptionDescriptor new.
	exception defaultActionBlock: [handled := true].
	(LinkedExceptionHandler on: falseSelector do: [:ex| self shouldNotHappen])
		handle: exception.
	[handled] verify! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testShouldInvokeHandleBlockWhenExceptionMatches

	|handled trueSelector exception|
	handled := false.
	exception := BlockExceptionDescriptor new.
	trueSelector := BlockExceptionSelector handlesBlock: [:ex| true].
	(LinkedExceptionHandler
		on: trueSelector
		do: [:ex| [ex == exception] verify.
			handled := true])
		handle: exception.
	[handled] verify! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
canHandleSignal: exception

	^(exceptionSelector handles: exception)
		or: [nextHandler notNil
			and: [nextHandler canHandleSignal: exception]]! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]].
	result := protectee value.
	^[result]! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
handle: exception

	self handle: exception
		return: returnBlock! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
handle: exception return: aReturnBlock

	exception handler: self.
	^(exceptionSelector handles: exception)
		ifTrue: [aReturnBlock value: (handleBlock value: exception)]
		ifFalse: [nextHandler handle: exception return: aReturnBlock]! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
nextHandler

	^nextHandler! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
outer: exception return: aReturnBlock

	^nextHandler handle: exception return: aReturnBlock! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
pass: exception

	^nextHandler handle: exception! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
protect: aBlock

	Processor activeProcess pushHandler: self.
	^[(self evaluateProtectee: aBlock) value]
		ensure: [Processor activeProcess popHandler]! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
retry

	retryBlock value! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
retryUsing: aBlock

	protectee := aBlock.
	retryBlock value! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
return: aValue

	returnBlock value: aValue! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
nextHandler: exceptionHandler

	nextHandler := exceptionHandler ! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler handleBlock: [:ex| ex defaultAction] ! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionInstantiator' !
signal
"Signal the occurrence of an exceptional condition."
	^ self new signal! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionInstantiator' !
signal: signalerText
"Signal the occurrence of an exceptional condition with a specified textual description."
	^ self new signal: signalerText! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionSelector' !
, anotherException
"Create an exception set."
"
	^ExceptionSet new
		add: self;
		add: anotherException;
		yourself"! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionSelector' !
handles: exception
"Determine whether an exception handler will accept a signaled exception."
	^ exception isKindOf: self! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
test

	self testSignalShouldInvokeProcessHandler;
		testPassShouldDeferToOuterHandler;
		testPassShouldNotReturn;
		testPassShouldInvokeDefaultActionWithoutReturning;
		testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable;
		testOuterShouldInvokeAndReturnDefaultActionWhenResumable;
		testOuterTwiceShouldInvokeSurroundingHandlerTwice;
		testResumeShouldReturnAsValueOfOuter;
		testResumeShouldReturnFromSignal;
		testResumeWithValueShouldReturnFromSignal;
		testReturnShouldDelegateToHandler;
		testIsNestedShouldBeFalseWithNoHandler;
		testIsNestedShouldBeTrueWhenOuterHandlerHandles;
		testIsNestedShouldBeFalseWhenOuterHandlerDoesntHandle;
		testIsNestedShouldBeTrueWhenOuterOuterHandlerHandles;
		testResignalAsShouldRestoreSignalEnvironment;
		testRetryShouldReevaluateProtectee;
		testRetryUsingShouldReplaceProtectee! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testIsNestedShouldBeFalseWhenOuterHandlerDoesntHandle

	|result|
	[[Exception signal]
		on: Exception
		do: [:ex| result := ex isNested]]
		on: TestException
		do: [:ex|].
	[result not] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testIsNestedShouldBeFalseWithNoHandler

	|exception|
	exception := Exception new.
	[exception isNested not] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testIsNestedShouldBeTrueWhenOuterHandlerHandles

	|result|
	[[Exception signal]
		on: Exception
		do: [:ex| result := ex isNested]]
		on: Exception
		do: [:ex| self shouldNotHappen].
	[result] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testIsNestedShouldBeTrueWhenOuterOuterHandlerHandles

	|result|
	[[[Exception signal]
		on: Exception
		do: [:ex| result := ex isNested]]
		on: TestException
		do: [:ex|]]
		on: Exception
		do: [:ex|].
	[result] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable

	|outer result|
	[(TestException defaultActionBlock: [#result])
		resumable: true;
		signal]
		on: TestException
		do: [:ex| outer := ex outer.
			result := #returned].
	[result == #returned] verify.
	[outer == #result] verify.! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	[([|result|
	result := (TestException defaultActionBlock: [#result])
		signal.
	[result == #result] verify.
	result]
		on: TestException
		do: [:ex| ex outer.
			self shouldNotHappen]) == #result] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testOuterTwiceShouldInvokeSurroundingHandlerTwice

	|count|	count := 0.
	[[(TestException defaultActionBlock: [-1])
		resumable: true;
		signal]
		on: TestException
		do: [:ex| ex outer.
			ex outer]]
		on: TestException
		do: [:ex| count := count + 1].
	[count == 2] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	[wasPassed] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testPassShouldInvokeDefaultActionWithoutReturning

	[([|result|
	result := (TestException defaultActionBlock: [#result])
			signal.
	[result == #result] verify.
	result]
		on: TestException
		do: [:ex| ex pass.
			self shouldNotHappen]) == #result] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testPassShouldNotReturn

	[([[Exception signal]
		on: Exception
		do: [:ex| ex pass.
			self shouldNotHappen]]
		on: Exception
		do: [:ex| #result]) == #result] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testResignalAsShouldRestoreSignalEnvironment

	|log|
	log := String new writeStream.
	[[Exception signal]
		on: TestException
		do: [:ex| log nextPutAll: 'resignal']]
		on: Exception
		do: [:ex| [log nextPutAll: 'signal '.
			ex resignalAs: TestException new]
				ifCurtailed: [log nextPutAll: 'curtail ']].
	[log contents = 'signal curtail resignal'] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testResumeShouldReturnAsValueOfOuter

	|result|
	[[Exception signal]
		on: Exception
		do: [:ex| result := ex outer]]
		on: Exception
		do: [:ex| ex resume: #result].
	[result == #result] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testResumeShouldReturnFromSignal

	|wasResumed|
	wasResumed := false.
	[Exception signal.
	wasResumed := true]
		on: Exception
		do: [:ex| ex resume].
	[wasResumed] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testResumeWithValueShouldReturnFromSignal

	|result|
	[result := Exception signal]
		on: Exception
		do: [:ex| ex resume: #result].
	[result == #result] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testRetryShouldReevaluateProtectee

	|count|
	count := 0.
	[count := count + 1.
	count == 1 ifTrue:[Exception signal]]
		on: Exception
		do: [:ex| ex retry].
	[count == 2] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testRetryUsingShouldReplaceProtectee

	|log count|
	log := String new writeStream.
	count := 0.
	[[Exception signal] ensure: [log nextPutAll: 'unwind ']]
		on: Exception
		do: [:ex|
			log nextPutAll: 'handle '.
			count := count + 1.
			count = 1 ifTrue: [ex retryUsing: [log nextPutAll: 'using '.
								Exception signal]]].
	[log contents = 'handle unwind using handle '] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testReturnShouldDelegateToHandler

	|exception handler result|
	exception := Exception new.
	handler := BlockExceptionHandler new.
	result := #invalid.
	handler returnBlock: [:value| result := value].
	exception handler: handler.
	exception return.
	[result isNil] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testSignalShouldInvokeProcessHandler

	|wasInvoked|
	wasInvoked := false.
	Processor activeProcess
		pushHandler: (BlockExceptionHandler
				handleBlock: [:ex| wasInvoked := true]).
	Exception signal.
	[[wasInvoked] verify]
		ensure: [Processor activeProcess popHandler]! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'exceptionBuilder' !
tag: t
"This message is not specified in the ANSI protocol,
but that looks like an oversight because #tag is specified,
and the spec states that the signaler may store the tag value."
	tag := t! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'exceptionDescription' !
tag
"Return an exception's tag value."
	^tag == nil
		ifTrue: [self messageText]
		ifFalse: [tag]! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
isNested
"Determine whether the current exception handler is within 
the scope of another handler for the same exception."
	^ handler notNil and: [handler nextHandler canHandleSignal: self]! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
outer
"Evaluate the enclosing exception action and return to here 
instead of signal if it resumes (see #resumeUnchecked:)."
	| oldHandler oldResume |
	self isResumable
		ifFalse: [self pass].
	[oldResume := resumeBlock.
	resumeBlock := [:value| ^value].
	(oldHandler := handler) outer: self return: [:value| ^value]]
		ensure: [handler := oldHandler.
			resumeBlock := oldResume]! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
pass
"Yield control to the enclosing exception action for the receiver."
	passBlock value! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resignalAs: replacementException
"Signal an alternative exception in place of the receiver."
	resignalBlock value: replacementException! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resume
"Return from the message that signaled the receiver."
	self resume: nil! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resume: resumptionValue
"Return resumptionValue as the value of the signal message."
	resumeBlock value: resumptionValue! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
retry
"Abort an exception handler and re-evaluate its protected block."
	handler retry! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
retryUsing: alternativeBlock
"Abort an exception handler and evaluate a new block 
in place of the handler's protected block."
	handler retryUsing: alternativeBlock! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
return
"Return nil as the value of the block protected 
by the active exception handler."
	self return: nil! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
return: returnValue
"Return the argument as the value of the block protected 
by the active exception handler."
	handler return: returnValue! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
description
"Return a textual description of the exception."
	| desc mt |
	desc := self class name asString.
	^(mt := self messageText) == nil
		ifTrue: [desc]
		ifFalse: [desc, ': ', mt]! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
messageText
"Return an exception's message text."
	^messageText! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
printOn: stream

	stream nextPutAll: self description! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
defaultAction
"The default action taken if the exception is signaled."
	self subclassResponsibility! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
handler: aHandler

	handler := aHandler! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
isResumable
"Determine whether an exception is resumable."
	^ true! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
messageText: signalerText
"Set an exception's message text."
	messageText := signalerText! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
privateSignal
"Ask ContextHandlers in the sender chain to handle this signal.
The default is to execute and return my defaultAction."
	resignalBlock := [:ex| ^[ex signal]].
	resumeBlock := [:result| ^[result]].
	passBlock := [^[handler pass: self]].
	Processor activeProcess handle: self.
	^[]! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
signal

	^self privateSignal value! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
signal: signalerText
"Signal the occurrence of an exceptional condition with a 
specified textual description."
	self messageText: signalerText.
	^ self signal! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handle: exception

	^self handlerChain handle: exception! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler handleBlock: [:ex| ex defaultAction]].
	^handlerChain! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
popHandler

	handlerChain := self handlerChain nextHandler ! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
pushHandler: handler

	handler nextHandler: self handlerChain.
	handlerChain := handler ! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
resetHandlers

	handlerChain := nil

! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'exceptions' !
on: exception do: handlerBlock

	^(LinkedExceptionHandler
		on: exception
		do: handlerBlock
		return: [:value | ^ value]) protect: self
! !

"May 19, 2008 -> 4:23:13"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:23:13"!

(Delta mirrorFor: #BlockExceptionSelector)
comment: 
'Determines whether an exception can be handled by evaluating the handlesBlock.'!


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:23:13"!

(Delta mirrorFor: #BlockExceptionHandler)
comment: 
'Exception handler for an exception. Handles the exception by invoking its handleBlock.'!


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:23:13"!

(Delta mirrorFor: #BlockExceptionDescriptor)
comment: 
'Implements the <exceptionDescriptor> protocol from the ANSI standard using configurable actionsdefined as blocks. Intended to be used primarily as a testing aid.'!


"May 19, 2008 -> 4:23:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:23:13"!

(Delta mirrorFor: #LinkedExceptionHandler)
comment: 
'Exception handler for an exception. Invokes its handleBlock when asked to handle an exceptionthat matches its exceptionSelector. If the exception does not match its exceptionSelector it passesthe exception on to the nextHandler. If the nextHandler is undefined signal an UnhandledExceptionError.This class is internal to the exception handling framework. There should be no need for code outside of thisframework to interact with instances of ExceptionHandler.'!


"May 19, 2008 -> 4:23:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:23:13"!

(Delta mirrorFor: #Exception)
comment: 
'Base class of the exception hierarchy. Implements the core of the ANSI exception handling protocols'!


"May 19, 2008 -> 4:23:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

(Delta mirrorFor: #Error)
comment: 
''!


"May 19, 2008 -> 4:23:13"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

(Delta mirrorFor: #Notification)
comment: 
''!


"May 19, 2008 -> 4:23:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

(Delta mirrorFor: #MessageNotUnderstood)
comment: 
''!


"May 19, 2008 -> 4:23:13"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'instantiation' !
handlesBlock: block

	^self new
		handlesBlock: block;
		yourself! !

"May 19, 2008 -> 4:23:13"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'test' !
test

	self testShouldHandleWhenHandleBlockReturnsTrue;
		testShouldPassExceptionToHandlesBlock! !

"May 19, 2008 -> 4:23:13"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'test' !
testShouldHandleWhenHandleBlockReturnsTrue

	|canHandle selector|
	selector := BlockExceptionSelector handlesBlock: [:ex| canHandle].
	canHandle := true.
	[selector handles: nil] verify.
	canHandle := false.
	[(selector handles: nil) not] verify! !

"May 19, 2008 -> 4:23:13"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'test' !
testShouldPassExceptionToHandlesBlock

	|exception selector|
	exception := Object new.
	selector := BlockExceptionSelector handlesBlock: [:ex| [ex == exception] verify].
	selector handles: exception! !

"May 19, 2008 -> 4:23:13"!

! (Delta mirrorFor: #BlockExceptionSelector) methodsFor: 'exception selector' !
handles: exceptionDescriptor

	^handlesBlock value: exceptionDescriptor! !

"May 19, 2008 -> 4:23:13"!

! (Delta mirrorFor: #BlockExceptionSelector) methodsFor: 'initialization' !
handlesBlock: block

	handlesBlock := block ! !

"May 19, 2008 -> 4:23:13"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
handleBlock: block

	^self new
		handleBlock: block;
		yourself! !

"May 19, 2008 -> 4:23:13"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
new

	^super new initialize! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'tests' !
test

	self testShouldInvokeHandlerBlockWithException! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'tests' !
testShouldInvokeHandlerBlockWithException

	|handled exception|
	handled := false.
	exception = Object new.
	(BlockExceptionHandler
		handleBlock: [:ex| [ex == exception] verify.
			handled := true])
		handle: exception.
	[handled] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
canHandleSignal: exception

	^false! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
handle: exception

	^handleBlock value: exception! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
handle: exception return: aBlock

	^aBlock value: (handleBlock value: exception)! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
nextHandler

	^nil! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
nextHandler: ignored! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
pass: exception

	passBlock value: exception! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
passBlock: block

	passBlock := block! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
return: value

	returnBlock value: value! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
returnBlock: block

	returnBlock := block! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'private initialization' !
handleBlock: block

	handleBlock := block! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'private initialization' !
initialize

	handleBlock := [:exception|].
	passBlock := [:exception|].! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'instantiation' !
new

	^super new
		initialize;
		yourself! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'test' !
test

	self testDefaultActionShouldInvokeDefaultActionBlock;
		testDefaultDefault;
		testHandlerShouldDelegateToHandlerBlock! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'test' !
testDefaultActionShouldInvokeDefaultActionBlock

	|exception wasInvoked|
	exception := BlockExceptionDescriptor new.
	wasInvoked := false.
	exception defaultActionBlock: [wasInvoked := true].
	exception defaultAction.
	[wasInvoked] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'test' !
testDefaultDefault

	|exception wasInvoked|
	exception := BlockExceptionDescriptor new.
	exception defaultAction! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'test' !
testHandlerShouldDelegateToHandlerBlock

	|descriptor actualHandler|
	descriptor := BlockExceptionDescriptor new.
	descriptor handlerBlock: [:handler| actualHandler := handler].
	descriptor handler: #handler.
	[actualHandler == #handler] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
defaultActionBlock: block

	defaultBlock := block! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
handler: handler

	handlerBlock value: handler ! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
handlerBlock: block

	handlerBlock := block ! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'exception descriptor' !
defaultAction

	defaultBlock value! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'initialization' !
initialize

	defaultBlock := [].
	handlerBlock := [:ignore|]! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'exceptionBuilder' !
on: anExceptionSelector do: handleBlock

	^self new
		on: anExceptionSelector
		do: handleBlock
		return: [:value|]
		outer: nil;
		yourself! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'exceptionBuilder' !
on: anExceptionSelector do: handleBlock return: returnBlock

	^self new
		on: anExceptionSelector
		do: handleBlock
		return: returnBlock
		outer: nil;
		yourself! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'exceptionBuilder' !
on: anExceptionSelector do: handleBlock return: returnBlock outer: outerBlock

	^self new
		on: anExceptionSelector
		do: handleBlock
		return: returnBlock
		outer: outerBlock;
		yourself! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
test

	self testShouldInvokeHandleBlockWhenExceptionMatches;
		testShouldInvokeExceptionsDefaultActionWhenNoNextHandler;
		testShouldDelegateToNextHandlerWhenNoMatch;
		testHandlerShouldSetHandlerOnException;
		testPassShouldDeferToNextHandler;
		testReturnShouldEvaluateReturnBlock! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testHandlerShouldSetHandlerOnException

	|handler trueSelector exception assignedHandler|
	trueSelector := BlockExceptionSelector handlesBlock: [:ex| true].
	exception := BlockExceptionDescriptor new.
	exception handlerBlock: [:handler| assignedHandler := handler].
	handler := LinkedExceptionHandler on: trueSelector do: [:ex| ].
	[assignedHandler ~~ handler] verify.
	handler handle: exception.
	[assignedHandler == handler] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testPassShouldDeferToNextHandler

	|handler trueSelector exception wasPassed nextHandler|
	trueSelector := BlockExceptionSelector handlesBlock: [:ex| true].
	exception := BlockExceptionDescriptor new.
	handler := LinkedExceptionHandler on: trueSelector do: [:ex| ].
	nextHandler := BlockExceptionHandler handleBlock: [:ex| wasPassed := true].
	handler nextHandler: nextHandler.
	wasPassed := false.
	handler pass: exception.
	[wasPassed] verify	! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testReturnShouldEvaluateReturnBlock

	|handler result |
	handler := LinkedExceptionHandler
			on: nil
			do: [:ex| ]
			return: [:returnValue| result := returnValue].
	handler return: #value.
	[result == #value] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testShouldDelegateToNextHandlerWhenNoMatch

	|handled falseSelector exception nextHandler|
	handled := false.
	falseSelector := BlockExceptionSelector handlesBlock: [:ex| false].
	exception := BlockExceptionDescriptor new.
	nextHandler := (BlockExceptionHandler
				handleBlock: [:ex| [ex == exception] verify.
					handled := true]).
	(LinkedExceptionHandler on: falseSelector do: [:ex| self shouldNotHappen])
		nextHandler: nextHandler;
		handle: exception.
	[handled] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testShouldInvokeExceptionsDefaultActionWhenNoNextHandler

	|handled falseSelector exception|
	handled := false.
	falseSelector := BlockExceptionSelector handlesBlock: [:ex| false].
	exception := BlockExceptionDescriptor new.
	exception defaultActionBlock: [handled := true].
	(LinkedExceptionHandler on: falseSelector do: [:ex| self shouldNotHappen])
		handle: exception.
	[handled] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testShouldInvokeHandleBlockWhenExceptionMatches

	|handled trueSelector exception|
	handled := false.
	exception := BlockExceptionDescriptor new.
	trueSelector := BlockExceptionSelector handlesBlock: [:ex| true].
	(LinkedExceptionHandler
		on: trueSelector
		do: [:ex| [ex == exception] verify.
			handled := true])
		handle: exception.
	[handled] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
canHandleSignal: exception

	^(exceptionSelector handles: exception)
		or: [nextHandler notNil
			and: [nextHandler canHandleSignal: exception]]! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]].
	result := protectee value.
	^[result]! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
handle: exception

	self handle: exception
		return: returnBlock! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
handle: exception return: aReturnBlock

	exception handler: self.
	^(exceptionSelector handles: exception)
		ifTrue: [aReturnBlock value: (handleBlock value: exception)]
		ifFalse: [nextHandler handle: exception return: aReturnBlock]! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
nextHandler

	^nextHandler! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
outer: exception return: aReturnBlock

	^nextHandler handle: exception return: aReturnBlock! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
pass: exception

	^nextHandler handle: exception! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
protect: aBlock

	Processor activeProcess pushHandler: self.
	^[(self evaluateProtectee: aBlock) value]
		ensure: [Processor activeProcess popHandler]! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
retry

	retryBlock value! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
retryUsing: aBlock

	protectee := aBlock.
	retryBlock value! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
return: aValue

	returnBlock value: aValue! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
nextHandler: exceptionHandler

	nextHandler := exceptionHandler ! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler handleBlock: [:ex| ex defaultAction] ! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionInstantiator' !
signal
"Signal the occurrence of an exceptional condition."
	^ self new signal! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionInstantiator' !
signal: signalerText
"Signal the occurrence of an exceptional condition with a specified textual description."
	^ self new signal: signalerText! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionSelector' !
, anotherException
"Create an exception set."
"
	^ExceptionSet new
		add: self;
		add: anotherException;
		yourself"! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionSelector' !
handles: exception
"Determine whether an exception handler will accept a signaled exception."
	^ exception isKindOf: self! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
test

	self testSignalShouldInvokeProcessHandler;
		testPassShouldDeferToOuterHandler;
		testPassShouldNotReturn;
		testPassShouldInvokeDefaultActionWithoutReturning;
		testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable;
		testOuterShouldInvokeAndReturnDefaultActionWhenResumable;
		testOuterTwiceShouldInvokeSurroundingHandlerTwice;
		testResumeShouldReturnAsValueOfOuter;
		testResumeShouldReturnFromSignal;
		testResumeWithValueShouldReturnFromSignal;
		testReturnShouldDelegateToHandler;
		testIsNestedShouldBeFalseWithNoHandler;
		testIsNestedShouldBeTrueWhenOuterHandlerHandles;
		testIsNestedShouldBeFalseWhenOuterHandlerDoesntHandle;
		testIsNestedShouldBeTrueWhenOuterOuterHandlerHandles;
		testResignalAsShouldRestoreSignalEnvironment;
		testRetryShouldReevaluateProtectee;
		testRetryUsingShouldReplaceProtectee! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testIsNestedShouldBeFalseWhenOuterHandlerDoesntHandle

	|result|
	[[Exception signal]
		on: Exception
		do: [:ex| result := ex isNested]]
		on: TestException
		do: [:ex|].
	[result not] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testIsNestedShouldBeFalseWithNoHandler

	|exception|
	exception := Exception new.
	[exception isNested not] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testIsNestedShouldBeTrueWhenOuterHandlerHandles

	|result|
	[[Exception signal]
		on: Exception
		do: [:ex| result := ex isNested]]
		on: Exception
		do: [:ex| self shouldNotHappen].
	[result] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testIsNestedShouldBeTrueWhenOuterOuterHandlerHandles

	|result|
	[[[Exception signal]
		on: Exception
		do: [:ex| result := ex isNested]]
		on: TestException
		do: [:ex|]]
		on: Exception
		do: [:ex|].
	[result] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable

	|outer result|
	[(TestException defaultActionBlock: [#result])
		resumable: true;
		signal]
		on: TestException
		do: [:ex| outer := ex outer.
			result := #returned].
	[result == #returned] verify.
	[outer == #result] verify.! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	[([|result|
	result := (TestException defaultActionBlock: [#result])
		signal.
	[result == #result] verify.
	result]
		on: TestException
		do: [:ex| ex outer.
			self shouldNotHappen]) == #result] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testOuterTwiceShouldInvokeSurroundingHandlerTwice

	|count|	count := 0.
	[[(TestException defaultActionBlock: [-1])
		resumable: true;
		signal]
		on: TestException
		do: [:ex| ex outer.
			ex outer]]
		on: TestException
		do: [:ex| count := count + 1].
	[count == 2] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	[wasPassed] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testPassShouldInvokeDefaultActionWithoutReturning

	[([|result|
	result := (TestException defaultActionBlock: [#result])
			signal.
	[result == #result] verify.
	result]
		on: TestException
		do: [:ex| ex pass.
			self shouldNotHappen]) == #result] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testPassShouldNotReturn

	[([[Exception signal]
		on: Exception
		do: [:ex| ex pass.
			self shouldNotHappen]]
		on: Exception
		do: [:ex| #result]) == #result] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testResignalAsShouldRestoreSignalEnvironment

	|log|
	log := String new writeStream.
	[[Exception signal]
		on: TestException
		do: [:ex| log nextPutAll: 'resignal']]
		on: Exception
		do: [:ex| [log nextPutAll: 'signal '.
			ex resignalAs: TestException new]
				ifCurtailed: [log nextPutAll: 'curtail ']].
	[log contents = 'signal curtail resignal'] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testResumeShouldReturnAsValueOfOuter

	|result|
	[[Exception signal]
		on: Exception
		do: [:ex| result := ex outer]]
		on: Exception
		do: [:ex| ex resume: #result].
	[result == #result] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testResumeShouldReturnFromSignal

	|wasResumed|
	wasResumed := false.
	[Exception signal.
	wasResumed := true]
		on: Exception
		do: [:ex| ex resume].
	[wasResumed] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testResumeWithValueShouldReturnFromSignal

	|result|
	[result := Exception signal]
		on: Exception
		do: [:ex| ex resume: #result].
	[result == #result] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testRetryShouldReevaluateProtectee

	|count|
	count := 0.
	[count := count + 1.
	count == 1 ifTrue:[Exception signal]]
		on: Exception
		do: [:ex| ex retry].
	[count == 2] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testRetryUsingShouldReplaceProtectee

	|log count|
	log := String new writeStream.
	count := 0.
	[[Exception signal] ensure: [log nextPutAll: 'unwind ']]
		on: Exception
		do: [:ex|
			log nextPutAll: 'handle '.
			count := count + 1.
			count = 1 ifTrue: [ex retryUsing: [log nextPutAll: 'using '.
								Exception signal]]].
	[log contents = 'handle unwind using handle '] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testReturnShouldDelegateToHandler

	|exception handler result|
	exception := Exception new.
	handler := BlockExceptionHandler new.
	result := #invalid.
	handler returnBlock: [:value| result := value].
	exception handler: handler.
	exception return.
	[result isNil] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testSignalShouldInvokeProcessHandler

	|wasInvoked|
	wasInvoked := false.
	Processor activeProcess
		pushHandler: (BlockExceptionHandler
				handleBlock: [:ex| wasInvoked := true]).
	Exception signal.
	[[wasInvoked] verify]
		ensure: [Processor activeProcess popHandler]! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'exceptionBuilder' !
tag: t
"This message is not specified in the ANSI protocol,
but that looks like an oversight because #tag is specified,
and the spec states that the signaler may store the tag value."
	tag := t! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'exceptionDescription' !
tag
"Return an exception's tag value."
	^tag == nil
		ifTrue: [self messageText]
		ifFalse: [tag]! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
isNested
"Determine whether the current exception handler is within 
the scope of another handler for the same exception."
	^ handler notNil and: [handler nextHandler canHandleSignal: self]! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
outer
"Evaluate the enclosing exception action and return to here 
instead of signal if it resumes (see #resumeUnchecked:)."
	| oldHandler oldResume |
	self isResumable
		ifFalse: [self pass].
	[oldResume := resumeBlock.
	resumeBlock := [:value| ^value].
	(oldHandler := handler) outer: self return: [:value| ^value]]
		ensure: [handler := oldHandler.
			resumeBlock := oldResume]! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
pass
"Yield control to the enclosing exception action for the receiver."
	passBlock value! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resignalAs: replacementException
"Signal an alternative exception in place of the receiver."
	resignalBlock value: replacementException! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resume
"Return from the message that signaled the receiver."
	self resume: nil! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resume: resumptionValue
"Return resumptionValue as the value of the signal message."
	resumeBlock value: resumptionValue! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
retry
"Abort an exception handler and re-evaluate its protected block."
	handler retry! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
retryUsing: alternativeBlock
"Abort an exception handler and evaluate a new block 
in place of the handler's protected block."
	handler retryUsing: alternativeBlock! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
return
"Return nil as the value of the block protected 
by the active exception handler."
	self return: nil! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
return: returnValue
"Return the argument as the value of the block protected 
by the active exception handler."
	handler return: returnValue! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
description
"Return a textual description of the exception."
	| desc mt |
	desc := self class name asString.
	^(mt := self messageText) == nil
		ifTrue: [desc]
		ifFalse: [desc, ': ', mt]! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
messageText
"Return an exception's message text."
	^messageText! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
printOn: stream

	stream nextPutAll: self description! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
defaultAction
"The default action taken if the exception is signaled."
	self subclassResponsibility! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
handler: aHandler

	handler := aHandler! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
isResumable
"Determine whether an exception is resumable."
	^ true! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
messageText: signalerText
"Set an exception's message text."
	messageText := signalerText! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
privateSignal
"Ask ContextHandlers in the sender chain to handle this signal.
The default is to execute and return my defaultAction."
	resignalBlock := [:ex| ^[ex signal]].
	resumeBlock := [:result| ^[result]].
	passBlock := [^[handler pass: self]].
	Processor activeProcess handle: self.
	^[]! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
signal

	^self privateSignal value! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
signal: signalerText
"Signal the occurrence of an exceptional condition with a 
specified textual description."
	self messageText: signalerText.
	^ self signal! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handle: exception

	^self handlerChain handle: exception! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler handleBlock: [:ex| ex defaultAction]].
	^handlerChain! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
popHandler

	handlerChain := self handlerChain nextHandler ! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
pushHandler: handler

	handler nextHandler: self handlerChain.
	handlerChain := handler ! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
resetHandlers

	handlerChain := nil

! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'exceptions' !
on: exception do: handlerBlock

	^(LinkedExceptionHandler
		on: exception
		do: handlerBlock
		return: [:value | ^ value]) protect: self
! !

"May 19, 2008 -> 4:23:45"!

"System saved" !
"May 19, 2008 -> 18:11:13"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'control' !
continueProcess

	|topWindow|
	self process resume.
	self process: nil.		"Don't terminate process when window closes"
	"self requestCloseIfTopWindow."
	topWindow := self visual topWindow
	topWindow isNil
		ifFalse: [topWindow requestClose]! !

"May 19, 2008 -> 18:12:17"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'control' !
continueProcess

	|topWindow|
	self process resume.
	self process: nil.		"Don't terminate process when window closes"
	"self requestCloseIfTopWindow."
	topWindow := self visual topWindow.
	topWindow isNil
		ifFalse: [topWindow requestClose]! !

"May 19, 2008 -> 18:12:49"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'control' !
continueProcess

	|topWindow|
	self process resume.
	self process: nil.		"Don't terminate process when window closes"
	topWindow := self visual topWindow.
	topWindow isNil
		ifFalse: [topWindow requestClose]! !

"May 19, 2008 -> 18:13:47"!

"System saved" !
"May 24, 2008 -> 9:11:48"!

! (Delta mirrorFor: #Behavior) methodsFor: 'Camp Smalltalk' !
allSelectors

	|selectors|
	selectors := Set withAll: self selectors.
	self superclassesDo: [:class| selectors addAll: class selectors].
	^selectors! !

"May 24, 2008 -> 9:12:3"!

"System saved" !
"May 24, 2008 -> 10:13:37"!

! (Delta mirrorFor: #Error) methodsFor: 'priv handling' !
defaultAction

	Processor stopWithError: (ProcessExplicitError new msg: messageText)! !

"May 24, 2008 -> 10:13:37"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
error: msg <Str> ^<BottomType>

	"Processor stopWithError: (ProcessExplicitError new msg: msg)"
	Error signal: msg! !

"May 24, 2008 -> 10:13:37"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Accessing' !
current

	^self currentDictionary
		at: self
		ifPresent: [:current| current]
		ifAbsentPut: [self new].

			! !

"May 24, 2008 -> 10:13:37"!

! (Delta mirrorFor: #SimpleTestResourceTestCase) classSide methodsFor: 'Not categorized' !
resources
	^Set new add: SimpleTestResource current; yourself
			! !

"May 24, 2008 -> 10:13:37"!

! (Delta mirrorFor: #ReadString) methodsFor: 'Camp Smalltalk' !
sunitAsSymbol
 
        ^self asSymbol! !

"May 24, 2008 -> 10:13:57"!

"System saved" !
"May 24, 2008 -> 10:20:55"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Init / Release' !
reset

	self class reset! !

"May 24, 2008 -> 10:24:14"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Creation' !
reset
	|current|
	current := self currentDictionary
		at: self
		ifAbsent: [^nil].
	current isNil
		ifFalse: [[current tearDown] ensure: [
					self current: nil]]
			! !

"May 24, 2008 -> 10:24:59"!

"System saved" !
"May 24, 2008 -> 10:48:18"!

! (Delta mirrorFor: #MessageNotUnderstood) methodsFor: 'priv handling' !
defaultAction

	Processor stopWithError: (ProcessDoesNotUnderstandError new message: messageText)! !

"May 24, 2008 -> 10:49:34"!

! (Delta mirrorFor: #MessageNotUnderstood) classSide methodsFor: 'instance creation' !
message: aMessage

	^self new message: aMessage; yourself! !

"May 24, 2008 -> 10:49:46"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"May 24, 2008 -> 10:50:12"!

! (Delta mirrorFor: #MessageNotUnderstood) methodsFor: 'private initialization' !
message: aMessage

	message := aMessage! !

"May 24, 2008 -> 10:50:19"!

! (Delta mirrorFor: #MessageNotUnderstood) methodsFor: 'priv handling' !
defaultAction

	Processor stopWithError: (ProcessDoesNotUnderstandError new message: message)! !

"May 24, 2008 -> 10:50:58"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
doesNotUnderstand: m <Message> ^<BottomType>

	"Processor stopWithError: (ProcessDoesNotUnderstandError new message: m)"
	(MessageNotUnderstood message: m) signal
! !

"May 24, 2008 -> 10:55:41"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Accessing' !
current

	^self currentDictionary
		at: self
		ifPresent: [:current| ^current]
		ifAbsentPut: [self new].

			! !

"May 24, 2008 -> 10:57:43"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Accessing' !
current

	^self currentDictionary
		at: self
		ifPresent: [:current| ^current halt]
		ifAbsentPut: [self new].

			! !

"May 24, 2008 -> 11:3:57"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Accessing' !
current: aTestResource

	aTestResource isNil
		ifTrue: [self currentDictionary removeKey: self]
		ifFalse: [self currentDictionary
							at: self
							put: aTestResource]			! !

"May 24, 2008 -> 11:4:40"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Accessing' !
current

	^self currentDictionary
		at: self
		ifPresent: [:current| ^current]
		ifAbsentPut: [self new].

			! !

"May 24, 2008 -> 11:5:21"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Accessing' !
current

	^self currentDictionary
		at: self
		ifPresent: [:current| ^current halt]
		ifAbsentPut: [self new].

			! !

"May 24, 2008 -> 11:5:38"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Accessing' !
current

	^self currentDictionary
		at: self
		ifPresent: [:current| ^current]
		ifAbsentPut: [self new].

			! !

"May 24, 2008 -> 11:8:57"!

"System saved" !
"May 24, 2008 -> 13:9:39"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Creation' !
reset
	|current|
	current := self currentDictionary
		at: self
		ifAbsent: [^nil].
	[current isNil
		ifFalse: [current tearDown]] ensure: [
					self current: nil]
			! !

"May 24, 2008 -> 13:9:39"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
doesNotUnderstand: m <Message> ^<BottomType>

	"Processor stopWithError: (ProcessDoesNotUnderstandError new message: m)"
	self halt.
	(MessageNotUnderstood message: m) signal! !

"May 24, 2008 -> 13:16:22"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
handles: anException
"should this really be here? - required for SUnit"
	^self class handles: anException! !

"May 24, 2008 -> 13:19:29"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
doesNotUnderstand: m <Message> ^<BottomType>
	"Processor stopWithError: (ProcessDoesNotUnderstandError new message: m)"
	(MessageNotUnderstood message: m) signal! !

"May 24, 2008 -> 13:55:35"!

! (Delta mirrorFor: #SUnitNameResolver) classSide methodsFor: 'Camp Smalltalk' !
notificationObject
	^Notification" new"! !

"May 24, 2008 -> 13:55:54"!

! (Delta mirrorFor: #SUnitNameResolver) classSide methodsFor: 'Camp Smalltalk' !
mnuExceptionObject
	^MessageNotUnderstood "new"! !

"May 24, 2008 -> 13:56:20"!

! (Delta mirrorFor: #SUnitNameResolver) classSide methodsFor: 'Camp Smalltalk' !
notificationObject
	^Notification! !

"May 24, 2008 -> 13:56:21"!

! (Delta mirrorFor: #SUnitNameResolver) classSide methodsFor: 'Camp Smalltalk' !
mnuExceptionObject
	^MessageNotUnderstood! !

"May 24, 2008 -> 13:58:2"!

(Delta mirrorFor: #Exception) removeMethod: #handles: ifAbsent: [] !


"May 24, 2008 -> 14:1:16"!

"System saved" !
"May 24, 2008 -> 14:1:53"!

Delta define: #BecomeTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"May 24, 2008 -> 14:4:25"!

! (Delta mirrorFor: #BecomeTest) methodsFor: 'testing' !
testBecome

	|first second source target|
	first := Array with: 1.
	second := Array with: 2.
	source := first copy.
	target := second copy.
	
	source become: target.
	self assert: (source = second).
	self assert: (target = first)! !

"May 24, 2008 -> 14:5:53"!

! (Delta mirrorFor: #Object) methodsFor: 'private-reflective' !
become: otherObject <BottomType>
	"Replace all references to the receiver anywhere in this image with references to otherObject, instead.

	This is a very dangerous message that should only be used if you really know what you are doing. Note that ALL
	references are changed, including 'self' in any currently active method contexts for the receiver,
	which means that instance variables could be accessed incorrectly, etc.  Note that this also means that the receiver
	becomes COMPLETELY inaccessible.
	 Also, this is not typesafe, and the type of the argument has been chosen to force typed code to insert an 
	 explicit guarantee, to avoid 'accidental' type-safety holes.  "

	"self unimplemented"
	{{ self primitiveBecome: otherObject ifFail: [:error| self error: error] }}! !

"May 24, 2008 -> 14:6:45"!

! (Delta mirrorFor: #BecomeTest) methodsFor: 'testing' !
testBecome

	|first second source target|
	first := Array with: 1.
	second := Array with: 2.
	source := first copy.
	target := second copy.
	
	self assert: (source = first).
	self assert: (target = second).
	source become: target.
	self assert: (source = second).
	self assert: (target = first)! !

"May 24, 2008 -> 14:7:44"!

! (Delta mirrorFor: #BecomeTest) methodsFor: 'testing' !
testBecomeShouldReportErrorWhenReceiverIsSmallInteger! !

"May 24, 2008 -> 14:8:34"!

! (Delta mirrorFor: #BecomeTest) methodsFor: 'initialize/release' !
setUp

	super setUp! !

"May 24, 2008 -> 14:10:49"!

(Delta mirrorFor: #BecomeTest) removeMethod: #setUp ifAbsent: [] !


"May 24, 2008 -> 14:14:6"!

! (Delta mirrorFor: #BecomeTest) methodsFor: 'testing' !
testBecomeShouldReportErrorWhenReceiverIsSmallInteger

	[1 become: ''.
	TestFailure signal]
		on: Error
		do: [:error| self assert: ('FirstArgumentHasWrongType' = error messageText)]
! !

"May 24, 2008 -> 14:22:54"!

"System saved" !
"May 29, 2008 -> 22:46:34"!

(Delta mirrorFor: #FileOutSet)
comment: 
'Simple tool to help organize file outs. Acts as a collection for classes
and method categories.

Add classes using addClass: and method categories using
addClass:category:. File out the results using fileOutOn:.

Files out definitions of all classes before any methods are filed out to
ensure that there are no undefined symbols, even if there are circular
references between classes.'!


"May 29, 2008 -> 22:46:34"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'adding' !
addClass: class

	classes add: class.
	classCategories
		removeKey: class
		ifAbsent: [].
	classCategories
		removeKey: class class
		ifAbsent: []! !

"May 29, 2008 -> 22:47:41"!

(Delta mirrorFor: #FileOutSet)
comment: 
'Simple tool to help organize file outs. Acts as a collection for classes
and method categories.

Add classes using addClass: and method categories using
addClass:category:. When adding method categories, you must add those
for class and instance side separately. When adding whole classes, just add
the instance side. File out the results using fileOutOn:.

Files out definitions of all classes before any methods are filed out to
ensure that there are no undefined symbols, even if there are circular
references between classes.'!


"May 29, 2008 -> 22:59:11"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private -  filing out' !
superclassesFor: aClass

	|superclasses|
	superclasses := Set new.
	aClass superclassesDo: [:class| superclasses add: class].
	^superclasses! !

"May 29, 2008 -> 23:24:57"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private -  filing out' !
classesForFileOut

	^classes asSortedCollection: [:class1 :class2|
			(self superclassesFor: class1) includes: class2]! !

"May 29, 2008 -> 23:25:22"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
fileOutClassHeadersOn: stream

	self classesForFileOut do: [:class|
		(self definitionWriterFor: class)
			fileOutHeaderOn: stream]! !

"May 29, 2008 -> 23:45:29"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private -  filing out' !
classesForFileOut

	^classes asSortedCollection: [:class1 :class2|
			(self superclassesFor: class2) includes: class1]! !

"May 29, 2008 -> 23:48:56"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private -  filing out' !
classesForFileOut

	^classes asSortedCollection: [:class1 :class2|
			((self superclassesFor: class1) includes: class2) not]! !

"May 29, 2008 -> 23:50:17"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
fileOutClassMethodsOn: stream

	self classesForFileOut do: [:class|
		(self definitionWriterFor: class)
			fileOutMethodsOn: stream]! !

"May 29, 2008 -> 23:58:30"!

Delta define: #BlockExceptionDesciptorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"May 29, 2008 -> 23:59:51"!

! (Delta mirrorFor: #BlockExceptionDesciptorTest) methodsFor: 'testing' !
testDefaultActionShouldInvokeDefaultActionBlock

	|exception wasInvoked|
	exception := BlockExceptionDescriptor new.
	wasInvoked := false.
	exception defaultActionBlock: [wasInvoked := true].
	exception defaultAction.
	self assert: wasInvoked! !

"May 30, 2008 -> 0:3:21"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"May 30, 2008 -> 0:3:42"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'testing' !
testDefaultActionShouldInvokeDefaultActionBlock

	|exception wasInvoked|
	exception := BlockExceptionDescriptor new.
	wasInvoked := false.
	exception defaultActionBlock: [wasInvoked := true].
	exception defaultAction.
	self assert: wasInvoked! !

"May 30, 2008 -> 0:5:41"!

(Delta mirrorFor: #BlockExceptionDesciptorTest) removeDefinitionIfFail: [] !


"May 30, 2008 -> 0:6:53"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'testing' !
testDefaultDefault

	|exception wasInvoked|
	exception := BlockExceptionDescriptor new.
	exception defaultAction! !

"May 30, 2008 -> 0:7:48"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'Running' !
setUp

	super setUp! !

"May 30, 2008 -> 0:8:5"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'exception')) !


"May 30, 2008 -> 0:8:14"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'testing' !
testDefaultDefault

	|wasInvoked|
	exception := BlockExceptionDescriptor new.
	exception defaultAction! !

"May 30, 2008 -> 0:8:25"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'testing' !
testDefaultActionShouldInvokeDefaultActionBlock

	|wasInvoked|
	exception := BlockExceptionDescriptor new.
	wasInvoked := false.
	exception defaultActionBlock: [wasInvoked := true].
	exception defaultAction.
	self assert: wasInvoked! !

"May 30, 2008 -> 0:8:52"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'Running' !
setUp

	super setUp.
	exception := BlockExceptionDescriptor new! !

"May 30, 2008 -> 0:9:0"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'testing' !
testDefaultDefault

	exception defaultAction! !

"May 30, 2008 -> 0:9:46"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'testing' !
testDefaultDefault

	self assert: exception defaultAction isNil! !

"May 30, 2008 -> 0:11:13"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'initialization' !
initialize

	defaultBlock := [nil].
	handlerBlock := [:ignore|]! !

"May 30, 2008 -> 0:11:34"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'exception descriptor' !
defaultAction

	^defaultBlock value! !

"May 30, 2008 -> 0:12:36"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'testing' !
testHandlerShouldDelegateToHandlerBlock

	|descriptor actualHandler|
	descriptor := BlockExceptionDescriptor new.
	descriptor handlerBlock: [:handler| actualHandler := handler].
	descriptor handler: #handler.
	[actualHandler == #handler] verify! !

"May 30, 2008 -> 0:14:3"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'testing' !
testHandlerShouldDelegateToHandlerBlock

	|actualHandler|
	exception handlerBlock: [:handler| actualHandler := handler].
	exception handler: #handler.
	self assert: (actualHandler == #handler)! !

"May 30, 2008 -> 0:14:56"!

(Delta mirrorFor: #BlockExceptionDescriptor) classSide removeMethod: #testHandlerShouldDelegateToHandlerBlock ifAbsent: [] !


"May 30, 2008 -> 0:14:58"!

(Delta mirrorFor: #BlockExceptionDescriptor) classSide removeMethod: #testDefaultDefault ifAbsent: [] !


"May 30, 2008 -> 0:14:59"!

(Delta mirrorFor: #BlockExceptionDescriptor) classSide removeMethod: #testDefaultActionShouldInvokeDefaultActionBlock ifAbsent: [] !


"May 30, 2008 -> 0:15:1"!

(Delta mirrorFor: #BlockExceptionDescriptor) classSide removeMethod: #test ifAbsent: [] !


"May 30, 2008 -> 0:17:9"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"May 30, 2008 -> 0:17:29"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testShouldInvokeHandlerBlockWithException

	|handled exception|
	handled := false.
	exception = Object new.
	(BlockExceptionHandler
		handleBlock: [:ex| [ex == exception] verify.
			handled := true])
		handle: exception.
	[handled] verify! !

"May 30, 2008 -> 0:18:57"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testShouldInvokeHandlerBlockWithException

	|handled exception|
	handled := false.
	exception = Object new.
	(BlockExceptionHandler
		handleBlock: [:ex| self assert: (ex == exception).
									handled := true])
		handle: exception.
	self assert: handled! !

"May 30, 2008 -> 0:22:9"!

(Delta mirrorFor: #BlockExceptionHandler) classSide removeMethod: #testShouldInvokeHandlerBlockWithException ifAbsent: [] !


"May 30, 2008 -> 0:22:11"!

(Delta mirrorFor: #BlockExceptionHandler) classSide removeMethod: #test ifAbsent: [] !


"May 30, 2008 -> 0:22:39"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"May 30, 2008 -> 0:23:8"!

! (Delta mirrorFor: #BlockExceptionSelectorTest) methodsFor: 'Testing' !
testShouldHandleWhenHandleBlockReturnsTrue

	|canHandle selector|
	selector := BlockExceptionSelector handlesBlock: [:ex| canHandle].
	canHandle := true.
	[selector handles: nil] verify.
	canHandle := false.
	[(selector handles: nil) not] verify! !

"May 30, 2008 -> 0:23:59"!

! (Delta mirrorFor: #BlockExceptionSelectorTest) methodsFor: 'Testing' !
testShouldHandleWhenHandleBlockReturnsTrue

	|canHandle selector|
	selector := BlockExceptionSelector handlesBlock: [:ex| canHandle].
	canHandle := true.
	self assert: (selector handles: nil).
	canHandle := false.
	self assert: (selector handles: nil) not! !

"May 30, 2008 -> 0:24:53"!

! (Delta mirrorFor: #BlockExceptionSelectorTest) methodsFor: 'Testing' !
testShouldHandleWhenHandleBlockReturnsTrue

	|canHandle selector|
	selector := BlockExceptionSelector handlesBlock: [:ex| canHandle].
	canHandle := true.
	self assert: (selector handles: nil).
	canHandle := false.
	self deny: (selector handles: nil)! !

"May 30, 2008 -> 0:25:36"!

! (Delta mirrorFor: #BlockExceptionSelectorTest) methodsFor: 'Testing' !
testShouldPassExceptionToHandlesBlock

	|exception selector|
	exception := Object new.
	selector := BlockExceptionSelector handlesBlock: [:ex| [ex == exception] verify].
	selector handles: exception! !

"May 30, 2008 -> 0:26:2"!

! (Delta mirrorFor: #BlockExceptionSelectorTest) methodsFor: 'Testing' !
testShouldPassExceptionToHandlesBlock

	|exception selector|
	exception := Object new.
	selector := BlockExceptionSelector handlesBlock: [:ex| self assert: (ex == exception)].
	selector handles: exception! !

"May 30, 2008 -> 0:26:11"!

! (Delta mirrorFor: #BlockExceptionSelectorTest) methodsFor: 'Testing' !
testShouldPassExceptionToHandlesBlock

	|exception selector|
	exception := Object new.
	selector := BlockExceptionSelector handlesBlock: [:ex| self assert: (ex == exception). true].
	selector handles: exception! !

"May 30, 2008 -> 0:26:25"!

! (Delta mirrorFor: #BlockExceptionSelectorTest) methodsFor: 'Testing' !
testShouldPassExceptionToHandlesBlock

	|exception selector|
	exception := Object new.
	selector := BlockExceptionSelector handlesBlock: [:ex| self assert: (ex == exception). true].
	self assert: (selector handles: exception)! !

"May 30, 2008 -> 0:27:3"!

(Delta mirrorFor: #BlockExceptionSelector) classSide removeMethod: #testShouldPassExceptionToHandlesBlock ifAbsent: [] !


"May 30, 2008 -> 0:27:6"!

(Delta mirrorFor: #BlockExceptionSelector) classSide removeMethod: #testShouldHandleWhenHandleBlockReturnsTrue ifAbsent: [] !


"May 30, 2008 -> 0:27:9"!

(Delta mirrorFor: #BlockExceptionSelector) classSide removeMethod: #test ifAbsent: [] !


"May 30, 2008 -> 0:28:57"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"May 30, 2008 -> 0:29:24"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testIsNestedShouldBeFalseWhenOuterHandlerDoesntHandle

	|result|
	[[Exception signal]
		on: Exception
		do: [:ex| result := ex isNested]]
		on: TestException
		do: [:ex|].
	[result not] verify! !

"May 30, 2008 -> 0:32:11"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testIsNestedShouldBeFalseWhenOuterHandlerDoesntHandle

	|wasHandled|
	[[Exception signal]
		on: Exception
		do: [:ex| self deny: ex isNested.
				wasHandled := true]]
		on: TestException
		do: [:ex|].
	self assert: wasHandled! !

"May 30, 2008 -> 0:32:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testIsNestedShouldBeFalseWhenOuterHandlerDoesntHandle

	|wasHandled|
	wasHandled := false.
	[[Exception signal]
		on: Exception
		do: [:ex| self deny: ex isNested.
				wasHandled := true]]
		on: TestException
		do: [:ex|].
	self assert: wasHandled! !

"May 30, 2008 -> 0:32:58"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testIsNestedShouldBeFalseWhenOuterHandlerDoesntHandle ifAbsent: [] !


"May 30, 2008 -> 0:33:16"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testIsNestedShouldBeFalseWithNoHandler

	|exception|
	exception := Exception new.
	[exception isNested not] verify! !

"May 30, 2008 -> 0:33:33"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testIsNestedShouldBeFalseWithNoHandler

	|exception|
	exception := Exception new.
	self deny: exception isNested! !

"May 30, 2008 -> 0:33:44"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testIsNestedShouldBeFalseWithNoHandler ifAbsent: [] !


"May 30, 2008 -> 0:35:16"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testIsNestedShouldBeTrueWhenOuterHandlerHandles

	|wasHandled|
	wasHandled := false.
	[[Exception signal]
		on: Exception
		do: [:ex| self assert: ex isNested.
				wasHandled:= true]]
		on: Exception
		do: [:ex| self shouldNotHappen].
	self assert: wasHandled! !

"May 30, 2008 -> 0:35:26"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testIsNestedShouldBeTrueWhenOuterHandlerHandles ifAbsent: [] !


"May 30, 2008 -> 0:36:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testIsNestedShouldBeTrueWhenOuterOuterHandlerHandles

	|wasHandled|
	wasHandled := false.
	[[[Exception signal]
		on: Exception
		do: [:ex| self assert: ex isNested.
				wasHandled := true]]
			on: TestException
			do: [:ex|]]
				on: Exception
				do: [:ex|].
	self assert: wasHandled! !

"May 30, 2008 -> 0:37:6"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testIsNestedShouldBeTrueWhenOuterOuterHandlerHandles ifAbsent: [] !


"May 30, 2008 -> 0:37:19"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable

	|outer result|
	[(TestException defaultActionBlock: [#result])
		resumable: true;
		signal]
		on: TestException
		do: [:ex| outer := ex outer.
			result := #returned].
	[result == #returned] verify.
	[outer == #result] verify.! !

"May 30, 2008 -> 0:41:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable

	|outer result|
	[(TestException defaultActionBlock: [#result])
		resumable: true;
		signal]
			on: TestException
			do: [:ex| self assert: ex outer == #result.
					result := #returned].
	self assert: result == #returned! !

"May 30, 2008 -> 0:41:58"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable

	|outer result|
	[(TestException defaultActionBlock: [#result])
		resumable: true;
		signal]
			on: TestException
			do: [:ex|
					self assert: ex outer == #result.
					result := #returned].
	self assert: result == #returned! !

"May 30, 2008 -> 0:42:28"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testOuterShouldInvokeAndReturnDefaultActionWhenResumable ifAbsent: [] !


"May 30, 2008 -> 0:42:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	[([|result|
	result := (TestException defaultActionBlock: [#result])
		signal.
	[result == #result] verify.
	result]
		on: TestException
		do: [:ex| ex outer.
			self shouldNotHappen]) == #result] verify! !

"May 30, 2008 -> 0:43:35"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	[([|result|
	result := (TestException defaultActionBlock: [#result])
		signal.
	[result == #result] verify.
	result]
		on: TestException
		do: [:ex| ex outer.
			self signalFailure: 'outer should not return']) == #result] verify! !

"May 30, 2008 -> 0:53:13"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [#defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 30, 2008 -> 1:13:13"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
handle: exception return: aReturnBlock

	^(exceptionSelector handles: exception)
		ifTrue: [	exception handler: self.
						aReturnBlock value: (handleBlock value: exception)]
		ifFalse: [nextHandler handle: exception return: aReturnBlock]! !

"May 30, 2008 -> 1:22:10"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
handle: exception return: aBlock

	aBlock value: (handleBlock value: exception)! !

"May 30, 2008 -> 1:38:49"!

Delta define: #FileOutSet as: (
(Class subclassOf: 'Object' instanceVariables: 'classes
classCategories
definitions')) !


"May 30, 2008 -> 1:39:10"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'adding' !
addDefinition: class

	definitions add: class! !

"May 30, 2008 -> 1:39:28"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private - initialization' !
initialize

	classes := Set new.
	classCategories := Dictionary new.
	definitions := Set new! !

"May 30, 2008 -> 1:39:55"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'adding' !
addDefinition: class

	(classes includes: class) ifTrue: [^self].
	definitions add: class! !

"May 30, 2008 -> 1:40:30"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'adding' !
addClass: class

	classes add: class.
	classCategories
		removeKey: class
		ifAbsent: [].
	classCategories
		removeKey: class class
		ifAbsent: [].
	definitions
		remove: class ifAbsent: []! !

"May 30, 2008 -> 1:41:33"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'adding' !
addClass: class

	classes add: class.
	classCategories
		removeKey: class
		ifAbsent: [].
	classCategories
		removeKey: class class
		ifAbsent: [].
	definitions
		remove: class
		ifAbsent: []! !

"May 30, 2008 -> 1:52:49"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private -  filing out' !
definitionsForFileOut

	|allDefinitions|
	(allDefinitions := Set new)
		addAll: classes;
		addAll: definitions.
	^allDefinitions asSortedCollection: [:class1 :class2|
			((self superclassesFor: class1) includes: class2) not]! !

"May 30, 2008 -> 1:53:21"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private -  filing out' !
definitionSortBlock

	^[:class1 :class2| ((self superclassesFor: class1) includes: class2) not]! !

"May 30, 2008 -> 1:53:45"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private -  filing out' !
definitionsForFileOut

	|allDefinitions|
	(allDefinitions := Set new)
		addAll: classes;
		addAll: definitions.
	^allDefinitions asSortedCollection: self definitionSortBlock! !

"May 30, 2008 -> 1:53:53"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private -  filing out' !
classesForFileOut

	^classes asSortedCollection: self definitionSortBlock! !

"May 30, 2008 -> 1:54:52"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private -  filing out' !
allDefinitions

	^Set new
		addAll: classes;
		addAll: definitions;
		yourself! !

"May 30, 2008 -> 1:55:18"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private -  filing out' !
definitionsForFileOut

	^self allDefinitions asSortedCollection: self definitionSortBlock! !

"May 30, 2008 -> 2:0:10"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
fileOutClassHeadersOn: stream

	self definitionsForFileOut do: [:class|
		(self definitionWriterFor: class)
			fileOutHeaderOn: stream]! !

"May 30, 2008 -> 2:11:26"!

"System saved" !
"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:40"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testPassShouldDeferToOuterHandler ifAbsent: [] !


"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:40"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testPassShouldNotReturn ifAbsent: [] !


"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:40"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:40"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:41"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:41"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:41"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:41"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:41"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:41"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:42"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:42"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:42"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:42"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:42"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:42"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:43"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:43"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
isLogging
	"By default, we're not logging failures. If you override this in 
	a subclass, make sure that you override #failureLog"
	^true
			! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable

	|outer result|
	[(TestException defaultActionBlock: [#result])
		resumable: true;
		signal]
			on: TestException
			do: [:ex|
					self assert: ex outer == #result.
					result := #returned].
	self assert: result == #returned description: 'outer did not return'! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable

	|outer result|
	[(TestException defaultActionBlock: [#result])
		resumable: true;
		signal]
			on: TestException
			do: [:ex|
					self assert: ex outer == #result description: 'outer returned wrong result'.
					result := #returned].
	self assert: result == #returned description: 'outer did not return'! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[
			[
				aTestCase runCase.
				true]
					sunitOn: self class failure
					do: [:signal |
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
								self logFailure: (signal printString).
								self errors add: aTestCase.
								signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:43"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:43"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:44"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:44"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:44"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:44"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:44"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:44"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:45"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:45"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:45"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:45"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:45"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:45"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:46"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:46"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
isLogging
	"By default, we're not logging failures. If you override this in 
	a subclass, make sure that you override #failureLog"
	^true
			! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable

	|outer result|
	[(TestException defaultActionBlock: [#result])
		resumable: true;
		signal]
			on: TestException
			do: [:ex|
					self assert: ex outer == #result.
					result := #returned].
	self assert: result == #returned description: 'outer did not return'! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable

	|outer result|
	[(TestException defaultActionBlock: [#result])
		resumable: true;
		signal]
			on: TestException
			do: [:ex|
					self assert: ex outer == #result description: 'outer returned wrong result'.
					result := #returned].
	self assert: result == #returned description: 'outer did not return'! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[
			[
				aTestCase runCase.
				true]
					sunitOn: self class failure
					do: [:signal |
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
								self logFailure: (signal printString).
								self errors add: aTestCase.
								signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:46"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:46"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:46"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:46"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:47"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:47"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:47"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:47"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:47"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:47"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:48"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:48"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:48"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:48"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:48"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:48"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
isLogging
	"By default, we're not logging failures. If you override this in 
	a subclass, make sure that you override #failureLog"
	^true
			! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable

	|outer result|
	[(TestException defaultActionBlock: [#result])
		resumable: true;
		signal]
			on: TestException
			do: [:ex|
					self assert: ex outer == #result.
					result := #returned].
	self assert: result == #returned description: 'outer did not return'! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable

	|outer result|
	[(TestException defaultActionBlock: [#result])
		resumable: true;
		signal]
			on: TestException
			do: [:ex|
					self assert: ex outer == #result description: 'outer returned wrong result'.
					result := #returned].
	self assert: result == #returned description: 'outer did not return'! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[
			[
				aTestCase runCase.
				true]
					sunitOn: self class failure
					do: [:signal |
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
								self logFailure: (signal printString).
								self errors add: aTestCase.
								signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:49"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:49"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:49"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:49"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:49"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:49"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:50"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:50"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:50"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:50"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:50"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:50"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:51"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:51"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:51"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:51"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
isLogging
	"By default, we're not logging failures. If you override this in 
	a subclass, make sure that you override #failureLog"
	^true
			! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable

	|outer result|
	[(TestException defaultActionBlock: [#result])
		resumable: true;
		signal]
			on: TestException
			do: [:ex|
					self assert: ex outer == #result.
					result := #returned].
	self assert: result == #returned description: 'outer did not return'! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable

	|outer result|
	[(TestException defaultActionBlock: [#result])
		resumable: true;
		signal]
			on: TestException
			do: [:ex|
					self assert: ex outer == #result description: 'outer returned wrong result'.
					result := #returned].
	self assert: result == #returned description: 'outer did not return'! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[
			[
				aTestCase runCase.
				true]
					sunitOn: self class failure
					do: [:signal |
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
								self logFailure: (signal printString).
								self errors add: aTestCase.
								signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[
			[
				aTestCase runCase.
				true]
					sunitOn: self class failure
					do: [:signal |
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
								[self logFailure: (signal printString)]
									suniton: Exception
									do: [].
								self errors add: aTestCase.
								signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"May 31, 2008 -> 12:22:26"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[
			[
				aTestCase runCase.
				true]
					sunitOn: self class failure
					do: [:signal |
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
								self errors add: aTestCase.
								signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"May 31, 2008 -> 12:43:54"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[
			[
				aTestCase runCase.
				true]
					sunitOn: self class failure
					do: [:signal |
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
								signal class printOn: Transcript.
								self errors add: aTestCase.
								signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"May 31, 2008 -> 12:51:15"!

"System saved" !
"June 1, 2008 -> 2:45:39"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"June 1, 2008 -> 2:45:39"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"June 1, 2008 -> 2:45:39"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"June 1, 2008 -> 2:45:39"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"June 1, 2008 -> 2:45:39"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"June 1, 2008 -> 2:45:39"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"June 1, 2008 -> 2:45:39"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"June 1, 2008 -> 2:45:39"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resumeBlock
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:40"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resumeBlock
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:40"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resumeBlock
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:40"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resumeBlock
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #Exception) methodsFor: 'private signal handling' !
installContextAndDo: aBlock
	"sets up a new context used as the target of a non-local return whenever an exception
	handling action needs to return to the signalling context. The context reference is cached
	in contextBlock. Whenever this block gets evaluated, its context will be consumed, so a
	new one needs to be set up. This is the purpose of the recursive call in the innermost block"
	|result|
	contextBlock := [:action| ^[self installContextAndDo: action]].
	result := aBlock value.
	^[result]! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeShouldReturnValueAsResultOfSignal

	[|result|
	result := TestException new
						resumable: true;
						signal.
	self assert: #resume == result]
		on: TestException
		do: [:ex| ex resume: #resume]! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
privateSignal

	resignalBlock := [:ex| ^[ex signal]].
	resumeBlock := [:result| ^[result]].
	passBlock := [^[handler pass: self]].
	^self installContextAndDo: [Processor activeProcess handle: self]! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resume: resumptionValue
"Return resumptionValue as the value of the signal message."
	contextBlock value: [resumptionValue]! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[
			[
				aTestCase runCase.
				true]
					sunitOn: self class failure
					do: [:signal |
						aTestCase printOn: Transcript.
						Transcript cr; tab; show: signal messageText.
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
								signal class printOn: Transcript.
								self errors add: aTestCase.
								signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[
			[
				aTestCase runCase.
				true]
					sunitOn: self class failure
					do: [:signal |
						aTestCase printOn: (Transcript cr; yourself).
						Transcript cr; tab; show: signal messageText.
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
								signal class printOn: Transcript.
								self errors add: aTestCase.
								signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeShouldReturnValueAsResultOfSignal

	[|result|
	result := TestException new
						resumable: true;
						signal.
	self assert: #resume == result description: result printString]
		on: TestException
		do: [:ex| ex resume: #resume]! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resume: resumptionValue
"Return resumptionValue as the value of the signal message."
	(contextBlock value: [resumptionValue]) value! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resume: resumptionValue
"Return resumptionValue as the value of the signal message."
	contextBlock value: [resumptionValue]! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #Exception) methodsFor: 'private signal handling' !
installContextAndDo: aBlock
	"sets up a new context used as the target of a non-local return whenever an exception
	handling action needs to return to the signalling context. The context reference is cached
	in contextBlock. Whenever this block gets evaluated, its context will be consumed, so a
	new one needs to be set up. This is the purpose of the recursive call in the innermost block"
	|result|
	contextBlock := [:action| ^[(self installContextAndDo: action) value]].
	result := aBlock value.
	^[result]! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldReturnResumptionValueWhenResumed

"	|wasResumed|
	wasResumed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| self assert: ex outer = 'result'.
				wasResumed := true]]
					on: TestException
					do: [:ex| ex resume: 'result'.
							self signalFailure: 'Resume should not return'].
	self assert: wasResumed"! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldReturnResumptionValueWhenResumed

	|wasResumed|
	wasResumed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| self assert: ex outer = 'result'.
				wasResumed := true]]
					on: TestException
					do: [:ex| ex resume: 'result'.
							self signalFailure: 'Resume should not return'].
	self assert: wasResumed! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldReturnResumptionValueWhenResumed

	|wasResumed|
	wasResumed := false.
	[[TestException new resumable: true; signal]
		on: TestException
		do: [:ex| self assert: ex outer = 'result'.
				wasResumed := true]]
					on: TestException
					do: [:ex| ex resume: 'result'.
							self signalFailure: 'Resume should not return'].
	self assert: wasResumed! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldReturnResumptionValueWhenResumed

	|wasResumed|
	wasResumed := false.
	[[TestException new resumable: true; signal]
		on: TestException
		do: [:ex| self assert: ex outer = 'result'.
				wasResumed := true]]
					on: TestException
					do: [:ex| ex resume: 'result'.
							self signalFailure: 'Resume should not return'].
	self assert: wasResumed description: 'not resumed'! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
outer
"Evaluate the enclosing exception action and return to here 
instead of signal if it resumes (see #resumeUnchecked:)."
	| oldHandler oldContext |
	self isResumable
		ifFalse: [self pass].
	[oldContext := contextBlock.
	self installContextAndDo: [	(oldHandler := handler)
															outer: self return: [:value| ^value]]]
		ensure: [handler := oldHandler.
						contextBlock := oldContext]! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
outer
"Evaluate the enclosing exception action and return to here 
instead of signal if it resumes (see #resumeUnchecked:)."
	| oldHandler oldContext |
	self isResumable
		ifFalse: [self pass].
	[oldContext := contextBlock.
	^self installContextAndDo: [	(oldHandler := handler)
															outer: self return: [:value| ^value]]]
		ensure: [handler := oldHandler.
						contextBlock := oldContext]! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
outer
"Evaluate the enclosing exception action and return to here 
instead of signal if it resumes (see #resumeUnchecked:)."
	| oldHandler oldContext |
	self isResumable
		ifFalse: [self pass].
	[oldContext := contextBlock.
	^self installContextAndDo: [(oldHandler := handler)
															outer: self return: [:value| ^value]]]
		ensure: [handler := oldHandler.
						contextBlock := oldContext]! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldReturnResumptionValueWhenResumed

	|wasResumed|
	wasResumed := false.
	[[TestException new resumable: true; signal]
		on: TestException
		do: [:ex| |result|
				result := ex outer.
				self assert: 'result' = result description: result printString.
				wasResumed := true]]
					on: TestException
					do: [:ex| ex resume: 'result'.
							self signalFailure: 'Resume should not return'].
	self assert: wasResumed description: 'not resumed'! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
outer
"Evaluate the enclosing exception action and return to here 
instead of signal if it resumes (see #resumeUnchecked:)."
	| oldHandler oldContext |
	self isResumable
		ifFalse: [self pass].
	[oldContext := contextBlock.
	^(self installContextAndDo: [(oldHandler := handler)
															outer: self return: [:value| ^value]]) value]
		ensure: [handler := oldHandler.
						contextBlock := oldContext]! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
privateSignal

	resignalBlock := [:ex| ^[ex signal]].
	passBlock := [^[handler pass: self]].
	^self installContextAndDo: [Processor activeProcess handle: self]! !

"June 1, 2008 -> 2:45:40"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resumeBlock
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:40"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resumeBlock
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:40"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resumeBlock
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:40"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resumeBlock
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:40"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resumeBlock
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:40"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resumeBlock
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:40"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resumeBlock
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:40"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:40"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:40"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:40"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldInvokeSurroundingHandler

	| wasPassed |
	wasPassed := false.
	[[TestException new
			signal]
		on: TestException
		do: [:ex| ex pass.
			self signalFailure: 'Pass should not return']]
				on: TestException
				do: [:ex| wasPassed := true].
	self assert: wasPassed description: 'Outer handler not invoked'! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldInvokeSurroundingHandler

	| wasPassed |
	wasPassed := false.
	[[TestException new signal]
		on: TestException
		do: [:ex| ex pass.
			self signalFailure: 'Pass should not return']]
				on: TestException
				do: [:ex| wasPassed := true].
	self assert: wasPassed description: 'Outer handler not invoked'! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldInvokeSurroundingHandler

	| wasPassed |
	wasPassed := false.
	[[TestException new signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'Pass should not return']]
				on: TestException
				do: [:ex| wasPassed := true].
	self assert: wasPassed description: 'Outer handler not invoked'! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
pass
"Yield control to the enclosing exception action for the receiver."
	contextBlock value: [handler pass: self]! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
privateSignal

	resignalBlock := [:ex| ^[ex signal]].
	^self installContextAndDo: [Processor activeProcess handle: self]! !

"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeAfterPassShouldReturnFromSignal

	| wasReturned |
	wasReturned := false.
	[[|result|
	result := TestException new resumable: true; signal.
	wasReturned := true]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'Pass should not return']]
				on: TestException
				do: [:ex| ex resume].
	self assert: wasReturned description: 'Resume did not return from signal'! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeAfterPassShouldReturnResultFromSignal

	| wasReturned |
	wasReturned := false.
	[[|result|
	result := TestException new resumable: true; signal.
	self assert: 'result' = result description: result printString.
	wasReturned := true]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'Pass should not return']]
				on: TestException
				do: [:ex| ex resume: 'result'].
	self assert: wasReturned description: 'Resume did not return from signal'! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldInvokeDefaultActionWithoutReturning

	[([|result|
	result := (TestException defaultActionBlock: [#result])
					resumable: true;
					signal.
	[result == #result] verify.
	result]
		on: TestException
		do: [:ex| ex pass.
			self shouldNotHappen]) == #result] verify! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldInvokeDefaultActionWithoutReturning

	| signalReturned |
	signalReturned := false.
	[|result|
	result := (TestException defaultActionBlock: [#result])
						resumable: true;
						signal.
	signalReturned := true]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'Pass should not return'].
	self assert: signalReturned description: 'Signal did not return'! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| |result|
										result :=  ex defaultAction.
										ex isResumable ifFalse: [self halt].
										ex resume: result]! !

"June 1, 2008 -> 2:45:41"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testPassShouldInvokeDefaultActionWithoutReturning ifAbsent: [] !


"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldInvokeDefaultActionWithoutReturning

	| signalReturned |
	signalReturned := false.
	[|result|
	result := (TestException defaultActionBlock: ['result'])
						resumable: true;
						signal.
	self assert: result = 'result' description: result printString.
	signalReturned := true]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'Pass should not return'].
	self assert: signalReturned description: 'Signal did not return'! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterTwiceShouldInvokeSurroundingHandlerTwice

	|count|	count := 0.
	[[(TestException defaultActionBlock: [-1])
		resumable: true;
		signal]
		on: TestException
		do: [:ex| ex outer.
			ex outer]]
		on: TestException
		do: [:ex| count := count + 1].
	[count == 2] verify! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterTwiceShouldInvokeSurroundingHandlerTwice

	|count|	count := 0.
	[[(TestException defaultActionBlock: [-1])
		resumable: true;
		signal]
		on: TestException
		do: [:ex| ex outer.
				ex outer]]
			on: TestException
			do: [:ex| count := count + 1].
	self assert: count == 2 description: 'Count was ', count printString! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterTwiceShouldInvokeSurroundingHandlerTwice

	|count|
	count := 0.
	[[(TestException defaultActionBlock: [-1])
		resumable: true;
		signal]
		on: TestException
		do: [:ex| ex outer.
				ex outer]]
			on: TestException
			do: [:ex| count := count + 1].
	self assert: count == 2 description: 'Count was ', count printString! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterTwiceShouldInvokeSurroundingHandlerTwice

	|count|
	count := 0.
	[[TestException new
		resumable: true;
		signal]
		on: TestException
		do: [:ex| ex outer.
				ex outer]]
			on: TestException
			do: [:ex| count := count + 1].
	self assert: count == 2 description: 'Count was ', count printString! !

"June 1, 2008 -> 2:45:41"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testOuterTwiceShouldInvokeSurroundingHandlerTwice ifAbsent: [] !


"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeShouldReturnAsValueOfOuter

	|result|
	[[Exception signal]
		on: Exception
		do: [:ex| result := ex outer]]
		on: Exception
		do: [:ex| ex resume: #result].
	[result == #result] verify! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeShouldReturnAsValueOfOuter

	|result|
	[[Exception signal]
		on: Exception
		do: [:ex| result := ex outer]]
			on: Exception
			do: [:ex| ex resume: #result].
	self assert: result == #result description: result printString! !

"June 1, 2008 -> 2:45:41"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testResumeShouldReturnAsValueOfOuter ifAbsent: [] !


"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeShouldReturnValueAsResultOfSignal

	|wasResumed|
	wasResumed := false.
	[|result|
	result := TestException new
						resumable: true;
						signal.
	self assert: #resume == result description: result printString.
	wasResumed := true]
		on: TestException
		do: [:ex| ex resume: #resume]
	self assert: wasResumed description: 'Should have resumed after signal'! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeShouldReturnValueAsResultOfSignal

	[|wasResumed|
	wasResumed := false.
	[|result|
	result := TestException new
						resumable: true;
						signal.
	self assert: #resume == result description: result printString.
	wasResumed := true]
		on: TestException
		do: [:ex| ex resume: #resume]
	self assert: wasResumed description: 'Should have resumed after signal']
		on: MessageNotUnderstood
		do: [:mnu|
				Transcript cr; show: mnu message printString.
				mnu pass]! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeShouldReturnValueAsResultOfSignal

	[|wasResumed|
	wasResumed := false.
	[|result|
	result := TestException new
						resumable: true;
						signal.
	self assert: #resume == result description: result printString.
	wasResumed := true]
		on: TestException
		do: [:ex| ex resume: #resume]
	self assert: wasResumed description: 'Should have resumed after signal']
		on: MessageNotUnderstood
		do: [:mnu| | message |
				message := mnu message.
				Transcript cr;
					show: (message receiver printString);
					cr; show: (message selector).
				mnu pass]! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeShouldReturnValueAsResultOfSignal

	[|wasResumed|
	wasResumed := false.
	[|result|
	result := TestException new
						resumable: true;
						signal.
	self assert: #resume == result description: result printString.
	wasResumed := true]
		on: TestException
		do: [:ex| ex resume: #resume].
	self assert: wasResumed description: 'Should have resumed after signal']
		on: MessageNotUnderstood
		do: [:mnu| | message |
				message := mnu message.
				Transcript cr;
					show: (message receiver printString);
					cr; show: (message selector).
				mnu pass]! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeShouldReturnValueAsResultOfSignal

	|wasResumed|
	wasResumed := false.
	[|result|
	result := TestException new
						resumable: true;
						signal.
	self assert: #resume == result description: result printString.
	wasResumed := true]
		on: TestException
		do: [:ex| ex resume: #resume].
	self assert: wasResumed description: 'Should have resumed after signal'! !

"June 1, 2008 -> 2:45:41"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testResumeShouldReturnFromSignal ifAbsent: [] !


"June 1, 2008 -> 2:45:41"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testResumeWithValueShouldReturnFromSignal ifAbsent: [] !


"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResignalAsShouldRestoreSignalEnvironment

	|log|
	log := String new writeStream.
	[[Exception signal]
		on: TestException
		do: [:ex| log nextPutAll: 'resignal']]
		on: Exception
		do: [:ex| [log nextPutAll: 'signal '.
			ex resignalAs: TestException new]
				ifCurtailed: [log nextPutAll: 'curtail ']].
	[log contents = 'signal curtail resignal'] verify! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResignalAsShouldRestoreSignalEnvironment

	|log|
	log := String new writeStream.
	[[Exception signal]
		on: TestException
		do: [:ex| log nextPutAll: 'resignal']]
			on: Exception
			do: [:ex| [log nextPutAll: 'signal '.
					ex resignalAs: TestException new]
						ifCurtailed: [log nextPutAll: 'curtail ']].
	self assert: log contents = 'signal curtail resignal' description: log contents! !

"June 1, 2008 -> 2:45:41"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testResignalAsShouldRestoreSignalEnvironment ifAbsent: [] !


"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resignalAs: replacementException
"Signal an alternative exception in place of the receiver."
	contextBlock value: [replacementException signal]! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
privateSignal

	^self installContextAndDo: [Processor activeProcess handle: self]! !

"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResignalAsShouldRestoreSignalEnvironment

	|log|
	log := String new writeStream.
	[[Exception signal]
		on: TestException
		do: [:ex| log nextPutAll: 'resignal']]
			on: Exception
			do: [:ex| [log nextPutAll: 'signal '.
							ex resignalAs: TestException new]
								ifCurtailed: [log nextPutAll: 'curtail ']].
	self assert: log contents = 'signal curtail resignal' description: log contents! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable
" This is nasty (in that it replaces the stopHandler temporarily). Not safe to do in a
  multi-processing environment!! If you can think of something better, please do!!"
	| error oldStopHandler completed |
	
	completed := Semaphore new.
	oldStopHandler := Processor stopHandler.
	[Processor stopHandler: [:process| error := process processError msg.
													completed signal].
	[[(TestException defaultActionBlock: [#defaultResult])  signal.
	self shouldNotHappen]
		on: TestException
		do: [:ex| ex outer.
				self shouldNotHappen].
	error := 'handler returned'.
	completed signal] fork,
	completed wait.
	self assert: 'Default action should not return' = error description: error printString]
		ensure: [Processor stopHandler: oldStopHandler]! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable
" This is nasty (in that it replaces the stopHandler temporarily). Not safe to do in a
  multi-processing environment!! If you can think of something better, please use it!!"
	| error oldStopHandler completed |
	
	completed := Semaphore new.
	oldStopHandler := Processor stopHandler.
	[Processor stopHandler: [:process| error := process processError msg.
													completed signal].
	[[(TestException defaultActionBlock: [#defaultResult])  signal.
	self shouldNotHappen]
		on: TestException
		do: [:ex| ex outer.
				self shouldNotHappen].
	error := 'handler returned'.
	completed signal] fork,
	completed wait.
	self assert: 'Default action should not return' = error description: error printString]
		ensure: [Processor stopHandler: oldStopHandler]! !

"June 1, 2008 -> 2:46:32"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable
" This is nasty (in that it replaces the stopHandler temporarily). Not safe to do in a
  multi-processing environment!! If you can think of something better, please use it!!"
"	| error oldStopHandler completed |
	
	completed := Semaphore new.
	oldStopHandler := Processor stopHandler.
	[Processor stopHandler: [:process| error := process processError msg.
													completed signal].
	[[(TestException defaultActionBlock: [#defaultResult])  signal.
	self shouldNotHappen]
		on: TestException
		do: [:ex| ex outer.
				self shouldNotHappen].
	error := 'handler returned'.
	completed signal] fork,
	completed wait.
	self assert: 'Default action should not return' = error description: error printString]
		ensure: [Processor stopHandler: oldStopHandler]"! !

"June 1, 2008 -> 3:2:37"!

"System saved" !
"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #MessageNotUnderstood) methodsFor: 'accessing' !
message

	^message! !

"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| |result|
										result :=  ex defaultAction.
										ex isResumable ifFalse: [self defaultActionReturnError].
										ex resume: result]! !

"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
defaultActionReturnError

	self error: 'Return from non-resumable default action is not supported'! !

"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReportErrorAfterReturnFromNonResumableDefaultAction

	| handler exception wasHandled |
	handler := BlockExceptionHandler default.
	exception := TestException defaultActionBlock: [].
	exception resumable: false.
	[handler handle: exception.
	self signalFailure: 'Handler should not return']
		on: Error
		do: [:error| self assert: 'Return from non-resumable default action is not supported' = error messageText
									description: error messageText.
				wasHandled := true].
	self assert: wasHandled description: 'Handler should report error'! !

"June 1, 2008 -> 18:29:2"!

(Delta mirrorFor: #ExceptionTest) removeMethod: #testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable ifAbsent: [] !


"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[[[aTestCase runCase.
			true]
				sunitOn: self class failure
				do: [:signal |
						aTestCase printOn: (Transcript cr; yourself).
						Transcript cr; tab; show: signal messageText.
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: MessageNotUnderstood
							do: [:signal | |message|
									message := signal message.
									message receiver printOn: (Transcript cr; yourself).
									Transcript space; show: message selector.
									signal pass]]
										sunitOn: self class error
										do: [:signal |
												signal class printOn: Transcript.
												self errors add: aTestCase.
												signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"June 1, 2008 -> 18:29:2"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable ifAbsent: [] !


"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testRetryShouldReevaluateProtectee

	|count|
	count := 0.
	[count := count + 1.
	count == 1 ifTrue:[Exception signal]]
		on: Exception
		do: [:ex| ex retry].
	self assert: count == 2 description: 'Count was ' , count printString! !

"June 1, 2008 -> 18:29:2"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testRetryShouldReevaluateProtectee ifAbsent: [] !


"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testRetryUsingShouldReplaceProtectee

	|log count|
	log := String new writeStream.
	count := 0.
	[[Exception signal]
		ensure: [log nextPutAll: 'unwind ']]
			on: Exception
			do: [:ex|
					log nextPutAll: 'handle '.
					count := count + 1.
					count = 1 ifTrue: [ex retryUsing: [log nextPutAll: 'using '.
													Exception signal]]].
	self assert: log contents = 'handle unwind using handle '
			description: log contents! !

"June 1, 2008 -> 18:29:2"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testRetryUsingShouldReplaceProtectee ifAbsent: [] !


"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testReturnShouldDelegateToHandler

	|exception handler result|
	exception := Exception new.
	handler := BlockExceptionHandler new.
	result := #invalid.
	handler returnBlock: [:value| result := value].
	exception handler: handler.
	exception return.
	self assert: result isNil description: 'Return should pass back nil'! !

"June 1, 2008 -> 18:29:2"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testReturnShouldDelegateToHandler ifAbsent: [] !


"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testSignalShouldInvokeProcessHandler

	|wasInvoked|
	wasInvoked := false.
	Processor activeProcess
		pushHandler: (LinkedExceptionHandler
										on: Exception
										do: [:ex| wasInvoked := true]).
	Exception signal.
	[self assert: wasInvoked description: 'Should invoke exception handler']
		ensure: [Processor activeProcess popHandler]! !

"June 1, 2008 -> 18:29:2"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testSignalShouldInvokeProcessHandler ifAbsent: [] !


"June 1, 2008 -> 18:29:2"!

(Delta mirrorFor: #Exception) classSide removeMethod: #test ifAbsent: [] !


"June 1, 2008 -> 18:29:2"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'instantiation' !
trueSelector

	^BlockExceptionSelector handlesBlock: [:ex| true]! !

"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'instantiation' !
falseSelector

	^BlockExceptionSelector handlesBlock: [:ex| false]! !

"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testHandlerShouldSetHandlerOnException

	|handler exception assignedHandler|
	exception := BlockExceptionDescriptor new.
	exception handlerBlock: [:handler| assignedHandler := handler].
	handler := LinkedExceptionHandler
							on: BlockExceptionSelector trueSelector
							do: [:ex| ].
	self assert: assignedHandler ~~ handler
			description: 'Handler should not have been assigned yet'.
	handler handle: exception.
	self assert: assignedHandler == handler
			description: 'Handler should have been assigned'! !

"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'instantiation' !
falseSelector

	^BlockExceptionSelector handlesBlock: [:ex| false]! !

"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'instantiation' !
trueSelector

	^BlockExceptionSelector handlesBlock: [:ex| true]! !

"June 1, 2008 -> 18:29:2"!

(Delta mirrorFor: #LinkedExceptionHandler) classSide removeMethod: #testHandlerShouldSetHandlerOnException ifAbsent: [] !


"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testPassShouldDeferToNextHandler

	|handler trueSelector exception wasPassed nextHandler|
	exception := BlockExceptionDescriptor new.
	handler := LinkedExceptionHandler
							on: BlockExceptionSelector trueSelector
							do: [:ex| ].
	nextHandler := BlockExceptionHandler handleBlock: [:ex| wasPassed := true].
	handler nextHandler: nextHandler.
	wasPassed := false.
	handler pass: exception.
	self assert: wasPassed
			description: 'Handler should defer pass to nextHandler'! !

"June 1, 2008 -> 18:29:2"!

(Delta mirrorFor: #LinkedExceptionHandler) classSide removeMethod: #testPassShouldDeferToNextHandler ifAbsent: [] !


"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testReturnShouldEvaluateReturnBlock

	|handler result |
	handler := LinkedExceptionHandler
			on: nil
			do: [:ex| ]
			return: [:returnValue| result := returnValue].
	handler return: #value.
	self assert: result == #value
			description: 'Should have invoked return'! !

"June 1, 2008 -> 18:29:2"!

(Delta mirrorFor: #LinkedExceptionHandler) classSide removeMethod: #testReturnShouldEvaluateReturnBlock ifAbsent: [] !


"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testShouldDelegateToNextHandlerWhenNoMatch

	|handled exception nextHandler|
	handled := false.
	exception := BlockExceptionDescriptor new.
	nextHandler := BlockExceptionHandler
										handleBlock: [:ex| self assert: ex == exception
																					description: 'Handler invoked with wrong exception'.
																	handled := true].
	(LinkedExceptionHandler
		on: BlockExceptionSelector falseSelector
		do: [:ex| self signalFailure: 'Should not invoke hander'])
			nextHandler: nextHandler;
			handle: exception.
	self assert: handled
			description: 'Next handler not invoked'! !

"June 1, 2008 -> 18:29:2"!

(Delta mirrorFor: #LinkedExceptionHandler) classSide removeMethod: #testShouldDelegateToNextHandlerWhenNoMatch ifAbsent: [] !


"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testShouldInvokeExceptionsDefaultActionWhenNoNextHandler

	|handled exception|
	handled := false.
	exception := BlockExceptionDescriptor new.
	exception defaultActionBlock: [handled := true].
	(LinkedExceptionHandler
		on: BlockExceptionSelector falseSelector
		do: [:ex| self shouldNotHappen])
			handle: exception.
	self assert: handled
			description: 'Default action not invoked'! !

"June 1, 2008 -> 18:29:2"!

(Delta mirrorFor: #LinkedExceptionHandler) classSide removeMethod: #testShouldInvokeExceptionsDefaultActionWhenNoNextHandler ifAbsent: [] !


"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'exception descriptor' !
isResumable

	^true! !

"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'exception descriptor' !
resume: aValue! !

"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testShouldInvokeHandleBlockWhenExceptionMatches

	|handled exception|
	handled := false.
	exception := BlockExceptionDescriptor new.
	(LinkedExceptionHandler
		on: BlockExceptionSelector trueSelector
		do: [:ex|
				self assert: ex == exception
						description: 'Handler invoked with wrong exception'.
				handled := true])
		handle: exception.
	self assert: handled
			description: 'Exception not handled by handler'! !

"June 1, 2008 -> 18:29:2"!

(Delta mirrorFor: #LinkedExceptionHandler) classSide removeMethod: #testShouldInvokeHandleBlockWhenExceptionMatches ifAbsent: [] !


"June 1, 2008 -> 18:29:2"!

(Delta mirrorFor: #LinkedExceptionHandler) classSide removeMethod: #test ifAbsent: [] !


"June 1, 2008 -> 18:29:2"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
resumeBlock: aBlock

	"resume"! !

"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
resumeBlock: aBlock

	resumeBlock := aBlock! !

"June 1, 2008 -> 18:29:3"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'exception descriptor' !
resume: aValue

	resumeBlock value: aValue! !

"June 1, 2008 -> 18:29:3"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'initialization' !
initialize

	defaultBlock := [nil].
	handlerBlock := [:ignore|].
	resumeBlock := [:ignore|]! !

"June 1, 2008 -> 18:29:3"!

(Delta mirrorFor: #Process) classSide removeMethod: #testHandleShouldInvokeDefaultAction ifAbsent: [] !


"June 1, 2008 -> 18:29:3"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testHandleShouldInvokeDefaultAction

	|exception wasInvoked|
	wasInvoked := false.
	exception := BlockExceptionDescriptor new.
	exception
		defaultActionBlock: [wasInvoked := true];
		resumeBlock: [:value|^self "force NLR to prevent problems with test infrastructure"].
	[Processor activeProcess handle: exception]
		ensure: [self assert: wasInvoked
								description: 'Default action not invoked']! !

"June 1, 2008 -> 18:29:3"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testPushedHandlerShouldDeferToDefaultHandlerWhenExceptionDoesntMatch

	|process wasInvoked exception|
	exception := BlockExceptionDescriptor new.
	exception defaultActionBlock: [wasInvoked := true].
	process := Processor activeProcess.
	process pushHandler: (LinkedExceptionHandler
														on: BlockExceptionSelector falseSelector
														do: [:ex| ]).
	wasInvoked := false.
	[[process handle: exception]
		ensure: [self assert: wasInvoked
								description: 'Default action not invoked']]
			ensure: [process popHandler]! !

"June 1, 2008 -> 18:29:3"!

(Delta mirrorFor: #Process) classSide removeMethod: #testPushHandlerShouldDeferToDefaultHandlerWhenExceptionDoesntMatch ifAbsent: [] !


"June 1, 2008 -> 18:29:3"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testPushedHandlerShouldDeferToOuterHandlerWhenExceptionDoesntMatch

	|process wasInvoked exception outerHandler|
	wasInvoked := false.
	exception := BlockExceptionDescriptor new.
	exception
		defaultActionBlock: [];
		resumeBlock: [:value|^self "force NLR to prevent problems with test infrastructure"].
	outerHandler := (LinkedExceptionHandler
										on: BlockExceptionSelector trueSelector
										do: [:ex| wasInvoked := true]).
	process := Processor activeProcess.
	process pushHandler: outerHandler.
	process pushHandler: (LinkedExceptionHandler
														on: BlockExceptionSelector falseSelector
														do: [:ex| ]).
	[[process handle: exception]
			ensure: [self assert: wasInvoked
									descriptor: 'Outer handler should have been invoked']]
				ensure: [process popHandler.
								process popHandler]
! !

"June 1, 2008 -> 18:29:49"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testPushedHandlerShouldDeferToOuterHandlerWhenExceptionDoesntMatch

	|process wasInvoked exception outerHandler|
	wasInvoked := false.
	exception := BlockExceptionDescriptor new.
	exception
		defaultActionBlock: [];
		resumeBlock: [:value|^self "force NLR to prevent problems with test infrastructure"].
	outerHandler := (LinkedExceptionHandler
										on: BlockExceptionSelector trueSelector
										do: [:ex| wasInvoked := true]).
	process := Processor activeProcess.
	process pushHandler: outerHandler.
	process pushHandler: (LinkedExceptionHandler
														on: BlockExceptionSelector falseSelector
														do: [:ex| ]).
	[[process handle: exception]
			ensure: [self assert: wasInvoked
									description: 'Outer handler should have been invoked']]
				ensure: [process popHandler.
								process popHandler]
! !

"June 1, 2008 -> 18:53:25"!

(Delta mirrorFor: #Process) classSide removeMethod: #testPushHandlerShouldDeferToOuterHandlerWhenExceptionDoesntMatch ifAbsent: [] !


"June 1, 2008 -> 18:53:46"!

"System saved" !
"June 1, 2008 -> 19:10:46"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testPushedHandlerShouldDeferToOuterHandlerWhenExceptionDoesntMatch

	|process wasInvoked exception outerHandler|
	wasInvoked := false.
	exception := BlockExceptionDescriptor new.
	exception
		defaultActionBlock: [];
		resumeBlock: [:value|^self "force NLR to prevent problems with test infrastructure"].
	outerHandler := (LinkedExceptionHandler
										on: BlockExceptionSelector trueSelector
										do: [:ex| wasInvoked := true]).
	process := Processor activeProcess.
	process pushHandler: outerHandler.
	process pushHandler: (LinkedExceptionHandler
														on: BlockExceptionSelector falseSelector
														do: [:ex| ]).
	[[process handle: exception]
			ensure: [self assert: wasInvoked
									description: 'Outer handler should have been invoked']]
				ensure: [process popHandler.
								process popHandler]! !

"June 1, 2008 -> 19:11:27"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testPushedHandlerShouldReplaceDefaultHandler

	|process exceptionSelector wasInvoked exception|
	process := Processor activeProcess.
	exception := BlockExceptionDescriptor new.
	wasInvoked := false.
	exceptionSelector := BlockExceptionSelector handlesBlock: [:ex| true].
	[process pushHandler: (LinkedExceptionHandler
							on: exceptionSelector
							do: [:ex| wasInvoked := true]).
	process handle: exception.
	[wasInvoked] verify]
		ensure: [process popHandler]! !

"June 1, 2008 -> 19:13:17"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testPushedHandlerShouldReplaceDefaultHandler

	|process wasInvoked exception|
	process := Processor activeProcess.
	exception := BlockExceptionDescriptor new.
	wasInvoked := false.
	process pushHandler: (LinkedExceptionHandler
													on: BlockExceptionSelector trueSelector
													do: [:ex| wasInvoked := true]).
	[wasInvoked := false.
	process handle: exception.
	self assert: wasInvoked description: 'Handler should be invoked']
		ensure: [process popHandler]! !

"June 1, 2008 -> 19:14:50"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testPushedHandlerShouldReplaceDefaultHandler

	|process wasInvoked exception|
	process := Processor activeProcess.
	exception := BlockExceptionDescriptor new.
	wasInvoked := false.
	process pushHandler: (LinkedExceptionHandler
													on: BlockExceptionSelector trueSelector
													do: [:ex| wasInvoked := true]).
	[wasInvoked := false.
	process handle: exception]
		ensure: [process popHandler].
	self assert: wasInvoked description: 'Handler should be invoked'! !

"June 1, 2008 -> 19:14:59"!

(Delta mirrorFor: #Process) classSide removeMethod: #testPushHandlerShouldReplaceDefaultHandler ifAbsent: [] !


"June 1, 2008 -> 19:15:1"!

(Delta mirrorFor: #Process) classSide removeMethod: #test ifAbsent: [] !


"June 1, 2008 -> 19:15:17"!

"System saved" !
"June 1, 2008 -> 20:0:30"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 1, 2008 -> 20:1:17"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testOnDoShouldInvokeDoWhenExceptionSignalled

	|wasHandled|
	wasHandled := false.
	[Exception signal]
		on: Exception
		do: [:ex| wasHandled := true].
	[wasHandled] verify
! !

"June 1, 2008 -> 20:1:53"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testOnDoShouldInvokeDoWhenExceptionSignalled

	|wasHandled|
	wasHandled := false.
	[Exception signal]
		on: Exception
		do: [:ex| wasHandled := true].
	self assert: wasHandled
			description: 'Signalled exception should be handled'
! !

"June 1, 2008 -> 20:5:40"!

(Delta mirrorFor: #BlockWithoutArguments) classSide removeMethod: #testOnDoShouldInvokeDoWhenExceptionSignalled ifAbsent: [] !


"June 1, 2008 -> 20:5:47"!

! (Delta mirrorFor: #BlockWithoutArguments) classSide methodsFor: 'testing' !
test

	| v <Boolean> |
	
	[ v := false ] ensure: [ v := true ].
	self assert: [ v ].

	[ v := false ] ifCurtailed: [ v := true ].
	self assert: [ v not ].

	self testForUnwind: [ v := false ] onUnwind: [ v := true ].
	self assert: [ v ].

	self testForEnsure: [ v := false ] onUnwind: [ v := true ].
	self assert: [ v ].
	self 
		testOnDoShouldPopHandler;
		testOnDoShouldInvokeNestedHandler! !

"June 1, 2008 -> 20:5:57"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testOnDoShouldInvokeDoWhenExceptionSignalled

	|wasHandled|
	wasHandled := false.
	[Exception signal]
		on: Exception
		do: [:ex| wasHandled := true].
	self assert: wasHandled
			description: 'Signalled exception should be handled'! !

"June 1, 2008 -> 20:6:3"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testOnDoShouldInvokeNestedHandler

	|innerInvoked falseSelector outerInvoked|
	falseSelector := BlockExceptionSelector handlesBlock: [:ex| false].
	innerInvoked := false.
	outerInvoked := false.
	[[[Exception signal]
		on: falseSelector
		do: [:ex| innerInvoked := true]]
			on: Exception
			do: [:ex| outerInvoked := true].
	[innerInvoked not] verify.
	[outerInvoked] verify]
		ensure: [Processor activeProcess resetHandlers]! !

"June 1, 2008 -> 20:8:12"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testOnDoShouldInvokeNestedHandler

	|innerInvoked outerInvoked|
	innerInvoked := false.
	outerInvoked := false.
	[[Exception signal]
		on: BlockExceptionSelector falseSelector
		do: [:ex| innerInvoked := true]]
			on: Exception
			do: [:ex| outerInvoked := true].
	self deny: innerInvoked
			description: 'Inner handler should not be invoked'.
	self assert: outerInvoked
			description: 'Outer handler should be invoked'! !

"June 1, 2008 -> 20:8:21"!

(Delta mirrorFor: #BlockWithoutArguments) classSide removeMethod: #testOnDoShouldInvokeNestedHandler ifAbsent: [] !


"June 1, 2008 -> 20:8:32"!

! (Delta mirrorFor: #BlockWithoutArguments) classSide methodsFor: 'testing' !
test

	| v <Boolean> |
	
	[ v := false ] ensure: [ v := true ].
	self assert: [ v ].

	[ v := false ] ifCurtailed: [ v := true ].
	self assert: [ v not ].

	self testForUnwind: [ v := false ] onUnwind: [ v := true ].
	self assert: [ v ].

	self testForEnsure: [ v := false ] onUnwind: [ v := true ].
	self assert: [ v ].
	self 
		testOnDoShouldPopHandler! !

"June 1, 2008 -> 20:8:46"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testOnDoShouldPopHandler

	|handlerInvoked descriptor selector defaultInvoked|
	Processor activeProcess resetHandlers.
	descriptor := BlockExceptionDescriptor new.
	descriptor defaultActionBlock: [defaultInvoked := true].
	selector := BlockExceptionSelector handlesBlock: [:ex| true].
	[Exception signal]
		on: selector
		do: [:ex| handlerInvoked := true].
	defaultInvoked := false.
	handlerInvoked := false.
	Processor activeProcess handle: descriptor.
	[handlerInvoked not] verify.
	[defaultInvoked] verify	! !

"June 1, 2008 -> 20:9:35"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testOnDoShouldPopHandler

	|handlerInvoked descriptor defaultInvoked|
	Processor activeProcess resetHandlers.
	descriptor := BlockExceptionDescriptor new.
	descriptor defaultActionBlock: [defaultInvoked := true].
	[Exception signal]
		on: BlockExceptionSelector trueSelector
		do: [:ex| handlerInvoked := true].
	defaultInvoked := false.
	handlerInvoked := false.
	Processor activeProcess handle: descriptor.
	[handlerInvoked not] verify.
	[defaultInvoked] verify	! !

"June 1, 2008 -> 20:12:59"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testOnDoShouldPopHandler

	|handlerInvoked descriptor defaultInvoked|
	descriptor := BlockExceptionDescriptor new.
	descriptor defaultActionBlock: [defaultInvoked := true].
	[Exception signal]
		on: BlockExceptionSelector trueSelector
		do: [:ex| handlerInvoked := true].
	defaultInvoked := false.
	handlerInvoked := false.
	Processor activeProcess handle: descriptor.
	self deny: handlerInvoked
			description: 'Handler should have been popped'.
	self assert: defaultInvoked
			description: 'Default action should have been invoked'! !

"June 1, 2008 -> 20:21:34"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testOnDoShouldPopHandler

	|handlerInvoked descriptor defaultInvoked|
	descriptor := BlockExceptionDescriptor new.
	descriptor
		defaultActionBlock: [defaultInvoked := true];
		resumeBlock: [:value| ^self " force NLR"].
	[Exception signal]
		on: BlockExceptionSelector trueSelector
		do: [:ex| handlerInvoked := true].
	defaultInvoked := false.
	handlerInvoked := false.
	[Processor activeProcess handle: descriptor]
		ensure: [self deny: handlerInvoked
								description: 'Handler should have been popped'.
						self assert: defaultInvoked
								description: 'Default action should have been invoked']! !

"June 1, 2008 -> 20:24:1"!

(Delta mirrorFor: #BlockWithoutArguments) classSide removeMethod: #testOnDoShouldPopHandler ifAbsent: [] !


"June 1, 2008 -> 20:24:10"!

! (Delta mirrorFor: #BlockWithoutArguments) classSide methodsFor: 'testing' !
test

	| v <Boolean> |
	
	[ v := false ] ensure: [ v := true ].
	self assert: [ v ].

	[ v := false ] ifCurtailed: [ v := true ].
	self assert: [ v not ].

	self testForUnwind: [ v := false ] onUnwind: [ v := true ].
	self assert: [ v ].

	self testForEnsure: [ v := false ] onUnwind: [ v := true ].
	self assert: [ v ]! !

"June 1, 2008 -> 20:24:41"!

"System saved" !
"June 1, 2008 -> 20:45:57"!

"System saved" !
"June 2, 2008 -> 3:49:54"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Instance Creation' !
runAll

	[self suite run printOn: (Transcript cr; yourself)] fork! !

"June 2, 2008 -> 3:50:54"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

(Delta mirrorFor: #ProcessExceptionHandlingTest)
comment: 
''!


"June 2, 2008 -> 3:50:54"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

(Delta mirrorFor: #LinkedExceptionHandlerTest)
comment: 
''!


"June 2, 2008 -> 3:50:54"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

(Delta mirrorFor: #ExceptionTest)
comment: 
''!


"June 2, 2008 -> 3:50:54"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

(Delta mirrorFor: #MessageNotUnderstoodTest)
comment: 
''!


"June 2, 2008 -> 3:50:54"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 2, 2008 -> 3:50:54"!

(Delta mirrorFor: #BlockExceptionSelector)
comment: 
'Determines whether an exception can be handled by evaluating the handlesBlock.'!


"June 2, 2008 -> 3:50:54"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

(Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest)
comment: 
''!


"June 2, 2008 -> 3:50:55"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

(Delta mirrorFor: #ErrorTest)
comment: 
''!


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 2, 2008 -> 3:50:55"!

(Delta mirrorFor: #BlockExceptionDescriptor)
comment: 
'Implements the <exceptionDescriptor> protocol from the ANSI standard using configurable actionsdefined as blocks. Intended to be used primarily as a testing aid.'!


"June 2, 2008 -> 3:50:55"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 2, 2008 -> 3:50:55"!

(Delta mirrorFor: #TestException)
comment: 
'Concrete exception class that can be used for testing'!


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

(Delta mirrorFor: #BlockExceptionSelectorTest)
comment: 
''!


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

(Delta mirrorFor: #BlockExceptionHandlerTest)
comment: 
''!


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'exception')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'exception')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'exception')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'exception')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'exception')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'exception')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'exception')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'exception')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'exception')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'exception')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'exception')) !


"June 2, 2008 -> 3:50:55"!

(Delta mirrorFor: #BlockExceptionDescriptorTest)
comment: 
''!


"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testHandleShouldInvokeDefaultAction

	|exception wasInvoked|
	wasInvoked := false.
	exception := BlockExceptionDescriptor new.
	exception
		defaultActionBlock: [wasInvoked := true];
		resumeBlock: [:value|^self "force NLR to prevent problems with test infrastructure"].
	[Processor activeProcess handle: exception]
		ensure: [self assert: wasInvoked
								description: 'Default action not invoked']! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testPushedHandlerShouldDeferToDefaultHandlerWhenExceptionDoesntMatch

	|process wasInvoked exception|
	exception := BlockExceptionDescriptor new.
	exception defaultActionBlock: [wasInvoked := true].
	process := Processor activeProcess.
	process pushHandler: (LinkedExceptionHandler
														on: BlockExceptionSelector falseSelector
														do: [:ex| ]).
	wasInvoked := false.
	[[process handle: exception]
		ensure: [self assert: wasInvoked
								description: 'Default action not invoked']]
			ensure: [process popHandler]! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testPushedHandlerShouldDeferToOuterHandlerWhenExceptionDoesntMatch

	|process wasInvoked exception outerHandler|
	wasInvoked := false.
	exception := BlockExceptionDescriptor new.
	exception
		defaultActionBlock: [];
		resumeBlock: [:value|^self "force NLR to prevent problems with test infrastructure"].
	outerHandler := (LinkedExceptionHandler
										on: BlockExceptionSelector trueSelector
										do: [:ex| wasInvoked := true]).
	process := Processor activeProcess.
	process pushHandler: outerHandler.
	process pushHandler: (LinkedExceptionHandler
														on: BlockExceptionSelector falseSelector
														do: [:ex| ]).
	[[process handle: exception]
			ensure: [self assert: wasInvoked
									description: 'Outer handler should have been invoked']]
				ensure: [process popHandler.
								process popHandler]! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testPushedHandlerShouldReplaceDefaultHandler

	|process wasInvoked exception|
	process := Processor activeProcess.
	exception := BlockExceptionDescriptor new.
	wasInvoked := false.
	process pushHandler: (LinkedExceptionHandler
													on: BlockExceptionSelector trueSelector
													do: [:ex| wasInvoked := true]).
	[wasInvoked := false.
	process handle: exception]
		ensure: [process popHandler].
	self assert: wasInvoked description: 'Handler should be invoked'! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testHandlerShouldSetHandlerOnException

	|handler exception assignedHandler|
	exception := BlockExceptionDescriptor new.
	exception handlerBlock: [:handler| assignedHandler := handler].
	handler := LinkedExceptionHandler
							on: BlockExceptionSelector trueSelector
							do: [:ex| ].
	self assert: assignedHandler ~~ handler
			description: 'Handler should not have been assigned yet'.
	handler handle: exception.
	self assert: assignedHandler == handler
			description: 'Handler should have been assigned'! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testPassShouldDeferToNextHandler

	|handler trueSelector exception wasPassed nextHandler|
	exception := BlockExceptionDescriptor new.
	handler := LinkedExceptionHandler
							on: BlockExceptionSelector trueSelector
							do: [:ex| ].
	nextHandler := BlockExceptionHandler handleBlock: [:ex| wasPassed := true].
	handler nextHandler: nextHandler.
	wasPassed := false.
	handler pass: exception.
	self assert: wasPassed
			description: 'Handler should defer pass to nextHandler'! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testReturnShouldEvaluateReturnBlock

	|handler result |
	handler := LinkedExceptionHandler
			on: nil
			do: [:ex| ]
			return: [:returnValue| result := returnValue].
	handler return: #value.
	self assert: result == #value
			description: 'Should have invoked return'! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testShouldDelegateToNextHandlerWhenNoMatch

	|handled exception nextHandler|
	handled := false.
	exception := BlockExceptionDescriptor new.
	nextHandler := BlockExceptionHandler
										handleBlock: [:ex| self assert: ex == exception
																					description: 'Handler invoked with wrong exception'.
																	handled := true].
	(LinkedExceptionHandler
		on: BlockExceptionSelector falseSelector
		do: [:ex| self signalFailure: 'Should not invoke hander'])
			nextHandler: nextHandler;
			handle: exception.
	self assert: handled
			description: 'Next handler not invoked'! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testShouldInvokeExceptionsDefaultActionWhenNoNextHandler

	|handled exception|
	handled := false.
	exception := BlockExceptionDescriptor new.
	exception defaultActionBlock: [handled := true].
	(LinkedExceptionHandler
		on: BlockExceptionSelector falseSelector
		do: [:ex| self shouldNotHappen])
			handle: exception.
	self assert: handled
			description: 'Default action not invoked'! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testShouldInvokeHandleBlockWhenExceptionMatches

	|handled exception|
	handled := false.
	exception := BlockExceptionDescriptor new.
	(LinkedExceptionHandler
		on: BlockExceptionSelector trueSelector
		do: [:ex|
				self assert: ex == exception
						description: 'Handler invoked with wrong exception'.
				handled := true])
		handle: exception.
	self assert: handled
			description: 'Exception not handled by handler'! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testDefaultActionShouldExecuteInSignallingEnvironment

	| original wasHandled |
	original := TestException defaultActionBlock: [self error: ''].
	original resumable: true.
	wasHandled := false.
	[original signal]
		on: Error
		do: [:ex| wasHandled := true].
	self assert: wasHandled! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testIsNestedShouldBeFalseWhenOuterHandlerDoesntHandle

	|wasHandled|
	wasHandled := false.
	[[Exception signal]
		on: Exception
		do: [:ex| self deny: ex isNested.
				wasHandled := true]]
		on: TestException
		do: [:ex|].
	self assert: wasHandled! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testIsNestedShouldBeFalseWithNoHandler

	|exception|
	exception := Exception new.
	self deny: exception isNested! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testIsNestedShouldBeTrueWhenOuterHandlerHandles

	|wasHandled|
	wasHandled := false.
	[[Exception signal]
		on: Exception
		do: [:ex| self assert: ex isNested.
				wasHandled:= true]]
		on: Exception
		do: [:ex| self shouldNotHappen].
	self assert: wasHandled! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testIsNestedShouldBeTrueWhenOuterOuterHandlerHandles

	|wasHandled|
	wasHandled := false.
	[[[Exception signal]
		on: Exception
		do: [:ex| self assert: ex isNested.
				wasHandled := true]]
			on: TestException
			do: [:ex|]]
				on: Exception
				do: [:ex|].
	self assert: wasHandled! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable

	|outer result|
	[(TestException defaultActionBlock: [#result])
		resumable: true;
		signal]
			on: TestException
			do: [:ex|
					self assert: ex outer == #result description: 'outer returned wrong result'.
					result := #returned].
	self assert: result == #returned description: 'outer did not return'! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldReturnResumptionValueWhenResumed

	|wasResumed|
	wasResumed := false.
	[[TestException new resumable: true; signal]
		on: TestException
		do: [:ex| |result|
				result := ex outer.
				self assert: 'result' = result description: result printString.
				wasResumed := true]]
					on: TestException
					do: [:ex| ex resume: 'result'.
							self signalFailure: 'Resume should not return'].
	self assert: wasResumed description: 'not resumed'! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterTwiceShouldInvokeSurroundingHandlerTwice

	|count|
	count := 0.
	[[TestException new
		resumable: true;
		signal]
		on: TestException
		do: [:ex| ex outer.
				ex outer]]
			on: TestException
			do: [:ex| count := count + 1].
	self assert: count == 2 description: 'Count was ', count printString! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldInvokeDefaultActionWithoutReturning

	| signalReturned |
	signalReturned := false.
	[|result|
	result := (TestException defaultActionBlock: ['result'])
						resumable: true;
						signal.
	self assert: result = 'result' description: result printString.
	signalReturned := true]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'Pass should not return'].
	self assert: signalReturned description: 'Signal did not return'! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldInvokeSurroundingHandler

	| wasPassed |
	wasPassed := false.
	[[TestException new signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'Pass should not return']]
				on: TestException
				do: [:ex| wasPassed := true].
	self assert: wasPassed description: 'Outer handler not invoked'! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResignalAsShouldRestoreSignalEnvironment

	|log|
	log := String new writeStream.
	[[Exception signal]
		on: TestException
		do: [:ex| log nextPutAll: 'resignal']]
			on: Exception
			do: [:ex| [log nextPutAll: 'signal '.
							ex resignalAs: TestException new]
								ifCurtailed: [log nextPutAll: 'curtail ']].
	self assert: log contents = 'signal curtail resignal' description: log contents! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeAfterPassShouldReturnFromSignal

	| wasReturned |
	wasReturned := false.
	[[|result|
	result := TestException new resumable: true; signal.
	wasReturned := true]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'Pass should not return']]
				on: TestException
				do: [:ex| ex resume].
	self assert: wasReturned description: 'Resume did not return from signal'! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeAfterPassShouldReturnResultFromSignal

	| wasReturned |
	wasReturned := false.
	[[|result|
	result := TestException new resumable: true; signal.
	self assert: 'result' = result description: result printString.
	wasReturned := true]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'Pass should not return']]
				on: TestException
				do: [:ex| ex resume: 'result'].
	self assert: wasReturned description: 'Resume did not return from signal'! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeShouldReturnAsValueOfOuter

	|result|
	[[Exception signal]
		on: Exception
		do: [:ex| result := ex outer]]
			on: Exception
			do: [:ex| ex resume: #result].
	self assert: result == #result description: result printString! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeShouldReturnValueAsResultOfSignal

	|wasResumed|
	wasResumed := false.
	[|result|
	result := TestException new
						resumable: true;
						signal.
	self assert: #resume == result description: result printString.
	wasResumed := true]
		on: TestException
		do: [:ex| ex resume: #resume].
	self assert: wasResumed description: 'Should have resumed after signal'! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testRetryShouldReevaluateProtectee

	|count|
	count := 0.
	[count := count + 1.
	count == 1 ifTrue:[Exception signal]]
		on: Exception
		do: [:ex| ex retry].
	self assert: count == 2 description: 'Count was ' , count printString! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testRetryUsingShouldReplaceProtectee

	|log count|
	log := String new writeStream.
	count := 0.
	[[Exception signal]
		ensure: [log nextPutAll: 'unwind ']]
			on: Exception
			do: [:ex|
					log nextPutAll: 'handle '.
					count := count + 1.
					count = 1 ifTrue: [ex retryUsing: [log nextPutAll: 'using '.
													Exception signal]]].
	self assert: log contents = 'handle unwind using handle '
			description: log contents! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testReturnShouldDelegateToHandler

	|exception handler result|
	exception := Exception new.
	handler := BlockExceptionHandler new.
	result := #invalid.
	handler returnBlock: [:value| result := value].
	exception handler: handler.
	exception return.
	self assert: result isNil description: 'Return should pass back nil'! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testSignalShouldInvokeProcessHandler

	|wasInvoked|
	wasInvoked := false.
	Processor activeProcess
		pushHandler: (LinkedExceptionHandler
										on: Exception
										do: [:ex| wasInvoked := true]).
	Exception signal.
	[self assert: wasInvoked description: 'Should invoke exception handler']
		ensure: [Processor activeProcess popHandler]! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'instantiation' !
falseSelector

	^BlockExceptionSelector handlesBlock: [:ex| false]! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'instantiation' !
new

	^super new
		initialize;
		yourself! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'instantiation' !
trueSelector

	^BlockExceptionSelector handlesBlock: [:ex| true]! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
defaultActionBlock: block

	defaultBlock := block! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
handler: handler

	handlerBlock value: handler ! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
handlerBlock: block

	handlerBlock := block ! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
resumeBlock: aBlock

	resumeBlock := aBlock! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'exception descriptor' !
defaultAction

	^defaultBlock value! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'exception descriptor' !
isResumable

	^true! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'exception descriptor' !
resume: aValue

	resumeBlock value: aValue! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'initialization' !
initialize

	defaultBlock := [nil].
	handlerBlock := [:ignore|].
	resumeBlock := [:ignore|]! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'restricted - exception handling' !
inContextDo: aBlock

	^aBlock value! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'instantiation' !
falseSelector

	^BlockExceptionSelector handlesBlock: [:ex| false]! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'instantiation' !
handlesBlock: block

	^self new
		handlesBlock: block;
		yourself! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'instantiation' !
trueSelector

	^BlockExceptionSelector handlesBlock: [:ex| true]! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionSelector) methodsFor: 'exception selector' !
handles: exceptionDescriptor

	^handlesBlock value: exceptionDescriptor! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionSelector) methodsFor: 'private - initialization' !
handlesBlock: block

	handlesBlock := block ! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testOnDoShouldInvokeDoWhenExceptionSignalled

	|wasHandled|
	wasHandled := false.
	[Exception signal]
		on: Exception
		do: [:ex| wasHandled := true].
	self assert: wasHandled
			description: 'Signalled exception should be handled'! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testOnDoShouldInvokeNestedHandler

	|innerInvoked outerInvoked|
	innerInvoked := false.
	outerInvoked := false.
	[[Exception signal]
		on: BlockExceptionSelector falseSelector
		do: [:ex| innerInvoked := true]]
			on: Exception
			do: [:ex| outerInvoked := true].
	self deny: innerInvoked
			description: 'Inner handler should not be invoked'.
	self assert: outerInvoked
			description: 'Outer handler should be invoked'! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testOnDoShouldPopHandler

	|handlerInvoked descriptor defaultInvoked|
	descriptor := BlockExceptionDescriptor new.
	descriptor
		defaultActionBlock: [defaultInvoked := true];
		resumeBlock: [:value| ^self " force NLR"].
	[Exception signal]
		on: BlockExceptionSelector trueSelector
		do: [:ex| handlerInvoked := true].
	defaultInvoked := false.
	handlerInvoked := false.
	[Processor activeProcess handle: descriptor]
		ensure: [self deny: handlerInvoked
								description: 'Handler should have been popped'.
						self assert: defaultInvoked
								description: 'Default action should have been invoked']! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testShouldUnwindExceptionHandlersWhenHandlingException

	| wasInvoked |
	wasInvoked := false.
	[[[Notification signal]
			on: Error
			do: [:ex| self signalFailure: 'Should be caught by outer handler']]
				on: Notification
				do: [:ex| self error: 'Provoke outer handler']]
					on: Error
					do: [:ex| wasInvoked:= true].
	self assert: wasInvoked description: 'Outer handler should be invoked'! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #ErrorTest) methodsFor: 'testing' !
testDefaultActionShouldPassToStopHandler

	"%todo - after signalling environment restoration test for exception"
	self halt.! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #ErrorTest) methodsFor: 'testing' !
testErrorShouldSignalError

	| wasSignalled |
	wasSignalled := true.
	[self error: 'error message'.
	self signalFailure: 'should not return']
		on: Error
		do: [:ex| wasSignalled := true.
				self assert: 'error message' = ex messageText
						description: ex messageText printString].
	self assert: wasSignalled
			description: 'Error should be signalled'! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #ErrorTest) methodsFor: 'testing' !
testShouldNotBeResumable

	self deny: Error new isResumable! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #MessageNotUnderstoodTest) methodsFor: 'testing' !
testShouldBeResumable

	self assert: MessageNotUnderstood new isResumable! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #TestException) classSide methodsFor: 'test support' !
defaultActionBlock: block

	^self new
			defaultActionBlock: block;
			yourself! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #TestException) methodsFor: 'test support' !
defaultAction	^defaultActionBlock value! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #TestException) methodsFor: 'test support' !
defaultActionBlock: block	defaultActionBlock := block! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #TestException) methodsFor: 'test support' !
isResumable	^resumable isNil		ifTrue: [false]		ifFalse: [resumable]! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #TestException) methodsFor: 'test support' !
resumable: boolean	^resumable := boolean! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionSelectorTest) methodsFor: 'Testing' !
testShouldHandleWhenHandleBlockReturnsTrue

	|canHandle selector|
	selector := BlockExceptionSelector handlesBlock: [:ex| canHandle].
	canHandle := true.
	self assert: (selector handles: nil).
	canHandle := false.
	self deny: (selector handles: nil)! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionSelectorTest) methodsFor: 'Testing' !
testShouldPassExceptionToHandlesBlock

	|exception selector|
	exception := Object new.
	selector := BlockExceptionSelector handlesBlock: [:ex| self assert: (ex == exception). true].
	self assert: (selector handles: exception)! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReportErrorAfterReturnFromNonResumableDefaultAction

	| handler exception wasHandled |
	handler := BlockExceptionHandler default.
	exception := TestException defaultActionBlock: [].
	exception resumable: false.
	[handler handle: exception.
	self signalFailure: 'Handler should not return']
		on: Error
		do: [:error| self assert: 'Return from non-resumable default action is not supported' = error messageText
									description: error messageText.
				wasHandled := true].
	self assert: wasHandled description: 'Handler should report error'! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testShouldInvokeHandlerBlockWithException

	|handled exception|
	handled := false.
	exception = Object new.
	(BlockExceptionHandler
		handleBlock: [:ex| self assert: (ex == exception).
									handled := true])
		handle: exception.
	self assert: handled! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'Running' !
setUp

	super setUp.
	exception := BlockExceptionDescriptor new! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'testing' !
testDefaultActionShouldInvokeDefaultActionBlock

	|wasInvoked|
	exception := BlockExceptionDescriptor new.
	wasInvoked := false.
	exception defaultActionBlock: [wasInvoked := true].
	exception defaultAction.
	self assert: wasInvoked! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'testing' !
testDefaultDefault

	self assert: exception defaultAction isNil! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'testing' !
testHandlerShouldDelegateToHandlerBlock

	|actualHandler|
	exception handlerBlock: [:handler| actualHandler := handler].
	exception handler: #handler.
	self assert: (actualHandler == #handler)! !

"June 2, 2008 -> 3:59:26"!

"System saved" !
"June 2, 2008 -> 22:17:16"!

Delta define: #DefinitionReader as: (
(Class subclassOf: 'DefinitionFiler' instanceVariables: 'category visibility ')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #DefinitionReader as: (
(Class subclassOf: 'DefinitionFiler' instanceVariables: 'category visibility ')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #DefinitionReader as: (
(Class subclassOf: 'DefinitionFiler' instanceVariables: 'category visibility ')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #DefinitionReader as: (
(Class subclassOf: 'DefinitionFiler' instanceVariables: 'category visibility ')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #DefinitionReader as: (
(Class subclassOf: 'DefinitionFiler' instanceVariables: 'category visibility ')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #DefinitionReader as: (
(Class subclassOf: 'DefinitionFiler' instanceVariables: 'category visibility ')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #DefinitionReader as: (
(Class subclassOf: 'DefinitionFiler' instanceVariables: 'category visibility ')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #DefinitionReader as: (
(Class subclassOf: 'DefinitionFiler' instanceVariables: 'category visibility ')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #DefinitionReader as: (
(Class subclassOf: 'DefinitionFiler' instanceVariables: 'category visibility ')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #DefinitionReader as: (
(Class subclassOf: 'DefinitionFiler' instanceVariables: 'category visibility ')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #DefinitionReader as: (
(Class subclassOf: 'DefinitionFiler' instanceVariables: 'category visibility ')) !


"June 2, 2008 -> 22:17:16"!

(Delta mirrorFor: #DefinitionReader)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"June 2, 2008 -> 22:17:16"!

Delta define: #CommentReader as: (
(Class subclassOf: 'DefinitionReader' instanceVariables: '')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #CommentReader as: (
(Class subclassOf: 'DefinitionReader' instanceVariables: '')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #CommentReader as: (
(Class subclassOf: 'DefinitionReader' instanceVariables: '')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #CommentReader as: (
(Class subclassOf: 'DefinitionReader' instanceVariables: '')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #CommentReader as: (
(Class subclassOf: 'DefinitionReader' instanceVariables: '')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #CommentReader as: (
(Class subclassOf: 'DefinitionReader' instanceVariables: '')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #CommentReader as: (
(Class subclassOf: 'DefinitionReader' instanceVariables: '')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #CommentReader as: (
(Class subclassOf: 'DefinitionReader' instanceVariables: '')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #CommentReader as: (
(Class subclassOf: 'DefinitionReader' instanceVariables: '')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #CommentReader as: (
(Class subclassOf: 'DefinitionReader' instanceVariables: '')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #CommentReader as: (
(Class subclassOf: 'DefinitionReader' instanceVariables: '')) !


"June 2, 2008 -> 22:17:16"!

(Delta mirrorFor: #CommentReader)
comment: 
''!


"June 2, 2008 -> 22:17:16"!

Delta define: #FileOutSet as: (
(Class subclassOf: 'Object' instanceVariables: 'classes
classCategories
definitions')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #FileOutSet as: (
(Class subclassOf: 'Object' instanceVariables: 'classes
classCategories
definitions')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #FileOutSet as: (
(Class subclassOf: 'Object' instanceVariables: 'classes
classCategories
definitions')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #FileOutSet as: (
(Class subclassOf: 'Object' instanceVariables: 'classes
classCategories
definitions')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #FileOutSet as: (
(Class subclassOf: 'Object' instanceVariables: 'classes
classCategories
definitions')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #FileOutSet as: (
(Class subclassOf: 'Object' instanceVariables: 'classes
classCategories
definitions')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #FileOutSet as: (
(Class subclassOf: 'Object' instanceVariables: 'classes
classCategories
definitions')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #FileOutSet as: (
(Class subclassOf: 'Object' instanceVariables: 'classes
classCategories
definitions')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #FileOutSet as: (
(Class subclassOf: 'Object' instanceVariables: 'classes
classCategories
definitions')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #FileOutSet as: (
(Class subclassOf: 'Object' instanceVariables: 'classes
classCategories
definitions')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #FileOutSet as: (
(Class subclassOf: 'Object' instanceVariables: 'classes
classCategories
definitions')) !


"June 2, 2008 -> 22:17:16"!

(Delta mirrorFor: #FileOutSet)
comment: 
'Simple tool to help organize file outs. Acts as a collection for classes
and method categories.

Add classes using addClass: and method categories using
addClass:category:. When adding method categories, you must add those
for class and instance side separately. When adding whole classes, just add
the instance side. File out the results using fileOutOn:.

Files out definitions of all classes before any methods are filed out to
ensure that there are no undefined symbols, even if there are circular
references between classes.'!


"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #DefinitionReader) classSide methodsFor: 'Unclassified' !
for: m <Mirror> category: c <Symbol>  ^ <Instance>
	^(self for: m) category: c
! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #DefinitionReader) methodsFor: 'Unclassified' !
category ^ <Str>
	^category isNil 
		ifTrue: ['Unclassified']
		ifFalse: [category]
! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #DefinitionReader) methodsFor: 'Unclassified' !
category: c <Str>
	category := c.
	('*private*' match: c)
		ifTrue: [ visibility := #private ]
		ifFalse: [ visibility := #public ]
! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #DefinitionReader) methodsFor: 'Unclassified' !
fileInFrom: stream <ReadStream>
	| source <String> |
	[(source := stream nextChunk) isEmpty]
		whileFalse: [self fileInMethod: source].
! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #DefinitionReader) methodsFor: 'Unclassified' !
fileInMethod: source <Str>
	| pt <ParseTree> ast <DeltaMethod> |
	pt := self mirror addMethod: source visibility: self visibility category: self category ifFail: [ :msg <String> :pos <Int> |
		^Transcript 
			nextPutAll: '"<< Method filein error in ';
			nextPutAll: self mirror name; 
			nextPutAll: ' category ';
			nextPutAll: self category; 
			nextPut: $"; cr;
			nextPutAll: (source copyFrom: 1 to: pos); cr;
			nextPutAll: '"<< ';
			nextPutAll: msg;
			nextPutAll: ' <<"'; cr;
			nextPutAll: (source copyFrom: pos + 1 to: source size); cr ].
	
	ast := pt body.
	ast clearBody. 			"Clear the body part of the ast. 
											This will go away once the type information no longer stores DeltaMethods."
! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #DefinitionReader) methodsFor: 'Unclassified' !
visibility ^ <Symbol>
	^visibility! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #CommentReader) methodsFor: 'Unclassified' !
fileInFrom: stream <ReadStream>

	self mirror comment: stream nextChunk! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #FileOutSet) classSide methodsFor: 'instance creation' !
new

	^(super new)
		initialize;
		yourself! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'adding' !
addClass: class

	classes add: class.
	classCategories
		removeKey: class
		ifAbsent: [].
	classCategories
		removeKey: class class
		ifAbsent: [].
	definitions
		remove: class
		ifAbsent: []! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'adding' !
addClass: class category: category

	(classes includes: class)
		ifTrue: [^self].
	classCategories
		at: class
		ifPresent: [:categories| categories add: category]
		ifAbsentPut: [Set with: category]! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'adding' !
addDefinition: class

	(classes includes: class) ifTrue: [^self].
	definitions add: class! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
definitionWriterFor: class

	^(DefinitionWriter for: (ClassMirror on: class))! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
fileOutCategoriesOn: stream

	classCategories keysAndValuesDo: [:class :categories|
		| definitionWriter |
		definitionWriter := self definitionWriterFor: class.
		categories do: [:category|
			definitionWriter fileOutCategory: category on: stream]]! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
fileOutClassHeadersOn: stream

	self definitionsForFileOut do: [:class|
		(self definitionWriterFor: class)
			fileOutHeaderOn: stream]! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
fileOutClassMethodsOn: stream

	self classesForFileOut do: [:class|
		(self definitionWriterFor: class)
			fileOutMethodsOn: stream]! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
fileOutOn: stream

	self fileOutClassHeadersOn: stream.
	self fileOutClassMethodsOn: stream.
	self fileOutCategoriesOn: stream! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private -  filing out' !
allDefinitions

	^Set new
		addAll: classes;
		addAll: definitions;
		yourself! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private -  filing out' !
classSortBlock

	^[:class1 :class2| ((self superclassesFor: class2) includes: class1)
											or: [class1 name <= class2 name
														and: [((self superclassesFor: class1) includes: class2) not]]]! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private -  filing out' !
classesForFileOut

	^classes asSortedCollection: self classSortBlock! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private -  filing out' !
definitionsForFileOut

	^self allDefinitions asSortedCollection: self classSortBlock! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private -  filing out' !
superclassesFor: aClass

	|superclasses|
	superclasses := Set new.
	aClass superclassesDo: [:class| superclasses add: class].
	^superclasses! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private - initialization' !
initialize

	classes := Set new.
	classCategories := Dictionary new.
	definitions := Set new! !

"June 2, 2008 -> 22:17:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 2, 2008 -> 22:17:22"!

(Delta mirrorFor: #BlockExceptionHandler)
comment: 
'Exception handler for an exception. Handles the exception by invoking its handleBlock.'!


"June 2, 2008 -> 22:17:22"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 2, 2008 -> 22:17:22"!

(Delta mirrorFor: #Exception)
comment: 
'Base class of the exception hierarchy. Implements the core of the ANSI exception handling protocols'!


"June 2, 2008 -> 22:17:22"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

(Delta mirrorFor: #Error)
comment: 
''!


"June 2, 2008 -> 22:17:22"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 2, 2008 -> 22:17:22"!

(Delta mirrorFor: #LinkedExceptionHandler)
comment: 
'Exception handler for an exception. Invokes its handleBlock when asked to handle an exceptionthat matches its exceptionSelector. If the exception does not match its exceptionSelector it passesthe exception on to the nextHandler. If the nextHandler is undefined signal an UnhandledExceptionError.This class is internal to the exception handling framework. There should be no need for code outside of thisframework to interact with instances of ExceptionHandler.'!


"June 2, 2008 -> 22:17:22"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 2, 2008 -> 22:17:22"!

(Delta mirrorFor: #MessageNotUnderstood)
comment: 
''!


"June 2, 2008 -> 22:17:22"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

(Delta mirrorFor: #Notification)
comment: 
''!


"June 2, 2008 -> 22:17:22"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 2, 2008 -> 22:17:22"!

(Delta mirrorFor: #Process)
comment: 
'Tags: %BlueBook %User

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license
'!


"June 2, 2008 -> 22:17:22"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| 
										ex inContextDo: [|result|
																		result :=  ex defaultAction.
																		ex isResumable ifFalse: [self defaultActionReturnError].
																		ex resume: result]]! !

"June 2, 2008 -> 22:17:22"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
defaultActionReturnError

	self error: 'Return from non-resumable default action is not supported'! !

"June 2, 2008 -> 22:17:22"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
handleBlock: block

	^self new
		handleBlock: block;
		yourself! !

"June 2, 2008 -> 22:17:22"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
new

	^super new initialize! !

"June 2, 2008 -> 22:17:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
canHandleSignal: exception

	^false! !

"June 2, 2008 -> 22:17:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
handle: exception

	^handleBlock value: exception! !

"June 2, 2008 -> 22:17:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
handle: exception return: aBlock

	aBlock value: (handleBlock value: exception)! !

"June 2, 2008 -> 22:17:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
nextHandler

	^nil! !

"June 2, 2008 -> 22:17:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
nextHandler: ignored! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
pass: exception

	passBlock value: exception! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
passBlock: block

	passBlock := block! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
return: value

	returnBlock value: value! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
returnBlock: block

	returnBlock := block! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'private initialization' !
handleBlock: block

	handleBlock := block! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'private initialization' !
initialize

	handleBlock := [:exception|].
	passBlock := [:exception|].! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'Camp Smalltalk' !
sunitSignalWith: aString
  
        ^self signal: aString! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionInstantiator' !
signal
"Signal the occurrence of an exceptional condition."
	^ self new signal! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionInstantiator' !
signal: signalerText
"Signal the occurrence of an exceptional condition with a specified textual description."
	^ self new signal: signalerText! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionSelector' !
, anotherException
"Create an exception set."
"
	^ExceptionSet new
		add: self;
		add: anotherException;
		yourself"! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionSelector' !
handles: exception
"Determine whether an exception handler will accept a signaled exception."
	^ exception isKindOf: self! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'Camp Smalltalk' !
sunitExitWith: aValue
 
        self return: aValue! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'exceptionBuilder' !
tag: t
"This message is not specified in the ANSI protocol,
but that looks like an oversight because #tag is specified,
and the spec states that the signaler may store the tag value."
	tag := t! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'exceptionDescription' !
tag
"Return an exception's tag value."
	^tag == nil
		ifTrue: [self messageText]
		ifFalse: [tag]! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
isNested
"Determine whether the current exception handler is within 
the scope of another handler for the same exception."
	^ handler notNil and: [handler nextHandler canHandleSignal: self]! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
outer
"Evaluate the enclosing exception action and return to here 
instead of signal if it resumes (see #resumeUnchecked:)."
	| oldHandler oldContext |
	self isResumable
		ifFalse: [self pass].
	[oldContext := contextBlock.
	^(self installContextAndDo: [(oldHandler := handler)
															outer: self return: [:value| ^value]]) value]
		ensure: [handler := oldHandler.
						contextBlock := oldContext]! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
pass
"Yield control to the enclosing exception action for the receiver."
	contextBlock value: [handler pass: self]! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resignalAs: replacementException
"Signal an alternative exception in place of the receiver."
	contextBlock value: [replacementException signal]! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resume
"Return from the message that signaled the receiver."
	self resume: nil! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resume: resumptionValue
"Return resumptionValue as the value of the signal message."
	contextBlock value: [resumptionValue]! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
retry
"Abort an exception handler and re-evaluate its protected block."
	handler retry! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
retryUsing: alternativeBlock
"Abort an exception handler and evaluate a new block 
in place of the handler's protected block."
	handler retryUsing: alternativeBlock! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
return
"Return nil as the value of the block protected 
by the active exception handler."
	self return: nil! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
return: returnValue
"Return the argument as the value of the block protected 
by the active exception handler."
	handler return: returnValue! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
description
"Return a textual description of the exception."
	| desc mt |
	desc := self class name asString.
	^(mt := self messageText) == nil
		ifTrue: [desc]
		ifFalse: [desc, ': ', mt]! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
messageText
"Return an exception's message text."
	^messageText! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
printOn: stream

	stream nextPutAll: self description! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
defaultAction
"The default action taken if the exception is signaled."
	self subclassResponsibility! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
handler: aHandler

	handler := aHandler! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
isResumable
"Determine whether an exception is resumable."
	^ true! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'private signal handling' !
installContextAndDo: aBlock
	"sets up a new context used as the target of a non-local return whenever an exception
	handling action needs to return to the signalling context. The context reference is cached
	in contextBlock. Whenever this block gets evaluated, its context will be consumed, so a
	new one needs to be set up. This is the purpose of the recursive call in the innermost block"
	|result|
	contextBlock := [:action| ^[(self installContextAndDo: action) value]].
	result := aBlock value.
	^[result]! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'restricted exception handling' !
inContextDo: aBlock

	contextBlock isNil
		ifTrue: [^aBlock value].
	contextBlock value: aBlock! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
messageText: signalerText
"Set an exception's message text."
	messageText := signalerText! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
privateSignal

	^self installContextAndDo: [Processor activeProcess handle: self]! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
signal

	^self privateSignal value! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
signal: signalerText
"Signal the occurrence of an exceptional condition with a 
specified textual description."
	self messageText: signalerText.
	^ self signal! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Error) methodsFor: 'exception descriptor' !
isResumable

	^false! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Error) methodsFor: 'priv handling' !
defaultAction

	Processor stopWithError: (ProcessExplicitError new msg: messageText)! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'exceptionBuilder' !
on: anExceptionSelector do: handleBlock

	^self new
		on: anExceptionSelector
		do: handleBlock
		return: [:value|]
		outer: nil;
		yourself! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'exceptionBuilder' !
on: anExceptionSelector do: handleBlock return: returnBlock

	^self new
		on: anExceptionSelector
		do: handleBlock
		return: returnBlock
		outer: nil;
		yourself! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'exceptionBuilder' !
on: anExceptionSelector do: handleBlock return: returnBlock outer: outerBlock

	^self new
		on: anExceptionSelector
		do: handleBlock
		return: returnBlock
		outer: outerBlock;
		yourself! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
canHandleSignal: exception

	^(exceptionSelector handles: exception)
		or: [nextHandler notNil
			and: [nextHandler canHandleSignal: exception]]! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
handle: exception

	self handle: exception
		return: returnBlock! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
handle: exception return: aReturnBlock

	Processor activeProcess popHandler.
	[^(exceptionSelector handles: exception)
		ifTrue: [	exception handler: self.
						aReturnBlock value: (handleBlock value: exception)]
		ifFalse: [nextHandler handle: exception return: aReturnBlock]]
			ensure: [Processor activeProcess pushHandler: self]! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
nextHandler

	^nextHandler! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
outer: exception return: aReturnBlock

	^nextHandler handle: exception return: aReturnBlock! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
pass: exception

	^nextHandler handle: exception! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
protect: aBlock

	Processor activeProcess pushHandler: self.
	^[(self evaluateProtectee: aBlock) value]
		ensure: [Processor activeProcess popHandler]! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
retry

	retryBlock value! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
retryUsing: aBlock

	protectee := aBlock.
	retryBlock value! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
return: aValue

	returnBlock value: aValue! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
nextHandler: exceptionHandler

	nextHandler := exceptionHandler ! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #MessageNotUnderstood) classSide methodsFor: 'instance creation' !
message: aMessage

	^self new message: aMessage; yourself! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #MessageNotUnderstood) methodsFor: 'accessing' !
message

	^message! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #MessageNotUnderstood) methodsFor: 'exception descriptor' !
isResumable

	^true! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #MessageNotUnderstood) methodsFor: 'priv handling' !
defaultAction

	Processor stopWithError: (ProcessDoesNotUnderstandError new message: message)! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #MessageNotUnderstood) methodsFor: 'private initialization' !
message: aMessage

	message := aMessage! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handle: exception

	^self handlerChain handle: exception! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
popHandler

	handlerChain := self handlerChain nextHandler ! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
pushHandler: handler

	handler nextHandler: self handlerChain.
	handlerChain := handler ! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
resetHandlers

	handlerChain := nil

! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
doesNotUnderstand: m <Message> ^<BottomType>
	"Processor stopWithError: (ProcessDoesNotUnderstandError new message: m)"
	(MessageNotUnderstood message: m) signal! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
error: msg <Str> ^<BottomType>

	"Processor stopWithError: (ProcessExplicitError new msg: msg)"
	Error signal: msg! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
shouldNotHappen ^<BottomType>

	self error: 'This shouldn''t happen'.! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
shouldNotImplement ^<BottomType>

	self error: 'A message that cannot be supported by this class has been sent to an instance'.! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
subclassResponsibility ^<BottomType>

	"Note: In the Strongtalk language, a method whose body consists of only 
	 'self subclassResponsibility' is considered a declaration, which subclasses
	  must implement for concrete subclasses"

	self error: 'A message that should be implemented but is not has been sent to this object'.! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
unimplemented ^<BottomType>

	self error: 'A hook for unimplemented code has been encountered'! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'exceptions' !
on: exception do: handlerBlock

	^(LinkedExceptionHandler
		on: exception
		do: handlerBlock
		return: [:value | ^ value]) protect: self
! !

"June 2, 2008 -> 22:23:31"!

Delta define: #AbstractExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 22:24:26"!

! (Delta mirrorFor: #AbstractExceptionHandlingTest) methodsFor: 'Running' !
tearDown

	Processor activeProcess resetHandlers! !

"June 2, 2008 -> 22:24:52"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'Running' !
tearDown

	Processor activeProcess resetHandlers! !

"June 2, 2008 -> 22:25:2"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
tearDown

	Processor activeProcess resetHandlers! !

"June 2, 2008 -> 22:25:12"!

! (Delta mirrorFor: #BlockExceptionSelectorTest) methodsFor: 'Testing' !
tearDown

	Processor activeProcess resetHandlers! !

"June 2, 2008 -> 22:25:24"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
tearDown

	Processor activeProcess resetHandlers! !

"June 2, 2008 -> 22:25:34"!

! (Delta mirrorFor: #ErrorTest) methodsFor: 'testing' !
tearDown

	Processor activeProcess resetHandlers! !

"June 2, 2008 -> 22:25:52"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
tearDown

	Processor activeProcess resetHandlers! !

"June 2, 2008 -> 22:25:59"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
tearDown

	Processor activeProcess resetHandlers! !

"June 2, 2008 -> 22:26:8"!

! (Delta mirrorFor: #MessageNotUnderstoodTest) methodsFor: 'testing' !
tearDown

	Processor activeProcess resetHandlers! !

"June 2, 2008 -> 22:26:18"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
tearDown

	Processor activeProcess resetHandlers! !

"June 2, 2008 -> 22:28:21"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:21"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:21"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:21"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:21"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:21"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:21"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:21"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:21"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:21"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:21"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:31"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:31"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:31"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:31"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:31"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:31"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:31"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:31"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:31"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:31"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:31"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:42"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:42"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:42"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:42"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:42"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:42"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:42"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:42"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:42"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:42"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:42"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:49"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:49"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:49"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:49"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:49"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:49"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:49"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:49"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:49"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:49"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:49"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:9"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:9"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:9"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:9"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:9"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:9"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:9"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:9"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:9"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:9"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:9"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:15"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:15"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:15"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:15"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:15"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:15"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:15"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:15"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:15"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:15"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:15"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:21"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:21"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:21"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:21"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:21"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:21"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:21"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:21"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:21"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:21"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:21"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:27"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:27"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:27"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:27"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:27"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:27"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:27"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:27"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:27"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:27"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:27"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:34"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 2, 2008 -> 22:29:34"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 2, 2008 -> 22:29:34"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 2, 2008 -> 22:29:34"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 2, 2008 -> 22:29:34"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 2, 2008 -> 22:29:34"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 2, 2008 -> 22:29:34"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 2, 2008 -> 22:29:34"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 2, 2008 -> 22:29:34"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 2, 2008 -> 22:29:34"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 2, 2008 -> 22:29:34"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 2, 2008 -> 22:30:18"!

(Delta mirrorFor: #BlockExceptionDescriptorTest) removeMethod: #tearDown ifAbsent: [] !


"June 2, 2008 -> 22:31:3"!

! (Delta mirrorFor: #AbstractExceptionHandlingTest) classSide methodsFor: 'Testing' !
isAbstract

	^true! !

"June 2, 2008 -> 22:31:17"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #tearDown ifAbsent: [] !


"June 2, 2008 -> 22:31:33"!

(Delta mirrorFor: #BlockExceptionSelectorTest) removeMethod: #tearDown ifAbsent: [] !


"June 2, 2008 -> 22:31:40"!

(Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) removeMethod: #tearDown ifAbsent: [] !


"June 2, 2008 -> 22:31:46"!

(Delta mirrorFor: #ErrorTest) removeMethod: #tearDown ifAbsent: [] !


"June 2, 2008 -> 22:31:53"!

(Delta mirrorFor: #ExceptionTest) removeMethod: #tearDown ifAbsent: [] !


"June 2, 2008 -> 22:31:59"!

(Delta mirrorFor: #LinkedExceptionHandlerTest) removeMethod: #tearDown ifAbsent: [] !


"June 2, 2008 -> 22:32:6"!

(Delta mirrorFor: #MessageNotUnderstoodTest) removeMethod: #tearDown ifAbsent: [] !


"June 2, 2008 -> 22:32:12"!

(Delta mirrorFor: #ProcessExceptionHandlingTest) removeMethod: #tearDown ifAbsent: [] !


"June 2, 2008 -> 22:33:32"!

"System saved" !
"June 3, 2008 -> 11:34:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 3, 2008 -> 11:34:13"!

(Delta mirrorFor: #BlockExceptionHandler)
comment: 
'Exception handler for an exception. Handles the exception by invoking its handleBlock.'!


"June 3, 2008 -> 11:34:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:34:13"!

(Delta mirrorFor: #Exception)
comment: 
'Base class of the exception hierarchy. Implements the core of the ANSI exception handling protocols'!


"June 3, 2008 -> 11:34:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:13"!

(Delta mirrorFor: #Error)
comment: 
''!


"June 3, 2008 -> 11:34:13"!

Delta define: #Halt as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"June 3, 2008 -> 11:34:13"!

(Delta mirrorFor: #Halt)
comment: 
''!


"June 3, 2008 -> 11:34:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 3, 2008 -> 11:34:13"!

(Delta mirrorFor: #LinkedExceptionHandler)
comment: 
'Exception handler for an exception. Invokes its handleBlock when asked to handle an exceptionthat matches its exceptionSelector. If the exception does not match its exceptionSelector it passesthe exception on to the nextHandler. If the nextHandler is undefined signal an UnhandledExceptionError.This class is internal to the exception handling framework. There should be no need for code outside of thisframework to interact with instances of ExceptionHandler.'!


"June 3, 2008 -> 11:34:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 3, 2008 -> 11:34:13"!

(Delta mirrorFor: #MessageNotUnderstood)
comment: 
''!


"June 3, 2008 -> 11:34:13"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:14"!

(Delta mirrorFor: #Notification)
comment: 
''!


"June 3, 2008 -> 11:34:14"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 3, 2008 -> 11:34:14"!

(Delta mirrorFor: #Process)
comment: 
'Tags: %BlueBook %User

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license
'!


"June 3, 2008 -> 11:34:14"!

Delta define: #ZeroDivide as: (
(Class subclassOf: 'Error' instanceVariables: 'dividend')) !


"June 3, 2008 -> 11:34:14"!

(Delta mirrorFor: #ZeroDivide)
comment: 
''!


"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| 
										ex inContextDo: [|result|
																		result :=  ex defaultAction.
																		ex isResumable ifFalse: [self defaultActionReturnError].
																		ex resume: result]]! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
defaultActionReturnError

	self error: 'Return from non-resumable default action is not supported'! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
handleBlock: block

	^self new
		handleBlock: block;
		yourself! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
new

	^super new initialize! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
canHandleSignal: exception

	^false! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
handle: exception

	^handleBlock value: exception! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
handle: exception return: aBlock

	aBlock value: (handleBlock value: exception)! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
nextHandler

	^nil! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
nextHandler: ignored! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
pass: exception

	passBlock value: exception! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
passBlock: block

	passBlock := block! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
return: value

	returnBlock value: value! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
returnBlock: block

	returnBlock := block! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'private initialization' !
handleBlock: block

	handleBlock := block! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'private initialization' !
initialize

	handleBlock := [:exception|].
	passBlock := [:exception|].! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'Camp Smalltalk' !
sunitSignalWith: aString
  
        ^self signal: aString! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionInstantiator' !
signal
"Signal the occurrence of an exceptional condition."
	^ self new signal! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionInstantiator' !
signal: signalerText
"Signal the occurrence of an exceptional condition with a specified textual description."
	^ self new signal: signalerText! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionSelector' !
, anotherException
"Create an exception set."
"
	^ExceptionSet new
		add: self;
		add: anotherException;
		yourself"! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionSelector' !
handles: exception
"Determine whether an exception handler will accept a signaled exception."
	^ exception isKindOf: self! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'Camp Smalltalk' !
sunitExitWith: aValue
 
        self return: aValue! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'exceptionBuilder' !
tag: t
"This message is not specified in the ANSI protocol,
but that looks like an oversight because #tag is specified,
and the spec states that the signaler may store the tag value."
	tag := t! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'exceptionDescription' !
tag
"Return an exception's tag value."
	^tag == nil
		ifTrue: [self messageText]
		ifFalse: [tag]! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
isNested
"Determine whether the current exception handler is within 
the scope of another handler for the same exception."
	^ handler notNil and: [handler nextHandler canHandleSignal: self]! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
outer
"Evaluate the enclosing exception action and return to here 
instead of signal if it resumes (see #resumeUnchecked:)."
	| oldHandler oldContext |
	self isResumable
		ifFalse: [self pass].
	[oldContext := contextBlock.
	^(self installContextAndDo: [(oldHandler := handler)
															outer: self return: [:value| ^value]]) value]
		ensure: [handler := oldHandler.
						contextBlock := oldContext]! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
pass
"Yield control to the enclosing exception action for the receiver."
	contextBlock value: [handler pass: self]! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resignalAs: replacementException
"Signal an alternative exception in place of the receiver."
	contextBlock value: [replacementException signal]! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resume
"Return from the message that signaled the receiver."
	self resume: nil! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resume: resumptionValue
"Return resumptionValue as the value of the signal message."
	contextBlock value: [resumptionValue]! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
retry
"Abort an exception handler and re-evaluate its protected block."
	handler retry! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
retryUsing: alternativeBlock
"Abort an exception handler and evaluate a new block 
in place of the handler's protected block."
	handler retryUsing: alternativeBlock! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
return
"Return nil as the value of the block protected 
by the active exception handler."
	self return: nil! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
return: returnValue
"Return the argument as the value of the block protected 
by the active exception handler."
	handler return: returnValue! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
description
"Return a textual description of the exception."
	| desc mt |
	desc := self class name asString.
	^(mt := self messageText) == nil
		ifTrue: [desc]
		ifFalse: [desc, ': ', mt]! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
messageText
"Return an exception's message text."
	^messageText! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
printOn: stream

	stream nextPutAll: self description! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
defaultAction
"The default action taken if the exception is signaled."
	self subclassResponsibility! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
handler: aHandler

	handler := aHandler! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
isResumable
"Determine whether an exception is resumable."
	^ true! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'private signal handling' !
installContextAndDo: aBlock
	"sets up a new context used as the target of a non-local return whenever an exception
	handling action needs to return to the signalling context. The context reference is cached
	in contextBlock. Whenever this block gets evaluated, its context will be consumed, so a
	new one needs to be set up. This is the purpose of the recursive call in the innermost block"
	|result|
	contextBlock := [:action| ^[(self installContextAndDo: action) value]].
	result := aBlock value.
	^[result]! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'restricted exception handling' !
inContextDo: aBlock

	contextBlock isNil
		ifTrue: [^aBlock value].
	contextBlock value: aBlock! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
messageText: signalerText
"Set an exception's message text."
	messageText := signalerText! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
privateSignal

	^self installContextAndDo: [Processor activeProcess handle: self]! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
signal

	^self privateSignal value! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
signal: signalerText
"Signal the occurrence of an exceptional condition with a 
specified textual description."
	self messageText: signalerText.
	^ self signal! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Error) methodsFor: 'exception descriptor' !
isResumable

	^false! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Error) methodsFor: 'priv handling' !
defaultAction

	Processor stopWithError: (ProcessExplicitError new msg: messageText)! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Halt) methodsFor: 'testing' !
defaultAction

		Processor stopWithError: ProcessHaltError new! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Halt) methodsFor: 'testing' !
isResumable

	^true! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'exceptionBuilder' !
on: anExceptionSelector do: handleBlock

	^self new
		on: anExceptionSelector
		do: handleBlock
		return: [:value|]
		outer: nil;
		yourself! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'exceptionBuilder' !
on: anExceptionSelector do: handleBlock return: returnBlock

	^self new
		on: anExceptionSelector
		do: handleBlock
		return: returnBlock
		outer: nil;
		yourself! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'exceptionBuilder' !
on: anExceptionSelector do: handleBlock return: returnBlock outer: outerBlock

	^self new
		on: anExceptionSelector
		do: handleBlock
		return: returnBlock
		outer: outerBlock;
		yourself! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
canHandleSignal: exception

	^(exceptionSelector handles: exception)
		or: [nextHandler notNil
			and: [nextHandler canHandleSignal: exception]]! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
handle: exception

	self handle: exception
		return: returnBlock! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
handle: exception return: aReturnBlock

	Processor activeProcess popHandler.
	[^(exceptionSelector handles: exception)
		ifTrue: [	exception handler: self.
						aReturnBlock value: (handleBlock value: exception)]
		ifFalse: [nextHandler handle: exception return: aReturnBlock]]
			ensure: [Processor activeProcess pushHandler: self]! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
nextHandler

	^nextHandler! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
outer: exception return: aReturnBlock

	^nextHandler handle: exception return: aReturnBlock! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
pass: exception

	^nextHandler handle: exception! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
protect: aBlock

	Processor activeProcess pushHandler: self.
	^[(self evaluateProtectee: aBlock) value]
		ensure: [Processor activeProcess popHandler]! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
retry

	retryBlock value! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
retryUsing: aBlock

	protectee := aBlock.
	retryBlock value! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
return: aValue

	returnBlock value: aValue! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
nextHandler: exceptionHandler

	nextHandler := exceptionHandler ! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #MessageNotUnderstood) classSide methodsFor: 'instance creation' !
message: aMessage

	^self new message: aMessage; yourself! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #MessageNotUnderstood) methodsFor: 'accessing' !
message

	^message! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #MessageNotUnderstood) methodsFor: 'accessing' !
receiver

	^message receiver! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #MessageNotUnderstood) methodsFor: 'exception descriptor' !
isResumable

	^true! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #MessageNotUnderstood) methodsFor: 'priv handling' !
defaultAction

	Processor stopWithError: (ProcessDoesNotUnderstandError new message: message)! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #MessageNotUnderstood) methodsFor: 'private initialization' !
message: aMessage

	message := aMessage! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Notification) methodsFor: 'exception description' !
defaultAction

	^nil! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #ZeroDivide) classSide methodsFor: 'Instance creation' !
dividend: dividend

	^self new
		dividend: dividend;
		yourself! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #ZeroDivide) methodsFor: 'accessing' !
dividend

	^dividend! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #ZeroDivide) methodsFor: 'private - initialization' !
dividend: aValue

	dividend := aValue.
	messageText := 'divide by zero'! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #ZeroDivide) methodsFor: 'testing' !
isResumable

	^true! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handle: exception

	^self handlerChain handle: exception! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
popHandler

	| poppedHandler |
	handlerChain := (poppedHandler := self handlerChain) nextHandler.
	^poppedHandler! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
pushHandler: handler

	handler nextHandler: self handlerChain.
	handlerChain := handler ! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
resetExceptionEnvironment

	handlerChain := nil

! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
resetHandlers

	handlerChain := nil

! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
doesNotUnderstand: m <Message> ^<BottomType>
	"Processor stopWithError: (ProcessDoesNotUnderstandError new message: m)"
	(MessageNotUnderstood message: m) signal! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
error: msg <Str> ^<BottomType>

	"Processor stopWithError: (ProcessExplicitError new msg: msg)"
	Error signal: msg! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
halt

	"Processor stopWithError: ProcessHaltError new."
	Halt signal
! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
shouldNotHappen ^<BottomType>

	self error: 'This shouldn''t happen'.! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
shouldNotImplement ^<BottomType>

	self error: 'A message that cannot be supported by this class has been sent to an instance'.! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
subclassResponsibility ^<BottomType>

	"Note: In the Strongtalk language, a method whose body consists of only 
	 'self subclassResponsibility' is considered a declaration, which subclasses
	  must implement for concrete subclasses"

	self error: 'A message that should be implemented but is not has been sent to this object'.! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
unimplemented ^<BottomType>

	self error: 'A hook for unimplemented code has been encountered'! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'exceptions' !
on: exception do: handlerBlock

	^(LinkedExceptionHandler
		on: exception
		do: handlerBlock
		return: [:value | ^ value]) protect: self
! !

"June 3, 2008 -> 11:34:22"!

Delta define: #AbstractExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #AbstractExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #AbstractExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #AbstractExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #AbstractExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #AbstractExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #AbstractExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #AbstractExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #AbstractExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #AbstractExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #AbstractExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

(Delta mirrorFor: #AbstractExceptionHandlingTest)
comment: 
''!


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 3, 2008 -> 11:34:22"!

(Delta mirrorFor: #BlockExceptionDescriptor)
comment: 
'Implements the <exceptionDescriptor> protocol from the ANSI standard using configurable actionsdefined as blocks. Intended to be used primarily as a testing aid.'!


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 3, 2008 -> 11:34:22"!

(Delta mirrorFor: #BlockExceptionDescriptorTest)
comment: 
''!


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

(Delta mirrorFor: #BlockExceptionHandlerTest)
comment: 
''!


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 3, 2008 -> 11:34:22"!

(Delta mirrorFor: #BlockExceptionSelector)
comment: 
'Determines whether an exception can be handled by evaluating the handlesBlock.'!


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

(Delta mirrorFor: #BlockExceptionSelectorTest)
comment: 
''!


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

(Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest)
comment: 
''!


"June 3, 2008 -> 11:34:22"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'handlers')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'handlers')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'handlers')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'handlers')) !


"June 3, 2008 -> 11:34:22"!

(Delta mirrorFor: #ErrorTest)
comment: 
''!


"June 3, 2008 -> 11:34:22"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

(Delta mirrorFor: #ExceptionTest)
comment: 
''!


"June 3, 2008 -> 11:34:22"!

Delta define: #HaltTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

(Delta mirrorFor: #HaltTest)
comment: 
''!


"June 3, 2008 -> 11:34:22"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

(Delta mirrorFor: #LinkedExceptionHandlerTest)
comment: 
''!


"June 3, 2008 -> 11:34:23"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

(Delta mirrorFor: #MessageNotUnderstoodTest)
comment: 
''!


"June 3, 2008 -> 11:34:23"!

Delta define: #NotificationTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

(Delta mirrorFor: #NotificationTest)
comment: 
''!


"June 3, 2008 -> 11:34:23"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

(Delta mirrorFor: #ProcessExceptionHandlingTest)
comment: 
''!


"June 3, 2008 -> 11:34:23"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 3, 2008 -> 11:34:23"!

(Delta mirrorFor: #TestException)
comment: 
'Concrete exception class that can be used for testing'!


"June 3, 2008 -> 11:34:23"!

Delta define: #WarningTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

(Delta mirrorFor: #WarningTest)
comment: 
''!


"June 3, 2008 -> 11:34:23"!

Delta define: #ZeroDivideTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

(Delta mirrorFor: #ZeroDivideTest)
comment: 
''!


"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #AbstractExceptionHandlingTest) classSide methodsFor: 'Testing' !
isAbstract

	^name = #AbstractExceptionHandlingTest! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #AbstractExceptionHandlingTest) methodsFor: 'Running' !
tearDown
"	some of these tests do nasty things to the exception
	environment so best clean up after them by resetting it"
	Processor activeProcess resetExceptionEnvironment! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #AbstractExceptionHandlingTest) methodsFor: 'test support' !
withStopHandler: stopHandler do: aBlock

	| oldHandler |
	oldHandler := Processor stopHandler.
	Processor stopHandler: stopHandler.
	aBlock
		ensure: [Processor stopHandler: oldHandler]! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'instantiation' !
falseSelector

	^BlockExceptionSelector handlesBlock: [:ex| false]! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'instantiation' !
new

	^super new
		initialize;
		yourself! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'instantiation' !
trueSelector

	^BlockExceptionSelector handlesBlock: [:ex| true]! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
defaultActionBlock: block

	defaultBlock := block! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
handler: handler

	handlerBlock value: handler ! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
handlerBlock: block

	handlerBlock := block ! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
resumeBlock: aBlock

	resumeBlock := aBlock! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'exception descriptor' !
defaultAction

	^defaultBlock value! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'exception descriptor' !
isResumable

	^true! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'exception descriptor' !
resume: aValue

	resumeBlock value: aValue! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'initialization' !
initialize

	defaultBlock := [nil].
	handlerBlock := [:ignore|].
	resumeBlock := [:ignore|]! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'restricted - exception handling' !
inContextDo: aBlock

	^aBlock value! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'Running' !
setUp

	super setUp.
	exception := BlockExceptionDescriptor new! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'testing' !
testDefaultActionShouldInvokeDefaultActionBlock

	|wasInvoked|
	exception := BlockExceptionDescriptor new.
	wasInvoked := false.
	exception defaultActionBlock: [wasInvoked := true].
	exception defaultAction.
	self assert: wasInvoked! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'testing' !
testDefaultDefault

	self assert: exception defaultAction isNil! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'testing' !
testHandlerShouldDelegateToHandlerBlock

	|actualHandler|
	exception handlerBlock: [:handler| actualHandler := handler].
	exception handler: #handler.
	self assert: (actualHandler == #handler)! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReportErrorAfterReturnFromNonResumableDefaultAction

	| handler exception wasHandled |
	handler := BlockExceptionHandler default.
	exception := TestException defaultActionBlock: [].
	exception resumable: false.
	[handler handle: exception.
	self signalFailure: 'Handler should not return']
		on: Error
		do: [:error| self assert: 'Return from non-resumable default action is not supported' = error messageText
									description: error messageText.
				wasHandled := true].
	self assert: wasHandled description: 'Handler should report error'! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testShouldInvokeHandlerBlockWithException

	|handled exception|
	handled := false.
	exception = Object new.
	(BlockExceptionHandler
		handleBlock: [:ex| self assert: (ex == exception).
									handled := true])
		handle: exception.
	self assert: handled! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'instantiation' !
falseSelector

	^BlockExceptionSelector handlesBlock: [:ex| false]! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'instantiation' !
handlesBlock: block

	^self new
		handlesBlock: block;
		yourself! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'instantiation' !
trueSelector

	^BlockExceptionSelector handlesBlock: [:ex| true]! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionSelector) methodsFor: 'exception selector' !
handles: exceptionDescriptor

	^handlesBlock value: exceptionDescriptor! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionSelector) methodsFor: 'private - initialization' !
handlesBlock: block

	handlesBlock := block ! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionSelectorTest) methodsFor: 'Testing' !
testShouldHandleWhenHandleBlockReturnsTrue

	|canHandle selector|
	selector := BlockExceptionSelector handlesBlock: [:ex| canHandle].
	canHandle := true.
	self assert: (selector handles: nil).
	canHandle := false.
	self deny: (selector handles: nil)! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionSelectorTest) methodsFor: 'Testing' !
testShouldPassExceptionToHandlesBlock

	|exception selector|
	exception := Object new.
	selector := BlockExceptionSelector handlesBlock: [:ex| self assert: (ex == exception). true].
	self assert: (selector handles: exception)! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testOnDoShouldInvokeDoWhenExceptionSignalled

	|wasHandled|
	wasHandled := false.
	[Exception signal]
		on: Exception
		do: [:ex| wasHandled := true].
	self assert: wasHandled
			description: 'Signalled exception should be handled'! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testOnDoShouldInvokeNestedHandler

	|innerInvoked outerInvoked|
	innerInvoked := false.
	outerInvoked := false.
	[[Exception signal]
		on: BlockExceptionSelector falseSelector
		do: [:ex| innerInvoked := true]]
			on: Exception
			do: [:ex| outerInvoked := true].
	self deny: innerInvoked
			description: 'Inner handler should not be invoked'.
	self assert: outerInvoked
			description: 'Outer handler should be invoked'! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testOnDoShouldPopHandler

	|handlerInvoked descriptor defaultInvoked|
	descriptor := BlockExceptionDescriptor new.
	descriptor
		defaultActionBlock: [defaultInvoked := true];
		resumeBlock: [:value| ^self " force NLR"].
	[Exception signal]
		on: BlockExceptionSelector trueSelector
		do: [:ex| handlerInvoked := true].
	defaultInvoked := false.
	handlerInvoked := false.
	[Processor activeProcess handle: descriptor]
		ensure: [self deny: handlerInvoked
								description: 'Handler should have been popped'.
						self assert: defaultInvoked
								description: 'Default action should have been invoked']! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testShouldUnwindExceptionHandlersWhenHandlingException

	| wasInvoked |
	wasInvoked := false.
	[[[Notification signal]
			on: Error
			do: [:ex| self signalFailure: 'Should be caught by outer handler']]
				on: Notification
				do: [:ex| self error: 'Provoke outer handler']]
					on: Error
					do: [:ex| wasInvoked:= true].
	self assert: wasInvoked description: 'Outer handler should be invoked'! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ErrorTest) methodsFor: 'testing' !
testDefaultActionShouldPassToStopHandler

	| wasHandled processError |
	wasHandled := false.
	self withStopHandler: [:p| wasHandled := true.
													processError := p processError]
			do: 	[[self error: 'this is an error'] fork.
					Processor yield].
	self assert: wasHandled
			description: 'defaultAction should invoke the stopHandler'.
	self assert: (processError isKindOf: ProcessExplicitError)
			description: 'Process stopped with wrong kind of error', processError printString.
	self assert: 'this is an error' = processError msg
			description: 'Process stopped with wrong message: ', processError msg! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ErrorTest) methodsFor: 'testing' !
testErrorShouldSignalError

	| wasSignalled |
	wasSignalled := true.
	[self error: 'error message'.
	self signalFailure: 'should not return']
		on: Error
		do: [:ex| wasSignalled := true.
				self assert: 'error message' = ex messageText
						description: ex messageText printString].
	self assert: wasSignalled
			description: 'Error should be signalled'! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ErrorTest) methodsFor: 'testing' !
testShouldNotBeResumable

	self deny: Error new isResumable! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testDefaultActionShouldExecuteInSignallingEnvironment

	| original wasHandled |
	original := TestException defaultActionBlock: [self error: ''].
	original resumable: true.
	wasHandled := false.
	[original signal]
		on: Error
		do: [:ex| wasHandled := true].
	self assert: wasHandled! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testDefaultActionShouldExecuteInSignallingEnvironmentAfterResumableOuter

	| original wasHandled |
	original := TestException defaultActionBlock: [self error: ''].
	original resumable: true.
	wasHandled := false.
	[[original signal]
		on: Error
		do: [:ex| wasHandled := true]]
			on: TestException
			do: [:ex| ex outer].
	self assert: wasHandled! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testIsNestedShouldBeFalseWhenOuterHandlerDoesntHandle

	|wasHandled|
	wasHandled := false.
	[[Exception signal]
		on: Exception
		do: [:ex| self deny: ex isNested.
				wasHandled := true]]
		on: TestException
		do: [:ex|].
	self assert: wasHandled! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testIsNestedShouldBeFalseWithNoHandler

	|exception|
	exception := Exception new.
	self deny: exception isNested! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testIsNestedShouldBeTrueWhenOuterHandlerHandles

	|wasHandled|
	wasHandled := false.
	[[Exception signal]
		on: Exception
		do: [:ex| self assert: ex isNested.
				wasHandled:= true]]
		on: Exception
		do: [:ex| self shouldNotHappen].
	self assert: wasHandled! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testIsNestedShouldBeTrueWhenOuterOuterHandlerHandles

	|wasHandled|
	wasHandled := false.
	[[[Exception signal]
		on: Exception
		do: [:ex| self assert: ex isNested.
				wasHandled := true]]
			on: TestException
			do: [:ex|]]
				on: Exception
				do: [:ex|].
	self assert: wasHandled! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable

	|outer result|
	[(TestException defaultActionBlock: [#result])
		resumable: true;
		signal]
			on: TestException
			do: [:ex|
					self assert: ex outer == #result description: 'outer returned wrong result'.
					result := #returned].
	self assert: result == #returned description: 'outer did not return'! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldReturnResumptionValueWhenResumed

	|wasResumed|
	wasResumed := false.
	[[TestException new resumable: true; signal]
		on: TestException
		do: [:ex| |result|
				result := ex outer.
				self assert: 'result' = result description: result printString.
				wasResumed := true]]
					on: TestException
					do: [:ex| ex resume: 'result'.
							self signalFailure: 'Resume should not return'].
	self assert: wasResumed description: 'not resumed'! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterTwiceShouldInvokeSurroundingHandlerTwice

	|count|
	count := 0.
	[[TestException new
		resumable: true;
		signal]
		on: TestException
		do: [:ex| ex outer.
				ex outer]]
			on: TestException
			do: [:ex| count := count + 1].
	self assert: count == 2 description: 'Count was ', count printString! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldInvokeDefaultActionWithoutReturning

	| signalReturned |
	signalReturned := false.
	[|result|
	result := (TestException defaultActionBlock: ['result'])
						resumable: true;
						signal.
	self assert: result = 'result' description: result printString.
	signalReturned := true]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'Pass should not return'].
	self assert: signalReturned description: 'Signal did not return'! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldInvokeSurroundingHandler

	| wasPassed |
	wasPassed := false.
	[[TestException new signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'Pass should not return']]
				on: TestException
				do: [:ex| wasPassed := true].
	self assert: wasPassed description: 'Outer handler not invoked'! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResignalAsShouldRestoreSignalEnvironment

	|log|
	log := String new writeStream.
	[[Exception signal]
		on: TestException
		do: [:ex| log nextPutAll: 'resignal']]
			on: Exception
			do: [:ex| [log nextPutAll: 'signal '.
							ex resignalAs: TestException new]
								ifCurtailed: [log nextPutAll: 'curtail ']].
	self assert: log contents = 'signal curtail resignal' description: log contents! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeAfterPassShouldReturnFromSignal

	| wasReturned |
	wasReturned := false.
	[[|result|
	result := TestException new resumable: true; signal.
	wasReturned := true]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'Pass should not return']]
				on: TestException
				do: [:ex| ex resume].
	self assert: wasReturned description: 'Resume did not return from signal'! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeAfterPassShouldReturnResultFromSignal

	| wasReturned |
	wasReturned := false.
	[[|result|
	result := TestException new resumable: true; signal.
	self assert: 'result' = result description: result printString.
	wasReturned := true]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'Pass should not return']]
				on: TestException
				do: [:ex| ex resume: 'result'].
	self assert: wasReturned description: 'Resume did not return from signal'! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeShouldReturnAsValueOfOuter

	|result|
	[[Exception signal]
		on: Exception
		do: [:ex| result := ex outer]]
			on: Exception
			do: [:ex| ex resume: #result].
	self assert: result == #result description: result printString! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeShouldReturnValueAsResultOfSignal

	|wasResumed|
	wasResumed := false.
	[|result|
	result := TestException new
						resumable: true;
						signal.
	self assert: #resume == result description: result printString.
	wasResumed := true]
		on: TestException
		do: [:ex| ex resume: #resume].
	self assert: wasResumed description: 'Should have resumed after signal'! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testRetryShouldReevaluateProtectee

	|count|
	count := 0.
	[count := count + 1.
	count == 1 ifTrue:[Exception signal]]
		on: Exception
		do: [:ex| ex retry].
	self assert: count == 2 description: 'Count was ' , count printString! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testRetryUsingShouldReplaceProtectee

	|log count|
	log := String new writeStream.
	count := 0.
	[[Exception signal]
		ensure: [log nextPutAll: 'unwind ']]
			on: Exception
			do: [:ex|
					log nextPutAll: 'handle '.
					count := count + 1.
					count = 1 ifTrue: [ex retryUsing: [log nextPutAll: 'using '.
													Exception signal]]].
	self assert: log contents = 'handle unwind using handle '
			description: log contents! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testReturnShouldDelegateToHandler

	|exception handler result|
	exception := Exception new.
	handler := BlockExceptionHandler new.
	result := #invalid.
	handler returnBlock: [:value| result := value].
	exception handler: handler.
	exception return.
	self assert: result isNil description: 'Return should pass back nil'! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testSignalShouldInvokeProcessHandler

	|wasInvoked|
	wasInvoked := false.
	Processor activeProcess
		pushHandler: (LinkedExceptionHandler
										on: Exception
										do: [:ex| wasInvoked := true]).
	Exception signal.
	[self assert: wasInvoked description: 'Should invoke exception handler']
		ensure: [Processor activeProcess popHandler]! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #HaltTest) methodsFor: 'Testing' !
testDefaultActionShouldStopWithProcessHaltError

	| wasHandled processError |
	wasHandled := false.
	self withStopHandler: [:p| wasHandled := true.
													processError := p processError]
			do: [[self halt] fork.
					Processor yield].
	self assert: wasHandled
			description: 'Halt should have been handled'.
	self assert: (processError isKindOf: ProcessHaltError)
			description: 'Wrong kind of error reported'! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #HaltTest) methodsFor: 'Testing' !
testHaltShouldSignalHalt

	| wasSignalled |
	wasSignalled := false.
	[self halt]
		on: Halt
		do: [:ex| wasSignalled := true].
	self assert: wasSignalled! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #HaltTest) methodsFor: 'Testing' !
testShouldBeResumable

	self assert: Halt new isResumable! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testHandlerShouldSetHandlerOnException

	|handler exception assignedHandler|
	exception := BlockExceptionDescriptor new.
	exception handlerBlock: [:handler| assignedHandler := handler].
	handler := LinkedExceptionHandler
							on: BlockExceptionSelector trueSelector
							do: [:ex| ].
	self assert: assignedHandler ~~ handler
			description: 'Handler should not have been assigned yet'.
	handler handle: exception.
	self assert: assignedHandler == handler
			description: 'Handler should have been assigned'! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testPassShouldDeferToNextHandler

	|handler trueSelector exception wasPassed nextHandler|
	exception := BlockExceptionDescriptor new.
	handler := LinkedExceptionHandler
							on: BlockExceptionSelector trueSelector
							do: [:ex| ].
	nextHandler := BlockExceptionHandler handleBlock: [:ex| wasPassed := true].
	handler nextHandler: nextHandler.
	wasPassed := false.
	handler pass: exception.
	self assert: wasPassed
			description: 'Handler should defer pass to nextHandler'! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testReturnShouldEvaluateReturnBlock

	|handler result |
	handler := LinkedExceptionHandler
			on: nil
			do: [:ex| ]
			return: [:returnValue| result := returnValue].
	handler return: #value.
	self assert: result == #value
			description: 'Should have invoked return'! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testShouldDelegateToNextHandlerWhenNoMatch

	|handled exception nextHandler|
	handled := false.
	exception := BlockExceptionDescriptor new.
	nextHandler := BlockExceptionHandler
										handleBlock: [:ex| self assert: ex == exception
																					description: 'Handler invoked with wrong exception'.
																	handled := true].
	(LinkedExceptionHandler
		on: BlockExceptionSelector falseSelector
		do: [:ex| self signalFailure: 'Should not invoke hander'])
			nextHandler: nextHandler;
			handle: exception.
	self assert: handled
			description: 'Next handler not invoked'! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testShouldInvokeExceptionsDefaultActionWhenNoNextHandler

	|handled exception|
	handled := false.
	exception := BlockExceptionDescriptor new.
	exception defaultActionBlock: [handled := true].
	(LinkedExceptionHandler
		on: BlockExceptionSelector falseSelector
		do: [:ex| self shouldNotHappen])
			handle: exception.
	self assert: handled
			description: 'Default action not invoked'! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testShouldInvokeHandleBlockWhenExceptionMatches

	|handled exception|
	handled := false.
	exception := BlockExceptionDescriptor new.
	(LinkedExceptionHandler
		on: BlockExceptionSelector trueSelector
		do: [:ex|
				self assert: ex == exception
						description: 'Handler invoked with wrong exception'.
				handled := true])
		handle: exception.
	self assert: handled
			description: 'Exception not handled by handler'! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #MessageNotUnderstoodTest) methodsFor: 'testing' !
testMessageShouldReturnMessageThatWasNotUnderstood

	| message |
	message := Message
								receiver: 1
								selector: #zork
								arguments: #().
	[(MessageNotUnderstood message: message)
			signal.]
		on: MessageNotUnderstood
		do: [:ex| self assert: message = ex message
								description: 'Wrong message']! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #MessageNotUnderstoodTest) methodsFor: 'testing' !
testReceiverShouldReturnReceiverOfMessage

	| message |
	message := Message
								receiver: 1
								selector: #zork
								arguments: #().
	[(MessageNotUnderstood message: message)
			signal.]
		on: MessageNotUnderstood
		do: [:ex| self assert: 1 = ex receiver
								description: 'Wrong receiver']! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #MessageNotUnderstoodTest) methodsFor: 'testing' !
testResumeShouldReturnResultFromSignal
"	note that until doesNotUnderstand: is fixed in the VM
	we cannot use the more obvious test of sending a
	message to an object that cannot understand it"
	|result|
	[result := (MessageNotUnderstood
							message: (Message
														receiver: 1
														selector: #zork
														arguments: #()))
							signal.]
		on: MessageNotUnderstood
		do: [:ex| ex resume: 5].
	self assert: result = 5
			description: 'Result not returned'! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #MessageNotUnderstoodTest) methodsFor: 'testing' !
testShouldBeResumable

	self assert: MessageNotUnderstood new isResumable! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #NotificationTest) methodsFor: 'Testing' !
testDefaultActionReturnsNil

	self assert: Notification signal isNil! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #NotificationTest) methodsFor: 'Testing' !
testIsResumable

	self assert: Notification new isResumable! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testHandleShouldInvokeDefaultAction

	|exception wasInvoked|
	wasInvoked := false.
	exception := BlockExceptionDescriptor new.
	exception
		defaultActionBlock: [wasInvoked := true];
		resumeBlock: [:value|^self "force NLR to prevent problems with test infrastructure"].
	[Processor activeProcess handle: exception]
		ensure: [self assert: wasInvoked
								description: 'Default action not invoked']! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testPushedHandlerShouldDeferToDefaultHandlerWhenExceptionDoesntMatch

	|process wasInvoked exception|
	exception := BlockExceptionDescriptor new.
	exception defaultActionBlock: [wasInvoked := true].
	process := Processor activeProcess.
	process pushHandler: (LinkedExceptionHandler
														on: BlockExceptionSelector falseSelector
														do: [:ex| ]).
	wasInvoked := false.
	[[process handle: exception]
		ensure: [self assert: wasInvoked
								description: 'Default action not invoked']]
			ensure: [process popHandler]! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testPushedHandlerShouldDeferToOuterHandlerWhenExceptionDoesntMatch

	|process wasInvoked exception outerHandler|
	wasInvoked := false.
	exception := BlockExceptionDescriptor new.
	exception
		defaultActionBlock: [];
		resumeBlock: [:value|^self "force NLR to prevent problems with test infrastructure"].
	outerHandler := (LinkedExceptionHandler
										on: BlockExceptionSelector trueSelector
										do: [:ex| wasInvoked := true]).
	process := Processor activeProcess.
	process pushHandler: outerHandler.
	process pushHandler: (LinkedExceptionHandler
														on: BlockExceptionSelector falseSelector
														do: [:ex| ]).
	[[process handle: exception]
			ensure: [self assert: wasInvoked
									description: 'Outer handler should have been invoked']]
				ensure: [process popHandler.
								process popHandler]! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testPushedHandlerShouldReplaceDefaultHandler

	|process wasInvoked exception|
	process := Processor activeProcess.
	exception := BlockExceptionDescriptor new.
	wasInvoked := false.
	process pushHandler: (LinkedExceptionHandler
													on: BlockExceptionSelector trueSelector
													do: [:ex| wasInvoked := true]).
	[wasInvoked := false.
	process handle: exception]
		ensure: [process popHandler].
	self assert: wasInvoked description: 'Handler should be invoked'! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #TestException) classSide methodsFor: 'test support' !
defaultActionBlock: block

	^self new
			defaultActionBlock: block;
			yourself! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #TestException) methodsFor: 'test support' !
defaultAction	^defaultActionBlock value! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #TestException) methodsFor: 'test support' !
defaultActionBlock: block	defaultActionBlock := block! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #TestException) methodsFor: 'test support' !
isResumable	^resumable isNil		ifTrue: [false]		ifFalse: [resumable]! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #TestException) methodsFor: 'test support' !
resumable: boolean	^resumable := boolean! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #WarningTest) methodsFor: 'Testing' !
testDefaultActionShouldProvokeHalt

	| wasHalted wasSignalled |
	wasHalted := wasSignalled := false.
	[[Warning signal]
		on: Halt
		do: [wasHalted := true]]
				on: Warning
				do: [:ex| wasSignalled := true.
								ex outer].
	self assert: wasSignalled
			description: 'Should have signalled Warning'.	
	self assert: wasHalted
			description: 'Default action should have halted'! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #WarningTest) methodsFor: 'Testing' !
testShouldBeResumable

	self assert: Warning new isResumable! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #ZeroDivideTest) methodsFor: 'Testing' !
testDivideByZeroShouldSignalZeroDivide

	| wasSignalled |
	wasSignalled := false.
	[1/0]
		on: ZeroDivide
		do: [:ex| wasSignalled := true.
						self assert: 1 = ex dividend
								description: 'Wrong dividend:', ex dividend printString.
						self assert: 'divide by zero' = ex messageText
								description: 'Wrong message: ', ex messageText printString].
	self assert: wasSignalled
			description: 'Should have signalled'! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #ZeroDivideTest) methodsFor: 'Testing' !
testDividendShouldReturnDividendThatCreatedException

	[(ZeroDivide dividend: 1) signal]
		on: ZeroDivide
		do: [:ex| self assert: 1 = ex dividend]! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #ZeroDivideTest) methodsFor: 'Testing' !
testShouldBeResumable

	self assert: ZeroDivide new isResumable! !

"June 3, 2008 -> 11:37:37"!

Delta define: #Warning as: (
(Class subclassOf: 'Notification' instanceVariables: '')) !


"June 3, 2008 -> 11:37:37"!

! (Delta mirrorFor: #WarningTest) methodsFor: 'Testing' !
testShouldBeResumable

	self assert: Warning new isResumable! !

"June 3, 2008 -> 11:37:37"!

! (Delta mirrorFor: #WarningTest) methodsFor: 'Testing' !
testDefaultActionShouldProvokeHalt

	| wasHalted wasSignalled |
	wasHalted := wasSignalled := false.
	[[Warning signal]
		on: Halt
		do: [wasHalted := true]]
				on: Warning
				do: [:ex| wasSignalled := true.
								ex outer].
	self assert: wasSignalled
			description: 'Should have signalled Warning'	
							! !

"June 3, 2008 -> 11:37:37"!

! (Delta mirrorFor: #WarningTest) methodsFor: 'Testing' !
testDefaultActionShouldProvokeHalt

	| wasHalted wasSignalled |
	wasHalted := wasSignalled := false.
	[[Warning signal]
		on: Halt
		do: [wasHalted := true]]
				on: Warning
				do: [:ex| wasSignalled := true.
								ex outer].
	self assert: wasSignalled
			description: 'Should have signalled Warning'.	
	self assert: wasHalted
			description: 'Default action should have halted'! !

"June 3, 2008 -> 11:37:37"!

! (Delta mirrorFor: #Warning) methodsFor: 'exception descriptor' !
defaultAction

	self halt! !

"June 3, 2008 -> 11:39:28"!

! (Delta mirrorFor: #Warning) methodsFor: 'exception descriptor' !
defaultAction

	self halt! !

"June 3, 2008 -> 11:39:28"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testDefaultActionShouldExecuteInSignallingEnvironmentAfterResumableOuter

	| original wasHandled |
	original := TestException defaultActionBlock: [self error: ''].
	original resumable: true.
	wasHandled := false.
	[[original signal]
		on: Error
		do: [:ex| wasHandled := true]]
			on: TestException
			do: [:ex| ex outer].
	self assert: wasHandled! !

"June 3, 2008 -> 11:39:28"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
outer
"Evaluate the enclosing exception action and return to here 
instead of signal if it resumes (see #resumeUnchecked:)."
	| oldHandler oldContext |
	self isResumable
		ifFalse: [self pass].
	["oldContext := contextBlock."
	"^(self installContextAndDo: ["
	(oldHandler := handler)
			outer: self return: [:value| ^value]
															"]) value"
															]
		ensure: [handler := oldHandler.
						"contextBlock := oldContext"]! !

"June 3, 2008 -> 11:39:28"!

! (Delta mirrorFor: #Exception) methodsFor: 'restricted exception handling' !
withResume: resumeBlock do: aBlock

	| oldResume |
	aBlock value! !

"June 3, 2008 -> 11:39:28"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:39:28"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:39:28"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:39:28"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:39:28"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:39:28"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:39:28"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:39:28"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"
resumeBlock')) !


"June 3, 2008 -> 11:39:28"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"
resumeBlock')) !


"June 3, 2008 -> 11:39:28"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"
resumeBlock')) !


"June 3, 2008 -> 11:39:28"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"
resumeBlock')) !


"June 3, 2008 -> 11:39:28"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionInstantiator' !
new

	^super new initialize; yourself! !

"June 3, 2008 -> 11:39:28"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionInstantiator' !
new

	^super new
			initialize;
			yourself! !

"June 3, 2008 -> 11:39:28"!

! (Delta mirrorFor: #Exception) methodsFor: 'restricted exception handling' !
initialize

	resumeBlock := [:resumptionValue| contextBlock value: [resumptionValue]]! !

"June 3, 2008 -> 11:39:28"!

! (Delta mirrorFor: #Exception) methodsFor: 'restricted exception handling' !
withResume: aResumeBlock do: aBlock

	| oldResume |
	oldResume := resumeBlock.
	resumeBlock := aResumeBlock.
	aBlock
		ensure: [resumeBlock := oldResume]! !

"June 3, 2008 -> 11:39:28"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resume: resumptionValue
"Return resumptionValue as the value of the signal message."
	resumeBlock value: resumptionValue! !

"June 3, 2008 -> 11:39:28"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
outer: exception return: aReturnBlock

	nextHandler handle: exception return: aReturnBlock! !

"June 3, 2008 -> 11:39:29"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
outer: exception return: aReturnBlock

	exception
		withResume: [:value| ^value]
		do: [nextHandler handle: exception return: aReturnBlock]! !

"June 3, 2008 -> 11:39:29"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
outer
"Evaluate the enclosing exception action and return to here 
instead of signal if it resumes (see #resumeUnchecked:)."
	| oldHandler oldContext |
	self isResumable
		ifFalse: [self pass].
	["oldContext := contextBlock."
	"^(self installContextAndDo: ["
	^(oldHandler := handler)
			outer: self return: [:value| ^value]
															"]) value"
															]
		ensure: [handler := oldHandler.
						"contextBlock := oldContext"]! !

"June 3, 2008 -> 11:39:29"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
handle: exception return: aReturnBlock

	Processor activeProcess popHandler.
	[^(exceptionSelector handles: exception)
		ifTrue: [	exception handler: self.
						returnBlock value: (handleBlock value: exception)]
		ifFalse: [nextHandler handle: exception return: aReturnBlock]]
			ensure: [Processor activeProcess pushHandler: self]! !

"June 3, 2008 -> 11:39:29"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"
resumeBlock')) !


"June 3, 2008 -> 11:39:29"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"
resumeBlock')) !


"June 3, 2008 -> 11:39:29"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"
resumeBlock')) !


"June 3, 2008 -> 11:39:29"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"
resumeBlock')) !


"June 3, 2008 -> 11:39:29"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"
resumeBlock')) !


"June 3, 2008 -> 11:39:29"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"
resumeBlock')) !


"June 3, 2008 -> 11:39:29"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"
resumeBlock')) !


"June 3, 2008 -> 11:39:29"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
signalledHandler "this was the first handler when the exception was originally signalled"
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"
resumeBlock')) !


"June 3, 2008 -> 11:39:29"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
signalledHandler "this was the first handler when the exception was originally signalled"
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"
resumeBlock')) !


"June 3, 2008 -> 11:39:29"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
signalledHandler "this was the first handler when the exception was originally signalled"
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"
resumeBlock')) !


"June 3, 2008 -> 11:39:29"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
signalledHandler "this was the first handler when the exception was originally signalled"
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"
resumeBlock')) !


"June 3, 2008 -> 11:39:29"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
privateSignal

	^self installContextAndDo: [signalledHandler := Processor activeProcess handlerChain.
														signalledHandler handle: self]! !

"June 3, 2008 -> 11:39:29"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain: aHandler

	handlerChain := aHandler! !

"June 3, 2008 -> 11:39:29"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
inEnvironment: aHandler do: block

	| oldHandler |
	oldHandler := self handlerChain.
	handlerChain := aHandler.
	block
		ensure: [handlerChain := oldHandler]! !

"June 3, 2008 -> 11:39:29"!

! (Delta mirrorFor: #Exception) methodsFor: 'restricted exception handling' !
inContextDo: aBlock

	Processor activeProcess
		inEnvironment: signalledHandler
		do: aBlock
	! !

"June 3, 2008 -> 11:39:29"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReportErrorAfterReturnFromNonResumableDefaultAction

	| handler exception wasHandled |
	handler := BlockExceptionHandler default.
	exception := TestException defaultActionBlock: [].
	exception resumable: false.
	[exception signal.
	self signalFailure: 'Handler should not return']
		on: Error
		do: [:error| self assert: 'Return from non-resumable default action is not supported' = error messageText
									description: error messageText.
				wasHandled := true].
	self assert: wasHandled description: 'Handler should report error'! !

"June 3, 2008 -> 11:39:29"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterTwiceShouldInvokeSurroundingHandlerTwice

	|count|
	count := 0.
	[[TestException new
		resumable: true;
		signal]
		on: TestException
		do: [:ex| ex outer.
				ex outer]]
			on: TestException
			do: [:ex| count := count + 1
							ex resume].
	self assert: count == 2 description: 'Count was ', count printString! !

"June 3, 2008 -> 11:39:29"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterTwiceShouldInvokeSurroundingHandlerTwice

	|count|
	count := 0.
	[[TestException new
		resumable: true;
		signal]
		on: TestException
		do: [:ex| ex outer.
				ex outer]]
			on: TestException
			do: [:ex| count := count + 1.
							ex resume].
	self assert: count == 2 description: 'Count was ', count printString! !

"June 3, 2008 -> 11:39:29"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[[[aTestCase runCase.
			true]
				sunitOn: self class failure
				do: [:signal |
						aTestCase echo.
						Transcript cr; tab; show: signal messageText.
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: MessageNotUnderstood
							do: [:signal | |message|
									aTestCase echo.
									message := signal message.
									message receiver printOn: (Transcript cr; yourself).
									Transcript space; show: message selector.
									signal pass]]
										sunitOn: self class error
										do: [:signal |
												self halt.
												aTestCase echo.
												Transcript cr.
												signal class printOn: Transcript.
												signal messageText isNil
													ifFalse: [Transcript space; show: signal messageText].
												self errors add: aTestCase.
												signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"June 3, 2008 -> 11:42:19"!

! (Delta mirrorFor: #WarningTest) methodsFor: 'Testing' !
testDefaultActionShouldProvokeHalt

	| wasHalted wasSignalled |
	wasHalted := wasSignalled := false.
	[[Warning signal]
		on: Halt
		do: [:ex| wasHalted := true]]
				on: Warning
				do: [:ex| wasSignalled := true.
								ex outer].
	self assert: wasSignalled
			description: 'Should have signalled Warning'.	
	self assert: wasHalted
			description: 'Default action should have halted'! !

"June 3, 2008 -> 11:45:34"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Printing' !
echo

	Transcript cr.
	self printOn: Transcript! !

"June 3, 2008 -> 11:47:26"!

! (Delta mirrorFor: #RationalNumber) classSide methodsFor: 'instance creation' !
numerator: n <Int> denominator: d <Int> ^<RationalNumber>

	| gcd <Int> num <Int> denom <Int> |
	d < 0
		ifFalse: [ d == 0
					ifTrue: [ (ZeroDivide dividend: n) signal ]
					ifFalse: [ num := n. denom := d ]	]
		ifTrue: [ num := n negated. denom := d negated ].
	gcd := num gcd: denom.
	num := num // gcd.
	^gcd == denom
		ifTrue: [ num ]
		ifFalse: [	Fraction
							numerator: num
							denominator: denom // gcd ]! !

"June 3, 2008 -> 11:51:15"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[[[aTestCase runCase.
			true]
				sunitOn: self class failure
				do: [:signal |
						aTestCase echo.
						Transcript cr; tab; show: signal messageText.
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: MessageNotUnderstood
							do: [:signal | |message|
									aTestCase echo.
									message := signal message.
									message receiver printOn: (Transcript cr; yourself).
									Transcript space; show: message selector.
									signal pass]]
										sunitOn: self class error
										do: [:signal |
												aTestCase echo.
												Transcript cr.
												signal class printOn: Transcript.
												signal messageText isNil
													ifFalse: [Transcript space; show: signal messageText].
												self errors add: aTestCase.
												signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"June 3, 2008 -> 11:52:4"!

"System saved" !
"June 3, 2008 -> 23:53:37"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testReturnShouldReturnValueAsResutlOfOnDo

	| result |
	result := [Error signal]
						on: Error
						do: [:ex| ex return: #value.
										self signalFailure: 'return: should not return!!'].
	self assert: result = #value
			description: 'Wrong result returned:', result! !

"June 3, 2008 -> 23:56:28"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testReturnShouldReturnValueFromInnerHandler

	| result |
	[result := [Error signal]
						on: Error
						do: [:ex| ex return: #value1]]
							on: Error
							do: [:ex| ex return: #value2].
	self assert: result = #value1
			description: 'Wrong result returned:', result! !

"June 3, 2008 -> 23:57:4"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testReturnShouldReturnValueFromOuterHandler

	| result |
	result := [[Error signal]
						on: Error
						do: [:ex| ex outer]]
							on: Error
							do: [:ex| ex return: #value2].
	self assert: result = #value2
			description: 'Wrong result returned:', result! !

"June 3, 2008 -> 23:57:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testReturnShouldReturnValueFromOuterHandler

	| result |
	result := [[Error signal]
						on: Error
						do: [:ex| ex outer].
					self signalFailure: 'Block should not complete']
							on: Error
							do: [:ex| ex return: #value2].
	self assert: result = #value2
			description: 'Wrong result returned:', result! !

"June 3, 2008 -> 23:58:55"!

"System saved" !
"June 4, 2008 -> 0:3:14"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testExceptionSetForWarningAndHaltHandlesBoth

	| exceptionSet |
	exceptionSet := Warning, Halt.
	self assert: (exceptionSet handles: Warning new)
			description: 'Should handle Warning'.
	self assert: (exceptionSet handles: Halt new)
			description: 'Should handle Halt'.
	self deny: (exceptionSet handles: Error new)
			description: 'Shouldn''t handle Error'.! !

"June 4, 2008 -> 0:5:0"!

Delta define: #ExceptionSet as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 4, 2008 -> 0:5:19"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionSelector' !
, anotherException
"Create an exception set."

	^ExceptionSet new
		add: self;
		add: anotherException;
		yourself! !

"June 4, 2008 -> 0:5:56"!

! (Delta mirrorFor: #ExceptionSet) methodsFor: 'accessing' !
add: exceptionSelector

	! !

"June 4, 2008 -> 0:7:1"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionSelector' !
, anotherException
"Create an exception set."

	^(ExceptionSet with: self)
			,  anotherException! !

"June 4, 2008 -> 0:7:39"!

! (Delta mirrorFor: #ExceptionSet) classSide methodsFor: 'instance creation' !
with: exceptionClass

	^self new , exceptionClass! !

"June 4, 2008 -> 0:7:57"!

! (Delta mirrorFor: #ExceptionSet) methodsFor: 'initialization' !
initialize! !

"June 4, 2008 -> 0:8:5"!

Delta define: #ExceptionSet as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptions')) !


"June 4, 2008 -> 0:8:17"!

! (Delta mirrorFor: #ExceptionSet) methodsFor: 'initialization' !
initialize

	exceptions  := Set new! !

"June 4, 2008 -> 0:8:23"!

! (Delta mirrorFor: #ExceptionSet) methodsFor: 'initialization' !
initialize

	exceptions := Set new! !

"June 4, 2008 -> 0:8:36"!

! (Delta mirrorFor: #ExceptionSet) methodsFor: 'accessing' !
, exceptionClass! !

"June 4, 2008 -> 0:9:29"!

! (Delta mirrorFor: #ExceptionSet) methodsFor: 'accessing' !
, exceptionClass

	exceptions add: exceptionClass! !

"June 4, 2008 -> 0:10:4"!

! (Delta mirrorFor: #ExceptionSet) classSide methodsFor: 'instance creation' !
with: exceptionClass

	^self new initialize , exceptionClass! !

"June 4, 2008 -> 0:10:50"!

! (Delta mirrorFor: #ExceptionSet) methodsFor: 'exception selector' !
handles: anException

	^exceptions includes: anException class! !

"June 4, 2008 -> 0:11:48"!

Delta define: #ExceptionSetTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 4, 2008 -> 0:14:21"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetSelectsMatchingException

	| exceptionSelector wasHandled |
	exceptionSelector := Warning, Halt.
	[Warning signal.
	self error: '']
		on: exceptionSelector
		do: [:ex| wasHandled := true].
	self assert: wasHandled
			description: 'Should have caught Warning'	! !

"June 4, 2008 -> 0:15:20"!

Delta define: #ExceptionSetTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exceptionSelector')) !


"June 4, 2008 -> 0:15:29"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
setUp
! !

"June 4, 2008 -> 0:16:22"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Running' !
setUp

	super setUp.
	exceptionSelector := Warning, Halt.
! !

"June 4, 2008 -> 0:17:7"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetSelectsMatchingException

	| wasHandled |
	exceptionSelector := Warning, Halt.
	[Warning signal.
	self error: '']
		on: exceptionSelector
		do: [:ex| wasHandled := true].
	self assert: wasHandled
			description: 'Should have caught Warning'	! !

"June 4, 2008 -> 0:17:15"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetSelectsMatchingException

	| wasHandled |
	[Warning signal.
	self error: '']
		on: exceptionSelector
		do: [:ex| wasHandled := true].
	self assert: wasHandled
			description: 'Should have caught Warning'	! !

"June 4, 2008 -> 0:17:33"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetSelectsWarning

	| wasHandled |
	[Warning signal.
	self error: '']
		on: exceptionSelector
		do: [:ex| wasHandled := true].
	self assert: wasHandled
			description: 'Should have caught Warning'	! !

"June 4, 2008 -> 0:17:36"!

(Delta mirrorFor: #ExceptionSetTest) removeMethod: #testExceptionSetSelectsMatchingException ifAbsent: [] !


"June 4, 2008 -> 0:17:49"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetSelectsHalt

	| wasHandled |
	[Halt signal.
	self error: '']
		on: exceptionSelector
		do: [:ex| wasHandled := true].
	self assert: wasHandled
			description: 'Should have caught Halt'	! !

"June 4, 2008 -> 0:18:52"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetShouldntSelectNotification

	| wasHandled |
	[Notification signal.
	self error: '']
		on: exceptionSelector
		do: [:ex| wasHandled := true].
	self deny: wasHandled
			description: 'Shouldn''t have caught Notification'	! !

"June 4, 2008 -> 0:19:7"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetShouldntSelectNotification

	| wasHandled |
	[Notification signal]
		on: exceptionSelector
		do: [:ex| wasHandled := true].
	self deny: wasHandled
			description: 'Shouldn''t have caught Notification'	! !

"June 4, 2008 -> 0:19:35"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetShouldntSelectNotification

	| wasHandled |
	wasHandled := false.
	[Notification signal]
		on: exceptionSelector
		do: [:ex| wasHandled := true].
	self deny: wasHandled
			description: 'Shouldn''t have caught Notification'	! !

"June 4, 2008 -> 0:19:43"!

Delta define: #ExceptionSetTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exceptionSelector
wasHandled')) !


"June 4, 2008 -> 0:19:48"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetShouldntSelectNotification

	wasHandled := false.
	[Notification signal]
		on: exceptionSelector
		do: [:ex| wasHandled := true].
	self deny: wasHandled
			description: 'Shouldn''t have caught Notification'	! !

"June 4, 2008 -> 0:19:58"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Running' !
setUp

	super setUp.
	exceptionSelector := Warning, Halt.
	wasHandled := false! !

"June 4, 2008 -> 0:20:12"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetSelectsWarning

	[Warning signal.
	self error: '']
		on: exceptionSelector
		do: [:ex| wasHandled := true].
	self assert: wasHandled
			description: 'Should have caught Warning'	! !

"June 4, 2008 -> 0:20:17"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetSelectsWarning

	[Warning signal.
	self error: '']
		on: exceptionSelector
		do: [:ex| wasHandled := true].
	self assert: wasHandled
			description: 'Should have caught Warning'! !

"June 4, 2008 -> 0:20:25"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetSelectsHalt

	[Halt signal.
	self error: '']
		on: exceptionSelector
		do: [:ex| wasHandled := true].
	self assert: wasHandled
			description: 'Should have caught Halt'	! !

"June 4, 2008 -> 0:20:30"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetSelectsHalt

	[Halt signal.
	self error: '']
		on: exceptionSelector
		do: [:ex| wasHandled := true].
	self assert: wasHandled
			description: 'Should have caught Halt'! !

"June 4, 2008 -> 0:20:54"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetShouldntSelectNotification

	[Notification signal]
		on: exceptionSelector
		do: [:ex| wasHandled := true].
	self deny: wasHandled
			description: 'Shouldn''t have caught Notification'	! !

"June 4, 2008 -> 0:21:49"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
signal: exceptionClass

	[exceptionClass signal]
		on: exceptionSelector
		do: [:ex| wasHandled := true].! !

"June 4, 2008 -> 0:22:8"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetSelectsHalt

	self signal: Halt.
	self assert: wasHandled
			description: 'Should have caught Halt'! !

"June 4, 2008 -> 0:22:23"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetSelectsWarning

	self signal: Warning
	self assert: wasHandled
			description: 'Should have caught Warning'! !

"June 4, 2008 -> 0:22:33"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetSelectsWarning

	self signal: Warning.
	self assert: wasHandled
			description: 'Should have caught Warning'! !

"June 4, 2008 -> 0:22:55"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetShouldntSelectNotification

	self signal: Notification.
	self deny: wasHandled
			description: 'Shouldn''t have caught Notification'	! !

"June 4, 2008 -> 0:25:22"!

"System saved" !
"June 4, 2008 -> 23:36:55"!

! (Delta mirrorFor: #SystemMonitorData) methodsFor: 'private' !
fractionFor: index <Integer> ^<Float>
	
	^total = 0
		ifTrue: [0.0d]
		ifFalse: [(data at: index) asFloat / total]
	! !

"June 4, 2008 -> 23:54:25"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
objectMemorySize

	^{{self primitiveObjectMemorySize}}! !

"June 4, 2008 -> 23:54:53"!

! (Delta mirrorFor: #SystemMonitorData) methodsFor: 'private' !
fractionFor: index <Integer> ^<Float>
	
	^total = 0
		ifTrue: [0.0d]
		ifFalse: [(data at: index) asFloat / total]! !

"June 4, 2008 -> 23:55:46"!

! (Delta mirrorFor: #SystemMonitorData) methodsFor: 'accessing' !
objectMemory

	^VM objectMemorySize! !

"June 4, 2008 -> 23:56:8"!

"System saved" !
"June 4, 2008 -> 23:57:17"!

! (Delta mirrorFor: #SystemMonitor) methodsFor: 'private  - initialization' !
entriesDo: blk <[Str, [^Float]]>
	"Iterates over all entries for the table"
	
	blk value: 'Optimized code'		value: [ self monitorData inCompiledCode ].
	blk value: 'Interpreted code'		value: [ self monitorData inInterpretedCode ].
	blk value: 'PIC code' 					value: [ self monitorData inPICCode ].
	blk value: 'Compiling' 					value: [ self monitorData inCompiler ].
	blk value: 'Garbage Collector'	value: [ self monitorData inGarbageCollector ].
	blk value: 'Stub code'					value: [ self monitorData inStubCode ].
	blk value: 'Primitives/DLL'			value: [ self monitorData inVM ].
	blk value: 'Primitives/DLL'			value: [ self monitorData inVM ]! !

"June 4, 2008 -> 23:57:27"!

! (Delta mirrorFor: #SystemMonitor) methodsFor: 'private' !
buildBareVisualTop: top <Boolean> ^ <Visual>

	self table: (Table rows: 8 columns: 2).
	self addConstantEntriesToTable.
	self startUpdateProcess.
	^self table imbeddedVisual" withBorder: (Border standard3DWithColor: Paint gray raised: false)"
! !

"June 4, 2008 -> 23:58:58"!

"System saved" !
"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #SystemMonitor) methodsFor: 'private  - initialization' !
entriesDo: blk <[Str, [^Float]]>
	"Iterates over all entries for the table"
	
	blk value: 'Optimized code'		value: [ self monitorData inCompiledCode ].
	blk value: 'Interpreted code'		value: [ self monitorData inInterpretedCode ].
	blk value: 'PIC code' 					value: [ self monitorData inPICCode ].
	blk value: 'Compiling' 					value: [ self monitorData inCompiler ].
	blk value: 'Garbage Collector'	value: [ self monitorData inGarbageCollector ].
	blk value: 'Stub code'					value: [ self monitorData inStubCode ].
	blk value: 'Primitives/DLL'			value: [ self monitorData inVM ].
	blk value: 'Object Memory'		value: [ self monitorData objectMemory ]! !

"June 6, 2008 -> 0:37:28"!

Delta define: #Model as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2008 -> 0:37:28"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Model' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'test processing' !
errorLog
	^SUnitNameResolver defaultLogDevice! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'test processing' !
showResult

	self errorLog cr;cr; show: '==== SUnit ======== Start ===='.
	self
		showResultSummary;
		showResultDefects.
	self errorLog cr; show: '==== SUnit ========== End ===='; cr.! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'test processing' !
showResultDefects

	(self result failureCount > 0)
		ifTrue: [
			self errorLog cr; show: '---- SUnit ----- Failures ----'.
			self result failures do: [:failure |
				self errorLog crtab; show: failure printString]].
	(self result errorCount > 0)
		ifTrue: [
			self errorLog cr; show: '---- SUnit ------- Errors ----'.
			self result errors do: [:error |
				self errorLog crtab; show: error printString]].! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'test processing' !
showResultSummary

	| message summary |
	message := (self result runCount = self result correctCount)
		ifTrue: [self successMessage]
		ifFalse: [self failureMessage].
	self errorLog crtab; show: message.
	summary :=
		self result runCount printString, ' run, ',
		self result failureCount printString, ' failed, ',
		self result errorCount printString, ' errors (',
		self duration printString, ' ms)'.
	self errorLog crtab; show: summary.! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
debugButtonLabel
        ^ 'DEBUG'! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
debugState

        ^true! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
errorColor
        ^ Color red! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
failColor
        ^ Color yellow! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
passColor
        ^ Color green! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
refreshButtonLabel
        ^ 'REFRESH'! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
refreshButtonState

        ^true! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
resetColor
        ^ Color white! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
runButtonColor
        ^ Color yellow! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
runButtonLabel
        ^ 'RUN ALL'! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
runButtonState

        ^true! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
runOneButtonLabel
        ^ 'RUN'! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
windowLabel

        ^'SUnit Camp Smalltalk ', TestCase sunitVersion, ' Test Runner'! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
debugTest! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
runOneTest
        Cursor execute showWhile:
                [testSuite notNil
                        ifTrue:
                                [self runWindow.
                                result _ testSuite asSymbol sunitAsClass suite run.
                                self updateWindow: result]
                        ifFalse:
                                [self runWindow.
                                self displayPassFail: 'No Test Suite Selected']]! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
runTests
	Cursor execute showWhile:[
		self runWindow.
		result := TestResult new.
		self suite tests do:[:each|
			self displayPassFail: 'Running ', each name.
			World displayWorld.
			each run: result.
			self updateWindow: result.
		].
	].
! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
selectedErrorTest
        ^selectedErrorTest! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
selectedFailureTest

        ^selectedFailureTest! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
selectedSuite

        ^selectedSuite! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
openAsMorph
        "TestRunner new openAsMorph"
        "=== build the parts ... ==="
        | topWindow runButton errorsList failuresList runOneButton
refreshButton |
        Smalltalk isMorphic
                ifFalse: [^self open].
        (topWindow _ SystemWindow labelled: self windowLabel) model: self.
        runButton _ PluggableButtonMorph
                                on: self
                                getState: #runButtonState
                                action: #runTests
                                label: #runButtonLabel.
        runButton color: self runButtonColor.
        runButton onColor: self runButtonColor offColor: self runButtonColor.
        runOneButton _ PluggableButtonMorph
                                on: self
                                getState: #runButtonState
                                action: #runOneTest
                                label: #runOneButtonLabel.
        runOneButton color: self runButtonColor.
        runOneButton onColor: self runButtonColor offColor: self
runButtonColor.
        refreshButton _ PluggableButtonMorph
                                on: self
                                getState: #refreshButtonState
                                action: #refreshTests
                                label: #refreshButtonLabel.
        refreshButton color: self runButtonColor.
        refreshButton onColor: self runButtonColor offColor: self
runButtonColor.
        passFailText _ PluggableTextMorph
                                on: self
                                text: #passFail
                                accept: nil.
        passFailText retractable: true.
        detailsText _ PluggableTextMorph
                                on: self
                                text: #details
                                accept: nil.
        detailsText retractable: true.
        testsList _ PluggableListMorph
                                on: self
                                list: #tests
                                selected: #selectedSuite
                                changeSelected: #selectedSuite:.
        testsList autoDeselect: false.
        failuresList _ PluggableListMorph
                                on: self
                                list: #failuresList
                                selected: #selectedFailureTest
                                changeSelected: #debugFailureTest:.
        errorsList _ PluggableListMorph
                                on: self
                                list: #errorsList
                                selected: #selectedErrorTest
                                changeSelected: #debugErrorTest:.
        "=== assemble the whole ... ==="
        topWindow addMorph: refreshButton frame: (0.0 @ 0.0 extent: 0.2 @ 0.2).
        topWindow addMorph: testsList frame: (0.2 @ 0.0 extent: 0.6 @ 0.2).
        topWindow addMorph: runOneButton frame: (0.8 @ 0.0 extent: 0.2 @ 0.1).
        topWindow addMorph: runButton frame: (0.8 @ 0.1 extent: 0.2 @ 0.1).
        topWindow addMorph: passFailText frame: (0.0 @ 0.2 extent: 1.0 @ 0.1).
        topWindow addMorph: detailsText frame: (0.0 @ 0.3 extent: 1.0 @ 0.1).
        topWindow addMorph: failuresList frame: (0.0 @ 0.4 extent: 1.0 @ 0.3).
        topWindow addMorph: errorsList frame: (0.0 @ 0.7 extent: 1.0 @ 0.3).
        "=== open it ... ==="
        topWindow openInWorldExtent: 400 @ 200.
        self refreshWindow.
        ^ topWindow! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'accessing' !
details

        ^details! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'accessing' !
errors

        ^errors! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'accessing' !
errorsList

        ^self errors collect: [:error | error printString]! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'accessing' !
failures

        ^failures! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'accessing' !
formatTime: aTime
        aTime hours > 0 ifTrue: [^aTime hours printString , 'h'].
        aTime minutes > 0 ifTrue: [^aTime minutes printString , 'min'].
        ^aTime seconds printString , ' sec'! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'accessing' !
passFail

        ^passFail! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'accessing' !
suite
        ^TestCase buildSuite! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'accessing' !
tests
        ^ tests! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'accessing' !
timeSinceLastPassAsString: aResult
        (lastPass isNil or: [aResult hasPassed not]) ifTrue: [^ ''].
        ^ ', ' , (self formatTime: (Time now subtractTime: lastPass)) , '
since last Pass'! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
displayDetails: aString
        details := aString.
        self changed: #details! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
displayErrors: anOrderedCollection

        errors := anOrderedCollection.
        self changed: #errorsList! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
displayFailures: anOrderedCollection

        failures := anOrderedCollection.
        self changed: #failuresList! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
displayPassFail: aString
        passFail := aString.
        self changed: #passFail! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
failuresList

	^self failures collect: [:failure | failure printString]! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshWindow
        passFailText isMorph
                ifTrue:
                        [passFailText color: Color white.
                        detailsText color: Color white]
                ifFalse:
                        [passFailText insideColor: Color white.
                        detailsText insideColor: Color white].
        self updateErrors: TestResult new.
        self updateFailures: TestResult new.
        self displayPassFail: 'N/A'.
        self displayDetails: '...'! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
runWindow
        passFailText isMorph
                ifTrue:
                        [passFailText color: Color white.
                        detailsText color: Color white]
                ifFalse:
                        [passFailText insideColor: Color white.
                        detailsText insideColor: Color white].
        self updateErrors: TestResult new.
        self updateFailures: TestResult new.
        self displayPassFail: 'Running...'.
        self displayDetails: '...'! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updateDetails: aTestResult
        self displayDetails: aTestResult printString , (self
timeSinceLastPassAsString: aTestResult).
        aTestResult hasPassed ifTrue: [lastPass _ Time now]! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updateErrors: aTestResult

        self displayErrors: aTestResult errors! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updateFailures: aTestResult

        self displayFailures: aTestResult failures asOrderedCollection! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updatePartColors: aColor
        passFailText isMorph
                ifTrue:
                        [passFailText color: aColor.
                        detailsText color: aColor]
                ifFalse:
                        [passFailText insideColor: aColor.
                        detailsText insideColor: aColor]! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updatePassFail: aTestResult
        | message |
        message _ aTestResult hasPassed
                                ifTrue: ['Pass']
                                ifFalse: ['Fail'].
        self displayPassFail: message! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updateWindow: aTestResult
        aTestResult errors size + aTestResult failures size = 0
                ifTrue: [self updatePartColors: self passColor]
                ifFalse: [aTestResult errors size > 0
                                ifTrue: [self updatePartColors: self
errorColor]
                                ifFalse: [self updatePartColors: self
failColor]].
        self updatePassFail: aTestResult.
        self updateDetails: aTestResult.
        self updateFailures: aTestResult.
        self updateErrors: aTestResult! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) classSide methodsFor: 'instance creation' !
new

        ^super new initialize! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) classSide methodsFor: 'instance creation' !
open
	"TestRunner open"
        ^super new initialize openAsMorph! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshTests
        tests := (TestCase allSubclasses collect: [:each | each name])
		asSortedCollection:[:a :b| a name asString <= b name asString].
        self changed: #tests.
        testSuite := nil.
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.
        self changed: #selectedFailureTest.             "added rew"
        self changed: #selectedErrorTest.               "added rew"
        self changed: #selectedSuite.
        self refreshWindow! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
debugErrorTest: anInteger
        selectedErrorTest := anInteger.				"added rew"
        selectedFailureTest := 0.							"added rew"
        self changed: #selectedFailureTest.		"added rew"
        self changed: #selectedErrorTest.			"added rew"
        (anInteger ~= 0)
                ifTrue: [(result errors at: anInteger) debug]! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
debugFailureTest: anInteger

        (anInteger ~= 0)
                ifTrue: [(self failures at: anInteger) debugAsFailure].

        selectedFailureTest := anInteger.
        selectedErrorTest := 0.
        self changed: #selectedErrorTest.
        self changed: #selectedFailureTest! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
selectedSuite: anInteger
        anInteger ~= 0 ifTrue: [testSuite := tests at: anInteger].
        selectedSuite := selectedSuite = anInteger
                                        ifTrue:[0]
                                        ifFalse:[anInteger].
        selectedFailureTest := 0.
        selectedErrorTest := 0.
        self changed: #selectedFailureTest.             "added rew"
        self changed: #selectedErrorTest.               "added rew" 
        self changed: #selectedSuite! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses collect: [:each | each name])
		asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses collect: [:each | each name])
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
openAsMorph
        "TestRunner new openAsMorph"
        "=== build the parts ... ==="
        | topWindow runButton errorsList failuresList runOneButton refreshButton |
        Smalltalk isMorphic
                ifFalse: [^self open].
        (topWindow := SystemWindow labelled: self windowLabel) model: self.
        runButton := PluggableButtonMorph
                               		on: self
                                	getState: #runButtonState
                                	action: #runTests
                                	label: #runButtonLabel.
        runButton color: self runButtonColor.
        runButton onColor: self runButtonColor offColor: self runButtonColor.
        runOneButton := PluggableButtonMorph
                                			on: self
                                			getState: #runButtonState
                                			action: #runOneTest
                                			label: #runOneButtonLabel.
        runOneButton color: self runButtonColor.
        runOneButton onColor: self runButtonColor offColor: self runButtonColor.
        refreshButton := PluggableButtonMorph
                                			on: self
                                			getState: #refreshButtonState
                                			action: #refreshTests
                                			label: #refreshButtonLabel.
        refreshButton color: self runButtonColor.
        refreshButton onColor: self runButtonColor offColor: self runButtonColor.
        passFailText := PluggableTextMorph
                                			on: self
                                			text: #passFail
                                			accept: nil.
        passFailText retractable: true.
        detailsText := PluggableTextMorph
                                		on: self
                                		text: #details
                                		accept: nil.
        detailsText retractable: true.
        testsList := PluggableListMorph
                                on: self
                                list: #tests
                                selected: #selectedSuite
                                changeSelected: #selectedSuite:.
        testsList autoDeselect: false.
        failuresList := PluggableListMorph
                                		on: self
                                		list: #failuresList
                                		selected: #selectedFailureTest
                                		changeSelected: #debugFailureTest:.
        errorsList := PluggableListMorph
                                	on: self
                                	list: #errorsList
                                	selected: #selectedErrorTest
                                	changeSelected: #debugErrorTest:.
        "=== assemble the whole ... ==="
        topWindow addMorph: refreshButton frame: (0.0 @ 0.0 extent: 0.2 @ 0.2).
        topWindow addMorph: testsList frame: (0.2 @ 0.0 extent: 0.6 @ 0.2).
        topWindow addMorph: runOneButton frame: (0.8 @ 0.0 extent: 0.2 @ 0.1).
        topWindow addMorph: runButton frame: (0.8 @ 0.1 extent: 0.2 @ 0.1).
        topWindow addMorph: passFailText frame: (0.0 @ 0.2 extent: 1.0 @ 0.1).
        topWindow addMorph: detailsText frame: (0.0 @ 0.3 extent: 1.0 @ 0.1).
        topWindow addMorph: failuresList frame: (0.0 @ 0.4 extent: 1.0 @ 0.3).
        topWindow addMorph: errorsList frame: (0.0 @ 0.7 extent: 1.0 @ 0.3).
        "=== open it ... ==="
        topWindow openInWorldExtent: 400 @ 200.
        self refreshWindow.
        ^ topWindow! !

"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess') !


"June 6, 2008 -> 0:37:29"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess') !


"June 6, 2008 -> 0:37:29"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess') !


"June 6, 2008 -> 0:37:29"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess') !


"June 6, 2008 -> 0:37:29"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess') !


"June 6, 2008 -> 0:37:29"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
startGCProcess

	GCProcess isNil
		or: [(GCProcess running
					or: [GCProcess suspended]) not]
		ifTrue: [GCProcess := [| delay |
														delay := Delay forMilliseconds: 500.
														[delay wait.
														VM objectMemorySize > 0.95
															ifTrue: [VM collectGarbage]] repeat] fork]
! !

"June 6, 2008 -> 0:37:29"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
startGCProcess

	GCProcess isNil
		or: [(GCProcess running
					or: [GCProcess suspended]) not]
		ifTrue: [GCProcess := [| delay |
														delay := Delay forMilliseconds: 500.
														[delay wait.
														VM objectMemorySize > 0.95
															ifTrue: [VM collectGarbage]] repeat] fork]! !

"June 6, 2008 -> 0:37:29"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
startGCProcess

	self needsNewGCProcess
		ifTrue: [GCProcess := [| delay |
														delay := Delay forMilliseconds: 500.
														[delay wait.
														VM objectMemorySize > 0.95
															ifTrue: [VM collectGarbage]] repeat] fork]! !

"June 6, 2008 -> 0:37:29"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
startGCProcess

	self needsNewGCProcess
		ifTrue: [self initializeGCProcess]! !

"June 6, 2008 -> 0:37:29"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
initializeGCProcess

GCProcess := [| delay |
														delay := Delay forMilliseconds: 500.
														[delay wait.
														VM objectMemorySize > 0.95
															ifTrue: [VM collectGarbage]] repeat] fork! !

"June 6, 2008 -> 0:37:29"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
needsNewGCProcess

	^GCProcess isNil
		or: [(GCProcess running
					or: [GCProcess suspended]) not]! !

"June 6, 2008 -> 0:37:29"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
needsNewGCProcess

	^GCProcess isNil
		or: [(GCProcess running
					or: [GCProcess suspended]) not]! !

"June 6, 2008 -> 0:37:29"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
initializeGCProcess

GCProcess := [| delay |
							delay := Delay forMilliseconds: 500.
							[delay wait.
							VM objectMemorySize > 0.95
								ifTrue: [VM collectGarbage]] repeat] fork! !

"June 6, 2008 -> 0:37:30"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
stopGCProcess

	self needsNewGCProcess
		ifFalse: [GCProcess terminate]! !

"June 6, 2008 -> 0:42:10"!

"System saved" !
"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #Application) methodsFor: 'launching' !
launch ^<Window>

	| win <Window> sess <Session> winCreated <Semaphore> 
		notCreated |
	winCreated := Semaphore new.
	notCreated := false.
	sess := Session in: Screen default
		do: [ :sess <Session> |
					winCreated wait.
					notCreated ifFalse: [	win makeActive show]].
	[win := self windowIn: sess.
	winCreated signal.
	sess sessionWindow: win]
		ifCurtailed: [notCreated := true.
								winCreated signal].
	^win! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #Application) methodsFor: 'launching' !
launch ^<Window>

	| win <Window> sess <Session> winCreated <Semaphore> 
		notCreated |
	winCreated := Semaphore new.
	notCreated := false.
	sess := Session in: Screen default
		do: [ :sess <Session> |
					winCreated wait.
					notCreated ifFalse: [	win makeActive show]].
	[win := self windowIn: sess.
	winCreated signal.
	sess sessionWindow: win]
		ifCurtailed: [notCreated := true.
								winCreated signal].
	^win! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox forSingleSelection! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsRow buttonBar container |
	testsRow := Row holding: (OrderedCollection
															with: ListBox forSingleSelection
															with: ListBox forSingleSelection
															with: (Column holding: (OrderedCollection
																											with: TextView new
																											with: TextView new))).
	buttonBar := Row holding: (OrderedCollection
															with: (Button labelled: #'1' action: [:b|])
															with: (Button labelled: #'2' action: [:b|])
															with: (Button labelled: #'3' action: [:b|])
															with: (Button labelled: #'4' action: [:b|])).
	container := Column holding: (OrderedCollection
																with: testsRow
																with: buttonBar).
	^container! !

"June 7, 2008 -> 3:36:20"!

"System saved" !
"June 7, 2008 -> 3:52:47"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsRow buttonBar container |
	testsRow := Row holding: (OrderedCollection
															with: ListBox forSingleSelection
															with: ListBox forSingleSelection
															with: (Column holding: (OrderedCollection
																											with: TextView forString imbeddedVisual
																											with: TextView forString imbeddedVisual))).
	buttonBar := Row holding: (OrderedCollection
															with: (Button labelled: #'1' action: [:b|])
															with: (Button labelled: #'2' action: [:b|])
															with: (Button labelled: #'3' action: [:b|])
															with: (Button labelled: #'4' action: [:b|])).
	container := Column holding: (OrderedCollection
																with: testsRow
																with: buttonBar).
	^container! !

"June 7, 2008 -> 3:57:35"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
textViewOn: aString

	^(TextView forString
			model: '';
			yourself)! !

"June 7, 2008 -> 3:58:8"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsRow buttonBar container |
	testsRow := Row holding: (OrderedCollection
															with: ListBox forSingleSelection
															with: ListBox forSingleSelection
															with: (Column holding: (OrderedCollection
																											with: (self textViewOn: '') imbeddedVisual
																											with: (self textViewOn: '') imbeddedVisual))).
	buttonBar := Row holding: (OrderedCollection
															with: (Button labelled: #'1' action: [:b|])
															with: (Button labelled: #'2' action: [:b|])
															with: (Button labelled: #'3' action: [:b|])
															with: (Button labelled: #'4' action: [:b|])).
	container := Column holding: (OrderedCollection
																with: testsRow
																with: buttonBar).
	^container! !

"June 7, 2008 -> 3:58:48"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsRow buttonBar container |
	testsRow := Row holding: (OrderedCollection
															with: ListBox forSingleSelection
															with: ListBox forSingleSelection
															with: (Column holding: (OrderedCollection
																											with: (self textViewOn: '') imbeddedVisual
																											with: (self textViewOn: '') imbeddedVisual))).
	buttonBar := Row holding: (OrderedCollection
															with: (Button labeled: #'1' action: [:b|])
															with: (Button labeled: #'2' action: [:b|])
															with: (Button labeled: #'3' action: [:b|])
															with: (Button labeled: #'4' action: [:b|])).
	container := Column holding: (OrderedCollection
																with: testsRow
																with: buttonBar).
	^container! !

"June 7, 2008 -> 3:59:20"!

"System saved" !
"June 7, 2008 -> 4:6:30"!

"System saved" !
"June 7, 2008 -> 14:56:46"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsRow buttonBar container equalizer buttonEqualizer |
	equalizer := Equalizer new.
	buttonEqualizer := Equalizer new.
	testsRow := Row holding: (OrderedCollection
															with: (equalizer for: (Row holding: (OrderedCollection
																																	with: self listbox
																																	with: self listbox)))
															with: (equalizer for: (Column holding: (OrderedCollection
																																			with: (self textViewOn: '') 
																																			with: (self textViewOn: ''))))).
	buttonBar := Row holding: (OrderedCollection
															with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																															action: [:b|]))
															with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																															action: [:b|]))
															with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																															action: [:b|]))).
	container := Column holding: (OrderedCollection
																with: testsRow
																with: buttonBar).
	self refreshWindow.
	^container! !

"June 7, 2008 -> 14:57:0"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshTests
        tests := (TestCase allSubclasses "collect: [:each | each name]")
		asSortedCollection:[:a :b| a name asString <= b name asString].
        self changed: #tests.
        testSuite := nil.
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.
        self changed: #selectedFailureTest.             "added rew"
        self changed: #selectedErrorTest.               "added rew"
        self changed: #selectedSuite.
        self refreshWindow! !

"June 7, 2008 -> 14:57:23"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
textViewOn: aString

	^(TextView forString
			isMultiLine: true;
			model: '';
			yourself)
			imbeddedVisual with3DBorder! !

"June 7, 2008 -> 14:57:36"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
listbox

	^ListBox forSingleSelection with3DBorder! !

"June 7, 2008 -> 14:58:0"!

"System saved" !
"June 7, 2008 -> 15:40:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsRow buttonBar container equalizer buttonEqualizer |
	equalizer := Equalizer new.
	buttonEqualizer := Equalizer new.
	passFailText := self textViewOn: ''.
	testsRow := Row holding: (OrderedCollection
															with: (equalizer for: self listbox)
															with: (equalizer for: (Column holding: (OrderedCollection
																																			with: passFailText imbeddedVisual with3DBorder
																																			with: self listbox
																																			with: self listbox)))).
	buttonBar := Row holding: (OrderedCollection
															with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																															action: [:b|]))
															with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																															action: [:b|]))
															with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																															action: [:b|]))).
	container := Column holding: (OrderedCollection
																with: testsRow
																with: buttonBar).
	"container changeAllocation: (Rectangle
																	corner: 0@0
																	corner: 400@200)
						at: 0@0."
	"self refreshWindow."
	^container! !

"June 7, 2008 -> 15:40:54"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
textViewOn: aString

	^TextView forString
			isMultiLine: true;
			model: '';
			yourself! !

"June 7, 2008 -> 15:41:20"!

"System saved" !
"June 7, 2008 -> 17:32:59"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer textEqualizer resultsRow resultsColumn |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: ''.
	detailsText := self textViewOn: ''.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: (self listbox 
																														naturalHeight: 300;
																														naturalWidth: 150;
																														yStretchy: true;
																														xStretchy: true;
																														yourself) with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																															action: [:b|]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																															action: [:b|]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b|]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: passFailText imbeddedVisual)
																			with: (textEqualizer for: detailsText imbeddedVisual)
																			with: (textEqualizer for: resultsRow)).
	^Row holding: (OrderedCollection
										with: testsColumn
										with: resultsColumn)! !

"June 7, 2008 -> 17:33:19"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
oldbuildBareVisualTop: top

	| testsRow buttonBar container equalizer buttonEqualizer |
	equalizer := Equalizer new.
	buttonEqualizer := Equalizer new.
	passFailText := self textViewOn: ''.
	testsRow := Row holding: (OrderedCollection
															with: (equalizer for: (self listbox 
																									naturalHeight: 300;
																									naturalWidth: 200;
																									yStretchy: true;
																									xStretchy: true;
																									yourself) with3DBorder)
															with: (equalizer for: (Column holding: (OrderedCollection
																																			with: passFailText imbeddedVisual with3DBorder
																																			with: self listbox with3DBorder
																																			with: self listbox with3DBorder)))).
	buttonBar := Row holding: (OrderedCollection
															with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																															action: [:b|]))
															with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																															action: [:b|]))
															with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																															action: [:b|]))).
	container := Column holding: (OrderedCollection
																with: testsRow
																with: buttonBar).

	"self refreshWindow."
	^ApplicationInterceptor
			for: container
			application: self! !

"June 7, 2008 -> 17:33:37"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'notificaition' !
visualAllocated
"self halt."
	"self inSessionProcessDo: [visual allocation: (Rectangle
																												corner: 0@0
																												corner: 400@200)
																	at: 0@0]."
	"self refreshWindow."! !

"June 7, 2008 -> 17:33:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
listbox

	^ListBox forSingleSelection! !

"June 7, 2008 -> 17:34:24"!

"System saved" !
"June 7, 2008 -> 19:32:58"!

Delta define: #TestRunner as: (
(Class subclassOf: 'NotifyingObject mixin |> Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 7, 2008 -> 19:32:58"!

Delta define: #TestRunner as: (
(Class subclassOf: 'NotifyingObject mixin |> Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 7, 2008 -> 19:32:58"!

Delta define: #TestRunner as: (
(Class subclassOf: 'NotifyingObject mixin |> Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 7, 2008 -> 19:32:58"!

Delta define: #TestRunner as: (
(Class subclassOf: 'NotifyingObject mixin |> Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 7, 2008 -> 19:32:58"!

Delta define: #TestRunner as: (
(Class subclassOf: 'NotifyingObject mixin |> Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 7, 2008 -> 19:32:58"!

Delta define: #TestRunner as: (
(Class subclassOf: 'NotifyingObject mixin |> Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 7, 2008 -> 19:32:58"!

Delta define: #TestRunner as: (
(Class subclassOf: 'NotifyingObject mixin |> Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 7, 2008 -> 19:32:58"!

Delta define: #TestRunner as: (
(Class subclassOf: 'NotifyingObject mixin |> Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 7, 2008 -> 19:32:58"!

Delta define: #TestRunner as: (
(Class subclassOf: 'NotifyingObject mixin |> Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 7, 2008 -> 19:32:58"!

Delta define: #TestRunner as: (
(Class subclassOf: 'NotifyingObject mixin |> Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 7, 2008 -> 19:32:58"!

Delta define: #TestRunner as: (
(Class subclassOf: 'NotifyingObject mixin |> Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 7, 2008 -> 19:33:33"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshWindow
        passFailText paint: Paint white.
        detailsText paint: Paint white.
        self updateErrors: TestResult new.
        self updateFailures: TestResult new.
        self displayPassFail: 'N/A'.
        self displayDetails: '...'! !

"June 7, 2008 -> 19:33:33"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer textEqualizer resultsRow resultsColumn |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: ''.
	detailsText := self textViewOn: ''.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: (self listbox 
																														naturalHeight: 300;
																														naturalWidth: 150;
																														yStretchy: true;
																														xStretchy: true;
																														yourself) with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																															action: [:b|]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																															action: [:b|]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b|]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: passFailText imbeddedVisual)
																			with: (textEqualizer for: detailsText imbeddedVisual)
																			with: (textEqualizer for: resultsRow)).
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 7, 2008 -> 19:33:33"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'notificaition' !
visualAllocated

	self refreshWindow! !

"June 7, 2008 -> 19:33:33"!

! (Delta mirrorFor: #TextView) methodsFor: 'private-initialization' !
initialize

	super initialize.
	self setPainter: self defaultPainter copy.
	self autoIndent: true.
	self maxUndo: 0.
	self isMultiLine: true.
	self monoPainter: false.
	self modelOutOfDate: false.
	self oneShotModel: false.
	self scrollable: false.! !

"June 7, 2008 -> 22:6:20"!

"System saved" !
"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

! (Delta mirrorFor: #ListModel) classSide methodsFor: 'instance creation' !
on: model items: itemSelector selected: accessor select: mutator

	^self new
			on: model
			items: itemSelector
			select: accessor
			select: mutator
	! !

"June 7, 2008 -> 22:58:27"!

! (Delta mirrorFor: #ListModel) methodsFor: 'initialization' !
on: model items: selector selected: accessor select: mutator

	model addDependent: self.
	"itemSelector := selector."
	! !

"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
')) !


"June 7, 2008 -> 22:58:27"!

! (Delta mirrorFor: #ListModel) methodsFor: 'initialization' !
on: aModel items: selector selected: accessor select: mutator

	| view |
	view := ListBox forSingleSelection.
	aModel addDependent: self.
	itemBlock := [view stringList: (aModel perform: selector)].
	selectionBlock := [view selections: (OrderedCollection
																		with: (aModel perform: accessor))].
	view onSelChange: [:lb | aModel	
														perform: mutator
														with: lb selections first]
	! !

"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'view " the list box displaying the list items "
model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
itemAspect " a selector used to retrieve the item strings from the model "
selectionAspect " a selector used to retrieve the selection from the model "
selectionMutator " a mutator used to change the selection in the model "')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'view " the list box displaying the list items "
model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
itemAspect " a selector used to retrieve the item strings from the model "
selectionAspect " a selector used to retrieve the selection from the model "
selectionMutator " a mutator used to change the selection in the model "')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'view " the list box displaying the list items "
model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
itemAspect " a selector used to retrieve the item strings from the model "
selectionAspect " a selector used to retrieve the selection from the model "
selectionMutator " a mutator used to change the selection in the model "')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'view " the list box displaying the list items "
model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
itemAspect " a selector used to retrieve the item strings from the model "
selectionAspect " a selector used to retrieve the selection from the model "
selectionMutator " a mutator used to change the selection in the model "')) !


"June 7, 2008 -> 22:58:27"!

! (Delta mirrorFor: #ListModel) methodsFor: 'notification' !
changed: aspect

	aspect == itemAspect
		ifTrue: [^view stringList: (model perform: itemAspect)].
	aspect == selectionAspect
		ifTrue: [^view selections: (OrderedCollection
																with: (model perform: selectionAspect))]! !

"June 7, 2008 -> 22:58:27"!

! (Delta mirrorFor: #ListModel) methodsFor: 'initialization' !
on: aModel items: selector selected: accessor select: mutator

	view := ListBox forSingleSelection.
	model := aModel.
	itemAspect := selector.
	selectionAspect := accessor.
	selectionMutator := mutator.
	
	aModel addDependent: self.
	view onSelChange: [:lb | aModel	
														perform: mutator
														with: lb selections first]
	! !

"June 7, 2008 -> 22:58:27"!

! (Delta mirrorFor: #ListModel) methodsFor: 'initialization' !
on: aModel items: selector selected: accessor select: mutator

	view := ListBox forSingleSelection.
	model := aModel.
	itemAspect := selector.
	selectionAspect := accessor.
	selectionMutator := mutator.
	
	model addDependent: self.
	view onSelChange: [:lb | aModel	
														perform: mutator
														with: lb selections first]
	! !

"June 7, 2008 -> 22:58:27"!

! (Delta mirrorFor: #ListModel) methodsFor: 'initialization' !
on: aModel items: selector selected: accessor select: mutator

	view := ListBox forSingleSelection.
	model := aModel.
	model addDependent: self.
	itemAspect := selector.
	selectionAspect := accessor.
	view onSelChange: [:lb | aModel	
														perform: mutator
														with: lb selections first]
	! !

"June 7, 2008 -> 22:58:27"!

! (Delta mirrorFor: #ListModel) methodsFor: 'initialization' !
on: aModel items: selector selected: accessor select: mutator

	view := ListBox forSingleSelection.
	model := aModel.
	model addDependent: self.
	itemAspect := selector.
	selectionAspect := accessor.
	view onSelChange: [:lb | aModel	
														perform: mutator
														with: lb selections first].
	^view
	! !

"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'view " the list box displaying the list items "
model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
itemAspect " a selector used to retrieve the item strings from the model "
selectionAspect " a selector used to retrieve the selection from the model "
selectionMutator " a mutator used to change the selection in the model "')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'view " the list box displaying the list items "
model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
itemAspect " a selector used to retrieve the item strings from the model "
selectionAspect " a selector used to retrieve the selection from the model "
selectionMutator " a mutator used to change the selection in the model "')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'view " the list box displaying the list items "
model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
itemAspect " a selector used to retrieve the item strings from the model "
selectionAspect " a selector used to retrieve the selection from the model "
selectionMutator " a mutator used to change the selection in the model "')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'view " the list box displaying the list items "
model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
itemAspect " a selector used to retrieve the item strings from the model "
selectionAspect " a selector used to retrieve the selection from the model "
selectionMutator " a mutator used to change the selection in the model "')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'view " the list box displaying the list items "
model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
itemAspect " a selector used to retrieve the item strings from the model "
selectionAspect " a selector used to retrieve the selection from the model "
selectionMutator " a mutator used to change the selection in the model "')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'view " the list box displaying the list items "
model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
itemAspect " a selector used to retrieve the item strings from the model "
selectionAspect " a selector used to retrieve the selection from the model "
selectionMutator " a mutator used to change the selection in the model "')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'view " the list box displaying the list items "
model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
itemAspect " a selector used to retrieve the item strings from the model "
selectionAspect " a selector used to retrieve the selection from the model "
selectionMutator " a mutator used to change the selection in the model "')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'view " the list box displaying the list items "
model " the model that provides the list items "
itemAspect " a selector used to retrieve the item strings from the model "
selectionAspect " a selector used to retrieve the selection from the model "')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'view " the list box displaying the list items "
model " the model that provides the list items "
itemAspect " a selector used to retrieve the item strings from the model "
selectionAspect " a selector used to retrieve the selection from the model "')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'view " the list box displaying the list items "
model " the model that provides the list items "
itemAspect " a selector used to retrieve the item strings from the model "
selectionAspect " a selector used to retrieve the selection from the model "')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'view " the list box displaying the list items "
model " the model that provides the list items "
itemAspect " a selector used to retrieve the item strings from the model "
selectionAspect " a selector used to retrieve the selection from the model "')) !


"June 7, 2008 -> 22:58:27"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: ''.
	detailsText := self textViewOn: ''.
	testList := ListModel
							on: self
							items: #tests
							selected: #selection
							select: #select:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: (testList
																														naturalHeight: 300;
																														naturalWidth: 150;
																														yStretchy: true;
																														xStretchy: true;
																														yourself) with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																															action: [:b|]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																															action: [:b|]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b|]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: passFailText imbeddedVisual)
																			with: (textEqualizer for: detailsText imbeddedVisual)
																			with: (textEqualizer for: resultsRow)).
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 7, 2008 -> 22:58:27"!

! (Delta mirrorFor: #ListModel) classSide methodsFor: 'instance creation' !
on: model items: itemSelector selected: accessor select: mutator

	^self new
			on: model
			items: itemSelector
			selected: accessor
			select: mutator
	! !

"June 7, 2008 -> 22:58:27"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: ''.
	detailsText := self textViewOn: ''.
	testList := ListModel
							on: self
							items: #tests
							selected: #selection
							select: #select:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: (testList
																														naturalHeight: 300;
																														naturalWidth: 150;
																														yStretchy: true;
																														xStretchy: true;
																														yourself) with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b|]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b|]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: passFailText imbeddedVisual)
																			with: (textEqualizer for: detailsText imbeddedVisual)
																			with: (textEqualizer for: resultsRow)).
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 7, 2008 -> 22:58:27"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshTests
		Transcript show: 'Refresh tests';cr.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
		asSortedCollection:[:a :b| a name asString <= b name asString].
        self changed: #tests.
        testSuite := nil.
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.
        self changed: #selectedFailureTest.             "added rew"
        self changed: #selectedErrorTest.               "added rew"
        self changed: #selectedSuite.
        self refreshWindow! !

"June 7, 2008 -> 22:58:27"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'accessing' !
tests
Transcript show: 'tests';cr.
        ^ tests! !

"June 7, 2008 -> 22:58:28"!

! (Delta mirrorFor: #ListModel) methodsFor: 'notification' !
changed: aspect
Transcript show: ('Changed ', aspect); cr.
	aspect == itemAspect
		ifTrue: [^view stringList: (model perform: itemAspect)].
	aspect == selectionAspect
		ifTrue: [^view selections: (OrderedCollection
																with: (model perform: selectionAspect))]! !

"June 7, 2008 -> 22:58:28"!

! (Delta mirrorFor: #NotifyingObject) methodsFor: 'private' !
changed: attribute <Object>
Transcript show: 'changed ', attribute.
	self changed: attribute with: nil! !

"June 7, 2008 -> 22:58:28"!

! (Delta mirrorFor: #NotifyingObject) methodsFor: 'private' !
changed: attribute <Object>
Transcript show: ('changed ', attribute); cr.
	self changed: attribute with: nil! !

"June 7, 2008 -> 22:58:28"!

! (Delta mirrorFor: #NotifyingObject) methodsFor: 'private' !
changed: attribute <Object>
self halt.
	self changed: attribute with: nil! !

"June 7, 2008 -> 22:58:28"!

! (Delta mirrorFor: #ListModel) methodsFor: 'notification' !
update: aspect
Transcript show: ('Changed ', aspect); cr.
	aspect == itemAspect
		ifTrue: [^view stringList: (model perform: itemAspect)].
	aspect == selectionAspect
		ifTrue: [^view selections: (OrderedCollection
																with: (model perform: selectionAspect))]! !

"June 7, 2008 -> 22:58:28"!

! (Delta mirrorFor: #NotifyingObject) methodsFor: 'private' !
changed: attribute <Object>

	self changed: attribute with: nil! !

"June 7, 2008 -> 22:58:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'accessing' !
tests

        ^ tests! !

"June 7, 2008 -> 22:58:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshTests
		Transcript show: 'Refresh tests';cr.
        tests := (TestCase allSubclasses collect: [:each | each name])
							asSortedCollection:[:a :b| a asString <= b asString].
        self changed: #tests.
        testSuite := nil.
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.
        self changed: #selectedFailureTest.             "added rew"
        self changed: #selectedErrorTest.               "added rew"
        self changed: #selectedSuite.
        self refreshWindow! !

"June 7, 2008 -> 22:58:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshTests

        tests := (TestCase allSubclasses collect: [:each | each name])
							asSortedCollection:[:a :b| a asString <= b asString].
        self changed: #tests.
        testSuite := nil.
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.
        self changed: #selectedFailureTest.             "added rew"
        self changed: #selectedErrorTest.               "added rew"
        self changed: #selectedSuite.
        self refreshWindow! !

"June 7, 2008 -> 22:58:28"!

! (Delta mirrorFor: #ListModel) methodsFor: 'notification' !
update: aspect

	aspect == itemAspect
		ifTrue: [^view stringList: (model perform: itemAspect)].
	aspect == selectionAspect
		ifTrue: [^view selections: (OrderedCollection
																with: (model perform: selectionAspect))]! !

"June 7, 2008 -> 22:58:28"!

(Delta mirrorFor: #ListModel) removeMethod: #changed: ifAbsent: [] !


"June 7, 2008 -> 22:58:28"!

! (Delta mirrorFor: #ListModel) methodsFor: 'initialization' !
on: aModel items: selector selected: accessor select: mutator

	view := ListBox forSingleSelection.
	model := aModel.
	model addDependent: self.
	itemAspect := selector.
	selectionAspect := accessor.
	view onSelChange: [:lb | aModel	
														perform: mutator
														with: lb selections anElement].
	^view
	! !

"June 7, 2008 -> 22:58:43"!

"System saved" !
"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: ''.
	detailsText := self textViewOn: ''.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: (testList
																														naturalHeight: 300;
																														naturalWidth: 150;
																														yStretchy: true;
																														xStretchy: true;
																														yourself) with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b|]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b|]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: passFailText imbeddedVisual)
																			with: (textEqualizer for: detailsText imbeddedVisual)
																			with: (textEqualizer for: resultsRow)).
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #Cursor) classSide methodsFor: 'instance creation' !
execute

	^self wait! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: ''.
	detailsText := self textViewOn: ''.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: (testList
																														naturalHeight: 300;
																														naturalWidth: 150;
																														yStretchy: true;
																														xStretchy: true;
																														yourself) with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: passFailText imbeddedVisual)
																			with: (textEqualizer for: detailsText imbeddedVisual)
																			with: (textEqualizer for: resultsRow)).
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
runOneTest
        "Cursor execute showWhile:
                ["
	testSuite notNil
		ifTrue: [self runWindow.
						result := testSuite asSymbol sunitAsClass suite run.
						self updateWindow: result]
 		ifFalse: [self runWindow.
						self displayPassFail: 'No Test Suite Selected']
       "]"! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
runTests
	"Cursor execute showWhile:["
	self runWindow.
	result := TestResult new.
	self suite tests
		do:[:each|
				self displayPassFail: 'Running ', each name.
				Processor yield.
				each run: result.
				self updateWindow: result]
	"]."
! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshWindow: passFailText
        passFailText paint: Paint white.
        detailsText paint: Paint white.
        self updateErrors: TestResult new.
        self updateFailures: TestResult new.
        self displayPassFail: passFailText.
        self displayDetails: '...'! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshWindow

        self refreshWindow: 'N/A'! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
runWindow

        self refreshWindow:  'Running...'! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshWindow: passFailText

        passFailText paint: Paint white.
        detailsText paint: Paint white.
        self updateErrors: TestResult new.
        self updateFailures: TestResult new.
        self displayPassFail: passFailText.
        self displayDetails: '...'! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshWindow: passFailString

        passFailText paint: Paint white.
        detailsText paint: Paint white.
        self updateErrors: TestResult new.
        self updateFailures: TestResult new.
        self displayPassFail: passFailString
        self displayDetails: '...'! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshWindow: passFailString

        passFailText paint: Paint white.
        detailsText paint: Paint white.
        self updateErrors: TestResult new.
        self updateFailures: TestResult new.
        self displayPassFail: passFailString.
        self displayDetails: '...'! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updateWindow: aTestResult
        aTestResult errors size + aTestResult failures size = 0
                ifTrue: [self updatePartColors: self passColor]
                ifFalse: [aTestResult errors size > 0
									ifTrue: [self updatePartColors: self errorColor]
									ifFalse: [self updatePartColors: self failColor]].
        self updatePassFail: aTestResult.
        self updateDetails: aTestResult.
        self updateFailures: aTestResult.
        self updateErrors: aTestResult! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
passColor
        ^ Paint green! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
failColor
        ^ Paint yellow! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
errorColor
        ^ Paint red! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updatePartColors: aColor

	passFailText paint: aColor.
	detailsText color: aColor! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updatePartColors: aColor

	passFailText paint: aColor.
	detailsText paint: aColor! !

"June 7, 2008 -> 23:28:54"!

"System saved" !
"June 7, 2008 -> 23:36:5"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updatePassFail: aTestResult

	| message |
	message := aTestResult hasPassed
								ifTrue: ['Pass']
								ifFalse: ['Fail'].
	self displayPassFail: message! !

"June 7, 2008 -> 23:36:5"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updateDetails: aTestResult

	| detailString |
	detailString := aTestResult printString , (self timeSinceLastPassAsString: aTestResult).
	self displayDetails: detailString.
	aTestResult hasPassed
		ifTrue: [lastPass := Time now]! !

"June 7, 2008 -> 23:36:5"!

! (Delta mirrorFor: #Time) methodsFor: 'arithmetic' !
subtractTime: amt <Date|Time> ^<Instance>

	^self actualClass fromSeconds: self asSeconds - amt asSeconds! !

"June 7, 2008 -> 23:36:26"!

"System saved" !
"June 8, 2008 -> 1:17:40"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updatePassFail: aTestResult

	| message |
	message := aTestResult hasPassed
								ifTrue: ['Pass']
								ifFalse: ['Fail'].
	self displayPassFail: message! !

"June 8, 2008 -> 1:17:40"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updateDetails: aTestResult

	| detailString |
	detailString := aTestResult printString , (self timeSinceLastPassAsString: aTestResult).
	self displayDetails: detailString.
	aTestResult hasPassed
		ifTrue: [lastPass := Time now]! !

"June 8, 2008 -> 1:17:41"!

! (Delta mirrorFor: #Time) methodsFor: 'arithmetic' !
subtractTime: amt <Date|Time> ^<Instance>

	^self actualClass fromSeconds: self asSeconds - amt asSeconds! !

"June 8, 2008 -> 1:23:1"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'accessing' !
formatTime: aTime
        aTime hour > 0 ifTrue: [^aTime hour printString , 'h'].
        aTime minutes > 0 ifTrue: [^aTime minutes printString , 'min'].
        ^aTime second printString , ' sec'! !

"June 8, 2008 -> 1:27:0"!

Delta define: #TextModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 8, 2008 -> 1:27:40"!

! (Delta mirrorFor: #TextModel) classSide methodsFor: 'instance creation' !
on: aModel text: selector

	^self new
			on: aModel
			text: selector! !

"June 8, 2008 -> 1:28:9"!

! (Delta mirrorFor: #TextModel) classSide methodsFor: 'instance creation' !
on: aModel text: aspect

	^self new
			on: aModel
			text: aspect! !

"June 8, 2008 -> 1:29:47"!

Delta define: #TextModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the contents "
aspect "  the aspect of the model "
view " the view to be updated with the contents "')) !


"June 8, 2008 -> 1:30:46"!

! (Delta mirrorFor: #TextModel) methodsFor: 'initialization' !
on: aModel text: anAspect

	view := TextView forString.
	view
		isMultiline: true;
		model: ''.
	model := aModel.
	aspect := anAspect! !

"June 8, 2008 -> 1:32:18"!

! (Delta mirrorFor: #TextModel) methodsFor: 'initialization' !
on: aModel text: anAspect

	view := TextView forString.
	view
		isMultiline: true;
		model: ''.
	model := aModel.
	aspect := anAspect.
	model addDependent: self.
	^view! !

"June 8, 2008 -> 1:33:24"!

! (Delta mirrorFor: #TextModel) methodsFor: 'notification' !
update: anAspect

	anAspect == aspect
		ifTrue: [view model: (model perform: aspect)]! !

"June 8, 2008 -> 1:34:23"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: (testList
																														naturalHeight: 300;
																														naturalWidth: 150;
																														yStretchy: true;
																														xStretchy: true;
																														yourself) with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: passFailText imbeddedVisual)
																			with: (textEqualizer for: detailsText imbeddedVisual)
																			with: (textEqualizer for: resultsRow)).
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 8, 2008 -> 1:34:49"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
textViewOn: aspect

	^TextModel
			on: self
			aspect: aspect! !

"June 8, 2008 -> 1:36:44"!

! (Delta mirrorFor: #TextModel) methodsFor: 'initialization' !
on: aModel aspect: anAspect

	view := TextView forString.
	view
		isMultiline: true;
		model: ''.
	model := aModel.
	aspect := anAspect.
	model addDependent: self.
	^view! !

"June 8, 2008 -> 1:36:47"!

! (Delta mirrorFor: #TextModel) classSide methodsFor: 'instance creation' !
on: aModel aspect: aspect

	^self new
			on: aModel
			aspect: aspect! !

"June 8, 2008 -> 1:37:39"!

! (Delta mirrorFor: #TextModel) methodsFor: 'initialization' !
on: aModel aspect: anAspect

	view := TextView forString.
	view
		isMultiLine: true;
		model: ''.
	model := aModel.
	aspect := anAspect.
	model addDependent: self.
	^view! !

"June 8, 2008 -> 1:40:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: (testList
																														naturalHeight: 300;
																														naturalWidth: 150;
																														yStretchy: true;
																														xStretchy: true;
																														yourself) with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: passFailText imbeddedVisual with3DBorder)
																			with: (textEqualizer for: detailsText imbeddedVisual with3DBorder)
																			with: (textEqualizer for: resultsRow)).
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 8, 2008 -> 1:44:5"!

"System saved" !
"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TextModel) methodsFor: 'notification' !
update: anAspect

	anAspect == aspect
		ifTrue: [Transcript show: ('updated: ', aspect); cr.
					view model: (model perform: aspect)]! !

"June 8, 2008 -> 18:19:37"!

(Delta mirrorFor: #TextModel) classSide removeMethod: #on:text: ifAbsent: [] !


"June 8, 2008 -> 18:19:37"!

(Delta mirrorFor: #TextModel) removeMethod: #on:text: ifAbsent: [] !


"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TextModel) methodsFor: 'initialization' !
on: aModel aspect: anAspect

	view := TextView forString.
	view
		isMultiLine: true;
		model: 'blank'.
	model := aModel.
	aspect := anAspect.
	model addDependent: self.
	^view! !

"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TextModel) methodsFor: 'notification' !
update: anAspect

	anAspect == aspect
		ifTrue: ["Transcript show: ('updated: ', aspect); cr."
					view model: (model perform: aspect).
					view visual invalidate]! !

"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TextModel) methodsFor: 'notification' !
update: anAspect

	anAspect == aspect
		ifTrue: [Transcript show: ('updated: ', aspect, ',', (model perform: aspect)); cr.
					view model: (model perform: aspect).
					view visual invalidate]! !

"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TextModel) methodsFor: 'initialization' !
on: aModel aspect: anAspect

	view := TextView forString.
	view
		isMultiLine: true;
		model: 'blank';
		paint: Paint black.
	model := aModel.
	aspect := anAspect.
	model addDependent: self.
	^view! !

"June 8, 2008 -> 18:19:37"!

(Delta mirrorFor: #TestRunner)
comment: 
'(TestRunner new launch)'!


"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TextView) methodsFor: 'accessing' !
paint: p <Paint>
Transcript cr. p  printOn: Transcript.
	self painter paint: p! !

"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Running' !
run: aResult 
	self tests do: [:each | 
		self sunitChanged: each.
		Processor yield.
		each run: aResult]
			! !

"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
errorColor
        ^ Paint black! !

"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
failColor
        ^ Paint black! !

"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
passColor
        ^ Paint black! !

"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
resetColor
        ^ Color black! !

"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshWindow: passFailString

        "passFailText paint: Paint white.
        detailsText paint: Paint white."
        self updateErrors: TestResult new.
        self updateFailures: TestResult new.
        self displayPassFail: passFailString.
        self displayDetails: '...'! !

"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TextModel) methodsFor: 'notification' !
update: anAspect

	anAspect == aspect
		ifTrue: [view model: (model perform: aspect)]! !

"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TextView) methodsFor: 'accessing' !
paint: p <Paint>

	self painter paint: p! !

"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'notificaition' !
visualAllocated
Transcript show: 'allocated'.
	self refreshWindow! !

"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'notificaition' !
visualAllocated

"	self refreshWindow"! !

"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: (testList
																														naturalHeight: 300;
																														naturalWidth: 150;
																														yStretchy: true;
																														xStretchy: true;
																														yourself) with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: passFailText imbeddedVisual with3DBorder)
																			with: (textEqualizer for: detailsText imbeddedVisual with3DBorder)
																			with: (textEqualizer for: resultsRow)).
	self refreshWindow.
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 8, 2008 -> 18:33:37"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
errorColor
        ^ Paint red! !

"June 8, 2008 -> 18:33:45"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
failColor
        ^ Paint yellow! !

"June 8, 2008 -> 18:37:5"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updateWindow: aTestResult
        aTestResult hasPassed
                ifTrue: [self updatePartColors: self passColor]
                ifFalse: [aTestResult hasErrors
									ifTrue: [self updatePartColors: self errorColor]
									ifFalse: [self updatePartColors: self failColor]].
        self updatePassFail: aTestResult.
        self updateDetails: aTestResult.
        self updateFailures: aTestResult.
        self updateErrors: aTestResult! !

"June 8, 2008 -> 18:41:57"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
passColor
        ^ Paint green! !

"June 8, 2008 -> 23:20:0"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
frameWithBorderAndBackdrop: visual

	^(visual with3DBorder)
			backdrop: (Painter new);
			yourself! !

"June 8, 2008 -> 23:21:35"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: (testList
																														naturalHeight: 300;
																														naturalWidth: 150;
																														yStretchy: true;
																														xStretchy: true;
																														yourself) with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: (self frameWithBorderAndBackDrop: passFailText imbeddedVisual))
																			with: (textEqualizer for: (self frameWithBorderAndBackDrop: detailsText imbeddedVisual))
																			with: (textEqualizer for: resultsRow)).
	self refreshWindow.
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 8, 2008 -> 23:24:59"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updatePartColors: aColor

	passFailText visual backgroundPainter paint: aColor.
	detailsText visual backgroundPainter paint: aColor! !

"June 8, 2008 -> 23:25:56"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: (testList
																														naturalHeight: 300;
																														naturalWidth: 150;
																														yStretchy: true;
																														xStretchy: true;
																														yourself) with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: passFailText imbeddedVisual))
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: detailsText imbeddedVisual))
																			with: (textEqualizer for: resultsRow)).
	self refreshWindow.
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 8, 2008 -> 23:28:31"!

! (Delta mirrorFor: #TextModel) methodsFor: 'initialization' !
on: aModel aspect: anAspect

	view := TextView forString.
	view
		isMultiLine: true;
		model: '';
		paint: Paint black.
	model := aModel.
	aspect := anAspect.
	model addDependent: self.
	^view! !

"June 8, 2008 -> 23:31:31"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshWindow: passFailString

        self updatePartColors: Paint white.
        self updateErrors: TestResult new.
        self updateFailures: TestResult new.
        self displayPassFail: passFailString.
        self displayDetails: '...'! !

"June 8, 2008 -> 23:40:41"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
buildTests

	^(TestCase allSubclasses collect: [:each | each name])
			asSortedCollection:[:a :b| a asString <= b asString]! !

"June 8, 2008 -> 23:40:54"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshTests

        tests := self buildTests.
        self changed: #tests.
        testSuite := nil.
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.
        self changed: #selectedFailureTest.             "added rew"
        self changed: #selectedErrorTest.               "added rew"
        self changed: #selectedSuite.
        self refreshWindow! !

"June 8, 2008 -> 23:41:6"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := self buildTests.
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 8, 2008 -> 23:42:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: (testList
																														naturalHeight: 300;
																														naturalWidth: 150;
																														yStretchy: true;
																														xStretchy: true;
																														yourself) with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: passFailText imbeddedVisual))
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: detailsText imbeddedVisual))
																			with: (textEqualizer for: resultsRow)).
	self updateAll.
	self refreshWindow.
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 8, 2008 -> 23:44:4"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updateAll

	self changed: #selectedFailureTest.
	self changed: #selectedErrorTest.
	self changed: #selectedSuite.
	self refreshWindow! !

"June 8, 2008 -> 23:44:55"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updateAll

	self changed: #tests.
	self changed: #details.
	self changed: #passFail.
	self refreshWindow! !

"June 8, 2008 -> 23:49:55"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: (testList
																														"naturalHeight: 300;
																														naturalWidth: 150;
																														yStretchy: true;
																														xStretchy: true;"
																														yourself) with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: passFailText imbeddedVisual))
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: detailsText imbeddedVisual))
																			with: (textEqualizer for: resultsRow)).
	self updateAll.
	self refreshWindow.
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 8, 2008 -> 23:53:32"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: testList with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: passFailText imbeddedVisual))
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: detailsText imbeddedVisual))
																			with: (textEqualizer for: resultsRow)).
	self updateAll.
	self refreshWindow.
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 9, 2008 -> 0:1:58"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList errorsList failuresList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	failuresList := ListModel
									on: self
									items: #failuresList
									selected: #selectedFailureTest
									select: #debugFailureTest:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: testList with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: passFailText imbeddedVisual))
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: detailsText imbeddedVisual))
																			with: (textEqualizer for: resultsRow)).
	self updateAll.
	self refreshWindow.
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 9, 2008 -> 0:2:41"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList errorsList failuresList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	failuresList := ListModel
									on: self
									items: #failuresList
									selected: #selectedFailureTest
									select: #debugFailureTest:.
	errorsList := ListModel
									on: self
									items: #errorsList
									selected: #selectedErrorTest
									select: #debugErrorTest:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: testList with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: passFailText imbeddedVisual))
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: detailsText imbeddedVisual))
																			with: (textEqualizer for: resultsRow)).
	self updateAll.
	self refreshWindow.
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 9, 2008 -> 0:9:11"!

! (Delta mirrorFor: #ListModel) methodsFor: 'initialization' !
on: aModel items: selector selected: accessor select: mutator

	view := ListBox forSingleSelection.
	model := aModel.
	model addDependent: self.
	itemAspect := selector.
	selectionAspect := accessor.
	view painter: (Painter new font: (Font forSpec: (FontSpec new points: 81; typeface: 'Times Roman')); yourself)
	view onSelChange: [:lb | aModel	
														perform: mutator
														with: lb selections anElement].
	^view
	! !

"June 9, 2008 -> 0:9:34"!

! (Delta mirrorFor: #ListModel) methodsFor: 'initialization' !
on: aModel items: selector selected: accessor select: mutator

	view := ListBox forSingleSelection.
	model := aModel.
	model addDependent: self.
	itemAspect := selector.
	selectionAspect := accessor.
	view painter: Painter new.
	view onSelChange: [:lb | aModel	
														perform: mutator
														with: lb selections anElement].
	^view
	! !

"June 9, 2008 -> 0:20:35"!

! (Delta mirrorFor: #ListModel) methodsFor: 'initialization' !
on: aModel items: selector selected: accessor select: mutator

	view := ListBox forSingleSelection.
	model := aModel.
	model addDependent: self.
	itemAspect := selector.
	selectionAspect := accessor.
	view onSelChange: [:lb | aModel	
														perform: mutator
														with: lb selections anElement].
	^view
	! !

"June 9, 2008 -> 0:22:9"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList errorsList failuresList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	testList painter font: self font.
	failuresList := ListModel
									on: self
									items: #failuresList
									selected: #selectedFailureTest
									select: #debugFailureTest:.
	errorsList := ListModel
									on: self
									items: #errorsList
									selected: #selectedErrorTest
									select: #debugErrorTest:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: testList with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: passFailText imbeddedVisual))
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: detailsText imbeddedVisual))
																			with: (textEqualizer for: resultsRow)).
	self updateAll.
	self refreshWindow.
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 9, 2008 -> 0:22:33"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
font

	^Font forSpec: (FontSpec new points: 8; typeface: 'Times Roman')! !

"June 9, 2008 -> 0:28:34"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList errorsList failuresList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	failuresList := ListModel
									on: self
									items: #failuresList
									selected: #selectedFailureTest
									select: #debugFailureTest:.
	errorsList := ListModel
									on: self
									items: #errorsList
									selected: #selectedErrorTest
									select: #debugErrorTest:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: testList with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: passFailText imbeddedVisual))
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: detailsText imbeddedVisual))
																			with: (textEqualizer for: resultsRow)).
	self updateAll.
	self refreshWindow.
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 9, 2008 -> 0:30:49"!

! (Delta mirrorFor: #TestRunner) classSide methodsFor: 'instance creation' !
open
	"TestRunner open"
        ^super new launch! !

"June 9, 2008 -> 0:31:17"!

! (Delta mirrorFor: #TestRunner) classSide methodsFor: 'instance creation' !
open
	"(TestRunner open)"
        ^super new launch! !

"June 9, 2008 -> 0:32:59"!

! (Delta mirrorFor: #HaltTest) methodsFor: 'Testing' !
testShouldBeResumable

	self deny: Halt new isResumable! !

"June 9, 2008 -> 0:35:12"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList errorsList failuresList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	failuresList := ListModel
									on: self
									items: #failuresList
									selected: #selectedFailureTest
									select: #debugFailureTest:.
	errorsList := ListModel
									on: self
									items: #errorsList
									selected: #selectedErrorTest
									select: #debugErrorTest:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: testList with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: failuresList with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: errorsList with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: passFailText imbeddedVisual))
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: detailsText imbeddedVisual))
																			with: (textEqualizer for: resultsRow)).
	self updateAll.
	self refreshWindow.
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 9, 2008 -> 0:35:24"!

(Delta mirrorFor: #TestRunner)
comment: 
'(TestRunner open)'!


"June 9, 2008 -> 0:38:44"!

"System saved" !
"June 9, 2008 -> 0:39:34"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
debugFailureTest: anInteger

        (anInteger ~= 0)
                ifTrue: [[(self failures at: anInteger) debugAsFailure] fork].

        selectedFailureTest := anInteger.
        selectedErrorTest := 0.
        self changed: #selectedErrorTest.
        self changed: #selectedFailureTest! !

"June 9, 2008 -> 0:40:16"!

! (Delta mirrorFor: #HaltTest) methodsFor: 'Testing' !
testShouldBeResumable

	self assert: Halt new isResumable! !

"June 9, 2008 -> 0:41:8"!

! (Delta mirrorFor: #HaltTest) methodsFor: 'Testing' !
testShouldBeResumable

	self deny: Halt new isResumable! !

"June 9, 2008 -> 0:41:24"!

! (Delta mirrorFor: #HaltTest) methodsFor: 'Testing' !
testShouldBeResumable
	self halt.
	self deny: Halt new isResumable! !

"June 9, 2008 -> 0:41:43"!

! (Delta mirrorFor: #HaltTest) methodsFor: 'Testing' !
testShouldBeResumable

	self assert: Halt new isResumable! !

"June 9, 2008 -> 0:43:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[[aTestCase runCase.
			true]
				sunitOn: self class failure
				do: [:signal |
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
									self errors add: aTestCase.
									signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"June 9, 2008 -> 0:44:29"!

"System saved" !
"June 9, 2008 -> 0:47:16"!

(Delta mirrorFor: #TestRunner) removeMethod: #oldbuildBareVisualTop: ifAbsent: [] !


"June 9, 2008 -> 0:47:19"!

(Delta mirrorFor: #TestRunner) removeMethod: #openAsMorph ifAbsent: [] !


"June 9, 2008 -> 0:47:49"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList errorsList failuresList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	failuresList := ListModel
									on: self
									items: #failuresList
									selected: #selectedFailureTest
									select: #debugFailureTest:.
	errorsList := ListModel
									on: self
									items: #errorsList
									selected: #selectedErrorTest
									select: #debugErrorTest:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: testList with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: failuresList with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: errorsList with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: passFailText imbeddedVisual))
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: detailsText imbeddedVisual))
																			with: (textEqualizer for: resultsRow)).
	self updateAll.
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 9, 2008 -> 0:48:2"!

(Delta mirrorFor: #TestRunner) removeMethod: #listbox ifAbsent: [] !


"June 9, 2008 -> 0:48:20"!

(Delta mirrorFor: #TestRunner) removeMethod: #resetColor ifAbsent: [] !


"June 9, 2008 -> 0:48:31"!

(Delta mirrorFor: #TestRunner) removeMethod: #runButtonColor ifAbsent: [] !


"June 9, 2008 -> 0:48:52"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
refreshButtonLabel
        ^ 'Refresh'! !

"June 9, 2008 -> 0:49:2"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
runButtonLabel
        ^ 'Run All'! !

"June 9, 2008 -> 0:49:10"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
runOneButtonLabel
        ^ 'Run'! !

"June 9, 2008 -> 0:51:28"!

(Delta mirrorFor: #TestRunner)
comment: 
'Test runner for SUnit tests. To launch doit on the following:-

	(TestRunner open)'!


"June 9, 2008 -> 0:53:22"!

"System saved" !
"June 10, 2008 -> 10:12:46"!

Delta define: #DoesNotUnderstandFixture as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 10, 2008 -> 10:13:40"!

! (Delta mirrorFor: #DoesNotUnderstandFixture) methodsFor: 'error handling' !
doesNotUnderstand: message

	^message! !

"June 10, 2008 -> 10:14:7"!

"System saved" !
"June 11, 2008 -> 21:31:27"!

! (Delta mirrorFor: #DoesNotUnderstandFixture) methodsFor: 'dnu triggers' !
dnuTrigger1

	^self quack! !

"June 11, 2008 -> 21:31:45"!

"System saved" !
"June 14, 2008 -> 22:4:38"!

Delta define: #DoesNotUnderstandTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 14, 2008 -> 22:7:41"!

! (Delta mirrorFor: #DoesNotUnderstandTest) methodsFor: 'Testing' !
testUnknownMethodReturnsResultFromDoesNotUnderstand

	| message |
	message := DoesNotUnderstandFixture new zork.
	self assert: #zork == message selector
			description: 'Wrong selector returned'! !

"June 14, 2008 -> 22:8:20"!

! (Delta mirrorFor: #DoesNotUnderstandTest) methodsFor: 'Testing' !
testUnknownNoArgMethodReturnsResultFromDoesNotUnderstand

	| message |
	message := DoesNotUnderstandFixture new zork.
	self assert: #zork == message selector
			description: 'Wrong selector returned'! !

"June 14, 2008 -> 22:8:34"!

! (Delta mirrorFor: #DoesNotUnderstandTest) methodsFor: 'Testing' !
testUnknownOneArgMethodReturnsResultFromDoesNotUnderstand

	| message |
	message := DoesNotUnderstandFixture new zork.
	self assert: #zork == message selector
			description: 'Wrong selector returned'! !

"June 14, 2008 -> 22:8:37"!

(Delta mirrorFor: #DoesNotUnderstandTest) removeMethod: #testUnknownMethodReturnsResultFromDoesNotUnderstand ifAbsent: [] !


"June 14, 2008 -> 22:9:17"!

! (Delta mirrorFor: #DoesNotUnderstandTest) methodsFor: 'Testing' !
testUnknownNoArgMethodReturnsResultFromDoesNotUnderstand

	| message |
	message := DoesNotUnderstandFixture new zork: 1.
	self assert: #zork: == message selector
			description: 'Wrong selector returned'.
	self assert: 1 == message args size
			description: 'Wrong number of args'! !

"June 14, 2008 -> 22:9:49"!

! (Delta mirrorFor: #DoesNotUnderstandTest) methodsFor: 'Testing' !
testUnknownNoArgMethodReturnsResultFromDoesNotUnderstand

	| message |
	message := DoesNotUnderstandFixture new zork: 1.
	self assert: #zork: == message selector
			description: 'Wrong selector returned'.
	self assert: 1 == message arguments size
			description: 'Wrong number of arguments'! !

"June 14, 2008 -> 22:10:25"!

! (Delta mirrorFor: #DoesNotUnderstandTest) methodsFor: 'Testing' !
testUnknownNoArgMethodReturnsResultFromDoesNotUnderstand

	| message |
	message := DoesNotUnderstandFixture new zork: 1.
	self assert: #zork: == message selector
			description: 'Wrong selector returned'.
	self assert: 1 == message arguments size
			description: 'Wrong number of arguments'.
	self assert: 1 == message arguments first
			description: 'Wrong argument returned'! !

"June 14, 2008 -> 22:15:43"!

"System saved" !
"June 15, 2008 -> 18:9:0"!

Delta define: #BlockNLRTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 15, 2008 -> 18:10:49"!

! (Delta mirrorFor: #BlockNLRTest) methodsFor: 'Testing' !
testNLRResult

	100000 timesRepeat: [
		self assert: 1 = (self nlrWith: 1)
				description: 'Should have returned 1']! !

"June 15, 2008 -> 18:12:16"!

! (Delta mirrorFor: #BlockNLRTest) methodsFor: 'Testing' !
nlrWith: value

	self doWith: [^value].
	^2 * value! !

"June 15, 2008 -> 18:12:37"!

! (Delta mirrorFor: #BlockNLRTest) methodsFor: 'Testing' !
doWith: block

	^block value! !

"June 15, 2008 -> 18:14:2"!

! (Delta mirrorFor: #BlockNLRTest) methodsFor: 'Testing' !
testNLRResult

	1000000 timesRepeat: [
		self assert: 1 = (self nlrWith: 1)
				description: 'Should have returned 1']! !

"June 15, 2008 -> 18:14:12"!

! (Delta mirrorFor: #BlockNLRTest) methodsFor: 'Testing' !
testNLRResult

	10000000 timesRepeat: [
		self assert: 1 = (self nlrWith: 1)
				description: 'Should have returned 1']! !

"June 15, 2008 -> 18:15:46"!

! (Delta mirrorFor: #BlockNLRTest) methodsFor: 'Testing' !
testNLRResult

	100000000 timesRepeat: [
		self assert: 1 = (self nlrWith: 1)
				description: 'Should have returned 1']! !

"June 15, 2008 -> 18:16:42"!

"System saved" !
"June 17, 2008 -> 1:14:5"!

! (Delta mirrorFor: #BlockNLRTest) methodsFor: 'Testing' !
nlrWith: value with: boolean

	self doWith: [boolean ifTrue: [^value].
							3 * value].
	^2 * value! !

"June 17, 2008 -> 1:14:5"!

! (Delta mirrorFor: #BlockNLRTest) methodsFor: 'Testing' !
testNLRResult

	100000000 timesRepeat: [
		self assert: 1 = (self nlrWith: 1 with: true)
				description: 'Should have returned 1']! !

"June 17, 2008 -> 1:14:5"!

! (Delta mirrorFor: #BlockNLRTest) methodsFor: 'Testing' !
testNLRResult

	100000000 timesRepeat: [
		| result |
		result := (self nlrWith: 1 with: true).
		self assert: 1 = result
				description: 'Should have returned 1, but was: ', result printString]! !

"June 17, 2008 -> 1:14:36"!

! (Delta mirrorFor: #BlockNLRTest) methodsFor: 'Testing' !
testNLRResult

	10000 timesRepeat: [
		| result |
		result := (self nlrWith: 1 with: true).
		self assert: 1 = result
				description: 'Should have returned 1, but was: ', result printString]! !

"June 17, 2008 -> 1:16:18"!

! (Delta mirrorFor: #BlockNLRTest) methodsFor: 'Testing' !
testNLRResult

	100000 timesRepeat: [
		| result |
		result := (self nlrWith: 1 with: true).
		self assert: 1 = result
				description: 'Should have returned 1, but was: ', result printString]! !

"June 17, 2008 -> 1:16:29"!

! (Delta mirrorFor: #BlockNLRTest) methodsFor: 'Testing' !
testNLRResult

	1000000 timesRepeat: [
		| result |
		result := (self nlrWith: 1 with: true).
		self assert: 1 = result
				description: 'Should have returned 1, but was: ', result printString]! !

"June 17, 2008 -> 1:17:1"!

"System saved" !
"August 17, 2008 -> 19:16:42"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
safePrintString: aValue

	[^aValue printString]
		on: Error
		do: [^'Cannot print instance of ', aValue class name]! !

"August 17, 2008 -> 19:16:42"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
safePrintString: aValue

	^[aValue printString]
		on: Error
		do: ['Cannot print instance of ', aValue class name]! !

"August 17, 2008 -> 19:16:42"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
safePrintString: aValue

	^[aValue printString]
		on: Error
		do: ['Cannot print instance of ', aValue class name]! !

"August 17, 2008 -> 19:16:42"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildClosedHeader ^ <Visual>

	| selector <Symbol> args <Array[Object]> row <Row[Visual]> |
	
	"Check type of activation"
	self activation isSmalltalk
		ifFalse: [	^(StringGlyph for: 'External activation' painter: self codePainter) asVisual ].

	selector := self activation method enclosingMethod selector.
	args := self activation arguments.
	row := Row[Visual] new.
	
	self activation method isBlockMethod
		ifTrue: [		"Add block parens interspersed with arguments"
							row add: (StringGlyph for: '[' painter: self codePainter) asVisual.
							args do: [ :arg <Object> |
								row add: (StringGlyph for: ':' painter: self selectorPainter) asVisual.
								row add: (self
									buildLabel: (self safePrintString: arg)
									painter: self codePainter
									action: [ (Inspector on: arg) launch ]) ].
							row add: (StringGlyph for: '] in ' painter: self codePainter) asVisual.
							row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
		ifFalse: [	"Add receiver"
							| receiver <Object> |
							receiver := self activation receiver.
							row add: (self
								buildLabel: receiver printString 
								painter: self codePainter
								action: [ (Inspector on: receiver) launch ]).
							row add: (StringGlyph for: '>> ' painter: self codePainter) asVisual.
							"Add selector interspersed with arguments"
							args size = 0
								ifTrue: [		row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
								ifFalse: [	| strm <CharacterReadStream> |
													strm := selector readStream.
													args do: [ :arg <Object> |
														row add: (StringGlyph for: (strm upTo: $:), ':' painter: self selectorPainter) asVisual.
														row add: (self
															buildLabel: arg printString 
															painter: self codePainter
															action: [ (Inspector on: arg) launch ]) ]
												]
						].
	^row! !

"August 17, 2008 -> 19:16:42"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildClosedHeader ^ <Visual>

	| selector <Symbol> args <Array[Object]> row <Row[Visual]> |
	
	"Check type of activation"
	self activation isSmalltalk
		ifFalse: [	^(StringGlyph for: 'External activation' painter: self codePainter) asVisual ].

	selector := self activation method enclosingMethod selector.
	args := self activation arguments.
	row := Row[Visual] new.
	
	self activation method isBlockMethod
		ifTrue: [		"Add block parens interspersed with arguments"
							row add: (StringGlyph for: '[' painter: self codePainter) asVisual.
							args do: [ :arg <Object> |
								row add: (StringGlyph for: ':' painter: self selectorPainter) asVisual.
								row add: (self
									buildLabel: (self safePrintString: arg)
									painter: self codePainter
									action: [ (Inspector on: arg) launch ]) ].
							row add: (StringGlyph for: '] in ' painter: self codePainter) asVisual.
							row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
		ifFalse: [	"Add receiver"
							| receiver <Object> |
							receiver := self activation receiver.
							row add: (self
								buildLabel: (self safePrintString: receiver)
								painter: self codePainter
								action: [ (Inspector on: receiver) launch ]).
							row add: (StringGlyph for: '>> ' painter: self codePainter) asVisual.
							"Add selector interspersed with arguments"
							args size = 0
								ifTrue: [		row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
								ifFalse: [	| strm <CharacterReadStream> |
													strm := selector readStream.
													args do: [ :arg <Object> |
														row add: (StringGlyph for: (strm upTo: $:), ':' painter: self selectorPainter) asVisual.
														row add: (self
															buildLabel: (self safePrintString: arg)
															painter: self codePainter
															action: [ (Inspector on: arg) launch ]) ]
												]
						].
	^row! !

"August 17, 2008 -> 19:16:42"!

! (Delta mirrorFor: #Test) methodsFor: 'test' !
printString

^1 + 'a'! !

"August 17, 2008 -> 19:16:42"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
safePrintString: aValue

	^[aValue printString]
		on: Error
		do: ['Cannot print instance of ', aValue class name]! !

"August 17, 2008 -> 19:16:42"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildClosedHeader ^ <Visual>

	| selector <Symbol> args <Array[Object]> row <Row[Visual]> |
	
	"Check type of activation"
	self activation isSmalltalk
		ifFalse: [	^(StringGlyph for: 'External activation' painter: self codePainter) asVisual ].

	selector := self activation method enclosingMethod selector.
	args := self activation arguments.
	row := Row[Visual] new.
	
	self activation method isBlockMethod
		ifTrue: [		"Add block parens interspersed with arguments"
							row add: (StringGlyph for: '[' painter: self codePainter) asVisual.
							args do: [ :arg <Object> |
								row add: (StringGlyph for: ':' painter: self selectorPainter) asVisual.
								row add: (self
									buildLabel: (self safePrintString: arg)
									painter: self codePainter
									action: [ (Inspector on: arg) launch ]) ].
							row add: (StringGlyph for: '] in ' painter: self codePainter) asVisual.
							row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
		ifFalse: [	"Add receiver"
							| receiver <Object> |
							receiver := self activation receiver.
							row add: (self
								buildLabel: (self safePrintString: receiver)
								painter: self codePainter
								action: [ (Inspector on: receiver) launch ]).
							row add: (StringGlyph for: '>> ' painter: self codePainter) asVisual.
							"Add selector interspersed with arguments"
							args size = 0
								ifTrue: [		row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
								ifFalse: [	| strm <CharacterReadStream> |
													strm := selector readStream.
													args do: [ :arg <Object> |
														row add: (StringGlyph for: (strm upTo: $:), ':' painter: self selectorPainter) asVisual.
														row add: (self
															buildLabel: (self safePrintString: arg)
															painter: self codePainter
															action: [ (Inspector on: arg) launch ]) ]
												]
						].
	^row! !

"August 17, 2008 -> 19:16:42"!

! (Delta mirrorFor: #Test) methodsFor: 'test' !
printString

^1 + 'a'! !

"August 17, 2008 -> 19:16:42"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
safePrintString: aValue

	^[aValue printString]
		on: Error
		do: [:ex|'Cannot print instance of ', aValue class name]! !

"August 17, 2008 -> 19:16:42"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
safePrintString: aValue

	^[aValue printString]
		on: Error
		do: [:ex|'instance of ', aValue class name]! !

"August 17, 2008 -> 19:16:42"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
safePrintString: aValue

	^[aValue printString]
		on: Error
		do: [:ex|'??instance of ', aValue class name]! !

"August 17, 2008 -> 19:16:42"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
safePrintString: aValue

	[^aValue printString]
		on: Error
		do: [^'Cannot print instance of ', aValue class name]! !

"August 17, 2008 -> 19:16:42"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
safePrintString: aValue

	^[aValue printString]
		on: Error
		do: ['Cannot print instance of ', aValue class name]! !

"August 17, 2008 -> 19:16:42"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
safePrintString: aValue

	^[aValue printString]
		on: Error
		do: ['Cannot print instance of ', aValue class name]! !

"August 17, 2008 -> 19:16:43"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildClosedHeader ^ <Visual>

	| selector <Symbol> args <Array[Object]> row <Row[Visual]> |
	
	"Check type of activation"
	self activation isSmalltalk
		ifFalse: [	^(StringGlyph for: 'External activation' painter: self codePainter) asVisual ].

	selector := self activation method enclosingMethod selector.
	args := self activation arguments.
	row := Row[Visual] new.
	
	self activation method isBlockMethod
		ifTrue: [		"Add block parens interspersed with arguments"
							row add: (StringGlyph for: '[' painter: self codePainter) asVisual.
							args do: [ :arg <Object> |
								row add: (StringGlyph for: ':' painter: self selectorPainter) asVisual.
								row add: (self
									buildLabel: (self safePrintString: arg)
									painter: self codePainter
									action: [ (Inspector on: arg) launch ]) ].
							row add: (StringGlyph for: '] in ' painter: self codePainter) asVisual.
							row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
		ifFalse: [	"Add receiver"
							| receiver <Object> |
							receiver := self activation receiver.
							row add: (self
								buildLabel: receiver printString 
								painter: self codePainter
								action: [ (Inspector on: receiver) launch ]).
							row add: (StringGlyph for: '>> ' painter: self codePainter) asVisual.
							"Add selector interspersed with arguments"
							args size = 0
								ifTrue: [		row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
								ifFalse: [	| strm <CharacterReadStream> |
													strm := selector readStream.
													args do: [ :arg <Object> |
														row add: (StringGlyph for: (strm upTo: $:), ':' painter: self selectorPainter) asVisual.
														row add: (self
															buildLabel: arg printString 
															painter: self codePainter
															action: [ (Inspector on: arg) launch ]) ]
												]
						].
	^row! !

"August 17, 2008 -> 19:16:43"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildClosedHeader ^ <Visual>

	| selector <Symbol> args <Array[Object]> row <Row[Visual]> |
	
	"Check type of activation"
	self activation isSmalltalk
		ifFalse: [	^(StringGlyph for: 'External activation' painter: self codePainter) asVisual ].

	selector := self activation method enclosingMethod selector.
	args := self activation arguments.
	row := Row[Visual] new.
	
	self activation method isBlockMethod
		ifTrue: [		"Add block parens interspersed with arguments"
							row add: (StringGlyph for: '[' painter: self codePainter) asVisual.
							args do: [ :arg <Object> |
								row add: (StringGlyph for: ':' painter: self selectorPainter) asVisual.
								row add: (self
									buildLabel: (self safePrintString: arg)
									painter: self codePainter
									action: [ (Inspector on: arg) launch ]) ].
							row add: (StringGlyph for: '] in ' painter: self codePainter) asVisual.
							row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
		ifFalse: [	"Add receiver"
							| receiver <Object> |
							receiver := self activation receiver.
							row add: (self
								buildLabel: (self safePrintString: receiver)
								painter: self codePainter
								action: [ (Inspector on: receiver) launch ]).
							row add: (StringGlyph for: '>> ' painter: self codePainter) asVisual.
							"Add selector interspersed with arguments"
							args size = 0
								ifTrue: [		row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
								ifFalse: [	| strm <CharacterReadStream> |
													strm := selector readStream.
													args do: [ :arg <Object> |
														row add: (StringGlyph for: (strm upTo: $:), ':' painter: self selectorPainter) asVisual.
														row add: (self
															buildLabel: (self safePrintString: arg)
															painter: self codePainter
															action: [ (Inspector on: arg) launch ]) ]
												]
						].
	^row! !

"August 17, 2008 -> 19:16:43"!

! (Delta mirrorFor: #Test) methodsFor: 'test' !
printString

^1 + 'a'! !

"August 17, 2008 -> 19:16:43"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
safePrintString: aValue

	^[aValue printString]
		on: Error
		do: ['Cannot print instance of ', aValue class name]! !

"August 17, 2008 -> 19:16:43"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildClosedHeader ^ <Visual>

	| selector <Symbol> args <Array[Object]> row <Row[Visual]> |
	
	"Check type of activation"
	self activation isSmalltalk
		ifFalse: [	^(StringGlyph for: 'External activation' painter: self codePainter) asVisual ].

	selector := self activation method enclosingMethod selector.
	args := self activation arguments.
	row := Row[Visual] new.
	
	self activation method isBlockMethod
		ifTrue: [		"Add block parens interspersed with arguments"
							row add: (StringGlyph for: '[' painter: self codePainter) asVisual.
							args do: [ :arg <Object> |
								row add: (StringGlyph for: ':' painter: self selectorPainter) asVisual.
								row add: (self
									buildLabel: (self safePrintString: arg)
									painter: self codePainter
									action: [ (Inspector on: arg) launch ]) ].
							row add: (StringGlyph for: '] in ' painter: self codePainter) asVisual.
							row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
		ifFalse: [	"Add receiver"
							| receiver <Object> |
							receiver := self activation receiver.
							row add: (self
								buildLabel: (self safePrintString: receiver)
								painter: self codePainter
								action: [ (Inspector on: receiver) launch ]).
							row add: (StringGlyph for: '>> ' painter: self codePainter) asVisual.
							"Add selector interspersed with arguments"
							args size = 0
								ifTrue: [		row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
								ifFalse: [	| strm <CharacterReadStream> |
													strm := selector readStream.
													args do: [ :arg <Object> |
														row add: (StringGlyph for: (strm upTo: $:), ':' painter: self selectorPainter) asVisual.
														row add: (self
															buildLabel: (self safePrintString: arg)
															painter: self codePainter
															action: [ (Inspector on: arg) launch ]) ]
												]
						].
	^row! !

"August 17, 2008 -> 19:16:43"!

! (Delta mirrorFor: #Test) methodsFor: 'test' !
printString

^1 + 'a'! !

"August 17, 2008 -> 19:16:43"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
safePrintString: aValue

	^[aValue printString]
		on: Error
		do: [:ex|'Cannot print instance of ', aValue class name]! !

"August 17, 2008 -> 19:16:43"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
safePrintString: aValue

	^[aValue printString]
		on: Error
		do: [:ex|'instance of ', aValue class name]! !

"August 17, 2008 -> 19:16:43"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
safePrintString: aValue

	^[aValue printString]
		on: Error
		do: [:ex|'??instance of ', aValue class name]! !

"August 17, 2008 -> 19:16:43"!

! (Delta mirrorFor: #Test) methodsFor: 'test' !
blockReturn

	|sem|
	sem := Semaphore new.
	[sem signal.
	^nil] fork.
	sem wait! !

"August 17, 2008 -> 19:16:43"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'accessing' !
windowTitle ^ <Str>

	self process processError isNil ifTrue: [^''].
	^self process processError name! !

"August 17, 2008 -> 19:16:43"!

! (Delta mirrorFor: #Test) methodsFor: 'test' !
blockReturn
	[^nil] fork.
	Processor yield! !

"August 17, 2008 -> 19:17:6"!

"System saved" !
"August 24, 2008 -> 9:31:53"!

! (Delta mirrorFor: #Planner) classSide methodsFor: 'add/remove' !
incrementalRemove: c
	"Entry point for retracting a constraint. Remove the given constraint and incrementally update the 
	dataflow graph."
	"Details: Retracting the given constraint may allow some currently unsatisfiable downstream 
	constraint be satisfied. We thus collect a list of unsatisfied downstream constraints and attempt 
	to satisfy each one in turn. This list is sorted by constraint strength, strongest first, as a heuristic 
	for avoiding unnecessarily adding and then overriding weak constraints."
	"Assume: c is satisfied."

	| out unsatisfied |
	out := c output.
	c markUnsatisfied.
	c removeFromGraph.
	unsatisfied := self removePropagateFrom: out.
	unsatisfied do: [: u | self incrementalAdd: u].! !

"August 24, 2008 -> 9:31:56"!

! (Delta mirrorFor: #Planner) classSide methodsFor: 'add/remove' !
incrementalAdd: c
	"Attempt to satisfy the given constraint and, if successful, incrementally update the dataflow graph."
	"Details: If satifying the constraint is successful, it may override a weaker constraint on its output. 
	The algorithm attempts to resatisfy that constraint using some other method. This process is 
	repeated until either a) it reaches a variable that was not previously determined by any constraint 
	or b) it reaches a constraint that is too weak to be satisfied using any of its methods. The variables 
	of constraints that have been processed are marked with a unique mark value so that we know 
	where we've been. This allows the algorithm to avoid getting into an infinite loop even if the 
	constraint graph has an inadvertent cycle."

	| mark overridden |
	mark := self newMark.
	overridden := c satisfy: mark.
	[overridden == nil] whileFalse:
		[overridden := overridden satisfy: mark].! !

"August 24, 2008 -> 9:46:39"!

"System saved" !
"August 25, 2008 -> 0:32:21"!

! (Delta mirrorFor: #Behavior) methodsFor: 'private' !
primitiveNew ^<Object>

	^{{self primitiveNewIfFail: [ :err <Symbol> | 
		Transcript show: err.
		VM scavengeGarbage.
		{{self primitiveNewIfFail: [:err2<Symbol> |
			Transcript show: err.
			VM collectGarbage.
			{{self primitiveNewIfFail: [:err3 <Symbol> |
				]}}
			]}}
			"can't happen"
		]}}! !

"August 25, 2008 -> 0:32:41"!

! (Delta mirrorFor: #Behavior) methodsFor: 'private' !
primitiveNew ^<Object>

	^{{self primitiveNewIfFail: [ :err <Symbol> | 
		Transcript show: err.
		VM scavengeGarbage.
		{{self primitiveNewIfFail: [:err2<Symbol> |
			Transcript show: err.
			VM collectGarbage.
			{{self primitiveNewIfFail: [:err3 <Symbol> |
				"need to expand memory here"
				]}}
			]}}
			"can't happen"
		]}}! !

"August 25, 2008 -> 0:34:15"!

! (Delta mirrorFor: #Behavior) methodsFor: 'private' !
primitiveNew ^<Object>

	^{{self primitiveNewIfFail: [ :err <Symbol> | 
		Transcript show: err.
		VM scavengeGarbage.
		{{self primitiveNewIfFail: [:err2<Symbol> |
			Transcript show: err.
			VM collectGarbage.
			{{self primitiveNewIfFail: [:err3 <Symbol> |
				"need to expand memory here"
				]}}
			]}}
		]}}! !

"August 25, 2008 -> 0:36:14"!

"System saved" !
"August 25, 2008 -> 0:44:37"!

! (Delta mirrorFor: #Behavior) methodsFor: 'private' !
primitiveNew ^<Object>

	^{{self primitiveNewIfFail: [ :err <Symbol> | 
		Transcript show: err.
		VM scavengeGarbage.
		{{self primitiveNewIfFail: [:err2<Symbol> |
			Transcript show: err2.
			VM collectGarbage.
			{{self primitiveNewIfFail: [:err3 <Symbol> |
				"need to expand memory here"
				]}}
			]}}
		]}}! !

"August 25, 2008 -> 0:45:31"!

"System saved" !
"August 26, 2008 -> 13:8:9"!

! (Delta mirrorFor: #Behavior) methodsFor: 'private' !
primitiveNew ^<Object>

	^{{self primitiveNew2IfFail: [ :err <Symbol> | 
		Transcript show: err.
		VM scavengeGarbage.
		{{self primitiveNew2IfFail: [:err2<Symbol> |
			Transcript show: err2.
			VM collectGarbage.
			{{self primitiveNew2IfFail: [:err3 <Symbol> |
				"need to expand memory here"
				]}}
			]}}
		]}}! !

"August 26, 2008 -> 13:12:7"!

"System saved" !
"August 26, 2008 -> 13:18:2"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'instance creation' !
new ^<Instance>
	"Create and return an initialized instance of this class."

	"%remove when inlining working:"
	^{{self primitiveNew2IfFail: [ :err <Symbol> | 
		Transcript show: err.
		VM scavengeGarbage.
		{{self primitiveNew2IfFail: [:err2<Symbol> |
			Transcript show: err2.
			VM collectGarbage.
			{{self primitiveNew2IfFail: [:err3 <Symbol> |
				"need to expand memory here"
				]}}
			]}}
		]}}
"
	^guaranteed <Instance> (super new)
"! !

"August 26, 2008 -> 13:29:57"!

"System saved" !
"August 26, 2008 -> 13:45:44"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'instance creation' !
new ^<Instance>
	"Create and return an initialized instance of this class."

	"%remove when inlining working:"
	^{{self primitiveNew2IfFail: [ :err <Symbol> | 
		VM scavengeGarbage.
		{{self primitiveNew2IfFail: [:err2<Symbol> |
			Transcript show: err2.
			VM collectGarbage.
			{{self primitiveNew2IfFail: [:err3 <Symbol> |
				"need to expand memory here"
				]}}
			]}}
		]}}
"
	^guaranteed <Instance> (super new)
"! !

"August 26, 2008 -> 14:40:35"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'instance creation' !
new ^<Instance>
	"Create and return an initialized instance of this class."

	"%remove when inlining working:"
	^{{self primitiveNewIfFail: [ :err <Symbol> | 
		VM scavengeGarbage.
		{{self primitiveNewIfFail: [:err2<Symbol> |
			Transcript show: err2.
			VM collectGarbage.
			{{self primitiveNewIfFail: [:err3 <Symbol> |
				"need to expand memory here"
				]}}
			]}}
		]}}
"
	^guaranteed <Instance> (super new)
"! !

"August 26, 2008 -> 14:40:48"!

! (Delta mirrorFor: #Behavior) methodsFor: 'private' !
primitiveNew ^<Object>

	^{{self primitiveNewIfFail: [ :err <Symbol> | 
		Transcript show: err.
		VM scavengeGarbage.
		{{self primitiveNewIfFail: [:err2<Symbol> |
			Transcript show: err2.
			VM collectGarbage.
			{{self primitiveNewIfFail: [:err3 <Symbol> |
				"need to expand memory here"
				]}}
			]}}
		]}}! !

"August 26, 2008 -> 14:41:38"!

! (Delta mirrorFor: #Behavior) methodsFor: 'private' !
primitiveNew ^<Object>

	^{{self primitiveNewIfFail: [ :err <Symbol> | 
		VM scavengeGarbage.
		{{self primitiveNewIfFail: [:err2<Symbol> |
			Transcript show: err2.
			VM collectGarbage.
			{{self primitiveNewIfFail: [:err3 <Symbol> |
				"need to expand memory here"
				]}}
			]}}
		]}}! !

"August 26, 2008 -> 16:47:54"!

"System saved" !
"August 27, 2008 -> 13:25:53"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
expand: size

	{{primitiveExpandMemory: (size * self oopSize)}}! !

"August 27, 2008 -> 13:26:25"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private' !
oopSize

	^{{primitiveOopSize}}! !

"August 27, 2008 -> 13:35:11"!

"System saved" !
"August 28, 2008 -> 9:35:0"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private' !
oopSize
self halt.
	^{{primitiveOopSize}}! !

"August 28, 2008 -> 9:35:54"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private' !
oopSize

	^{{primitiveOopSize}}! !

"August 28, 2008 -> 9:36:45"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private' !
oopSize

	^{{self primitiveOopSize}}! !

"August 28, 2008 -> 9:37:35"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private' !
oopSize

	^{{primitiveOopSize}}! !

"August 28, 2008 -> 12:50:18"!

"System saved" !
"August 28, 2008 -> 15:37:37"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private' !
oopSize

	^{{primitiveSizeOfOop}}! !

"August 28, 2008 -> 15:38:9"!

"System saved" !
"August 28, 2008 -> 15:51:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
deferredGC

	[self collectGarbage] fork! !

"August 28, 2008 -> 15:51:22"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore') !


"August 28, 2008 -> 15:53:25"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
deferredGC

	GCSemaphore := Semaphore new.
	[self collectGarbage.
	GCSemaphore signal] fork! !

"August 28, 2008 -> 16:8:4"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
waitForGC

	GCSemaphore isNil
		ifTrue: [self deferredGC]
		ifFalse:[GCSemaphore wait.
					GCSemaphore := nil]! !

"August 28, 2008 -> 16:17:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
isGCPending

	^GCSemaphore notNil! !

"August 28, 2008 -> 16:45:57"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'instance creation' !
new ^<Instance>
	"Create and return an initialized instance of this class."

	"%remove when inlining working:"
	^{{self primitiveNewIfFail: [ :err <Symbol> | 
		VM scavengeGarbage.
		{{self primitiveNewIfFail: [:err2<Symbol> |
			VM isGCPending
				ifTrue: [VM waitForGC.
							{{self primitiveNewIfFail: [:err3 <Symbol> |
								VM expand: (VMMirror on: self) instanceSize.
								VM deferredGC.
								{{self primitiveNewIfFail: [:err3 <Symbol> |
																"should not happen"]}}]}}]
				ifFalse: [VM expand: (VMMirror on: self) instanceSize.
							VM deferredGC.
							{{self primitiveNewIfFail: [:err3 <Symbol> |
																"should not happen"]}}].
			]}}
		]}}
"
	^guaranteed <Instance> (super new)
"! !

"August 28, 2008 -> 16:54:13"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'instance creation' !
new ^<Instance>
	"Create and return an initialized instance of this class."

	"%remove when inlining working:"
	^{{self primitiveNewIfFail: [ :err <Symbol> | 
		VM scavengeGarbage.
		{{self primitiveNewIfFail: [:err <Symbol> |
			VM isGCPending
				ifTrue: [VM waitForGC.
							{{self primitiveNewIfFail: [:err <Symbol> |
								VM expand: (VMMirror on: self) instanceSize.
								VM deferredGC.
								{{self primitiveNewIfFail: [:err <Symbol> |
																"should not happen"]}}]}}]
				ifFalse: [VM expand: (VMMirror on: self) instanceSize.
							VM deferredGC.
							{{self primitiveNewIfFail: [:err <Symbol> |
																"should not happen"]}}].
			]}}
		]}}
"
	^guaranteed <Instance> (super new)
"! !

"August 28, 2008 -> 17:5:51"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'instance creation' !
new ^<Instance>
	"Create and return an initialized instance of this class."

	"%remove when inlining working:"
	^{{self primitiveNewIfFail: [ :err <Symbol> | 
		VM scavengeGarbage.
		{{self primitiveNewIfFail: [:err <Symbol> |
			VM isGCPending
				ifTrue: [VM waitForGC.
							{{self primitiveNewIfFail: [:err <Symbol> |
								VM expand: (VMMirror on: self) instanceSize.
								VM deferredGC.
								{{self primitiveNewIfFail: [:err <Symbol> |
																		self error: err]}}]}}]
				ifFalse: [VM expand: (VMMirror on: self) instanceSize.
							VM deferredGC.
							{{self primitiveNewIfFail: [:err <Symbol> |
																	self error: err]}}].
			]}}
		]}}
"
	^guaranteed <Instance> (super new)
"! !

"August 28, 2008 -> 17:17:14"!

! (Delta mirrorFor: #IndexedInstanceVariables) classSide methodsFor: 'private' !
primitiveNew: size <Int> ^<Instance>

	^{{self primitiveIndexedObjectNew: size
			ifFail: [ :err <Symbol> |
					VM scavengeGarbage.
					{{self primitiveIndexedObjectNew: size
							ifFail: [ :err <Symbol> |
									VM isGCPending
										ifTrue: [VM waitForGC.
													{{self primitiveIndexedObjectNew: size
															ifFail: [:err <Symbol> |
																	VM expand: (VMMirror on: self) instanceSize + size.
																	VM deferredGC.
																	{{self primitiveIndexedObjectNew: size
																			ifFail: [:err <Symbol> |
																						self error: err]}}]}}]
										ifFalse: [VM expand: (VMMirror on: self) instanceSize + size.
													VM deferredGC.
													{{self primitiveIndexedObjectNew: size
															ifFail: [:err <Symbol> |
																	self error: err]}}]
						]}}
				]}}! !

"August 28, 2008 -> 18:0:1"!

"System saved" !
"August 28, 2008 -> 18:49:8"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'instance creation' !
new ^<Instance>
	"Create and return an initialized instance of this class."

	"%remove when inlining working:"
	^{{self primitiveNewIfFail: [ :err <Symbol> | 
		VM scavengeGarbage.
		{{self primitiveNewIfFail: [:err <Symbol> |
			Transcript show: err; cr.
			VM isGCPending
				ifTrue: [VM waitForGC.
							{{self primitiveNewIfFail: [:err <Symbol> |
								VM expand: (VMMirror on: self) instanceSize.
								VM deferredGC.
								{{self primitiveNewIfFail: [:err <Symbol> |
																		self error: err]}}]}}]
				ifFalse: [VM expand: (VMMirror on: self) instanceSize.
							VM deferredGC.
							{{self primitiveNewIfFail: [:err <Symbol> |
																	self error: err]}}].
			]}}
		]}}
"
	^guaranteed <Instance> (super new)
"! !

"August 28, 2008 -> 18:49:8"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'instance creation' !
new ^<Instance>
	"Create and return an initialized instance of this class."

	"%remove when inlining working:"
	^{{self primitiveNewIfFail: [ :err <Symbol> |
		Transcript show: err; cr.
		VM scavengeGarbage.
		{{self primitiveNewIfFail: [:err <Symbol> |
			Transcript show: err; cr.
			VM isGCPending
				ifTrue: [VM waitForGC.
							{{self primitiveNewIfFail: [:err <Symbol> |
								VM expand: (VMMirror on: self) instanceSize.
								VM deferredGC.
								{{self primitiveNewIfFail: [:err <Symbol> |
																		self error: err]}}]}}]
				ifFalse: [VM expand: (VMMirror on: self) instanceSize.
							VM deferredGC.
							{{self primitiveNewIfFail: [:err <Symbol> |
																	self error: err]}}].
			]}}
		]}}
"
	^guaranteed <Instance> (super new)
"! !

"August 28, 2008 -> 18:49:8"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'instance creation' !
new ^<Instance>
	"Create and return an initialized instance of this class."

	"%remove when inlining working:"
	^{{self primitiveNewIfFail: [ :err <Symbol> |
		VM scavengeGarbage.
		{{self primitiveNewIfFail: [:err <Symbol> |
			Transcript show: err; cr.
			VM isGCPending
				ifTrue: [VM waitForGC.
							{{self primitiveNewIfFail: [:err <Symbol> |
								VM expand: (VMMirror on: self) instanceSize.
								VM deferredGC.
								{{self primitiveNewIfFail: [:err <Symbol> |
																		self error: err]}}]}}]
				ifFalse: [VM expand: (VMMirror on: self) instanceSize.
							VM deferredGC.
							{{self primitiveNewIfFail: [:err <Symbol> |
																	self error: err]}}].
			]}}
		]}}
"
	^guaranteed <Instance> (super new)
"! !

"August 28, 2008 -> 19:24:12"!

"System saved" !
"September 8, 2008 -> 9:45:44"!

! (Delta mirrorFor: #RichardsBenchmarks) classSide methodsFor: 'instance creation' !
loop

	|start elapsed count|
start := Time millisecondClockValue.
count := 0.
[(elapsed := Time millisecondClockValue - start) < 1000]
	whileTrue: [
		self new run.
		count := count + 1].
elapsed * 1000.0/ count printOn: Transcript cr; yourself! !

"September 8, 2008 -> 9:45:57"!

"System saved" !
"September 24, 2008 -> 1:24:11"!

Delta define: #SequenceableCollectionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"September 24, 2008 -> 1:24:12"!

! (Delta mirrorFor: #SequenceableCollectionTest) methodsFor: 'testing' !
testIsSortedBy


	self shouldnt: [#(1 5 3) isSortedBy: [:a :b| a < b]].
	self should: [#(1 3 5) isSortedBy: [:a :b| a < b]]! !

"September 24, 2008 -> 1:24:12"!

! (Delta mirrorFor: #SequenceableCollectionTest) methodsFor: 'testing' !
testIsSortedBy


	"self shouldnt: [#(1 5 3) isSortedBy: [:a :b| a < b]]."
	self should: [#(1 3 5) isSortedBy: [:a :b| a < b]]! !

"September 24, 2008 -> 1:24:12"!

! (Delta mirrorFor: #SequenceableCollectionTest) methodsFor: 'testing' !
testIsSortedBy


	self shouldnt: [#(1 5 3) isSortedBy: [:a :b| a < b]].
	self should: [#(1 3 5) isSortedBy: [:a :b| a < b]]! !

"September 24, 2008 -> 1:24:12"!

! (Delta mirrorFor: #SequenceableCollection) methodsFor: 'testing' !
isSortedBy: compare <[E,E,^Boolean]> ^<Boolean>
	"Returns true if the receiver is in sorted order, using the specified comparison"

	| last <E> |
	self size < 2
		ifTrue: [ ^true ].
	last := self at: 1.
	2 to: self size do:
		[ :i <Int> | |current|
			(compare value: last value: (current := self at: i))
				ifFalse: [ ^false ].
			last := current].
	^true! !

"September 24, 2008 -> 1:24:12"!

Delta define: #SortedCollectionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"September 24, 2008 -> 1:24:12"!

! (Delta mirrorFor: #SortedCollectionTest) methodsFor: 'testing' !
testSortedCollection
	|r c s index|
	r := Random new.
	1 to: 500 do:
		[:j|	c := Array[Int] new: j.
			1 to: j do:
				[ :i <Int> |
					c at: i put: (r next * (SmallInteger maxVal - 1)) asInteger	].
			"Transcript show: 'c size = '; print: c size; cr."
			self should: [ (c asSortedCollection: [ :i1 <Int> :i2 <Int> | i1 <= i2 ]) isSorted ]].! !

"September 24, 2008 -> 1:24:12"!

! (Delta mirrorFor: #SortedCollectionTest) methodsFor: 'testing' !
testSortedCollection
	|r c s index|
	r := Random new.
	1 to: 500 do:
		[:j|	c := Array[Int] new: j.
			1 to: j do:
				[ :i <Int> |
					c at: i put: (r next * (SmallInteger maxVal - 1)) asInteger	].
			"Transcript show: 'c size = '; print: c size; cr."
			self should: [ (c asSortedCollection: [ :i1 <Int> :i2 <Int> | i1 <= i2 ]) isSorted ]
				description: 'collection should be sorted'].! !

"September 24, 2008 -> 1:24:12"!

! (Delta mirrorFor: #SortedCollectionTest) methodsFor: 'testing' !
testSortedCollection
	|r c s index|
	r := Random new.
	1 to: 500 do:
		[:j|	c := Array[Int] new: j.
			1 to: j do:
				[ :i <Int> |
					c at: i put: (r next * (SmallInteger maxVal - 1)) asInteger	].
			"Transcript show: 'c size = '; print: c size; cr."
			self shouldnt: [ (c asSortedCollection: [ :i1 <Int> :i2 <Int> | i1 <= i2 ]) isSorted ]
				description: 'collection should be sorted'].! !

"September 24, 2008 -> 1:24:12"!

! (Delta mirrorFor: #SortedCollectionTest) methodsFor: 'testing' !
testSortedCollection
	|r c s index|
	r := Random new.
	1 to: 500 do:
		[:j|	c := Array[Int] new: j.
			1 to: j do:
				[ :i <Int> |
					c at: i put: (r next * (SmallInteger maxVal - 1)) asInteger	].
			"Transcript show: 'c size = '; print: c size; cr."
			self should: [ (c asSortedCollection: [ :i1 <Int> :i2 <Int> | i1 <= i2 ]) isSorted ]
				description: 'collection should be sorted'].! !

"September 24, 2008 -> 1:24:12"!

! (Delta mirrorFor: #SortedCollectionTest) methodsFor: 'testing' !
testSortSimpleCollection

	self should: [#(5 3 1) asSortedCollection asArray = #(1 3 5)]! !

"September 24, 2008 -> 1:24:12"!

! (Delta mirrorFor: #SortedCollectionTest) methodsFor: 'testing' !
testSortSimpleCollection

	self should: [#(5 3 1) asSortedCollection asArray = #(1 3 5)].
	self should: [#(1 3 5) asSortedCollection asArray = #(1 3 5)].
	self should: [#(1 5 3) asSortedCollection asArray = #(1 3 5)].! !

"September 24, 2008 -> 1:24:12"!

! (Delta mirrorFor: #SortedCollectionTest) methodsFor: 'testing' !
testSortSimpleCollection

	self should: [#(5 3 1) asSortedCollection asArray = #(1 3 5)].
	self should: [#(1 3 5) asSortedCollection asArray = #(1 3 5)].
	self should: [#(1 5 3) asSortedCollection asArray = #(1 3 5)].
	self should: [#(1 2 1)asSortedCollection asArray = #(1 1 2)].! !

"September 24, 2008 -> 1:24:12"!

! (Delta mirrorFor: #SortedCollectionTest) methodsFor: 'testing' !
testSortSimpleCollection

	self should: [#(5 3 1) asSortedCollection asArray = #(1 3 5)].
	self should: [#(1 3 5) asSortedCollection asArray = #(1 3 5)].
	self should: [#(1 5 3) asSortedCollection asArray = #(1 3 5)].
	self should: [#(1 2 1)asSortedCollection asArray = #(1 1 2)].
	self should: [#(1 2 1 2)asSortedCollection asArray = #(1 1 2 2)].! !

"September 24, 2008 -> 1:38:52"!

"System saved" !
"September 25, 2008 -> 17:44:24"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: class ifFail: failureBlock

	^{{primitiveNew: class
			ifFail: [:e| failureBlock value: e]}}! !

"September 25, 2008 -> 17:44:24"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: class

	|allocateBlock|
	allocateBlock := [:failBlock| self new: class ifFail: failBlock].
	^allocateBlock
			value: [:e| self freeSpace > 2 * self survivorSpaceSize
									ifTrue: [self scavengeGarbage
														ifTrue: [self collectGarbage]
														ifFalse: [allocateBlock
																			value: [:e2| self collectGarbage]]]]
						! !

"September 25, 2008 -> 17:44:24"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
spaceToScavenge

	^self freeSpace > 2 * self survivorSpaceSize					! !

"September 25, 2008 -> 17:44:24"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: class

	|allocateBlock|
	allocateBlock := [:failBlock| self new: class ifFail: failBlock].
	^allocateBlock
			value: [:e| self spaceToScavenge
									ifTrue: [self scavengeGarbage
														ifTrue: [self collectGarbage]
														ifFalse: [allocateBlock
																			value: [:e2| self collectGarbage]]]]
						! !

"September 25, 2008 -> 17:44:24"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: class

	|allocateBlock|
	allocateBlock := [:failBlock| self new: class ifFail: failBlock].
	^allocateBlock
			value: [:e| self spaceToScavenge
									ifTrue: [self scavengeAndAllocate: allocateBlock]]! !

"September 25, 2008 -> 17:44:24"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
scavengeAndAllocate: allocateBlock

	^self scavengeGarbage
			ifTrue: [self collectGarbage.
							allocateBlock
								value: [:e| self expand.
													allocateBlock value: [:e2| self error: e2]]]
			ifFalse: [allocateBlock
								value: [:e3| self collectGarbage.
														allocateBlock
															value: [:e4| self expand.
																				allocateBlock value: [:e5| self error: e5]]]]! !

"September 25, 2008 -> 17:44:24"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
survivorSpaceSize

	^self smallIntegerAt: #SurvivorSize! !

"September 25, 2008 -> 17:44:24"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
freeSpace

	^{{freeSpace}}! !

"September 25, 2008 -> 17:44:24"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
spaceToScavenge

	^self freeSpace > (2 * self survivorSpaceSize)	! !

"September 25, 2008 -> 17:44:24"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'integer flags' !
survivorSpaceSize

	^(self smallIntegerAt: #SurvivorSize) * 1024! !

"September 25, 2008 -> 17:44:34"!

"System saved" !
"September 25, 2008 -> 17:44:57"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
freeSpace

	^{{primitiveFreeSpace}}! !

"September 25, 2008 -> 17:49:9"!

"System saved" !
"September 27, 2008 -> 15:22:51"!

! (Delta mirrorFor: #Method) methodsFor: 'debugging' !
debugInfo

	^{{self primitiveMethodDebugInfo}}! !

"September 27, 2008 -> 15:24:31"!

(Delta mirrorFor: #Method) removeMethod: #debugInfo ifAbsent: [] !


"September 28, 2008 -> 21:33:34"!

"System saved" !
"October 12, 2008 -> 14:14:14"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
scavengeAndAllocate: allocateBlock

	|expansions|
	expansions := {{primitiveExpansions}}
	self scavengeGarbage.
	^(expansions ~~ {{primitiveExpansions}})
			ifTrue: [self collectGarbage.
							allocateBlock
								value: [:e| self expand.
													allocateBlock value: [:e2| self error: e2]]]
			ifFalse: [allocateBlock
								value: [:e3| self collectGarbage.
														allocateBlock
															value: [:e4| self expand.
																				allocateBlock value: [:e5| self error: e5]]]]! !

"October 12, 2008 -> 15:26:25"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: class

	|allocateBlock|
	allocateBlock := [:failBlock| self new: class ifFail: failBlock].
	^allocateBlock
			value: [:e| e == #FailedAllocation
									ifTrue: [self spaceToScavenge
														ifTrue: [self scavengeAndAllocate: allocateBlock]]
									ifFalse: [self error: e]]! !

"October 12, 2008 -> 15:29:31"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
scavengeAndAllocate: allocateBlock

	|expansions|
	expansions := {{primitiveExpansions}}
	self scavengeGarbage.
	^(expansions ~~ {{primitiveExpansions}})
			ifTrue: [self collectGarbage.
							allocateBlock
								value: [:e| 
												self expand.
												allocateBlock value: [:e2| self error: e2]]]
			ifFalse: [allocateBlock
								value: [:e3|
												self collectGarbage.
												allocateBlock
													value: [:e4|
																	self expand.
																	allocateBlock value: [:e5| self error: e5]]]]! !

"October 12, 2008 -> 15:31:58"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
expand

	|expansionSize|
	expansionSize := (self smallIntegerAt: #ObjectHeapExpandSize) * self K.
	{{primitiveExpand: expansionSize}}! !

"October 12, 2008 -> 15:36:17"!

"System saved" !
"October 12, 2008 -> 16:47:45"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: class

	|allocateBlock|
	allocateBlock := [:failBlock| self new: class ifFail: failBlock].
	^allocateBlock
			value: [:e| e == #FailedAllocation
									ifTrue: [self spaceToScavenge
														ifTrue: [self scavengeAndAllocate: allocateBlock]]
									ifFalse: [nil error: e]]! !

"October 12, 2008 -> 16:48:5"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
scavengeAndAllocate: allocateBlock

	|expansions|
	expansions := {{primitiveExpansions}}
	self scavengeGarbage.
	^(expansions ~~ {{primitiveExpansions}})
			ifTrue: [self collectGarbage.
							allocateBlock
								value: [:e| 
												self expand.
												allocateBlock value: [:e2| nil error: e2]]]
			ifFalse: [allocateBlock
								value: [:e3|
												self collectGarbage.
												allocateBlock
													value: [:e4|
																	self expand.
																	allocateBlock value: [:e5| nil error: e5]]]]! !

"October 12, 2008 -> 17:5:47"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
K

	^1024! !

"October 12, 2008 -> 17:6:44"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
expand

	|expansionSize|
	expansionSize := (self smallIntegerAt: #ObjectHeapExpandSize) * self K.
	{{primitiveExpandMemory: expansionSize}}! !

"October 12, 2008 -> 17:46:8"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
hasExpandedBlock
	|expansions|
	expansions := {{primitiveExpansions}}.
	^[expansions ~~ {{primitiveExpansions}}]! !

"October 12, 2008 -> 17:47:16"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
scavengeAndAllocate: allocateBlock

	|hasExpanded|
	hasExpanded := self hasExpandedBlock.
	self scavengeGarbage.
	^hasExpanded value
			ifTrue: [self collectGarbage.
							allocateBlock
								value: [:e| 
												self expand.
												allocateBlock value: [:e2| nil error: e2]]]
			ifFalse: [allocateBlock
								value: [:e3|
												self collectGarbage.
												allocateBlock
													value: [:e4|
																	self expand.
																	allocateBlock value: [:e5| nil error: e5]]]]! !

"October 12, 2008 -> 17:50:52"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
collectAndAllocated: allocateBlock

	^self collectGarbage.
	allocateBlock
		value: [:e| 
						self expand.
						allocateBlock value: [:e2| nil error: e2]]! !

"October 12, 2008 -> 17:52:15"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
scavengeAndAllocate: allocateBlock

	|hasExpanded|
	hasExpanded := self hasExpandedBlock.
	self scavengeGarbage.
	^hasExpanded value
			ifTrue: [self collectAndAllocate: allocateBlock]
			ifFalse: [allocateBlock
								value: [:e3| self collectAndAllocate: allocateBlock]]! !

"October 12, 2008 -> 17:54:27"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: class

	|allocateBlock|
	allocateBlock := [:failBlock| self new: class ifFail: failBlock].
	^allocateBlock
			value: [:e| e == #FailedAllocation
									ifTrue: [self spaceToScavenge
														ifTrue: [self scavengeAndAllocate: allocateBlock]
														ifFalse: [self collectAndAllocate: allocateBlock]]
									ifFalse: [nil error: e]]! !

"October 12, 2008 -> 17:55:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
scavengeAndAllocate: allocateBlock

	|hasExpandedBlock|
	hasExpandedBlock := self hasExpandedBlock.
	self scavengeGarbage.
	^hasExpandedBlock value
			ifTrue: [self collectAndAllocate: allocateBlock]
			ifFalse: [allocateBlock
								value: [:e3| self collectAndAllocate: allocateBlock]]! !

"October 12, 2008 -> 17:56:57"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
expand: expansionSize

	{{primitiveExpandMemory: expansionSize}}! !

"October 12, 2008 -> 17:57:11"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
expand

	|expansionSize|
	expansionSize := (self smallIntegerAt: #ObjectHeapExpandSize) * self K.
	self expand: expansionSize! !

"October 12, 2008 -> 17:58:13"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
scavengeAndAllocate: allocateBlock ifExpand: expansionBlock

	|hasExpandedBlock|
	hasExpandedBlock := self hasExpandedBlock.
	self scavengeGarbage.
	^hasExpandedBlock value
			ifTrue: [self collectAndAllocate: allocateBlock]
			ifFalse: [allocateBlock
								value: [:e3| self collectAndAllocate: allocateBlock]]! !

"October 12, 2008 -> 17:58:23"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
collectAndAllocate: allocateBlock

	^self collectGarbage.
	allocateBlock
		value: [:e| 
						self expand.
						allocateBlock value: [:e2| nil error: e2]]! !

"October 12, 2008 -> 17:58:26"!

(Delta mirrorFor: #VM) classSide removeMethod: #collectAndAllocated: ifAbsent: [] !


"October 12, 2008 -> 17:59:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
collectAndAllocate: allocateBlock ifExpand: expansionBlock

	^self collectGarbage.
	allocateBlock
		value: [:e| 
						expansionBlock value.
						allocateBlock value: [:e2| nil error: e2]]! !

"October 12, 2008 -> 17:59:51"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
scavengeAndAllocate: allocateBlock ifExpand: expansionBlock

	|hasExpandedBlock|
	hasExpandedBlock := self hasExpandedBlock.
	self scavengeGarbage.
	^hasExpandedBlock value
			ifTrue: [self collectAndAllocate: allocateBlock
								ifExpand: expansionBlock]
			ifFalse: [allocateBlock
								value: [:e3| self collectAndAllocate: allocateBlock
															ifExpand: expansionBlock]]! !

"October 12, 2008 -> 18:1:52"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: class

	|allocateBlock expansionBlock|
	allocateBlock := [:failBlock| self new: class ifFail: failBlock].
	expansionBlock := [self expand].
	^allocateBlock
			value: [:e| e == #FailedAllocation
									ifTrue: [self spaceToScavenge
														ifTrue: [self scavengeAndAllocate: allocateBlock
																			ifExpand: expansionBlock]
														ifFalse: [self collectAndAllocate: allocateBlock
																			ifExpand: expansionBlock]]
									ifFalse: [nil error: e]]! !

"October 12, 2008 -> 18:2:12"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
collectAndAllocate: allocateBlock ifExpand: expansionBlock

	self collectGarbage.
	^allocateBlock
		value: [:e| 
						expansionBlock value.
						allocateBlock value: [:e2| nil error: e2]]! !

"October 12, 2008 -> 18:2:48"!

(Delta mirrorFor: #VM) classSide removeMethod: #scavengeAndAllocate: ifAbsent: [] !


"October 12, 2008 -> 18:3:8"!

(Delta mirrorFor: #VM) classSide removeMethod: #collectAndAllocate: ifAbsent: [] !


"October 12, 2008 -> 18:4:26"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
allocate: allocateBlock ifExpand: expansionBlock

	^allocateBlock
			value: [:e| e == #FailedAllocation
									ifTrue: [self spaceToScavenge
														ifTrue: [self scavengeAndAllocate: allocateBlock
																			ifExpand: expansionBlock]
														ifFalse: [self collectAndAllocate: allocateBlock
																			ifExpand: expansionBlock]]
									ifFalse: [nil error: e]]! !

"October 12, 2008 -> 18:5:19"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: class

	|allocateBlock expansionBlock|
	allocateBlock := [:failBlock| self new: class ifFail: failBlock].
	expansionBlock := [self expand].
	^self allocate: allocateBlock ifExpand: expansionBlock! !

"October 12, 2008 -> 18:6:23"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: class

	^self allocate: [:failBlock| self new: class ifFail: failBlock]
			ifExpand: [self expand]! !

"October 12, 2008 -> 18:12:6"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
newBytes: byteClass size: size

	^self allocate: [:failBlock| self newBytes: byteClass size: size ifFail: failBlock]
			ifExpand: [self expand: size]! !

"October 12, 2008 -> 18:12:26"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
newBytes: class size: size ifFail: failureBlock

	^{{primitiveNew: class
			ifFail: [:e| failureBlock value: e]}}! !

"October 12, 2008 -> 18:13:16"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: indexableClass size: size

	^self allocate: [:failBlock| self new: indexableClass size: size ifFail: failBlock]
			ifExpand: [self expand: size]! !

"October 12, 2008 -> 18:13:26"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
new: class size: size ifFail: failureBlock

	^{{primitiveNew: class
			ifFail: [:e| failureBlock value: e]}}! !

"October 12, 2008 -> 18:23:47"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: indexableClass size: size

	^self allocate: [:failBlock|
								self new: indexableClass
										size: size
										ifFail: failBlock]
			ifExpand: [self expand: size]! !

"October 12, 2008 -> 18:24:3"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
newBytes: byteClass size: size

	^self allocate: [:failBlock|
								self newBytes: byteClass
										size: size
										ifFail: failBlock]
			ifExpand: [self expand: size]! !

"October 12, 2008 -> 18:24:26"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: indexableClass size: size

	^self allocate: [:failBlock|
								self new: indexableClass
										size: size
										ifFail: failBlock]
			ifExpand: [self expand: size / self oopSize]! !

"October 12, 2008 -> 18:43:36"!

"System saved" !
"October 12, 2008 -> 20:4:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
newBytes: class size: size ifFail: failureBlock

	^{{primitiveIndexedByteNew: class
			size: size
			ifFail: [:e| failureBlock value: e]}}! !

"October 12, 2008 -> 20:4:18"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: indexableClass size: size

	^self allocate: [:failBlock|
								self new: indexableClass
										size: size
										ifFail: failBlock]
			ifExpand: [self expand: size * self oopSize]! !

"October 12, 2008 -> 20:21:2"!

"System saved" !
"October 12, 2008 -> 23:38:45"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
newBytes: byteClass size: size

	^self allocate: [:failBlock :tenured|
								self newBytes: byteClass
										size: size
										tenured: tenured
										ifFail: failBlock]
			ifExpand: [self expand: size]! !

"October 12, 2008 -> 23:39:12"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
newBytes: class size: size tenured: tenured ifFail: failureBlock

	^{{primitiveIndexedByteNew: class
			size: size
			tenured: tenured
			ifFail: [:e| failureBlock value: e]}}! !

"October 12, 2008 -> 23:40:7"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
allocate: allocateBlock ifExpand: expansionBlock

	^allocateBlock
			value: false
			value: [:e| e == #FailedAllocation
									ifTrue: [self spaceToScavenge
														ifTrue: [self scavengeAndAllocate: allocateBlock
																			ifExpand: expansionBlock]
														ifFalse: [self collectAndAllocate: allocateBlock
																			ifExpand: expansionBlock]]
									ifFalse: [nil error: e]]! !

"October 12, 2008 -> 23:40:33"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
newBytes: byteClass size: size

	^self allocate: [:tenured :failBlock|
								self newBytes: byteClass
										size: size
										tenured: tenured
										ifFail: failBlock]
			ifExpand: [self expand: size]! !

"October 12, 2008 -> 23:40:41"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: indexableClass size: size

	^self allocate: [:tenured :failBlock|
								self new: indexableClass
										size: size
										ifFail: failBlock]
			ifExpand: [self expand: size * self oopSize]! !

"October 12, 2008 -> 23:43:23"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
scavengeAndAllocate: allocateBlock ifExpand: expansionBlock

	|hasExpandedBlock|
	hasExpandedBlock := self hasExpandedBlock.
	self scavengeGarbage.
	^hasExpandedBlock value
			ifTrue: [self collectAndAllocate: allocateBlock
								ifExpand: expansionBlock]
			ifFalse: [allocateBlock
								value: true
								value: [:e3| self collectAndAllocate: allocateBlock
															ifExpand: expansionBlock]]! !

"October 12, 2008 -> 23:43:48"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
collectAndAllocate: allocateBlock ifExpand: expansionBlock

	self collectGarbage.
	^allocateBlock
			value: true
			value: [:e| 
						expansionBlock value.
						allocateBlock value: true value: [:e2| nil error: e2]]! !

"October 12, 2008 -> 23:44:4"!

(Delta mirrorFor: #VM) classSide removeMethod: #newBytes:size:ifFail: ifAbsent: [] !


"October 12, 2008 -> 23:45:30"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
collectAndAllocate: allocateBlock ifExpand: expansionBlock

	self collectGarbage.
	^allocateBlock
			value: true
			value: [:e| 
						expansionBlock value.
						allocateBlock
							value: true
							value: [:e2| nil error: e2]]! !

"October 12, 2008 -> 23:45:55"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: class

	^self allocate: [:tenured :failBlock| self new: class ifFail: failBlock]
			ifExpand: [self expand]! !

"October 12, 2008 -> 23:46:28"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
allocate: allocateBlock ifExpand: expansionBlock

	^allocateBlock
			value: false
			value: [:e| e == #FailedAllocation
									ifTrue: [self spaceToScavenge
														ifTrue: [self scavengeAndAllocate: allocateBlock
																				ifExpand: expansionBlock]
														ifFalse: [self collectAndAllocate: allocateBlock
																				ifExpand: expansionBlock]]
									ifFalse: [nil error: e]]! !

"October 12, 2008 -> 23:51:0"!

"System saved" !
"October 16, 2008 -> 17:41:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
shrinkIfPossible

	self freeSpace > (self smallIntegerAt: #ObjectHeapExpandSize) * 3
		ifTrue: [|amountToShrink|
						amountToShrink := self freeSpace - ((self smallIntegerAt: #ObjectHeapExpandSize) * 3).
						self shrink: amountToShrink]! !

"October 16, 2008 -> 17:41:32"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
shrink: size

	{{primitiveShrinkMemory: size}}! !

"October 16, 2008 -> 17:42:26"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
collectAndAllocate: allocateBlock ifExpand: expansionBlock

	self collectGarbage.
	^[allocateBlock
			value: true
			value: [:e| 
						expansionBlock value.
						allocateBlock
							value: true
							value: [:e2| nil error: e2]]]
			ensure: [self shrinkIfPossible]! !

"October 16, 2008 -> 17:43:30"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
shrinkIfPossible

	self freeSpace > ((self smallIntegerAt: #ObjectHeapExpandSize) * 3)
		ifTrue: [|amountToShrink|
						amountToShrink := self freeSpace - ((self smallIntegerAt: #ObjectHeapExpandSize) * 3).
						self shrink: amountToShrink]! !

"October 16, 2008 -> 17:49:31"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
shrinkIfPossible

	self freeSpace > ((self smallIntegerAt: #ObjectHeapExpandSize) * 3)
		ifTrue: [|amountToShrink|
						amountToShrink := self freeSpace - ((self smallIntegerAt: #ObjectHeapExpandSize) * 3 * VM K).
						self shrink: amountToShrink]! !

"October 16, 2008 -> 17:50:4"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
shrinkBarrier

	^(self smallIntegerAt: #ObjectHeapExpandSize) * 3 * VM K! !

"October 16, 2008 -> 17:50:45"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
shrinkIfPossible

	self freeSpace > self shrinkBarrier
		ifTrue: [|amountToShrink|
						amountToShrink := self freeSpace - self shrinkBarrier.
						self shrink: amountToShrink]! !

"October 16, 2008 -> 17:53:7"!

"System saved" !
"October 17, 2008 -> 15:40:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
handleFailure: error allocate: allocateBlock ifExpand: expansionBlock

	^error == #FailedAllocation
			ifTrue: [self spaceToScavenge
								ifTrue: [self scavengeAndAllocate: allocateBlock
														ifExpand: expansionBlock]
								ifFalse: [self collectAndAllocate: allocateBlock
														ifExpand: expansionBlock]]
			ifFalse: [nil error: error]! !

"October 17, 2008 -> 15:40:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: class

	^{{primitiveNew: class
			ifFail: [:e| self handleFailure: e
									allocate: [:tenured :failBlock| self new: class ifFail: failBlock]
									ifExpand: [self expand]]}}! !

"October 17, 2008 -> 15:40:9"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore') !


"October 17, 2008 -> 15:40:9"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore') !


"October 17, 2008 -> 15:40:9"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore') !


"October 17, 2008 -> 15:40:9"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore') !


"October 17, 2008 -> 15:40:9"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore') !


"October 17, 2008 -> 15:40:9"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore') !


"October 17, 2008 -> 15:40:9"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore ScavengeCount') !


"October 17, 2008 -> 15:40:9"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore ScavengeCount') !


"October 17, 2008 -> 15:40:9"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore ScavengeCount') !


"October 17, 2008 -> 15:40:9"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore ScavengeCount') !


"October 17, 2008 -> 15:40:9"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore ScavengeCount') !


"October 17, 2008 -> 15:40:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
resetScavengeCount

	ScavengeCount := 0! !

"October 17, 2008 -> 15:40:9"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore ScavengeCount') !


"October 17, 2008 -> 15:40:9"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore ScavengeCount') !


"October 17, 2008 -> 15:40:9"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore ScavengeCount') !


"October 17, 2008 -> 15:40:9"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore ScavengeCount') !


"October 17, 2008 -> 15:40:9"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore ScavengeCount') !


"October 17, 2008 -> 15:40:9"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore ScavengeCount') !


"October 17, 2008 -> 15:40:9"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore ScavengeCount AllocFailureCount') !


"October 17, 2008 -> 15:40:9"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore ScavengeCount AllocFailureCount') !


"October 17, 2008 -> 15:40:9"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore ScavengeCount AllocFailureCount') !


"October 17, 2008 -> 15:40:9"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore ScavengeCount AllocFailureCount') !


"October 17, 2008 -> 15:40:9"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore ScavengeCount AllocFailureCount') !


"October 17, 2008 -> 15:40:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
resetAllocCounts

	ScavengeCount := 0.
	AllocFailureCount := 0.! !

"October 17, 2008 -> 15:40:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: class

	^{{primitiveNew: class
			ifFail: [:e|
						AllocFailureCount := AllocatFailureCount + 1.
						self handleFailure: e
								allocate: [:tenured :failBlock| self new: class ifFail: failBlock]
								ifExpand: [self expand]]}}! !

"October 17, 2008 -> 15:40:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: class

	^{{primitiveNew: class
			ifFail: [:e|
						AllocFailureCount := AllocFailureCount + 1.
						self handleFailure: e
								allocate: [:tenured :failBlock| self new: class ifFail: failBlock]
								ifExpand: [self expand]]}}! !

"October 17, 2008 -> 15:40:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
allocFailures

	^AllocFailureCount! !

"October 17, 2008 -> 15:40:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'profiling' !
resetProfiler
	{{primitiveFlatProfilerReset}}! !

"October 17, 2008 -> 15:40:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'profiling' !
engageProfiler

	{{primitiveFlatProfilerEngage: Processor activeProcess ifFail: [:e| nil error: e]}}.! !

"October 17, 2008 -> 15:40:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'profiling' !
disengageProfiler

	{{primitiveFlatProfilerDisengage}}.! !

"October 17, 2008 -> 15:40:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'profiling' !
printProfile

	{{primitiveFlatProfilerPrint}}! !

"October 17, 2008 -> 15:40:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'benchmarking' !
benchmarkNew: iterations

	|elapsed|
	self resetProfiler.
	self engageProfiler.
	elapsed := Time millisecondsToRun: [
								iterations timesRepeat: [
									Object new]].
	self disengageProfiler.
	self printProfile.
	Transcript cr; show: elapsed printString.! !

"October 17, 2008 -> 15:40:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'benchmarking' !
benchmarkNewNew: iterations

	|elapsed|
	self resetProfiler.
	self engageProfiler.
	elapsed := Time millisecondsToRun: [
								iterations timesRepeat: [
									VM new: Object]].
	self disengageProfiler.
	self printProfile.
	Transcript cr; show: elapsed printString.! !

"October 17, 2008 -> 15:40:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'benchmarking' !
benchmarkNewNew: iterations

	|elapsed|
	self resetProfiler.
	self engageProfiler.
	self resetAllocCounts.
	elapsed := Time millisecondsToRun: [
								iterations timesRepeat: [
									VM new: Object]].
	self disengageProfiler.
	self printProfile.
	Transcript cr; show: elapsed printString.
	Transcript cr; show: self allocFailures! !

"October 17, 2008 -> 15:40:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'benchmarking' !
benchmarkNewNew: iterations

	|elapsed|
	self resetProfiler.
	self engageProfiler.
	self resetAllocCounts.
	elapsed := Time millisecondsToRun: [
								iterations timesRepeat: [
									VM new: Object]].
	self disengageProfiler.
	self printProfile.
	Transcript cr; show: elapsed printString.
	Transcript cr; show: self allocFailures printString! !

"October 17, 2008 -> 15:40:9"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'instance creation' !
new2

	^{{primitiveNew: self
			ifFail: [:e|
						VM handleFailure: e
								allocate: [:tenured :failBlock| VM new: self ifFail: failBlock]
								ifExpand: [VM expand]]}}! !

"October 17, 2008 -> 15:40:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'benchmarking' !
benchmarkNewNew: iterations

	|elapsed|
	self resetProfiler.
	self engageProfiler.
	self resetAllocCounts.
	elapsed := Time millisecondsToRun: [
								iterations timesRepeat: [
									Object new2]].
	self disengageProfiler.
	self printProfile.
	Transcript cr; show: elapsed printString.
	Transcript cr; show: self allocFailures printString! !

"October 17, 2008 -> 15:40:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'benchmarking' !
benchmarkNewNew: iterations

	|elapsed|
	self resetProfiler.
	self engageProfiler.
	self resetAllocCounts.
	elapsed := Time millisecondsToRun: [
								iterations timesRepeat: [
									Object new2]].
	self disengageProfiler.
	self printProfile.
	Transcript cr; show: elapsed printString.
! !

"October 17, 2008 -> 15:40:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'benchmarking' !
benchmarkNewNew: iterations

	|elapsed|
	self resetProfiler.
	self engageProfiler.
	self resetAllocCounts.
	elapsed := Time millisecondsToRun: [
								iterations timesRepeat: [
									self new: Object]].
	self disengageProfiler.
	self printProfile.
	Transcript cr; show: elapsed printString.
! !

"October 17, 2008 -> 15:40:10"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'benchmarking' !
benchmarkNewNew: iterations

	|elapsed|
	self resetProfiler.
	self engageProfiler.
	self resetAllocCounts.
	elapsed := Time millisecondsToRun: [
								iterations timesRepeat: [
									self new: Object]].
	self disengageProfiler.
	self printProfile.
	Transcript cr; show: elapsed printString.
	Transcript cr; show: self allocFailures printString! !

"October 17, 2008 -> 15:40:10"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: class

	^{{primitiveNew: class
			ifFail: [:e|
						AllocFailureCount := AllocFailureCount + 1.
						VM handleFailure: e
								allocate: [:tenured :failBlock| VM new: class ifFail: failBlock]
								ifExpand: [VM expand]]}}! !

"October 17, 2008 -> 15:40:10"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'benchmarking' !
benchmarkNewNew: iterations

	|elapsed|
	self resetProfiler.
	self engageProfiler.
	self resetAllocCounts.
	elapsed := Time millisecondsToRun: [
								iterations timesRepeat: [
									VM new: Object]].
	self disengageProfiler.
	self printProfile.
	Transcript cr; show: elapsed printString.
	Transcript cr; show: self allocFailures printString! !

"October 17, 2008 -> 15:40:10"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'instance creation' !
new3 ^<Instance>
	"Create and return an initialized instance of this class."

	"%remove when inlining working:"
	^{{self primitiveNew2IfFail: [ :err <Symbol> |]}}
"
	^guaranteed <Instance> (super new)
"! !

"October 17, 2008 -> 15:40:10"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'benchmarking' !
benchmarkNew: iterations

	|elapsed|
	self resetProfiler.
	self engageProfiler.
	elapsed := Time millisecondsToRun: [
								iterations timesRepeat: [
									Object new3]].
	self disengageProfiler.
	self printProfile.
	Transcript cr; show: elapsed printString.! !

"October 17, 2008 -> 15:40:22"!

"System saved" !
"October 17, 2008 -> 22:39:8"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'benchmarking' !
privateBenchmarkNew: iterations

	iterations timesRepeat: [Object new3]! !

"October 17, 2008 -> 22:39:27"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'benchmarking' !
benchmarkNew: iterations

	|elapsed|
	self resetProfiler.
	self engageProfiler.
	elapsed := Time millisecondsToRun: [
								VM privateBenchmarkNew: iterations].
	self disengageProfiler.
	self printProfile.
	Transcript cr; show: elapsed printString.! !

"October 17, 2008 -> 22:39:53"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'benchmarking' !
privateBenchmarkNewNew: iterations

	iterations timesRepeat: [VM new: Object]! !

"October 17, 2008 -> 22:40:15"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'benchmarking' !
benchmarkNewNew: iterations

	|elapsed|
	self resetProfiler.
	self engageProfiler.
	self resetAllocCounts.
	elapsed := Time millisecondsToRun: [
								VM privateBenchmarkNewNew: iterations].
	self disengageProfiler.
	self printProfile.
	Transcript cr; show: elapsed printString.
	Transcript cr; show: self allocFailures printString! !

"October 17, 2008 -> 22:55:21"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'benchmarking' !
privateBenchmarkNewNew: iterations

	iterations timesRepeat: [VM new: Object]! !

"October 18, 2008 -> 12:45:20"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'benchmarking' !
privateBenchmarkNewNew: iterations

	iterations timesRepeat: [VM new: Object]! !

"October 18, 2008 -> 13:26:1"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'benchmarking' !
privateBenchmarkNewNew: iterations

	iterations timesRepeat: [VM new: Object]! !

"October 18, 2008 -> 14:47:39"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'benchmarking' !
privateBenchmarkNewNew: iterations

	iterations timesRepeat: [VM new: Object]! !

"October 18, 2008 -> 15:31:53"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
handleNew: class failure: error

	AllocFailureCount := AllocFailureCount + 1.
	^VM handleFailure: error
			allocate: [:tenured :failBlock| VM new: class ifFail: failBlock]
			ifExpand: [VM expand]! !

"October 18, 2008 -> 15:32:29"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: class

	^{{primitiveNew: class
			ifFail: [:e| VM handleNew: class failure: e]}}! !

"October 18, 2008 -> 16:56:6"!

"System saved" !
"October 26, 2008 -> 17:10:4"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
scavengeAndAllocate: allocateBlock ifExpand: expansionBlock

	|expansions |
	expansions := {{primitiveExpansions}}.
	self scavengeGarbage.
	^(expansions ~~ {{primitiveExpansions}})
			ifTrue: [self collectAndAllocate: allocateBlock
								ifExpand: expansionBlock]
			ifFalse: [allocateBlock
								value: true
								value: [:e3| self collectAndAllocate: allocateBlock
															ifExpand: expansionBlock]]! !

"October 26, 2008 -> 17:10:36"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
expansionCount

	^ {{primitiveExpansions}}! !

"October 26, 2008 -> 17:11:0"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
scavengeAndAllocate: allocateBlock ifExpand: expansionBlock

	|expansions |
	expansions := self expansionCount.
	self scavengeGarbage.
	^(expansions ~~ self expansionCount)
			ifTrue: [self collectAndAllocate: allocateBlock
								ifExpand: expansionBlock]
			ifFalse: [allocateBlock
								value: true
								value: [:e3| self collectAndAllocate: allocateBlock
															ifExpand: expansionBlock]]! !

"October 26, 2008 -> 17:14:35"!

"System saved" !
"October 26, 2008 -> 22:55:49"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
new: class tenured: tenured ifFail: failureBlock

	^{{primitiveNew: class
			tenured: tenured
			ifFail: [:e| failureBlock value: e]}}! !

"October 26, 2008 -> 22:55:49"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
handleNew: class failure: error

	AllocFailureCount := AllocFailureCount + 1.
	^VM handleFailure: error
			allocate: [:tenured :failBlock| VM new: class tenured: tenured ifFail: failBlock]
			ifExpand: [VM expand]! !

"October 26, 2008 -> 22:55:49"!

(Delta mirrorFor: #VM) classSide removeMethod: #hasExpandedBlock ifAbsent: [] !


"October 26, 2008 -> 22:55:49"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: class

	^{{primitiveNew: class
			tenured: false
			ifFail: [:e| VM handleNew: class failure: e]}}! !

"October 26, 2008 -> 22:55:49"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
scavengeAndAllocate: allocateBlock ifExpand: expansionBlock

	|expansions |
	expansions := self expansionCount.
	self scavengeGarbage.
	^(expansions ~~ self expansionCount)
			ifTrue: [self collectAndAllocate: allocateBlock
								ifExpand: expansionBlock]
			ifFalse: [allocateBlock
								value: false
								value: [:e3| self collectAndAllocate: allocateBlock
															ifExpand: expansionBlock]]! !

"October 26, 2008 -> 22:55:49"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
scavengeAndAllocate: allocateBlock ifExpand: expansionBlock

	|expansions |
	expansions := self expansionCount.
	self scavengeGarbage.
	^(expansions ~~ self expansionCount)
			ifTrue: [self collectAndAllocate: allocateBlock
								ifExpand: expansionBlock]
			ifFalse: [allocateBlock
								value: false
								value: [:e3| allocateBlock
															value: true
															value: [:e4| self collectAndAllocate: allocateBlock
																						ifExpand: expansionBlock]]]! !

"October 26, 2008 -> 22:55:49"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
reportNonAllocationFailure: errorSymbol

	(errorSymbol == #allocationFailure)
		ifFalse: [nil error: errorSymbol printString, ' reported during allocation']! !

"October 26, 2008 -> 22:55:50"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
scavengeAndAllocate: allocateBlock ifExpand: expansionBlock

	|expansions |
	expansions := self expansionCount.
	self scavengeGarbage.
	^(expansions ~~ self expansionCount)
			ifTrue: [self collectAndAllocate: allocateBlock
								ifExpand: expansionBlock]
			ifFalse: [allocateBlock
								value: false
								value: [:e1| self reportNonAllocationFailure: e1.
													allocateBlock
															value: true
															value: [:e2| self reportNonAllocationFailure: e2.
																				self collectAndAllocate: allocateBlock
																						ifExpand: expansionBlock]]]! !

"October 26, 2008 -> 22:55:50"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
collectAndAllocate: allocateBlock ifExpand: expansionBlock

	self collectGarbage.
	^[allocateBlock
			value: true
			value: [:e| 
						self reportNonAllocationFailure: e.
						expansionBlock value.
						allocateBlock
							value: true
							value: [:e2| nil error: e2]]]
			ensure: [self shrinkIfPossible]! !

"October 26, 2008 -> 22:55:50"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
collectAndAllocate: allocateBlock ifExpand: expansionBlock

	self collectGarbage.
	^[allocateBlock
			value: false
			value: [:e|
						self reportNonAllocationFailure: e.
						allocateBlock
							value: true
							value: [:e1|
										self reportNonAllocationFailure: e1.
										expansionBlock value.
										allocateBlock
											value: true
											value: [:e2| nil error: e2]]]]
			ensure: [self shrinkIfPossible]! !

"October 26, 2008 -> 22:55:50"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
allocate: allocateBlock ifExpand: expansionBlock

	^allocateBlock
			value: false
			value: [:e|
							self reportNonAllocationFailure: e.
							self spaceToScavenge
									ifTrue: [self scavengeAndAllocate: allocateBlock
															ifExpand: expansionBlock]
									ifFalse: [self collectAndAllocate: allocateBlock
															ifExpand: expansionBlock]]! !

"October 26, 2008 -> 22:55:50"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
handleFailure: error allocate: allocateBlock ifExpand: expansionBlock

	self reportNonAllocationFailure: error.
	self spaceToScavenge
				ifTrue: [self scavengeAndAllocate: allocateBlock
										ifExpand: expansionBlock]
				ifFalse: [self collectAndAllocate: allocateBlock
										ifExpand: expansionBlock]! !

"October 26, 2008 -> 22:55:50"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
reportNonAllocationFailure: errorSymbol

	(errorSymbol == #FailedAllocation)
		ifFalse: [nil error: errorSymbol printString, ' reported during allocation']! !

"October 26, 2008 -> 22:56:0"!

"System saved" !
"October 26, 2008 -> 23:6:39"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
handleNewBytes: class size: size failure: error

	AllocFailureCount := AllocFailureCount + 1.
	^VM handleFailure: error
			allocate: [:tenured :failBlock|
								VM newBytes: class
										size: size
										tenured: tenured
										ifFail: failBlock]
			ifExpand: [VM expand]! !

"October 26, 2008 -> 23:23:52"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
handleNewBytes: class size: size failure: error

	AllocFailureCount := AllocFailureCount + 1.
	^VM handleFailure: error
			allocate: [:tenured :failBlock|
								VM newBytes: class
										size: size
										tenured: tenured
										ifFail: failBlock]
			ifExpand: [VM expandBytes: class size: size]! !

"October 26, 2008 -> 23:35:50"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
expandBytes: class size: size

	|nonIndexableSizeInOops sizeInOops|
	nonIndexableSizeInOops := {{primitiveBehaviorNonIndexableSizeOf: class ifFail: [:err| nil error: err]}} + 1.
	self expand: (nonIndexableSizeInOops * self oopSize + size)! !

"October 26, 2008 -> 23:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
expandBytes: class size: size

	|nonIndexableSizeInOops|
	nonIndexableSizeInOops := {{primitiveBehaviorNonIndexableSizeOf: class ifFail: [:err| nil error: err]}} + 1.
	self expand: (nonIndexableSizeInOops * self oopSize + size)! !

"October 26, 2008 -> 23:39:50"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
expansionSize

	^(self smallIntegerAt: #ObjectHeapExpandSize) * self K! !

"October 27, 2008 -> 0:7:16"!

"System saved" !
"October 27, 2008 -> 0:44:44"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
new: class size: size tenured: tenured ifFail: failureBlock

	^{{primitiveIndexedObjectNew: class
			size: size
			tenured: tenured
			ifFail: [:e| failureBlock value: e]}}! !

"October 27, 2008 -> 0:44:56"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: indexableClass size: size

	^self allocate: [:tenured :failBlock|
								self new: indexableClass
										size: size
										tenured: tenured
										ifFail: failBlock]
			ifExpand: [self expand: size * self oopSize]! !

"October 27, 2008 -> 0:45:46"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
expand: class size: size

	|nonIndexableSizeInOops|
	nonIndexableSizeInOops := {{primitiveBehaviorNonIndexableSizeOf: class ifFail: [:err| nil error: err]}} + 1.
	self expand: (nonIndexableSizeInOops + size) * self oopSize! !

"October 27, 2008 -> 0:46:16"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: indexableClass size: size

	^self allocate: [:tenured :failBlock|
								self new: indexableClass
										size: size
										tenured: tenured
										ifFail: failBlock]
			ifExpand: [self expand: indexableClass size: size]! !

"October 27, 2008 -> 0:46:50"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
fixedSize: class

	^ {{primitiveBehaviorNonIndexableSizeOf: class ifFail: [:err| nil error: err]}} + 1! !

"October 27, 2008 -> 0:47:17"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
expand: class size: size

	|nonIndexableSizeInOops|
	nonIndexableSizeInOops := self fixedSize: class.
	self expand: (nonIndexableSizeInOops + size) * self oopSize! !

"October 27, 2008 -> 0:47:31"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
expandBytes: class size: size

	|nonIndexableSizeInOops|
	nonIndexableSizeInOops := self fixedSize: class.
	self expand: (nonIndexableSizeInOops * self oopSize + size)! !

"October 27, 2008 -> 1:0:17"!

"System saved" !
"October 27, 2008 -> 9:39:43"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
incFailureCount

	AllocFailureCount isNil
		ifTrue: [AllocFailureCount = 1]
		ifFalse: [AllocFailureCount := AllocFailureCount + 1]! !

"October 27, 2008 -> 9:40:0"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
handleNew: class failure: error

	self incFailureCount.
	^VM handleFailure: error
			allocate: [:tenured :failBlock| VM new: class tenured: tenured ifFail: failBlock]
			ifExpand: [VM expand]! !

"October 27, 2008 -> 9:40:7"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
handleNewBytes: class size: size failure: error

	self incFailureCount.
	^VM handleFailure: error
			allocate: [:tenured :failBlock|
								VM newBytes: class
										size: size
										tenured: tenured
										ifFail: failBlock]
			ifExpand: [VM expandBytes: class size: size]! !

"October 27, 2008 -> 9:40:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
handleFailure: error allocate: allocateBlock ifExpand: expansionBlock

	self reportNonAllocationFailure: error.
	^self spaceToScavenge
				ifTrue: [self scavengeAndAllocate: allocateBlock
										ifExpand: expansionBlock]
				ifFalse: [self collectAndAllocate: allocateBlock
										ifExpand: expansionBlock]! !

"October 27, 2008 -> 9:40:32"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'instance creation' !
oldnew ^<Instance>
	"Create and return an initialized instance of this class."

	"%remove when inlining working:"
	^{{self primitiveNewIfFail: [ :err <Symbol> |
		VM scavengeGarbage.
		{{self primitiveNewIfFail: [:err <Symbol> |
			Transcript show: err; cr.
			VM isGCPending
				ifTrue: [VM waitForGC.
							{{self primitiveNewIfFail: [:err <Symbol> |
								VM expand: (VMMirror on: self) instanceSize.
								VM deferredGC.
								{{self primitiveNewIfFail: [:err <Symbol> |
																		self error: err]}}]}}]
				ifFalse: [VM expand: (VMMirror on: self) instanceSize.
							VM deferredGC.
							{{self primitiveNewIfFail: [:err <Symbol> |
																	self error: err]}}].
			]}}
		]}}
"
	^guaranteed <Instance> (super new)
"! !

"October 27, 2008 -> 9:40:32"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'instance creation' !
new ^<Instance>
	"Create and return an initialized instance of this class."

	"%remove when inlining working:"
	^VM new: self
"
	^guaranteed <Instance> (super new)
"! !

"October 27, 2008 -> 10:39:16"!

! (Delta mirrorFor: #IndexedInstanceVariables) classSide methodsFor: 'private' !
oldprimitiveNew: size <Int> ^<Instance>

	^{{self primitiveIndexedObjectNew: size
			ifFail: [ :err <Symbol> |
					VM scavengeGarbage.
					{{self primitiveIndexedObjectNew: size
							ifFail: [ :err <Symbol> |
									VM isGCPending
										ifTrue: [VM waitForGC.
													{{self primitiveIndexedObjectNew: size
															ifFail: [:err <Symbol> |
																	VM expand: (VMMirror on: self) instanceSize + size.
																	VM deferredGC.
																	{{self primitiveIndexedObjectNew: size
																			ifFail: [:err <Symbol> |
																						self error: err]}}]}}]
										ifFalse: [VM expand: (VMMirror on: self) instanceSize + size.
													VM deferredGC.
													{{self primitiveIndexedObjectNew: size
															ifFail: [:err <Symbol> |
																	self error: err]}}]
						]}}
				]}}! !

"October 27, 2008 -> 10:39:24"!

! (Delta mirrorFor: #IndexedByteInstanceVariables) classSide methodsFor: 'private' !
oldprimitiveNew: size <Int> ^<Instance>

	^{{self primitiveIndexedByteNew: size
		ifFail: [ :err <Symbol> |  self error: err ]}}! !

"October 27, 2008 -> 10:40:18"!

! (Delta mirrorFor: #IndexedInstanceVariables) classSide methodsFor: 'private' !
primitiveNew: size <Int> ^<Instance>

	^VM new: self size: size! !

"October 27, 2008 -> 10:40:45"!

! (Delta mirrorFor: #IndexedByteInstanceVariables) classSide methodsFor: 'private' !
primitiveNew: size <Int> ^<Instance>

	^VM newBytes: self size: size! !

"October 27, 2008 -> 10:46:6"!

"System saved" !
"October 27, 2008 -> 12:2:45"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'evaluation' !
recompileAllMethods

	| counter <Int> |
	counter := 0.
	self classesAndMixinsReflectiveDo: [ :mirror <ClassMirror|MixinMirror> |
		Platform errorStream show: 'Recompiling ', mirror name; cr.
		mirror recompileAllMethodsIfFail: [ self shouldNotHappen ].
		"(counter := counter + 1) = 20
			ifTrue: [	counter := 0. VM collectGarbage ]"
	]

! !

"October 27, 2008 -> 12:8:41"!

"System saved" !
"October 27, 2008 -> 16:54:44"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
growBarrier

	^(self smallIntegerAt: #ObjectHeapExpandSize) * VM K! !

"October 27, 2008 -> 16:54:44"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
growIfNecessary

	self freeSpace < self growBarrier
		ifTrue: [self expand]! !

"October 27, 2008 -> 16:54:44"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
collectAndAllocate: allocateBlock ifExpand: expansionBlock

	self collectGarbage.
	self growIfNecessary.
	^[allocateBlock
			value: false
			value: [:e|
						self reportNonAllocationFailure: e.
						allocateBlock
							value: true
							value: [:e1|
										self reportNonAllocationFailure: e1.
										expansionBlock value.
										allocateBlock
											value: true
											value: [:e2| nil error: e2]]]]
			ensure: [self shrinkIfPossible]! !

"October 27, 2008 -> 17:2:4"!

"System saved" !
"October 27, 2008 -> 20:16:14"!

! (Delta mirrorFor: #Test) classSide methodsFor: 'toy benchmarks' !
testContexts
	|value|
	[(1 to: 10) do: [:i|
		value := value + i]]! !

"October 27, 2008 -> 20:16:14"!

! (Delta mirrorFor: #Test) classSide methodsFor: 'toy benchmarks' !
testContexts
	|value|
	[(1 to: 10) do: [:i|
		value := value + i]].
	^value! !

"October 27, 2008 -> 20:16:54"!

! (Delta mirrorFor: #Test) classSide methodsFor: 'toy benchmarks' !
testContexts
	|value|
	[(1 to: 10) do: [:i|
		value := value + i]] value.
	^value! !

"October 27, 2008 -> 20:17:14"!

! (Delta mirrorFor: #Test) classSide methodsFor: 'toy benchmarks' !
testContexts
	|value|
	value := 0.
	[(1 to: 10) do: [:i|
		value := value + i]] value.
	^value! !

"October 27, 2008 -> 20:22:40"!

! (Delta mirrorFor: #Test) classSide methodsFor: 'toy benchmarks' !
testContexts
	|value|
	value := 0.
	[(1 to: 10) do: [:i|
		value := value + i]] value.
	^value! !

"October 28, 2008 -> 9:32:15"!

"System saved" !
"October 31, 2008 -> 19:40:34"!

! (Delta mirrorFor: #Test) classSide methodsFor: 'toy benchmarks' !
allocations: count

	|time|
	time := Time millisecondsToRun: [
		count  timesRepeat: [Object new]
	].
	Transcript show: time printString; cr! !

"October 31, 2008 -> 19:49:31"!

! (Delta mirrorFor: #Test) classSide methodsFor: 'toy benchmarks' !
allocations: count

	count  timesRepeat: [Object new]! !

"October 31, 2008 -> 20:6:13"!

"System saved" !
"November 2, 2008 -> 21:54:23"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
handleNewBytes: class size: size failure: error

	self incFailureCount.
	^self handleFailure: error
			allocate: [:tenured :failBlock|
								VM newBytes: class
										size: size
										tenured: tenured
										ifFail: failBlock]
			ifExpand: [VM expandBytes: class size: size]! !

"November 2, 2008 -> 21:54:23"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
handleNewBytes: class size: size failure: error

	self incFailureCount.
	^self handleFailure: error
			allocate: [:tenured :failBlock|
								self newBytes: class
										size: size
										tenured: tenured
										ifFail: failBlock]
			ifExpand: [VM expandBytes: class size: size]! !

"November 2, 2008 -> 21:54:23"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
handleNewBytes: class size: size failure: error

	self incFailureCount.
	^self handleFailure: error
			allocate: [:tenured :failBlock|
								self newBytes: class
										size: size
										tenured: tenured
										ifFail: failBlock]
			ifExpand: [self expandBytes: class size: size]! !

"November 2, 2008 -> 21:54:23"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
handleNew: class failure: error

	self incFailureCount.
	^self handleFailure: error
			allocate: [:tenured :failBlock| VM new: class tenured: tenured ifFail: failBlock]
			ifExpand: [VM expand]! !

"November 2, 2008 -> 21:54:23"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
handleNew: class failure: error

	self incFailureCount.
	^self handleFailure: error
			allocate: [:tenured :failBlock| self new: class tenured: tenured ifFail: failBlock]
			ifExpand: [VM expand]! !

"November 2, 2008 -> 21:54:23"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
handleNew: class failure: error

	self incFailureCount.
	^self handleFailure: error
			allocate: [:tenured :failBlock| self new: class tenured: tenured ifFail: failBlock]
			ifExpand: [self expand]! !

"November 2, 2008 -> 21:54:23"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: class

	^{{primitiveNew: class
			tenured: false
			ifFail: [:e| self handleNew: class failure: e]}}! !

"November 2, 2008 -> 21:54:23"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
newBytes: byteClass size: size

	^{{primitiveIndexedByteNew: byteClass
			size: size
			tenured: false
			ifFail: [:e| self handleNewBytes: byteClass
										size: size
										failure: e]}}! !

"November 2, 2008 -> 21:54:23"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
handleNew: class size: size failure: error

	self incFailureCount.
	^self handleFailure: error
			allocate: [:tenured :failBlock| self new: class size: size tenured: tenured ifFail: failBlock]
			ifExpand: [self expand: class size: size]! !

"November 2, 2008 -> 21:54:23"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: indexableClass size: size

	^{{primitiveIndexedObjectNew: indexableClass
			size: size
			tenured: false
			ifFail: [:e| self handleNew: indexableClass
										size: size
										failure: e]}}! !

"November 2, 2008 -> 21:54:34"!

"System saved" !
"November 2, 2008 -> 23:6:57"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
newDoubleBytes: doubleByteClass size: size

	^{{primitiveIndexedDoubleByteNew: doubleByteClass
			size: size
			tenured: false
			ifFail: [:e| self handleNewDoubleBytes: doubleByteClass
										size: size
										failure: e]}}! !

"November 2, 2008 -> 23:6:57"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
newDoubleBytes: class size: size tenured: tenured ifFail: failureBlock

	^{{primitiveIndexedDoubleByteNew: class
			size: size
			tenured: tenured
			ifFail: [:e| failureBlock value: e]}}! !

"November 2, 2008 -> 23:6:57"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
handleNewDoubleBytes: class size: size failure: error

	self incFailureCount.
	^self handleFailure: error
			allocate: [:tenured :failBlock|
								self newDoubleBytes: class
										size: size
										tenured: tenured
										ifFail: failBlock]
			ifExpand: [self expandDoubleBytes: class size: size]! !

"November 2, 2008 -> 23:6:57"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
expandDoubleBytes: class size: size

	|nonIndexableSizeInOops|
	nonIndexableSizeInOops := self fixedSize: class.
	self expand: (nonIndexableSizeInOops * self oopSize + (size * 2))! !

"November 2, 2008 -> 23:6:57"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
newDoubleBytes: doubleByteClass size: size

	^{{primitiveIndexedDoubleByteNew: doubleByteClass
			size: size
			tenured: false
			ifFail: [:e| self handleNewDoubleBytes: doubleByteClass
										size: size
										failure: e]}}! !

"November 2, 2008 -> 23:6:57"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
newDoubleBytes: class size: size tenured: tenured ifFail: failureBlock

	^{{primitiveIndexedDoubleByteNew: class
			size: size
			tenured: tenured
			ifFail: [:e| failureBlock value: e]}}! !

"November 2, 2008 -> 23:6:57"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
handleNewDoubleBytes: class size: size failure: error

	self incFailureCount.
	^self handleFailure: error
			allocate: [:tenured :failBlock|
								self newDoubleBytes: class
										size: size
										tenured: tenured
										ifFail: failBlock]
			ifExpand: [self expandDoubleBytes: class size: size]! !

"November 2, 2008 -> 23:6:57"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
expandDoubleBytes: class size: size

	|nonIndexableSizeInOops|
	nonIndexableSizeInOops := self fixedSize: class.
	self expand: (nonIndexableSizeInOops * self oopSize + (size * 2))! !

"November 2, 2008 -> 23:7:6"!

"System saved" !
"November 2, 2008 -> 23:49:40"!

! (Delta mirrorFor: #Behavior) methodsFor: 'private' !
primitiveNew ^<Object>

	^VM new: self! !

"November 2, 2008 -> 23:51:50"!

! (Delta mirrorFor: #IndexedDoubleByteInstanceVariables) classSide methodsFor: 'private' !
primitiveNew: size <Int> ^<Instance>

	^VM newDoubleBytes: self size: size! !

"November 3, 2008 -> 0:0:13"!

"System saved" !
"November 3, 2008 -> 0:20:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
incFailureCount

	AllocFailureCount isNil
		ifTrue: [AllocFailureCount := 1]
		ifFalse: [AllocFailureCount := AllocFailureCount + 1]! !

"November 3, 2008 -> 0:22:59"!

"System saved" !
"January 13, 2009 -> 19:25:6"!

Delta define: #ContextNestingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"January 13, 2009 -> 19:30:53"!

! (Delta mirrorFor: #ContextNestingTest) methodsFor: 'testing' !
testNestedContext

|t1 t2 block|
t1 := 10.
t2 := 1.0.
self testWith: t1.
self testWith: t2		! !

"January 13, 2009 -> 19:33:18"!

! (Delta mirrorFor: #ContextNestingTest) methodsFor: 'testing' !
testWith: value

^self do: [:val|
				self subDo: [:val1|
									value = val1]
						with: val]! !

"January 13, 2009 -> 19:33:46"!

! (Delta mirrorFor: #ContextNestingTest) methodsFor: 'testing' !
do: block

	^block value: 1.0! !

"January 13, 2009 -> 19:33:58"!

! (Delta mirrorFor: #ContextNestingTest) methodsFor: 'testing' !
do: block

	^block value: 10! !

"January 13, 2009 -> 19:34:29"!

! (Delta mirrorFor: #ContextNestingTest) methodsFor: 'testing' !
subDo: block with: value

	^block value: value! !

"January 13, 2009 -> 19:34:48"!

! (Delta mirrorFor: #ContextNestingTest) methodsFor: 'testing' !
testNestedContext

|t1 t2 block|
t1 := 10.
t2 := #symbol.
self testWith: t1.
self testWith: t2		! !

"January 13, 2009 -> 19:35:8"!

! (Delta mirrorFor: #ContextNestingTest) methodsFor: 'testing' !
testNestedContext

self testWith: 10.
self testWith: #symbol		! !

"January 13, 2009 -> 19:37:3"!

! (Delta mirrorFor: #ContextNestingTest) methodsFor: 'testing' !
testWith: value

^self do: [:val|
				self subDo: [:val1|
									value = (val1 /val)]
						with: val]! !

"January 13, 2009 -> 19:37:52"!

"System saved" !
"January 13, 2009 -> 19:46:5"!

! (Delta mirrorFor: #ContextNestingTest) methodsFor: 'testing' !
testOnce

self testWith: 10.
self testWith: #symbol		! !

"January 13, 2009 -> 19:46:13"!

! (Delta mirrorFor: #ContextNestingTest) methodsFor: 'testing' !
testTwice

self testWith: 10.
self testWith: #symbol		! !

"January 13, 2009 -> 19:46:16"!

(Delta mirrorFor: #ContextNestingTest) removeMethod: #testNestedContext ifAbsent: [] !


"January 13, 2009 -> 19:46:22"!

! (Delta mirrorFor: #ContextNestingTest) methodsFor: 'testing' !
testOnce

self testWith: 10! !

"January 13, 2009 -> 19:46:32"!

! (Delta mirrorFor: #ContextNestingTest) methodsFor: 'testing' !
testTwice

self testWith: 10.
self testWith: #symbol! !

"January 13, 2009 -> 19:46:57"!

"System saved" !
"February 5, 2009 -> 0:7:56"!

Delta define: #DeltaParameterTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"February 5, 2009 -> 0:8:50"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
testSetupTypes
	
	DeltaParameter new
		name: #name
		type: (DeltaType for: Object)! !

"February 5, 2009 -> 0:9:22"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
testTriggerUncommonTrap
	
	DeltaParameter new
		name: #name
		type: (DeltaType for: Object class)! !

"February 5, 2009 -> 0:10:13"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
testSetupTypes
	
	DeltaParameter new
		name: #name
		type: (DeltaType for: Object);
		isFloatValue! !

"February 5, 2009 -> 0:10:14"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
testTriggerUncommonTrap
	
	DeltaParameter new
		name: #name
		type: (DeltaType for: Object class);
		isFloatValue! !

"February 5, 2009 -> 0:11:59"!

"System saved" !
"February 8, 2009 -> 15:21:44"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
testSetupTypes
	
	DeltaParameter new
		name: #name
		type: (DeltaType for: Object);
		isFloatValue.
		
	DeltaParameter new
		name: #name
		type: nil;
		isFloatValue.! !

"February 8, 2009 -> 15:22:0"!

"System saved" !
"February 8, 2009 -> 16:3:56"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
debugErrorTest: anInteger
        selectedErrorTest := anInteger.				"added rew"
        selectedFailureTest := 0.							"added rew"
        self changed: #selectedFailureTest.		"added rew"
        self changed: #selectedErrorTest.			"added rew"
        (anInteger ~= 0)
                ifTrue: [[(result errors at: anInteger) debug] fork]! !

"February 8, 2009 -> 16:26:47"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
testSetupTypes
	
	DeltaParameter new
		name: #name
		type: (DeltaType for: Object);
		isFloatValue.
		
	DeltaParameter new
		name: #name
		type: ((DeltaTypeId new)
					setId: #id;
					yourself);
		isFloatValue.! !

"February 8, 2009 -> 16:28:4"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
testSetupTypes
	
	DeltaParameter new
		name: #name
		type: (DeltaType for: Object);
		isFloatValue.
		
	DeltaParameter new
		name: #name
		type: ((DeltaTypeId new)
					setId: #id;
					yourself);
		isFloatValue.
		
	DeltaParameter new
		name: #name
		type: nil;
		type! !

"February 8, 2009 -> 16:29:2"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
testSetupTypes
	
	DeltaParameter new
		name: #name
		type: (DeltaType for: Object);
		isFloatValue.
		
	DeltaParameter new
		name: #name
		type: ((DeltaTypeId new)
					setId: #id;
					yourself);
		isFloatValue.

	DeltaParameter new
		name: #name
		type: ((DeltaClassId new)
					setId: #id;
					yourself);
		isFloatValue.

	DeltaParameter new
		name: #name
		type: nil;
		type! !

"February 8, 2009 -> 16:29:30"!

"System saved" !
"February 8, 2009 -> 16:40:28"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
objectType
	
	^DeltaParameter new
		name: #name
		type: (DeltaType for: Object);
		yourself! !

"February 8, 2009 -> 16:40:48"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
testSetupTypes
	
	self objectType isFloatValue.
		
	DeltaParameter new
		name: #name
		type: ((DeltaTypeId new)
					setId: #id;
					yourself);
		isFloatValue.

	DeltaParameter new
		name: #name
		type: ((DeltaClassId new)
					setId: #id;
					yourself);
		isFloatValue.

	DeltaParameter new
		name: #name
		type: nil;
		type! !

"February 8, 2009 -> 16:41:16"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
typeId
	
	^DeltaParameter new
		name: #name
		type: ((DeltaTypeId new)
					setId: #id;
					yourself);
		yourself! !

"February 8, 2009 -> 16:41:36"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
testSetupTypes
	
	self objectType isFloatValue.
	self typeId isFloatValue.

	DeltaParameter new
		name: #name
		type: ((DeltaClassId new)
					setId: #id;
					yourself);
		isFloatValue.

	DeltaParameter new
		name: #name
		type: nil;
		type! !

"February 8, 2009 -> 16:42:21"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
classId
	
	^DeltaParameter new
		name: #name
		type: ((DeltaClassId new)
					setId: #id;
					yourself);
		yourself! !

"February 8, 2009 -> 16:42:38"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
testSetupTypes
	
	self objectType isFloatValue.
	self typeId isFloatValue.
	self classId isFloatValue.

	DeltaParameter new
		name: #name
		type: nil;
		type! !

"February 8, 2009 -> 16:43:9"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
nilType
	
	^DeltaParameter new
		name: #name
		type: nil;
		yourself! !

"February 8, 2009 -> 16:43:25"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
testSetupTypes
	
	self objectType isFloatValue.
	self typeId isFloatValue.
	self classId isFloatValue.
	self nilType type! !

"February 8, 2009 -> 16:44:20"!

Delta define: #DeltaParameterTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'objectType typeId classId nilType')) !


"February 8, 2009 -> 16:45:9"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
initialize
	
	objectType := self objectType.
	typeId := self typeId.
	classId := self classId.
	nilType := self nilType! !

"February 8, 2009 -> 16:45:32"!

! (Delta mirrorFor: #DeltaParameterTest) classSide methodsFor: 'instance creation' !
new

	^super new initialize; yourself! !

"February 8, 2009 -> 16:45:56"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
testSetupTypes
	
	objectType isFloatValue.
	typeId isFloatValue.
	classId isFloatValue.
	nilType type! !

"February 8, 2009 -> 16:46:11"!

"System saved" !
"February 8, 2009 -> 17:50:52"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
operatorTypeError
	
	^DeltaParameter new
		name: #name
		type: ((DeltaInvalidTypeOperatorError new)
					operator: '+';
					yourself);
		yourself! !

"February 8, 2009 -> 17:51:14"!

Delta define: #DeltaParameterTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'objectType typeId classId nilType operatorTypeError')) !


"February 8, 2009 -> 17:51:30"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
initialize
	
	objectType := self objectType.
	typeId := self typeId.
	classId := self classId.
	nilType := self nilType.
	operatorTypeError := self operatorTypeError! !

"February 8, 2009 -> 17:51:46"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
testSetupTypes
	
	objectType isFloatValue.
	typeId isFloatValue.
	classId isFloatValue.
	nilType type.
	operatorTypeError type! !

"February 8, 2009 -> 17:52:15"!

"System saved" !
"February 8, 2009 -> 18:10:47"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
setupPolymorphicSends

	self objectType type.
	self nilType type.
	self typeId type.
	self classId type.
	self operatorTypeError type.
	self superNilError type.
	! !

"February 8, 2009 -> 18:13:8"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
testSetupTypes
	
	self setupPolymorphicSends.
	self arityError type! !

"February 8, 2009 -> 18:13:10"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
setupPolymorphicSends

	self objectType type.
	self nilType type.
	self typeId type.
	self classId type.
	self operatorTypeError type.
	self superNilError type.
	self placeholderError type.
	self noTypeError type.
	! !

"February 8, 2009 -> 18:13:24"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
superNilError

! !

"February 8, 2009 -> 18:14:26"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
superNilError
	
	^DeltaParameter new
		name: #name
		type: (DeltaSuperSendToNilError new);
		yourself! !

"February 8, 2009 -> 18:15:24"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
placeholderError
	
	^DeltaParameter new
		name: #name
		type: (DeltaPlaceHolderError new
						name: #placeholder;
						yourself);
		yourself! !

"February 8, 2009 -> 18:16:14"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
noTypeError
	
	^DeltaParameter new
		name: #name
		type: (DeltaNoTypeSpecifiedError new);
		yourself! !

"February 8, 2009 -> 18:16:37"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
parameter: type
	
	^DeltaParameter new
		name: #name
		type: type;
		yourself! !

"February 8, 2009 -> 18:17:0"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
operatorTypeError
	
	^self parameter: ((DeltaInvalidTypeOperatorError new)
									operator: '+';
									yourself)! !

"February 8, 2009 -> 18:17:30"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
objectType
	
	^self parameter: (DeltaType for: Object)! !

"February 8, 2009 -> 18:17:45"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
noTypeError
	
	^self parameter: (DeltaNoTypeSpecifiedError new)! !

"February 8, 2009 -> 18:18:38"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
placeholderError
	
	^self parameter: (DeltaPlaceHolderError new
									name: #placeholder;
									yourself)! !

"February 8, 2009 -> 18:19:2"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
superNilError
	
	^self parameter: (DeltaSuperSendToNilError new)! !

"February 8, 2009 -> 18:19:22"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
typeId
	
	^self parameter: ((DeltaTypeId new)
									setId: #id;
									yourself)! !

"February 8, 2009 -> 18:19:48"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
nilType
	
	^self parameter: nil! !

"February 8, 2009 -> 18:20:5"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
classId
	
	^self parameter: ((DeltaClassId new)
									setId: #id;
									yourself)! !

"February 8, 2009 -> 18:21:14"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
arityError
	
	^self parameter: (DeltaGenericArityError new)! !

"February 8, 2009 -> 18:21:28"!

"System saved" !
"February 8, 2009 -> 18:33:55"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
setupPolymorphicSends

	self objectType type.
	self nilType type.
	self typeId type.
	self classId type.
	self operatorTypeError type.
	"self superNilError type.
	self placeholderError type.
	self noTypeError type."
	! !

"February 8, 2009 -> 18:34:1"!

"System saved" !
"February 8, 2009 -> 18:40:48"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
testTriggerUncommonTrap
	
	(self parameter: (DeltaType for: Object class))
		isFloatValue! !

"February 8, 2009 -> 18:41:28"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
testSetupPoly
	
	self setupPolymorphicSends! !

"February 8, 2009 -> 18:41:41"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
testSetupTypes
	
	self arityError type! !

"February 8, 2009 -> 18:42:9"!

"System saved" !
"February 8, 2009 -> 21:34:57"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
setupPolymorphicSends

	self objectType type.
	self nilType type.
	self typeId type.
	self classId type.
	"self operatorTypeError type.
	self superNilError type.
	self placeholderError type.
	self noTypeError type."
	! !

"February 8, 2009 -> 21:35:11"!

"System saved" !
"February 8, 2009 -> 22:59:51"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
setupPolymorphicSends

	self objectType type.
	self nilType type.
	self typeId type.
	"self classId type.
	self operatorTypeError type.
	self superNilError type.
	self placeholderError type.
	self noTypeError type."
	! !

"February 8, 2009 -> 23:0:13"!

"System saved" !
"February 8, 2009 -> 23:45:53"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
setupPolymorphicSends

"	self objectType type."
	self nilType type.
"	self typeId type."
	"self classId type.
	self operatorTypeError type.
	self superNilError type."
	self placeholderError type.
	self noTypeError type.
	! !

"February 8, 2009 -> 23:46:24"!

"System saved" !
"February 19, 2009 -> 19:5:19"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
populatePIC

"	self objectType type."
	self nilType type.
"	self typeId type."
	"self classId type.
	self operatorTypeError type.
	self superNilError type."
	self placeholderError type.
	self noTypeError type.
	! !

"February 19, 2009 -> 19:5:19"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
populatePIC

	self nilType type.
	self placeholderError type.
	self noTypeError type.
	self arityError type	! !

"February 19, 2009 -> 19:5:19"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
populatePIC

	self nilType type.
	self placeholderError type.
	self noTypeError type.
	self arityError type! !

"February 19, 2009 -> 19:5:19"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
objectClassType
	
	^self parameter: (DeltaType for: Object class)! !

"February 19, 2009 -> 19:5:19"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
testTriggerUncommonTrap

	self objectClassType isFloatValue! !

"February 19, 2009 -> 19:5:19"!

(Delta mirrorFor: #DeltaParameterTest) classSide removeMethod: #new ifAbsent: [] !


"February 19, 2009 -> 19:5:19"!

(Delta mirrorFor: #DeltaParameterTest) removeMethod: #initialize ifAbsent: [] !


"February 19, 2009 -> 19:5:19"!

! (Delta mirrorFor: #DeltaParameterTest) methodsFor: 'testing' !
testTriggerUncommonTrap

	self populatePIC.
	self objectClassType isFloatValue! !

"February 19, 2009 -> 19:6:33"!

(Delta mirrorFor: #DeltaParameterTest) removeMethod: #testSetupPoly ifAbsent: [] !


"February 19, 2009 -> 19:6:36"!

(Delta mirrorFor: #DeltaParameterTest) removeMethod: #testSetupTypes ifAbsent: [] !


"February 19, 2009 -> 19:7:27"!

(Delta mirrorFor: #DeltaParameterTest) removeMethod: #setupPolymorphicSends ifAbsent: [] !


"February 19, 2009 -> 19:7:39"!

(Delta mirrorFor: #DeltaParameterTest) removeMethod: #superNilError ifAbsent: [] !


"February 19, 2009 -> 19:7:51"!

(Delta mirrorFor: #DeltaParameterTest) removeMethod: #operatorTypeError ifAbsent: [] !


"February 19, 2009 -> 19:7:59"!

(Delta mirrorFor: #DeltaParameterTest) removeMethod: #objectType ifAbsent: [] !


"February 19, 2009 -> 19:8:23"!

(Delta mirrorFor: #DeltaParameterTest) removeMethod: #classId ifAbsent: [] !


"February 19, 2009 -> 19:9:3"!

(Delta mirrorFor: #DeltaParameterTest) removeMethod: #typeId ifAbsent: [] !


"February 19, 2009 -> 19:9:24"!

"System saved" !
"February 22, 2009 -> 0:32:23"!

Delta define: #DeltaScopeTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"February 22, 2009 -> 0:33:15"!

! (Delta mirrorFor: #DeltaScopeTest) methodsFor: 'testing' !
testAtIfAbsent

	DeltaScope new
		at: #symbol
		ifAbsent: []! !

"February 22, 2009 -> 0:34:34"!

! (Delta mirrorFor: #DeltaScopeTest) methodsFor: 'testing' !
testAtIfAbsent

	(DeltaScope within: nil)
		at: #symbol
		ifAbsent: []! !

"February 22, 2009 -> 0:34:56"!

"System saved" !
"February 22, 2009 -> 0:40:40"!

! (Delta mirrorFor: #DeltaScopeTest) methodsFor: 'testing' !
testAtIfAbsent

|scope1 scope2|
	scope1 := DeltaScope within: nil.
	scope2 := DeltaScope within: scope1.
	scope1 bindings
		at: #symbol
		put: #value.
	scope2
		at: #symbol
		ifAbsent: [].
	scope2
		at: #unknown
		ifAbsent: []! !

"February 22, 2009 -> 0:40:59"!

"System saved" !
"February 23, 2009 -> 1:13:16"!

! (Delta mirrorFor: #DeltaScopeTest) methodsFor: 'testing' !
oldtestAtIfAbsent

|scope1 scope2|
	scope1 := DeltaScope within: nil.
	scope2 := DeltaScope within: scope1.
	scope1 bindings
		at: #symbol
		put: #value.
	scope2
		at: #symbol
		ifAbsent: [].
	scope2
		at: #unknown
		ifAbsent: []! !

"February 23, 2009 -> 1:14:32"!

! (Delta mirrorFor: #DeltaScopeTest) methodsFor: 'testing' !
testAtIfAbsent

|scope1|
	scope1 := DeltaScope within: nil.
	scope1 bindings
		at: #symbol
		put: #value.
	scope1
		at: #symbol
		ifAbsent: [nil]! !

"February 23, 2009 -> 1:15:3"!

"System saved" !
"February 23, 2009 -> 1:29:50"!

Delta define: #BlockMaterializeTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"February 23, 2009 -> 1:30:6"!

Delta define: #IgnoreBlock as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"February 23, 2009 -> 1:30:25"!

! (Delta mirrorFor: #IgnoreBlock) methodsFor: 'test support' !
ignore: block

	^self! !

"February 23, 2009 -> 1:30:55"!

! (Delta mirrorFor: #BlockMaterializeTest) methodsFor: 'testing' !
testIgnoredBlock

	! !

"February 23, 2009 -> 1:31:15"!

Delta define: #BlockMaterializeTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'scope')) !


"February 23, 2009 -> 1:31:57"!

! (Delta mirrorFor: #BlockMaterializeTest) classSide methodsFor: 'instance creation' !
new

	^super new initialize! !

"February 23, 2009 -> 1:32:23"!

! (Delta mirrorFor: #BlockMaterializeTest) methodsFor: 'initialization' !
initialize

	scope := IgnoreBlock new! !

"February 23, 2009 -> 1:33:7"!

! (Delta mirrorFor: #BlockMaterializeTest) methodsFor: 'testing' !
testIgnoredBlock

	self assert: (scope ignore: [nil]) = scope! !

"February 23, 2009 -> 1:34:34"!

"System saved" !
"February 27, 2009 -> 1:4:53"!

Delta define: #CanonicalContextTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"February 27, 2009 -> 1:5:31"!

! (Delta mirrorFor: #CanonicalContextTest) methodsFor: 'testing' !
testDoBlock

! !

"February 27, 2009 -> 1:5:39"!

Delta define: #CanonicalContextTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'vars')) !


"February 27, 2009 -> 1:11:36"!

! (Delta mirrorFor: #CanonicalContextTest) methodsFor: 'fixture' !
setUp

	vars := OrderedCollection new.
	vars add: DeltaParameter new! !

"February 27, 2009 -> 1:12:24"!

! (Delta mirrorFor: #CanonicalContextTest) methodsFor: 'fixture' !
varOfType: aClass

	^aClass new
		name: #name
		type: nil! !

"February 27, 2009 -> 1:12:39"!

! (Delta mirrorFor: #CanonicalContextTest) methodsFor: 'fixture' !
setUp

	vars := OrderedCollection new.
	vars add: (self varOfType: DeltaParameter)! !

"February 27, 2009 -> 1:13:9"!

! (Delta mirrorFor: #CanonicalContextTest) methodsFor: 'testing' !
testDoBlock

	vars do: [:var| var name]
! !

"February 27, 2009 -> 1:13:14"!

! (Delta mirrorFor: #CanonicalContextTest) methodsFor: 'testing' !
testDoBlock

	vars do: [:var| var name]! !

"February 27, 2009 -> 1:13:46"!

! (Delta mirrorFor: #CanonicalContextTest) methodsFor: 'fixture' !
addNewVar

	vars add: (self varOfType: DeltaInstVar)! !

"February 27, 2009 -> 1:16:35"!

! (Delta mirrorFor: #CanonicalContextTest) methodsFor: 'testing' !
testDoBlock

	|names|
	vars do: [:var| var name]! !

"February 27, 2009 -> 1:16:46"!

! (Delta mirrorFor: #CanonicalContextTest) methodsFor: 'testing' !
testDoBlock

	|names|
	names := OrderedCollection new.
	vars do: [:var| var name]! !

"February 27, 2009 -> 1:17:19"!

"System saved" !
"February 27, 2009 -> 1:20:9"!

! (Delta mirrorFor: #CanonicalContextTest) methodsFor: 'testing' !
testDoBlock

	|names|
	names := OrderedCollection new.
	vars do: [:var| names add: var name]! !

"February 27, 2009 -> 1:20:24"!

! (Delta mirrorFor: #CanonicalContextTest) methodsFor: 'testing' !
testDoBlock

	|names|
	names := OrderedCollection new.
	vars do: [:var| names add: var name].
	^names! !

"February 27, 2009 -> 1:21:6"!

"System saved" !
"March 15, 2009 -> 15:14:54"!

Delta define: #ComputeHeapsetTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"March 15, 2009 -> 15:16:41"!

! (Delta mirrorFor: #ComputeHeapsetTest) methodsFor: 'testing' !
testWithTwoSubscopes

	|outer inner1 inner2|
	outer := DeltaCodeScope within: nil.
	inner1 := DeltaGlobalScope within: outer.
	inner2 := DeltaCodeScope within: outer.
	
	outer computeHeapSet! !

"March 15, 2009 -> 15:18:59"!

Delta define: #ComputeHeapSetTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"March 15, 2009 -> 15:19:23"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
testWithTwoSubscopes

	|outer inner1 inner2|
	outer := DeltaCodeScope within: nil.
	inner1 := DeltaGlobalScope within: outer.
	inner2 := DeltaCodeScope within: outer.
	
	outer computeHeapSet! !

"March 15, 2009 -> 15:20:3"!

(Delta mirrorFor: #ComputeHeapsetTest) removeDefinitionIfFail: [] !


"March 15, 2009 -> 15:20:39"!

"System saved" !
"March 15, 2009 -> 16:20:43"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
testWithOneSubscope

	|outer inner|
	outer := DeltaCodeScope within: nil.
	inner := DeltaCodeScope within: outer.
	
	outer computeHeapSet! !

"March 15, 2009 -> 16:20:52"!

"System saved" !
"March 15, 2009 -> 16:43:33"!

Delta define: #ComputeHeapSetTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'outer inner inner2')) !


"March 15, 2009 -> 16:43:49"!

Delta define: #ComputeHeapSetTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'outer')) !


"March 15, 2009 -> 16:44:6"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
testWithOneSubscope

	|inner|
	outer := DeltaCodeScope within: nil.
	inner := DeltaCodeScope within: outer.
	
	outer computeHeapSet! !

"March 15, 2009 -> 16:44:15"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
testWithTwoSubscopes

	|inner1 inner2|
	outer := DeltaCodeScope within: nil.
	inner1 := DeltaGlobalScope within: outer.
	inner2 := DeltaCodeScope within: outer.
	
	outer computeHeapSet! !

"March 15, 2009 -> 16:44:25"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
testWithTwoSubscopes

	|inner1 inner2|
	outer := DeltaCodeScope within: nil.
	DeltaGlobalScope within: outer.
	DeltaCodeScope within: outer.
	
	outer computeHeapSet! !

"March 15, 2009 -> 16:44:49"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
testWithOneSubscope

	|inner|
	outer := DeltaCodeScope within: nil.
	DeltaCodeScope within: outer.
	
	outer computeHeapSet! !

"March 15, 2009 -> 16:44:54"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
testWithOneSubscope

	outer := DeltaCodeScope within: nil.
	DeltaCodeScope within: outer.
	
	outer computeHeapSet! !

"March 15, 2009 -> 16:45:0"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
testWithTwoSubscopes

	outer := DeltaCodeScope within: nil.
	DeltaGlobalScope within: outer.
	DeltaCodeScope within: outer.
	
	outer computeHeapSet! !

"March 15, 2009 -> 16:45:30"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
setupScope

	outer := DeltaCodeScope within: nil.
	DeltaCodeScope within: outer! !

"March 15, 2009 -> 16:45:55"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
testWithTwoSubscopes

	self setupScope.
	DeltaCodeScope within: outer.
	
	outer computeHeapSet! !

"March 15, 2009 -> 16:45:56"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
testWithOneSubscope

	self setupScope.
	
	outer computeHeapSet! !

"March 15, 2009 -> 16:46:26"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
testWithTwoSubscopes

	self setupScope.
	DeltaGlobalScope within: outer.
	
	outer computeHeapSet! !

"March 15, 2009 -> 16:46:53"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
setupTwoSubscopes

	self setupScope.
	DeltaGlobalScope within: outer! !

"March 15, 2009 -> 16:47:4"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
testWithOneSubscope

	self setupTwoSubscopes.
	
	outer computeHeapSet! !

"March 15, 2009 -> 16:47:51"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
testWithOneSubscope

	self setupScope.
	
	outer computeHeapSet! !

"March 15, 2009 -> 16:47:53"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
testWithTwoSubscopes

	self setupTwoSubscopes.
	
	outer computeHeapSet! !

"March 15, 2009 -> 16:48:7"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
testWithOneSubscope

	self setupScope.
	outer computeHeapSet! !

"March 15, 2009 -> 17:1:20"!

"System saved" !
"March 15, 2009 -> 17:2:8"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
testWithTwoSubscopes

	self setupTwoSubscopes.
	outer computeHeapSet! !

"March 15, 2009 -> 17:3:10"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
setupScope

	outer := DeltaCodeScope within: nil.
	(DeltaCodeScope within: outer) inline! !

"March 15, 2009 -> 17:3:22"!

"System saved" !
"March 15, 2009 -> 20:39:5"!

Delta define: #ComputeHeapSetTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'outer inner innerInner')) !


"March 15, 2009 -> 20:39:22"!

Delta define: #ComputeHeapSetTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'outer inner inner2 inner3')) !


"March 15, 2009 -> 20:39:31"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
setupScope

	outer := DeltaCodeScope within: nil.
	(inner := DeltaCodeScope within: outer) inline! !

"March 15, 2009 -> 20:40:44"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
setupScope

	outer := DeltaCodeScope within: nil.
	(inner := DeltaCodeScope within: outer) inline.
	(inner2 := DeltaCodeScope within: inner) inline.
	(inner3 := DeltaCodeScope within: inner2) inline! !

"March 15, 2009 -> 20:51:30"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
setupTwoVars

	|var|
	self setupScope.
	var := DeltaClassVar
					declare: #Var2
					of: nil
					inScope: inner2
					ifThere: [].
	inner2 at: #Var2 put: var! !

"March 15, 2009 -> 20:51:42"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
testWithTwoSubscopes

	self setupTwoVars.
	outer computeHeapSet! !

"March 15, 2009 -> 20:52:24"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
setupScope

	|var|
	outer := DeltaCodeScope within: nil.
	(inner := DeltaCodeScope within: outer) inline.
	(inner2 := DeltaCodeScope within: inner) inline.
	var := DeltaInstVar
					declare: #var1
					of: nil
					inScope: inner2
					ifThere: [].
	inner2 at: #var1 put: var.
	
	"(inner3 := DeltaCodeScope within: inner2) inline"! !

"March 15, 2009 -> 20:52:39"!

"System saved" !
"March 15, 2009 -> 21:21:18"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
setupScope

	|var|
	outer := DeltaCodeScope within: nil.
	(inner := DeltaCodeScope within: outer) inline.
	(inner2 := DeltaCodeScope within: inner) inline.
	var := DeltaInstVar
					declare: #var1
					of: nil
					inScope: inner2
					ifThere: [].
	inner2 superVars add: var.
	
	"(inner3 := DeltaCodeScope within: inner2) inline"! !

"March 15, 2009 -> 21:21:39"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
setupTwoVars

	|var|
	self setupScope.
	var := DeltaClassVar
					declare: #Var2
					of: nil
					inScope: inner2
					ifThere: [].
	inner2 superVars add: var! !

"March 15, 2009 -> 21:22:56"!

"System saved" !
"March 15, 2009 -> 21:35:54"!

! (Delta mirrorFor: #ComputeHeapSetTest) methodsFor: 'testing' !
setupScope

	|var|
	outer := DeltaCodeScope within: (DeltaCodeScope within: nil).
	(inner := DeltaCodeScope within: outer) inline.
	(inner2 := DeltaCodeScope within: inner) inline.
	var := DeltaInstVar
					declare: #var1
					of: nil
					inScope: inner2
					ifThere: [].
	inner2 superVars add: var.
	
	"(inner3 := DeltaCodeScope within: inner2) inline"! !

"March 15, 2009 -> 21:38:3"!

"System saved" !
"March 21, 2009 -> 13:38:51"!

Delta define: #RecursionBlockTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"March 21, 2009 -> 13:41:37"!

! (Delta mirrorFor: #RecursionBlockTest) methodsFor: 'testing' !
recurse: count block: block

	count > 0
		ifTrue: [self recurse: count - 1
							block: block]
		ifFalse: [block value]! !

"March 21, 2009 -> 13:42:17"!

! (Delta mirrorFor: #RecursionBlockTest) methodsFor: 'testing' !
recurse: count block: block

	count > 0
		ifTrue: [self recurse: count - 1
							block: block]
		ifFalse: [block value: count]! !

"March 21, 2009 -> 13:44:56"!

! (Delta mirrorFor: #RecursionBlockTest) methodsFor: 'testing' !
recurse4

	|result|
	result := OrderedCollection new.
	self recurse: 4
		block: [:var| var isInteger
								ifTrue: [result add: var]]! !

"March 21, 2009 -> 13:45:7"!

! (Delta mirrorFor: #RecursionBlockTest) methodsFor: 'testing' !
recursef4

	|result|
	result := OrderedCollection new.
	self recurse: 4.0
		block: [:var| var isInteger
								ifTrue: [result add: var]]! !

"March 21, 2009 -> 13:45:39"!

! (Delta mirrorFor: #RecursionBlockTest) methodsFor: 'testing' !
testRecurse4! !

"March 21, 2009 -> 13:45:53"!

! (Delta mirrorFor: #RecursionBlockTest) methodsFor: 'testing' !
recurse: val

	|result|
	result := OrderedCollection new.
	self recurse: val
		block: [:var| var isInteger
								ifTrue: [result add: var]]! !

"March 21, 2009 -> 13:45:59"!

(Delta mirrorFor: #RecursionBlockTest) removeMethod: #recurse4 ifAbsent: [] !


"March 21, 2009 -> 13:46:1"!

(Delta mirrorFor: #RecursionBlockTest) removeMethod: #recursef4 ifAbsent: [] !


"March 21, 2009 -> 13:46:20"!

! (Delta mirrorFor: #RecursionBlockTest) methodsFor: 'testing' !
recurse: val

	|result|
	result := OrderedCollection new.
	self recurse: val
		block: [:var| var isInteger
								ifTrue: [result add: var]].
	^result! !

"March 21, 2009 -> 13:47:6"!

! (Delta mirrorFor: #RecursionBlockTest) methodsFor: 'testing' !
testRecurse4

	self recurse: 4! !

"March 21, 2009 -> 13:47:13"!

! (Delta mirrorFor: #RecursionBlockTest) methodsFor: 'testing' !
testRecursef4

	self recurse: 4.0! !

"March 21, 2009 -> 13:50:45"!

"System saved" !
"March 21, 2009 -> 14:2:7"!

! (Delta mirrorFor: #RecursionBlockTest) methodsFor: 'testing' !
testRecurse4

	self recurse: 1! !

"March 21, 2009 -> 14:2:33"!

"System saved" !
"March 21, 2009 -> 14:5:2"!

! (Delta mirrorFor: #RecursionBlockTest) methodsFor: 'testing' !
recurse: val result: result

	self recurse: val
		block: [:var| var isInteger
								ifTrue: [result add: var]].
	^result! !

"March 21, 2009 -> 14:5:32"!

! (Delta mirrorFor: #RecursionBlockTest) methodsFor: 'testing' !
testRecursef4

	self recurse: 4.0
		result: OrderedCollection new! !

"March 21, 2009 -> 14:5:33"!

! (Delta mirrorFor: #RecursionBlockTest) methodsFor: 'testing' !
testRecurse4

	self recurse: 1
		result: OrderedCollection new! !

"March 21, 2009 -> 14:6:14"!

"System saved" !
"March 21, 2009 -> 14:44:29"!

(Delta mirrorFor: #RecursionBlockTest) removeMethod: #recurse: ifAbsent: [] !


"March 21, 2009 -> 14:46:34"!

"System saved" !
"March 21, 2009 -> 15:45:0"!

Delta define: #RecursionBlockTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'var')) !


"March 21, 2009 -> 15:45:22"!

! (Delta mirrorFor: #RecursionBlockTest) methodsFor: 'testing' !
recurse: count block: block

	count > 0
		ifTrue: [self recurse: count - 1
							block: var]
		ifFalse: [block value: var]! !

"March 21, 2009 -> 15:45:41"!

Delta define: #RecursionBlockTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'var value')) !


"March 21, 2009 -> 15:45:49"!

! (Delta mirrorFor: #RecursionBlockTest) methodsFor: 'testing' !
recurse: count block: block

	count > 0
		ifTrue: [self recurse: count - 1
							block: value]
		ifFalse: [block value: value]! !

"March 21, 2009 -> 15:46:2"!

Delta define: #RecursionBlockTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'value')) !


"March 21, 2009 -> 15:46:16"!

! (Delta mirrorFor: #RecursionBlockTest) methodsFor: 'testing' !
testRecurse4

	value = 3.
	self recurse: 1
		result: OrderedCollection new! !

"March 21, 2009 -> 15:46:29"!

! (Delta mirrorFor: #RecursionBlockTest) methodsFor: 'testing' !
testRecursef4

	value = 3.0.
	self recurse: 2
		result: OrderedCollection new! !

"March 21, 2009 -> 15:48:42"!

! (Delta mirrorFor: #RecursionBlockTest) methodsFor: 'testing' !
recurse: count block: block

	count > 0
		ifTrue: [self recurse: count - 1
							block: block]
		ifFalse: [block value: value]! !

"March 21, 2009 -> 15:49:14"!

"System saved" !
"March 21, 2009 -> 16:42:51"!

! (Delta mirrorFor: #RecursionBlockTest) methodsFor: 'testing' !
testRecursef4

	|result|
	value = 3.0.
	result := OrderedCollection new.
	self recurse: 2
		result: result.
	value = 4.
	self recurse: 2
		result: result! !

"March 21, 2009 -> 16:43:1"!

"System saved" !
"March 22, 2009 -> 0:50:22"!

! (Delta mirrorFor: #RecursionBlockTest) methodsFor: 'testing' !
testRecurse

	value = 3.
	self recurse: 1
		result: OrderedCollection new! !

"March 22, 2009 -> 0:50:32"!

(Delta mirrorFor: #RecursionBlockTest) removeMethod: #testRecurse ifAbsent: [] !


"March 22, 2009 -> 0:50:48"!

! (Delta mirrorFor: #RecursionBlockTest) methodsFor: 'testing' !
testRecurseFloat

	|result|
	value = 3.0.
	result := OrderedCollection new.
	self recurse: 2
		result: result.
	value = 4.
	self recurse: 2
		result: result! !

"March 22, 2009 -> 0:50:51"!

(Delta mirrorFor: #RecursionBlockTest) removeMethod: #testRecursef4 ifAbsent: [] !


"March 22, 2009 -> 0:50:55"!

! (Delta mirrorFor: #RecursionBlockTest) methodsFor: 'testing' !
testRecurseInteger

	value = 3.
	self recurse: 1
		result: OrderedCollection new! !

"March 22, 2009 -> 0:50:57"!

(Delta mirrorFor: #RecursionBlockTest) removeMethod: #testRecurse4 ifAbsent: [] !


"March 22, 2009 -> 0:51:4"!

"System saved" !
"March 29, 2009 -> 16:20:37"!

! (Delta mirrorFor: #Integer) methodsFor: 'benchmarking' !
benchFib  "Handy send-heavy benchmark"
	"(result // seconds to run) = approx calls per second"
	" | r t |
	  t _ Time millisecondsToRun: [r _ 26 benchFib].
	  (r * 1000) // t"
	"138000 on a Mac 8100/100"
	^ self < 2
		ifTrue: [1] 
		ifFalse: [(self-1) benchFib + (self-2) benchFib + 1]! !

"March 29, 2009 -> 16:24:3"!

"System saved" !
"April 4, 2009 -> 17:53:0"!

Delta define: #NonInlinedBlockTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"April 4, 2009 -> 17:53:53"!

! (Delta mirrorFor: #NonInlinedBlockTest) methodsFor: 'testing' !
testSetup! !

"April 4, 2009 -> 17:57:36"!

Delta define: #NIBA as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"April 4, 2009 -> 17:57:45"!

Delta define: #NIBB as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"April 4, 2009 -> 17:57:52"!

Delta define: #NIBC as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"April 4, 2009 -> 17:58:14"!

Delta define: #AbstractNIB as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"April 4, 2009 -> 17:59:2"!

Delta define: #NIBC as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:2"!

Delta define: #NIBC as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:2"!

Delta define: #NIBC as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:2"!

Delta define: #NIBC as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:2"!

Delta define: #NIBC as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:2"!

Delta define: #NIBC as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:2"!

Delta define: #NIBC as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:2"!

Delta define: #NIBC as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:2"!

Delta define: #NIBC as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:2"!

Delta define: #NIBC as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:2"!

Delta define: #NIBC as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:8"!

Delta define: #NIBB as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:8"!

Delta define: #NIBB as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:8"!

Delta define: #NIBB as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:8"!

Delta define: #NIBB as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:8"!

Delta define: #NIBB as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:8"!

Delta define: #NIBB as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:8"!

Delta define: #NIBB as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:8"!

Delta define: #NIBB as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:8"!

Delta define: #NIBB as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:8"!

Delta define: #NIBB as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:8"!

Delta define: #NIBB as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:31"!

Delta define: #NIBA as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:31"!

Delta define: #NIBA as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:31"!

Delta define: #NIBA as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:31"!

Delta define: #NIBA as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:31"!

Delta define: #NIBA as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:31"!

Delta define: #NIBA as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:31"!

Delta define: #NIBA as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:31"!

Delta define: #NIBA as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:31"!

Delta define: #NIBA as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:31"!

Delta define: #NIBA as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 17:59:31"!

Delta define: #NIBA as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 18:0:21"!

! (Delta mirrorFor: #AbstractNIB) methodsFor: 'testing' !
do: block value: value

	^block value: value! !

"April 4, 2009 -> 18:1:53"!

! (Delta mirrorFor: #NonInlinedBlockTest) methodsFor: 'testing' !
testSetup
	|a b c|
	a := NIBA new.
	b := NIBB new.
	c := NIBC new.
	self exercise: a value: 1.
	self exercise: b value: 1.
	self exercise: c value: 1
! !

"April 4, 2009 -> 18:3:7"!

! (Delta mirrorFor: #NonInlinedBlockTest) methodsFor: 'testing' !
exercise: nib value: value
	
	nib do: [:a | a isNil] value: value! !

"April 4, 2009 -> 18:4:43"!

! (Delta mirrorFor: #NonInlinedBlockTest) methodsFor: 'testing' !
testTrap1
	|a|
	a := NIBA new.
	self exercise: a value: 1.
	self exercise: a value: 1.0! !

"April 4, 2009 -> 18:4:55"!

! (Delta mirrorFor: #NonInlinedBlockTest) methodsFor: 'testing' !
testTrap
	|a|
	a := NIBA new.
	self exercise: a value: 1.
	self exercise: a value: 1.0! !

"April 4, 2009 -> 18:8:25"!

! (Delta mirrorFor: #NonInlinedBlockTest) methodsFor: 'testing' !
exercise: nib value: value
	|set|
	set := Set new.
	nib do: [:a | a isNil
						ifFalse: [set add: a]]
		value: value! !

"April 4, 2009 -> 18:10:7"!

(Delta mirrorFor: #NonInlinedBlockTest) removeMethod: #testTrap1 ifAbsent: [] !


"April 4, 2009 -> 18:10:19"!

"System saved" !
"April 4, 2009 -> 19:1:42"!

Delta define: #NIBD as: (
(Class subclassOf: 'AbstractNIB' instanceVariables: '')) !


"April 4, 2009 -> 19:2:41"!

! (Delta mirrorFor: #NonInlinedBlockTest) methodsFor: 'testing' !
testSetup
	self exercise: NIBA new value: 1.
	self exercise: NIBB new value: 1.
	self exercise: NIBC new value: 1.
	self exercise: NIBD new value: 1.
! !

"April 4, 2009 -> 19:2:59"!

"System saved" !
"April 4, 2009 -> 23:38:0"!

! (Delta mirrorFor: #NonInlinedBlockTest) methodsFor: 'testing' !
exercise: nib value: value
	|set|
	set := Set new.
	[nib do: [:a | a isNil
						ifFalse: [set add: a]]
		value: value] value! !

"April 4, 2009 -> 23:40:1"!

"System saved" !
"April 5, 2009 -> 11:48:28"!

! (Delta mirrorFor: #NonInlinedBlockTest) methodsFor: 'testing' !
exercise: nib value: value
	|set|
	set := Set new.
	[nib do: [:a | a isNil
							ifFalse: [set add: a].
						self assert: [a notNil]]
		value: value] value! !

"April 5, 2009 -> 11:49:39"!

! (Delta mirrorFor: #NonInlinedBlockTest) methodsFor: 'testing' !
exercise: nib value: value
	|set|
	set := Set new.
	[nib do: [:a | a isNil
							ifFalse: [set add: a].
						a assert: [a notNil]]
		value: value] value! !

"April 5, 2009 -> 11:50:0"!

"System saved" !
"April 5, 2009 -> 13:48:36"!

! (Delta mirrorFor: #NonInlinedBlockTest) methodsFor: 'testing' !
exercise: nib value: value
	|set|
	set := Set new.
	[:val1 | nib do: [:a | a isNil
										ifFalse: [set add: a].
									a assert: [a notNil]]
		value: val1] value: value! !

"April 5, 2009 -> 13:49:10"!

"System saved" !
"April 5, 2009 -> 14:7:4"!

! (Delta mirrorFor: #NonInlinedBlockTest) methodsFor: 'testing' !
exercise: nib value: value
	|set|
	set := Set new.
	nib do: [:val | [:a | a isNil
									ifFalse: [set add: a].
								a assert: [a notNil]]
								value: val]
		value: value! !

"April 5, 2009 -> 14:7:28"!

"System saved" !
"April 12, 2009 -> 2:21:54"!

! (Delta mirrorFor: #NonInlinedBlockTest) methodsFor: 'initialize-release' !
initialize! !

"April 12, 2009 -> 2:23:34"!

! (Delta mirrorFor: #NonInlinedBlockTest) classSide methodsFor: 'instance creation' !
new

	^(super new)
		initialize;
		yourself! !

"April 12, 2009 -> 2:23:53"!

Delta define: #NonInlinedBlockTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'a b c d')) !


"April 12, 2009 -> 2:25:4"!

! (Delta mirrorFor: #NonInlinedBlockTest) methodsFor: 'initialize-release' !
initialize

	a := NIBA new.
	b := NIBB new.
	c := NIBC new.
	d :=NIBD new.! !

"April 12, 2009 -> 2:25:24"!

! (Delta mirrorFor: #NonInlinedBlockTest) methodsFor: 'testing' !
testSetup
	self exercise: a value: 1.
	self exercise: b value: 1.
	self exercise: c value: 1.
	self exercise: d value: 1.
! !

"April 12, 2009 -> 2:25:42"!

! (Delta mirrorFor: #NonInlinedBlockTest) methodsFor: 'testing' !
testSetup
	self exercise: a value: 1.
	self exercise: b value: 1.
	self exercise: c value: 1.
	self exercise: d value: 1! !

"April 12, 2009 -> 2:25:55"!

! (Delta mirrorFor: #NonInlinedBlockTest) methodsFor: 'testing' !
testTrap

	self exercise: a value: 1.
	self exercise: a value: 1.0! !

"April 12, 2009 -> 2:29:33"!

! (Delta mirrorFor: #NonInlinedBlockTest) methodsFor: 'testing' !
exercise2: nib value: value
	|set|
	set := Set new.
	nib do: [:val |
					
					val assert: [val notNil].]
		value: value! !

"April 12, 2009 -> 2:33:0"!

! (Delta mirrorFor: #NonInlinedBlockTest) methodsFor: 'testing' !
exercise2: nib value: value
	|set|
	set := Set new.
	nib do: [:val |
					|block|
					block := [val notNil].
					val assert: [block value].
					val noyNil ifTrue: [set add: val]]
		value: value! !

"April 12, 2009 -> 2:33:16"!

! (Delta mirrorFor: #NonInlinedBlockTest) methodsFor: 'testing' !
testSetup2
	self exercise2: a value: 1.
	self exercise2: b value: 1.
	self exercise2: c value: 1.
	self exercise2: d value: 1! !

"April 12, 2009 -> 2:33:23"!

! (Delta mirrorFor: #NonInlinedBlockTest) methodsFor: 'testing' !
testTrap2

	self exercise2: a value: 1.
	self exercise2: a value: 1.0! !

"April 12, 2009 -> 2:34:4"!

! (Delta mirrorFor: #NonInlinedBlockTest) methodsFor: 'testing' !
exercise2: nib value: value
	|set|
	set := Set new.
	nib do: [:val |
					|block|
					block := [val notNil].
					val assert: [block value].
					val notNil ifTrue: [set add: val]]
		value: value! !

"April 12, 2009 -> 2:35:44"!

"System saved" !
"May 4, 2009 -> 14:11:47"!

Delta define: #CompilerTests as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"May 4, 2009 -> 14:12:58"!

Delta define: #CompilerTests as: (
(Class subclassOf: 'TestCase' instanceVariables: 'a')) !


"May 4, 2009 -> 14:13:9"!

! (Delta mirrorFor: #CompilerTests) methodsFor: 'initialise-release' !
setUp

a := NibA new! !

"May 4, 2009 -> 14:13:16"!

Delta define: #CompilerTests as: (
(Class subclassOf: 'TestCase' instanceVariables: 'a b c d')) !


"May 4, 2009 -> 14:13:58"!

! (Delta mirrorFor: #CompilerTests) methodsFor: 'initialise-release' !
setUp

a := NibA new.
b := NibB new.
c := NibC new.
d := NibD new! !

"May 4, 2009 -> 14:14:51"!

! (Delta mirrorFor: #CompilerTests) methodsFor: 'initialise-release' !
setUp

a := NIBA new.
b := NIBB new.
c := NIBC new.
d := NIBD new! !

"May 4, 2009 -> 14:15:58"!

! (Delta mirrorFor: #CompilerTests) methodsFor: 'testing' !
testOnce! !

"May 4, 2009 -> 14:16:8"!

! (Delta mirrorFor: #CompilerTests) methodsFor: 'testing' !
testOnce

	self with: a! !

"May 4, 2009 -> 14:17:59"!

! (Delta mirrorFor: #CompilerTests) methodsFor: 'testing' !
with: value

	value do: [:a|]
		value: 1! !

"May 4, 2009 -> 14:18:23"!

! (Delta mirrorFor: #CompilerTests) methodsFor: 'testing' !
testTwice

	self with: a.
	self with: b! !

"May 4, 2009 -> 14:19:12"!

Delta define: #AbstractCompilerFixture as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 4, 2009 -> 14:19:46"!

! (Delta mirrorFor: #AbstractCompilerFixture) methodsFor: 'test support' !
value

	^self! !

"May 4, 2009 -> 14:20:1"!

Delta define: #FixtureA as: (
(Class subclassOf: 'AbstractCompilerFixture' instanceVariables: '')) !


"May 4, 2009 -> 14:20:11"!

Delta define: #FixtureB as: (
(Class subclassOf: 'AbstractCompilerFixture' instanceVariables: '')) !


"May 4, 2009 -> 14:20:38"!

! (Delta mirrorFor: #CompilerTests) methodsFor: 'initialise-release' !
setUp

a := CompilerFixtureA new.
b := CompilerFixtureB new! !

"May 4, 2009 -> 14:20:54"!

! (Delta mirrorFor: #CompilerTests) methodsFor: 'initialise-release' !
setUp

a := FixtureA new.
b := FixtureB new! !

"May 4, 2009 -> 14:21:0"!

Delta define: #CompilerTests as: (
(Class subclassOf: 'TestCase' instanceVariables: 'a b')) !


"May 4, 2009 -> 14:21:25"!

! (Delta mirrorFor: #CompilerTests) methodsFor: 'testing' !
with: fixture

	^fixture value
	! !

"May 4, 2009 -> 14:22:23"!

! (Delta mirrorFor: #CompilerTests) classSide methodsFor: 'instance creation' !
new

	^(super new)
		initialize;
		release! !

"May 4, 2009 -> 14:22:29"!

! (Delta mirrorFor: #CompilerTests) methodsFor: 'initialise-release' !
initialize

a := FixtureA new.
b := FixtureB new! !

"May 4, 2009 -> 14:22:37"!

! (Delta mirrorFor: #CompilerTests) classSide methodsFor: 'instance creation' !
new

	^(super new)
		initialize;
		yourself! !

"May 4, 2009 -> 14:22:42"!

(Delta mirrorFor: #CompilerTests) removeMethod: #setUp ifAbsent: [] !


"May 4, 2009 -> 14:23:0"!

! (Delta mirrorFor: #CompilerTests) methodsFor: 'initialise-release' !
initialize

	a := FixtureA new.
	b := FixtureB new! !

"May 4, 2009 -> 14:23:46"!

"System saved" !
"May 4, 2009 -> 14:32:48"!

Delta define: #CompilerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'a b')) !


"May 4, 2009 -> 14:32:48"!

(Delta mirrorFor: #CompilerTest)
comment: 
''!


"May 4, 2009 -> 14:32:48"!

! (Delta mirrorFor: #CompilerTest) classSide methodsFor: 'instance creation' !
new

	^(super new)
		initialize;
		yourself! !

"May 4, 2009 -> 14:32:48"!

! (Delta mirrorFor: #CompilerTest) methodsFor: 'initialise-release' !
initialize

	a := FixtureA new.
	b := FixtureB new! !

"May 4, 2009 -> 14:32:48"!

! (Delta mirrorFor: #CompilerTest) methodsFor: 'testing' !
testOnce

	self with: a! !

"May 4, 2009 -> 14:32:48"!

! (Delta mirrorFor: #CompilerTest) methodsFor: 'testing' !
testTwice

	self with: a.
	self with: b! !

"May 4, 2009 -> 14:32:48"!

! (Delta mirrorFor: #CompilerTest) methodsFor: 'testing' !
with: fixture

	^fixture value
	! !

"May 4, 2009 -> 14:33:20"!

(Delta mirrorFor: #CompilerTests) removeDefinitionIfFail: [] !


"May 4, 2009 -> 14:33:33"!

"System saved" !
"May 24, 2009 -> 17:30:28"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildCodeView ^<Visual>

	| cv <CodeView> vmSrc <Str> strm <CharacterReadStream> gls <OrdCltn[CharacterGlyph]> |

	"Construct vm source with highligthed bci"
	vmSrc := self activation vmPrettyPrint.
	strm := vmSrc readStream.
	gls := OrderedCollection[CharacterGlyph] new: vmSrc size.
	(vmSrc occurrencesOf: self currentByteCodeSeparatorCharacter) = 2
		ifTrue: [	gls addAll: (self standardTextForString: (strm upTo: self currentByteCodeSeparatorCharacter) painter: self codePainter).
						gls addAll: (self standardTextForString: (strm upTo: self currentByteCodeSeparatorCharacter) painter: self codeBCIPainter) ].
	gls addAll: (self standardTextForString: strm contentsRemaining painter: self codePainter).
	
	cv := CodeView forText.
	cv doneBlock: [ :b <Boolean> :onSuccess <[]> | b ifTrue: onSuccess ].	"Dummy for now, we are not showing the real source code"
	cv model: gls.
	^self editorBorderFor: cv
! !

"May 24, 2009 -> 17:34:19"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildActions ^ <Visual>

	| row <Row[Visual]> |

	row := Row[Button] new.
	row add: (Button labeled: 'Step' action: [:b <Button> | ]).
	
	^row! !

"May 24, 2009 -> 17:35:46"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildBody ^<Visual>

	| col <Column[Visual]> |

	col := Column[Visual] new.
	col add: self buildActions;
		add: self buildCodeView.
	^col
! !

"May 24, 2009 -> 17:38:44"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildActions ^ <Visual>

	| row <Row[Visual]> |

	row := Row[Button] new.
	row add: (Button labeled: 'Step into' action: [:b <Button> | ]).
	row add: (Button labeled: 'Step over' action: [:b <Button> | ]).
	row add: (Button labeled: 'Step out' action: [:b <Button> | ]).
	^row! !

"May 26, 2009 -> 11:30:17"!

"System saved" !
"May 30, 2009 -> 20:33:29"!

! (Delta mirrorFor: #ActivationOutliner) classSide methodsFor: 'instance creation' !
on: a <Activation> debugger: debugger<StackTraceInspector> ^ <Instance>

	^self new initActivation: a! !

"May 30, 2009 -> 20:33:29"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'private' !
buildBareVisualTop: top <Boolean> ^ <Visual>

	| stack <Array[Activation]> col <Column[Visual]> start <Int> |
	stack := self process activationStack.
	col := Column[Visual] new.
	start := 1 + self process processError topFramesIgnored.
	
	"Add first activation open"
	self assert: [ start < stack size ].
	col add: ((ActivationOutliner
						on: (stack at: start)
						debugger: self)
							open: true;
							imbeddedVisual) .
	start+1 to: stack size do: [ :i <Int> |
		| a <Activation> |
		a := stack at: i.
		a isBlockValueActivation
			ifFalse: [	col add: (ActivationOutliner on: a) imbeddedVisual ]
	].
	^col
! !

"May 30, 2009 -> 20:33:29"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private-initialization' !
initActivation: a <Activation> debugger: d <StackTraceInspector>

	activation := a! !

"May 30, 2009 -> 20:33:29"!

! (Delta mirrorFor: #ActivationOutliner) classSide methodsFor: 'instance creation' !
on: a <Activation> debugger: debugger<StackTraceInspector> ^ <Instance>

	^self new initActivation: a debugger: debugger! !

"May 30, 2009 -> 20:33:29"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:29"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:29"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:29"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:29"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:29"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:29"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:29"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:29"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:29"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:29"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:29"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private-initialization' !
initActivation: a <Activation> debugger: d <StackTraceInspector>

	activation := a.
	debugger := d! !

"May 30, 2009 -> 20:33:29"!

! (Delta mirrorFor: #ActivationOutliner) classSide methodsFor: 'instance creation' !
on: a <Activation> debugger: debugger<StackTraceInspector> ^ <Instance>

	^self new initActivation: a! !

"May 30, 2009 -> 20:33:30"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'private' !
buildBareVisualTop: top <Boolean> ^ <Visual>

	| stack <Array[Activation]> col <Column[Visual]> start <Int> |
	stack := self process activationStack.
	col := Column[Visual] new.
	start := 1 + self process processError topFramesIgnored.
	
	"Add first activation open"
	self assert: [ start < stack size ].
	col add: ((ActivationOutliner
						on: (stack at: start)
						debugger: self)
							open: true;
							imbeddedVisual) .
	start+1 to: stack size do: [ :i <Int> |
		| a <Activation> |
		a := stack at: i.
		a isBlockValueActivation
			ifFalse: [	col add: (ActivationOutliner on: a) imbeddedVisual ]
	].
	^col
! !

"May 30, 2009 -> 20:33:30"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private-initialization' !
initActivation: a <Activation> debugger: d <StackTraceInspector>

	activation := a! !

"May 30, 2009 -> 20:33:30"!

! (Delta mirrorFor: #ActivationOutliner) classSide methodsFor: 'instance creation' !
on: a <Activation> debugger: debugger<StackTraceInspector> ^ <Instance>

	^self new initActivation: a debugger: debugger! !

"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"May 30, 2009 -> 20:33:30"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private-initialization' !
initActivation: a <Activation> debugger: d <StackTraceInspector>

	activation := a.
	debugger := d! !

"May 30, 2009 -> 20:39:16"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'control' !
singleStep: activation

	Transcript cr;
		show: 'single step for: '.
	activation printOn: Transcript.
	Transcript cr! !

"May 30, 2009 -> 20:39:30"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'control' !
singleStep: activation <Activation>

	Transcript cr;
		show: 'single step for: '.
	activation printOn: Transcript.
	Transcript cr! !

"May 30, 2009 -> 20:40:30"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildActions ^ <Visual>

	| row <Row[Visual]> |

	row := Row[Button] new.
	row add: (Button
						labeled: 'Step into'
						action: [:b <Button> | debugger singleStep: self]).
	row add: (Button labeled: 'Step over' action: [:b <Button> | ]).
	row add: (Button labeled: 'Step out' action: [:b <Button> | ]).
	^row! !

"May 30, 2009 -> 20:53:7"!

"System saved" !
"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>')) !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>')) !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>')) !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>')) !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>')) !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>')) !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

! (Delta mirrorFor: #StackTraceInspector) classSide methodsFor: 'private - accessing' !
debuggers ^<Dict[Process,StackTraceInspector]>

	Debuggers isNil
		ifTrue: [Debuggers := Dictionary[Process, StackTraceInspector] new].
	^Debuggers! !

"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:1"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"May 30, 2009 -> 22:6:4"!

! (Delta mirrorFor: #StackTraceInspector) classSide methodsFor: 'instance creation' !
on: p <Process> ^ <Instance>

	|debugger|
	(debugger := self new) initProcess: p.
	self debuggers at: p put: debugger.
	^debugger! !

"May 30, 2009 -> 22:6:4"!

! (Delta mirrorFor: #StackTraceInspector) classSide methodsFor: 'private - accessing' !
removeDebugger: debugger <StackTraceInspector>

	self debuggers
		remove: debugger process
		ifAbsent: []! !

"May 30, 2009 -> 22:6:4"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'private' !
remove

	self class removeDebugger: self! !

"May 30, 2009 -> 22:6:4"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'control' !
abortProcess

	"Process get aborted by default when stack trace inspector is closed"
	self remove.
	self requestCloseIfTopWindow.

! !

"May 30, 2009 -> 22:6:4"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'control' !
continueProcess

	|topWindow|
	self remove.
	self process resume.
	self process: nil.		"Don't terminate process when window closes"
	topWindow := self visual topWindow.
	topWindow isNil
		ifFalse: [topWindow requestClose]! !

"May 30, 2009 -> 22:6:4"!

! (Delta mirrorFor: #StackTraceInspector) classSide methodsFor: 'private - accessing' !
removeDebugger: debugger <StackTraceInspector>

	self debuggers
		removeAt: debugger process
		ifAbsent: []! !

"May 30, 2009 -> 22:7:32"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'private' !
addActivationsTo: col <Column[Visual]>

	| stack <Array[Activation]> start <Int> |
	stack := self process activationStack.
	start := 1 + self process processError topFramesIgnored.
	
	"Add first activation open"
	self assert: [ start < stack size ].
	col add: ((ActivationOutliner
						on: (stack at: start)
						debugger: self)
							open: true;
							imbeddedVisual) .
	start+1 to: stack size do: [ :i <Int> |
		| a <Activation> |
		a := stack at: i.
		a isBlockValueActivation
			ifFalse: [	col add: (ActivationOutliner
											on: a
											debugger: self) imbeddedVisual ]
	]! !

"May 30, 2009 -> 22:8:6"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'private' !
buildBareVisualTop: top <Boolean> ^ <Visual>

	activationOutliners := Column[Visual] new.
	self addActivationsTo: activationOutliners.
	^activationOutliners
! !

"May 30, 2009 -> 22:9:47"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'private' !
rebuild

	activationOutliners removeAll.
	self addActivationsTo: activationOutliners! !

"May 30, 2009 -> 22:11:31"!

! (Delta mirrorFor: #StackTraceInspector) classSide methodsFor: 'instance creation' !
openOn: p <Process>
	|debugger|
	debugger := self debuggers at: p.
	debugger isNil
		ifTrue: [(self on: p) launch]
		ifFalse: [debugger rebuild]! !

"May 30, 2009 -> 22:17:19"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'private' !
outlinerFor: activation <Activation> open: b <Boolean>

	^(ActivationOutliner
			on: activation
			debugger: self)
				open: b;
				imbeddedVisual! !

"May 30, 2009 -> 22:18:22"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'private' !
addActivationsTo: col <Column[Visual]>

	| stack <Array[Activation]> start <Int> |
	stack := self process activationStack.
	start := 1 + self process processError topFramesIgnored.
	
	"Add first activation open"
	self assert: [ start < stack size ].
	col add: (self outlinerFor: (stack at: start)
						open: true).
	start+1 to: stack size do: [ :i <Int> |
		| a <Activation> |
		a := stack at: i.
		a isBlockValueActivation
			ifFalse: [	col add: (ActivationOutliner
											on: a
											debugger: self) imbeddedVisual ]
	]! !

"May 30, 2009 -> 22:19:25"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'private' !
addActivationsTo: col <Column[Visual]>

	| stack <Array[Activation]> start <Int> |
	stack := self process activationStack.
	start := 1 + self process processError topFramesIgnored.
	
	"Add first activation open"
	self assert: [ start < stack size ].
	col add: (self outlinerFor: (stack at: start)
						open: true).
	start+1 to: stack size do: [ :i <Int> |
		| a <Activation> |
		a := stack at: i.
		a isBlockValueActivation
			ifFalse: [	col add: (self outlinerFor: a open: false) ]
	]! !

"May 31, 2009 -> 1:40:9"!

"System saved" !
"May 31, 2009 -> 1:46:57"!

! (Delta mirrorFor: #StackTraceInspector) classSide methodsFor: 'instance creation' !
openOn: p <Process>
	
	(self debuggers
				at: p
				ifAbsent: [(self on: p) launch. ^self]) rebuild! !

"May 31, 2009 -> 1:48:19"!

"System saved" !
"May 31, 2009 -> 1:49:31"!

! (Delta mirrorFor: #Launcher) classSide methodsFor: 'control' !
startProgEnv ^<Instance>

	| launcher <Instance> |
	self createUITranscript.
	
	"Register stophandler for process scheduler"
	Processor stopHandler: [ :p <Process> | StackTraceInspector openOn: p ].

	launcher := (self new) launch; yourself.

	"Don't launch start page if system is inconsistent so that it won't
		obscure the error messages in the transcript"
	SourceHandler systemIsConsistent
		ifTrue: [ [ launcher browseStartPage ] fork. ]. 

	^launcher
! !

"May 31, 2009 -> 1:49:41"!

"System saved" !
"May 31, 2009 -> 1:54:7"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'control' !
singleStep: activation <Activation>

	{{primitiveProcessSingleStep: self process ifFail: [:err <Symbol> | self error: err]}}! !

"May 31, 2009 -> 1:55:49"!

"System saved" !
"May 31, 2009 -> 2:3:17"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'control' !
singleStep: activation <Activation>

	{{primitiveProcessSingleStep: self process ifFail: [:err <Symbol> | self error: err]}}.
	self process resume! !

"May 31, 2009 -> 2:3:29"!

"System saved" !
"May 31, 2009 -> 11:42:39"!

! (Delta mirrorFor: #StackTraceInspector) classSide methodsFor: 'instance creation' !
openOn: p <Process>
	
	(self debuggers
				at: p
				ifAbsent: [^(self on: p) launch]) rebuild! !

"May 31, 2009 -> 11:42:39"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'private' !
addActivationsTo: col <Column[Visual]>

	| stack <Array[Activation]> start <Int> |
	stack := self process activationStack.
	start := 1 "+ self process processError topFramesIgnored".
	
	"Add first activation open"
	self assert: [ start < stack size ].
	col add: (self outlinerFor: (stack at: start)
						open: true).
	start+1 to: stack size do: [ :i <Int> |
		| a <Activation> |
		a := stack at: i.
		a isBlockValueActivation
			ifFalse: [	col add: (self outlinerFor: a open: false) ]
	]! !

"May 31, 2009 -> 11:42:49"!

"System saved" !
"June 1, 2009 -> 20:53:28"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'private' !
rebuild

	self inSessionProcessDo:
		[activationOutliners removeAll.
		self addActivationsTo: activationOutliners]! !

"June 1, 2009 -> 20:53:39"!

"System saved" !
"June 9, 2009 -> 1:53:0"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'control' !
stepNext: activation <Activation>

	{{primitiveActivationStepNext: activation ifFail: [:err <Symbol> | self error: err]}}.
	self process resume! !

"June 9, 2009 -> 1:54:39"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildActions ^ <Visual>

	| row <Row[Visual]> |

	row := Row[Button] new.
	row add: (Button
						labeled: 'Step into'
						action: [:b <Button> | debugger singleStep: self activation]).
	row add: (Button 
						labeled: 'Step over'
						action: [:b <Button> | debugger stepNext: self activation]).
	row add: (Button labeled: 'Step out' action: [:b <Button> | ]).
	^row! !

"June 9, 2009 -> 1:54:58"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'control' !
stepReturn: activation <Activation>

	{{primitiveActivationStepNext: activation ifFail: [:err <Symbol> | self error: err]}}.
	self process resume! !

"June 9, 2009 -> 1:55:42"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildActions ^ <Visual>

	| row <Row[Visual]> |

	row := Row[Button] new.
	row add: (Button
						labeled: 'Step into'
						action: [:b <Button> | debugger singleStep: self activation]).
	row add: (Button 
						labeled: 'Step over'
						action: [:b <Button> | debugger stepNext: self activation]).
	row add: (Button
						labeled: 'Step out'
						action: [:b <Button> | debugger stepReturn: self activation]).
	^row! !

"June 9, 2009 -> 1:56:0"!

"System saved" !
"June 9, 2009 -> 23:47:44"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'control' !
stepReturn: activation <Activation>

	{{primitiveActivationStepReturn: activation ifFail: [:err <Symbol> | self error: err]}}.
	self process resume! !

"June 9, 2009 -> 23:49:12"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'control' !
singleStep: activation <Activation>

	{{primitiveActivationSingleStep: activation ifFail: [:err <Symbol> | self error: err]}}.
	self process resume! !

"June 9, 2009 -> 23:49:44"!

"System saved" !
"June 9, 2009 -> 23:52:12"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'private' !
step: activation setup: block

	block value: activation.
	self process resume! !

"June 9, 2009 -> 23:53:58"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'control' !
singleStep: activation <Activation>

	self resumeAfter: [{{primitiveActivationSingleStep: activation
										ifFail: [:err <Symbol> | self error: err]}}]! !

"June 9, 2009 -> 23:54:19"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'private' !
resumeAfter: block

	block value.
	self process resume! !

"June 9, 2009 -> 23:54:53"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'control' !
stepNext: activation <Activation>

	self resumeAfter: [{{primitiveActivationStepNext: activation
										ifFail: [:err <Symbol> | self error: err]}}]! !

"June 9, 2009 -> 23:55:15"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'control' !
stepReturn: activation <Activation>

	self resumeAfter: [{{primitiveActivationStepReturn: activation
										ifFail: [:err <Symbol> | self error: err]}}]! !

"June 9, 2009 -> 23:55:24"!

"System saved" !
"June 19, 2009 -> 0:13:15"!

Delta define: #MacOSXPlatform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"June 19, 2009 -> 0:13:15"!

(Delta mirrorFor: #MacOSXPlatform)
comment: 
'The class side holds platform dependent constants and utilities.  Is also used
to get command line args, and other things like that.

Keywords: %machdep  %User

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.4 $
'!


"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLInitialize
    DLLDict := Dictionary new.
    {{primitiveDLLSetupLookup: self selector: #DLLLookup:in: ifFail: [:err | self error: err]}}! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLLibrary: name
    ^DLLDict at: name ifAbsent: [
        DLLDict at: name put: (self DLLLoad: name)
    ]! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLLoad: name
    | r n |
    r := ExternalProxy new.
    n := (self DLLMapName: name) asSymbol.
    ^{{primitiveDLLLoad: n result: r ifFail: [ :err | self error: err]}}! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLLookup: name <Str> in: library <Str>
    "Convert library into proxy"
    | p r |
    p := self DLLLibrary: library.
    r := ExternalProxy new.
    {{primitiveDLLLookup: name asSymbol in: p result: r ifFail: [:err | self error: err]}}.
    ^r! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLMapName: name <Str> ^<Str>
    name = 'libc' ifTrue: [^'libc.dylib'].
    ^name, '.so'! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'clipboard access' !
clipboardText: str <Str>

    self openClipboard.
    [   | glob <HGLOBAL> strm <ReadWriteStream[Character]> xstr <Str> |
        self emptyClipboard.

        "transform string into a form with lfs inserted"
        strm := (String new: str size) readWriteStream.
        str do:
            [ :c <Character> |
                strm put: c.
                c = Character cr
                    ifTrue: [ strm put: Character lf ].
            ].
        xstr := String withAll: strm contentsWritten.

        glob := HGLOBAL new
                        allocate: xstr size + 1
                        attributes: (Win32 GMEM_MOVEABLE
                                            externalBitOr: Win32 GMEM_DDESHARE).
        glob withPointer: CString new
                do: [ :cs <CString> |
                            cs value: xstr   ].

        {{<user ExternalProxy SetClipboardData>
                format: Win32 CF_TEXT
                data: glob
        }} isNull
            ifTrue: [ Win32 handleError ].
    ] ensure:
        [ self closeClipboard ]! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'clipboard access' !
clipboardTextIfAbsent: blk <[^X def]> ^<Str | X>

    self openClipboard.
    [   | glob <HGLOBAL> strm <CharWriteStream> |

        {{<user ExternalProxy IsClipboardFormatAvailable> format: Win32 CF_TEXT}} asBoolean
            ifFalse: [ ^blk value ].
        glob := {{<user HGLOBAL GetClipboardData> format: Win32 CF_TEXT}}.
        glob isNull
            ifTrue: [ Win32 handleError ].
        strm := (String new: 100) writeStream.
        glob withPointer: CString new
                do: [ :cs <CString> |
                            cs asString do:
                                [ :c <Character> |
                                    c = Character lf
                                        ifFalse: [ strm put: c ]
                                ].
                            ^strm contentsWritten
                      ].
    ] ensure:
        [ self closeClipboard ]! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'command line' !
commandLine ^<Str>
   ^self getCommandLine! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'command line' !
commandLineTokens ^<InputStream[Str]>
    "a stream of the input line tokens.  Tokens are sequences separated by whitespace; whitespace can be 
        included in a token by double quoting the arg.  (quotes can be imbedded by doubling, as with Smalltalk strings;
        the returned token has delimiting quotes removed and internal quotes undoubled. "

    | cstrm <CharInputStream> |
    cstrm := self commandLine readStream.
    self skipSpacesIn: cstrm.
    ^CustomInputStream[Str] new
            nextBlock: [    self parseArgFrom: cstrm ];
            atEndBlock: [ cstrm atEnd ].! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'command line' !
getArguments ^<OrdCltn[Str]>

    ^ {{ primitiveCommandLineArgs }} asOrderedCollection
    	collect: [:bytes| bytes asString]! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'command line' !
getCommandLine
    | stream |
    stream := CharacterReadWriteStream on: ''.
    self getArguments do: [:arg| stream nextPutAll: arg; space].
    stream isEmpty ifTrue: [^''].
    ^stream copyFrom: 1 to: stream size - 1! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'constants' !
multipleMatchWildcardCharacter ^<Character>

    ^$*! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'constants' !
singleMatchWildcardCharacter ^<Character>

    ^$?! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'constants' !
wordSize ^<Int>
    ^4! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'environment' !
environmentVariableAt: key <Str> ifAbsent: blk <[^X def]> ^ <Str | X>

    | cKey <CString> cValue <CString> |
    cKey := CString for: key.
    [cValue := {{<libc CString getenv> key: cKey}}.
    ^cValue isNull
    	ifTrue: [blk value]
    	ifFalse: [cValue asString]]
    	ensure: [cKey free]! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'initialization' !
initialize

    self DLLInitialize! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'os specific' !
currentThreadId
	"^ 0"
	^ {{ primitiveCurrentThreadId }}! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'os streams' !
errorStream ^<CharOutputStream>

    ErrorStream isNil
        ifTrue: [   ErrorStream := TempTranscript new ].
    ^ErrorStream! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'platform classes' !
pathClass ^<FilePath class>

    ^UnixFilePath! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'platform classes' !
patternClass ^<FilePattern class>

    ^UnixFilePattern! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'private' !
parseArgFrom: strm <CharInputStream>  ^<Str>

    ^strm peek = $"
        ifTrue: [       strm next.
                        strm upTo: $"   ]
        ifFalse: [  strm upTo: Character space ]! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'private' !
skipSpacesIn: strm <CharInputStream>

    [ strm atEnd not and: [ strm peekFor: Character space] ] whileTrue.
! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'private-clipboard access' !
closeClipboard

    {{<user ExternalProxy CloseClipboard> call}}! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'private-clipboard access' !
emptyClipboard

    {{<user ExternalProxy EmptyClipboard> call}} asBoolean
        ifFalse: [ Win32 handleError ].
! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'private-clipboard access' !
openClipboard

    {{<user ExternalProxy OpenClipboard> hnd: Win32 NULL}} asBoolean
        ifFalse: [ Win32 handleError ].
! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'testing' !
usesCrLfConvention ^<Boolean>

    ^false! !

"June 19, 2009 -> 0:13:15"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t tm |
	t := TimeT new allocate.
	[{{<libc ExternalProxy time> struct: t}} isAllOnes
		ifTrue: [self error: 'Invalid time'].
	tm := {{<libc TM gmtime>
					struct: t}}.
	^tm asSYSTEMTIME] ensure: [t free]
! !

"June 19, 2009 -> 0:13:55"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLMapName: name <Str> ^<Str>
    name = 'libc' ifTrue: [^'libc.dylib'].
    ^name, '.dylib'! !

"June 19, 2009 -> 0:14:50"!

"System saved" !
"June 19, 2009 -> 0:34:6"!

Delta define: #MacOSXFileDescriptor as: (
(Class subclassOf: 'UnixFileDescriptor' instanceVariables: '')) !


"June 19, 2009 -> 0:35:3"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
fileDescriptorClass ^<FileDescriptor class>
"%TODO delegate to Platform"
    ^UnixFileDescriptor! !

"June 19, 2009 -> 0:35:31"!

Delta define: #MacOSXFilePath as: (
(Class subclassOf: 'UnixFilePath' instanceVariables: '')) !


"June 19, 2009 -> 0:35:50"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'platform classes' !
pathClass ^<FilePath class>

    ^MacOSXFilePath! !

"June 19, 2009 -> 0:36:31"!

! (Delta mirrorFor: #MacOSXFilePath) methodsFor: 'private' !
fileDescriptorClass ^<FileDescriptor class>
"%TODO delegate to Platform"
    ^MacOSXFileDescriptor! !

"June 19, 2009 -> 0:37:18"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'accessing' !
blockSize ^<Int>
    "Use the sector size"
    | statBuffer <StatBuffer> 
    	status <ExternalProxy> |
    statBuffer := StatBuffer new.
    statBuffer allocate.
    [ status := {{<libc ExternalProxy fxstat>
    					version: statBuffer version
            			name: self handle
            			buffer: statBuffer    }}.
	^status asSmallInteger == -1
		ifTrue: [4096]
		ifFalse: [ statBuffer blockSize ]]
		ensure: [ statBuffer free]! !

"June 19, 2009 -> 0:48:25"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'accessing' !
blockSize ^<Int>
    "Use the sector size"
    | statBuffer <StatBuffer> 
    	status <ExternalProxy> |
    statBuffer := StatBuffer new.
    statBuffer allocate.
    [ status := {{<libc ExternalProxy fstat>
    					version: statBuffer version
            			name: self handle
            			buffer: statBuffer    }}.
	^status asSmallInteger == -1
		ifTrue: [4096]
		ifFalse: [ statBuffer blockSize ]]
		ensure: [ statBuffer free]! !

"June 19, 2009 -> 0:49:2"!

"System saved" !
"June 19, 2009 -> 0:54:8"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'accessing' !
size ^<Int>
    "Use the sector size"
    | statBuffer <StatBuffer> 
    	status <ExternalProxy> |
    statBuffer := StatBuffer new.
    statBuffer allocate.
    [ status := {{<libc ExternalProxy fxstat>
    					version: statBuffer version
            			name: self handle
            			buffer: statBuffer    }}.
	^status asSmallInteger == -1
		ifTrue: [0]
		ifFalse: [ statBuffer fileSize ]]
		ensure: [ statBuffer free]! !

"June 19, 2009 -> 0:54:28"!

"System saved" !
"June 19, 2009 -> 1:2:32"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'accessing' !
size ^<Int>
    "Use the sector size"
    | statBuffer <StatBuffer> 
    	status <ExternalProxy> |
    statBuffer := StatBuffer new.
    statBuffer allocate.
    [ status := {{<libc ExternalProxy fstat>
    					version: statBuffer version
            			name: self handle
            			buffer: statBuffer    }}.
	^status asSmallInteger == -1
		ifTrue: [0]
		ifFalse: [ statBuffer fileSize ]]
		ensure: [ statBuffer free]! !

"June 19, 2009 -> 1:2:40"!

"System saved" !
"June 23, 2009 -> 21:2:43"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'accessing' !
size ^<Int>
    "Use the sector size"
    | statBuffer <StatBuffer> 
    	status <ExternalProxy> |
    statBuffer := StatBuffer new.
    statBuffer allocate.
    [ status := {{<libc ExternalProxy fstat>
            			name: self handle
            			buffer: statBuffer    }}.
	^status asSmallInteger == -1
		ifTrue: [0]
		ifFalse: [ statBuffer fileSize ]]
		ensure: [ statBuffer free]! !

"June 23, 2009 -> 21:2:45"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'accessing' !
blockSize ^<Int>
    "Use the sector size"
    | statBuffer <StatBuffer> 
    	status <ExternalProxy> |
    statBuffer := StatBuffer new.
    statBuffer allocate.
    [ status := {{<libc ExternalProxy fstat>
            			name: self handle
            			buffer: statBuffer    }}.
	^status asSmallInteger == -1
		ifTrue: [4096]
		ifFalse: [ statBuffer blockSize ]]
		ensure: [ statBuffer free]! !

"June 23, 2009 -> 21:3:11"!

"System saved" !
"June 23, 2009 -> 21:59:1"!

Delta define: #MacOSXStatBuffer as: (
(Class subclassOf: 'StatBuffer' instanceVariables: '')) !


"June 23, 2009 -> 21:59:35"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'private' !
statBufferClass

	^MacOSXStatBuffer! !

"June 23, 2009 -> 22:0:15"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'accessing' !
size ^<Int>
    "Use the sector size"
    | statBuffer <StatBuffer> 
    	status <ExternalProxy> |
    statBuffer := self statBufferClass new.
    statBuffer allocate.
    [ status := {{<libc ExternalProxy fstat>
            			name: self handle
            			buffer: statBuffer    }}.
	^status asSmallInteger == -1
		ifTrue: [0]
		ifFalse: [ statBuffer fileSize ]]
		ensure: [ statBuffer free]! !

"June 23, 2009 -> 22:0:17"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'accessing' !
blockSize ^<Int>
    "Use the sector size"
    | statBuffer <StatBuffer> 
    	status <ExternalProxy> |
    statBuffer := self statBufferClass new.
    statBuffer allocate.
    [ status := {{<libc ExternalProxy fstat>
            			name: self handle
            			buffer: statBuffer    }}.
	^status asSmallInteger == -1
		ifTrue: [4096]
		ifFalse: [ statBuffer blockSize ]]
		ensure: [ statBuffer free]! !

"June 23, 2009 -> 22:6:38"!

! (Delta mirrorFor: #MacOSXStatBuffer) methodsFor: 'offsets' !
fileSizeOffset

	^48! !

"June 23, 2009 -> 22:6:52"!

! (Delta mirrorFor: #MacOSXStatBuffer) methodsFor: 'offsets' !
blockSizeOffset

	^64! !

"June 23, 2009 -> 22:10:33"!

! (Delta mirrorFor: #MacOSXStatBuffer) methodsFor: 'accessing' !
structureSize

	^96! !

"June 23, 2009 -> 22:12:6"!

"System saved" !
"June 25, 2009 -> 0:52:52"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'accessing' !
stat: block ifFail: failBlock

    | statBuffer <StatBuffer> 
    	status <ExternalProxy> |
    statBuffer := self statBufferClass new.
    statBuffer allocate.
    [ status := {{<libc ExternalProxy fstat>
            			name: self handle
            			buffer: statBuffer    }}.
	^status asSmallInteger == -1
		ifTrue: [failBlock value]
		ifFalse: [ block value: statBuffer ]]
			ensure: [ statBuffer free]

	! !

"June 25, 2009 -> 0:53:35"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'accessing' !
blockSize ^<Int>
    "Use the sector size"
    ^self stat: [:buffer| buffer blockSize]
    		ifFail: [4096]! !

"June 25, 2009 -> 0:53:58"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'accessing' !
size ^<Int>
    "Use the sector size"
    ^self stat: [:buffer| buffer fileSize]
    		ifFail: [0]! !

"June 25, 2009 -> 1:7:41"!

! (Delta mirrorFor: #ExternalReadWriteStream) classSide methodsFor: 'testing' !
test
    "self test"
    |    file <FilePath>
        sz <Int>
        read <ExternalReadStream>
        write <ExternalReadWriteStream>
        in <CharInStream>
        out <CharOutStream>
        bytes <ByteArray>
        s <Str> |
    file := FilePath for: 'deltatest.tmp'.
    sz := 12345.    "make sure this number is much greater than the stream buffer size" 
    write := file writeStream.
    0 to: sz-1 do: 
        [ :i <Int> |
            write nextPut: i \\ 100.    ].
    self test: 1 is: [ write size = sz ].
    write position: 5001.
    write nextPut: 123.
    write close.
    write := file readWriteStream.
    write position: 5000.
    write nextPut: 12.
    self test: 2 is: [ write next = 123 ].
    write setToEnd.
    bytes := write contentsWritten.
    self test: 3 is: [ Transcript show: 'actual: '; print: bytes size; show: ', expected: '; print: sz;cr. bytes size = sz ].
    write close.
    read := file readStream.
    self test: 4 is: [ read peek = 0 ].
    self test: 5 is: [ read size = sz ].
    0 to: sz-1 do:
        [ :i <Int> |
            | byte <Int> |
            byte := read next.
            self test: 6 is:
                [ i ~= 5001
                    ifTrue: [ i ~= 5000
                                ifTrue: [ (i \\ 100) = byte ]
                                ifFalse: [ byte = 12 ]    ]
                    ifFalse: [ byte = 123 ]    ].
            self test: 7 is: [ (bytes at: i + 1) = byte ].    ].

    self test: 8 is: [ read atEnd ].
    read position: 5001.

    self test: 9 is: [ read next = 123 ].
    read position: 0.

    self test: 10 is: [ bytes = read contentsRemaining ].
    read close.
    out := file charOutputStream.
    s := 'hi 
there'.
    out nextPutAll: s.
    out close.
    in := file charInputStream.

    self test: 11 is: [ in peek = (s at: 1) ].

    1 to: s size do: 
        [ :i <Int> |
            self test: 12 is: [
				| n |
				n := in next.
				(s at: i) =  n].    ].

    self test: 13 is: [ in atEnd ].
    in close.
    in := file charInputStream.

    self test: 14 is: [ in contentsRemaining = s ].
    in close.! !

"June 25, 2009 -> 1:8:54"!

"System saved" !
"June 25, 2009 -> 21:58:12"!

Delta define: #Counter as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 25, 2009 -> 21:58:36"!

Delta define: #Counter as: (
(Class subclassOf: 'Object' instanceVariables: 'count')) !


"June 25, 2009 -> 21:59:0"!

! (Delta mirrorFor: #Counter) methodsFor: 'initialization' !
initialize

	count := 0! !

"June 25, 2009 -> 21:59:31"!

! (Delta mirrorFor: #Counter) classSide methodsFor: 'instance creation' !
new

	^(super new)
		initialize;
		yourself! !

"June 25, 2009 -> 22:0:29"!

! (Delta mirrorFor: #Counter) methodsFor: 'updating' !
preinc

	^count := count + 1! !

"June 25, 2009 -> 22:1:12"!

! (Delta mirrorFor: #Counter) methodsFor: 'updating' !
postinc

	^[count] ensure: [count := count + 1]! !

"June 25, 2009 -> 22:4:23"!

! (Delta mirrorFor: #ExternalReadWriteStream) classSide methodsFor: 'testing' !
test
    "self test"
    |    file <FilePath>
        sz <Int>
        read <ExternalReadStream>
        write <ExternalReadWriteStream>
        in <CharInStream>
        out <CharOutStream>
        bytes <ByteArray>
        s <Str> 
        testCount <Counter>
        test <Integer> |
    testCount := Counter new.
    file := FilePath for: 'deltatest.tmp'.
    sz := 12345.    "make sure this number is much greater than the stream buffer size" 
    write := file writeStream.
    0 to: sz-1 do: 
        [ :i <Int> |
            write nextPut: i \\ 100.    ].
    self test: testCount preinc is: [ write size = sz ].
    write position: 5001.
    write nextPut: 123.
    write close.
    write := file readWriteStream.
    write position: 5000.
    write nextPut: 12.
    self test: testCount preinc is: [ write next = 123 ].
    write setToEnd.
    bytes := write contentsWritten.
    self test: testCount preinc is: [ Transcript show: 'actual: '; print: bytes size; show: ', expected: '; print: sz;cr. bytes size = sz ].
    write close.
    read := file readStream.
    self test: testCount preinc is: [ read peek = 0 ].
    self test: testCount preinc is: [ read size = sz ].
    test := testCount preinc.
    0 to: sz-1 do:
        [ :i <Int> |
            | byte <Int> |
            byte := read next.
            self test: 6 is:
                [ i ~= 5001
                    ifTrue: [ i ~= 5000
                                ifTrue: [ (i \\ 100) = byte ]
                                ifFalse: [ byte = 12 ]    ]
                    ifFalse: [ byte = 123 ]    ].
            self test: test is: [ (bytes at: i + 1) = byte ].    ].

    self test: testCount preinc is: [ read atEnd ].
    read position: 5001.

    self test: testCount preinc is: [ read next = 123 ].
    read position: 0.

    self test: testCount preinc is: [ bytes = read contentsRemaining ].
    read close.
    out := file charOutputStream.
    s := 'hi 
there'.
    out nextPutAll: s.
    out close.
    in := file charInputStream.

    self test: testCount preinc is: [ in peek = (s at: 1) ].

	test := testCount preinc.
    1 to: s size do: 
        [ :i <Int> |
            self test: 12 is: [
				| n |
				n := in next.
				(s at: i) =  n].    ].

    self test: testCount preinc is: [ in atEnd ].
    in close.
    in := file charInputStream.

    self test: testCount preinc is: [ in contentsRemaining = s ].
    in close.! !

"June 25, 2009 -> 22:5:32"!

"System saved" !
"June 25, 2009 -> 22:8:54"!

! (Delta mirrorFor: #ExternalReadWriteStream) classSide methodsFor: 'testing' !
test
    "self test"
    |    file <FilePath>
        sz <Int>
        read <ExternalReadStream>
        write <ExternalReadWriteStream>
        in <CharInStream>
        out <CharOutStream>
        bytes <ByteArray>
        s <Str> 
        testCount <Counter>
        test <Integer> |
    testCount := Counter new.
    file := FilePath for: 'deltatest.tmp'.
    sz := 12345.    "make sure this number is much greater than the stream buffer size" 
    write := file writeStream.
    0 to: sz-1 do: 
        [ :i <Int> |
            write nextPut: i \\ 100.    ].
    self test: testCount preinc is: [ write size = sz ].
    write position: 5001.
    write nextPut: 123.
    write close.
    write := file readWriteStream.
    write position: 5000.
    write nextPut: 12.
    self test: testCount preinc is: [ write next = 123 ].
    write setToEnd.
    bytes := write contentsWritten.
    self test: testCount preinc is: [ write atEnd ].
    self test: testCount preinc is: [ Transcript show: 'actual: '; print: bytes size; show: ', expected: '; print: sz;cr. bytes size = sz ].
    write close.
    read := file readStream.
    self test: testCount preinc is: [ read peek = 0 ].
    self test: testCount preinc is: [ read size = sz ].
    test := testCount preinc.
    0 to: sz-1 do:
        [ :i <Int> |
            | byte <Int> |
            byte := read next.
            self test: 6 is:
                [ i ~= 5001
                    ifTrue: [ i ~= 5000
                                ifTrue: [ (i \\ 100) = byte ]
                                ifFalse: [ byte = 12 ]    ]
                    ifFalse: [ byte = 123 ]    ].
            self test: test is: [ (bytes at: i + 1) = byte ].    ].

    self test: testCount preinc is: [ read atEnd ].
    read position: 5001.

    self test: testCount preinc is: [ read next = 123 ].
    read position: 0.

    self test: testCount preinc is: [ bytes = read contentsRemaining ].
    read close.
    out := file charOutputStream.
    s := 'hi 
there'.
    out nextPutAll: s.
    out close.
    in := file charInputStream.

    self test: testCount preinc is: [ in peek = (s at: 1) ].

	test := testCount preinc.
    1 to: s size do: 
        [ :i <Int> |
            self test: 12 is: [
				| n |
				n := in next.
				(s at: i) =  n].    ].

    self test: testCount preinc is: [ in atEnd ].
    in close.
    in := file charInputStream.

    self test: testCount preinc is: [ in contentsRemaining = s ].
    in close.! !

"June 25, 2009 -> 22:10:13"!

! (Delta mirrorFor: #ExternalReadWriteStream) classSide methodsFor: 'testing' !
test
    "self test"
    |    file <FilePath>
        sz <Int>
        read <ExternalReadStream>
        write <ExternalReadWriteStream>
        in <CharInStream>
        out <CharOutStream>
        bytes <ByteArray>
        s <Str> 
        testCount <Counter>
        test <Integer> |
    testCount := Counter new.
    file := FilePath for: 'deltatest.tmp'.
    sz := 12345.    "make sure this number is much greater than the stream buffer size" 
    write := file writeStream.
    0 to: sz-1 do: 
        [ :i <Int> |
            write nextPut: i \\ 100.    ].
    self test: testCount preinc is: [ write size = sz ].
    write position: 5001.
    write nextPut: 123.
    write close.
    write := file readWriteStream.
    write position: 5000.
    write nextPut: 12.
    self test: testCount preinc is: [ write next = 123 ].
    write setToEnd.
    write position: 0.
    self test: testCount preinc is: [ write position = 0 ].
    bytes := write contentsWritten.
    self test: testCount preinc is: [ write atEnd ].
    self test: testCount preinc is: [ Transcript show: 'actual: '; print: bytes size; show: ', expected: '; print: sz;cr. bytes size = sz ].
    write close.
    read := file readStream.
    self test: testCount preinc is: [ read peek = 0 ].
    self test: testCount preinc is: [ read size = sz ].
    test := testCount preinc.
    0 to: sz-1 do:
        [ :i <Int> |
            | byte <Int> |
            byte := read next.
            self test: 6 is:
                [ i ~= 5001
                    ifTrue: [ i ~= 5000
                                ifTrue: [ (i \\ 100) = byte ]
                                ifFalse: [ byte = 12 ]    ]
                    ifFalse: [ byte = 123 ]    ].
            self test: test is: [ (bytes at: i + 1) = byte ].    ].

    self test: testCount preinc is: [ read atEnd ].
    read position: 5001.

    self test: testCount preinc is: [ read next = 123 ].
    read position: 0.

    self test: testCount preinc is: [ bytes = read contentsRemaining ].
    read close.
    out := file charOutputStream.
    s := 'hi 
there'.
    out nextPutAll: s.
    out close.
    in := file charInputStream.

    self test: testCount preinc is: [ in peek = (s at: 1) ].

	test := testCount preinc.
    1 to: s size do: 
        [ :i <Int> |
            self test: 12 is: [
				| n |
				n := in next.
				(s at: i) =  n].    ].

    self test: testCount preinc is: [ in atEnd ].
    in close.
    in := file charInputStream.

    self test: testCount preinc is: [ in contentsRemaining = s ].
    in close.! !

"June 25, 2009 -> 22:14:40"!

! (Delta mirrorFor: #ExternalReadWriteStream) classSide methodsFor: 'testing' !
test
    "self test"
    |    file <FilePath>
        sz <Int>
        read <ExternalReadStream>
        write <ExternalReadWriteStream>
        in <CharInStream>
        out <CharOutStream>
        bytes <ByteArray>
        s <Str> 
        testCount <Counter>
        test <Integer> |
    testCount := Counter new.
    file := FilePath for: 'deltatest.tmp'.
    sz := 12345.    "make sure this number is much greater than the stream buffer size" 
    write := file writeStream.
    0 to: sz-1 do: 
        [ :i <Int> |
            write nextPut: i \\ 100 + 32.    ].
    self test: testCount preinc is: [ write size = sz ].
    write position: 5001.
    write nextPut: 123.
    write close.
    write := file readWriteStream.
    write position: 5000.
    write nextPut: 12.
    self test: testCount preinc is: [ write next = 123 ].
    write setToEnd.
    write position: 0.
    self test: testCount preinc is: [ write position = 0 ].
    bytes := write contentsWritten.
    self test: testCount preinc is: [ write atEnd ].
    self test: testCount preinc is: [ Transcript show: 'actual: '; print: bytes size; show: ', expected: '; print: sz;cr. bytes size = sz ].
    write close.
    read := file readStream.
    self test: testCount preinc is: [ read peek = 0 ].
    self test: testCount preinc is: [ read size = sz ].
    test := testCount preinc.
    0 to: sz-1 do:
        [ :i <Int> |
            | byte <Int> |
            byte := read next.
            self test: 6 is:
                [ i ~= 5001
                    ifTrue: [ i ~= 5000
                                ifTrue: [ (i \\ 100) = byte ]
                                ifFalse: [ byte = 12 ]    ]
                    ifFalse: [ byte = 123 ]    ].
            self test: test is: [ (bytes at: i + 1) = byte ].    ].

    self test: testCount preinc is: [ read atEnd ].
    read position: 5001.

    self test: testCount preinc is: [ read next = 123 ].
    read position: 0.

    self test: testCount preinc is: [ bytes = read contentsRemaining ].
    read close.
    out := file charOutputStream.
    s := 'hi 
there'.
    out nextPutAll: s.
    out close.
    in := file charInputStream.

    self test: testCount preinc is: [ in peek = (s at: 1) ].

	test := testCount preinc.
    1 to: s size do: 
        [ :i <Int> |
            self test: 12 is: [
				| n |
				n := in next.
				(s at: i) =  n].    ].

    self test: testCount preinc is: [ in atEnd ].
    in close.
    in := file charInputStream.

    self test: testCount preinc is: [ in contentsRemaining = s ].
    in close.! !

"June 25, 2009 -> 22:16:55"!

"System saved" !
"June 25, 2009 -> 22:18:9"!

! (Delta mirrorFor: #ExternalReadWriteStream) classSide methodsFor: 'testing' !
test
    "self test"
    |    file <FilePath>
        sz <Int>
        read <ExternalReadStream>
        write <ExternalReadWriteStream>
        in <CharInStream>
        out <CharOutStream>
        bytes <ByteArray>
        s <Str> 
        testCount <Counter>
        test <Integer> |
    testCount := Counter new.
    file := FilePath for: 'deltatest.tmp'.
    sz := 12345.    "make sure this number is much greater than the stream buffer size" 
    write := file writeStream.
    0 to: sz-1 do: 
        [ :i <Int> |
            write nextPut: i \\ 100 + 32.    ].
    self test: testCount preinc is: [ write size = sz ].
    write position: 5001.
    write nextPut: 123.
    write close.
    write := file readWriteStream.
    write position: 5000.
    write nextPut: 12.
    self test: testCount preinc is: [ write next = 123 ].
    write setToEnd.
    write position: 0.
    self test: testCount preinc is: [ write position = 0 ].
    bytes := write contentsWritten.
    "self test: testCount preinc is: [ write atEnd ]."
    self test: testCount preinc is: [ Transcript show: 'actual: '; print: bytes size; show: ', expected: '; print: sz;cr. bytes size = sz ].
    write close.
    read := file readStream.
    self test: testCount preinc is: [ read peek = 0 ].
    self test: testCount preinc is: [ read size = sz ].
    test := testCount preinc.
    0 to: sz-1 do:
        [ :i <Int> |
            | byte <Int> |
            byte := read next.
            self test: 6 is:
                [ i ~= 5001
                    ifTrue: [ i ~= 5000
                                ifTrue: [ (i \\ 100) = byte ]
                                ifFalse: [ byte = 12 ]    ]
                    ifFalse: [ byte = 123 ]    ].
            self test: test is: [ (bytes at: i + 1) = byte ].    ].

    self test: testCount preinc is: [ read atEnd ].
    read position: 5001.

    self test: testCount preinc is: [ read next = 123 ].
    read position: 0.

    self test: testCount preinc is: [ bytes = read contentsRemaining ].
    read close.
    out := file charOutputStream.
    s := 'hi 
there'.
    out nextPutAll: s.
    out close.
    in := file charInputStream.

    self test: testCount preinc is: [ in peek = (s at: 1) ].

	test := testCount preinc.
    1 to: s size do: 
        [ :i <Int> |
            self test: 12 is: [
				| n |
				n := in next.
				(s at: i) =  n].    ].

    self test: testCount preinc is: [ in atEnd ].
    in close.
    in := file charInputStream.

    self test: testCount preinc is: [ in contentsRemaining = s ].
    in close.! !

"June 25, 2009 -> 22:18:24"!

"System saved" !
"June 25, 2009 -> 22:21:22"!

! (Delta mirrorFor: #ExternalReadWriteStream) classSide methodsFor: 'testing' !
test
    "self test"
    |    file <FilePath>
        sz <Int>
        read <ExternalReadStream>
        write <ExternalReadWriteStream>
        in <CharInStream>
        out <CharOutStream>
        bytes <ByteArray>
        s <Str> 
        testCount <Counter>
        test <Integer> |
    testCount := Counter new.
    file := FilePath for: 'deltatest.tmp'.
    sz := 12345.    "make sure this number is much greater than the stream buffer size" 
    write := file writeStream.
    0 to: sz-1 do: 
        [ :i <Int> |
            write nextPut: i \\ 100 + 32.    ].
    self test: testCount preinc is: [ write size = sz ].
    write position: 5001.
    write nextPut: 123.
    write close.
    write := file readWriteStream.
    write position: 5000.
    write nextPut: 12.
    self test: testCount preinc is: [ write next = 123 ].
    write position: 0.
    self test: testCount preinc is: [ write position = 0 ].
    write setToEnd.
    bytes := write contentsWritten.
    "self test: testCount preinc is: [ write atEnd ]."
    self test: testCount preinc is: [ Transcript show: 'actual: '; print: bytes size; show: ', expected: '; print: sz;cr. bytes size = sz ].
    write close.
    read := file readStream.
    self test: testCount preinc is: [ read peek = 0 ].
    self test: testCount preinc is: [ read size = sz ].
    test := testCount preinc.
    0 to: sz-1 do:
        [ :i <Int> |
            | byte <Int> |
            byte := read next.
            self test: 6 is:
                [ i ~= 5001
                    ifTrue: [ i ~= 5000
                                ifTrue: [ (i \\ 100) = byte ]
                                ifFalse: [ byte = 12 ]    ]
                    ifFalse: [ byte = 123 ]    ].
            self test: test is: [ (bytes at: i + 1) = byte ].    ].

    self test: testCount preinc is: [ read atEnd ].
    read position: 5001.

    self test: testCount preinc is: [ read next = 123 ].
    read position: 0.

    self test: testCount preinc is: [ bytes = read contentsRemaining ].
    read close.
    out := file charOutputStream.
    s := 'hi 
there'.
    out nextPutAll: s.
    out close.
    in := file charInputStream.

    self test: testCount preinc is: [ in peek = (s at: 1) ].

	test := testCount preinc.
    1 to: s size do: 
        [ :i <Int> |
            self test: 12 is: [
				| n |
				n := in next.
				(s at: i) =  n].    ].

    self test: testCount preinc is: [ in atEnd ].
    in close.
    in := file charInputStream.

    self test: testCount preinc is: [ in contentsRemaining = s ].
    in close.! !

"June 25, 2009 -> 22:21:27"!

"System saved" !
"June 25, 2009 -> 22:22:51"!

! (Delta mirrorFor: #ExternalReadWriteStream) classSide methodsFor: 'testing' !
test
    "ExternalReadWriteStream test"
    |    file <FilePath>
        sz <Int>
        read <ExternalReadStream>
        write <ExternalReadWriteStream>
        in <CharInStream>
        out <CharOutStream>
        bytes <ByteArray>
        s <Str> 
        testCount <Counter>
        test <Integer> |
    testCount := Counter new.
    file := FilePath for: 'deltatest.tmp'.
    sz := 12345.    "make sure this number is much greater than the stream buffer size" 
    write := file writeStream.
    0 to: sz-1 do: 
        [ :i <Int> |
            write nextPut: i \\ 100 + 32.    ].
    self test: testCount preinc is: [ write size = sz ].
    write position: 5001.
    write nextPut: 123.
    write close.
    write := file readWriteStream.
    write position: 5000.
    write nextPut: 12.
    self test: testCount preinc is: [ write next = 123 ].
    write position: 0.
    self test: testCount preinc is: [ write position = 0 ].
    write setToEnd.
    bytes := write contentsWritten.
    "self test: testCount preinc is: [ write atEnd ]."
    self test: testCount preinc is: [ Transcript show: 'actual: '; print: bytes size; show: ', expected: '; print: sz;cr. bytes size = sz ].
    write close.
    read := file readStream.
    self test: testCount preinc is: [ read peek = 0 ].
    self test: testCount preinc is: [ read size = sz ].
    test := testCount preinc.
    0 to: sz-1 do:
        [ :i <Int> |
            | byte <Int> |
            byte := read next.
            self test: 6 is:
                [ i ~= 5001
                    ifTrue: [ i ~= 5000
                                ifTrue: [ (i \\ 100) = byte ]
                                ifFalse: [ byte = 12 ]    ]
                    ifFalse: [ byte = 123 ]    ].
            self test: test is: [ (bytes at: i + 1) = byte ].    ].

    self test: testCount preinc is: [ read atEnd ].
    read position: 5001.

    self test: testCount preinc is: [ read next = 123 ].
    read position: 0.

    self test: testCount preinc is: [ bytes = read contentsRemaining ].
    read close.
    out := file charOutputStream.
    s := 'hi 
there'.
    out nextPutAll: s.
    out close.
    in := file charInputStream.

    self test: testCount preinc is: [ in peek = (s at: 1) ].

	test := testCount preinc.
    1 to: s size do: 
        [ :i <Int> |
            self test: 12 is: [
				| n |
				n := in next.
				(s at: i) =  n].    ].

    self test: testCount preinc is: [ in atEnd ].
    in close.
    in := file charInputStream.

    self test: testCount preinc is: [ in contentsRemaining = s ].
    in close.! !

"June 25, 2009 -> 22:23:3"!

! (Delta mirrorFor: #ExternalReadWriteStream) classSide methodsFor: 'testing' !
test
    " ExternalReadWriteStream test "
    |    file <FilePath>
        sz <Int>
        read <ExternalReadStream>
        write <ExternalReadWriteStream>
        in <CharInStream>
        out <CharOutStream>
        bytes <ByteArray>
        s <Str> 
        testCount <Counter>
        test <Integer> |
    testCount := Counter new.
    file := FilePath for: 'deltatest.tmp'.
    sz := 12345.    "make sure this number is much greater than the stream buffer size" 
    write := file writeStream.
    0 to: sz-1 do: 
        [ :i <Int> |
            write nextPut: i \\ 100 + 32.    ].
    self test: testCount preinc is: [ write size = sz ].
    write position: 5001.
    write nextPut: 123.
    write close.
    write := file readWriteStream.
    write position: 5000.
    write nextPut: 12.
    self test: testCount preinc is: [ write next = 123 ].
    write position: 0.
    self test: testCount preinc is: [ write position = 0 ].
    write setToEnd.
    bytes := write contentsWritten.
    "self test: testCount preinc is: [ write atEnd ]."
    self test: testCount preinc is: [ Transcript show: 'actual: '; print: bytes size; show: ', expected: '; print: sz;cr. bytes size = sz ].
    write close.
    read := file readStream.
    self test: testCount preinc is: [ read peek = 0 ].
    self test: testCount preinc is: [ read size = sz ].
    test := testCount preinc.
    0 to: sz-1 do:
        [ :i <Int> |
            | byte <Int> |
            byte := read next.
            self test: 6 is:
                [ i ~= 5001
                    ifTrue: [ i ~= 5000
                                ifTrue: [ (i \\ 100) = byte ]
                                ifFalse: [ byte = 12 ]    ]
                    ifFalse: [ byte = 123 ]    ].
            self test: test is: [ (bytes at: i + 1) = byte ].    ].

    self test: testCount preinc is: [ read atEnd ].
    read position: 5001.

    self test: testCount preinc is: [ read next = 123 ].
    read position: 0.

    self test: testCount preinc is: [ bytes = read contentsRemaining ].
    read close.
    out := file charOutputStream.
    s := 'hi 
there'.
    out nextPutAll: s.
    out close.
    in := file charInputStream.

    self test: testCount preinc is: [ in peek = (s at: 1) ].

	test := testCount preinc.
    1 to: s size do: 
        [ :i <Int> |
            self test: 12 is: [
				| n |
				n := in next.
				(s at: i) =  n].    ].

    self test: testCount preinc is: [ in atEnd ].
    in close.
    in := file charInputStream.

    self test: testCount preinc is: [ in contentsRemaining = s ].
    in close.! !

"June 25, 2009 -> 22:24:59"!

! (Delta mirrorFor: #ExternalReadWriteStream) classSide methodsFor: 'testing' !
test
    " ExternalReadWriteStream test "
    |    file <FilePath>
        sz <Int>
        read <ExternalReadStream>
        write <ExternalReadWriteStream>
        in <CharInStream>
        out <CharOutStream>
        bytes <ByteArray>
        s <Str> 
        testCount <Counter>
        test <Integer> |
    testCount := Counter new.
    file := FilePath for: 'deltatest.tmp'.
    sz := 12345.    "make sure this number is much greater than the stream buffer size" 
    write := file writeStream.
    0 to: sz-1 do: 
        [ :i <Int> |
            write nextPut: i \\ 100 + 32.    ].
    self test: testCount preinc is: [ write size = sz ].
    write position: 5001.
    write nextPut: 123.
    write close.
    write := file readWriteStream.
    write position: 5000.
    write nextPut: 12.
    self test: testCount preinc is: [ write next = 123 ].
    write position: 0.
    self test: testCount preinc is: [ write position = 0 ].
    write setToEnd.
    bytes := write contentsWritten.
    "self test: testCount preinc is: [ write atEnd ]."
    self test: testCount preinc is: [ Transcript show: 'actual: '; print: bytes size; show: ', expected: '; print: sz;cr. bytes size = sz ].
    write close.
    read := file readStream.
    self test: testCount preinc is: [ read peek = 32 ].
    self test: testCount preinc is: [ read size = sz ].
    test := testCount preinc.
    0 to: sz-1 do:
        [ :i <Int> |
            | byte <Int> |
            byte := read next.
            self test: 6 is:
                [ i ~= 5001
                    ifTrue: [ i ~= 5000
                                ifTrue: [ (i \\ 100 +32) = byte ]
                                ifFalse: [ byte = 12 ]    ]
                    ifFalse: [ byte = 123 ]    ].
            self test: test is: [ (bytes at: i + 1) = byte ].    ].

    self test: testCount preinc is: [ read atEnd ].
    read position: 5001.

    self test: testCount preinc is: [ read next = 123 ].
    read position: 0.

    self test: testCount preinc is: [ bytes = read contentsRemaining ].
    read close.
    out := file charOutputStream.
    s := 'hi 
there'.
    out nextPutAll: s.
    out close.
    in := file charInputStream.

    self test: testCount preinc is: [ in peek = (s at: 1) ].

	test := testCount preinc.
    1 to: s size do: 
        [ :i <Int> |
            self test: test is: [
				| n |
				n := in next.
				(s at: i) =  n].    ].

    self test: testCount preinc is: [ in atEnd ].
    in close.
    in := file charInputStream.

    self test: testCount preinc is: [ in contentsRemaining = s ].
    in close.! !

"June 25, 2009 -> 22:25:6"!

"System saved" !
"June 27, 2009 -> 1:7:0"!

Delta define: #TextTestRunner as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 27, 2009 -> 1:7:0"!

! (Delta mirrorFor: #TextTestRunner) classSide methodsFor: 'instance creation' !
runAll

	| runner suite |
	runner := self new.
	suite := TestCase buildSuite.
	suite addDependent: runner.
	suite run
	! !

"June 27, 2009 -> 1:7:0"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Running' !
run: aResult 
	self tests do: [:each | 
		self sunitChanged: each with: aResult.
		Processor yield.
		each run: aResult]
			! !

"June 27, 2009 -> 1:7:0"!

! (Delta mirrorFor: #Object) methodsFor: 'Camp Smalltalk' !
sunitChanged: anAspect with: value
 
        self changed: anAspect with: value! !

"June 27, 2009 -> 1:7:0"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Running' !
run: aResult 
	self tests do: [:each | 
		Processor yield.
		each run: aResult.
		self sunitChanged: each with: aResult]
			! !

"June 27, 2009 -> 1:7:0"!

! (Delta mirrorFor: #TextTestRunner) classSide methodsFor: 'instance creation' !
runAll

	| runner suite result |
	runner := self new.
	suite := TestCase buildSuite.
	suite addDependent: runner.
	result := suite run.
	Transcript cr;
		print: result! !

"June 27, 2009 -> 1:7:0"!

! (Delta mirrorFor: #TextTestRunner) methodsFor: 'notifications' !
update: test with: result

	(result isFailure: test)
		ifTrue: [ Transcript print: test; show: ' failed'; cr].
	(result isError: test)
		ifTrue: [ Transcript print: test; show: ' error'; cr]! !

"June 27, 2009 -> 1:7:0"!

! (Delta mirrorFor: #BecomeTest) methodsFor: 'testing' !
testFail

	self fail! !

"June 27, 2009 -> 1:7:0"!

! (Delta mirrorFor: #TextTestRunner) methodsFor: 'notifications' !
update: test with: result
Transcript print: test.
	(result isFailure: test)
		ifTrue: [ Transcript print: test; show: ' failed'; cr].
	(result isError: test)
		ifTrue: [ Transcript print: test; show: ' error'; cr]! !

"June 27, 2009 -> 1:7:0"!

! (Delta mirrorFor: #TextTestRunner) classSide methodsFor: 'instance creation' !
runAll

	| runner suite result |
	runner := self new.
	suite := TestCase buildSuite.
	suite addDependentToHierarch: runner.
	result := suite run.
	Transcript cr;
		print: result! !

"June 27, 2009 -> 1:7:0"!

! (Delta mirrorFor: #TextTestRunner) methodsFor: 'notifications' !
update: test with: result

	(result isFailure: test)
		ifTrue: [ Transcript print: test; show: ' failed'; cr].
	(result isError: test)
		ifTrue: [ Transcript print: test; show: ' error'; cr]! !

"June 27, 2009 -> 1:7:0"!

! (Delta mirrorFor: #TextTestRunner) classSide methodsFor: 'instance creation' !
runAll

	| runner suite result |
	runner := self new.
	suite := TestCase buildSuite.
	suite addDependentToHierarchy: runner.
	result := suite run.
	Transcript cr;
		print: result! !

"June 27, 2009 -> 1:7:0"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Dependencies' !
addDependentToHierarchy: anObject
	self sunitAddDependent: anObject.
	self tests do: [ :each | each addDependentToHierarchy: anObject]
			! !

"June 27, 2009 -> 1:7:0"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Dependencies' !
removeDependentFromHierarchy: anObject
	self sunitRemoveDependent: anObject.
	self tests do: [ :each | each removeDependentFromHierarchy: anObject]
			! !

"June 27, 2009 -> 1:7:0"!

(Delta mirrorFor: #TestSuite) removeMethod: #removeDependentFromHierachy: ifAbsent: [] !


"June 27, 2009 -> 1:7:1"!

(Delta mirrorFor: #TestSuite) removeMethod: #addDependentToHierachy: ifAbsent: [] !


"June 27, 2009 -> 1:7:1"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Dependencies' !
removeDependentFromHierarchy: anObject 
	"an empty method. for Composite compability with TestSuite"


			! !

"June 27, 2009 -> 1:7:1"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Dependencies' !
addDependentToHierarchy: anObject 
	"an empty method. for Composite compability with TestSuite"


			! !

"June 27, 2009 -> 1:7:1"!

(Delta mirrorFor: #TestCase) removeMethod: #addDependentToHierachy: ifAbsent: [] !


"June 27, 2009 -> 1:7:1"!

(Delta mirrorFor: #TestCase) removeMethod: #removeDependentFromHierachy: ifAbsent: [] !


"June 27, 2009 -> 1:7:1"!

! (Delta mirrorFor: #BecomeTest) methodsFor: 'testing' !
testFail

	self assert: false! !

"June 27, 2009 -> 1:7:1"!

! (Delta mirrorFor: #TextTestRunner) classSide methodsFor: 'instance creation' !
runAll

	| runner suite result |
	runner := self new.
	suite := TestCase buildSuite.
	suite addDependentToHierarchy: runner.
	Transcript cr.
	result := suite run.
	Transcript cr;
		print: result! !

"June 27, 2009 -> 1:7:1"!

(Delta mirrorFor: #BecomeTest) removeMethod: #testFail ifAbsent: [] !


"June 27, 2009 -> 1:7:1"!

! (Delta mirrorFor: #BecomeTest) methodsFor: 'testing' !
testFail

	self assert: false description: 'failure message'! !

"June 27, 2009 -> 1:7:1"!

! (Delta mirrorFor: #TextTestRunner) methodsFor: 'notifications' !
update: test with: result

	(result isFailure: test)
		ifTrue: [ Transcript space; print: test; show: ' failed'; cr].
	(result isError: test)
		ifTrue: [ Transcript space; print: test; show: ' error'; cr]! !

"June 27, 2009 -> 1:7:1"!

(Delta mirrorFor: #BecomeTest) removeMethod: #testFail ifAbsent: [] !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file <FilePath>
write <ReadWriteStream>')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file <FilePath>
write <ReadWriteStream>')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file <FilePath>
write <ReadWriteStream>')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file <FilePath>
write <ReadWriteStream>')) !


"June 27, 2009 -> 1:7:1"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'running' !
tearDown

	write ifNotNil: [write close].
	file delete! !

"June 27, 2009 -> 1:7:1"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'running' !
setUp

	file := FilePath for: 'deltatest.tmp'.
	write := file writeStream! !

"June 27, 2009 -> 1:7:1"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'running' !
tearDown

	write isNil ifFalse: [write close].
	file delete! !

"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file <FilePath>
write <ReadWriteStream>')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file <FilePath>
write <ReadWriteStream>')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file <FilePath>
write <ReadWriteStream>')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file <FilePath>
write <ReadWriteStream>')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file <FilePath>
write <ReadWriteStream>')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file <FilePath>
write <ReadWriteStream>')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file <FilePath>
write <ReadWriteStream>')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file		<FilePath>
write		<ReadWriteStream>
sz			<Integer>')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file		<FilePath>
write		<ReadWriteStream>
sz			<Integer>')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file		<FilePath>
write		<ReadWriteStream>
sz			<Integer>')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file		<FilePath>
write		<ReadWriteStream>
sz			<Integer>')) !


"June 27, 2009 -> 1:7:1"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testWrittenFileShouldHaveCorrectSize

	0 to: sz-1 do: 
        [ :i <Int> |
            write nextPut: i \\ 100 + 32.    ].
    self should: [ write size = sz ]
    	description: 'Wrong size ', write size printString.! !

"June 27, 2009 -> 1:7:1"!

! (Delta mirrorFor: #TextTestRunner) methodsFor: 'notifications' !
update: test with: result

	(result isFailure: test)
		ifTrue: [ Transcript space; print: test; show: ' failed'; cr].
	(result isError: test)
		ifTrue: [ Transcript print: test; show: ' error'; cr]! !

"June 27, 2009 -> 1:7:1"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[[aTestCase runCase.
			true]
				sunitOn: self class failure
				do: [:signal |
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
							self halt.
									self errors add: aTestCase.
									signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"June 27, 2009 -> 1:7:1"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'running' !
setUp

    file := FilePath for: 'deltatest.tmp'.
    sz := 12345.    "make sure this number is much greater than the stream buffer size" 
    write := file writeStream.! !

"June 27, 2009 -> 1:7:1"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[[aTestCase runCase.
			true]
				sunitOn: self class failure
				do: [:signal |
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
							"self halt."
									self errors add: aTestCase.
									signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"June 27, 2009 -> 1:7:1"!

! (Delta mirrorFor: #TextTestRunner) classSide methodsFor: 'instance creation' !
run: suite

	| runner result |
	runner := self new.
	suite addDependentToHierarchy: runner.
	Transcript cr.
	result := suite run.
	Transcript cr;
		print: result! !

"June 27, 2009 -> 1:7:1"!

! (Delta mirrorFor: #TextTestRunner) classSide methodsFor: 'instance creation' !
runAll

	self run: TestCase buildSuite! !

"June 27, 2009 -> 1:7:1"!

! (Delta mirrorFor: #TextTestRunner) classSide methodsFor: 'instance creation' !
run: suite

	| runner result |
	runner := self new.
	suite addDependentToHierarchy: runner.
	[Transcript cr.
	result := suite run.
	Transcript cr;
		print: result]
			ensure: [suite removeDependentFromHierarchy: runner]! !

"June 27, 2009 -> 1:7:1"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'running' !
setUp

    file := FilePath for: 'deltatest.tmp'.
    sz := 12345.    "make sure this number is much greater than the stream buffer size" 
    write := file writeStream.
	0 to: sz-1 do: 
        [ :i <Int> |
            write nextPut: i \\ 100 + 32]! !

"June 27, 2009 -> 1:7:1"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testWrittenFileShouldHaveCorrectSize

    self should: [ write size = sz ]
    	description: 'Wrong size ', write size printString.! !

"June 27, 2009 -> 1:7:1"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testModifyingWrittenFileShouldUpdateContents

	| byte |
    write position: 5001.
    write nextPut: 123.
    write close.
    write := file readWriteStream.
    write position: 5000.
    write nextPut: 12.
    byte := write next.
    self should: [ byte = 123 ]
    	description: 'Wrong byte value: ', byte printString.! !

"June 27, 2009 -> 1:7:1"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testContentsWrittenShouldReturnCorrectlySizedCollection

	| bytes |
	write setToEnd.
    bytes := write contentsWritten.

    self should: [ bytes size = sz ]
    	description: 'Wrong byte count: ', bytes size printString! !

"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file		<FilePath>
write		<ReadWriteStream>
sz			<Integer>')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file		<FilePath>
write		<ReadWriteStream>
sz			<Integer>')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file		<FilePath>
write		<ReadWriteStream>
sz			<Integer>')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file		<FilePath>
write		<ReadWriteStream>
sz			<Integer>')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file		<FilePath>
write		<ReadWriteStream>
sz			<Integer>')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file		<FilePath>
write		<ReadWriteStream>
sz			<Integer>')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file		<FilePath>
write		<ReadWriteStream>
sz			<Integer>')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file		<FilePath>
write		<ReadWriteStream>
read		<ReadStream>
sz			<Integer>')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file		<FilePath>
write		<ReadWriteStream>
read		<ReadStream>
sz			<Integer>')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file		<FilePath>
write		<ReadWriteStream>
read		<ReadStream>
sz			<Integer>')) !


"June 27, 2009 -> 1:7:1"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file		<FilePath>
write		<ReadWriteStream>
read		<ReadStream>
sz			<Integer>')) !


"June 27, 2009 -> 1:7:1"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'running' !
tearDown

	write isNil ifFalse: [write close].
	read isNil ifFalse: [read close].
	file delete! !

"June 27, 2009 -> 1:7:1"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testPeekShouldReturnCorrectByte

	| byte |
	write close.
    read := file readStream.
    byte := read peek.
    self should: [ byte = 32 ]
    	description: 'Wrong byte: ', byte printString! !

"June 27, 2009 -> 1:7:10"!

"System saved" !
"June 27, 2009 -> 1:19:50"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'running' !
close: stream

	stream isNil ifTrue: [^self].
	stream isClosed ifTrue: [^self].
	stream close! !

"June 27, 2009 -> 1:20:14"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'running' !
tearDown

	self close: write.
	self close: read.
	file delete! !

"June 27, 2009 -> 1:23:36"!

! (Delta mirrorFor: #ExternalStream) methodsFor: 'testing' !
isClosed

	^self descriptor isClosed! !

"June 27, 2009 -> 1:26:38"!

! (Delta mirrorFor: #ExternalStream) methodsFor: 'testing' !
isClosed

	^self descriptor isNil or: [self descriptor isClosed]! !

"June 27, 2009 -> 1:28:12"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[[aTestCase runCase.
			true]
				sunitOn: self class failure
				do: [:signal |
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
							self halt.
									self errors add: aTestCase.
									signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"June 27, 2009 -> 1:29:5"!

"System saved" !
"June 27, 2009 -> 1:32:1"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testReadStreamShouldHaveCorrectSize

	| size |
	write close.
    read := file readStream.
    size := read size.
    self should: [ size = sz ]
    	description: 'Wrong size: ', size printString! !

"June 27, 2009 -> 1:35:53"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testReadStreamShouldHaveCorrectContents

	| size |
	write close.
    read := file readStream.
    0 to: sz-1 do:
        [ :i <Int> |
            | byte <Int> |
            byte := read next.
            self should: [ (i \\ 100 +32) = byte ]
            	description: 'Wrong byte: ', byte printString, ' at index: ', i printString]! !

"June 27, 2009 -> 1:38:1"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testContentsWrittenShouldMatchReadStreamContents

	| size bytes |
	write setAtEnd.
	bytes := write contentsWritten.
	write close.
    read := file readStream.
    0 to: sz-1 do:
        [ :i <Int> |
            | byte <Int> |
            byte := read next.
            self should: [ (bytes at: i + 1) = byte ]
            	description: 'Wrong byte: ', (bytes at: i + 1) printString, ' at index: ', i printString]! !

"June 27, 2009 -> 1:38:43"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testContentsWrittenShouldMatchReadStreamContents

	| size bytes |
	write setToEnd.
	bytes := write contentsWritten.
	write close.
    read := file readStream.
    0 to: sz-1 do:
        [ :i <Int> |
            | byte <Int> |
            byte := read next.
            self should: [ (bytes at: i + 1) = byte ]
            	description: 'Wrong byte: ', (bytes at: i + 1) printString, ' at index: ', i printString]! !

"June 27, 2009 -> 1:39:48"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testContentsWrittenShouldMatchReadStreamContents

	| size bytes |
	write setToEnd.
	bytes := write contentsWritten.
	write close.
    read := file readStream.
    0 to: sz-1 do:
        [ :i <Int> |
            | byte <Int> |
            byte := read next.
            self should: [ (bytes at: i + 1) = byte ]
            	description: 'Wrong byte: ', (bytes at: i + 1) printString, ' at index: ', i printString].
    self should: [ read atEnd] description: 'Read stream should be at end'! !

"June 27, 2009 -> 1:44:36"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testModifyingWrittenFileShouldUpdateContents

	| byte |
    write position: 5001.
    write nextPut: 123.
    write close.
    write := file readWriteStream.
    write position: 5000.
    write nextPut: 12.
    byte := write next.
    self assert: byte = 123 description: 'Wrong write byte value: ', byte printString.
    write close.

    read := file readStream.
    read position: 5001.
    byte := read next.
    self assert: byte = 123 description: 'Wrong read byte value: ', byte printString! !

"June 27, 2009 -> 1:47:10"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testContentsWrittenShouldMatchReadStreamContents

	| size bytes |
	write setToEnd.
	bytes := write contentsWritten.
	write close.
    read := file readStream.
    0 to: sz-1 do:
        [ :i <Int> |
            | byte <Int> |
            byte := read next.
            self should: [ (bytes at: i + 1) = byte ]
            	description: 'Wrong byte: ', (bytes at: i + 1) printString, ' at index: ', i printString].
    self should: [ read atEnd] description: 'Read stream should be at end'.
    read position: 0.
    self assert: bytes = read contentsRemaining description: 'Invalid contentsRemaining'! !

"June 27, 2009 -> 1:48:21"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file		<FilePath>
write		<ReadWriteStream>
read		<ReadStream>
sz			<Integer>
out		<CharOutputStream>')) !


"June 27, 2009 -> 1:49:22"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file		<FilePath>
write		<ReadWriteStream>
read		<ReadStream>
sz			<Integer>
out		<CharOutputStream>
in			<CharInputStream>')) !


"June 27, 2009 -> 1:50:14"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file			<FilePath>
write			<ReadWriteStream>
read			<ReadStream>
sz				<Integer>
charFile	<FilePath>
out			<CharOutputStream>
in				<CharInputStream>')) !


"June 27, 2009 -> 1:52:40"!

Delta define: #ExternalReadWriteStreamTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'file			<FilePath>
write			<ReadWriteStream>
read			<ReadStream>
sz				<Integer>
charFile	<FilePath>
in				<CharInputStream>
s				<ReadString>')) !


"June 27, 2009 -> 1:53:9"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'running' !
setUp

	| out	<CharOutputStream> |
    file := FilePath for: 'deltatest.tmp'.
    charFile := FilePath for: 'deltatest2.tmp'.
    
    sz := 12345.    "make sure this number is much greater than the stream buffer size" 
    write := file writeStream.
	0 to: sz-1 do: 
        [ :i <Int> |
            write nextPut: i \\ 100 + 32].

	out := charFile charOutputStream.
    s := 'hi 
there'.
    out nextPutAll: s.
    out close.
    in := file charInputStream! !

"June 27, 2009 -> 1:53:11"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'running' !
tearDown

	self close: write.
	self close: read.
	self close: in.
	file delete.
	charFile delete! !

"June 27, 2009 -> 1:55:8"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testPeekShouldReturnFirstCharacter

	| char |
	char := in peek.
	self assert: char = (s at: 1)
		description: 'Wrong character: ', char printString! !

"June 27, 2009 -> 1:55:44"!

"System saved" !
"June 27, 2009 -> 1:56:42"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'running' !
setUp

	| out	<CharOutputStream> |
    file := FilePath for: 'deltatest.tmp'.
    charFile := FilePath for: 'deltatest2.tmp'.
    
    sz := 12345.    "make sure this number is much greater than the stream buffer size" 
    write := file writeStream.
	0 to: sz-1 do: 
        [ :i <Int> |
            write nextPut: i \\ 100 + 32].

	out := charFile charOutputStream.
    s := 'hi 
there'.
    out nextPutAll: s.
    out close.
    in := charFile charInputStream! !

"June 27, 2009 -> 1:57:47"!

"System saved" !
"June 27, 2009 -> 1:59:21"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'running' !
tearDown

	self close: write.
	self close: read.
	in close.
	file delete.
	charFile delete! !

"June 27, 2009 -> 2:1:12"!

"System saved" !
"June 27, 2009 -> 2:4:33"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testCharStreamShouldHaveCorrectContents

	1 to: s size do: 
        [ :i <Int> |
            | n |
			n := in next.
            self assert: (s at: i) =  n
            	description: 'Wrong character: ', n printString, ' at index: ', i printString]! !

"June 27, 2009 -> 2:5:24"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testCharStreamShouldHaveCorrectContents

	1 to: s size do: 
        [ :i <Int> |
            | n |
			n := in next.
            self assert: (s at: i) =  n
            	description: 'Wrong character: ', n printString, ' at index: ', i printString].
     self assert: in atEnd description: 'Character stream should be exhausted'! !

"June 27, 2009 -> 2:5:55"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testCharStreamShouldHaveCorrectContents

	1 to: s size do: 
        [ :i <Int> |
            | n |
			n := in next.
            self assert: (s at: i) =  n
            	description: 'Wrong character: ', n printString, ' at index: ', i printString].
    self assert: in atEnd description: 'Character stream should be exhausted'! !

"June 27, 2009 -> 2:7:54"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testCharStreamContentsRemainingShouldHaveCorrectContents

	| contents |
	contents := in contentsRemaining.
	self assert: contents = s description: 'Wrong contents: ', contents! !

"June 27, 2009 -> 2:8:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[[aTestCase runCase.
			true]
				sunitOn: self class failure
				do: [:signal |
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
							"self halt."
									self errors add: aTestCase.
									signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"June 27, 2009 -> 2:9:43"!

"System saved" !
"June 27, 2009 -> 11:59:59"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testWrittenFileShouldHaveCorrectSize
"
    self should: [ write size = sz ]
    	description: 'Wrong size ', write size printString.
    	"! !

"June 27, 2009 -> 12:0:0"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testReadStreamShouldHaveCorrectSize
"
	| size |
	write close.
    read := file readStream.
    size := read size.
    self should: [ size = sz ]
    	description: 'Wrong size: ', size printString
    	"! !

"June 27, 2009 -> 12:0:2"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testReadStreamShouldHaveCorrectContents
"
	| size |
	write close.
    read := file readStream.
    0 to: sz-1 do:
        [ :i <Int> |
            | byte <Int> |
            byte := read next.
            self should: [ (i \\ 100 +32) = byte ]
            	description: 'Wrong byte: ', byte printString, ' at index: ', i printString]
            	"! !

"June 27, 2009 -> 12:0:3"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testPeekShouldReturnFirstCharacter
"
	| char |
	char := in peek.
	self assert: char = (s at: 1)
		description: 'Wrong character: ', char printString
		"! !

"June 27, 2009 -> 12:0:5"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testPeekShouldReturnCorrectByte
"
	| byte |
	write close.
    read := file readStream.
    byte := read peek.
    self should: [ byte = 32 ]
    	description: 'Wrong byte: ', byte printString"! !

"June 27, 2009 -> 12:0:7"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testModifyingWrittenFileShouldUpdateContents
"
	| byte |
    write position: 5001.
    write nextPut: 123.
    write close.
    write := file readWriteStream.
    write position: 5000.
    write nextPut: 12.
    byte := write next.
    self assert: byte = 123 description: 'Wrong write byte value: ', byte printString.
    write close.

    read := file readStream.
    read position: 5001.
    byte := read next.
    self assert: byte = 123 description: 'Wrong read byte value: ', byte printString
    "! !

"June 27, 2009 -> 12:0:9"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testContentsWrittenShouldReturnCorrectlySizedCollection
"
	| bytes |
	write setToEnd.
    bytes := write contentsWritten.

    self should: [ bytes size = sz ]
    	description: 'Wrong byte count: ', bytes size printString
    	"! !

"June 27, 2009 -> 12:0:11"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testContentsWrittenShouldMatchReadStreamContents
"
	| size bytes |
	write setToEnd.
	bytes := write contentsWritten.
	write close.
    read := file readStream.
    0 to: sz-1 do:
        [ :i <Int> |
            | byte <Int> |
            byte := read next.
            self should: [ (bytes at: i + 1) = byte ]
            	description: 'Wrong byte: ', (bytes at: i + 1) printString, ' at index: ', i printString].
    self should: [ read atEnd] description: 'Read stream should be at end'.
    read position: 0.
    self assert: bytes = read contentsRemaining description: 'Invalid contentsRemaining'
    "! !

"June 27, 2009 -> 12:0:13"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testCharStreamShouldHaveCorrectContents
"
	1 to: s size do: 
        [ :i <Int> |
            | n |
			n := in next.
            self assert: (s at: i) =  n
            	description: 'Wrong character: ', n printString, ' at index: ', i printString].
    self assert: in atEnd description: 'Character stream should be exhausted'
    "! !

"June 27, 2009 -> 12:0:14"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testCharStreamContentsRemainingShouldHaveCorrectContents

	"
	| contents |
	contents := in contentsRemaining.
	self assert: contents = s description: 'Wrong contents: ', contents
	"! !

"June 27, 2009 -> 12:0:35"!

"System saved" !
"June 27, 2009 -> 12:4:1"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'running' !
tearDown
"
	self close: write.
	self close: read.
	in close.
	file delete.
	charFile delete"! !

"June 27, 2009 -> 12:4:3"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'running' !
setUp
"
	| out	<CharOutputStream> |
    file := FilePath for: 'deltatest.tmp'.
    charFile := FilePath for: 'deltatest2.tmp'.
    
    sz := 12345."    "make sure this number is much greater than the stream buffer size" 
    "write := file writeStream.
	0 to: sz-1 do: 
        [ :i <Int> |
            write nextPut: i \\ 100 + 32].

	out := charFile charOutputStream.
    s := 'hi 
there'.
    out nextPutAll: s.
    out close.
    in := charFile charInputStream"! !

"June 27, 2009 -> 12:4:8"!

"System saved" !
"June 28, 2009 -> 11:15:30"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'running' !
tearDown

	self close: write.
	self close: read.
	in close.
	file delete.
	charFile delete! !

"June 28, 2009 -> 11:15:54"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'running' !
setUp

	| out	<CharOutputStream> |
    file := FilePath for: 'deltatest.tmp'.
    charFile := FilePath for: 'deltatest2.tmp'.
    
    sz := 12345.    "make sure this number is much greater than the stream buffer size" 
    write := file writeStream.
	0 to: sz-1 do: 
        [ :i <Int> |
            write nextPut: i \\ 100 + 32].

	out := charFile charOutputStream.
    s := 'hi 
there'.
    out nextPutAll: s.
    out close.
    in := charFile charInputStream! !

"June 28, 2009 -> 11:16:16"!

"System saved" !
"June 28, 2009 -> 11:27:36"!

! (Delta mirrorFor: #MacOSXFilePath) methodsFor: 'private' !
stat: block ifFail: failBlock

    | statBuffer <StatBuffer> 
    	status <ExternalProxy> |
    statBuffer := self statBufferClass new.
    statBuffer allocate.
    [ status := {{<libc ExternalProxy fstat>
            			name: self handle
            			buffer: statBuffer    }}.
	^status asSmallInteger == -1
		ifTrue: [failBlock value]
		ifFalse: [ block value: statBuffer ]]
			ensure: [ statBuffer free]
! !

"June 28, 2009 -> 11:27:51"!

! (Delta mirrorFor: #MacOSXFilePath) methodsFor: 'private' !
statBufferClass

	^MacOSXStatBuffer! !

"June 28, 2009 -> 11:35:41"!

! (Delta mirrorFor: #MacOSXStatBuffer) methodsFor: 'offsets' !
gidOffset

	^16! !

"June 28, 2009 -> 11:35:51"!

! (Delta mirrorFor: #MacOSXStatBuffer) methodsFor: 'offsets' !
uidOffset

	^12! !

"June 28, 2009 -> 11:36:15"!

! (Delta mirrorFor: #MacOSXStatBuffer) methodsFor: 'offsets' !
modeOffset

	^8! !

"June 28, 2009 -> 11:37:21"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
StatBuffer

    ^StatBuffer! !

"June 28, 2009 -> 11:38:14"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
stat: testBlock ifFail: failBlock

    | statBuffer <StatBuffer> 
    	status <ExternalProxy>
    	name <CString> |
    statBuffer := self StatBuffer new.
    statBuffer allocate.
    name := CString for: self name.
    [ status := {{<libc ExternalProxy __xstat>
    					version: statBuffer version
            			name: name
            			buffer: statBuffer    }}.
	status asSmallInteger == -1
		ifTrue: [ failBlock value ]
		ifFalse: [ ^testBlock value: statBuffer ]]
		ensure: [ statBuffer free.
						name free]! !

"June 28, 2009 -> 11:39:37"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
statName: name buffer: statBuffer

    ^{{<libc ExternalProxy __xstat>
   				version: statBuffer version
       			name: name
       			buffer: statBuffer}}! !

"June 28, 2009 -> 11:40:46"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
stat: testBlock ifFail: failBlock

    | statBuffer <StatBuffer> 
    	status <ExternalProxy>
    	name <CString> |
    statBuffer := self StatBuffer new.
    statBuffer allocate.
    name := CString for: self name.
    [ status := self statName: name
            			buffer: statBuffer.
	status asSmallInteger == -1
		ifTrue: [ failBlock value ]
		ifFalse: [ ^testBlock value: statBuffer ]]
		ensure: [ statBuffer free.
						name free]! !

"June 28, 2009 -> 11:42:7"!

! (Delta mirrorFor: #MacOSXFilePath) methodsFor: 'private' !
StatBuffer

	^MacOSXStatBuffer! !

"June 28, 2009 -> 11:42:13"!

! (Delta mirrorFor: #MacOSXFilePath) methodsFor: 'private' !
statName: name buffer: statBuffer

    ^{{<libc ExternalProxy fstat>
       			name: name
       			buffer: statBuffer}}! !

"June 28, 2009 -> 11:42:37"!

(Delta mirrorFor: #MacOSXFilePath) removeMethod: #stat:ifFail: ifAbsent: [] !


"June 28, 2009 -> 11:44:17"!

"System saved" !
"June 28, 2009 -> 11:52:29"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
failureLog	
	^SUnitNameResolver defaultLogDevice
			! !

"June 28, 2009 -> 11:52:41"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
logFailure: aString
	self isLogging ifTrue: [
		self failureLog 
			cr; 
			nextPutAll: aString; 
			flush]! !

"June 28, 2009 -> 11:52:48"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
failureLog	
	^SUnitNameResolver defaultLogDevice! !

"June 28, 2009 -> 11:53:21"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[[aTestCase runCase.
			true]
				sunitOn: self class failure
				do: [:signal |
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
							"self halt."
									self logFailure: signal printString.
									self errors add: aTestCase.
									signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"June 28, 2009 -> 11:55:59"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[[aTestCase runCase.
			true]
				sunitOn: self class failure
				do: [:signal |
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
									"self halt."
									[self logFailure: signal printString]
										sunitOn: self class error
										do: [:s2| [self logFailure: 'a ', signal class printString]
															sunitOn: self class error
															do: [:s3| ]].
									self errors add: aTestCase.
									signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"June 28, 2009 -> 11:57:4"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testError

	self error: 'test failed'! !

"June 28, 2009 -> 11:58:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
isLogging

	^true! !

"June 28, 2009 -> 11:58:58"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
logFailure: aString
	self isLogging ifTrue: [
		self failureLog 
			cr; 
			nextPutAll: aString;
			cr;
			flush]! !

"June 28, 2009 -> 11:59:9"!

(Delta mirrorFor: #ExternalReadWriteStreamTest) removeMethod: #testError ifAbsent: [] !


"June 28, 2009 -> 11:59:41"!

"System saved" !
"June 28, 2009 -> 14:40:49"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'private' !
lastError

	^{{primitiveGetLastError}}! !

"June 28, 2009 -> 14:43:20"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
statFailed

	self error: 'could not stat file: ', self lastError printString! !

"June 28, 2009 -> 14:43:31"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
isWriteable

    ^self stat: [:stat| 
    				(stat uid == self geteuid and: [(stat mode bitAnd: self S_IWUSR) == self S_IWUSR])
    					or: [(stat gid == self getegid and: [(stat mode bitAnd: self S_IWGRP) == self S_IWGRP])
    					or: [(stat mode bitAnd: self S_IWOTH) == self S_IWOTH]]]
    	ifFail: [ self statFailed ]! !

"June 28, 2009 -> 14:44:26"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
isDirectory ^<Boolean>

    ^self stat: [:stat| (stat mode bitAnd: self S_IFDIR) == self S_IFDIR]
    	ifFail: [ self statFailed ]! !

"June 28, 2009 -> 14:48:17"!

"System saved" !
"June 28, 2009 -> 14:56:50"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
statFailed

	| errno|
	errno := self lastError.
	self vmHalt.
	self error: 'could not stat file: ', errno printString! !

"June 28, 2009 -> 14:57:49"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
vmHalt

	{{primitiveVMBreakpoint}}! !

"June 28, 2009 -> 14:59:12"!

"System saved" !
"July 5, 2009 -> 16:20:8"!

! (Delta mirrorFor: #MacOSXFilePath) methodsFor: 'private' !
statName: name buffer: statBuffer

    ^{{<libc ExternalProxy stat>
       			name: name
       			buffer: statBuffer}}! !

"July 5, 2009 -> 16:20:56"!

"System saved" !
"July 5, 2009 -> 16:24:16"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testCharStreamContentsRemainingShouldHaveCorrectContents

	| contents |
	contents := in contentsRemaining.
	self assert: contents = s description: 'Wrong contents: ', contents! !

"July 5, 2009 -> 16:24:36"!

"System saved" !
"July 5, 2009 -> 16:25:57"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testCharStreamShouldHaveCorrectContents

	1 to: s size do: 
        [ :i <Int> |
            | n |
			n := in next.
            self assert: (s at: i) =  n
            	description: 'Wrong character: ', n printString, ' at index: ', i printString].
    self assert: in atEnd description: 'Character stream should be exhausted'! !

"July 5, 2009 -> 16:26:10"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testContentsWrittenShouldMatchReadStreamContents

	| size bytes |
	write setToEnd.
	bytes := write contentsWritten.
	write close.
    read := file readStream.
    0 to: sz-1 do:
        [ :i <Int> |
            | byte <Int> |
            byte := read next.
            self should: [ (bytes at: i + 1) = byte ]
            	description: 'Wrong byte: ', (bytes at: i + 1) printString, ' at index: ', i printString].
    self should: [ read atEnd] description: 'Read stream should be at end'.
    read position: 0.
    self assert: bytes = read contentsRemaining description: 'Invalid contentsRemaining'! !

"July 5, 2009 -> 16:26:20"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testContentsWrittenShouldReturnCorrectlySizedCollection

	| bytes |
	write setToEnd.
    bytes := write contentsWritten.

    self should: [ bytes size = sz ]
    	description: 'Wrong byte count: ', bytes size printString! !

"July 5, 2009 -> 16:26:31"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testModifyingWrittenFileShouldUpdateContents

	| byte |
    write position: 5001.
    write nextPut: 123.
    write close.
    write := file readWriteStream.
    write position: 5000.
    write nextPut: 12.
    byte := write next.
    self assert: byte = 123 description: 'Wrong write byte value: ', byte printString.
    write close.

    read := file readStream.
    read position: 5001.
    byte := read next.
    self assert: byte = 123 description: 'Wrong read byte value: ', byte printString! !

"July 5, 2009 -> 16:26:40"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testPeekShouldReturnCorrectByte

	| byte |
	write close.
    read := file readStream.
    byte := read peek.
    self should: [ byte = 32 ]
    	description: 'Wrong byte: ', byte printString! !

"July 5, 2009 -> 16:26:49"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testPeekShouldReturnFirstCharacter

	| char |
	char := in peek.
	self assert: char = (s at: 1)
		description: 'Wrong character: ', char printString! !

"July 5, 2009 -> 16:27:1"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testReadStreamShouldHaveCorrectContents

	| size |
	write close.
    read := file readStream.
    0 to: sz-1 do:
        [ :i <Int> |
            | byte <Int> |
            byte := read next.
            self should: [ (i \\ 100 +32) = byte ]
            	description: 'Wrong byte: ', byte printString, ' at index: ', i printString]! !

"July 5, 2009 -> 16:27:10"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testReadStreamShouldHaveCorrectSize

	| size |
	write close.
    read := file readStream.
    size := read size.
    self should: [ size = sz ]
    	description: 'Wrong size: ', size printString! !

"July 5, 2009 -> 16:27:28"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'tests' !
testWrittenFileShouldHaveCorrectSize

    self should: [ write size = sz ]
    	description: 'Wrong size ', write size printString! !

"July 5, 2009 -> 16:27:55"!

"System saved" !
"July 5, 2009 -> 16:39:47"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[[aTestCase runCase.
			true]
				sunitOn: self class failure
				do: [:signal |
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
									"self halt."
									self vmHalt.
									[self logFailure: signal printString]
										sunitOn: self class error
										do: [:s2| [self logFailure: 'a ', signal class printString]
															sunitOn: self class error
															do: [:s3| ]].
									self errors add: aTestCase.
									signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"July 5, 2009 -> 16:41:0"!

"System saved" !
"July 7, 2009 -> 0:52:15"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
setExternalPosition: p <Int>
    "%todo: support large integer positions for extremely large files"
    |result|
    result := {{<libc ExternalProxy lseek>
        				fd: self handle
        				offset: p
        				whence: self SEEK_SET }}.    "FILE_BEGIN"
    result isAllOnes
    	ifTrue: [self error: 'Could not position file descriptor: ', 
    					{{primitiveGetLastError}}]! !

"July 7, 2009 -> 0:53:42"!

"System saved" !
"July 7, 2009 -> 0:58:32"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
setExternalPosition: p <Int>
    "%todo: support large integer positions for extremely large files"
    |result|
    result := {{<libc ExternalProxy lseek>
        				fd: self handle
        				offset: p
        				whence: self SEEK_SET }}.    "FILE_BEGIN"
    result isAllOnes
    	ifTrue: [self error: 'Could not position file descriptor: ', 
    					{{primitiveGetLastError}} printString]! !

"July 7, 2009 -> 0:58:49"!

"System saved" !
"July 9, 2009 -> 0:46:5"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
setExternalPosition: p <Int>
    "%todo: support large integer positions for extremely large files"
    |result|
    result := {{<libc ExternalProxy lseek>
        				fd: self handle
        				offset: p
        				whence: self SEEK_SET }}.    "FILE_BEGIN"
    result isAllOnes
    	ifTrue: [| error |
    				error := {{primitiveGetLastError}}.
    				self vmHalt.
    				self error: 'Could not position file descriptor: ', 
    					error printString]! !

"July 9, 2009 -> 0:46:57"!

"System saved" !
"July 11, 2009 -> 10:43:11"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
setExternalPosition: p <Int>
    "%todo: support large integer positions for extremely large files"
    |result|
    self vmHalt.
    result := {{<libc ExternalProxy lseek>
        				fd: self handle
        				offset: p
        				whence: self SEEK_SET }}.    "FILE_BEGIN"
    result isAllOnes
    	ifTrue: [| error |
    				error := {{primitiveGetLastError}}.
    				self vmHalt.
    				self error: 'Could not position file descriptor: ', 
    					error printString]! !

"July 11, 2009 -> 10:44:0"!

"System saved" !
"July 12, 2009 -> 15:58:40"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'private' !
setExternalPosition: p <Int>
    "%todo: support large integer positions for extremely large files"
    | result padding |
    padding := p < 0
    					ifTrue: [-1]
    					ifFalse: [0].
    result := {{<libc ExternalProxy lseek>
        				fd: self handle
        				with: padding
        				offset: p
        				whence: self SEEK_SET }}.    "FILE_BEGIN"
    result isAllOnes
    	ifTrue: [| error |
    				error := {{primitiveGetLastError}}.
    				self vmHalt.
    				self error: 'Could not position file descriptor: ', 
    					error printString]! !

"July 12, 2009 -> 16:0:2"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'private' !
lseek: p <Int> whence: whence <Int>
    "%todo: support large integer positions for extremely large files"
    | padding |
    padding := p < 0
    					ifTrue: [-1]
    					ifFalse: [0].
    ^ {{<libc ExternalProxy lseek>
        				fd: self handle
        				with: padding
        				offset: p
        				whence: whence }}! !

"July 12, 2009 -> 16:0:54"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'private' !
setExternalPosition: p <Int>
    "%todo: support large integer positions for extremely large files"
    | result |
    result := self lseek: p
           				whence: self SEEK_SET.    "FILE_BEGIN"
    result isAllOnes
    	ifTrue: [| error |
    				error := {{primitiveGetLastError}}.
    				self vmHalt.
    				self error: 'Could not position file descriptor: ', 
    					error printString]! !

"July 12, 2009 -> 16:2:10"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'private' !
lseekHandle: handle position: p <Int> whence: whence <Int>
    "%todo: support large integer positions for extremely large files"
    | padding |
    padding := p < 0
    					ifTrue: [-1]
    					ifFalse: [0].
    ^ {{<libc ExternalProxy lseek>
        				fd: handle
        				with: padding
        				offset: p
        				whence: whence }}! !

"July 12, 2009 -> 16:2:50"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'private' !
setExternalPosition: p <Int>
    "%todo: support large integer positions for extremely large files"
    | result |
    result := self handle: self handle
    					lseek: p
           				whence: self SEEK_SET.    "FILE_BEGIN"
    result isAllOnes
    	ifTrue: [| error |
    				error := {{primitiveGetLastError}}.
    				self vmHalt.
    				self error: 'Could not position file descriptor: ', 
    					error printString]! !

"July 12, 2009 -> 16:3:9"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
lseekHandle: handle position: p <Int> whence: whence <Int>
    "%todo: support large integer positions for extremely large files"
    | padding |
    padding := p < 0
    					ifTrue: [-1]
    					ifFalse: [0].
    ^ {{<libc ExternalProxy lseek>
        				fd: handle
        				with: padding
        				offset: p
        				whence: whence }}! !

"July 12, 2009 -> 16:3:31"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
lseekHandle: handle position: p <Int> whence: whence <Int>
    "%todo: support large integer positions for extremely large files"
    ^ {{<libc ExternalProxy lseek>
        				fd: handle
        				offset: p
        				whence: whence }}! !

"July 12, 2009 -> 16:4:32"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'private' !
lseek: handle position: p <Int> whence: whence <Int>
    "%todo: support large integer positions for extremely large files"
    | padding |
    padding := p < 0
    					ifTrue: [-1]
    					ifFalse: [0].
    ^ {{<libc ExternalProxy lseek>
        				fd: handle
        				with: padding
        				offset: p
        				whence: whence }}! !

"July 12, 2009 -> 16:4:34"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'private' !
setExternalPosition: p <Int>
    "%todo: support large integer positions for extremely large files"
    | result |
    result := self lseek: self handle
    					position: p
           				whence: self SEEK_SET.    "FILE_BEGIN"
    result isAllOnes
    	ifTrue: [| error |
    				error := {{primitiveGetLastError}}.
    				self vmHalt.
    				self error: 'Could not position file descriptor: ', 
    					error printString]! !

"July 12, 2009 -> 16:4:49"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
lseek: handle position: p <Int> whence: whence <Int>
    "%todo: support large integer positions for extremely large files"
    ^ {{<libc ExternalProxy lseek>
        				fd: handle
        				offset: p
        				whence: whence }}! !

"July 12, 2009 -> 16:5:5"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
setExternalPosition: p <Int>
    "%todo: support large integer positions for extremely large files"
    | result |
    result := self lseek: self handle
    					position: p
           				whence: self SEEK_SET.    "FILE_BEGIN"
    result isAllOnes
    	ifTrue: [| error |
    				error := {{primitiveGetLastError}}.
    				self vmHalt.
    				self error: 'Could not position file descriptor: ', 
    					error printString]! !

"July 12, 2009 -> 16:5:23"!

(Delta mirrorFor: #MacOSXFileDescriptor) removeMethod: #lseek:whence: ifAbsent: [] !


"July 12, 2009 -> 16:5:25"!

(Delta mirrorFor: #MacOSXFileDescriptor) removeMethod: #lseekHandle:position:whence: ifAbsent: [] !


"July 12, 2009 -> 16:5:30"!

(Delta mirrorFor: #MacOSXFileDescriptor) removeMethod: #setExternalPosition: ifAbsent: [] !


"July 12, 2009 -> 16:8:7"!

"System saved" !
"July 12, 2009 -> 18:33:2"!

(Delta mirrorFor: #UnixFileDescriptor) removeMethod: #lseekHandle:position:whence: ifAbsent: [] !


"July 12, 2009 -> 19:39:11"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'private' !
lseek: handle position: p <Int> whence: whence <Int>
    "%todo: support large integer positions for extremely large files"
    | padding |
    padding := p < 0
    					ifTrue: [-1]
    					ifFalse: [0].
    self vmHalt.
    ^ {{<libc ExternalProxy lseek>
        				fd: handle
        				with: padding
        				offset: p
        				whence: whence }}! !

"July 12, 2009 -> 19:39:35"!

"System saved" !
"July 13, 2009 -> 0:40:1"!

! (Delta mirrorFor: #ExternalReadWriteStream) methodsFor: 'accessing' !
contentsWritten  ^<SeqCltn[Int]>
    "%copied (substituting for E) from BasicReadWriteStream"
    | cltn <VarSeqCltn[Int]>  origPos <Int> |
    cltn := self newCollectionOfSize: self position.
    origPos := self position.
    self vmHalt.
    self position: 0.
    1 to: origPos do: [ :i <Int> |
        cltn at: i put: self next.    ].
    self position: origPos.
    ^cltn! !

"July 13, 2009 -> 0:40:24"!

"System saved" !
"July 13, 2009 -> 0:42:0"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'private' !
lseek: handle position: p <Int> whence: whence <Int>
    "%todo: support large integer positions for extremely large files"
    | padding |
    padding := p < 0
    					ifTrue: [-1]
    					ifFalse: [0].
    "self vmHalt."
    ^ {{<libc ExternalProxy lseek>
        				fd: handle
        				with: padding
        				offset: p
        				whence: whence }}! !

"July 13, 2009 -> 0:42:20"!

"System saved" !
"July 14, 2009 -> 1:32:18"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'i/o' !
read: handle buffer: buffer count: count

	^{{<libc ExternalProxy read>
		fd: handle
		buffer: buffer
		count: count }}! !

"July 14, 2009 -> 1:35:19"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'i/o' !
readAt: pos <Int> ifFail: errf <[ExternalError]> ^<Int>
    | result <ExternalProxy> count <Int> |
    self position = pos
        ifFalse: [ self position: pos ].
    self knowAtEnd
        ifTrue: [ count := 0 ]
        ifFalse: [result := self read: self handle
                        				buffer: self buffer
                        				count: self bufferSize.
                     result isAllOnes
                     	ifTrue: [self vmHalt.
                     				errf value: 'Error filling buffer']
                     	ifFalse: [count := result asSmallInteger ]].
    self setPosition: self position + count.
    ^count! !

"July 14, 2009 -> 1:36:21"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
errno

	^{{primitiveGetLastError}}! !

"July 14, 2009 -> 1:36:44"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'i/o' !
readAt: pos <Int> ifFail: errf <[ExternalError]> ^<Int>
    | result <ExternalProxy> count <Int> |
    self position = pos
        ifFalse: [ self position: pos ].
    self knowAtEnd
        ifTrue: [ count := 0 ]
        ifFalse: [result := self read: self handle
                        				buffer: self buffer
                        				count: self bufferSize.
                     result isAllOnes
                     	ifTrue: [self vmHalt.
                     				errf value: 'Error filling buffer: ', self errno printString]
                     	ifFalse: [count := result asSmallInteger ]].
    self setPosition: self position + count.
    ^count! !

"July 14, 2009 -> 1:38:2"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'i/o' !
readAt: pos <Int> ifFail: errf <[ExternalError]> ^<Int>
    | result <ExternalProxy> count <Int> |
    self position = pos
        ifFalse: [ self position: pos ].
    self knowAtEnd
        ifTrue: [ count := 0 ]
        ifFalse: [result := self read: self handle
                        				buffer: self buffer
                        				count: self bufferSize.
                     result isAllOnes
                     	ifTrue: [|msg|
                     				msg := 'Error filling buffer: ', self errno printString.
                     				self vmHalt.
                     				errf value: msg]
                     	ifFalse: [count := result asSmallInteger ]].
    self setPosition: self position + count.
    ^count! !

"July 14, 2009 -> 1:38:38"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
setExternalPosition: p <Int>
    "%todo: support large integer positions for extremely large files"
    | result |
    result := self lseek: self handle
    					position: p
           				whence: self SEEK_SET.    "FILE_BEGIN"
    result isAllOnes
    	ifTrue: [| error |
    				error := self errno.
    				self vmHalt.
    				self error: 'Could not position file descriptor: ', 
    					error printString]! !

"July 14, 2009 -> 1:39:33"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
errorText: message

	^message , self errno! !

"July 14, 2009 -> 1:39:54"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
errorText: message

	^message , self errno printString! !

"July 14, 2009 -> 1:41:13"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
setExternalPosition: p <Int>
    "%todo: support large integer positions for extremely large files"
    | result |
    result := self lseek: self handle
    					position: p
           				whence: self SEEK_SET.    "FILE_BEGIN"
    result isAllOnes
    	ifTrue: [self vmHalt.
    				self error: (self errorText: 'Could not position file descriptor: ')]! !

"July 14, 2009 -> 1:42:21"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'i/o' !
readAt: pos <Int> ifFail: errf <[ExternalError]> ^<Int>
    | result <ExternalProxy> count <Int> |
    self position = pos
        ifFalse: [ self position: pos ].
    self knowAtEnd
        ifTrue: [ count := 0 ]
        ifFalse: [result := self read: self handle
                        				buffer: self buffer
                        				count: self bufferSize.
                     result isAllOnes
                     	ifTrue: [|msg|
                     				msg := self errorText: 'Error filling buffer: '.
                     				self vmHalt.
                     				errf value: msg]
                     	ifFalse: [count := result asSmallInteger ]].
    self setPosition: self position + count.
    ^count! !

"July 14, 2009 -> 1:44:57"!

"System saved" !
"July 14, 2009 -> 10:30:14"!

! (Delta mirrorFor: #ExternalReadWriteStreamTest) methodsFor: 'running' !
setUp

	| out	<CharOutputStream> |
    file := FilePath for: 'deltatest.tmp'.
    charFile := FilePath for: 'deltatest2.tmp'.
    
    sz := 12345.    "make sure this number is much greater than the stream buffer size" 
    write := file readWriteStream.
	0 to: sz-1 do: 
        [ :i <Int> |
            write nextPut: i \\ 100 + 32].

	out := charFile charOutputStream.
    s := 'hi 
there'.
    out nextPutAll: s.
    out close.
    in := charFile charInputStream! !

"July 14, 2009 -> 10:32:14"!

! (Delta mirrorFor: #ExternalReadWriteStream) methodsFor: 'accessing' !
contentsWritten  ^<SeqCltn[Int]>
    "%copied (substituting for E) from BasicReadWriteStream"
    | cltn <VarSeqCltn[Int]>  origPos <Int> |
    cltn := self newCollectionOfSize: self position.
    origPos := self position.
    self position: 0.
    1 to: origPos do: [ :i <Int> |
        cltn at: i put: self next.    ].
    self position: origPos.
    ^cltn! !

"July 14, 2009 -> 10:33:49"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
statFailed

	| errno|
	errno := self lastError.
	self error: 'could not stat file: ', errno printString! !

"July 14, 2009 -> 10:33:51"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
setExternalPosition: p <Int>
    "%todo: support large integer positions for extremely large files"
    | result |
    result := self lseek: self handle
    					position: p
           				whence: self SEEK_SET.    "FILE_BEGIN"
    result isAllOnes
    	ifTrue: [self error: (self errorText: 'Could not position file descriptor: ')]! !

"July 14, 2009 -> 10:33:53"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[[aTestCase runCase.
			true]
				sunitOn: self class failure
				do: [:signal |
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
									[self logFailure: signal printString]
										sunitOn: self class error
										do: [:s2| [self logFailure: 'a ', signal class printString]
															sunitOn: self class error
															do: [:s3| ]].
									self errors add: aTestCase.
									signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"July 14, 2009 -> 10:33:55"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'i/o' !
readAt: pos <Int> ifFail: errf <[ExternalError]> ^<Int>
    | result <ExternalProxy> count <Int> |
    self position = pos
        ifFalse: [ self position: pos ].
    self knowAtEnd
        ifTrue: [ count := 0 ]
        ifFalse: [result := self read: self handle
                        				buffer: self buffer
                        				count: self bufferSize.
                     result isAllOnes
                     	ifTrue: [|msg|
                     				msg := self errorText: 'Error filling buffer: '.
                     				errf value: msg]
                     	ifFalse: [count := result asSmallInteger ]].
    self setPosition: self position + count.
    ^count! !

"July 14, 2009 -> 10:34:13"!

"System saved" !
"July 14, 2009 -> 11:0:4"!

! (Delta mirrorFor: #MacOSXFilePath) methodsFor: 'private' !
O_CREAT

	^16r200! !

"July 14, 2009 -> 11:0:25"!

! (Delta mirrorFor: #MacOSXFilePath) methodsFor: 'private' !
O_TRUNC

	^16r400! !

"July 14, 2009 -> 11:8:33"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'restricted' !
open: dname <ExternalProxy> mode: dmode <SmallInt> ^ <ExternalProxy>

   ^{{<libc ExternalProxy open>
    					name: dname
    					flags: dmode
    					create: 8r777 }}! !

"July 14, 2009 -> 11:8:50"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'restricted' !
open: dname <ExternalProxy> mode: dmode <SmallInt> ^ <ExternalProxy>

   ^{{<libc ExternalProxy open>
    		name: dname
    		flags: dmode
    		create: 8r777 }}! !

"July 14, 2009 -> 11:8:58"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'restricted' !
open: dname <ExternalProxy> mode: dmode <SmallInt> ^ <ExternalProxy>

   ^{{<libc ExternalProxy open>
    		name: dname
    		flags: dmode
    		permissions: 8r777 }}! !

"July 14, 2009 -> 11:9:34"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'restricted' !
openInternalFor: mode <Symbol> ifFail: err <[ExternalError, ^X def]>  ^<ExternalProxy | X>

    |   dname <ExternalProxy>
        dmode <SmallInt>
        proxy <ExternalProxy> |
    dname := self nameProxy.

    [ dmode := self modeFor: mode.
    	proxy := self open: dname
    					mode: dmode]
    		ensure: [ dname free ].

    ^proxy isAllOnes
        ifFalse: [ proxy ]
        ifTrue: [ err value: #cannotOpenFile ]! !

"July 14, 2009 -> 11:10:14"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'restricted' !
openInternalFor: mode <Symbol> ifFail: err <[ExternalError, ^X def]>  ^<ExternalProxy | X>

    |   dname <ExternalProxy>
        dmode <SmallInt>
        proxy <ExternalProxy> |
    dname := self nameProxy.

    [ dmode := self modeFor: mode.
    	proxy := self open: dname
    						mode: dmode]
    		ensure: [ dname free ].

    ^proxy isAllOnes
        ifFalse: [ proxy ]
        ifTrue: [ err value: #cannotOpenFile ]! !

"July 14, 2009 -> 11:10:48"!

! (Delta mirrorFor: #MacOSXFilePath) methodsFor: 'private' !
open: dname <ExternalProxy> mode: dmode <SmallInt> ^ <ExternalProxy>

   ^{{<libc ExternalProxy open>
    		name: dname
    		flags: dmode }}! !

"July 14, 2009 -> 11:12:14"!

"System saved" !
"July 14, 2009 -> 21:49:15"!

(Delta mirrorFor: #MacOSXFilePath) removeMethod: #open:mode: ifAbsent: [] !


"July 14, 2009 -> 21:49:57"!

"System saved" !
"July 18, 2009 -> 12:35:26"!

! (Delta mirrorFor: #DefWithMsgSourceHandler) methodsFor: 'Unclassified' !
sourceForSelector: sel <Symbol> ^ <Str> 

	| list <OrdCltn[Str]> |
	#positions: == sel ifTrue: [self vmHalt].
	list := self attributeAt: sel.
	list size < 2 ifTrue: [ self shouldNotHappen ].
	(list at: 1) do: [ :e <Character> | e isDigit ifFalse: [ self shouldNotHappen ] ].
	self changeLog position: (Integer readFrom: (list at: 1) readStream).
	^self changeLog nextChunk! !

"July 18, 2009 -> 12:40:1"!

"System saved" !
"July 18, 2009 -> 13:27:27"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
vmHalt: condition

	condition ifTrue: [self vmHalt]! !

"July 18, 2009 -> 13:28:22"!

! (Delta mirrorFor: #DefWithMsgSourceHandler) methodsFor: 'Unclassified' !
sourceForSelector: sel <Symbol> ^ <Str> 

	| list <OrdCltn[Str]> |
	list := self attributeAt: sel.
	list size < 2 ifTrue: [ self shouldNotHappen ].
	(list at: 1) do: [ :e <Character> | e isDigit ifFalse: [ self shouldNotHappen ] ].
	self changeLog position: ((Integer readFrom: (list at: 1) readStream) vmHalt: #positions: == sel).
	^self changeLog nextChunk! !

"July 18, 2009 -> 13:32:59"!

"System saved" !
"July 19, 2009 -> 17:5:13"!

! (Delta mirrorFor: #DefWithMsgSourceHandler) methodsFor: 'Unclassified' !
sourceForSelector: sel <Symbol> ^ <Str> 

	| list <OrdCltn[Str]> |
	list := self attributeAt: sel.
	list size < 2 ifTrue: [ self shouldNotHappen ].
	(list at: 1) do: [ :e <Character> | e isDigit ifFalse: [ self shouldNotHappen ] ].
	LSeekStop := #positions: == sel.
	self changeLog position: ((Integer readFrom: (list at: 1) readStream)).
	^self changeLog nextChunk! !

"July 19, 2009 -> 17:12:52"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'private' !
lseek: handle position: p <Int> whence: whence <Int>
    "%todo: support large integer positions for extremely large files"
    | padding |
    padding := p < 0
    					ifTrue: [-1]
    					ifFalse: [0].
    "self vmHalt: LSeekStop."
    ^ {{<libc ExternalProxy lseek>
        				fd: (handle vmHalt: LSeekStop)
        				with: padding
        				offset: p
        				whence: whence }}! !

"July 19, 2009 -> 17:18:42"!

"System saved" !
"July 19, 2009 -> 17:27:32"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'private' !
lseek: handle position: p <Int> whence: whence <Int>
    "%todo: support large integer positions for extremely large files"
    | padding |
    padding := p < 0
    					ifTrue: [-1]
    					ifFalse: [0].
    "self vmHalt: LSeekStop."
    ^ {{<libc ExternalProxy lseek>
        				fd: (handle vmHalt: (LSeekStop notNil and: [LSeekStop]))
        				with: padding
        				offset: p
        				whence: whence }}! !

"July 19, 2009 -> 17:27:46"!

"System saved" !
"July 19, 2009 -> 23:19:10"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'private' !
lseek: handle position: p <Int> whence: whence <Int>
    "%todo: support large integer positions for extremely large files"
    | padding |
    padding := p < 0
    					ifTrue: [-1]
    					ifFalse: [0].
    "self vmHalt: LSeekStop."
    ^ {{<libc ExternalProxy lseek>
        				fd: (handle "vmHalt: (LSeekStop notNil and: [LSeekStop])")
        				offsetLow: p
        				offsetHigh: padding
        				whence: whence }}! !

"July 19, 2009 -> 23:19:31"!

"System saved" !
"July 19, 2009 -> 23:22:14"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'private' !
lseek: handle position: p <Int> whence: whence <Int>
    "%todo: support large integer positions for extremely large files"
    | padding |
    padding := p < 0
    					ifTrue: [-1]
    					ifFalse: [0].
   ^ {{<libc ExternalProxy lseek>
        				fd: handle
        				offsetLow: p
        				offsetHigh: padding
        				whence: whence }}! !

"July 19, 2009 -> 23:23:10"!

! (Delta mirrorFor: #DefWithMsgSourceHandler) methodsFor: 'Unclassified' !
sourceForSelector: sel <Symbol> ^ <Str> 

	| list <OrdCltn[Str]> |
	list := self attributeAt: sel.
	list size < 2 ifTrue: [ self shouldNotHappen ].
	(list at: 1) do: [ :e <Character> | e isDigit ifFalse: [ self shouldNotHappen ] ].
	self changeLog position: ((Integer readFrom: (list at: 1) readStream)).
	^self changeLog nextChunk! !

"July 19, 2009 -> 23:23:31"!

(Delta mirrorFor: #LSeekStop) removeDefinitionIfFail: [] !


"July 19, 2009 -> 23:25:54"!

"System saved" !
"July 26, 2009 -> 23:19:41"!

! (Delta mirrorFor: #HaltTest) methodsFor: 'Testing' !
testDefaultActionShouldStopWithProcessHaltError

	| wasHandled processError |
	wasHandled := false.
	self withStopHandler: [:p| wasHandled := true.
											processError := p processError.
											p terminate]
			do: [[self halt] fork.
					Processor yield].
	self assert: wasHandled
			description: 'Halt should have been handled'.
	self assert: (processError isKindOf: ProcessHaltError)
			description: 'Wrong kind of error reported'! !

"July 26, 2009 -> 23:19:54"!

! (Delta mirrorFor: #ErrorTest) methodsFor: 'testing' !
testDefaultActionShouldPassToStopHandler

	| wasHandled processError |
	wasHandled := false.
	self withStopHandler: [:p| wasHandled := true.
											processError := p processError.
											p terminate]
			do: 	[[self error: 'this is an error'] fork.
					Processor yield].
	self assert: wasHandled
			description: 'defaultAction should invoke the stopHandler'.
	self assert: (processError isKindOf: ProcessExplicitError)
			description: 'Process stopped with wrong kind of error', processError printString.
	self assert: 'this is an error' = processError msg
			description: 'Process stopped with wrong message: ', processError msg! !

"July 26, 2009 -> 23:21:30"!

"System saved" !
"August 1, 2009 -> 16:18:48"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Testing' !
shouldInheritSelectors
	"I should inherit from an Abstract superclass but not from a concrete one by default,
	 unless I have no testSelectors in which case I must be expecting to inherit them
	 from my superclass.  If a test case with selectors wants to inherit selectors from a
	 concrete superclass, override this to true in that subclass."

	^self superclass isAbstract
		or: [self testSelectors isEmpty]

"$QA Ignore:Sends system method(superclass)$"
			! !

"August 3, 2009 -> 21:39:59"!

Delta define: #NLRAlignmentTest as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 3, 2009 -> 21:40:49"!

! (Delta mirrorFor: #NLRAlignmentTest) methodsFor: 'private' !
call: block

	block value! !

"August 3, 2009 -> 21:41:26"!

! (Delta mirrorFor: #NLRAlignmentTest) methodsFor: 'private' !
call: block

	[block value]
		ensure: []! !

"August 3, 2009 -> 21:41:49"!

! (Delta mirrorFor: #NLRAlignmentTest) methodsFor: 'private' !
call: block with: one

	[block value]
		ensure: []! !

"August 3, 2009 -> 21:41:55"!

! (Delta mirrorFor: #NLRAlignmentTest) methodsFor: 'private' !
call: block with: one with: two

	[block value]
		ensure: []! !

"August 3, 2009 -> 21:42:27"!

! (Delta mirrorFor: #NLRAlignmentTest) methodsFor: 'private' !
call: block with: one with: two with: three

	[block value]
		ensure: []! !

"August 3, 2009 -> 21:44:12"!

! (Delta mirrorFor: #NLRAlignmentTest) methodsFor: 'testing' !
testWithNone

	self call: [^self]! !

"August 3, 2009 -> 21:44:27"!

! (Delta mirrorFor: #NLRAlignmentTest) methodsFor: 'testing' !
testWithOne

	self call: [^self] with: 0! !

"August 3, 2009 -> 21:44:37"!

! (Delta mirrorFor: #NLRAlignmentTest) methodsFor: 'testing' !
testWithTwo

	self call: [^self] with: 0 with: 0! !

"August 3, 2009 -> 21:44:49"!

! (Delta mirrorFor: #NLRAlignmentTest) methodsFor: 'testing' !
testWithThree

	self call: [^self] with: 0 with: 0 with: 0! !

"August 3, 2009 -> 21:45:43"!

Delta define: #NLRAlignmentTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 3, 2009 -> 21:45:43"!

Delta define: #NLRAlignmentTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 3, 2009 -> 21:45:43"!

Delta define: #NLRAlignmentTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 3, 2009 -> 21:45:43"!

Delta define: #NLRAlignmentTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 3, 2009 -> 21:45:43"!

Delta define: #NLRAlignmentTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 3, 2009 -> 21:45:43"!

Delta define: #NLRAlignmentTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 3, 2009 -> 21:45:43"!

Delta define: #NLRAlignmentTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 3, 2009 -> 21:45:43"!

Delta define: #NLRAlignmentTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 3, 2009 -> 21:45:43"!

Delta define: #NLRAlignmentTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 3, 2009 -> 21:45:43"!

Delta define: #NLRAlignmentTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 3, 2009 -> 21:45:43"!

Delta define: #NLRAlignmentTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 3, 2009 -> 21:47:19"!

"System saved" !
"August 3, 2009 -> 22:2:20"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
exists ^<Boolean>
	| name result |
	name := self nameProxy.
    [ result := {{<libc ExternalProxy open>
   	 					name: name
    					flags: 0}}.
    	result isAllOnes
    		ifFalse: [{{<libc ExternalProxy close>
   	 							fd: result}}]]
     	ensure: [ name free ].
     ^result isAllOnes not! !

"August 3, 2009 -> 22:2:39"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
exists ^<Boolean>
	| name result |
	name := self nameProxy.
    [ result := {{<libc ExternalProxy open>
   	 					name: name
    					flags: 0}}.
    	result isAllOnes
    		ifFalse: [{{<libc ExternalProxy close>
   	 							fd: result}}]]
     	ensure: [ name free ].
    ^result isAllOnes not! !

"August 3, 2009 -> 22:3:27"!

"System saved" !
"August 8, 2009 -> 10:48:20"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
exists ^<Boolean>
	| name result |
	name := self nameProxy.
    [result := {{<libc ExternalProxy open>
   	 					name: name
    					flags: 0}}.
    result asInteger > 0
    	ifTrue: [{{<libc ExternalProxy close>
   							fd: result}}]]
     	ensure: [ name free ].
    ^result isAllOnes not! !

"August 8, 2009 -> 10:48:37"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
exists ^<Boolean>
	| name result |
	name := self nameProxy.
    [result := {{<libc ExternalProxy open>
   	 					name: name
    					flags: 0
    					ignored: 0}}.
    result asInteger > 0
    	ifTrue: [{{<libc ExternalProxy close>
   							fd: result}}]]
     	ensure: [ name free ].
    ^result isAllOnes not! !

"August 8, 2009 -> 10:50:4"!

"System saved" !
"August 9, 2009 -> 11:25:45"!

! (Delta mirrorFor: #NLRAlignmentTest) methodsFor: 'testing' !
invokeWithNone

	self call: [^0]! !

"August 9, 2009 -> 11:26:40"!

! (Delta mirrorFor: #NLRAlignmentTest) methodsFor: 'testing' !
testWithNone

	self assert: 0 == self invokeWithNone! !

"August 9, 2009 -> 11:26:54"!

! (Delta mirrorFor: #NLRAlignmentTest) methodsFor: 'testing' !
invokeWithOne

	self call: [^1] with: 0! !

"August 9, 2009 -> 11:27:17"!

! (Delta mirrorFor: #NLRAlignmentTest) methodsFor: 'testing' !
testWithOne

	self assert: 1 == self invokeWithOne! !

"August 9, 2009 -> 11:27:31"!

! (Delta mirrorFor: #NLRAlignmentTest) methodsFor: 'testing' !
invokeWithThree

	self call: [^3] with: 0 with: 0 with: 0! !

"August 9, 2009 -> 11:27:51"!

! (Delta mirrorFor: #NLRAlignmentTest) methodsFor: 'testing' !
testWithThree

	self assert: 3 == self invokeWithThree! !

"August 9, 2009 -> 12:16:31"!

! (Delta mirrorFor: #NLRAlignmentTest) methodsFor: 'testing' !
invokeWithTwo

	self call: [^2] with: 0 with: 0! !

"August 9, 2009 -> 12:16:54"!

! (Delta mirrorFor: #NLRAlignmentTest) methodsFor: 'testing' !
testWithTwo

	self assert: 3 == self invokeWithTwo! !

"August 9, 2009 -> 12:20:6"!

! (Delta mirrorFor: #NLRAlignmentTest) methodsFor: 'testing' !
testWithTwo

	self assert: 2 == self invokeWithTwo! !

"August 9, 2009 -> 12:20:57"!

"System saved" !
"August 13, 2009 -> 22:18:36"!

Delta define: #Alien as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:36"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Object' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
dataSize

	^self subclassResponsibility! !

"August 13, 2009 -> 22:18:37"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
new

	^self new: self dataSize! !

"August 13, 2009 -> 22:18:37"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
new: size <Integer> ^ <X>! !

"August 13, 2009 -> 22:18:37"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
new: size <Integer> ^ <X>

	^(super new: size)
		size: size;
		initialize! !

"August 13, 2009 -> 22:18:37"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
new: size <Integer> ^ <X>

	^(super primitiveNew: size)
		size: size;
		initialize! !

"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:37"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
new: size <Integer> ^ <X>

	^(super new: size)
		size: size;
		initialize! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
size: anInteger <Integer>

	size := anInteger! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
size ^<Integer>

	^size! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) methodsFor: 'instance initialization' !
initialize
	"Subclasses may override to perform specific initialization"! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
newC

	^self newC: self dataSize! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
newC: size <Integer> ^ <X>

	^(super new: 4)
		size: size negated;
		address: (self Ccalloc: size);
		initialize! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
address: anInteger <Integer>

	self unimplemented! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
address ^<Integer>

	self unimplemented! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
Ccalloc: size <Integer> ^ <Integer>

	^{{self primitiveAlienCalloc: size
		ifFail: [:err| self error: 'Failed to alloc alien: ', err]}}! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
Cmalloc: size <Integer> ^ <Integer>

	^{{self primitiveAlienMalloc: size
		ifFail: [:err| self error: 'Failed to malloc alien: ', err]}}! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
Ccalloc: size <Integer> ^ <Integer>

	^{{self primitiveAlienCalloc: size
		ifFail: [:err| self error: 'Failed to calloc alien: ', err]}}! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
newGC

	^self newGC: self dataSize! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
newGC: size <Integer> ^<X>

	| alien address |
	alien := (super new: 4).
	alien size: size negated.
	address := self Ccalloc: size.
	"GCMallocedAliens add: alien finalizing: address."
	^alien
		address: address;
		initialize
		! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
rawNewC: size <Integer> ^ <X>

	^(super new: 4)
		size: size negated;
		address: (self Cmalloc: size);
		initialize! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
atAddress: pointer <Integer> ^<X>! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
atAddress: pointer <Integer> ^<X>

	^(super new: 4)
		size: self dataSize negated;
		address: pointer;
		yourself! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
atAddress: pointer <Integer> ^<X>

	^(super primitiveNew: 4)
		size: self dataSize negated;
		address: pointer;
		yourself! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
new: size <Integer> ^ <X>

	^(super primitiveNew: size)
		size: size;
		initialize! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
newC: size <Integer> ^ <X>

	^(self primitiveNew: 4)
		size: size negated;
		address: (self Ccalloc: size);
		initialize! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
newGC: size <Integer> ^<X>

	| alien address |
	alien := self primitiveNew: 4.
	alien size: size negated.
	address := self Ccalloc: size.
	"GCMallocedAliens add: alien finalizing: address."
	^alien
		address: address;
		initialize
		! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
rawNewC: size <Integer> ^ <X>

	^(self primitiveNew: 4)
		size: size negated;
		address: (self Cmalloc: size);
		initialize! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
atAddress: pointer <Integer> dataSize: dataSize <Integer> ^<X>

	^(super primitiveNew: 4)
		size: dataSize negated;
		address: pointer;
		yourself! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
atAddress: pointer <Integer> dataSize: dataSize <Integer> ^<X>

	^(self primitiveNew: 4)
		size: dataSize negated;
		address: pointer;
		yourself! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
atAddress: pointer <Integer> ^<X>

	^(self primitiveNew: 4)
		size: self dataSize negated;
		address: pointer;
		yourself! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
new: size <Integer> ^ <X>

	^(self primitiveNew: size)
		size: size;
		initialize! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
forPointer: pointer <Integer> ^<X>

	^(self primitiveNew: 4)
		size: 0;
		address: pointer;
		yourself! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
autoFreeAfter: action <BlockWithOneArgument>
	"Evaluate the action, which must be a 1-argument block.
	 The argument passed to the action is a block the action
	 can use to register Aliens created inside the action.
	 Such aliens will be freed as soon as the action completes.
	 Return the value returned from the action. See usage
	 example at the bottom of the method. "
	
	| toFree |
	toFree := OrderedCollection new.
	^[action value: [:alien | toFree add: alien]]
		ensure: [toFree do: [:each | each free]]
		
"
	Alien autoFreeAfter:
		[:autoFree | | foo bar |
		foo := autoFree value: (Alien newCString: 'foo').
		bar := autoFree value: (Alien newCString: 'bar').
		...]
"! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
autoFreeAfter: action <OneArgumentBlock>
	"Evaluate the action, which must be a 1-argument block.
	 The argument passed to the action is a block the action
	 can use to register Aliens created inside the action.
	 Such aliens will be freed as soon as the action completes.
	 Return the value returned from the action. See usage
	 example at the bottom of the method. "
	
	| toFree |
	toFree := OrderedCollection new.
	^[action value: [:alien | toFree add: alien]]
		ensure: [toFree do: [:each | each free]]
		
"
	Alien autoFreeAfter:
		[:autoFree | | foo bar |
		foo := autoFree value: (Alien newCString: 'foo').
		bar := autoFree value: (Alien newCString: 'bar').
		...]
"! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
autoFreeAfter: action <[X, ^ Y]>
	"Evaluate the action, which must be a 1-argument block.
	 The argument passed to the action is a block the action
	 can use to register Aliens created inside the action.
	 Such aliens will be freed as soon as the action completes.
	 Return the value returned from the action. See usage
	 example at the bottom of the method. "
	
	| toFree |
	toFree := OrderedCollection new.
	^[action value: [:alien | toFree add: alien]]
		ensure: [toFree do: [:each | each free]]
		
"
	Alien autoFreeAfter:
		[:autoFree | | foo bar |
		foo := autoFree value: (Alien newCString: 'foo').
		bar := autoFree value: (Alien newCString: 'bar').
		...]
"! !

"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size') classVariables: 'GCMallocedAliens LoadedLibraries') !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size') classVariables: 'GCMallocedAliens LoadedLibraries') !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size') classVariables: 'GCMallocedAliens LoadedLibraries') !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size') classVariables: 'GCMallocedAliens LoadedLibraries') !


"August 13, 2009 -> 22:18:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: 'size') classVariables: 'GCMallocedAliens LoadedLibraries') !


"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'class initialization' !
initialize

	LoadedLibraries isNil ifTrue: 
		[LoadedLibraries := Dictionary new].
	GCMallocedAliens isNil ifTrue:
		[GCMallocedAlients := nil "AlienWeakTable newForOwner: self"]! !

"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'class initialization' !
initialize

	LoadedLibraries isNil ifTrue: 
		[LoadedLibraries := Dictionary new].
	GCMallocedAliens isNil ifTrue:
		[GCMallocedAlients := AlienWeakTable newForOwner: self]! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #AlienWeakTable) classSide methodsFor: 'instance creation' !
newForOwner: owner
	^self new initializeWithOwner: owner! !

"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #AlienWeakTable) methodsFor: 'initialization' !
initializeWithOwner: owner

	! !

"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUnusedInder <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUnusedInder <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUnusedInder <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUnusedInder <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:38"!

! (Delta mirrorFor: #AlienWeakTable) methodsFor: 'initialization' !
initializeWithOwner: owner

	accessProtect := Semaphore forMutualExclusion.! !

"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUnusedInder <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUnusedInder <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUnusedInder <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUnusedInder <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUnusedInder <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUnusedInder <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUnusedInder <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUnusedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUnusedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUnusedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUnusedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:38"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUnusedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:39"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUnusedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:39"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUnusedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:39"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUnusedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:39"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUnusedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:39"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUnusedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:39"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUnusedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:39"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUsedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:39"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUsedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:39"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUsedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:39"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUsedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #AlienWeakTable) methodsFor: 'initialization' !
initializeWithOwner: anOwner

	accessProtect := Semaphore forMutualExclusion.
	firstUnusedIndex := 1.
	lastUsedIndex := 0.
	weakArray := WeakArray new: 1024.
	strongArray := Array new: 1024.
	owner := anOwner.
	! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
newGC: size <Integer> ^<X>

	| alien address |
	alien := self primitiveNew: 4.
	alien size: size negated.
	address := self Ccalloc: size.
	GCMallocedAliens add: alien finalizing: address.
	^alien
		address: address;
		initialize
		! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #AlienWeakTable) methodsFor: 'adding' !
add: anObject finalizing: postMortemFinalizationTag
	"Register a new object in the table, with the associated tag.
	 The object is held onto weakly, the tag--strongly. The tag
	 will be passed to the owner as the argument of #finalize:
	 some time after the object is garbage collected."

	| size start delta |
	accessProtect critical:
		[size := strongArray size.
		 start := firstUnusedIndex].
	start to: size do:
		[:i|
		(strongArray at: i) == nil ifTrue:
			[accessProtect critical:
				[weakArray at: i put: anObject.
				 strongArray at: i put: postMortemFinalizationTag.
				 firstUnusedIndex := i + 1.
				 i > lastUsedIndex ifTrue: [lastUsedIndex := i]].
			 ^anObject]].
	delta := size min: 4096.
	accessProtect critical:
		[(weakArray := weakArray copyGrownBy: delta)
			 at: size + 1 put: anObject.
		 (strongArray := strongArray  copyGrownBy: delta)
			at: size put: postMortemFinalizationTag.
		 firstUnusedIndex := size + 1.
		 lastUsedIndex := size].
	^anObject! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'class initialization' !
initialize

	LoadedLibraries isNil ifTrue: 
		[LoadedLibraries := Dictionary new].
	GCMallocedAliens isNil ifTrue:
		[GCMallocedAliens := AlienWeakTable newForOwner: self]! !

"August 13, 2009 -> 22:18:39"!

(Delta mirrorFor: #GCMallocedAlients) removeDefinitionIfFail: [] !


"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #Array) methodsFor: 'copying' !
copyGrownBy: delta <Integer> ^<Array[EX]>
	{where EX is returnType of #anElement message of receiverType}

	^self copyWithSize: self size + delta! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
address: anInteger <Integer>

	{{self primitiveAlienAddress: anInteger}}! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
address ^<Integer>

	{{self primitiveAlienAddress}}! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'private - memory allocation' !
Cmalloc: size <Integer> ^ <Integer>

	^{{self primitiveAlienMalloc: size
			ifFail: [:err| self error: 'Failed to malloc alien: ', err]}}! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'private - memory allocation' !
Ccalloc: size <Integer> ^ <Integer>

	^{{self primitiveAlienCalloc: size
			ifFail: [:err| self error: 'Failed to calloc alien: ', err]}}! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
address ^<Integer>

	^self size <= 0
		ifTrue: [{{self primitiveAlienAddress}}]
		ifFalse: [self error: 'One cannot take the address of direct Alien instances; they may move']! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
addressField ^<Integer>

	^{{self primitiveAlienAddress}}! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
address ^<Integer>

	^self size <= 0
		ifTrue: [self addressField]
		ifFalse: [self error: 'One cannot take the address of direct Alien instances; they may move']! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
addressField: anInteger <Integer>

	{{self primitiveAlienAddress: anInteger}}! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
atAddress: pointer <Integer> ^<X>

	^(self primitiveNew: 4)
		size: self dataSize negated;
		addressField: pointer;
		yourself! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
atAddress: pointer <Integer> dataSize: dataSize <Integer> ^<X>

	^(self primitiveNew: 4)
		size: dataSize negated;
		addressField: pointer;
		yourself! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
forPointer: pointer <Integer> ^<X>

	^(self primitiveNew: 4)
		size: 0;
		addressField: pointer;
		yourself! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
newC: size <Integer> ^ <X>

	^(self primitiveNew: 4)
		size: size negated;
		addressField: (self Ccalloc: size);
		initialize! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
newGC: size <Integer> ^<X>

	| alien address |
	alien := self primitiveNew: 4.
	alien size: size negated.
	address := self Ccalloc: size.
	GCMallocedAliens add: alien finalizing: address.
	^alien
		addressField: address;
		initialize
		! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
rawNewC: size <Integer> ^ <X>

	^(self primitiveNew: 4)
		size: size negated;
		addressField: (self Cmalloc: size);
		initialize! !

"August 13, 2009 -> 22:18:39"!

(Delta mirrorFor: #Alien) removeMethod: #address: ifAbsent: [] !


"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedByteAt: index <Integer> ^<Integer>

	^self at: index! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedByteAt: index <Integer> put: byte <Integer> ^<Integer>

	^self at: index put: byte! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedByteAt: index <Integer> ^<Integer>

	|byte|
	byte := self at: index.
	^byte < 128
		ifTrue: [byte]
		ifFalse: [256 - byte]! !

"August 13, 2009 -> 22:18:39"!

Delta define: #AlienTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 13, 2009 -> 22:18:39"!

Delta define: #AlienTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 13, 2009 -> 22:18:39"!

Delta define: #AlienTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 13, 2009 -> 22:18:39"!

Delta define: #AlienTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 13, 2009 -> 22:18:39"!

Delta define: #AlienTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 13, 2009 -> 22:18:39"!

Delta define: #AlienTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 13, 2009 -> 22:18:39"!

Delta define: #AlienTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 13, 2009 -> 22:18:39"!

Delta define: #AlienTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 13, 2009 -> 22:18:39"!

Delta define: #AlienTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'alien')) !


"August 13, 2009 -> 22:18:39"!

Delta define: #AlienTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'alien')) !


"August 13, 2009 -> 22:18:39"!

Delta define: #AlienTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'alien')) !


"August 13, 2009 -> 22:18:39"!

Delta define: #AlienTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'alien')) !


"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'fixture' !
setUp

	alien := Alien new: 4! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedByteAccess

	alien unsignedByteAt: 1 put: 1.
	alien unsignedByteAt: 2 put: 2.
	alien unsignedByteAt: 3 put: 3.
	alien unsignedByteAt: 4 put: 4.
	self assert: (alien unsignedByteAt: 1) == 1! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedByteAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: index].
	1 to: 4 do: [:index|
		self assert: (alien unsignedByteAt: index) == index]! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedByteAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: index].
	1 to: 4 do: [:index|
		self assert: (alien unsignedByteAt: index) == index]! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedByteAccess

	1 to: 4 do: [:index|
		alien signedByteAt: index put: index].
	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index) == index]! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedByteAt: index <Integer> put: byte <Integer> ^<Integer>

	^self at: index put: (byte < 0 ifTrue: [byte + 256] ifFalse: [byte])! !

"August 13, 2009 -> 22:18:39"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedByteAccess

	1 to: 4 do: [:index|
		alien signedByteAt: index put: index].
	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index) == index].
	1 to: 4 do: [:index|
		alien signedByteAt: index put: index negated].
	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index) == index negated].! !

"August 13, 2009 -> 22:18:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedByteAt: index <Integer> put: byte <Integer> ^<Integer>

	^self at: index put: (byte < 0 ifTrue: [byte - 256] ifFalse: [byte])! !

"August 13, 2009 -> 22:18:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedByteAt: index <Integer> put: byte <Integer> ^<Integer>

	^self at: index put: (byte < 0 ifTrue: [byte + 256] ifFalse: [byte])! !

"August 13, 2009 -> 22:18:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedByteAt: index <Integer> ^<Integer>

	|byte|
	byte := self at: index.
	^byte < 128
		ifTrue: [byte]
		ifFalse: [(256 - byte) negated]! !

"August 13, 2009 -> 22:18:40"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: index].
	self assert: (alien unsignedShortAt: 1) == (2 * 256 + 1)! !

"August 13, 2009 -> 22:19:9"!

"System saved" !
"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> ^<Integer>

	^(self at: index) + (self at: index + 1) * 256! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> ^<Integer>

	^(self at: index) + ((self at: index + 1) * 256)! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: index].
	self assert: (alien unsignedShortAt: 1) == (2 * 256 + 1).
	alien unsignedShortAt: 2 put: 65535.
	self assert: (alien unsignedByteAt: 2) == 255.
	self assert: (alien unsignedByteAt: 3) == 255! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> put: short <Integer>^<Integer>

	^(self at: index) + ((self at: index + 1) * 256)! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> put: short <Integer>^<Integer>

	self at: index put: (short \\ 256).
	self at: index + 1 put: (short / 256).
	^short! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> put: short <Integer>^<Integer>

	self at: index put: (short \\ 256).
	self at: index + 1 put: (short // 256).
	^short! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: index].
	self assert: (alien unsignedShortAt: 1) == (2 * 256 + 1).
	self assert: (alien unsignedShortAt: 2 put: 65535) == 65535.
	self assert: (alien unsignedByteAt: 2) == 255.
	self assert: (alien unsignedByteAt: 3) == 255! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedByteAccess

	1 to: 4 do: [:index|
		self assert: (alien unsignedByteAt: index put: index) == index].
	1 to: 4 do: [:index|
		self assert: (alien unsignedByteAt: index) == index]! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedByteAt: index <Integer> put: byte <Integer> ^<Integer>

	self at: index put: byte.
	^byte! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedByteAccess

	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index put: index) == index].
	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index) == index].
	1 to: 4 do: [:index|
		alien signedByteAt: index put: index negated].
	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index) == index negated].! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedByteAt: index <Integer> put: byte <Integer> ^<Integer>

	self at: index put: (byte < 0 ifTrue: [byte + 256] ifFalse: [byte]).
	^byte! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: 255].
	self assert: (alien signedShortAt: 1) == -1! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> ^<Integer>

	|unsigned|
	unsigned := (self at: index) + ((self at: index + 1) * 256).
	^unsigned < 32768
		ifTrue: [unsigned]
		ifFalse: [65536 - unsigned]! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> ^<Integer>

	|unsigned|
	unsigned := (self at: index) + ((self at: index + 1) * 256).
	^unsigned < 32768
		ifTrue: [unsigned]
		ifFalse: [unsigned - 65536]! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: 255].
	self assert: (alien signedShortAt: 1) == -1
	self assert: (alien signedShortAt: 1 put: 255) == 255.
	self assert: (alien signedShortAt: 1) == 255! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> put: short <Integer> ^<Integer>

	|unsigned|
	unsigned := (self at: index) + ((self at: index + 1) * 256).
	^unsigned < 32768
		ifTrue: [unsigned]
		ifFalse: [unsigned - 65536]! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> put: short <Integer> ^<Integer>

	|unsigned|
	unsigned := short < 0
		ifTrue: [65536 + short]
		ifFalse: [short]
	self unsignedShortAt: index put: unsigned.
	^short! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> put: short <Integer> ^<Integer>

	|unsigned|
	unsigned := short < 0
		ifTrue: [65536 + short]
		ifFalse: [short].
	self unsignedShortAt: index put: unsigned.
	^short! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: 255].
	self assert: (alien signedShortAt: 1) == -1.
	self assert: (alien signedShortAt: 1 put: 255) == 255.
	self assert: (alien signedShortAt: 1) == 255! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedLongAccess

	|long|
	long := 256 * 256 + 1.
	self assert: (alien unsignedLongAt: 1 put: long) == long.! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedLongAt: index <Integer> put: long <Integer>^<Integer>

	self unsignedShortAt: index put: (long \\ (256 * 256)).
	self unsignedShortAt: index + 2 put: (long // (256 * 256)).
	^long! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedLongAccess

	|long|
	long := 256 * 256 + 1.
	self assert: (alien unsignedLongAt: 1 put: long) == long.
	self assert: (alien unsignedLongAt: 1) == long! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedLongAt: index <Integer> ^<Integer>

	^(self unsignedShortAt: index) + ((self unsignedShortAt: index + 2) * (256 * 256))! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedLongAccess

	|long|
	long := 256 * 256 + 1.
	self assert: (alien unsignedLongAt: 1 put: long) == long.
	self assert: (alien unsignedLongAt: 1) == long
	self assert: (alien unsignedByteAt: 1) == 1.
	self assert: (alien unsignedByteAt: 3) == 1! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedLongAccess

	|long|
	long := 256 * 256 + 1.
	self assert: (alien unsignedLongAt: 1 put: long) == long.
	self assert: (alien unsignedLongAt: 1) == long.
	self assert: (alien unsignedByteAt: 1) == 1.
	self assert: (alien unsignedByteAt: 3) == 1! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedByteAccess

	1 to: 4 do: [:index|
		self assert: (alien unsignedByteAt: index put: index) == index].
	1 to: 4 do: [:index|
		self assert: (alien unsignedByteAt: index) == index].
	self assert: (alien asUnsignedByte == 1)! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
asUnsignedByte

	^self unsignedByteAt: 1! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedByteAccess

	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index put: index) == index].
	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index) == index].
	1 to: 4 do: [:index|
		alien signedByteAt: index put: index negated].
	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index) == index negated].
	self assert: alien asSignedByte == -1! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
asSignedByte

	^self signedByteAt: 1! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: index].
	self assert: (alien unsignedShortAt: 1) == (2 * 256 + 1).
	self assert: (alien unsignedShortAt: 2 put: 65535) == 65535.
	self assert: (alien unsignedByteAt: 2) == 255.
	self assert: (alien unsignedByteAt: 3) == 255.
	self assert: alien asUnsignedShort == (2 * 256 + 1)! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
asUnsignedShort

	^self unsignedShortAt: 1! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: index].
	self assert: (alien unsignedShortAt: 1) == (2 * 256 + 1).
	self assert: (alien unsignedShortAt: 2 put: 65535) == 65535.
	self assert: (alien unsignedByteAt: 2) == 255.
	self assert: (alien unsignedByteAt: 3) == 255.
	self assert: alien asUnsignedShort == (255 * 256 + 1)! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: 255].
	self assert: (alien signedShortAt: 1) == -1.
	self assert: (alien signedShortAt: 1 put: 255) == 255.
	self assert: (alien signedShortAt: 1) == 255.
	self assert: alien asSignedShort == 255! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
asSignedShort

	^self signedShortAt: 1! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedLongAccess

	|long|
	long := (256 * 256 + 1) negated.
	self assert: (alien signedLongAt: 1 put: long) == long.
	self assert: (alien signedLongAt: 1) == long.
	self assert: (alien unsignedByteAt: 1) == 255.
	self assert: (alien unsignedByteAt: 3) == 254! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedLongAt: index <Integer> put: long <Integer>^<Integer>

	|unsigned|
	unsigned := long < 0
		ifTrue: [(256 * 256 * 256 * 256) + long]
		ifFalse: [long].
	self unsignedLongAt: index put: unsigned.
	^long! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedLongAt: index <Integer> put: long <Integer>^<Integer>

	|unsigned|
	unsigned := long < 0
		ifTrue: [4294967296 + long]
		ifFalse: [long].
	self unsignedLongAt: index put: unsigned.
	^long! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedLongAt: index <Integer> ^<Integer>

	|unsigned|
	unsigned := (self unsignedShortAt: index) + ((self unsignedShortAt: index + 2) * 65536).
	^unsigned < 2147483648
		ifTrue: [unsigned]
		ifFalse: [unsigned - 4294967296]! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedLongAccess

	|long|
	long := (256 * 256 + 1) negated.
	self assert: (alien signedLongAt: 1 put: long) = long.
	self assert: (alien signedLongAt: 1) = long.
	self assert: (alien unsignedByteAt: 1) == 255.
	self assert: (alien unsignedByteAt: 3) == 254! !

"August 16, 2009 -> 1:26:3"!

Delta define: #LargeIntegerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #LargeIntegerTest) methodsFor: 'testing' !
testUnderflow

	self deny: SmallInteger maxVal + 1 * 8 - 1 = -1! !

"August 16, 2009 -> 1:26:3"!

! (Delta mirrorFor: #LargeIntegerTest) methodsFor: 'testing' !
testUnderflow

	self deny: SmallInteger maxVal + 1 * 8 + 1 negated = -1! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #LargeIntegerTest) methodsFor: 'testing' !
testUnderflow

	self deny: SmallInteger maxVal + 1 * 8 + 1 negated = -1! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> ^<Integer>

	^(self at: index) + (self at: index + 1) * 256! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> ^<Integer>

	^(self at: index) + ((self at: index + 1) * 256)! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: index].
	self assert: (alien unsignedShortAt: 1) == (2 * 256 + 1).
	alien unsignedShortAt: 2 put: 65535.
	self assert: (alien unsignedByteAt: 2) == 255.
	self assert: (alien unsignedByteAt: 3) == 255! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> put: short <Integer>^<Integer>

	^(self at: index) + ((self at: index + 1) * 256)! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> put: short <Integer>^<Integer>

	self at: index put: (short \\ 256).
	self at: index + 1 put: (short / 256).
	^short! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> put: short <Integer>^<Integer>

	self at: index put: (short \\ 256).
	self at: index + 1 put: (short // 256).
	^short! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: index].
	self assert: (alien unsignedShortAt: 1) == (2 * 256 + 1).
	self assert: (alien unsignedShortAt: 2 put: 65535) == 65535.
	self assert: (alien unsignedByteAt: 2) == 255.
	self assert: (alien unsignedByteAt: 3) == 255! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedByteAccess

	1 to: 4 do: [:index|
		self assert: (alien unsignedByteAt: index put: index) == index].
	1 to: 4 do: [:index|
		self assert: (alien unsignedByteAt: index) == index]! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedByteAt: index <Integer> put: byte <Integer> ^<Integer>

	self at: index put: byte.
	^byte! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedByteAccess

	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index put: index) == index].
	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index) == index].
	1 to: 4 do: [:index|
		alien signedByteAt: index put: index negated].
	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index) == index negated].! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedByteAt: index <Integer> put: byte <Integer> ^<Integer>

	self at: index put: (byte < 0 ifTrue: [byte + 256] ifFalse: [byte]).
	^byte! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: 255].
	self assert: (alien signedShortAt: 1) == -1! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> ^<Integer>

	|unsigned|
	unsigned := (self at: index) + ((self at: index + 1) * 256).
	^unsigned < 32768
		ifTrue: [unsigned]
		ifFalse: [65536 - unsigned]! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> ^<Integer>

	|unsigned|
	unsigned := (self at: index) + ((self at: index + 1) * 256).
	^unsigned < 32768
		ifTrue: [unsigned]
		ifFalse: [unsigned - 65536]! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: 255].
	self assert: (alien signedShortAt: 1) == -1
	self assert: (alien signedShortAt: 1 put: 255) == 255.
	self assert: (alien signedShortAt: 1) == 255! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> put: short <Integer> ^<Integer>

	|unsigned|
	unsigned := (self at: index) + ((self at: index + 1) * 256).
	^unsigned < 32768
		ifTrue: [unsigned]
		ifFalse: [unsigned - 65536]! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> put: short <Integer> ^<Integer>

	|unsigned|
	unsigned := short < 0
		ifTrue: [65536 + short]
		ifFalse: [short]
	self unsignedShortAt: index put: unsigned.
	^short! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> put: short <Integer> ^<Integer>

	|unsigned|
	unsigned := short < 0
		ifTrue: [65536 + short]
		ifFalse: [short].
	self unsignedShortAt: index put: unsigned.
	^short! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: 255].
	self assert: (alien signedShortAt: 1) == -1.
	self assert: (alien signedShortAt: 1 put: 255) == 255.
	self assert: (alien signedShortAt: 1) == 255! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedLongAccess

	|long|
	long := 256 * 256 + 1.
	self assert: (alien unsignedLongAt: 1 put: long) == long.! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedLongAt: index <Integer> put: long <Integer>^<Integer>

	self unsignedShortAt: index put: (long \\ (256 * 256)).
	self unsignedShortAt: index + 2 put: (long // (256 * 256)).
	^long! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedLongAccess

	|long|
	long := 256 * 256 + 1.
	self assert: (alien unsignedLongAt: 1 put: long) == long.
	self assert: (alien unsignedLongAt: 1) == long! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedLongAt: index <Integer> ^<Integer>

	^(self unsignedShortAt: index) + ((self unsignedShortAt: index + 2) * (256 * 256))! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedLongAccess

	|long|
	long := 256 * 256 + 1.
	self assert: (alien unsignedLongAt: 1 put: long) == long.
	self assert: (alien unsignedLongAt: 1) == long
	self assert: (alien unsignedByteAt: 1) == 1.
	self assert: (alien unsignedByteAt: 3) == 1! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedLongAccess

	|long|
	long := 256 * 256 + 1.
	self assert: (alien unsignedLongAt: 1 put: long) == long.
	self assert: (alien unsignedLongAt: 1) == long.
	self assert: (alien unsignedByteAt: 1) == 1.
	self assert: (alien unsignedByteAt: 3) == 1! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedByteAccess

	1 to: 4 do: [:index|
		self assert: (alien unsignedByteAt: index put: index) == index].
	1 to: 4 do: [:index|
		self assert: (alien unsignedByteAt: index) == index].
	self assert: (alien asUnsignedByte == 1)! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
asUnsignedByte

	^self unsignedByteAt: 1! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedByteAccess

	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index put: index) == index].
	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index) == index].
	1 to: 4 do: [:index|
		alien signedByteAt: index put: index negated].
	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index) == index negated].
	self assert: alien asSignedByte == -1! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
asSignedByte

	^self signedByteAt: 1! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: index].
	self assert: (alien unsignedShortAt: 1) == (2 * 256 + 1).
	self assert: (alien unsignedShortAt: 2 put: 65535) == 65535.
	self assert: (alien unsignedByteAt: 2) == 255.
	self assert: (alien unsignedByteAt: 3) == 255.
	self assert: alien asUnsignedShort == (2 * 256 + 1)! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
asUnsignedShort

	^self unsignedShortAt: 1! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: index].
	self assert: (alien unsignedShortAt: 1) == (2 * 256 + 1).
	self assert: (alien unsignedShortAt: 2 put: 65535) == 65535.
	self assert: (alien unsignedByteAt: 2) == 255.
	self assert: (alien unsignedByteAt: 3) == 255.
	self assert: alien asUnsignedShort == (255 * 256 + 1)! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: 255].
	self assert: (alien signedShortAt: 1) == -1.
	self assert: (alien signedShortAt: 1 put: 255) == 255.
	self assert: (alien signedShortAt: 1) == 255.
	self assert: alien asSignedShort == 255! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
asSignedShort

	^self signedShortAt: 1! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> ^<Integer>

	^(self at: index) + (self at: index + 1) * 256! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> ^<Integer>

	^(self at: index) + ((self at: index + 1) * 256)! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: index].
	self assert: (alien unsignedShortAt: 1) == (2 * 256 + 1).
	alien unsignedShortAt: 2 put: 65535.
	self assert: (alien unsignedByteAt: 2) == 255.
	self assert: (alien unsignedByteAt: 3) == 255! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> put: short <Integer>^<Integer>

	^(self at: index) + ((self at: index + 1) * 256)! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> put: short <Integer>^<Integer>

	self at: index put: (short \\ 256).
	self at: index + 1 put: (short / 256).
	^short! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> put: short <Integer>^<Integer>

	self at: index put: (short \\ 256).
	self at: index + 1 put: (short // 256).
	^short! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: index].
	self assert: (alien unsignedShortAt: 1) == (2 * 256 + 1).
	self assert: (alien unsignedShortAt: 2 put: 65535) == 65535.
	self assert: (alien unsignedByteAt: 2) == 255.
	self assert: (alien unsignedByteAt: 3) == 255! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedByteAccess

	1 to: 4 do: [:index|
		self assert: (alien unsignedByteAt: index put: index) == index].
	1 to: 4 do: [:index|
		self assert: (alien unsignedByteAt: index) == index]! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedByteAt: index <Integer> put: byte <Integer> ^<Integer>

	self at: index put: byte.
	^byte! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedByteAccess

	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index put: index) == index].
	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index) == index].
	1 to: 4 do: [:index|
		alien signedByteAt: index put: index negated].
	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index) == index negated].! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedByteAt: index <Integer> put: byte <Integer> ^<Integer>

	self at: index put: (byte < 0 ifTrue: [byte + 256] ifFalse: [byte]).
	^byte! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: 255].
	self assert: (alien signedShortAt: 1) == -1! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> ^<Integer>

	|unsigned|
	unsigned := (self at: index) + ((self at: index + 1) * 256).
	^unsigned < 32768
		ifTrue: [unsigned]
		ifFalse: [65536 - unsigned]! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> ^<Integer>

	|unsigned|
	unsigned := (self at: index) + ((self at: index + 1) * 256).
	^unsigned < 32768
		ifTrue: [unsigned]
		ifFalse: [unsigned - 65536]! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: 255].
	self assert: (alien signedShortAt: 1) == -1
	self assert: (alien signedShortAt: 1 put: 255) == 255.
	self assert: (alien signedShortAt: 1) == 255! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> put: short <Integer> ^<Integer>

	|unsigned|
	unsigned := (self at: index) + ((self at: index + 1) * 256).
	^unsigned < 32768
		ifTrue: [unsigned]
		ifFalse: [unsigned - 65536]! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> put: short <Integer> ^<Integer>

	|unsigned|
	unsigned := short < 0
		ifTrue: [65536 + short]
		ifFalse: [short]
	self unsignedShortAt: index put: unsigned.
	^short! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> put: short <Integer> ^<Integer>

	|unsigned|
	unsigned := short < 0
		ifTrue: [65536 + short]
		ifFalse: [short].
	self unsignedShortAt: index put: unsigned.
	^short! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: 255].
	self assert: (alien signedShortAt: 1) == -1.
	self assert: (alien signedShortAt: 1 put: 255) == 255.
	self assert: (alien signedShortAt: 1) == 255! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedLongAccess

	|long|
	long := 256 * 256 + 1.
	self assert: (alien unsignedLongAt: 1 put: long) == long.! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedLongAt: index <Integer> put: long <Integer>^<Integer>

	self unsignedShortAt: index put: (long \\ (256 * 256)).
	self unsignedShortAt: index + 2 put: (long // (256 * 256)).
	^long! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedLongAccess

	|long|
	long := 256 * 256 + 1.
	self assert: (alien unsignedLongAt: 1 put: long) == long.
	self assert: (alien unsignedLongAt: 1) == long! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedLongAt: index <Integer> ^<Integer>

	^(self unsignedShortAt: index) + ((self unsignedShortAt: index + 2) * (256 * 256))! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedLongAccess

	|long|
	long := 256 * 256 + 1.
	self assert: (alien unsignedLongAt: 1 put: long) == long.
	self assert: (alien unsignedLongAt: 1) == long
	self assert: (alien unsignedByteAt: 1) == 1.
	self assert: (alien unsignedByteAt: 3) == 1! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedLongAccess

	|long|
	long := 256 * 256 + 1.
	self assert: (alien unsignedLongAt: 1 put: long) == long.
	self assert: (alien unsignedLongAt: 1) == long.
	self assert: (alien unsignedByteAt: 1) == 1.
	self assert: (alien unsignedByteAt: 3) == 1! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedByteAccess

	1 to: 4 do: [:index|
		self assert: (alien unsignedByteAt: index put: index) == index].
	1 to: 4 do: [:index|
		self assert: (alien unsignedByteAt: index) == index].
	self assert: (alien asUnsignedByte == 1)! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
asUnsignedByte

	^self unsignedByteAt: 1! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedByteAccess

	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index put: index) == index].
	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index) == index].
	1 to: 4 do: [:index|
		alien signedByteAt: index put: index negated].
	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index) == index negated].
	self assert: alien asSignedByte == -1! !

"August 16, 2009 -> 1:26:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
asSignedByte

	^self signedByteAt: 1! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: index].
	self assert: (alien unsignedShortAt: 1) == (2 * 256 + 1).
	self assert: (alien unsignedShortAt: 2 put: 65535) == 65535.
	self assert: (alien unsignedByteAt: 2) == 255.
	self assert: (alien unsignedByteAt: 3) == 255.
	self assert: alien asUnsignedShort == (2 * 256 + 1)! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
asUnsignedShort

	^self unsignedShortAt: 1! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: index].
	self assert: (alien unsignedShortAt: 1) == (2 * 256 + 1).
	self assert: (alien unsignedShortAt: 2 put: 65535) == 65535.
	self assert: (alien unsignedByteAt: 2) == 255.
	self assert: (alien unsignedByteAt: 3) == 255.
	self assert: alien asUnsignedShort == (255 * 256 + 1)! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: 255].
	self assert: (alien signedShortAt: 1) == -1.
	self assert: (alien signedShortAt: 1 put: 255) == 255.
	self assert: (alien signedShortAt: 1) == 255.
	self assert: alien asSignedShort == 255! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
asSignedShort

	^self signedShortAt: 1! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> ^<Integer>

	^(self at: index) + (self at: index + 1) * 256! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> ^<Integer>

	^(self at: index) + ((self at: index + 1) * 256)! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: index].
	self assert: (alien unsignedShortAt: 1) == (2 * 256 + 1).
	alien unsignedShortAt: 2 put: 65535.
	self assert: (alien unsignedByteAt: 2) == 255.
	self assert: (alien unsignedByteAt: 3) == 255! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> put: short <Integer>^<Integer>

	^(self at: index) + ((self at: index + 1) * 256)! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> put: short <Integer>^<Integer>

	self at: index put: (short \\ 256).
	self at: index + 1 put: (short / 256).
	^short! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> put: short <Integer>^<Integer>

	self at: index put: (short \\ 256).
	self at: index + 1 put: (short // 256).
	^short! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: index].
	self assert: (alien unsignedShortAt: 1) == (2 * 256 + 1).
	self assert: (alien unsignedShortAt: 2 put: 65535) == 65535.
	self assert: (alien unsignedByteAt: 2) == 255.
	self assert: (alien unsignedByteAt: 3) == 255! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedByteAccess

	1 to: 4 do: [:index|
		self assert: (alien unsignedByteAt: index put: index) == index].
	1 to: 4 do: [:index|
		self assert: (alien unsignedByteAt: index) == index]! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedByteAt: index <Integer> put: byte <Integer> ^<Integer>

	self at: index put: byte.
	^byte! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedByteAccess

	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index put: index) == index].
	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index) == index].
	1 to: 4 do: [:index|
		alien signedByteAt: index put: index negated].
	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index) == index negated].! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedByteAt: index <Integer> put: byte <Integer> ^<Integer>

	self at: index put: (byte < 0 ifTrue: [byte + 256] ifFalse: [byte]).
	^byte! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: 255].
	self assert: (alien signedShortAt: 1) == -1! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> ^<Integer>

	|unsigned|
	unsigned := (self at: index) + ((self at: index + 1) * 256).
	^unsigned < 32768
		ifTrue: [unsigned]
		ifFalse: [65536 - unsigned]! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> ^<Integer>

	|unsigned|
	unsigned := (self at: index) + ((self at: index + 1) * 256).
	^unsigned < 32768
		ifTrue: [unsigned]
		ifFalse: [unsigned - 65536]! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: 255].
	self assert: (alien signedShortAt: 1) == -1
	self assert: (alien signedShortAt: 1 put: 255) == 255.
	self assert: (alien signedShortAt: 1) == 255! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> put: short <Integer> ^<Integer>

	|unsigned|
	unsigned := (self at: index) + ((self at: index + 1) * 256).
	^unsigned < 32768
		ifTrue: [unsigned]
		ifFalse: [unsigned - 65536]! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> put: short <Integer> ^<Integer>

	|unsigned|
	unsigned := short < 0
		ifTrue: [65536 + short]
		ifFalse: [short]
	self unsignedShortAt: index put: unsigned.
	^short! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> put: short <Integer> ^<Integer>

	|unsigned|
	unsigned := short < 0
		ifTrue: [65536 + short]
		ifFalse: [short].
	self unsignedShortAt: index put: unsigned.
	^short! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: 255].
	self assert: (alien signedShortAt: 1) == -1.
	self assert: (alien signedShortAt: 1 put: 255) == 255.
	self assert: (alien signedShortAt: 1) == 255! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedLongAccess

	|long|
	long := 256 * 256 + 1.
	self assert: (alien unsignedLongAt: 1 put: long) == long.! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedLongAt: index <Integer> put: long <Integer>^<Integer>

	self unsignedShortAt: index put: (long \\ (256 * 256)).
	self unsignedShortAt: index + 2 put: (long // (256 * 256)).
	^long! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedLongAccess

	|long|
	long := 256 * 256 + 1.
	self assert: (alien unsignedLongAt: 1 put: long) == long.
	self assert: (alien unsignedLongAt: 1) == long! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedLongAt: index <Integer> ^<Integer>

	^(self unsignedShortAt: index) + ((self unsignedShortAt: index + 2) * (256 * 256))! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedLongAccess

	|long|
	long := 256 * 256 + 1.
	self assert: (alien unsignedLongAt: 1 put: long) == long.
	self assert: (alien unsignedLongAt: 1) == long
	self assert: (alien unsignedByteAt: 1) == 1.
	self assert: (alien unsignedByteAt: 3) == 1! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedLongAccess

	|long|
	long := 256 * 256 + 1.
	self assert: (alien unsignedLongAt: 1 put: long) == long.
	self assert: (alien unsignedLongAt: 1) == long.
	self assert: (alien unsignedByteAt: 1) == 1.
	self assert: (alien unsignedByteAt: 3) == 1! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedByteAccess

	1 to: 4 do: [:index|
		self assert: (alien unsignedByteAt: index put: index) == index].
	1 to: 4 do: [:index|
		self assert: (alien unsignedByteAt: index) == index].
	self assert: (alien asUnsignedByte == 1)! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
asUnsignedByte

	^self unsignedByteAt: 1! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedByteAccess

	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index put: index) == index].
	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index) == index].
	1 to: 4 do: [:index|
		alien signedByteAt: index put: index negated].
	1 to: 4 do: [:index|
		self assert: (alien signedByteAt: index) == index negated].
	self assert: alien asSignedByte == -1! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
asSignedByte

	^self signedByteAt: 1! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: index].
	self assert: (alien unsignedShortAt: 1) == (2 * 256 + 1).
	self assert: (alien unsignedShortAt: 2 put: 65535) == 65535.
	self assert: (alien unsignedByteAt: 2) == 255.
	self assert: (alien unsignedByteAt: 3) == 255.
	self assert: alien asUnsignedShort == (2 * 256 + 1)! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
asUnsignedShort

	^self unsignedShortAt: 1! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: index].
	self assert: (alien unsignedShortAt: 1) == (2 * 256 + 1).
	self assert: (alien unsignedShortAt: 2 put: 65535) == 65535.
	self assert: (alien unsignedByteAt: 2) == 255.
	self assert: (alien unsignedByteAt: 3) == 255.
	self assert: alien asUnsignedShort == (255 * 256 + 1)! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedShortAccess

	1 to: 4 do: [:index|
		alien unsignedByteAt: index put: 255].
	self assert: (alien signedShortAt: 1) == -1.
	self assert: (alien signedShortAt: 1 put: 255) == 255.
	self assert: (alien signedShortAt: 1) == 255.
	self assert: alien asSignedShort == 255! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
asSignedShort

	^self signedShortAt: 1! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedLongAccess

	|long|
	long := (256 * 256 + 1) negated.
	self assert: (alien signedLongAt: 1 put: long) == long.
	self assert: (alien signedLongAt: 1) == long.
	self assert: (alien unsignedByteAt: 1) == 255.
	self assert: (alien unsignedByteAt: 3) == 254! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedLongAt: index <Integer> put: long <Integer>^<Integer>

	|unsigned|
	unsigned := long < 0
		ifTrue: [(256 * 256 * 256 * 256) + long]
		ifFalse: [long].
	self unsignedLongAt: index put: unsigned.
	^long! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedLongAt: index <Integer> put: long <Integer>^<Integer>

	|unsigned|
	unsigned := long < 0
		ifTrue: [4294967296 + long]
		ifFalse: [long].
	self unsignedLongAt: index put: unsigned.
	^long! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedLongAt: index <Integer> ^<Integer>

	|unsigned|
	unsigned := (self unsignedShortAt: index) + ((self unsignedShortAt: index + 2) * 65536).
	^unsigned < 2147483648
		ifTrue: [unsigned]
		ifFalse: [unsigned - 4294967296]! !

"August 16, 2009 -> 1:26:5"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedLongAccess

	|long|
	long := (256 * 256 + 1) negated.
	self assert: (alien signedLongAt: 1 put: long) = long.
	self assert: (alien signedLongAt: 1) = long.
	self assert: (alien unsignedByteAt: 1) == 255.
	self assert: (alien unsignedByteAt: 3) == 254! !

"August 16, 2009 -> 1:27:35"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
smallIntLimit

	^SmallInteger maxVal + 1! !

"August 16, 2009 -> 1:28:32"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
fourByteLimit

	^self smallIntLimit * 8! !

"August 16, 2009 -> 1:28:54"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
unsignedFourByteLimit

	^self smallIntLimit * 8! !

"August 16, 2009 -> 1:29:7"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
signedFourByteLimit

	^self smallIntLimit * 4! !

"August 16, 2009 -> 1:29:14"!

(Delta mirrorFor: #Alien) removeMethod: #fourByteLimit ifAbsent: [] !


"August 16, 2009 -> 1:30:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedLongAt: index <Integer> ^<Integer>

	|unsigned|
	unsigned := (self unsignedShortAt: index) + ((self unsignedShortAt: index + 2) * 65536).
	^unsigned < self signedFourByteLimit
		ifTrue: [unsigned]
		ifFalse: [unsigned - self unsignedFourByteLimit]! !

"August 16, 2009 -> 1:30:16"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedLongAt: index <Integer> put: long <Integer>^<Integer>

	|unsigned|
	unsigned := long < 0
		ifTrue: [self unsignedFourByteLimit + long]
		ifFalse: [long].
	self unsignedLongAt: index put: unsigned.
	^long! !

"August 16, 2009 -> 1:35:48"!

"System saved" !
"August 16, 2009 -> 1:39:5"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedLongAccess

	|long|
	long := (256 * 256 + 1) negated.
	self assert: (alien signedLongAt: 1 put: long) = long.
	self assert: (alien signedLongAt: 1) = long.
	self assert: (alien unsignedByteAt: 1) == 255.
	self assert: (alien unsignedByteAt: 3) == 254.
	self assert: alien asSignedLong = long! !

"August 16, 2009 -> 1:39:36"!

! (Delta mirrorFor: #Alien) methodsFor: 'converting' !
asSignedLong

	^self signedLongAt: 1! !

"August 16, 2009 -> 1:40:29"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedLongAccess

	|long|
	long := 256 * 256 + 1.
	self assert: (alien unsignedLongAt: 1 put: long) == long.
	self assert: (alien unsignedLongAt: 1) == long.
	self assert: (alien unsignedByteAt: 1) == 1.
	self assert: (alien unsignedByteAt: 3) == 1.
	self assert: alien asUnsignedLong = long! !

"August 16, 2009 -> 1:41:8"!

! (Delta mirrorFor: #Alien) methodsFor: 'converting' !
asUnsignedLong

	^self unsignedLongAt: 1! !

"August 16, 2009 -> 1:42:36"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testDataSize

	self assert: alien dataSize == 4! !

"August 16, 2009 -> 1:42:56"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
dataSize ^<Integer>

	^self size abs! !

"August 16, 2009 -> 1:45:6"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testBoolAccess

	self assert: (alien boolAt: 1 put: true).
	self assert: (alien boolAt: 1).
	self deny: (alien boolAt: 1 put: false).
	self deny: (alien boolAt: 1)! !

"August 16, 2009 -> 1:46:52"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
boolAt: index <Integer> put: value <Boolean> ^<Boolean>

	self at: 1 put: (value ifTrue: [1] ifFalse: [0]).
	^value! !

"August 16, 2009 -> 1:47:43"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
boolAt: index <Integer> ^<Boolean>

	^(self at: 1) ~~ 0! !

"August 16, 2009 -> 1:49:12"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testAsAlien

	self assert: alien asAlien == alien! !

"August 16, 2009 -> 1:49:32"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
asAlien

	^self! !

"August 16, 2009 -> 2:9:26"!

"System saved" !
"August 16, 2009 -> 19:50:21"!

"System saved" !
"August 16, 2009 -> 19:58:6"!

Delta define: #PointerAlienTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 16, 2009 -> 19:58:20"!

Delta define: #PointerAlienTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'pointer')) !


"August 16, 2009 -> 19:59:13"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'fixture' !
setUp

	pointer := Alien forPointer: (Alien Ccalloc: 4)! !

"August 16, 2009 -> 20:0:3"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'fixture' !
tearDown

	pointer free! !

"August 16, 2009 -> 20:0:31"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'testing' !
testIsPointer

	self assert: pointer isPointer! !

"August 16, 2009 -> 20:2:31"!

"System saved" !
"August 18, 2009 -> 21:7:19"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
addressField: anInteger <Integer>

	self signedLongAt: 1 put: anInteger! !

"August 18, 2009 -> 21:7:19"!

! (Delta mirrorFor: #Alien) methodsFor: 'testing' !
isPointer

	^self size == 0! !

"August 18, 2009 -> 21:7:19"!

! (Delta mirrorFor: #Alien) methodsFor: 'deallocation' !
free! !

"August 18, 2009 -> 21:7:19"!

! (Delta mirrorFor: #Alien) methodsFor: 'deallocation' !
free

	{{self primitiveAlienFree}}! !

"August 18, 2009 -> 21:7:19"!

! (Delta mirrorFor: #Alien) methodsFor: 'deallocation' !
free

	{{primitiveAlienFree: self ifFail: [:err| self error: 'Could not free alien']}}! !

"August 18, 2009 -> 21:7:19"!

! (Delta mirrorFor: #Alien) methodsFor: 'deallocation' !
free

	{{primitiveAlienFree: self ifFail: [:err| self error: 'Could not free alien: ', err]}}! !

"August 18, 2009 -> 21:7:19"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
addressField ^<Integer>

	^self signedLongAt: 1! !

"August 18, 2009 -> 21:7:19"!

! (Delta mirrorFor: #Alien) methodsFor: 'deallocation' !
free

	{{primitiveAlienFree: self addressField
		ifFail: [:err| self error: 'Could not free alien: ', err]}}! !

"August 18, 2009 -> 21:7:19"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'testing' !
testFreeingTwiceShouldFail

	pointer free.
	self should: [pointer free] raise: Error! !

"August 18, 2009 -> 21:7:19"!

! (Delta mirrorFor: #Alien) methodsFor: 'deallocation' !
free

	{{primitiveAlienFree: self addressField
		ifFail: [:err| self error: 'Could not free alien: ', err]}}.
	self addressField: 0! !

"August 18, 2009 -> 21:7:19"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'fixture' !
tearDown

	[pointer free]
		on: Error
		do: [:ignore|]! !

"August 18, 2009 -> 21:8:5"!

"System saved" !
"August 22, 2009 -> 14:20:50"!

Delta define: #Mirror as: (
(Class subclassOf: 'Object' instanceVariables: '') abstract) !


"August 22, 2009 -> 14:20:51"!

Delta define: #Mirror as: (
(Class subclassOf: 'Object' instanceVariables: '') abstract) !


"August 22, 2009 -> 14:20:51"!

Delta define: #Mirror as: (
(Class subclassOf: 'Object' instanceVariables: '') abstract) !


"August 22, 2009 -> 14:20:51"!

Delta define: #Mirror as: (
(Class subclassOf: 'Object' instanceVariables: '') abstract) !


"August 22, 2009 -> 14:20:51"!

Delta define: #Mirror as: (
(Class subclassOf: 'Object' instanceVariables: '') abstract) !


"August 22, 2009 -> 14:20:51"!

Delta define: #Mirror as: (
(Class subclassOf: 'Object' instanceVariables: '') abstract) !


"August 22, 2009 -> 14:20:51"!

Delta define: #Mirror as: (
(Class subclassOf: 'Object' instanceVariables: '') abstract) !


"August 22, 2009 -> 14:20:51"!

Delta define: #Mirror as: (
(Class subclassOf: 'Object' instanceVariables: '') abstract) !


"August 22, 2009 -> 14:20:51"!

Delta define: #Mirror as: (
(Class subclassOf: 'Object' instanceVariables: '') abstract) !


"August 22, 2009 -> 14:20:51"!

Delta define: #Mirror as: (
(Class subclassOf: 'Object' instanceVariables: '') abstract) !


"August 22, 2009 -> 14:20:51"!

Delta define: #Mirror as: (
(Class subclassOf: 'Object' instanceVariables: '') abstract) !


"August 22, 2009 -> 14:20:51"!

(Delta mirrorFor: #Mirror)
comment: 
'Mirrors are used in the Strongtalk system as the reflective interface
used to examine objects.  This replaces the way reflection is
done in other Smalltalks, which use a battery of reflective messages
supported by Object and Behavior.  

The reason for this difference is a philisophical one that has an
important benefit.  The philisophical reason is encapsulation: an object''s
interface should be as independent as possible of its implementation.
The benefit is that good encapsulation allows you to create alternative
implementations that behave identically.

But standard Smalltalk violates this principle, because all the reflective
message go through an objects interface (#class, etc),  which means
they are really a hole in the object''s encapsulation.  Mirrors are a way
around this problem.  The idea is that you shouldn''t talk to an object
directly to examine it reflectively, which would violate its interface
encapsulation.  Instead, you ask the system to create a ''mirror'' on that
object, which you can use to ''reflect'' on it (pun).  So if you want to
examine an object o reflectively, you say (Mirror on: o), and the mirror
supports all the reflective operations instead of the object.

This also has the benefit of cleaning up an object''s interface, since it
doesn''t have to support all the reflective messages that the system
(inspectors, etc) uses to manipulate.   This also makes the type system
protocols for objects simpler.

Some of the most common reflective messages in standard Smalltalk-80
(such as #class, #isKindOf:, etc)
are still supported in Strongtalk, but because the system code doesn''t
use them, you are free to reimplement them, so that an object can pretend
to have a different class, for example, without breaking any system code.

Note: the concept (and name) of Mirrors comes from the Self system.

Tags:  %User

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license
'!


"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) classSide methodsFor: 'Unclassified' !
classFor: e < Class | Protocol | Mixin | TypeAlias | GlobalAssociation> ^ <Mirror class>

	"This is not at all object-oriented. However, it maintains the complete separation of
		Mirrors and is quite simple "

(Metaclass == e class class or: [Metaclass == e class]) ifTrue:[^AbstractClassMirror classFor: e].
(Protocol  == e class  or:[ MetaProtocol == e class]) ifTrue:[^ProtocolMirror].
TypeAlias == e class ifTrue:[^TypeAliasMirror].
GlobalAssociation == e class ifTrue:[^GlobalVariableMirror].
^MixinMirror classFor: e
! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) classSide methodsFor: 'Unclassified' !
classReferenceTo: n <Symbol> ^ <DeltaClassId>

^DeltaClassId new setId: n; scope: DeltaGlobals! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) classSide methodsFor: 'Unclassified' !
metaclassReferenceTo: n <Symbol>

^(self classReferenceTo: n) dualClassType! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) classSide methodsFor: 'Unclassified' !
on: element <Class|Mixin|Protocol|TypeAlias|GlobalAssociation> ^ <Instance>

^(self classFor: element) on: element! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
comment  ^ <Str> 

^self sourceInfo comment! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
comment: c  <Str> 

self sourceInfo comment: c
! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
convert: c   <Mirror> ifFail: fb <[Str]>
" The purpose of this method is to convert the definition represented by
the mirror C into myself, if possible. If not, the failure block fb should be
called"
self subclassResponsibility! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
convert: m <Mirror> toGeneric: g   <GenericMirror> ifFail: fb <[Str]>

fb value: 'Cannot convert ', self name, ' into a generic'.! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
convertToClass: c   <ClassMirror> ifFail: fb <[Str]>

fb value: 'Cannot convert ', self name, 'into a class'.! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
convertToGeneric: g <GenericMirror> ifFail: fb <[Str]>

g body convert: self toGeneric: g ifFail: fb.



! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
convertToGenericClass: g <GenericMirror> ifFail: fb <[Str]>

fb value: 'Cannot convert ', self name, ' into a generic class'




! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
convertToGenericMixin: g <GenericMirror> ifFail: fb <[Str]>

fb value: 'Cannot convert ', self name, ' into a generic mirror'
! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
convertToGenericProtocol: g <GenericMirror> ifFail: fb <[Str]>

fb value: 'Cannot convert ', self name, ' into a generic protocol'




! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
convertToGlobalVariable: g <GlobalVariableMirror> ifFail: fb <[Str]>

fb value: 'Cannot convert ', self name, ' into a global variable'.! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
convertToMixin: m <MixinDeclMirror> ifFail: fb <[Str]>

fb value: 'Cannot convert', self name, ' into a mixin'.! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
convertToProtocol: p <ProtocolMirror> ifFail: fb <[Str]>

Delta at: self name put: p reflectee




! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
definitionString   ^ <Str>


self sourceInfo isGeneric ifTrue:[^(GenericMirror new body: self) definitionString].
^self basicDefinitionString.! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
definitionWriterClass ^ <DefinitionWriter class>

^DefinitionWriter! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
fileName  ^<Str>
	^self name, self fileNameExtension! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
fileNameExtension  ^<Str>
	^'.dlt'! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
group ^ <Str>

	"File-out group for definition"
	^self sourceInfo group
! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
group: s <Str>

	"File-out group for definition"
	self sourceInfo group: s
! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
hasTypeInfoLoaded ^ <Boolean>

^Type hasTypeInfoFor: self reflectee! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
isGeneric ^ <Boolean>
    ^ self sourceInfo isGeneric! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
isGeneric: b  <Boolean>
    self sourceInfo isGeneric: b! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
isMeta ^ <Boolean>

self subclassResponsibility! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
mayNeedToUnwind

"Used to mark where we may have to use unwind:protect:
to preserve system integrity"! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
name  ^ <Symbol> 

^self reflectee name! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
name: n <Symbol> ifFail: fb <[Str]>
"i"
"This method can be invoked by the Delta environment to create a  class
named n based upon the source code information in this object.
Handling differs depending on whether an entity named n already exists or not.
"
| exists <Boolean> |

exists := (Delta includesKey: n) and:[(Delta at: n) isError not].

exists ifTrue:[self nameExisting: n ifFail: fb]
             ifFalse:[self nameNew: n ifFail: fb].

(Mirror on: (Delta at: n))  sourceInfo logDefinition.
! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
nestInGenericWithTypeArguments: tas  <Str>

self subclassResponsibility! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
nonAtomic

self deltaHack.! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
placeHolder

^DeltaPlaceHolderError new name: self name! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
placeHolderFor: name <Symbol>

^DeltaPlaceHolderError new name: name! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
printOn: aStream  <Stream> 
	aStream 
		nextPutAll: self class name;
		nextPutAll: ' on ';
		nextPutAll: self name.
! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
priorReflecteeFor: n <Symbol> ^ <Mirror>
	^(Delta at: n) isNil 
									ifTrue:[Delta assocAt: n] "it's a global created as forward reference"
									ifFalse:[Delta at: n].

! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
reflectee  ^ <T>

self subclassResponsibility! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
removeDefinitionIfFail: blk <[]>

	"Remove entry from system dictionary and source database"

	self isMeta
		ifTrue: [	^blk value: 'Cannot remove on meta side'  ].
	self sourceInfo removeIndex.
	Smalltalk removeKey: self name.
	self reflectee: nil.
	^nil
! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
rename: oldId <Symbol> to: newId <Symbol>
"All mirrors must provide a method that renames oldId to newId throughout
their source code"
self subclassResponsibility! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
rename: oldId <Symbol> to: newId <Symbol> in: s <Str> ^ <Str>
"
Callers can rely on the identity of the returned string to know whether a change has taken place;
if no change was made, the incoming parameter 's' is returned.
"
| renamed <Str>  changed <Boolean> |

changed := false.
renamed := TokenStreamEditor  transform: s
		using:[: sym <Symbol> :v <Object> :str <Str> | 
					sym  = #identifier  
						ifTrue:[v = oldId 
												ifTrue:[
															changed := true.
															newId]
												 ifFalse:[str]
									] ifFalse:[str]]
		ifFail:[:s <Str>  :i <Int> | self error: s].
^changed ifTrue:[renamed] ifFalse:[s].! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
renameGroup: grp <Dict[Symbol,Symbol]> 
" grp maps old name to new names.
All mirrors must provide a method that uses the mapping
defined by grp to rename throughout their source code"
self subclassResponsibility! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
renameGroup: grp <Dict[Symbol,Symbol]> in: s <Str> ^ <Str>
"
Callers can rely on the identity of the returned string to know whether a change has taken place;
if no change was made, the incoming parameter 's' is returned.
Right now we determine this by comparing s against the renamed string. Shortly, we will
change this so we remember if we ever made a change."
| renamed <Str>  changed <Boolean> |

changed := false.
renamed := TokenStreamEditor  transform: s
		using:[: sym <Symbol> :v <Object> :str <Str> | 
					sym  = #identifier 
						ifTrue:[
										(grp includesKey: v) ifTrue:[changed := true].
										grp at:  v ifAbsent:[str]
									] 
						ifFalse:[str]
					]
		ifFail:[:s <Str>  :i <Int> | self error: s].
^changed ifTrue:[renamed] ifFalse:[s].! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
renameTo: newId <Symbol>

Smalltalk definitionsReflectiveDo:[ :d <Mirror> | d rename: self name to: newId].! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
revision ^ <Str>

	"Revision for file-out"
	^self sourceInfo revision
! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
revision: s <Str>

	"Revision for file-out"
	self sourceInfo revision: s
! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
sourceInfo ^ <CommonSourceHandler>

self subclassResponsibility! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
typecheck

self subclassResponsibility! !

"August 22, 2009 -> 14:20:51"!

! (Delta mirrorFor: #Mirror) methodsFor: 'accessing' !
nameWithTypeArgs ^ <Str>

	"Returns the name with generic type argument names appended, e.g. Set[E]"
	
	| stream <CharReadWriteStream> tas <OrdCltn[TypeFormal]> |
	stream := (String new: self name size) writeStream.
	stream nextPutAll: self name.

	self isGeneric ifTrue: [	
		tas := self hasTypeInfoLoaded
			ifTrue: [		self typeInfo asGeneric formals ]
			ifFalse: [	 (DeltaParser new 
										parseTypeArgs: self typeArgumentString 
										within: DeltaGlobals 
										ifError: [ :msg <Str> :pos <Int> | self shouldNotHappen ]) 
									collect: [ :pt <ParseTree[TypeFormal]> | pt body ] ].
									
		stream nextPut: $[.
		1 to: tas size - 1 do: [ :index <Int> |
			stream 
				nextPutAll: (tas at: index) name;
				nextPut: $, ].
		stream nextPutAll: (tas at: tas size) name.
		stream nextPut: $].
	].

	^stream
	! !

"August 22, 2009 -> 14:21:51"!

Delta define: #DeltaTuple as: (
(Class subclassOf: 'DeltaArray' instanceVariables: '')) !


"August 22, 2009 -> 14:21:51"!

(Delta mirrorFor: #DeltaTuple)
comment: 
''!


"August 22, 2009 -> 14:21:51"!

! (Delta mirrorFor: #DeltaTuple) methodsFor: 'a new category' !
apply: aTool <DeltaTool > ^ <Self>
	aTool tupleNode: self! !

"August 22, 2009 -> 14:21:51"!

! (Delta mirrorFor: #DeltaTuple) methodsFor: 'a new category' !
elements ^ <OrderedCollection[ASTNode]>
	^self value! !

"August 22, 2009 -> 14:21:51"!

! (Delta mirrorFor: #DeltaTuple) methodsFor: 'a new category' !
isArrayNode
    ^ false! !

"August 22, 2009 -> 14:21:51"!

! (Delta mirrorFor: #DeltaTuple) methodsFor: 'a new category' !
isTupleNode
    ^ true! !

"August 22, 2009 -> 14:22:20"!

Delta define: #ASTtoRichTextTool as: (
Generic forAll: 'E ' body: ((Class subclassOf: 'DeltaASTTool' instanceVariables: 'result <SeqCltn[Tuple[[Character,^E],Tuple[Int,Int]]]>
parseTrees <Cltn[ParseTree[ASTNode]]>
currentParseTree <ParseTree[ASTNode]>
selectorEnd <Int>
selectorBuilder <[Character,^E]>
codeBuilder <[Character,^E]>
commentBuilder <[Character,^E]>
typeexpressionBuilder <[Character,^E]>
inferenceclauseBuilder <[Character,^E]>
defaultBuilder <[Character,^E]>
'))) !


"August 22, 2009 -> 14:22:20"!

Delta define: #ASTtoRichTextTool as: (
Generic forAll: 'E ' body: ((Class subclassOf: 'DeltaASTTool' instanceVariables: 'result <SeqCltn[Tuple[[Character,^E],Tuple[Int,Int]]]>
parseTrees <Cltn[ParseTree[ASTNode]]>
currentParseTree <ParseTree[ASTNode]>
selectorEnd <Int>
selectorBuilder <[Character,^E]>
codeBuilder <[Character,^E]>
commentBuilder <[Character,^E]>
typeexpressionBuilder <[Character,^E]>
inferenceclauseBuilder <[Character,^E]>
defaultBuilder <[Character,^E]>
'))) !


"August 22, 2009 -> 14:22:20"!

Delta define: #ASTtoRichTextTool as: (
Generic forAll: 'E ' body: ((Class subclassOf: 'DeltaASTTool' instanceVariables: 'result <SeqCltn[Tuple[[Character,^E],Tuple[Int,Int]]]>
parseTrees <Cltn[ParseTree[ASTNode]]>
currentParseTree <ParseTree[ASTNode]>
selectorEnd <Int>
selectorBuilder <[Character,^E]>
codeBuilder <[Character,^E]>
commentBuilder <[Character,^E]>
typeexpressionBuilder <[Character,^E]>
inferenceclauseBuilder <[Character,^E]>
defaultBuilder <[Character,^E]>
'))) !


"August 22, 2009 -> 14:22:20"!

Delta define: #ASTtoRichTextTool as: (
Generic forAll: 'E ' body: ((Class subclassOf: 'DeltaASTTool' instanceVariables: 'result <SeqCltn[Tuple[[Character,^E],Tuple[Int,Int]]]>
parseTrees <Cltn[ParseTree[ASTNode]]>
currentParseTree <ParseTree[ASTNode]>
selectorEnd <Int>
selectorBuilder <[Character,^E]>
codeBuilder <[Character,^E]>
commentBuilder <[Character,^E]>
typeexpressionBuilder <[Character,^E]>
inferenceclauseBuilder <[Character,^E]>
defaultBuilder <[Character,^E]>
'))) !


"August 22, 2009 -> 14:22:20"!

Delta define: #ASTtoRichTextTool as: (
Generic forAll: 'E ' body: ((Class subclassOf: 'DeltaASTTool' instanceVariables: 'result <SeqCltn[Tuple[[Character,^E],Tuple[Int,Int]]]>
parseTrees <Cltn[ParseTree[ASTNode]]>
currentParseTree <ParseTree[ASTNode]>
selectorEnd <Int>
selectorBuilder <[Character,^E]>
codeBuilder <[Character,^E]>
commentBuilder <[Character,^E]>
typeexpressionBuilder <[Character,^E]>
inferenceclauseBuilder <[Character,^E]>
defaultBuilder <[Character,^E]>
'))) !


"August 22, 2009 -> 14:22:20"!

Delta define: #ASTtoRichTextTool as: (
Generic forAll: 'E ' body: ((Class subclassOf: 'DeltaASTTool' instanceVariables: 'result <SeqCltn[Tuple[[Character,^E],Tuple[Int,Int]]]>
parseTrees <Cltn[ParseTree[ASTNode]]>
currentParseTree <ParseTree[ASTNode]>
selectorEnd <Int>
selectorBuilder <[Character,^E]>
codeBuilder <[Character,^E]>
commentBuilder <[Character,^E]>
typeexpressionBuilder <[Character,^E]>
inferenceclauseBuilder <[Character,^E]>
defaultBuilder <[Character,^E]>
'))) !


"August 22, 2009 -> 14:22:20"!

Delta define: #ASTtoRichTextTool as: (
Generic forAll: 'E ' body: ((Class subclassOf: 'DeltaASTTool' instanceVariables: 'result <SeqCltn[Tuple[[Character,^E],Tuple[Int,Int]]]>
parseTrees <Cltn[ParseTree[ASTNode]]>
currentParseTree <ParseTree[ASTNode]>
selectorEnd <Int>
selectorBuilder <[Character,^E]>
codeBuilder <[Character,^E]>
commentBuilder <[Character,^E]>
typeexpressionBuilder <[Character,^E]>
inferenceclauseBuilder <[Character,^E]>
defaultBuilder <[Character,^E]>
'))) !


"August 22, 2009 -> 14:22:20"!

Delta define: #ASTtoRichTextTool as: (
Generic forAll: 'E ' body: ((Class subclassOf: 'DeltaASTTool' instanceVariables: 'result <SeqCltn[Tuple[[Character,^E],Tuple[Int,Int]]]>
parseTrees <Cltn[ParseTree[ASTNode]]>
currentParseTree <ParseTree[ASTNode]>
selectorEnd <Int>
selectorBuilder <[Character,^E]>
codeBuilder <[Character,^E]>
commentBuilder <[Character,^E]>
typeexpressionBuilder <[Character,^E]>
inferenceclauseBuilder <[Character,^E]>
defaultBuilder <[Character,^E]>
'))) !


"August 22, 2009 -> 14:22:20"!

Delta define: #ASTtoRichTextTool as: (
Generic forAll: 'E ' body: ((Class subclassOf: 'DeltaASTTool' instanceVariables: 'result <SeqCltn[Tuple[[Character,^E],Tuple[Int,Int]]]>
parseTrees <Cltn[ParseTree[ASTNode]]>
currentParseTree <ParseTree[ASTNode]>
selectorEnd <Int>
selectorBuilder <[Character,^E]>
codeBuilder <[Character,^E]>
commentBuilder <[Character,^E]>
typeexpressionBuilder <[Character,^E]>
inferenceclauseBuilder <[Character,^E]>
defaultBuilder <[Character,^E]>
'))) !


"August 22, 2009 -> 14:22:20"!

Delta define: #ASTtoRichTextTool as: (
Generic forAll: 'E ' body: ((Class subclassOf: 'DeltaASTTool' instanceVariables: 'result <SeqCltn[Tuple[[Character,^E],Tuple[Int,Int]]]>
parseTrees <Cltn[ParseTree[ASTNode]]>
currentParseTree <ParseTree[ASTNode]>
selectorEnd <Int>
selectorBuilder <[Character,^E]>
codeBuilder <[Character,^E]>
commentBuilder <[Character,^E]>
typeexpressionBuilder <[Character,^E]>
inferenceclauseBuilder <[Character,^E]>
defaultBuilder <[Character,^E]>
'))) !


"August 22, 2009 -> 14:22:20"!

Delta define: #ASTtoRichTextTool as: (
Generic forAll: 'E ' body: ((Class subclassOf: 'DeltaASTTool' instanceVariables: 'result <SeqCltn[Tuple[[Character,^E],Tuple[Int,Int]]]>
parseTrees <Cltn[ParseTree[ASTNode]]>
currentParseTree <ParseTree[ASTNode]>
selectorEnd <Int>
selectorBuilder <[Character,^E]>
codeBuilder <[Character,^E]>
commentBuilder <[Character,^E]>
typeexpressionBuilder <[Character,^E]>
inferenceclauseBuilder <[Character,^E]>
defaultBuilder <[Character,^E]>
'))) !


"August 22, 2009 -> 14:22:20"!

Delta define: #ASTtoRichTextTool as: (
Generic forAll: 'E ' body: ((Class subclassOf: 'DeltaASTTool' instanceVariables: 'result <SeqCltn[Tuple[[Character,^E],Tuple[Int,Int]]]>
parseTrees <Cltn[ParseTree[ASTNode]]>
currentParseTree <ParseTree[ASTNode]>
selectorEnd <Int>
selectorBuilder <[Character,^E]>
codeBuilder <[Character,^E]>
commentBuilder <[Character,^E]>
typeexpressionBuilder <[Character,^E]>
inferenceclauseBuilder <[Character,^E]>
defaultBuilder <[Character,^E]>
'))) !


"August 22, 2009 -> 14:22:20"!

(Delta mirrorFor: #ASTtoRichTextTool)
comment: 
'Tool generating information for printing sources with rich text.

The tool generates a sequencable collection of elements of type E.
The generated collection will have the same size as the source.
E is the type of the rich text used for each character, e.g. Glyph.

The elements in the resulting collection are built by the 5 builders:

	selectorBuilder <[Character,^E]>
	typeexpressionBuilder <[Character,^E]>
	inferenceclauseBuilder <[Character,^E]>
	codeBuilder <[Character,^E]>
	commentBuilder <[Character,^E]>

The tool has to be parameterized with these 5 builder blocks. 
It is also possible to set a default builder block

	defaultBuilder <[Str, ^E]>
	
which will be used if one of the above mentioned are not specified.
 (c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"August 22, 2009 -> 14:22:20"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'accessing' !
compute ^ <SeqCltn[E]>	
	
	| value <SeqCltn[E]> |
	self insertCommentIntervals.								"Add comment intervals from scanner"
	self parseTrees do: [ :pt <ParseTree> |
		self currentParseTree: pt.
		pt body apply: self ].											"Add AST based intervals"
	self insertSelectorAndCodeIntervals.			"Add remaining intervals"
	self sortResult.

	value := OrderedCollection[E] new: self source size.
	self result do: [ :e <Tuple[[Character,^E], Tuple[Int,Int]]> | 
		e at2 at1 to: e at2 at2 - 1 do: [ :index <Int> |
			value add: (e at1 value: (self source at: index)) ] ].

	self assert: [ value size = self source size ].
	^value
! !

"August 22, 2009 -> 14:22:20"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'accessing' !
parseTree: pt <ParseTree[ASTNode]>

	self parseTrees: (OrderedCollection[ParseTree[ASTNode]] with: pt).
! !

"August 22, 2009 -> 14:22:20"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'accessing' !
parseTrees ^ <Cltn[ParseTree[ASTNode]]>

	^parseTrees! !

"August 22, 2009 -> 14:22:20"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'accessing' !
parseTrees: pts <Cltn[ParseTree[ASTNode]]>

	| src <Str> |
	self initialize.

	"Verify that the source pointers in the list of parse trees are identical"
	self assert: [ pts size > 0 ].
	src := pts first source.
	2 to: pts size do: [ :i <Int> | self assert: [ (pts at: i) source = src ] ].
	
	parseTrees := pts! !

"August 22, 2009 -> 14:22:20"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'builders' !
codeBuilder ^ <[Character,^E]>

	^codeBuilder isNil
		ifTrue: [		self defaultBuilder ]
		ifFalse: [	codeBuilder ]
		! !

"August 22, 2009 -> 14:22:20"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'builders' !
codeBuilder: b <[Character,^E]>

	codeBuilder := b! !

"August 22, 2009 -> 14:22:20"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'builders' !
commentBuilder ^ <[Character,^E]>

	^commentBuilder isNil
		ifTrue: [		self defaultBuilder ]
		ifFalse: [	commentBuilder ]
		! !

"August 22, 2009 -> 14:22:20"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'builders' !
commentBuilder: b <[Character,^E]>

	commentBuilder := b! !

"August 22, 2009 -> 14:22:20"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'builders' !
defaultBuilder ^ <[Character,^E]>

	defaultBuilder isNil
		ifTrue: [	self error: 'Default builder not specified' ].
	^defaultBuilder! !

"August 22, 2009 -> 14:22:20"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'builders' !
defaultBuilder: b <[Character,^E]>

	defaultBuilder := b! !

"August 22, 2009 -> 14:22:20"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'builders' !
inferenceclauseBuilder ^ <[Character,^E]>

	^inferenceclauseBuilder isNil
		ifTrue: [		self defaultBuilder ]
		ifFalse: [	inferenceclauseBuilder ]
		! !

"August 22, 2009 -> 14:22:20"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'builders' !
inferenceclauseBuilder: b <[Character,^E]>

	inferenceclauseBuilder := b! !

"August 22, 2009 -> 14:22:20"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'builders' !
selectorBuilder ^ <[Character,^E]>

	^selectorBuilder isNil
		ifTrue: [		self defaultBuilder ]
		ifFalse: [	selectorBuilder ]
		! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'builders' !
selectorBuilder: b <[Character,^E]>

	selectorBuilder := b! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'builders' !
typeexpressionBuilder ^ <[Character,^E]>

	^typeexpressionBuilder isNil
		ifTrue: [		self defaultBuilder ]
		ifFalse: [	typeexpressionBuilder ]
		! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'builders' !
typeexpressionBuilder: b <[Character,^E]>

	typeexpressionBuilder := b! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
assignmentNode: node <DeltaAssignment >
    node expr apply: self.! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
blockNode: node <DeltaBlock> ^ <Self>
    node body apply: self.
! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
cascadedSendNode: node <DeltaCascadedSend>
    node prevSend apply: self.
    node msg apply: self.! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
classVarNode: node <DeltaInstVar > 

	self varNode: node! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
codeBodyNode: node <DeltaCodeBody >
    node parameters do: [ :d <DeltaParameter>  | d apply: self ].
    node temporaries do: [ :d <DeltaTemporary>  | d apply: self ].
    node statements do: [ :d <DeltaStatement>  | d apply: self ]! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
dllCallNode: node <DeltaDLLCall>
    node msg apply: self.! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
genericApplicationExpressionNode: node <DeltaGenericApplicationExpression >

	"Mark the actuals of the generic application as a type expression"

	| position <Tuple[Int,Int]> | 
	position := self currentParseTree positionForNode: node.
	self addToResultCheckOverlap: self typeexpressionBuilder ,, ((position at1 + node target name size) ,, position at2).
	node target apply: self.
    ! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
guaranteedNode: node <DeltaGuaranteed >

	"Mark the declared type as a type expression"

	| nodePosition <Tuple[Int,Int]> typePosition <Tuple[Int,Int]> | 
	nodePosition := self currentParseTree positionForNode: node.
	typePosition := self findTypeExprIntervalFrom: (self currentParseTree positionForNode: node declaredType).
	self addToResultCheckOverlap: self typeexpressionBuilder ,, (nodePosition at1 ,, typePosition at2).
    node expr apply: self.
    ! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
instVarNode: node <DeltaInstVar > 

	self varNode: node! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
literalNode: node <DeltaLiteral >! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
messageNode: node <DeltaMessage >
    node args do: [ :s <DeltaExpression>  | s apply: self].! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
messagePatternNode: node <MessagePattern>
    node type apply: self
! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
methodDeclNode: node <DeltaMethod>
    node filteree apply: self.
! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
methodNode: node <DeltaMethod>
    node type apply: self.
    node body apply: self.
! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
msgSignatureNode: node <DeltaMsgSignature>

	"We process the type nodes in the domain here. Note that we have to skip them when traversing the
		method parameters, see #parameterNode:. This should be changed at some point - they should
		only be reachable from one place"
	
	| position <Tuple[Int,Int]> domainPosition <Tuple[Int,Int]> |
	
	node domain do: [ :domainNode <DeltaType>  | 
		domainNode isError
			ifFalse: [	domainPosition := self currentParseTree positionForNode: domainNode. 
								self addToResultCheckOverlap: self typeexpressionBuilder ,, (self findTypeExprIntervalFrom: domainPosition) ] ].
	
    position := self currentParseTree positionForNode: node range.
    self selectorEnd: position at1.
    (position at2 - position at1) > 0
    	ifTrue: [	"An explicit return type was given"
    					self addToResultCheckOverlap: self typeexpressionBuilder ,, (self findReturnTypeExprIntervalFrom: position) ]
! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
normalSendNode: node <DeltaSend>
    node recv apply: self.
    node msg apply: self.! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
parameterNode: node <DeltaParameter>

	| methodScope <Scope> realParameterNode <DeltaParameter> position <Tuple[Int,Int]> |
	
	"The first hack below is due to the fact that the rewriter inserts artificial parameters into the AST
		when rewriting loops.
		The second hack below is due to the fact that the types of method parameters are reachable
		from both the method message signature and the parameters in the method code body.
		This should be changed at some point. Also note that CodeScopes hold state and have the parameters 
		copied down for method code bodies. The real parameter present in the parse tree can in this case be 
		found in the super scope. This should really be changed at some point."
	
	self deltaHack.
	node isIntroducedByRewriter ifTrue: [ ^ self ].						"Ignore index parameter inserted by the rewriter."
		
	methodScope := self currentParseTree body scope.		"This is a CodeScope"
	(methodScope parameters includes: node)
		ifTrue: [		"We are in a method code body. We should only process the parameter name.
								The type node is processed in #msgSignatureNode:"
							realParameterNode := methodScope superScope at: node name.
							position := self currentParseTree positionForNode: realParameterNode.
							self addToResultCheckOverlap: self codeBuilder ,, (position at1 ,, (position at1 + realParameterNode name size)) ]
		ifFalse: [	self varNode: node  ].
! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
polyMsgSignatureNode: node <PolyMsgSignature>

	"The formals contain the inferred type variables Some stem from magical
	'def' clauses and others stem from a real inference clause. The latter will have
	their inference clause node present in the parse tree for the method. We take
	any one of them and use it for selecting the entire {where ...} expression."
	
	| tvPos <Tuple[Int,Int]> inferenceClausePos <Tuple[Int,Int]> |
	node formals do: [ :tv <InferredTypeVar> |
		(tvPos := self currentParseTree positionForNode: tv inferenceClause ifAbsent: [nil]) notNil
			ifTrue: [	inferenceClausePos := tvPos ] ].
	inferenceClausePos notNil
		ifTrue: [	self addToResultCheckOverlap: self inferenceclauseBuilder ,, (self findInferenceClauseIntervalFrom: inferenceClausePos) ].

	node body apply: self.! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
primitiveNode: node <DeltaPrimitiveNode>
    node recv isNil ifFalse:[node recv apply: self].
    node msg apply: self.! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
refNode: node <DeltaRef>
! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
returnStatNode: node <DeltaReturnStat>
    node expr apply: self.
! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
superSendNode: node <DeltaSuperSend>
    node msg apply: self.! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
temporaryNode: node <DeltaTemporary>

	self deltaHack.
	node isIntroducedByRewriter ifTrue: [ ^ self ].		"ignore temporaries introduced by rewriter"
	self varNode: node! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'node traversal' !
tupleNode: node <DeltaTule>
	node elements do:[:e | e apply: self]! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'private' !
addToResult: t <Tuple[[Character,^E],Tuple[Int,Int]]>
	"Add tuple to result without checking for overlap with existing intervals"
	self result addLast: t! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'private' !
addToResultCheckOverlap: t <Tuple[[Character,^E],Tuple[Int,Int]]>
	"Add tuple to result and checking for overlap with existing intervals.
	The existing intervals can only be fully embedded in the new interval."

	| embeddedIntervals <SeqCltn[Tuple[Int,Int]]> nextBegin <Int> |
	embeddedIntervals := OrderedCollection[Tuple[Int,Int]] new.
	self result do: [ :e <Tuple[[Character,^E],Tuple[Int,Int]]> |
		(t at2 at1 < e at2 at1 and: [ e at2 at2 < t at2 at2 ])
			ifTrue: [	embeddedIntervals add: e at2 ] ].
	embeddedIntervals := embeddedIntervals asSortedCollection:
		[ :i1 <Tuple[Int,Int]> :i2 <Tuple[Int,Int]> |
			i1 at1 <= i2 at1 ].
	nextBegin := t at2 at1.
	embeddedIntervals do: [ :i <Tuple[Int,Int]> |
		self result add: t at1 ,, (nextBegin ,, i at1).
		nextBegin := i at2 ].
	self result add: t at1 ,, (nextBegin ,, t at2 at2).
! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'private' !
currentParseTree ^ <ParseTree[ASTNode]>

	^currentParseTree! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'private' !
currentParseTree: pt <ParseTree[ASTNode]>

	currentParseTree := pt! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'private' !
findInferenceClauseIntervalFrom: position <Tuple[Int,Int]> ^ <Tuple[Int,Int]>

	| begin <Int> end <Int> |
	begin := position at1.
	end := position at2.
	[ (self source at: begin) = ${ ] whileFalse: [
		begin := begin - 1.
		self assert: [ begin > 0 ] ].
	[ (self source at: end) = $} ] whileFalse: [
		end := end + 1.
		self assert: [ end <= self source size ] ].
	^begin ,, (end + 1)
	
	! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'private' !
findReturnTypeExprIntervalFrom: position <Tuple[Int,Int]> ^ <Tuple[Int,Int]>

	| returnPos <Int> begin <Int> |
	returnPos := self findTypeExprIntervalFrom: position.
	begin := returnPos at1.
	[ (self source at: begin) = $^] whileFalse: [
		begin := begin - 1.
		self assert: [ begin > 0 ] ].
	^begin ,, returnPos at2





! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'private' !
findTypeExprIntervalFrom: position <Tuple[Int,Int]> ^ <Tuple[Int,Int]>

	| begin <Int> end <Int> |
	begin := position at1.
	end := position at2.
	[ (self source at: begin) = $< ] whileFalse: [
		begin := begin - 1.
		self assert: [ begin > 0 ] ].
	[ (self source at: end) = $> ] whileFalse: [
		end := end + 1.
		self assert: [ end <= self source size ] ].
	^begin ,, (end + 1)
	
	! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'private' !
insertCommentIntervals

	"All parsetrees will hold the same source and comment positions"
	self parseTrees first commentPositions do: [ :cp <Tuple[Int,Int]> |
		self addToResult: self commentBuilder ,, cp ]
! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'private' !
insertSelectorAndCodeIntervals

	| newIntervals <SeqCltn[Tuple[[Character,^E],Tuple[Int,Int]]]> nextBegin <Int> currentBuilder <[Character,^E]> |
	self sortResult.
	currentBuilder := self selectorBuilder.
	nextBegin := 1.
	newIntervals := OrderedCollection[Tuple[[Character,^E],Tuple[Int,Int]]] new.
	self result do: [ :e <Tuple[[Character,^E],Tuple[Int,Int]]> |
		nextBegin >= self selectorEnd
			ifTrue: [		currentBuilder := self codeBuilder ].
		e at2 at1 > nextBegin
			ifTrue: [ 		(nextBegin < self selectorEnd and: [self selectorEnd < e at2 at1])
									ifTrue: [	newIntervals add: currentBuilder ,, (nextBegin ,, self selectorEnd).
													currentBuilder := self codeBuilder.
													nextBegin := self selectorEnd ].
								newIntervals add: currentBuilder ,, (nextBegin ,, e at2 at1) ].
		nextBegin := e at2 at2 ].
	nextBegin > self source size 
			ifFalse: [ 	nextBegin < self selectorEnd
									ifTrue: [	newIntervals add: currentBuilder ,, (nextBegin ,, self selectorEnd).
													currentBuilder := self codeBuilder.
													nextBegin := self selectorEnd ].
								currentBuilder := self codeBuilder.
								newIntervals add: currentBuilder ,, (nextBegin ,, (self source size + 1)) ].
	newIntervals do: [ :e <Tuple[[Character,^E],Tuple[Int,Int]]> |
		self addToResult: e ].! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'private' !
result ^ <SeqCltn[Tuple[[Character,^E],Tuple[Int,Int]]]>

	^result! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'private' !
result: r <SeqCltn[Tuple[[Character,^E],Tuple[Int,Int]]]>

	result := r! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'private' !
selectorEnd ^ <Int>

	selectorEnd isNil
		ifTrue: [		^0 ]								"#selectorEnd: not called, assume no selector in source"
		ifFalse: [	^selectorEnd ]! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'private' !
selectorEnd: i <Int>

	self assert: [ i isNil or: [ selectorEnd isNil ]].
	selectorEnd := i! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'private' !
sortResult

	self result: 
		(OrderedCollection[Tuple[[Character,^E],Tuple[Int,Int]]] withAll:
			(self result asSortedCollection: 
				[ :t1 <Tuple[[Character,^E],Tuple[Int,Int]]> :t2 <Tuple[[Character,^E],Tuple[Int,Int]]> |
					t1 at2 at1 <= t2 at2 at1 ]))
! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'private' !
source ^ <Str>

	^self parseTrees first source! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'private' !
varNode: node <DeltaVar>

	| position <Tuple[Int,Int]> |
	position := self currentParseTree positionForNode: node.
	self addToResultCheckOverlap: self codeBuilder ,, (position at1 ,, (position at1 + node name size)).
	node type isError
		ifFalse: [	position := self currentParseTree positionForNode: node type. 
							self addToResultCheckOverlap: self typeexpressionBuilder ,, (self findTypeExprIntervalFrom: position) ]! !

"August 22, 2009 -> 14:22:21"!

! (Delta mirrorFor: #ASTtoRichTextTool) methodsFor: 'private - initialization' !
initialize

	self result: OrderedCollection[Tuple[[Character,^E],Tuple[Int,Int]]] new.
	self selectorEnd: nil.
	self currentParseTree: nil.
	! !

"August 22, 2009 -> 14:22:58"!

Delta define: #DeltaRewriter as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'scope result ')) !


"August 22, 2009 -> 14:22:58"!

Delta define: #DeltaRewriter as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'scope result ')) !


"August 22, 2009 -> 14:22:58"!

Delta define: #DeltaRewriter as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'scope result ')) !


"August 22, 2009 -> 14:22:58"!

Delta define: #DeltaRewriter as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'scope result ')) !


"August 22, 2009 -> 14:22:58"!

Delta define: #DeltaRewriter as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'scope result ')) !


"August 22, 2009 -> 14:22:58"!

Delta define: #DeltaRewriter as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'scope result ')) !


"August 22, 2009 -> 14:22:58"!

Delta define: #DeltaRewriter as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'scope result ')) !


"August 22, 2009 -> 14:22:58"!

Delta define: #DeltaRewriter as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'scope result ')) !


"August 22, 2009 -> 14:22:58"!

Delta define: #DeltaRewriter as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'scope result ')) !


"August 22, 2009 -> 14:22:58"!

Delta define: #DeltaRewriter as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'scope result ')) !


"August 22, 2009 -> 14:22:58"!

Delta define: #DeltaRewriter as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'scope result ')) !


"August 22, 2009 -> 14:22:58"!

(Delta mirrorFor: #DeltaRewriter)
comment: 
'The rewriter recursively traverses the AST and optimizes
    particular nodes by relacing them with other (more optimal)
    nodes.

    Instance variables:

    result      the result after rewriting the current node. If the node
                      has not changed, result simply holds the current node.

    scope      the current scope. Scope is adjusted whenever a
                      new codeBody is entered.
    
 (c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
andOrNode: node
    self assert: [node isAndOrNode].
    result := node! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
assignmentNode: node
    | var expr |
    self assert: [ node isAssignmentNode ].
	var := self rewrite: node var.
	var isFloatValue
		ifTrue: [ result := DeltaFloatAssignment new to: var assign: (self rewriteAsFloatValue: node expr) ]
		ifFalse: [ result := DeltaAssignment new to: var assign: (self rewriteAsOop: node expr) ]! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
at: node error: msg
	"Simple soultion for now - fix this at some point"
	Transcript show: 'error: ', msg ; cr.
	self halt! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
blockNode: node
    | prevScope body |
    self assert: [ node isBlockNode ].
    result := DeltaBlock new body: (self rewrite: node body)! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
cascadedSendNode: node
	| prevSend msg |
	self assert: [node isCascadedSendNode].
	prevSend := self rewrite: node prevSend.
	msg := self rewrite: node msg.
	prevSend isSelfSendNode ifTrue: [
		"do not rewrite: keep normal send instead"
		result := DeltaCascadedSend new to: node prevSend cascade: msg.
		^ self
	].
	prevSend isSuperSendNode ifTrue: [
		Transcript show: 'cascaded super sends not implemented yet' ; cr.
		self halt.
		^ self
	].
	result := DeltaCascadedSend new to: prevSend cascade: msg! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
codeBodyNode: node <CodeBody>
    | prevScope statements |
    self assert: [node isCodeBodyNode].
    prevScope := scope.
    scope := node scope.
    statements := OrderedCollection new.
    node statements do: [ :stat | statements add: (self rewrite: stat)].
    result :=
        DeltaCodeBody new
            parameters: node parameters
            temporaries: node temporaries
            statements: statements
            scope: node scope.
    scope := prevScope! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
dllCallNode: node
    self assert: [node isDLLCallNode].
    result :=
        DeltaDLLCall new
            to: node dll
            send: (self rewrite: node msg)
            called: node function
            return: node proxy
			async: node async! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
genericApplicationExpressionNode: node
    self assert: [node isGenericApplicationExpressionNode].
    result := self rewrite: node target! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
globalVarNode: node
    self assert: [node isGlobalVarNode].
    result := node! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
guaranteedNode: node
    self assert: [node isGuaranteedNode].
    result := self rewrite: node expr! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
if: cond with: block1 and: block2 do: action
	cond value ifFalse: [ ^ false ].
	(self isRemovableBlock: block1 withArgs: 0) ifFalse: [ ^ self ].
	(self isRemovableBlock: block2 withArgs: 0) ifFalse: [ ^ self ].
	"inline the block and do action"
	block1 body scope inline.
	block2 body scope inline.
	action value! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
if: cond with: block nofArgs: nofArgs do: action
	cond value ifFalse: [ ^ false ].
	(self isRemovableBlock: block withArgs: nofArgs) ifFalse: [ ^ self ].
	"inline the block and do action"
	block body scope inline.
	action value! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
ifNode: node
	self assert: [ node isIfNode ].
	result := node! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
inlinedBlockNode: node
	self assert: [ node isInlinedBlockNode ].
	result := node! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
isRemovableBlock: block withArgs: nofArgs
	"
	Private.
	Answers true if block can be removed (inlined)
	within another block, answers false otherwise.
	"
	| s |
	block isBlockNode					ifFalse: [ ^ false ].
	s := block body scope.
	s isInlineable							ifFalse: [ ^ false ].
	s nofParameters = nofArgs		ifFalse: [ ^ false ].
	^ true! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
komment
    "
    The rewriter recursively traverses the AST and optimizes
    particular nodes by relacing them with other (more optimal)
    nodes.

    Instance variables:

    result      the result after rewriting the current node. If the node
                      has not changed, result simply holds the current node.

    scope      the current scope. Scope is adjusted whenever a
                      new codeBody is entered.
    "! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
literalNode: node
    self assert: [ node isLiteralNode ].
    result := node! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
loopNode: node
    self assert: [node isLoopNode].
    result := node! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
messageNode: node
    | args |
    self assert: [node isMessageNode].
    args := OrderedCollection new.
    node arguments do: [ :arg | args add: (self rewriteAsOop: arg)].
    result := DeltaMessage new send: node selector with: args! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
methodNode: node
	self assert: [ node isMethodNode ].
	result :=
		DeltaMethod new
			selector: node selector
			type: node type
			visibility: node visibility
			body: (self rewriteSpecialBodies: node body)! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
normalSendNode: node
	| recv msg sel arg1 arg2 arg3 |
	self assert: [ node isNormalSendNode ].
	recv := self rewrite: node recv.

	recv isFloatValue ifTrue: [
		result := self rewrite: node asFloatOperationOn: recv.
		result notNil ifTrue: [ ^ self ].
		"no FloatValue operation found"
		AutoFloatConversion
			ifTrue: [ recv := DeltaFloatUnaryOpToOop new f: #asFloat x: recv ]
			ifFalse: [ self at: node error: 'not a supported FloatValue operation' ]
	].

	"Prepare arguments for normal message sends"
	msg := self rewriteAsOop: node msg.
	sel := msg selector.
	msg nofArgs >= 1 ifTrue: [ arg1 := msg args at: 1 ].
	msg nofArgs >= 2 ifTrue: [ arg2 := msg args at: 2 ].
	msg nofArgs >= 3 ifTrue: [ arg3 := msg args at: 3 ].

	"Self & Super sends"
	(sel ~= #== and: [ sel ~= #~~ ]) ifTrue: [
		(recv isRefNode and: [ recv decl isReceiverNode ])	ifTrue: [ result := DeltaSelfSend new send: msg.						^ self ]
	].
	(recv isRefNode and: [ recv decl isSuperVarNode ])		ifTrue: [ result := DeltaSuperSend new send: msg.					^ self ].

	"Hardwired asFloatValue message"
	sel = #asFloatValue ifTrue: [
		result :=
			EnableFloatValues
				ifTrue: [ DeltaFloatify new obj: recv ]
				ifFalse: [ recv "simply ignore conversion" ].
		^ self
	].

	"Hardwired ifTrue: / ifFalse: messages"
	self if: [ sel = #ifTrue:				] with: arg1 nofArgs: 0	do: [ result := DeltaIf new if: recv is: true then: arg1.						^ self ].
	self if: [ sel = #ifFalse:			] with: arg1 nofArgs: 0	do: [ result := DeltaIf new if: recv is: false then: arg1.					^ self ].
	self if: [ sel = #ifTrue:ifFalse:	] with: arg1 and: arg2	do: [ result := DeltaIf new if: recv is: true then: arg1 else: arg2.	^ self ].
	self if: [ sel = #ifFalse:ifTrue:	] with: arg1 and: arg2	do: [ result := DeltaIf new if: recv is: false then: arg1 else: arg2.	^ self ].

	"Hardwired and: / or: messages"
	self if: [ sel = #and:					] with: arg1 nofArgs: 0	do: [ result := DeltaAndOr new if: recv and: arg1.							^ self ].
	self if: [ sel = #or:					] with: arg1 nofArgs: 0	do: [ result := DeltaAndOr new if: recv or: arg1.								^ self ].

	"Hardwired whileTrue: / whileFalse: messages"
	self if: [ sel = #whileTrue			] with: recv nofArgs: 0	do: [ result := DeltaLoop new while: true do: recv.							^ self ].
	self if: [ sel = #whileFalse		] with: recv nofArgs: 0	do: [ result := DeltaLoop new while: false do: recv.						^ self ].
	self if: [ sel = #whileTrue:		] with: recv and: arg1	do: [ result := DeltaLoop new while: recv is: true do: arg1.			^ self ].
	self if: [ sel = #whileFalse:		] with: recv and: arg1	do: [ result := DeltaLoop new while: recv is: false do: arg1.			^ self ].

	"Hardwired repeat: / timesRepeat: / to:do: / to:by:do: messages"
	self if: [ sel = #repeat				] with: recv nofArgs: 0	do: [ result := DeltaLoop new repeat: recv.										^ self ].
	self if: [ sel = #timesRepeat:	] with: arg1 nofArgs: 0	do: [ result := DeltaLoop new do: recv timesRepeat: arg1.			^ self ].
	self if: [ sel = #to:do:				] with: arg2 nofArgs: 1	do: [ result := DeltaLoop new from: recv to: arg1 do: arg2.			^ self ].
	self if: [ sel = #to:by:do:			] with: arg3 nofArgs: 1 do: [
		arg2 isIntNode ifTrue: [
			"inline only if step is a constant"
			result := DeltaLoop new from: recv to: arg1 by: arg2 do: arg3.
			^ self
		]
	].

	"Hardwired value message"
"
	self if: [ sel = #value				] with: recv nofArgs: 0 do: [ result := DeltaInlinedBlock new block: recv.							^ self ].
"

	"No rewriting"
	result := DeltaNormalSend new to: recv send: msg! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
parameters: pars matchArguments: args
	| i |
	i := pars size.
	
	"Proceed if no. of parameter matches no. of arguments"
	pars size = args size ifFalse: [ ^ false ].

	"check individual arguments, starting with last one"
	i := pars size.
	[ i > 0 ] whileTrue: [
		(args at: i) isRefNode ifFalse: [ ^ false ].
		(pars at: i) == (args at: i) decl ifFalse: [ ^ false ].
		i := i - 1
	].

	"parameters & arguments match 1-to-1, in same order"
	^ true! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
predictPrimitiveNode: node
	self assert: [ node isPredictPrimitiveNode ].
	result := node! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
predictSpecialPrimitiveNode: node
	self assert: [ node isPredictSpecialPrimitiveNode ].
	result := node! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
primitiveCallNode: node
    self assert: [node isPrimitiveCallNode].
    result := node! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
primitiveNode: node
	| recv msg sel args failureBlock failureCode tail |
	self assert: [ node isPrimitiveNode ].
	recv := self rewriteAsOop: node recv.
	msg := self rewrite: node msg.
	sel := msg selector.
	args := msg args.

	failureBlock := nil.
	(sel size >= #ifFail: size) ifTrue: [
		tail := sel copyFrom: (sel size - #ifFail: size + 1) to: sel size.
		(tail =  'ifFail:' or:[tail = 'IfFail:']) ifTrue: [
			(failureBlock := args removeLast) isBlockNode ifFalse: [
				self error: 'primitive send: last argument must be a block'
			].
			failureBlock body parameters size = 1 ifFalse: [
				self error: 'primitive send: failure block must take exactly one argument'
			]
		]
	].

	failureBlock isNil ifFalse: [
		failureBlock scope isInlineable
			ifTrue: [failureBlock scope inline]
			ifFalse: [
				"
				Generate a failureCode of the form:
				failureBlock value: tos
				"
				self error: 'primitive send: failure block is not inlineable - not implemented'
				"
				Transcript show: 'primitive send: failure block is not inlineable - not implemented' ; cr
				"
			]
	].

	result := DeltaPrimitiveCall new call: sel recv: recv with: args ifFail: failureBlock! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
refNode: node
    self assert: [ node isRefNode ].
	result :=
		node decl isFloatValue
			ifTrue: [ DeltaFloatRef new decl: node decl ]
			ifFalse: [ node ]! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
returnInstVarNode: node
	self assert: [ node isReturnInstVarNode ].
	result := node! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
returnStatNode: node
    self assert: [node isReturnStatNode].
    result := DeltaReturnStat new return: (self rewriteAsOop: node expr)! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
rewrite: node
	"
	Applies self to the node and answers result.
	apply must conform to general AST tools and
	therefore can't return a value itself. The value
	is returned in result.
	"
	node isNil
		ifTrue: [ ^ nil ]
		ifFalse: [ node apply: self. ^ result ]! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
rewrite: node asFloatOperationOn: recv
	| msg sel arg1 |
	"Prepare arguments for float operations"
	self assert: [ recv isFloatValue ].
	msg := node msg.
	sel := msg selector.
	msg nofArgs = 1 ifTrue: [ arg1 := self rewriteAsFloatValue: (msg args at: 1) ].

	"Hardwired unary FloatValue operations"
	msg nofArgs = 0 ifTrue: [
		"Operations that return a float"
		#(abs negated squared sqrt sin cos tan exp ln) do: [ :op |
			sel = op ifTrue: [
				scope usesFloatValues.
				^ DeltaFloatUnaryOp new f: op x: recv
			]
		].
		"Operations that return an oop"
		#(asFloat) do: [ :op |
			sel = op ifTrue: [
				scope usesFloatValues.
				^ DeltaFloatUnaryOpToOop new f: op x: recv
			]
		].
		"unary operation not found"
		^ nil
	].

	"Hardwired binary FloatValue operations"
	msg nofArgs = 1 ifTrue: [
		"Operations that return a float"
		#(+ - * / \\) do: [ :op |
			sel = op ifTrue: [
				scope usesFloatValues.
				^ DeltaFloatBinaryOp new x: recv f: op y: arg1
			]
		].
		"Operations that return an oop"
		#(= ~= < <= > >=) do: [ :op |
			sel = op ifTrue: [
				scope usesFloatValues.
				^ DeltaFloatBinaryOpToOop new x: recv f: op y: arg1
			]
		].
		"binary operation not found"
		^ nil
	].
	"operation not found"
	^ nil! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
rewriteAsFloatValue: node
	| n |
	self assert: [ EnableFloatValues ].
	self assert: [ node notNil ].
	n := self rewrite: node.
	n isFloatValue ifFalse: [
		(n isLiteralNode and: [ n isFloatNode ])
			ifTrue: [
				"float literals are always converted automatically - no run-time overhead involved"
				n := DeltaFloatLiteral new value: n value
			]
			ifFalse: [
				AutoFloatConversion
					ifTrue: [ n := DeltaFloatify new obj: n ]
					ifFalse: [ self at: node error: 'expression type must be FloatValue' ]
			]
	].
	^ n! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
rewriteAsOop: node
	| n |
	n := self rewrite: node.
	(n notNil and: [ n isFloatValue ]) ifTrue: [
		self assert: [ EnableFloatValues ].
		AutoFloatConversion
			ifTrue: [ n := DeltaFloatUnaryOpToOop new f: #asFloat x: n ]
			ifFalse: [ self at: node error: 'expression type cannot be a FloatValue' ]
	].
	^ n! !

"August 22, 2009 -> 14:22:58"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
rewriteSpecialBodies: b
	"
	Detects access and primitive method
	bodies and rewrites them accordingly.
	"
	| body stats stat decl expr |
	body := self rewrite: b.
	stats := body statements.
	stats size = 1 ifTrue: [
		stat := stats at: 1.
		stat isReturnStatNode ifTrue: [
			expr := stat expr.
			expr isRefNode ifTrue: [
				decl := expr decl.
				decl isInstVarNode ifTrue: [
					body parameters isEmpty ifFalse: [ ^ body ].
					stats := OrderedCollection new.
					stats add: (DeltaReturnInstVar new var: decl).
					^ DeltaCodeBody new
						parameters: body parameters
						temporaries: body temporaries
						statements: stats
						scope: body scope
				]
			].
			expr isPrimitiveCallNode ifTrue: [
				(expr receiver notNil and: [ expr receiver decl isReceiverNode ]) ifTrue: [
					"primitive takes self as first argument"
					(self parameters: body parameters matchArguments: expr arguments) ifTrue: [
						expr failureCode notNil ifTrue: [
							"
							primitive takes exactly the method arguments - add hint
							whether primitive is actually predicted depends on code generator
							"
							stats addFirst: (DeltaPredictSpecialPrimitive new primitive: expr selector).
							^ DeltaCodeBody new
								parameters: body parameters
								temporaries: body temporaries
								statements: stats
								scope: body scope
						]
					]
				]

"				This is old code - not correct anymore because primitives with self argument
				are not handled the right way - keep it around anyway for later - gri 5/2/96.
				
				(self parameters: body parameters matchArguments: expr arguments) ifTrue: [
					expr failureCode isNil ifTrue: [
						stats addFirst: (DeltaPredictPrimitive new primitive: expr selector).
						^ DeltaCodeBody new
							parameters: body parameters
							temporaries: body temporaries
							statements: stats
							scope: body scope
					]
				]
"
			]
		]
	].

	^ body! !

"August 22, 2009 -> 14:22:59"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
selfSendNode: node
    self assert: [node isSelfSendNode].
    result := node! !

"August 22, 2009 -> 14:22:59"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
superSendNode: node
    self assert: [node isSuperSendNode].
    result := node! !

"August 22, 2009 -> 14:22:59"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
tupleNode: aNode <TupleAST>
"
This code added based on Newspeak code.  Therefore:

Copyright 2008 Cadence Design Systems, Inc.
   
   Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0
"
"should rewrite into a tree representing the expression
(Array new:  n) at: 1 put:: e1 ; ...  at: n put: en; yourself
where n is the size of the tuple"
| els <OrderedCollection[AST]>   
  array <NormalSendAST> 
  len <NumberAST> 
  tup <NormalSendAST>
  index <Integer>
|

	len :=  DeltaInt new value: aNode elements size.
	array :=  DeltaNormalSend new
		to: (DeltaRef new decl: (DeltaGlobals at: #Array)) "Array" 
		send: (DeltaMessage new send: #new: with:((Array new:1) at: 1 put: len; yourself)). "Array new: n"
	aNode elements size = 0 ifTrue:[^array apply: self].
	index :=  0.
	tup := aNode elements inject: array into:[:r : e |  | msg <MessageAST> |
	      index := index + 1.
	      msg :=  DeltaMessage new send: #at:put:
								with: ((Array new: 2) at: 1 put: (DeltaInt new value: index); at: 2 put: e; yourself).
	      index = 1 
			ifTrue:[DeltaNormalSend new to: r send: msg] 
						"(Array new: n) at:1 put: e1"
	      	ifFalse:[DeltaCascadedSend new to: r cascade: msg]. "...; at: k put: ek"
		].
^(DeltaCascadedSend new to: tup cascade:(DeltaMessage new send: #yourself with: #()))
	"(Array new:  n) at: 1 put:: e1 ; ...  at: n put: en; yourself"
	 apply: self "visit elements"! !

"August 22, 2009 -> 14:23:19"!

Delta define: #GenericMirror as: (
(Class subclassOf: 'Mirror' instanceVariables: 'body ')) !


"August 22, 2009 -> 14:23:19"!

Delta define: #GenericMirror as: (
(Class subclassOf: 'Mirror' instanceVariables: 'body ')) !


"August 22, 2009 -> 14:23:19"!

Delta define: #GenericMirror as: (
(Class subclassOf: 'Mirror' instanceVariables: 'body ')) !


"August 22, 2009 -> 14:23:19"!

Delta define: #GenericMirror as: (
(Class subclassOf: 'Mirror' instanceVariables: 'body ')) !


"August 22, 2009 -> 14:23:19"!

Delta define: #GenericMirror as: (
(Class subclassOf: 'Mirror' instanceVariables: 'body ')) !


"August 22, 2009 -> 14:23:19"!

Delta define: #GenericMirror as: (
(Class subclassOf: 'Mirror' instanceVariables: 'body ')) !


"August 22, 2009 -> 14:23:19"!

Delta define: #GenericMirror as: (
(Class subclassOf: 'Mirror' instanceVariables: 'body ')) !


"August 22, 2009 -> 14:23:19"!

Delta define: #GenericMirror as: (
(Class subclassOf: 'Mirror' instanceVariables: 'body ')) !


"August 22, 2009 -> 14:23:19"!

Delta define: #GenericMirror as: (
(Class subclassOf: 'Mirror' instanceVariables: 'body ')) !


"August 22, 2009 -> 14:23:19"!

Delta define: #GenericMirror as: (
(Class subclassOf: 'Mirror' instanceVariables: 'body ')) !


"August 22, 2009 -> 14:23:19"!

Delta define: #GenericMirror as: (
(Class subclassOf: 'Mirror' instanceVariables: 'body ')) !


"August 22, 2009 -> 14:23:19"!

(Delta mirrorFor: #GenericMirror)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"August 22, 2009 -> 14:23:19"!

! (Delta mirrorFor: #GenericMirror) classSide methodsFor: 'Unclassified' !
typeArgs: a <Str> body: b  <Mirror>
    ^self new initializeTypeArgs: a body: b! !

"August 22, 2009 -> 14:23:19"!

! (Delta mirrorFor: #GenericMirror) methodsFor: 'Unclassified' !
adjustBounds
"Private"

self body adjustBounds.
! !

"August 22, 2009 -> 14:23:19"!

! (Delta mirrorFor: #GenericMirror) methodsFor: 'Unclassified' !
body  ^ <Mirror>

^body! !

"August 22, 2009 -> 14:23:19"!

! (Delta mirrorFor: #GenericMirror) methodsFor: 'Unclassified' !
body: b   <Mirror>

body := b! !

"August 22, 2009 -> 14:23:19"!

! (Delta mirrorFor: #GenericMirror) methodsFor: 'Unclassified' !
convertToGeneric: g <GenericMirror> ifFail: fb <[Str]>


self deltaHack.

g body class == self body class
  ifTrue:[
               g body convert: self body ifFail: fb.
               self convertTypeTo: g.
                ]
  ifFalse:[fb value: 'Conversion failed - generics have incompatible bodies'].




! !

"August 22, 2009 -> 14:23:19"!

! (Delta mirrorFor: #GenericMirror) methodsFor: 'Unclassified' !
convertTypeTo: g <GenericMirror>

| gt <Generic>  formals <OrdCltn[TypeFormal]> |


gt := Type forDefinition: self body reflectee.
"patch up formals in scope and in gt"
formals :=  (DeltaParser new parseTypeArgs: g typeArgumentString within: DeltaGlobals) collect: [ :pt | pt body].
gt generifyWithFormals: formals.


! !

"August 22, 2009 -> 14:23:19"!

! (Delta mirrorFor: #GenericMirror) methodsFor: 'Unclassified' !
createTypeStructure

self error: 'Should be disabled in this version!!'.
! !

"August 22, 2009 -> 14:23:19"!

! (Delta mirrorFor: #GenericMirror) methodsFor: 'Unclassified' !
definitionString  ^ <Str>

^'Generic forAll: ', self typeArgumentString asString printString, ' body: (', self body basicDefinitionString, ')'! !

"August 22, 2009 -> 14:23:19"!

! (Delta mirrorFor: #GenericMirror) methodsFor: 'Unclassified' !
fileName  ^<Str>
	^self body fileName! !

"August 22, 2009 -> 14:23:19"!

! (Delta mirrorFor: #GenericMirror) methodsFor: 'Unclassified' !
initializeTypeArgs: tas  <Str> body: b  <Mirror>

b nestInGenericWithTypeArguments: tas.
self body: b.! !

"August 22, 2009 -> 14:23:19"!

! (Delta mirrorFor: #GenericMirror) methodsFor: 'Unclassified' !
nameExisting: n <Symbol> ifFail: fb <[Str]>

| b <Mirror> |

b :=  Mirror on: (self priorReflecteeFor: n).
b convertToGeneric: self ifFail: fb.
"self body convert: b ifFail: fb."
b :=  Mirror on: (Delta at: n).
"b nestInGenericWithTypeArguments:  self  typeArgumentString."
self body: b.
"self adjustBounds."

! !

"August 22, 2009 -> 14:23:19"!

! (Delta mirrorFor: #GenericMirror) methodsFor: 'Unclassified' !
nameNew: n <Symbol> ifFail: fb <[Str]>

self body name: n ifFail: fb.
self adjustBounds.! !

"August 22, 2009 -> 14:23:19"!

! (Delta mirrorFor: #GenericMirror) methodsFor: 'Unclassified' !
reflectee  ^ <T>

^self body reflectee! !

"August 22, 2009 -> 14:23:19"!

! (Delta mirrorFor: #GenericMirror) methodsFor: 'Unclassified' !
sourceInfo

	^self body sourceInfo! !

"August 22, 2009 -> 14:23:19"!

! (Delta mirrorFor: #GenericMirror) methodsFor: 'Unclassified' !
typeArgumentString ^ <Str>

^self body typeArgumentString! !

"August 22, 2009 -> 14:23:39"!

Delta define: #MixinDeclMirror as: (
(Class subclassOf: 'MixinMirror' instanceVariables: 'mixinDecl sourceInfo ') classVariables: 'InvocationInfo <VarDict[Mixin, AbstractInvocationData]>') !


"August 22, 2009 -> 14:23:39"!

Delta define: #MixinDeclMirror as: (
(Class subclassOf: 'MixinMirror' instanceVariables: 'mixinDecl sourceInfo ') classVariables: 'InvocationInfo <VarDict[Mixin, AbstractInvocationData]>') !


"August 22, 2009 -> 14:23:39"!

Delta define: #MixinDeclMirror as: (
(Class subclassOf: 'MixinMirror' instanceVariables: 'mixinDecl sourceInfo ') classVariables: 'InvocationInfo <VarDict[Mixin, AbstractInvocationData]>') !


"August 22, 2009 -> 14:23:39"!

Delta define: #MixinDeclMirror as: (
(Class subclassOf: 'MixinMirror' instanceVariables: 'mixinDecl sourceInfo ') classVariables: 'InvocationInfo <VarDict[Mixin, AbstractInvocationData]>') !


"August 22, 2009 -> 14:23:39"!

Delta define: #MixinDeclMirror as: (
(Class subclassOf: 'MixinMirror' instanceVariables: 'mixinDecl sourceInfo ') classVariables: 'InvocationInfo <VarDict[Mixin, AbstractInvocationData]>') !


"August 22, 2009 -> 14:23:39"!

Delta define: #MixinDeclMirror as: (
(Class subclassOf: 'MixinMirror' instanceVariables: 'mixinDecl sourceInfo ') classVariables: 'InvocationInfo <VarDict[Mixin, AbstractInvocationData]>') !


"August 22, 2009 -> 14:23:39"!

Delta define: #MixinDeclMirror as: (
(Class subclassOf: 'MixinMirror' instanceVariables: 'mixinDecl sourceInfo ') classVariables: 'InvocationInfo <VarDict[Mixin, AbstractInvocationData]>') !


"August 22, 2009 -> 14:23:39"!

Delta define: #MixinDeclMirror as: (
(Class subclassOf: 'MixinMirror' instanceVariables: 'mixinDecl sourceInfo ') classVariables: 'InvocationInfo <VarDict[Mixin, AbstractInvocationData]>') !


"August 22, 2009 -> 14:23:39"!

Delta define: #MixinDeclMirror as: (
(Class subclassOf: 'MixinMirror' instanceVariables: 'mixinDecl sourceInfo ') classVariables: 'InvocationInfo <VarDict[Mixin, AbstractInvocationData]>') !


"August 22, 2009 -> 14:23:39"!

Delta define: #MixinDeclMirror as: (
(Class subclassOf: 'MixinMirror' instanceVariables: 'mixinDecl sourceInfo ') classVariables: 'InvocationInfo <VarDict[Mixin, AbstractInvocationData]>') !


"August 22, 2009 -> 14:23:39"!

Delta define: #MixinDeclMirror as: (
(Class subclassOf: 'MixinMirror' instanceVariables: 'mixinDecl sourceInfo ') classVariables: 'InvocationInfo <VarDict[Mixin, AbstractInvocationData]>') !


"August 22, 2009 -> 14:23:39"!

(Delta mirrorFor: #MixinDeclMirror)
comment: 
'This class represents a mirror on a mixin declaration.

The mirror maintains an instance variable, mixinDecl, which is a low level mirror
(a MixinVMMirror) on the actual mixin. Changes are accomplished by forwarding
to this low level mirror. The actual mixin being reflected is also available thru mixinDecl.

Changes to the structure of the mixin are accomplished by creating an uninstalled copy
of the mixin, and performing the changes on it, and the installing the changes atomically
using the changed copy as a constructor which is passed to the VM. The VM also receives
a list of all invocations and their dependent subclasses, so that it can modify them atomically
at the same time.

This process is done using the makeChange:ifFail: method, which in turn invokes the
install:ifFail: method.

Methods are simply added to the mixin, and copied down to invocations. This is not done atomically
at this point.

 (c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) classSide methodsFor: 'Unclassified' !
cleanUp

InvocationInfo keys do: [ :k | k name isNil ifTrue: [ InvocationInfo removeKey: k ]].

! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) classSide methodsFor: 'Unclassified' !
createInvocationOf: mixin <MixinMirror>  named: n <Symbol> superclass: sc <ClassMirror> ifFail: fb <[Str]> ^ <ClassVMMirror>
"h1"
"
create a named invocation of  mixin
"
| klass <ClassVMMirror>  |

klass := self createInvocationValueOf: mixin named: n superclass: sc ifFail: fb.
self addTypeStructureForInvocation: klass.
^klass! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) classSide methodsFor: 'Unclassified' !
createInvocationValueOf: mixin <MixinDeclMirror> named: n <Symbol>  superclass: sc <ClassMirror> ifFail: fb <[Str]> ^ <ClassVMMirror>
"b"
"
create a named invocation value of  mixin
"

| 
klass <ClassVMMirror> 
vmSuperclass <ClassVMMirror> 
vmMixin  <MixinVMMirror> 
|


(Delta includesKey: n) "previous version of n exists"
  ifTrue:[(Delta at: n) isError ifFalse:[ fb value: 'Internal failure: Class ', n , ' already exists']].
vmMixin := MixinVMMirror on: mixin reflectee.
vmSuperclass := ClassVMMirror on: sc reflectee.
klass := ClassVMMirror createInvocationOf: vmMixin named: n superclass: vmSuperclass ifFail: fb.
mixin addInvocation: klass reflectee.
^klass
! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) classSide methodsFor: 'Unclassified' !
init

	InvocationInfo := Dictionary [Mixin, AbstractInvocationData]  new.
! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) classSide methodsFor: 'Unclassified' !
on: mixin <Mixin> ^ <Instance> 

| mixinDecl <MixinVMMirror> |

mixinDecl := MixinVMMirror on: mixin.

^self new reflect: mixinDecl.! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) classSide methodsFor: 'Unclassified' !
superclassType: s  <Str>  body: b  <ClassMirror> ^ <Instance> 
	self deltaHack.  "Should go away once schema changes work"
	^b mixin superclassType: s! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) classSide methodsFor: 'private' !
addBasicTypeStructureForInvocation: class <ClassVMMirror>
"Private" 
| classTypeInfo <MixinInvocationSide> classClassTypeInfo <MixinInvocationSide> |
classTypeInfo := Type atClass: class reflectee 
                                             put:  (DeltaMixinInvocationSide new initialize).
classClassTypeInfo := Type atClass: class classSide reflectee 
                                                        put: (DeltaMixinInvocationSide new initialize).
classTypeInfo  dual: classClassTypeInfo.
classClassTypeInfo  dual: classTypeInfo.
! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) classSide methodsFor: 'private' !
addSuperclassTypeStructureForInvocation: class <ClassVMMirror>

"Private" 
(Type forClass: class reflectee) superclassType: (self classReferenceTo: (class superclass nameIfAbsent:[self error: 'Internal flaw: Use of unnamed superclass'])).
(Type forClass: class classSide reflectee) superclassType: (self metaclassReferenceTo: (class superclass nameIfAbsent:[self error: 'Internal flaw: Use of unnamed superclass'])).

! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) classSide methodsFor: 'private' !
addTypeStructureForInvocation: class <ClassVMMirror>
"e"
"Private"

self addBasicTypeStructureForInvocation: class.
(Type forClass: class reflectee) mixinType: (Type forMixin: class mixin reflectee).
(Type forClass: class classSide reflectee) mixinType: (Type forMixin: class mixin classSide reflectee).
self addSuperclassTypeStructureForInvocation: class.

! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) classSide methodsFor: 'private' !
addTypeStructureForMixin: mixin <MixinVMMirror>
"d"
"Private" 
| cDecl  <ClassUpdate> mixinTypeInfo <SideUpdate> |

cDecl := DeltaClassUpdate new  abstract: false; 
                                                       branded: true; 
                                                       monotonic: true; 
                                                       subtype: true.
mixinTypeInfo :=  DeltaSideUpdate new initialize.
cDecl instanceSide: mixinTypeInfo.

Type atMixin: mixin reflectee put: mixinTypeInfo.
Type atMixin: mixin classSide  reflectee put: (DeltaSideUpdate new initialize classDecl: cDecl).
(Type forMixin: mixin reflectee) superclassType:(self classReferenceTo: #Object).
(Type forMixin: mixin classSide reflectee) superclassType: (self metaclassReferenceTo: #Object).

! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) classSide methodsFor: 'private' !
computeDependentsOf: mixin <MixinDeclMirror> ^ <Array[Class]>
"Private"
"Here we collect all the invocations of mixin and all their subclasses"
| dependents <Array[Class]> |

dependents := Array[Class] new.
mixin vmInvocations do:[:vi <ClassVMMirror> | dependents addAll: vi subclasses].
^dependents.! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) classSide methodsFor: 'private' !
validate: m <MixinVMMirror> name: n <Symbol> superclass: sc <ClassMirror> ifFail: fb <[Str]>
"Private"
"This method performs certain checks to see if associating the name n
with an invocation of mixin could cause problems.

For example, the current version has methods that rely on instance, class or class instance
variables that are not available in mixin or in superclass.
 "! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
abstract

self abstract: true! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
abstract: b <Boolean>

self typeInfo abstract: b.
self sourceInfo abstract: b.! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
addClassVariable: v  <VarDecl> ifFail: blk <[Str]>


self isMeta ifTrue:[blk value: 'One cannot add class variables to meta mixins'].
self makeChange:[:mvm <MixinVMMirror> | mvm addClassVarName: v name ifFail: blk]
        ifFail: blk.

self typeInfoAddClassVariable: v.! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
addInstanceVariable: v  <VarDecl> ifFail: fb <[Str]>

self makeChange:[:mvm <MixinVMMirror> | mvm addInstVarName: v name ifFail: fb]
        ifFail: fb.

self typeInfoAddInstanceVariable: v.
          ! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
addInvocation: inv <Class>

self isMeta ifTrue: [ self error: 'Should not be called for meta-side' ].
self invocationInfo addInvocation: inv.
! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
addMethod: mtd <DeltaMethod> to: inv <ClassVMMirror>
"
Private
"
| m <Method> |

m := self compileMethod: mtd within: inv ifFail:[:e <Str> | self error: 'Internal failure. Cannot compile ', mtd selector, ' within ', inv name, ' : ', e].
inv addMethod: m ifFail:[:e <Str> | self error: 'Internal failure. Cannot add ', mtd selector, ' to ', inv name, ' : ', e].! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
addMethod: str <Str> visibility: vis <Symbol> category: cat <Symbol> ifFail: blk <[Str]> ^ <ParseTree>
	"This is the method to be called to add a method to a mixin"

	| pt <ParseTree> |

	pt := self insertMethod: str visibility: vis category: cat ifFail: blk.
	
	"We do not clear the body here since the caller may need the parse tree.
	The caller is responsible for sending #clearBody to the ast.
	All of this will go away once the type information no longer stores DeltaMethods."

	^pt
! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
addPool: name <Str> ifFail: fb <[Str]>

self deltaHack.
self halt.! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
basicDefinitionString  ^ <Str>

self isMeta 
  ifFalse:[^'Mixin superclassType: ', self superclassTypeString asString printString,  ' body: (', self body definitionString, ')']
  ifTrue:[self deltaHack. self shouldNotHappen].! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
basicLocator  ^ <BasicMixinLocator> 
	^self typeInfo basicLocator! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
body ^ <ClassMirror>

| newBody <ClassMirror> |

self superclassTypeString isEmpty "This is Object"
   ifTrue:[newBody := Class delta]
   ifFalse:[newBody :=  (Class subclassOf: self superclassTypeString
                                                         instanceVariables: self instanceVariableString).
                  ].
newBody := newBody
                                    classVariables: self classVariableString;
                                    protocols: self supportedProtocolString;
                                    classProtocols: self classSide supportedProtocolString.

self isAbstract ifTrue:[newBody abstract].
self extensionsAreSubtypes ifFalse:[newBody extensionsAreNotSubtypes].
self isSubtype ifFalse:[newBody notSubtype].
self isBranded ifFalse:[newBody unbranded].
^newBody

         ! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
body: b  <ClassMirror>

self isMeta ifTrue:[self halt].
self conformToShape: b.
self conformBodyTypeTo:  b.

! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
branded: b <Boolean>

self typeInfo branded: b.
self sourceInfo branded: b! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
changeClassVariablesTo: list <Cltn[VarDecl]>
"Private"

| newDecls <Cltn[VarDecl]> existingDecls <Cltn[VarDecl]> deletedDecls <Cltn[VarDecl]> |

self nonAtomic.

newDecls := OrderedCollection[VarDecl] new.
existingDecls := OrderedCollection[VarDecl] new.
deletedDecls := OrderedCollection[VarDecl] new.

list do: [ :v <VarDecl> | 
	(self classVariableAt: v name ifAbsent: [ nil ]) isNil
		ifTrue: [ newDecls add: v ]
		ifFalse: [ existingDecls add: v ] ].

self classVariablesDo: [ :v <VarDecl> | 
	list detect: [ :e <VarDecl> | e name = v name ] ifNone: [ deletedDecls add: v ] ].

"Remove surplus inst vars"
deletedDecls do: [ :v <VarDecl> | 
	self removeClassVariable: v name ifAbsent: [ self error: 'Cannot remove class variable ', v name, ' from ', self name ] ].

"Add new inst vars"
newDecls do: [ :v <VarDecl> | 
	self addClassVariable: v  ifFail: [ self error: 'Cannot add class variable ', v name, ' to ', self name ] ].

"Update type information on existing inst vars"
existingDecls do: [ :v <VarDecl> | 
	(self classVariableAt: v name ifAbsent: [ self error: 'Should not happen' ]) name: v name type: v type ].

"
self removeAllClassVariables.
list do:[:v <VarDecl> | self addClassVariable: v 
                                                                ifFail:[:e <Str> | self error: 'Failed attempt to install class variable ', v name, ' in mixin ', self name, ' : ', e]].
"! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
changeInstanceVariablesTo: list <Cltn[VarDecl]>
"Private"

| oldDecls <Cltn[VarDecl]> names <OrdCltn[Symbol]> |

self error: 'Should not be called anymore'.
self nonAtomic.
oldDecls := OrderedCollection[VarDecl] new.
self instanceVariablesDo: [ :v <VarDecl> | oldDecls add: v ].
names := list collect: [: v <VarDecl> | v name].

self makeChange: [:mvm <MixinVMMirror> |
                                     mvm changeInstanceVariablesTo: names]
         ifFail: [:s <Str> | self error: s ].

"Now we have changed the mixin; we must adjust the type info"
"Remove old inst vars from the type info"
oldDecls do: [ :v <VarDecl> | 
	self typeInfoRemoveInstanceVariable: v name].

"Add new inst vars to the type info"
list do: [ :v <VarDecl> | 
	self typeInfoAddInstanceVariable: v].

! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
changeMethod: oldAST <MethodDecl> to: newAST  <MethodDecl>

| typeInfo <SideUpdate>  |
" Private "
"Take whatever action is needed when a method changes from oldAST to newAST"

typeInfo := self typeInfo.
typeInfo errorHandler pushDefinition: typeInfo.
typeInfo errorHandler pushSelector: newAST selector.

" update dependencies"
self updateDependenciesFrom: oldAST to: newAST.

"Check if interface has changed, and take appropriate action"
self handleInterfaceChangeFrom: oldAST to: newAST.

typeInfo errorHandler popSelector.
typeInfo errorHandler popDefinition.! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
changePoolsTo: list  <Cltn[Str]>

"Private"

self deltaHack.
self halt.
! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
changeToMixin: mixin <MixinVMMirror> 
oldClasses: ocs <OrderedCollection[Class]>
newClasses: ncs <OrderedCollection[ClassMirror]>
ifFail: fb <[Str, ^DoesNotMatter]> ^ <MixinDeclMirror>

| 
existed <Boolean> 
invocations <SequenceableCollection[Class]>
change <Array[Mixin | Array[Class|Symbol]]>
cvns  <OrderedCollection[Symbol]>
mixinFormat <Symbol>
|

"If I mirror a meta mixin, I ask my instance side to install itself.  The installation is
always done in pairs, with the instance side as the argument to the primitive. "

self isMeta ifTrue:[^self instanceSide changeToMixin:  mixin instanceSide oldClasses: ocs newClasses: ncs  ifFail: fb].
ocs size = ncs size ifFalse:[fb value: 'Number of new classes does not match number of old classes'].
invocations := ClassVMMirror sort: self invocationInfo invocations. 
invocations isEmpty ifTrue:[self shouldNotHappen].
mixin name = self name ifFalse:[fb value: 'Attempt to replace mixin ', self name, ' with mixin ', mixin name].
mixinFormat := self mixinDecl format. 
"The format of the mixin itself can never change. If this turns out to be a problem, we will keep the format
in the VM"
change := Array[Mixin | Array[Class|Symbol]] new: 2 + invocations size.
change at: 1 put: mixin reflectee; 
                at: 2 put: self reflectee.
invocations with: (3 to: invocations size + 2)
						do:[: inv <Class> :i <Integer> |              
								change at: i put: (self prepareInvocation: inv mixinFormat: mixinFormat oldClasses: ocs newClasses: ncs ifFail: fb).
								].
{{primitiveApplyChange: change ifFail: [:e <CompressedSymbol> | fb value: e]}}.
ocs isEmpty ifFalse:[AbstractClassMirror flushSubclassHierarchyCache].
             
! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
classProtocols: p  <Str> 

self classSide supportedProtocol: p! !

"August 22, 2009 -> 14:23:39"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
classVariableAt: aName <Symbol> ifAbsent: aBlock <[]> ^ <VarDecl>

(self mixinDecl hasClassVarName: aName) ifFalse:[^aBlock value].
self classVariablesDo:[:v <VarDecl> | v name = aName ifTrue:[^v]].
^aBlock value.! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
classVariableString ^ <Str>

^self isMeta ifTrue:[self deltaHack. self error: 'Ask non-metaclass for class variables string']
                        ifFalse:[self sourceInfo classVariableString].
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
classVariables: vars <Str>

| oldNames <Cltn[Symbol]> newNames <OrdCltn[Symbol]> newDecls <OrdCltn[VarDecl]> |

self deltaHack.
"We parse in a dummy scope since the parser insert the classvar decls in the scope and will complain about existing ones."
newDecls := (DeltaParser new parseClassVarList: vars within: (DeltaScope within: nil)) collect: [ :pt <ParseTree[VarDecl]> | pt body scope: DeltaGlobals].

self nonAtomic.
oldNames := OrderedCollection[Symbol] new.
self classVariablesDo: [ :v <VarDecl> | oldNames add: v name ].
newNames := newDecls collect: [: v <VarDecl> | v name].

self makeChange: [:mvm <MixinVMMirror> |
                                     mvm changeClassVariablesTo: newNames]
         ifFail: [:s <Str> | self error: s ].

"Now we have changed the mixin; we must adjust the type info"
"Remove old class vars from the type info"
oldNames do: [ :name <Symbol> | 
	self typeInfoRemoveClassVariable: name ].

newDecls do: [ :v <VarDecl> |
	self typeInfoAddClassVariable: v  ].

self sourceInfo classVariableString: vars.
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
classVariablesDo: blk <[VarDecl]>


"does this really take var decls?"
| typeInfo <SideUpdate> |

typeInfo := self typeInfo .
typeInfo  classVarDecls do: blk.
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
cloneConformingToShape: b <ClassMirror> ^ <MixinVMMirror>
"Private"
"Return a clone of myself,  whose shape conforms to that of b"
| clone <MixinVMMirror> |

clone := MixinVMMirror onCopyOf: self reflectee.
^self conform: clone toShape: b
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
combinedFormatOfMixin: m <Mixin> andSuperclass: sc <Class> ifFail: fb <[Str, ^DoesNotMatter]> ^ <Symbol>

^ self combinedFormatOfMixinFormat: m format andSuperclassFormat: sc format ifFail:fb.! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
combinedFormatOfMixinFormat: m <Symbol> andSuperclassFormat: sc <Symbol> ifFail: fb <[Str, ^DoesNotMatter]> ^ <Symbol>
"Private"
sc = m ifTrue:[^m].
m = #Oops ifTrue:[^sc].
sc = #Oops ifTrue:[^m].


fb value: 'Incompatible formats: mixin has format ', m , ' and superclass has format ', sc.! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
comment  ^ <Str> 

^self sourceInfo comment! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
comment: c  <Str> 

self sourceInfo comment: c
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
compileMethod: m <DeltaMethod> ifFail: fb  <[Str]>  ^ <Method>
"Private"
	
	^self compileMethod: m within: self mixinDecl ifFail: fb! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
compileMethod: m <DeltaMethod> within: d <ClassVMMirror | MixinVMMirror> ifFail: blk  <[Str]>  ^ <Method>
"Private"

	^(DeltaCompiler forClass: d optimize: false ifError: [:e <Str> | ^blk value: e]) compile: (DeltaRewriter new rewrite: m)! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
compiledMethodAt: selector <Symbol> ifFail: blk   <[^X def]> ^ <Method | X>

	^self mixinDecl methodAt: selector ifFail: blk! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
compiledMethodsDo: blk  <[Method]>

	self mixinDecl methodsDo: blk! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
conform: m <MixinVMMirror> toShape: b <ClassMirror> ^ <MixinVMMirror>
"Private"
"make m's shape conform to that of b"
| noClassVars <Boolean> bvs <VarOrdCltn[Symbol]> |

b isMeta ifTrue:[self error: 'Attempt to modify meta mixin directly'].

bvs := OrderedCollection[Symbol] new.
b instanceVariablesDo:[:v <VarDecl> | bvs add: v name].
m changeInstanceVariablesTo: bvs.

bvs := OrderedCollection[Symbol] new.
b classVariablesDo:[:v <VarDecl> | bvs add: v name].
m changeClassVariablesTo: bvs.  

bvs := OrderedCollection[Symbol] new.
b mixin classSide instanceVariablesDo:[:v <VarDecl> | bvs add: v name].
m classSide changeInstanceVariablesTo: bvs.                                                  
              
" must eventually do same for pools"
^m
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
conformBodyTypeTo: b <ClassMirror>
"Private"
|  bType <SideUpdate> |

"modify type information"
self mayNeedToUnwind.
bType :=  (Type forMixin: b mixin reflectee).

self abstract: bType abstract.
self subtype: bType subtype.
self branded: bType branded.
self extensionsAreSubtypes: bType extensionsAreSubtypes.

self protocols: b mixin supportedProtocolString.

self typeInfoClassVariables: b mixin  classVariableString.
self typeInfoInstanceVariables: b mixin instanceVariableString.

self classSide protocols: b mixin classSide supportedProtocolString.
self classSide typeInfoInstanceVariables: b mixin classSide instanceVariableString! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
conformToShape: b <ClassMirror>
"Private"
| clone <MixinVMMirror> |

self installed 
	ifTrue:["Clone myself,  make its shape conform to that of b, and install it in my place"
					clone := self cloneConformingToShape: b.
					"install clone "
					self install: clone 
							 ifFail:[:e <Str> | self error: 'Inconsistency when attempting to modify ', self name, ' ', e].
				]
	ifFalse:[self conform: self mixinDecl toShape: b].
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
convert: m <Mirror> ifFail: fb <[Str]>

m convertToMixin: self ifFail: fb.



! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
convert: m <Mirror> toGeneric: g   <GenericMirror> ifFail: fb <[Str]>

self assert: [g body = self].
m convertToGenericMixin: g ifFail: fb.! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
convertToGenericMixin: g <GenericMirror> ifFail: fb <[Str]>

self convertToMixin: g body ifFail: fb.
self nestInGenericWithTypeArguments: g typeArgumentString.
self adjustBounds.

! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
convertToMixin: m <MixinDeclMirror> changingClass: oldClass <ClassMirror> to: newClass <ClassMirror> ifFail: fb <[Str, ^DoesNotMatter]>

| clone <MixinVMMirror> b <ClassMirror> |

self installed ifFalse:[self shouldNotHappen].
self isMeta
  ifFalse:[
                 m superclassTypeString isEmpty ifFalse:[self superclassType: m  superclassTypeString].
                 b := m body.
                 clone := self cloneConformingToShape: b.
                   "install clone " 
                self changeToMixin: clone 
                         oldClasses: (OrderedCollection[Class] new  add: oldClass reflectee; yourself)
                         newClasses: (OrderedCollection[ClassMirror] new add: newClass; yourself)
                         ifFail: [:e <Str> | self error: 'Inconsistency when attempting to modify ', self name].
                 self conformBodyTypeTo:  b.
                 ]
  ifTrue:[self instanceSide convertToMixin: m instanceSide changingClass: oldClass instanceSide to: newClass instanceSide ifFail: fb].! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
convertToMixin: m <MixinDeclMirror> ifFail: fb <[Str]>

self isMeta
  ifFalse:[
                 m superclassTypeString isEmpty ifFalse:[self superclassType: m  superclassTypeString].
                 self body: m body.
                ]
  ifTrue:[self instanceSide convertToMixin: m instanceSide ifFail: fb].! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
extensionsAreNotSubtypes

^self extensionsAreSubtypes: false! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
extensionsAreSubtypes ^ <Boolean>

^(self sourceInfo extensionsAreSubtypesString  = #false) not! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
extensionsAreSubtypes: e <Boolean>

self typeInfo extensionsAreSubtypes: e.
self sourceInfo extensionsAreSubtypes: e.
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
formatFor: c <ClassVMMirror>   mixinFormat: mf <Symbol> formats: formats <VarDict[Class, Symbol]> ifFail: fb <[Str, ^DoesNotMatter]> ^ <Symbol>
"Private"
|  f  <Symbol> |

c isNil ifTrue: [^#Oops].
c format = #Special ifTrue:[^#Special]. "Magic things like blocks etc."
"Weak arrays are a special case.  We check if the weak array mixin is used, and if so check to see if
the superclass is Array. Other cases are banned"

c mixin reflectee = IndexedNextOfKinInstanceVariables
  ifTrue:[
                c superclass reflectee = Array ifFalse:[self error: 'Bad Magic for weak arrays'].
               ^#IndexedNextOfKinInstanceVariables
               ].
 

f := formats at: c reflectee ifAbsent:[c format].
f isNil ifTrue:[                         
                         f := self combinedFormatOfMixinFormat: mf  
                                         andSuperclassFormat: (self formatFor: c superclass mixinFormat: mf formats: formats ifFail: fb) ifFail: fb.
                          formats at: c reflectee put: f
                          ].
^f

            ! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
formatsOf: cs <Cltn[Class]> mixinFormat: mixinFormat <Symbol> ifFail: fb <[Str, ^DoesNotMatter]> ^ <VarDict[Class, Symbol]>

| 
j  <Integer>
formats <VarDict[Class, Symbol]>
dm <ClassVMMirror>
|

formats := IdentityDictionary[Class, Symbol] new: cs size.
cs do:[:d <Class> | formats at: d put: nil].
cs do:[: d <Class> | 
			dm := ClassVMMirror on: d.
			(self formatFor: dm mixinFormat: dm mixin format formats: formats ifFail: fb). " new format, if legal !!"
			].
^formats! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
handleInterfaceChangeFrom: oldAST  <MethodDecl>  to: newAST  <MethodDecl>
"Private"
"Check if interface has changed, and take appropriate action"
| 
nsig <MsgSignature> 
osig <MsgSignature> 
sub <Boolean> 
sup <Boolean> 
typeInfo <SideUpdate>
|

"compare old and new signatures to determine interface change."
nsig := newAST type.
osig := oldAST type.
typeInfo := self typeInfo .

typeInfo setupTypeAssumptions.
DeltaSilentTypeErrorHandler new catchErrorsFor: [		"Only the result is relevant, not potential errors since they cannot be reported in a meaningful way anyway"
	sub := nsig subtypeOf: osig assuming: DeltaGlobalTrail.
	sup := osig subtypeOf: nsig assuming: DeltaGlobalTrail.
].
 typeInfo  retractTypeAssumptions.

(sub and:[sup]) ifTrue:[^self].
sub ifTrue:[^self heirsCheckSelector: newAST selector withSignature: nsig].
self noteFilteredSendersOf: newAST selector.
sup ifTrue:[
                     self nonSubtypeHeirsCheckSelector: newAST selector withSignature: nsig.
                    "test structural assumptions?"
                     ]
      ifFalse:[self heirsCheckSelector: newAST selector withSignature: nsig].! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
hasSelector: selector <Symbol> ^ <Boolean>

	self compiledMethodAt: selector ifFail: [ ^false ].		"We use compiled methods here since otherwise type info will have to be loaded"
	^true! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
heir: ih <Decl> checkSelector: sel <Symbol> withSignature: sig  <MsgSignature>

"Private.
Check heir ih to see whether it conflicts typewise with the signature sig of selector sel"
| ihSig <MsgSignature> typeInfo <SideUpdate>  ihTypeInfo <MixinInvocationSide> |

ihTypeInfo := Type forMixin: ih mixin reflectee.
typeInfo := self typeInfo .

(ihTypeInfo functions includesKey: sel)
       ifTrue:[
                     typeInfo errorHandler pushDefinitions: ihTypeInfo and: typeInfo.
                     typeInfo errorHandler pushSelector: sel.
                     ihSig := (ihTypeInfo functions at: sel) type.
                     ihTypeInfo subtype
                           ifTrue:[ "need to set and retract type assumptions"
                                        ihTypeInfo setupTypeAssumptions.                          
                                        (ihSig subtypeOf: sig assuming: DeltaGlobalTrail)
                                                 ifFalse:[ typeInfo reportError: DeltaMsgConflictSubtypeInSubError new.].
                                          ihTypeInfo retractTypeAssumptions.
                                          ]
                             ifFalse:[
                                            (ihSig subtypeOf: sig assuming: DeltaGlobalTrail)
                                                      ifFalse:[ typeInfo reportError: DeltaMsgConflictInheritedtypeInSubError new.].
                                            ].
                           typeInfo errorHandler popDefinitions.
                           typeInfo errorHandler popSelector.     
                          ].
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
heirScope  ^ <Scope>

"delete"
self deltaHack.

^(DeltaOverrideScope new base: self superclass heirScope;
                                                     delta: self localScope; yourself)
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
heirsCheckSelector: sel <Symbol> withSignature: sig  <MsgSignature>

"Private.
Check all heirs to see whether they conflict typewise with the signature sig of selector sel"

self immediateHeirs do:[:ih <Decl> |
                                               self heir: ih checkSelector: sel withSignature: sig
                                              ].! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
immediateHeirs  ^ <OrdCltn[ClassMirror]>
	"Return a collection of immediate heirs for all invocations"
	| heirs  <OrdCltn[ClassMirror]> |
	heirs := OrderedCollection[ClassMirror] new.
	self invocations do: [ :inv <AbstractClassMirror> | heirs addAll: inv immediateHeirs ].
	^heirs! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
initializeSuperclassType: s body: b

"self reflect: MixinVMMirror createNewMixin."
self superclassType: s.
self body: b.
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
insertMethod: src <Str> visibility: vis <Symbol> category: cat <Symbol> ifFail: blk <[Str]> ^ <ParseTree>
"Private"
"
This  method is used internally to add a method to a mixin. It is
factored out so that both the typechecking and non-typechecking versions
of adding a method can share almost all the code
"

| pt <ParseTree> method <Method> ast  <DeltaMethod> oldAST  <DeltaMethod> |

    pt := self parseMethod: src ifFail: blk.
    ast := pt body.
    ast visibility: vis.
	
	"Wrong. What about inherited stuff, or messages"
    oldAST := self hasFullTypeInfoLoaded
                                   ifTrue:[self typeInfo methods at: ast selector 
                                                            						ifAbsent:[self typeInfo messages at: ast selector 
                                                                                                                       						 ifAbsent:[nil] ] ].

	method := self compileMethod: ast ifFail: blk.
    self makeChange:[:mvm <MixinVMMirror> | mvm addMethod: method ifFail: blk]
        ifFail: blk.
	self hasFullTypeInfoLoaded ifTrue:[self typeInfo addMethod: ast].
	
	self sourceInfo source: src category: cat 	visibility: vis typeFormat: (ast type formattedName: pt) forSelector: ast selector.

	"ast timeSaved: Time dateAndTimeNow."
	"oldAST isNil ifFalse:[self changeMethod: oldAST to: ast.]."
	
	^pt
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
install

^self mixinDecl install! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
install: mixin <MixinVMMirror> ifFail: fb <[Str, ^DoesNotMatter]> ^ <MixinDeclMirror>
"
Private.

This method installs mixin into the vm as my mixin."

^self changeToMixin: mixin 
         oldClasses: OrderedCollection[Class] new 
         newClasses: OrderedCollection[ClassMirror] new
         ifFail: fb
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
installed  ^ <Boolean>
"Private"

self invocationInfo invocations isEmpty
	ifTrue:[self uninstall].
^self mixinDecl installed! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
instanceVariableAt: aName <Symbol> ifAbsent: aBlock <[]>

(self mixinDecl hasInstVarName: aName) ifFalse:[^aBlock value].
self instanceVariablesDo:[:v <VarDecl> | v name = aName ifTrue:[^v]].
^aBlock value.! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
instanceVariableString ^ <Str>

^self sourceInfo instanceVariableString
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
instanceVariables: vars <Str>

| oldNames <Cltn[Symbol]> newNames <OrdCltn[Symbol]> newDecls <OrdCltn[VarDecl]> |

self deltaHack.
"We parse in a dummy scope since the parser insert the instvar decls in the scope and will complain about existing ones."
newDecls := (DeltaParser new parseInstVarList: vars within: (DeltaScope within: nil)) collect: [ :pt <ParseTree[VarDecl]> | pt body scope: self scope].

self nonAtomic.
oldNames := OrderedCollection[Symbol] new.
self instanceVariablesDo: [ :v <VarDecl> | oldNames add: v name ].
newNames := newDecls collect: [: v <VarDecl> | v name].

self makeChange: [:mvm <MixinVMMirror> |
                                     mvm changeInstanceVariablesTo: newNames]
         ifFail: [:s <Str> | self error: s ].

"Now we have changed the mixin; we must adjust the type info"
"Remove old inst vars from the type info"
oldNames do: [ :name <Symbol> | 
	self typeInfoRemoveInstanceVariable: name ].

self sourceInfo instanceVariableString: vars.
newDecls do:[:v <VarDecl> | self typeInfoAddInstanceVariable: v].
"Reparse again to redeclare instvar decls. This should be changed shortly!!
DeltaParser new parseInstVarList: vars within: self scope."
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
instanceVariablesDo: blk  <[VarDecl]>

| typeInfo <SideUpdate> sorted |

typeInfo := self typeInfo.
self deltaHack.
sorted := SortedCollection[DeltaInstVar] new sortBlock: [:a <DeltaInstVar>  :b <DeltaInstVar> | a ordinalNumber <= b ordinalNumber].
typeInfo  instVarDecls do: [:v <DeltaInstVar> | sorted add: v].
sorted do: blk.
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
invocationInfo ^<AbstractInvocationData>

	^InvocationInfo at: self reflectee ifAbsent: [ self error: 'Inconsistency in invocation data' ].! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
invocations  ^<Cltn[AbstractClassMirror]> 

	^self invocationInfo invocations collect: [ :class <Class> | AbstractClassMirror on: class ]
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
isAbstract ^ <Boolean>

^self sourceInfo abstractString  = #true! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
isBranded ^ <Boolean>

^(self sourceInfo brandedString  = #false) not! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
isMeta ^ <Boolean> 

^self reflectee isMeta! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
isSubtype ^ <Boolean>

^(self sourceInfo subtypeString  = #false) not! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
komment

"This class represents a mirror on a mixin declaration.

The mirror maintains an instance variable, mixinDecl, which is a low level mirror
(a MixinVMMirror) on the actual mixin. Changes are accomplished by forwarding
to this low level mirror. The actual mixin being reflected is also available thru mixinDecl.

Changes to the structure of the mixin are accomplished by creating an uninstalled copy
of the mixin, and performing the changes on it, and the installing the changes atomically
using the changed copy as a constructor which is passed to the VM. The VM also receives
a list of all invocations and their dependent subclasses, so that it can modify them atomically
at the same time.

This process is done using the makeChange:ifFail: method, which in turn invokes the
install:ifFail: method.

Methods are simply added to the mixin, and copied down to invocations. This is not done atomically
at this point.
"! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
localScope  ^ <Scope>

"delete"
self deltaHack.

^DeltaScope new on: self ! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
makeChange: changeBlock <[MixinVMMirror, ^MixinVMMirror]> ifFail: fb <[Str]>

| copy <MixinVMMirror> |

self installed
  ifTrue:[
               copy := changeBlock value: (MixinVMMirror onCopyOf: self reflectee).
                self install: copy ifFail: fb "install copy"
                ]
  ifFalse:[changeBlock value: (MixinVMMirror on: self reflectee)]! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
masterInvocation  ^<Class> 

	^self mixinDecl masterInvocation! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
masterInvocation: c  <Class>  ifFail: fb <[Str]>

self isMeta ifTrue:[self error: 'Should not be called on meta side'].
self invocationInfo invocations size = 1 ifFalse: [^fb value: 'More than one master invocation'].		"The invocations should contain cm as the only element"
self invocationInfo invocations first  == c ifFalse: [^fb value: 'Master invocations not identical'].
self mixinDecl masterInvocation: c ifFail: fb.


! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
methodAt: selector <Symbol> ifFail: blk   <[^X def]> ^ <DeltaMethod | X>

self methodsDo: [:m <DeltaMethod> | m selector = selector ifTrue: [^m]].
^blk value
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
methodsDo: blk  <[DeltaMethod]>

| typeInfo <SideUpdate> |

typeInfo := self typeInfo .
typeInfo  methods do: blk.
typeInfo messages do: blk.! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
methodsFor: category <String>
    ^DefinitionReader for: self category: category
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
mixinDecl  ^ <MixinVMMirror>

^mixinDecl! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
mixinDecl: md <MixinVMMirror>

"self assert:[md isKindOf: MixinVMMirror]."
mixinDecl := md! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
nameExisting: n <Symbol> ifFail: fb <[Str]>

self nonAtomic.
self mixinDecl name: n ifFail: fb.
(Mirror on: (self priorReflecteeFor: n)) convertToMixin: self ifFail: fb.
                          ! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
nameNew: n <Symbol> ifFail: fb <[Str]>

"Must check if n exists already. If so, we must update it to reflect the
state of this mixin.
"
self setName: n ifFail: fb.
self install.
Delta at: n put: self reflectee.
      ! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
nestInGenericWithTypeArguments: tas  <Str>

super nestInGenericWithTypeArguments: tas.
self isMeta ifFalse:[self sourceInfo typeArgumentString: tas].! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
nonSubtypeHeir: ih <Decl> checkSelector: sel <Symbol> withSignature: sig  <MsgSignature>

"Private.
Check heir ih to see whether it conflicts typewise with the signature sig of selector sel"
| ihSig <MsgSignature>  typeInfo <SideUpdate>  ihTypeInfo <MixinInvocationSide> |


ihTypeInfo := Type forClass: ih reflectee.
typeInfo := self typeInfo .

(ihTypeInfo functions includesKey: sel)
       ifTrue:[
                      typeInfo errorHandler pushDefinitions: ihTypeInfo and: typeInfo.
                      typeInfo errorHandler pushSelector: sel.
                     ihSig := (ihTypeInfo functions at: sel) type.
                     ihTypeInfo  subtype
                             ifFalse:[
                                            (ihSig subtypeOf: sig assuming: DeltaGlobalTrail)
                                                      ifFalse:[ typeInfo reportError: DeltaMsgConflictInheritedtypeInSubError new.].
                                            ].
                           typeInfo errorHandler popDefinitions.
                           typeInfo errorHandler popSelector.     
                          ].
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
nonSubtypeHeirsCheckSelector: sel <Symbol> withSignature: sig  <MsgSignature>

"Private.
Check all heirs that are inherited types of me to see whether they conflict typewise with the siganture sig of the
selector sel"

self immediateHeirs do:[:ih <Decl> |
                                               self nonSubtypeHeir: ih checkSelector: sel withSignature: sig
                                               ].! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
notSubtype

self subtype: false! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
noteFilteredSendersOf: sel <Symbol>

" Private.
This method is intended to make a note of all potentially problematic
senders of the message sel.  Collect all senders, and filter
them according to a suitable criterion. Then add these to the set of
methods that may require typechecking."

| unfilteredSenders  <Set[MethodLocator]>  senders  <Set[MethodLocator]>  |

unfilteredSenders := self sendersOf:  sel.
"Here is where we supposedly filter out irrelevant sends. Currently we just select those 
methods that had successfully typechecked  "

senders := unfilteredSenders select:[:s | s deltaMethod  typecheckedSuccessfully].
 "add all relevant senders to the list of methods that must be re-typechecked"
senders do:[: sender  <MethodLocator>  | DeltaMethodsToRevisit add: sender.].
  





! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
parseMethod: src <Str> ifFail: blk <[Str,Int]> ^ <ParseTree[DeltaMethod]>

	| scope <Scope> mi <Class> |
	"We use a constructed untyped scope if no type information is loaded.
		This is currently only enabled for mixins with a master invocation (since 
		currently computing the superclass type class object for a pure mixin will 
		cause type information to be loaded)."
	scope := (self hasTypeInfoLoaded or: [ (mi := self masterInvocation) isNil])
		ifTrue: [		self scope ]
		ifFalse: [	DeltaUntypedClassScope for: (AbstractClassMirror on: mi) ].
	^DeltaParser new parseMethod: src within: scope ifError: blk
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
poolString ^ <Str>

^self sourceInfo poolString! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
pools: pools  <Str> 

self assert: [ pools isString ].
self changePoolsTo: ((DeltaParser new parseIdList: pools within: DeltaGlobals) collect: [ :pt <ParseTree[Ref]> | pt body])! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
prepareInvocation2: inv <Class> mixinFormat: mixinFormat <Symbol> 
oldClasses: ocs <OrderedCollection[Class]> newClasses: ncs <OrderedCollection[ClassMirror]> 
ifFail: fb <[Str, ^DoesNotMatter]> ^  <Array[Class|Symbol]>
| 
dependents <Collection[Class]>
a <Array[Class | Symbol]>
mir <ClassVMMirror>
j  <Integer>
formats <VarDict[Class, Symbol]>
sc <ClassVMMirror | ClassMirror>
dm <ClassVMMirror>
formatMightChange <Boolean>
fmt <Symbol> 
|

                                      
mir := ClassVMMirror on: inv.
dependents := mir sortedSubclasses remove: inv; yourself.
formats := IdentityDictionary[Class, Symbol] new.
formatMightChange := ocs isEmpty not.
formatMightChange 
	ifTrue:[
				formats at: inv put: nil.
				dependents do:[:d <Class> | formats at: d put: nil].
				fmt := self formatFor: mir mixinFormat: mixinFormat formats: formats ifFail: fb.
				]
	ifFalse:[fmt := mir format].
a := Array[Class | Symbol] new: 3 + (dependents size * 2).
a at: 1 put: inv.
a at: 2 put: fmt. " new format, if legal !!"
sc := ((ocs includes: inv)
			ifTrue:[ncs at: (ocs indexOf: inv ifAbsent:[self error: 'Internal failure in change'])]
			ifFalse:[mir]) superclass.
a at: 3 put: (sc notNil ifTrue:[sc reflectee] ifFalse:[nil]).
j := 4.
dependents do:[: d <Class>  | 
								dm := ClassVMMirror on: d.
								a at: j put: d.
								fmt := formatMightChange 
									ifTrue:[self formatFor: dm mixinFormat: dm mixin format formats: formats ifFail: fb]
									ifFalse:[dm format].
								a at: j + 1 put:  fmt. " new format, if legal !!"
								j := j + 2.
								].                           
^a! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
prepareInvocation: inv <Class> mixinFormat: mixinFormat <Symbol> 
oldClasses: ocs <OrderedCollection[Class]> newClasses: ncs <OrderedCollection[ClassMirror]> 
ifFail: fb <[Str, ^DoesNotMatter]> ^  <Array[Class|Symbol]>
| 
dependents <Collection[Class]>
a <Array[Class | Symbol]>
mir <ClassVMMirror>
j  <Integer>
formats <VarDict[Class, Symbol]>
sc <ClassVMMirror | ClassMirror>
dm <ClassVMMirror>
formatMightChange <Boolean>
fmt <Symbol> 
|

                                      
mir := ClassVMMirror on: inv.
dependents := mir sortedSubclasses remove: inv; yourself.
formats := IdentityDictionary[Class, Symbol] new.
formatMightChange := ocs isEmpty not.
formatMightChange 
	ifTrue:[
				formats at: inv put: nil.
				dependents do:[:d <Class> | formats at: d put: nil].
				fmt := self formatFor: mir mixinFormat: mixinFormat formats: formats ifFail: fb.
				]
	ifFalse:[fmt := mir format].
a := Array[Class | Symbol] new: 3 + (dependents size * 2).
a at: 1 put: inv.
a at: 2 put: fmt. " new format, if legal !!"
sc := ((ocs includes: inv)
			ifTrue:[ncs at: (ocs indexOf: inv ifAbsent:[self error: 'Internal failure in change'])]
			ifFalse:[mir]) superclass.
a at: 3 put: (sc notNil ifTrue:[sc reflectee] ifFalse:[nil]).
j := 4.
dependents do:[: d <Class>  | 
								dm := ClassVMMirror on: d.
								a at: j put: d.
								fmt := formatMightChange 
									ifTrue:[self formatFor: dm mixinFormat: dm mixin format formats: formats ifFail: fb]
									ifFalse:[dm format].
								a at: j + 1 put:  fmt. " new format, if legal !!"
								j := j + 2.
								].                           
^a! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
privateMethodsFor: category <String>

	"For compatability"
    ^self methodsFor: category
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
protocols: p  <Str> 

self supportedProtocol: p! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
publicMethodsFor: category <String>

	"For compatability"
    ^self methodsFor: category
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
recompileAllMethodsIfFail: blk <[]>

	self compiledMethodsDo: [ :method <Method> |
		self recompileMethod: method selector ifFail: blk ]! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
recompileMethod: selector <Symbol> ifFail: blk <[]>

	| src <Str> method <Method> ast  <DeltaMethod> |

	src := self sourceForSelector: selector.
	ast := (self parseMethod: src ifFail: blk) body.
	method := self compileMethod: ast ifFail: blk.
	self makeChange:[:mvm <MixinVMMirror> | mvm addMethod: method ifFail: [^blk value]]
		ifFail: [self error: 'Failed attempt to install method in mixin ', self name].
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
referencesToAssociation: assoc <Association> ^ <Cltn[MethodLocator]>
	| result <Cltn[MethodLocator]> |
	result := OrderedCollection [MethodLocator] new.
	self mixinDecl methodsDo: [ :method <Method> | 
		 (method referencesAssociation: assoc) ifTrue: [
				result add: (MethodLocator new definition: self basicLocator selector: method selector)]].
	^result! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
reflect: r  <MixinVMMirror>
"Private"

| i <InvocationData> ci <MetaInvocationData> |
self mixinDecl: r.
(InvocationInfo includesKey: r reflectee) ifFalse: [
	i := InvocationData new.
	InvocationInfo at: r reflectee put: i.
	(InvocationInfo includesKey: r classSide reflectee) ifFalse: [
		ci := MetaInvocationData new dual: i.
		InvocationInfo at: r classSide reflectee put: ci ] ]
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
reflectee  ^ <Mixin>

	^self mixinDecl isNil
		ifTrue: [		nil ]
		ifFalse: [	self mixinDecl reflectee ]! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
reflectee: r <Mixin>

	self mixinDecl reflectee: r! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
removeAllClassVariables
"We need to create the collection of names first, because we cannot iterate over the same
collection we are modifying "
| names <OrdCltn[Symbol]> |

names := OrderedCollection[Symbol] new.
self mixinDecl classVarNamesDo: [: n <Symbol> | names add: n].
names do:
   [: n <Symbol> | 
   self removeClassVariable: n 
            ifAbsent:[self error: 'Internal inconsistency - missing class variable in ', self name]
   ].
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
removeAllInstanceVariables

"We need to create the collection of names first, because we cannot iterate over the same
collection we are modifying "
| names <OrdCltn[Symbol]> |

names := OrderedCollection[Symbol] new.
self mixinDecl instVarNamesDo: [: n <Symbol> | names add: n].
names do:
   [: n <Symbol> | 
   self removeInstanceVariable: n 
            ifAbsent:[self error: 'Internal inconsistency - missing instance variable in ', self name]
   ].
! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
removeClassVariable: name  <Symbol>  ifAbsent: blk  <[]> 

self isMeta ifTrue:[self error: 'Class variables cannot be manipulated through metaclasses'].
self makeChange:[:mvm <MixinVMMirror> | mvm removeClassVarName: name ifFail: [: e <Str> | blk value]]
        ifFail: [:e <Str> | self error: 'Failed attempt to remove class variable ', name, ' in mixin ', self name, ' : ', e].

self typeInfoRemoveClassVariable: name.! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
removeClassVariable: name  <Symbol>  ifFail: blk  <[Str]> 

self isMeta ifTrue:[blk value].
self makeChange:[:mvm <MixinVMMirror> | mvm removeClassVarName: name ifFail: blk]
        ifFail: blk.

self typeInfoRemoveClassVariable: name.! !

"August 22, 2009 -> 14:23:40"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
removeDefinitionIfFail: blk <[]>

	"Remove entry from system dictionary and source database"

	super removeDefinitionIfFail: [ ^blk value ].
	self mixinDecl: nil.
	^nil! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
removeInstanceVariable: name  <Symbol>  ifAbsent: blk  <[]> 

self makeChange:[:mvm <MixinVMMirror> | mvm removeInstVarName: name ifFail: [: e <Str> | blk value]]
        ifFail: [:e <Str> | self error: 'Failed attempt to remove instance variable ', name, ' in mixin ', self name, ' : ', e].

self typeInfoRemoveInstanceVariable: name.! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
removeMethod: selector <Symbol>  ifAbsent: blk <[]>

| typeInfo <SideUpdate> |

self mayNeedToUnwind.

(self hasSelector: selector)
	ifFalse: [	self sourceInfo removeSelector: selector ifAbsent: [].		"Remove if present in source database (for consistency)"
						^blk value ].
						
self makeChange:[:mvm <MixinVMMirror> | mvm removeMethodAt: selector ifFail: [:e <Str> | ^blk value ]] 
         ifFail: [:e <Str> | 'Failed attempt to remove method ', selector, ' in mixin ', self name, ' : ', e].

self hasFullTypeInfoLoaded
	ifTrue:[
				typeInfo := self typeInfo.
				typeInfo  methods removeKey: selector 
                                 				    ifAbsent:[typeInfo messages removeKey: selector
                                                                                    			            ifAbsent: []. "Should never happen"
                                                     				  ].	
				].
self sourceInfo removeSelector: selector ifAbsent: blk.! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
removePool: name <Str>  ifAbsent: blk <[]>

self deltaHack.
self halt.! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
rename: oldId <Symbol> to: newId <Symbol>

| s <ReadString> src <ReadString>  |

"rename in all methods"
self methodsDo:[: m <DeltaMethod> |
									src := self sourceForSelector: m selector.
									s := self rename: oldId to: newId in: src.
									s == src
										ifFalse:[self addMethod: s
																visibility: (self sourceInfo visibilityForSelector: m selector)
																category: (self sourceInfo categoryForSelector: m selector)
																ifFail:[:msg <Str>  :i <Int>  | self error: 'Renamed code uparseable: ', msg].
														].
								].
"rename in all instance variables"
s := self rename: oldId to: newId in: (src := self instanceVariableString).
s == src  ifFalse:[self instanceVariables: s].
"rename in supported protocol"
s := self rename: oldId to: newId in: (src := self supportedProtocolString).
s == src ifFalse:[self supportedProtocol: s].
"If non meta: "
self isMeta
	ifFalse:[
				"rename in superclass type"
					s := self rename: oldId to: newId in: (src := self superclassTypeString).
					s == src ifFalse:[self superclassType: s].
				"rename in all class variables"
					s := self rename: oldId to: newId in: (src := self classVariableString).
					s == src ifFalse:[self classVariables: s].
				"rename in all type arguments, if any"
					s := self rename: oldId to: newId in: (src := self typeArgumentString).
					s == src ifFalse:[self nestInGenericWithTypeArguments: s].
					self classSide rename: oldId to: newId.
				].
! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
renameGroup: grp <Dict[Symbol,Symbol]>

| s <ReadString> src <ReadString>  |

"rename in all methods"
self methodsDo:[: m <DeltaMethod> |
									src := self sourceForSelector: m selector.
									s := self renameGroup: grp in: src.
									s == src
										ifFalse:[self addMethod: s
																visibility: (self sourceInfo visibilityForSelector: m selector)
																category: (self sourceInfo categoryForSelector: m selector)
																ifFail:[:msg <Str>  :i <Int>  | self error: 'Renamed code uparseable: ', msg].
														].
								].
"rename in all instance variables"
s := self renameGroup: grp in: (src := self instanceVariableString).
s == src  ifFalse:[self instanceVariables: s].
"rename in supported protocol"
s := self renameGroup: grp in: (src := self supportedProtocolString).
s == src ifFalse:[self supportedProtocol: s].
"If non meta: "
self isMeta
	ifFalse:[
				"rename in superclass type"
					s := self renameGroup: grp in: (src := self superclassTypeString).
					s == src ifFalse:[self superclassType: s].
				"rename in all class variables"
					s := self renameGroup: grp in: (src := self classVariableString).
					s == src ifFalse:[self classVariables: s].
				"rename in all type arguments, if any"
					s := self renameGroup: grp in: (src := self typeArgumentString).
					s == src ifFalse:[self nestInGenericWithTypeArguments: s].
					self classSide renameGroup: grp.
				].
! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
scope  ^ <Scope>

	^self typeInfo scope
! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
scope: s <Scope>

	self typeInfo scope: s
! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
selectorsFor: cat <Str> ^ <OrdCltn[Symbol]>
	
	^self sourceInfo selectorsFor: cat! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
selectorsMatching: pattern <Str> ^ <Set[Symbol]>

	| result <Set[Symbol]> |
	result := Set[Symbol] new.
	self compiledMethodsDo: [ :method <Method> | 		"We use compiled methods here since otherwise type info will have to be loaded"
		(pattern platformMatch: method selector) 
			ifTrue: [	result add: method selector ] ].
	^result! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
setName: n <Symbol> ifFail: fb <[Str]>

self mixinDecl name: n ifFail: fb.
self sourceInfo setName: n! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
sourceForSelector: sel <Symbol>  ^ <Str>

	^self sourceInfo sourceForSelector: sel
! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
sourceInfo ^<MixinSourceHandler>

	sourceInfo isNil 
		ifTrue: [ sourceInfo := MixinSourceHandler for: self ].
	^sourceInfo! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
subtype ^ <Boolean>

	^self typeInfo subtype! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
subtype: s <Boolean>

	self typeInfo subtype: s.
	self sourceInfo subtype: s.
! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
superclassType ^ <ClassNode>

^self typeInfo superclassType.
! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
superclassType: st <Str>

| superclass <ClassExpr> |

self assert: [ st isString ].
self sourceInfo superclassTypeString: st.
superclass := (DeltaParser new parseClassOrMixinExpr: st within: self scope) body.
self typeInfo superclassType: superclass.
(Type forMixin: self classSide reflectee) superclassType: superclass dualClassType.
AbstractClassMirror flushSubclassHierarchyCache.
! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
superclassTypeString ^ <Str>

^self sourceInfo superclassTypeString
! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
supportedProtocol: p <Str>

self assert: [ p isString ].
self sourceInfo supportedProtocolString: p.
p isEmpty ifFalse:[self typeInfo supportedProtocol: (DeltaParser new
parseTypeExpr: p within: self scope superScope) body]
                    ifTrue:[self typeInfo supportedProtocol: nil].! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
supportedProtocolString ^ <Str>

^self sourceInfo supportedProtocolString
! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
typeArgumentString ^ <Str>

^self isMeta ifTrue:[self instanceSide typeArgumentString]
                        ifFalse:[self sourceInfo typeArgumentString].
! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
typeForNode: n <ASTNode> inMethod: m <Method > ^ <ObjectType>

^self typeInfo typeForNode: n inMethod: m! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
typeInfo ^ <SideUpdate>
"Private"

^(Type forMixin: self reflectee)! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
typeInfoAddClassVariable: v  <VarDecl>
"Private"

self isMeta ifFalse:[self classSide scope at: v name put: v.].
self typeInfo scope at: v name put: v.! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
typeInfoAddInstanceVariable: v  <VarDecl>
"Private"

self typeInfo scope at: v name put: v.! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
typeInfoClassVariables: vars <Str>
"Change class vars in type info and source only"
self deltaHack.
self assert: [ vars isString ].
self sourceInfo classVariableString: vars.
self classVariablesDo: [: v <VarDecl> | self typeInfoRemoveClassVariable: v name].
 ((DeltaParser new parseClassVarList: vars within: self scope) collect: [ :pt <ParseTree[VarDecl]> | pt body  scope: DeltaGlobals])
   do:[:v <VarDecl> | self typeInfoAddClassVariable: v].

! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
typeInfoInstanceVariables: vars <Str>
"Change inst vars in type info and source only"
self deltaHack. 
self assert: [ vars isString ].
self sourceInfo instanceVariableString: vars.
self instanceVariablesDo: [: v <VarDecl> | self typeInfoRemoveInstanceVariable: v name].
 ((DeltaParser new parseInstVarList: vars within: self scope) collect: [ :pt <ParseTree[VarDecl]> | pt body])
   do:[:v <VarDecl> | self typeInfoAddInstanceVariable: v].

! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
typeInfoRemoveClassVariable: name  <Symbol> 
"Private"

self isMeta ifFalse:[self classSide scope removeKey: name.].
self typeInfo scope removeKey: name.! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
typeInfoRemoveInstanceVariable: name  <Symbol> 
"Private"
self typeInfo scope removeKey: name.! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
typeNameForNode: n <ASTNode> inMethod: m <Method > ^ <String>

^self typeInfo typeNameForNode: n inMethod: m! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
unbranded

self branded: false! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
uninstall

^self mixinDecl uninstall! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
updateDependenciesFrom: oldAST to: newAST

" Private.
Update the top level dependency graph based upon the differences among the new and old ASTs"
| newRefs <OrdCltn[Symbol]> oldRefs <OrdCltn[Symbol]> |
"add dependencies present in newAST"

newRefs := (DeltaReferenceGatherer new initialize methodNode: newAST) references.
newRefs do:[:r <Symbol> | DeltaDependencyGraph addDependencyFrom: self  name to: r].

oldRefs := (DeltaReferenceGatherer new initialize methodNode: oldAST) references.
oldRefs do:[:r <Symbol> | DeltaDependencyGraph removeDependencyFrom: self  name to: r].
"remove dependencies present in oldAST"
! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
vmInvocations ^ <OrdCltn[ClassVMMirror]>
"Private"
	^self invocationInfo invocations collect:[: inv <Class> | ClassVMMirror on: inv]
! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
|> c <ClassMirror > ^ <ClassMirror>
"h2"
| invocation <ClassVMMirror> |

self isMeta ifTrue:[self error: 'MetaMixins should not be invoked'].

invocation := ClassVMMirror createInvocationOf: self mixinDecl 
                              superclass:  (ClassVMMirror on: c reflectee)
                              ifFail: [: e | self error: 'Internal inconsistency in MixinDeclMirror>>|> ', e].
self class addTypeStructureForInvocation: invocation.
self addInvocation: invocation reflectee.

^InvocationMirror on: invocation reflectee
! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'accessing' !
shortDescription ^ <Str>

	"Returns a short desciption of this mixin"
	
	| header <String> |
	header := ''.
	self isGeneric
		ifTrue: [ 		header := header, 'generic ' ].
	self isSubtype
		ifFalse: [ 	header := header, 'non-subtype ' ].
	self isAbstract
		ifTrue: [		header := header, 'abstract ' ].
	header := header, 'mixin on ', self superclassTypeString.
	^header at: 1 put: (header at: 1) asUppercase; yourself
! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'loading type info' !
createMethodTypeStructure

	| 
	ast <DeltaMethod> 
	ti <DeltaSideUpdate>
	selector <Symbol>
	methods <IdentitySet[Symbol]> 
	messages <IdentitySet[Symbol]>
	 |

ti := self typeInfo.
methods := IdentityDictionary[Symbol, DeltaMethod] new.
messages := IdentityDictionary[Symbol, DeltaMethod] new.
ti 	methods: methods;
	messages: messages.
self compiledMethodsDo:
[: m <Method> | 
		selector := m selector.
		m isAbstract
			ifTrue: [		messages at: selector put: (LazyMessage new mixin: self reflectee; mySelector: selector)]
			ifFalse: [	methods at: selector put: (LazyMethod new mixin: self reflectee; mySelector: selector)] 
]
! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'loading type info' !
createTypeStructure
" This method creates type information for my mixin, based upon the contents of
the  source database"
|
cDecl  <ClassUpdate> 
mixinTypeInfo <SideUpdate>
classMixinTypeInfo <SideUpdate>
st <ClassId | MixinInvocationNode | GenericApplicationClassType>
classSide <MixinDeclMirror>
isGeneric <Boolean>
sp <Str>
sts <Str>
tas <VarOrdCltn[TypeFormal]>
 |

self isMeta ifTrue:[^self instanceSide createTypeStructure].
ReportTypeLoading
	ifTrue:[ Platform errorStream show: 'Loading type info for ', self name; cr].
self name = #Object ifTrue:[^self createTypeStructureForObject].
classSide := self classSide.
isGeneric := self sourceInfo isGeneric.

"Create type info node(s)"

cDecl := DeltaClassUpdate new  abstract: self isAbstract; 
                                                       branded: self isBranded; 
                                                       monotonic: self extensionsAreSubtypes; 
                                                       subtype: self isSubtype.
mixinTypeInfo :=  DeltaSideUpdate new initialize.
cDecl instanceSide: mixinTypeInfo.
classMixinTypeInfo :=  DeltaSideUpdate new initialize classDecl: cDecl.
"Nil out methods to provoke reparsing"
mixinTypeInfo methods: nil; messages: nil.
classMixinTypeInfo  methods: nil; messages: nil.

cDecl instanceSide: mixinTypeInfo.

Type atMixin: self reflectee put: mixinTypeInfo.
Type atMixin: self classSide  reflectee put: classMixinTypeInfo.

DeltaSilentTypeErrorHandler new catchErrorsFor: [
isGeneric
   ifTrue:[ 
                tas := (DeltaParser new parseTypeArgs: self typeArgumentString
                                                              within:  DeltaGlobals
                                                              ifError:[:m <Str> : i <Integer> | self error: 'Source database contains invalid code'])
                              collect: [ :pt <ParseTree> | pt body].
               mixinTypeInfo := DeltaGenericSideUpdate new name: self name  body: mixinTypeInfo formals: tas.
               classMixinTypeInfo := DeltaGenericSideUpdate new name: classSide name body: classMixinTypeInfo formals: tas.
              Type atMixin: self reflectee put: mixinTypeInfo.
              Type atMixin: self classSide  reflectee put: classMixinTypeInfo.
              self adjustBounds.
               ].

"set up superclass type info "
sts := self superclassTypeString.
sts isEmpty ifTrue:[sts := 'Object'].
st := (DeltaParser new parseClassOrMixinExpr:  sts within: self scope superScope) body.

mixinTypeInfo superclassType:  st.
classMixinTypeInfo superclassType: st dualClassType.

"Patch up instance, class and pool variables for both sides"

 ((DeltaParser new parseInstVarList: self instanceVariableString within: self scope) collect: [ :pt <ParseTree[VarDecl]> | pt body])
   do:[:v <VarDecl> | self typeInfoAddInstanceVariable: v].

 ((DeltaParser new parseClassVarList: self classVariableString within: self scope) collect: [ :pt <ParseTree[VarDecl]> | pt body scope: DeltaGlobals])
   do:[:v <VarDecl> | self typeInfoAddClassVariable: v].

 ((DeltaParser new parseInstVarList:  classSide instanceVariableString within:  classSide scope) collect: [ :pt <ParseTree[VarDecl]> | pt body])
   do:[:v <VarDecl> |  classSide typeInfoAddInstanceVariable: v].

"self  typeInfoPools: self poolString."

" patch up supported protocol info on both sides"

sp := self supportedProtocolString.
sp isEmpty 
	ifFalse:[mixinTypeInfo supportedProtocol: (DeltaParser new parseTypeExpr: sp 
                                                                    within: self scope superScope) body.
					isGeneric ifTrue:[mixinTypeInfo formals do:[:f <TypeFormal>  | mixinTypeInfo supportedProtocol addRelevantTypeVar: f typeVar]].
                   ].

sp :=  self classSide supportedProtocolString.

sp isEmpty 
	ifFalse:[classMixinTypeInfo supportedProtocol: (DeltaParser new parseTypeExpr:  sp 
                                                                               within:  classSide scope superScope) body.
 					isGeneric ifTrue:[classMixinTypeInfo formals do:[:f <TypeFormal>  | 
 																													classMixinTypeInfo supportedProtocol addRelevantTypeVar: f typeVar
 																													]
 													].
                   ].
                   ].
! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'loading type info' !
createTypeStructureForObject

"Private"
"Special case, when reflectee is Object. Requires special type structure"

|
cDecl  <ClassUpdate> 
mixinTypeInfo <SideUpdate>
classMixinTypeInfo <SideUpdate>
st <ClassId | MixinInvocationNode | GenericApplicationClassType>
classSide <MixinDeclMirror>
sp <Str>
sts <Str>
|

classSide := self classSide.


"Create type info node(s)"

cDecl := DeltaClassUpdate new  abstract: self isAbstract; 
                                                       branded: self isBranded; 
                                                       monotonic: self extensionsAreSubtypes; 
                                                       subtype: self isSubtype.
mixinTypeInfo :=  DeltaSide new initialize.
classMixinTypeInfo :=  DeltaObjectClassSide new initialize classDecl: cDecl.
"Nil out methods to provoke reparsing"
mixinTypeInfo methods: nil; messages: nil.
classMixinTypeInfo methods: nil; messages: nil.

cDecl instanceSide: mixinTypeInfo.

Type atMixin: self reflectee put: mixinTypeInfo.
Type atMixin: self classSide  reflectee put: classMixinTypeInfo.

classMixinTypeInfo superclassType: (DeltaClassId new setId: #Class; scope: DeltaGlobals).


"Patch up instance, class and pool variables for both sides"

 ((DeltaParser new parseInstVarList: self instanceVariableString within: self scope) collect: [ :pt <ParseTree[VarDecl]> | pt body])
   do:[:v <VarDecl> | self typeInfoAddInstanceVariable: v].

 ((DeltaParser new parseClassVarList: self classVariableString within: self scope) collect: [ :pt <ParseTree[VarDecl]> | pt body scope: DeltaGlobals])
   do:[:v <VarDecl> | self typeInfoAddClassVariable: v].

 ((DeltaParser new parseInstVarList:  classSide instanceVariableString within:  classSide scope) collect: [ :pt <ParseTree[VarDecl]> | pt body])
   do:[:v <VarDecl> |  classSide typeInfoAddInstanceVariable: v].

"self  typeInfoPools: self poolString."

" patch up supported protocol info on both sides"

sp := self supportedProtocolString.
sp isEmpty ifFalse:[mixinTypeInfo supportedProtocol: (DeltaParser new parseTypeExpr: sp 
                                                                    within: self scope superScope) body.].

sp :=  self classSide supportedProtocolString.

sp isEmpty ifFalse:[classMixinTypeInfo supportedProtocol: (DeltaParser new parseTypeExpr:  sp 
                                                                               within:  classSide scope superScope) body.].




! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'loading type info' !
hasFullTypeInfoLoaded ^ <Boolean>

^self hasTypeInfoLoaded and:[self typeInfo hasMethodsLoaded].! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'loading type info' !
loadMsgSelector: sel <Symbol> ^ <DeltaMethod>

| ast <DeltaMethod> |
	ReportTypeLoading
		ifTrue:[Platform errorStream  show: 'Loading type info for message ', self name, '>>', sel; cr].
   ast := (DeltaParser new parseMethodHeader: (self sourceForSelector:  sel)
                                                  within: self scope
                                                  ifError: [self error: 'Internal failure: Source database has syntax errors']
                                                         ) body.
    ast visibility: (self sourceInfo visibilityForSelector: sel).
    self typeInfo messages at: sel put: ast.
    ast clearBody.
    ^ast! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'loading type info' !
loadSelector: sel <Symbol> ^ <DeltaMethod>

| ast <DeltaMethod> |

	ReportTypeLoading
		ifTrue:[Platform errorStream show: 'Loading type info for method ', self name, '>>', sel; cr].
   ast := (DeltaParser new parseMethodHeader: (self sourceForSelector:  sel)
                                                  within: self scope
                                                  ifError: [: e <Str> :i <Int> | self error: 'Internal failure: Source database has syntax errors']
                                                         ) body.
    ast visibility: (self sourceInfo visibilityForSelector: sel).
    self typeInfo methods at: sel put: ast.
    ast clearBody.
    ^ast! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'typechecking' !
typecheck

	| methodsWithoutBody <OrdCltn[DeltaMethod]> tmp <DeltaMethod> |

	methodsWithoutBody := OrderedCollection[DeltaMethod] new.
	self methodsDo: [ :m <DeltaMethod> | m body isNil ifTrue: [ methodsWithoutBody add: m ]].
	[
		methodsWithoutBody do: [ :m <DeltaMethod> |
			DeltaSilentTypeErrorHandler new catchErrorsFor: [
				tmp := (self parseMethod: (self sourceForSelector: m selector) ifFail: [:s <Str> :i <Int> | self halt]) body
			].
               m type: tmp type.
			m body: tmp body
		].
		self typeInfo typecheck.
	] ensure: [
		methodsWithoutBody do: [ :m <DeltaMethod> | m clearBody ]
	]
! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'typechecking' !
typecheckClassVars

self typeInfo typecheckClassVarDecls 


! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'typechecking' !
typecheckDeclaration

self typeInfo typecheckDeclaration! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'typechecking' !
typecheckInstVars

self typeInfo typecheckInstVarDecls 
! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'typechecking' !
typecheckInterface

self typeInfo typecheckInterface! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'typechecking' !
typecheckSelector: sel <Symbol>

	| m <DeltaMethod> tmp <DeltaMethod> methodHasBody <Boolean> |
	
	m := self methodAt: sel ifFail: [self error: 'Method not found'].
	methodHasBody := m body notNil.
	[
		methodHasBody
			ifFalse: [	DeltaSilentTypeErrorHandler new catchErrorsFor: [
									tmp := (self parseMethod: (self sourceForSelector: sel) ifFail: [:s <Str> :i <Int> | self shouldNotHappen]) body
								].
								m type: tmp type.
								m body: tmp body.
							].
		self typeInfo typecheckMethod: m.
	] ensure: [
		methodHasBody
			ifFalse: [	m clearBody ]
	]
! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'typechecking' !
typecheckSelectorInterface: sel <Symbol>

	| m <DeltaMethod> tmp <DeltaMethod> methodHasBody <Boolean> |
	
	m := self methodAt: sel ifFail: [self error: 'Method not found'].
	methodHasBody := m body notNil.
	[
		methodHasBody
			ifFalse: [	DeltaSilentTypeErrorHandler new catchErrorsFor: [
									tmp := (self parseMethod: (self sourceForSelector: sel) ifFail: [:s <Str> :i <Int> | self shouldNotHappen]) body
								].
								m body: tmp body.
							].
		self typeInfo typecheckMethodInterface: m.
	] ensure: [
		methodHasBody
			ifFalse: [	m clearBody ]
	]
! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'typechecking' !
typecheckSuperclassClause

self typeInfo typecheckSuperclassType.
! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'typechecking' !
typecheckSupportedProtocol

self typeInfo typecheckSupportedProtocol. ! !

"August 22, 2009 -> 14:23:41"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'typechecking' !
typecheckTypeArguments

self typeInfo asGeneric typecheckTypeArgs. 
! !

"August 22, 2009 -> 14:24:24"!

Delta define: #ProtocolMirror as: (
(Class subclassOf: 'Mirror' instanceVariables: 'reflectee sourceInfo ')) !


"August 22, 2009 -> 14:24:24"!

Delta define: #ProtocolMirror as: (
(Class subclassOf: 'Mirror' instanceVariables: 'reflectee sourceInfo ')) !


"August 22, 2009 -> 14:24:24"!

Delta define: #ProtocolMirror as: (
(Class subclassOf: 'Mirror' instanceVariables: 'reflectee sourceInfo ')) !


"August 22, 2009 -> 14:24:24"!

Delta define: #ProtocolMirror as: (
(Class subclassOf: 'Mirror' instanceVariables: 'reflectee sourceInfo ')) !


"August 22, 2009 -> 14:24:24"!

Delta define: #ProtocolMirror as: (
(Class subclassOf: 'Mirror' instanceVariables: 'reflectee sourceInfo ')) !


"August 22, 2009 -> 14:24:24"!

Delta define: #ProtocolMirror as: (
(Class subclassOf: 'Mirror' instanceVariables: 'reflectee sourceInfo ')) !


"August 22, 2009 -> 14:24:24"!

Delta define: #ProtocolMirror as: (
(Class subclassOf: 'Mirror' instanceVariables: 'reflectee sourceInfo ')) !


"August 22, 2009 -> 14:24:24"!

Delta define: #ProtocolMirror as: (
(Class subclassOf: 'Mirror' instanceVariables: 'reflectee sourceInfo ')) !


"August 22, 2009 -> 14:24:24"!

Delta define: #ProtocolMirror as: (
(Class subclassOf: 'Mirror' instanceVariables: 'reflectee sourceInfo ')) !


"August 22, 2009 -> 14:24:24"!

Delta define: #ProtocolMirror as: (
(Class subclassOf: 'Mirror' instanceVariables: 'reflectee sourceInfo ')) !


"August 22, 2009 -> 14:24:24"!

Delta define: #ProtocolMirror as: (
(Class subclassOf: 'Mirror' instanceVariables: 'reflectee sourceInfo ')) !


"August 22, 2009 -> 14:24:24"!

(Delta mirrorFor: #ProtocolMirror)
comment: 
'This class represents a mirror on a protocol declaration.

The mirror is on the run-time representation of a protocol,
of class Protocol, that only retains its name.

The protocol is used as a key to look up source code and type information.
The mirror allows certain manipulations of these.

 (c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) classSide methodsFor: 'Unclassified' !
on: protocol <Protocol> ^ <Instance> 

	^self new reflectee: protocol! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) classSide methodsFor: 'Unclassified' !
superProtocol: name <Str> subtype: b <Boolean> ^ <Instance>

    ^(self on: Protocol new) initializeSuperProtocol: name subtype: b branded: true! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
addMessage: src <Str> category: cat <Str> ifFail: aBlock ^ <ParseTree>

	|  pt <ParseTree> mp <MessagePattern> | 

	pt := self addMessage: src  ifFail: aBlock.
	mp := pt body.
	self sourceInfo source: src category: cat visibility: #public typeFormat: (mp type formattedName: pt) forSelector: mp selector.
	^pt! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
addMessage: src <Str>  ifFail: aBlock ^ <ParseTree>
	"Private"
	|  pt <ParseTree> mp <MessagePattern> |

	pt := self parseMessage: src ifFail: aBlock.
	mp := pt body.
	self messages at: mp selector put: mp type.
	^pt
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
addMethod: str <Str> visibility: v <Symbol> category: cat <Str> ifFail: blk ^ <ParseTree>

	^self addMessage: str category: cat ifFail: blk
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
adjustBounds
"Private"

self typeInfo  asGeneric adjustBoundToTrivialApplication.		"Update name of target in trivial application"
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
asProtocol
	^self typeInfo asProtocol! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
basicDefinitionString  ^ <Str>

^'Protocol superProtocol: ', self superprotocolString asString printString,  
(self isSubtype ifFalse:['; notSubtype '] ifTrue:['']),
(self isBranded ifFalse:['; unbranded '] ifTrue:[''])
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
basicLocator  ^ <BasicMixinLocator> 
	^self typeInfo basicLocator! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
branded ^ <Boolean>

self deltaHack.
^true
"^self typeInfo branded"! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
branded: b <Boolean>
"Private"
self deltaHack.
"
^self typeInfo branded: b"! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
classSide ^ <ProtocolMirror>

^self actualClass on: self reflectee classProtocol! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
comment: c  <Str> 

c isNil
	ifTrue: [	Transcript show: 'Protocol ', self name, ' has comment set to nil, change this to an empty string'; cr.
					self sourceInfo comment: '' ]
	ifFalse: [	self sourceInfo comment: c ]
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
convert: m <Mirror> ifFail: fb <[Str]>

m convertToProtocol: self ifFail: fb.
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
convert: m <Mirror> toGeneric: g   <GenericMirror> ifFail: fb <[Str]>

self assert: [g body = self].
m convertToGenericProtocol: g ifFail: fb! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
convertToGenericClass: g <ProtocolMirror> ifFail: fb <[Str]>

fb value: 'Cannot convert a protocol into a generic class'
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
convertToGenericProtocol: g <ProtocolMirror> ifFail: fb <[Str]>

self convertToProtocol: g body ifFail: fb.
self nestInGenericWithTypeArguments: g typeArgumentString.
self adjustBounds.
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
convertToProtocol: p <ProtocolMirror> ifFail: fb <[Str]>

self superProtocol: p superprotocolString.
self subtype: p subtype.
self branded: p isBranded.
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
createMessageTypeStructure

self sourceInfo selectorsDo: 
[: m <Symbol> | 
    self addMessage: (self sourceForSelector: m )
             ifFail: [self error: 'Internal failure: Source database has syntax errors'].
].
                                                       ! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
createTypeStructure
    
| tas <VarOrdCltn[TypeFormal]> genericTypeInfo <GenericProtocolUpdate> |

self nonAtomic.
ReportTypeLoading
	ifTrue:[Platform errorStream show: 'Loading type info for Protocol ', self name; cr].
self setupInitialTypeInfo.
self setSuperProtocol: self superprotocolString.
self typeInfo subtype: self isSubtype.
"self branded: self isBranded."

self isGeneric
     ifTrue:[
                  tas := (DeltaParser new parseTypeArgs: self typeArgumentString
                                                                 within:  DeltaGlobals
                                                                 ifError:[:m <Str> : i <Integer> | self error: 'Source database contains invalid code'])
                                collect: [ :pt <ParseTree> | pt body].
                 genericTypeInfo := (DeltaGenericProtocolUpdate new name: self name  body: self typeInfo formals: tas).
                Type atProtocol: self reflectee 
                           put: genericTypeInfo.            
                  ].

Type atProtocol: self classSide  reflectee  put: self typeInfo classProtocol.  
self createMessageTypeStructure.

! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
fileNameExtension  ^<Str>
	^'.str'! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
hasSelector: selector <Symbol> ^ <Boolean>

	^self sourceInfo hasSelector: selector! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
initializeSuperProtocol: n  <Str> subtype: st  <Boolean> branded: b  <Boolean>

	self setupInitialTypeInfo.
	self superProtocol: n.
	self subtype: st.
	b ifFalse: [self unbranded].! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
instanceSide ^ <ProtocolMirror>

	^self actualClass on: self reflectee instanceProtocol! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
isAssociationOop
	self deltaHack.
	^false! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
isBranded ^ <Boolean>

^(self sourceInfo brandedString = #false) not! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
isMarkOop
  ^false! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
isMemOop
    ^ false! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
isMeta ^ <Boolean>

^self reflectee isMeta! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
isMetaSide
	^false! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
isMethodOop
    ^ false! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
isMixin
    ^false! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
isProtocol
  ^true! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
isSmiOop
    ^ false! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
isSubtype ^ <Boolean>

^(self sourceInfo subtypeString  = #false) not! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
isSymbolOop
    ^ false! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
komment

"This class represents a mirror on a protocol declaration.

The mirror is on the run-time representation of a protocol,
of class Protocol, that only retains its name.

The protocol is used as a key to look up source code and type information.
The mirror allows certain manipulations of these.
"! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
localPrimaryInterface
"Private "
"Should probably be eliminated"
self halt. "See if this is this called anymore?"
self deltaHack.
	^self typeInfo localPrimaryInterface! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
localSecondaryInterface
"Private"
"Should probably be eliminated"
self deltaHack.
	^self typeInfo localSecondaryInterface! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
messageAt: selector <Symbol> ifFail: aBlock <[^X def]> ^ <Message | X> 
    ^self messages at: selector ifAbsent: aBlock
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
messages  ^ <Dict[Symbol,Type]>

^self typeInfo messages
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
methodAt: selector <Symbol> ifFail: aBlock <[^X def]> ^ <Message | X> 
    ^self messageAt: selector ifAbsent: aBlock
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
methodsDo: blk <[Message]>

	self messages do: blk
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
methodsFor: category <String>
    ^DefinitionReader for: self category: category! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
nameExisting: n <Symbol> ifFail: fb <[Str]>

"This method modifies an existing protocol named n so that it is equivalent to me"

|  p  <ProtocolMirror> |
p :=  Mirror on: (self priorReflecteeFor: n).
p convertToProtocol: self ifFail: fb.
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
nameNew: n <Symbol> ifFail: fb <[Str]>

"This method is used to create a new protocol
named n based upon the source code information in this object.
"
self reflectee name: n.
self typeInfo name: n.
self sourceInfo setName: n.
Delta at: n put: self reflectee.

! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
nestInGenericWithTypeArguments: tas  <Str>

| formals <OrdCltn[TypeFormal]> |

formals :=  (DeltaParser new parseTypeArgs: tas within: DeltaGlobals) collect: [ :pt | pt body].
self typeInfo generifyWithFormals: formals.
self sourceInfo typeArgumentString: tas; isGeneric: true.
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
notSubtype

    	self subtype: false! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
parseMessage: src <Str> ifFail: blk <[Str,Int]> ^ <ParseTree>

	^DeltaParser new parseMessageDeclaration: src within: self scope ifError: blk
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
parseMethod: src <Str> ifFail: blk <[Str,Int]> ^ <ParseTree>

	^self parseMessage: src  ifFail: blk 
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
privateMethodsFor: category <String>

	"For compatability"
    ^self methodsFor: category
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
publicMethodsFor: category <String>

	"For compatability"
    ^self methodsFor: category
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
reflectee   ^ <Protocol>
"Private"

^reflectee! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
reflectee: r   <Protocol>
"Private"

reflectee := r.
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
removeMethod: selector <Symbol> ifAbsent: blk <[]>
    self messages removeKey: selector ifAbsent: blk.
    self sourceInfo removeSelector: selector ifAbsent: blk! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
rename: oldId <Symbol> to: newId <Symbol>
| s <ReadString> src <ReadString>  |


"rename in all messages" 
self methodsDo:[: m <Message> |
									src := self sourceForSelector: m selector.
									s := self rename: oldId to: newId in: src.
									s == src
										ifFalse:[self addMessage: s
																category: (self sourceInfo categoryForSelector: m selector)
																ifFail:[:msg <Str>  :i <Int>  | self error: 'Renamed code uparseable: ', msg].
														].
								].
self isMeta
	ifFalse:[
					"rename in super protocol"
					s := self rename: oldId to: newId in: (src := self superprotocolString).
					s == src ifFalse:[self superProtocol: s].
					"rename in all type arguments, if any"
					s := self rename: oldId to: newId in: (src := self typeArgumentString).
					s == src ifFalse:[self nestInGenericWithTypeArguments: s].
					self classSide rename: oldId to: newId.
				].! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
renameGroup: grp <Dict[Symbo,Symbol]> 
| s <ReadString> src <ReadString>  |

"rename in all messages" 
self methodsDo:[: m <Message> |
									src := self sourceForSelector: m selector.
									s := self renameGroup: grp in: src.
									s == src
										ifFalse:[self addMessage: s
																category: (self sourceInfo categoryForSelector: m selector)
																ifFail:[:msg <Str>  :i <Int>  | self error: 'Renamed code uparseable: ', msg].
														].
								].
self isMeta
	ifFalse:[
					"rename in super protocol"
					s := self renameGroup: grp in: (src := self superprotocolString).
					s == src ifFalse:[self superProtocol: s].
					"rename in all type arguments, if any"
					s := self renameGroup: grp in: (src := self typeArgumentString).
					s == src ifFalse:[self nestInGenericWithTypeArguments: s].
					self classSide renameGroup: grp.
					].! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
scope ^ <Scope>
	^self typeInfo scope! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
scope: s <Scope>

self typeInfo scope: s

! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
selectorsFor: cat <Str> ^ <OrdCltn[Symbol]>
	
	^self sourceInfo selectorsFor: cat! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
selectorsMatching: pattern <Str> ^ <Set[Symbol]>

	| result <Set[Symbol]> |
	result := Set[Symbol] new.
	self sourceInfo selectorsDo: [ :selector <Symbol> | 		
		(pattern platformMatch: selector) 
			ifTrue: [	result add: selector ] ].
	^result! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
setSuperProtocol: sp  <Str>

| superprotocol <Protocol> |

superprotocol :=  sp isEmpty 
                                     ifTrue:[ DeltaTypeId new setId: #Object; scope: DeltaGlobals]
                                     ifFalse:[(DeltaParser new parseType: sp 
                                     													within: DeltaGlobals
                                     													ifError: [: e <Str> : i <Int> | self error: e]) body.].
superprotocol isProtocol ifFalse:[self error:  sp, ' is not a protocol'].
superprotocol scope: self scope.

self typeInfo superprotocol: superprotocol.
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
setupInitialTypeInfo
"Private"
| rawProtocol  <RawProtocol>  |

rawProtocol := DeltaRawProtocol new.
rawProtocol	 primaryInterface:  (DeltaInterface new initialize)
				      secondaryInterface: (DeltaInterface new initialize)
				      branded: true.

Type atProtocol: self reflectee
           put: (DeltaDeclaredProtocolUpdate new
			            value: self reflectee
			            superprotocol: nil
			            delta: rawProtocol
			            branded: true
			            subtype: true)


! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
sourceForSelector: sel <Symbol>  ^ <Str>

	^self sourceInfo sourceForSelector: sel
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
sourceInfo ^<ProtocolSourceHandler>

	sourceInfo isNil 
		ifTrue: [ sourceInfo := ProtocolSourceHandler for: self ].
	^sourceInfo! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
subtype  ^ <Boolean>

^self typeInfo subtype! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
subtype: st  <Boolean>

self typeInfo subtype: st.
self sourceInfo subtype: st.! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
superProtocol  ^ <ProtocolMirror>

^ProtocolMirror on: (self typeInfo superprotocol protocolObj)! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
superProtocol: sp  <Str>

self assert: [ sp isString ].
self sourceInfo superprotocolString: sp.
self setSuperProtocol: sp.! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
superprotocolString  ^ <Str>

^self sourceInfo superprotocolString! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
typeArgumentString ^ <Str>

^self sourceInfo typeArgumentString! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
typeInfo ^ <ProtocolUpdate>

"Private"

^(Type forProtocol: self reflectee).! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'Unclassified' !
unbranded

self branded: false! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'accessing' !
shortDescription ^ <Str>

	"Returns a short desciption of this protocol"

	| header <String> |
	header := ''.
	self isGeneric
		ifTrue: [ 		header := header, 'generic ' ].
	self isSubtype
		ifFalse: [ 	header := header, 'non-subtype ' ].
	header := header, 'subprotocol of ', self superprotocolString.
	^header at: 1 put: (header at: 1) asUppercase; yourself! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'typechecking' !
typecheck

	self typeInfo typecheck
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'typechecking' !
typecheckDeclaration

	self typeInfo typecheckDeclaration
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'typechecking' !
typecheckInterface

	self typeInfo typecheckInterface
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'typechecking' !
typecheckSelector: sel <Symbol> 

    self typeInfo setupTypeAssumptions.
	self typeInfo errorHandler pushDefinition: self typeInfo.
	self typeInfo typecheckMessage: (self messageAt: sel ifFail:[self error: 'message not found']).
	self typeInfo errorHandler popDefinition.
    self typeInfo retractTypeAssumptions.
	
! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'typechecking' !
typecheckSuperprotocol

self typeInfo typecheckSuperprotocol! !

"August 22, 2009 -> 14:24:24"!

! (Delta mirrorFor: #ProtocolMirror) methodsFor: 'typechecking' !
typecheckTypeArguments

self typeInfo typecheckTypeArgs. ! !

"August 22, 2009 -> 14:24:39"!

Delta define: #ClassMirror as: (
(Class subclassOf: 'AbstractClassMirror' instanceVariables: 'mixin ')) !


"August 22, 2009 -> 14:24:39"!

Delta define: #ClassMirror as: (
(Class subclassOf: 'AbstractClassMirror' instanceVariables: 'mixin ')) !


"August 22, 2009 -> 14:24:39"!

Delta define: #ClassMirror as: (
(Class subclassOf: 'AbstractClassMirror' instanceVariables: 'mixin ')) !


"August 22, 2009 -> 14:24:39"!

Delta define: #ClassMirror as: (
(Class subclassOf: 'AbstractClassMirror' instanceVariables: 'mixin ')) !


"August 22, 2009 -> 14:24:39"!

Delta define: #ClassMirror as: (
(Class subclassOf: 'AbstractClassMirror' instanceVariables: 'mixin ')) !


"August 22, 2009 -> 14:24:39"!

Delta define: #ClassMirror as: (
(Class subclassOf: 'AbstractClassMirror' instanceVariables: 'mixin ')) !


"August 22, 2009 -> 14:24:39"!

Delta define: #ClassMirror as: (
(Class subclassOf: 'AbstractClassMirror' instanceVariables: 'mixin ')) !


"August 22, 2009 -> 14:24:39"!

Delta define: #ClassMirror as: (
(Class subclassOf: 'AbstractClassMirror' instanceVariables: 'mixin ')) !


"August 22, 2009 -> 14:24:39"!

Delta define: #ClassMirror as: (
(Class subclassOf: 'AbstractClassMirror' instanceVariables: 'mixin ')) !


"August 22, 2009 -> 14:24:39"!

Delta define: #ClassMirror as: (
(Class subclassOf: 'AbstractClassMirror' instanceVariables: 'mixin ')) !


"August 22, 2009 -> 14:24:39"!

Delta define: #ClassMirror as: (
(Class subclassOf: 'AbstractClassMirror' instanceVariables: 'mixin ')) !


"August 22, 2009 -> 14:24:39"!

(Delta mirrorFor: #ClassMirror)
comment: 
'This class implements the user-level reflective interface for classes.
Classes are in fact implemented as mixin invocations. When a ClassMirror
is created, it creates a mixin for itself. All changes made to a class are implemented
by asking the mixin to change accordingly.

 (c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"August 22, 2009 -> 14:24:39"!

! (Delta mirrorFor: #ClassMirror) classSide methodsFor: 'Unclassified' !
delta ^ <Instance>
    ^self new initializeDelta! !

"August 22, 2009 -> 14:24:39"!

! (Delta mirrorFor: #ClassMirror) classSide methodsFor: 'Unclassified' !
on: class<Class> ^ <Instance> 

^self new reflect: class ! !

"August 22, 2009 -> 14:24:39"!

! (Delta mirrorFor: #ClassMirror) classSide methodsFor: 'Unclassified' !
sort: cs <Collection[Class]> ^ <OrdCltn[Class]>

^ClassVMMirror sort: cs! !

"August 22, 2009 -> 14:24:39"!

! (Delta mirrorFor: #ClassMirror) classSide methodsFor: 'Unclassified' !
subclassOf: s <Str> instanceVariables: instVars <Str> ^ <Instance>
    ^self new initializeSubclassOf: s instanceVariables: instVars! !

"August 22, 2009 -> 14:24:39"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
abstract
    self mixin abstract! !

"August 22, 2009 -> 14:24:39"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
abstract: a <Boolean>

self mixin abstract: a! !

"August 22, 2009 -> 14:24:39"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
addClassVariable: v  <VarDecl> ifFail: fb <[Str]>

self mixin addClassVariable: v ifFail: fb! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
addInstanceVariable: v  <VarDecl> ifFail:  blk <[Str]>


self mixin addInstanceVariable: v ifFail: blk! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
addMethod: str <Str> visibility: vis  <Symbol> category: cat ifFail: blk <[Str]> ^ <ParseTree>

^self mixin addMethod: str visibility: vis category: cat ifFail: blk! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
addPool: name <Str>  ifFail: fb <Str>

self mixin addPool: name ifFail: fb! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
basicDefinitionString   ^ <Str>
| classVarStr protocolStr classProtocolStr stream first |

classVarStr := self mixin classVariableString.
protocolStr := self mixin supportedProtocolString.
classProtocolStr := self mixin classSide supportedProtocolString.

stream := (String new: 20) writeStream.
self superclass isNil
	ifTrue: [
		stream nextPutAll: '(Class delta)'.
		self mixin instanceVariableString isEmpty ifFalse: [
			stream nextPutAll: ' instanceVariables: '.
			stream nextPutAll: self mixin instanceVariableString asString printString]]
	ifFalse: [
		stream nextPutAll: '(Class subclassOf: '.
		stream nextPutAll: self mixin superclassTypeString asString printString.
		stream nextPutAll: ' instanceVariables: '.
		stream nextPutAll: self mixin instanceVariableString asString printString, ')'].

first := true.
classVarStr isEmpty ifFalse: [
	first ifTrue: [ first := false ] ifFalse: [ stream nextPut: $; ].
	stream nextPutAll: ' classVariables: ', classVarStr asString printString].
protocolStr isEmpty ifFalse: [
	first ifTrue: [ first := false ] ifFalse: [ stream nextPut: $; ].
	stream nextPutAll: ' protocols: ', protocolStr asString printString].
classProtocolStr isEmpty ifFalse: [
	first ifTrue: [ first := false ] ifFalse: [ stream nextPut: $; ].
	stream nextPutAll: ' classProtocols: ', classProtocolStr asString printString].
self isAbstract ifTrue:[
	first ifTrue: [ first := false ] ifFalse: [ stream nextPut: $; ].
	stream nextPutAll: ' abstract'].
self extensionsAreSubtypes ifFalse:[
	first ifTrue: [ first := false ] ifFalse: [ stream nextPut: $; ].
	stream nextPutAll: ' extensionsAreNotSubtypes'].
self isSubtype ifFalse:[
	first ifTrue: [ first := false ] ifFalse: [ stream nextPut: $; ].
	stream nextPutAll: ' notSubtype'].
self isBranded ifFalse:[
	first ifTrue: [ first := false ] ifFalse: [ stream nextPut: $; ].
	stream nextPutAll: ' unbranded'].

^stream contents
! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
basicLocator  ^ <BasicMixinLocator> 
	^self typeInfo basicLocator! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
branded: b <Boolean>

self mixin branded: b.
! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
classProtocols: p  <Str>

self mixin classProtocols: p! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
classVariableString ^ <Str>

^self mixin classVariableString! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
classVariables: cv <Str>

self mixin classVariables: cv! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
classVariablesDo: blk   <[VarDecl]>
    self mixin classVariablesDo: blk! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
comment  ^ <Str> 

	^self sourceInfo comment! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
comment: c  <Str> 

	self sourceInfo comment: c! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
compiledMethodAt: selector <Symbol> ifFail: blk   <[^X def]> ^ <Method | X>

	^self mixin compiledMethodAt: selector ifFail: blk! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
compiledMethodsDo: blk  <[Method]>

	self mixin compiledMethodsDo: blk! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
convert: m <Mirror> ifFail: fb <[Str]>

m convertToClass: self ifFail: fb.



! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
convert: m <Mirror> toGeneric: g   <GenericMirror> ifFail: fb <[Str]>

self assert: [g body = self].
m convertToGenericClass: g ifFail: fb! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
convertToClass: c   <ClassMirror> ifFail: fb <[Str, ^DoesNotMatter]>

	self superclass isNil
		ifFalse: [	self superclass reflectee = c superclass reflectee
								ifFalse: [	| oldsuperclass <AbstractClassMirror> |
													oldsuperclass := self superclass.
													self mixin convertToMixin: c mixin changingClass: self to: c ifFail: fb.
													self typeInfo superclassType: self mixin typeInfo superclassType.
													self classSide typeInfo superclassType: self mixin classSide typeInfo superclassType.
													self superclass sourceInfo changedSubclasses.
													oldsuperclass sourceInfo changedSubclasses.
												]
								ifTrue: 	[	self mixin convertToMixin: c mixin ifFail: fb
												]
						]
! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
convertToGenericClass: g <ProtocolMirror> ifFail: fb <[Str]>

self convertToClass: g body ifFail: fb.
self nestInGenericWithTypeArguments: g typeArgumentString.
self adjustBounds.






! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
convertToGenericProtocol: g <ProtocolMirror> ifFail: fb <[Str]>

fb value: 'Cannot convert a class into a generic protocol'





! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
createTypeStructure

| 
classTypeInfo <MixinInvocationSide> 
classClassTypeInfo <MixinInvocationSide>
classSide <ClassMirror>
|

self isMeta ifTrue:[^self instanceSide createTypeStructure].
self name = #Object ifTrue:[^self createTypeStructureForObject].
classSide := self classSide.
self nonAtomic.
classTypeInfo := Type atClass: self reflectee 
                                             put:  (DeltaMixinInvocationSide new initialize klass: self reflectee).
classClassTypeInfo := Type atClass:  classSide reflectee 
                                                        put: (DeltaMixinInvocationSide new initialize klass: classSide reflectee).
classTypeInfo  dual: classClassTypeInfo.
classClassTypeInfo  dual: classTypeInfo.

classTypeInfo mixinType:  (Type forMixin: self mixin  reflectee).
classClassTypeInfo mixinType:  (Type forMixin:  classSide mixin  reflectee).

" A named class shares its scope with its mixin"
classTypeInfo scope: self mixin scope.
classClassTypeInfo scope:  classSide mixin scope.

"Can we share the superclass type nodes with the mixin?"
classTypeInfo superclassType: (DeltaParser new parseClassOrMixinExpr: self mixin superclassTypeString  
																									within: self scope superScope) body.
classClassTypeInfo superclassType: classTypeInfo superclassType dualClassType.
" (DeltaParser new parseClassOrMixinExpr: classSide mixin superclassTypeString  within: DeltaGlobals) body."! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
createTypeStructureForObject

"Private"
"Special case, when reflectee is Object. Requires special type structure"

| 
classTypeInfo <MixinInvocationSide> 
classClassTypeInfo <MixinInvocationSide>
classSide <ClassMirror>
|


classSide := self classSide.
self nonAtomic.
classTypeInfo := Type atClass: self reflectee 
                                             put:  (DeltaObjectInvocationSide new initialize klass: self reflectee).
classClassTypeInfo := Type atClass:  classSide reflectee 
                                                        put: (DeltaObjectClassInvocationSide new initialize klass: classSide reflectee).
classTypeInfo  dual: classClassTypeInfo.
classClassTypeInfo  dual: classTypeInfo.

" A named class shares its scope with its mixin"
classTypeInfo scope: self mixin scope.
classClassTypeInfo scope:  classSide mixin scope.

classClassTypeInfo mixinType:  (Type forMixin:  classSide mixin  reflectee).

classClassTypeInfo superclassType: (DeltaClassId new setId: #Class; scope: DeltaGlobals).
! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
extensionsAreNotSubtypes
    self mixin extensionsAreNotSubtypes! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
extensionsAreSubtypes ^ <Boolean>

	^self mixin extensionsAreSubtypes! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
extensionsAreSubtypes: e <Boolean>

self mixin extensionsAreSubtypes: e! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
hasSelector: selector <Symbol> ^ <Boolean>

	^self mixin hasSelector: selector! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
initialize

mixin := MixinDeclMirror createNewMixin.! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
initializeDelta
    self initialize! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
initializeSubclassOf: s  <Str> instanceVariables: instVars  <Str>

    self initialize.
    self superclass: s.
    self instanceVariables: instVars! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
installed  ^ <Boolean>
"Private"
^self mixin installed! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
instanceVariableString ^ <Str>

^self mixin instanceVariableString! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
instanceVariables: iv  <Str>

self mixin instanceVariables: iv! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
instanceVariablesDo: blk   <[VarDecl]>
    self mixin instanceVariablesDo: blk! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
isAbstract ^ <Boolean>

	^self mixin isAbstract! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
isBranded ^ <Boolean>

	^self mixin isBranded
! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
isMixinInvocation  ^ <Boolean>

^false! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
isSubtype ^ <Boolean>

	^self mixin isSubtype
! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
komment

"
This class implements the user-level reflective interface for classes.
Classes are in fact implemented as mixin invocations. When a ClassMirror
is created, it creates a mixin for itself. All changes made to a class are implemented
by asking the mixin to change accordingly.
"! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
methodAt: selector <Symbol> ifFail: blk   <[^X def]> ^ <DeltaMethod | X>

^self mixin methodAt: selector ifFail: blk ! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
methodsDo: blk   <[DeltaMethod]>
    self mixin methodsDo: blk! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
methodsFor: category <String>
    ^DefinitionReader for: self category: category
! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
mixin  ^<MixinDeclMirror>

^mixin! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
nameExisting: n <Symbol> ifFail: fb <[Str]>

"This method modifies an existing class named n so that it is equivalent to me"
|  c  <ClassMirror>  |

"self verifyNoCyclesFor: n ifFail: fb."

c :=  Mirror on: (self priorReflecteeFor: n).
c convertToClass: self ifFail: fb.
self reflect: (Delta at: n).



! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
nameNew: n <Symbol> ifFail: fb <[Str]>
"i"
"This method is used to create a new class
named n based upon the source code information in this object.

Here we create the canonical invocation, and install it.
"
| klass <ClassVMMirror> |

self mixin invocations isEmpty ifFalse: [^fb value: 'internal inconsistency'].

klass := MixinDeclMirror createInvocationOf: self mixin named: n superclass: self superclass ifFail: fb.
self mixin setName: n ifFail: fb.
(Type forClass: klass reflectee) superclassType: (Type forMixin: self mixin reflectee) superclassType.
(Type forClass: klass classSide reflectee)  superclassType: (Type forMixin: self mixin classSide reflectee) superclassType.
self reflect: klass reflectee.
Delta at: n put: klass reflectee.
! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
nestInGenericWithTypeArguments: tas  <Str>

self mixin nestInGenericWithTypeArguments: tas.! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
notSubtype
    self mixin notSubtype! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
parseMethod: src <Str> ifFail: blk <[Str,Int]> ^ <ParseTree>

	^self mixin parseMethod: src ifFail: blk
! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
pools: p  <Str>

self mixin pools: p! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
privateMethodsFor: category <String>

	"For compatability"
    ^self methodsFor: category
! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
protocols: p  <Str>

self mixin protocols: p! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
publicMethodsFor: category <String>

	"For compatability"
    ^self methodsFor: category
! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
recompileAllMethodsIfFail: blk <[]>

	self mixin recompileAllMethodsIfFail: blk! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
recompileMethod: selector <Symbol> ifFail: blk <[Str]>

	self mixin recompileMethod: selector ifFail: blk! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
referenceToSelf ^ <DeltaClassId>

^DeltaClassId new 
                 setId: (self nameIfAbsent:[self error: 'Internal flaw: Use of unnamed superclass']);
                 scope: DeltaGlobalScope! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
referencesToAssociation: assoc <Association> ^ <Cltn[MethodLocator]>
	^self mixin referencesToAssociation: assoc! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
reflect: c <Class>

self reflectee: c.
mixin := MixinDeclMirror on: (ClassVMMirror on: c) mixin reflectee.
mixin masterInvocation isNil ifTrue: [self error: 'Internal inconsistency'].
mixin masterInvocation == c ifFalse: [self error: 'Internal inconsistency']." Verify that c is master invocation"

! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
removeClassVariable: name  <Symbol>  ifAbsent: blk  <[]> 
    self mixin removeClassVariable: name ifAbsent: blk! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
removeClassVariable: name  <Symbol>  ifFail: blk  <[Str]> 
    self mixin removeClassVariable: name ifFail: blk! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
removeDefinitionIfFail: blk <[]>

	"Remove entry from system dictionary and source database"
	
	"Forwards to the mixin rather than calling super"
	self isMeta
		ifTrue: [	^blk value: 'Cannot remove on meta side'  ].
	self directSubclasses isEmpty
		ifFalse: [	^blk value: 'Class has subclasses' ].	
	self actualClass flushSubclassHierarchyCache.
	^self mixin removeDefinitionIfFail: blk! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
removeInstanceVariable: name  <Symbol>  ifAbsent: blk  <[]> 
    self mixin removeInstanceVariable: name ifAbsent: blk! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
removeMethod: selector  <Symbol>  ifAbsent: blk  <[]> 
    self mixin removeMethod: selector  ifAbsent: blk! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
rename: oldId <Symbol> to: newId <Symbol>

self mixin rename: oldId to: newId! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
renameGroup: grp <Dict[Symbol, Symbol]> 

self mixin renameGroup: grp! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
scope^ <Scope>

	^self mixin scope
! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
scope: s <Scope>

	self mixin scope: s
! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
selectorsFor: cat <Str> ^ <OrdCltn[Symbol]>

	^self mixin selectorsFor: cat! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
selectorsMatching: pattern <Str> ^ <Set[Symbol]>

	^self mixin selectorsMatching: pattern
! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
sourceForSelector: sel <Symbol>  ^ <Str>

	^self mixin sourceForSelector: sel
! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
sourceInfo ^ <MixinSourceHandler>

	^self mixin sourceInfo! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
subtype ^ <Boolean>

	^self mixin subtype! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
subtype: s <Boolean>

	self mixin subtype: s.
! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
superclass: s  <Str>

	self mixin superclassType: s.
	
	
! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
supportedProtocol: p <Str>

	self mixin supportedProtocol: p! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
supportedProtocolString ^ <Str>

^self mixin supportedProtocolString! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
typeArgumentString ^ <Str>

^self mixin typeArgumentString! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
typeForNode: n <ASTNode> inMethod: m <Method > ^ <ObjectType>

^self mixin typeForNode: n inMethod: m! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
typeNameForNode: n <ASTNode> inMethod: m <Method > ^ <String>

^self mixin typeNameForNode: n inMethod: m! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
unbranded

self mixin unbranded! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
verifyNoCyclesFor: n <Symbol> ifFail: fb <[Symbol, ^DoesNotMatter]>
"Private"
"This method is only called if there already exists an entity with the name 'n' in
the system dictionary (otherwise, there could not be a cycle, since no
subclasses could have been created).
The method is called before my reflectee is actually created and placed in the
SystemDictionary under its name. That is why we start the check with my
superclass.
This code assumes the atomic addition of one class at a time.
"
| cs <VarOrdCltn[Symbol]> |

n = #Object ifTrue:[^self].
cs := OrderedCollection[Symbol] new.
cs add: n.
self superclass isNil ifFalse:[self superclass verifyNoCyclesIn: cs ifFail: fb].
! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'typechecking' !
typecheck

self mixin typecheck! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'typechecking' !
typecheckClassVars

self mixin typecheckClassVars! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'typechecking' !
typecheckDeclaration

self mixin typecheckDeclaration! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'typechecking' !
typecheckInstVars

self mixin typecheckInstVars! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'typechecking' !
typecheckInterface

self mixin typecheckInterface! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'typechecking' !
typecheckSelector: aSymbol <Symbol>

self mixin typecheckSelector: aSymbol! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'typechecking' !
typecheckSelectorInterface: aSymbol <Symbol>

self mixin typecheckSelectorInterface: aSymbol! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'typechecking' !
typecheckSuperclassClause

self mixin typecheckSuperclassClause! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'typechecking' !
typecheckSupportedProtocol

self mixin typecheckSupportedProtocol! !

"August 22, 2009 -> 14:24:40"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'typechecking' !
typecheckTypeArguments

self mixin typecheckTypeArguments! !

"August 22, 2009 -> 14:25:9"!

Delta define: #DeltaParser as: (
(Class subclassOf: 'Object' instanceVariables: 'pseudoVars error scanner <DeltaScanner>  token <Symbol>  topScope <Scope> prevTokenBegin <Int> prevTokenEnd <Int> nodePositions defsAllowed <Boolean> ')) !


"August 22, 2009 -> 14:25:9"!

Delta define: #DeltaParser as: (
(Class subclassOf: 'Object' instanceVariables: 'pseudoVars error scanner <DeltaScanner>  token <Symbol>  topScope <Scope> prevTokenBegin <Int> prevTokenEnd <Int> nodePositions defsAllowed <Boolean> ')) !


"August 22, 2009 -> 14:25:9"!

Delta define: #DeltaParser as: (
(Class subclassOf: 'Object' instanceVariables: 'pseudoVars error scanner <DeltaScanner>  token <Symbol>  topScope <Scope> prevTokenBegin <Int> prevTokenEnd <Int> nodePositions defsAllowed <Boolean> ')) !


"August 22, 2009 -> 14:25:9"!

Delta define: #DeltaParser as: (
(Class subclassOf: 'Object' instanceVariables: 'pseudoVars error scanner <DeltaScanner>  token <Symbol>  topScope <Scope> prevTokenBegin <Int> prevTokenEnd <Int> nodePositions defsAllowed <Boolean> ')) !


"August 22, 2009 -> 14:25:9"!

Delta define: #DeltaParser as: (
(Class subclassOf: 'Object' instanceVariables: 'pseudoVars error scanner <DeltaScanner>  token <Symbol>  topScope <Scope> prevTokenBegin <Int> prevTokenEnd <Int> nodePositions defsAllowed <Boolean> ')) !


"August 22, 2009 -> 14:25:9"!

Delta define: #DeltaParser as: (
(Class subclassOf: 'Object' instanceVariables: 'pseudoVars error scanner <DeltaScanner>  token <Symbol>  topScope <Scope> prevTokenBegin <Int> prevTokenEnd <Int> nodePositions defsAllowed <Boolean> ')) !


"August 22, 2009 -> 14:25:9"!

Delta define: #DeltaParser as: (
(Class subclassOf: 'Object' instanceVariables: 'pseudoVars error scanner <DeltaScanner>  token <Symbol>  topScope <Scope> prevTokenBegin <Int> prevTokenEnd <Int> nodePositions defsAllowed <Boolean> ')) !


"August 22, 2009 -> 14:25:9"!

Delta define: #DeltaParser as: (
(Class subclassOf: 'Object' instanceVariables: 'pseudoVars error scanner <DeltaScanner>  token <Symbol>  topScope <Scope> prevTokenBegin <Int> prevTokenEnd <Int> nodePositions defsAllowed <Boolean> ')) !


"August 22, 2009 -> 14:25:9"!

Delta define: #DeltaParser as: (
(Class subclassOf: 'Object' instanceVariables: 'pseudoVars error scanner <DeltaScanner>  token <Symbol>  topScope <Scope> prevTokenBegin <Int> prevTokenEnd <Int> nodePositions defsAllowed <Boolean> ')) !


"August 22, 2009 -> 14:25:9"!

Delta define: #DeltaParser as: (
(Class subclassOf: 'Object' instanceVariables: 'pseudoVars error scanner <DeltaScanner>  token <Symbol>  topScope <Scope> prevTokenBegin <Int> prevTokenEnd <Int> nodePositions defsAllowed <Boolean> ')) !


"August 22, 2009 -> 14:25:9"!

Delta define: #DeltaParser as: (
(Class subclassOf: 'Object' instanceVariables: 'pseudoVars error scanner <DeltaScanner>  token <Symbol>  topScope <Scope> prevTokenBegin <Int> prevTokenEnd <Int> nodePositions defsAllowed <Boolean> ')) !


"August 22, 2009 -> 14:25:9"!

(Delta mirrorFor: #DeltaParser)
comment: 
'The Strongtalk parser.
 (c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
array ^ <VarOrdCltn[DeltaLiteral]>
    | a <VarOrdCltn[DeltaLiteral]>  |

    self check: #lparen.
    a := OrderedCollection[DeltaLiteral]  new.
    [(token ~= #rparen) and: [token ~= #eos]] whileTrue: [
        a add: (self literal: false)
    ].
    self check: #rparen.
    ^ a! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
assignment ^ <DeltaAssignment>
    |
    maybeVar <DeltaVariable | DeltaLiteral> 
    var <DeltaVariable> 
    expr <Expression> 
    |
    maybeVar := self variable.
    self check: #becomes.
    expr := self expression.
    ^ maybeVar isRefNode
        ifTrue: [
            var := guaranteed <DeltaRef>  maybeVar.
            (var decl isParameterNode)
                ifTrue: [self error: 'variable must not be a parameter'.]
                ifFalse: [self node: (DeltaAssignment new to: var assign: expr) beginNode: var endNode: expr]
        ]
        ifFalse: [self error: 'left-hand must be a variable'.]! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
binaryClassOrMixin

| expr sel |

expr := self unaryClassOrMixin.
   [self binaryClassOrMixinSel] 
      whileTrue: [
                            sel := self get: #binarySel.
                            expr := sel = #* ifTrue:[self node:(DeltaMixinCompositionNode new inputMixin: expr outputMixin: self unaryClassOrMixin) begin: 0 end: 0]
                                                          ifFalse:[sel = #|> ifTrue:[self node:(DeltaMixinInvocationNode new mix: expr on: self unaryClassOrMixin) begin: 0 end: 0]
                                                                                           ifFalse:[self node:(DeltaMixinInvocationNode new mix: self unaryClassOrMixin on: expr) begin: 0 end: 0]
                                                                        ]
                            ].

^expr
       ! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
binaryClassOrMixinSel ^ <Boolean>

| tokenVal |

tokenVal := scanner tokenVal.
^token = #binarySel and:[tokenVal = #* or:[tokenVal = '|>' asSymbol or: [tokenVal = '<|' asSymbol]]].
! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
binaryExpr ^ <Expression>
    | expr <Expression>  msg <Message>  |
    expr := self unaryExpr.
    [self binarySel] whileTrue: [
	   msg := self binaryMsg.
        expr := self node: (DeltaNormalSend new to: expr send: msg) beginNode: expr endNode: msg
    ].
    ^ expr! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
binaryMsg ^ <DeltaMessage>
    |
    sel <Symbol> 
    args <VarOrdCltn[Expression]> 
    start <Int> 
    |
    self assert: [self binarySel].
    sel := scanner tokenVal.
    start := scanner tokenBeg.
    self nextToken.
    args := OrderedCollection[Expression]  new.
    args add: self unaryExpr.
    ^self node: (DeltaMessage new send: sel with: args) begin: start endNode: args last
! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
binaryMsgSequence ^ <OrdCltn[DeltaMessage]>
    | msgs <VarOrdCltn[DeltaMessage]>  |

msgs := OrderedCollection[DeltaMessage]  new.
msgs addFirst: self binaryMsg.
[self binarySel] whileTrue:[msgs addLast: self binaryMsg.].
token = #keyword ifTrue:[msgs addLast: self keywordMsg].
^msgs! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
binarySel ^ <Boolean>
    ^ (((((token = #binarySel) or: [token = #less]) or: [token = #greater]) or: [token = #vbar]) or: [token = #comma]) or: [token = #slash]! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
block ^ <DeltaBlock>
    |
    pars
    blk  <DeltaBlock> 
    start <Int> 
    |
    self check: #lbracket.
    start := prevTokenBegin.
    self openCodeScope.

    pars := OrderedCollection new.
    token = #colon ifTrue: [self parameters: pars].

    blk := DeltaBlock new body: (self body: pars).
    self closeScope.
    self check: #rbracket.
    ^self node: blk begin: start end: prevTokenEnd! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
blockType ^ <DeltaBlockApplicationType>
    |
    tas <VarOrdCltn[ObjectType]> 
    start <Int> 
    tid <DeltaTypeId> 
    |
    self check: #lbracket.
    start := prevTokenEnd.
    tid := self node: (DeltaTypeId new setId: #Fun; scope: DeltaGlobals) begin: start end: start.
    tas := token  == #rbracket ifFalse:[self blockTypeArgList]
                                                       ifTrue:[self defaultBlockTypeArgList].
    self check: #rbracket.
    ^self node: (DeltaBlockApplicationType new apply: tid  to: tas) begin: start end: prevTokenEnd! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
blockTypeArgList ^ <VarOrdCltn[ObjectType]>
    |
    tas <VarOrdCltn[ObjectType]> 
    first <ObjectType> 
    |
    tas := OrderedCollection[ObjectType]  new.
    token = #arrow
        ifTrue: [
            self nextToken.
            tas addLast: self typeExpr.
        ]
    ifFalse: [
        first :=  self typeExpr.
        tas :=
            token = #comma
                ifTrue: [self nextToken. self blockTypeArgList]
                ifFalse: [self defaultBlockTypeArgList].
        tas addFirst: first.
    ].
    ^ tas.! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
blockTypeArguments ^ <OrdCltn[ObjectType]>
    | tas <VarOrdCltn[ObjectType]>  |

    self check: #lbracket.
    tas := self blockTypeArgList.
    self check: #rbracket.
    ^tas! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
body: pars ^ <DeltaCodeBody>
    |
    temps <OrdCltn[Statement]> 
    stats <OrdCltn[Statement]> 
    codeBody <DeltaCodeBody> 
    |

    temps := OrderedCollection new.
    token = #vbar ifTrue: [self temporaries: temps].

    stats := OrderedCollection new.
    (token ~= #eos) & (token ~= #rbracket) ifTrue: [self statements: stats].

    topScope parameters: pars.
    topScope temporaries: temps.

    codeBody :=
        DeltaCodeBody new
            parameters: pars
            temporaries: temps
            statements: stats
            scope: topScope.

    stats isEmpty
        ifTrue: [^self node: codeBody begin: prevTokenEnd end: prevTokenEnd]
        ifFalse: [^self node: codeBody beginNode: stats first endNode: stats last]
! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
classOrMixin

^self binaryClassOrMixin! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
defaultBlockTypeArgList  ^ <VarOrdCltn[ObjectType]> 

^OrderedCollection[ObjectType] new
   addLast: (self node: (DeltaTypeId new setId: #Object; scope: topScope) 
                               begin: prevTokenBegin 
		                     end: prevTokenBegin);
   yourself! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
dllCall ^ <DLLCall>
    |
    start <Int> 
    dllName <Symbol> 
    proxy <DeltaVariable | DeltaLiteral> 
    functionName <Symbol> 
	async
    msg <Message> 
    |
    start := scanner tokenBeg.
    self check: #less.
    dllName := self get: #identifier.
    proxy := self variable.
    functionName := self get: #identifier.
	async :=
		(token = #identifier and: [ scanner tokenVal = #async ])
			ifTrue: [ self nextToken. true ]
			ifFalse: [ false ].
    self check: #greater.
    msg := self message.
    ^self node: (DeltaDLLCall new to: dllName send: msg called: functionName return: proxy async: async) begin: start endNode: msg
! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
expr ^ <Expression>
    |
    primary <Expression> 
    sends <OrdCltn[OrdCltn[DeltaMessage]]> 
    exp <Expression> 
    initialSend <DeltaSend> 
    |
    (token = #identifier and: [scanner tokenVal = #super])
        ifTrue: [
            primary := self super.
            sends := self send.
        ]
        ifFalse: [
            (token = #identifier and: [scanner tokenVal = #guaranteed])
                ifTrue: [
                    primary := self guaranteed.
                    sends := OrderedCollection[OrdCltn[DeltaMessage]]  new
                ]
                ifFalse: [
                    primary := self primary.
                    sends :=
                        (token = #identifier or: [self binarySel or: [token = #keyword]])
                            ifTrue: [self send]
                            ifFalse: [OrderedCollection[OrdCltn[DeltaMessage]]  new]
                     ]
        ].

    exp :=
        sends isEmpty
            ifTrue: [primary]
            ifFalse: [
                 sends first
                    inject: primary
                    into: [ :target <Expression>  :msg <DeltaMessage>  |
                        initialSend :=
                            self node: (DeltaNormalSend new to: target send: msg) beginNode: target endNode: msg
                    ].
                sends last
                    inject: initialSend
                    into: [ :target <DeltaSend>  :msg <DeltaMessage>  |
                        self node: (DeltaCascadedSend new to: target cascade: msg) beginNode: target endNode: msg 
                    ]
            ].

    ^ exp! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
expression ^ <Expression>
    ^ scanner copy token = #becomes
        ifTrue: [self assignment]
        ifFalse: [self expr]! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
genericTypeArgument  ^ <DeltaTypeFormal>

"
GenericTypeArgumentClause  -> ((Id [Variance]) | Id) [TypeParamConstraint]
"

 |
 tv <DeltaTypeVar>
 tf <DeltaTypeFormal>
 start <Integer>
 tid <Symbol>
 tpc <TypeParamConstraint> 
 variance <Symbol>
 |

start := scanner tokenBeg.
variance := #unrelated.
token = #lparen
  ifTrue:[
               self get: #lparen.
               tid :=  self get: #identifier.
               variance := self variance.
               self check: #rparen.
               ]
  ifFalse:[tid :=  self get: #identifier].

token = #less
     ifTrue:[tpc := self typeParamConstraint.]
     ifFalse:[tpc := Association 
								key:#subtypeOf: 
								value: (self node: (DeltaTypeId new setId: #Object; scope: DeltaGlobals) begin: prevTokenBegin end: prevTokenBegin)
                    ].

tv := self node: (DeltaTypeVar new name: tid bound: tpc value; subtype: tpc key = #subtypeOf:) begin: start endNode: tpc value.

^self node: (DeltaTypeFormal new variance: variance typeVar: tv) begin: start endNode: tv
! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
guaranteed ^ <DeltaGuaranteed>
    |
    guarantee < DeltaGuaranteed > 
    start < Integer > 
    |

    (token = #identifier and: [scanner tokenVal = #guaranteed])
        ifTrue: [
            start := scanner tokenBeg.
            self nextToken.
            guarantee := self node: (DeltaGuaranteed new type: self type expr: self primary) begin: start end: prevTokenEnd
        ]
        ifFalse: [self error:' ''guaranteed'' expected'].

    ^ guarantee.! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
ifUnary: unaryBlock <[^Object] >ifBinary: binaryBlock <[^Object] >ifKeyword: keywordBlock <[^Object] >else: elseBlock <[^Object] > ^ <Self>
    token = #identifier ifTrue: [^ unaryBlock value].
    self binarySel ifTrue: [^ binaryBlock value].
    token = #keyword ifTrue: [^ keywordBlock value].
    ^ elseBlock value! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
inferenceClause ^ <ObjectTypeInferenceClause>
    |
argIndex <Int> 
id <Symbol> 
clause <ObjectTypeInferenceClause> 
start <Int> 
target <InferenceClause> 
 |

start := self scanner tokenBeg.
id := self get: #identifier.
(id = #returnType)
  ifTrue:[
            clause := self returnTypeInferenceClause
            ]
  ifFalse:[id = #arg
                ifTrue:[
                         token = #number ifFalse:[self error: 'integer expected'].
                         argIndex := scanner tokenVal.
                         self nextToken.
                         token = #identifier ifTrue:[target := self inferenceClauseTail].
                         clause := self node: (DeltaArgTypeSelection new target: target arg: argIndex) begin: start end: prevTokenEnd
                         ]
    ifFalse:[id = #typeArg ifTrue:[clause := self typeArgInferenceClause]
	ifFalse:[id = #receiverType ifFalse:[self error: ' ''returnType'', ''arg'' or ''receiverType'' expected']
                                           ifTrue:[clause := self node: (DeltaReceiverTypeSelection new) begin: start end: prevTokenEnd]]]].
^clause! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
inferenceClauseTail ^ <MsgSignatureInferenceClause>
    |
    id <Symbol> 
    clause <MsgSignatureInferenceClause> 
    |
    self scanner tokenBeg.
    id := self get: #identifier.
    id = #of
        ifTrue: [clause := self msgSelector]
        ifFalse: [self error: ' ''of'' expected'].
    ^ clause.! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
keywordMsg ^ <DeltaMessage>
    | sel <Str>  args <VarOrdCltn[Expression]>  start <Int>  |
    token = #keyword ifFalse: [self error: 'keyword expected'].
    start := scanner tokenBeg.
    sel := ''.
    args := OrderedCollection[Expression]  new.
    [token = #keyword] whileTrue: [
        sel := sel, scanner tokenVal asString.
        self nextToken.
        args add: self binaryExpr
    ].
    ^self node: (DeltaMessage new send: sel asSymbol with: args) begin: start end: prevTokenEnd! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
literal: withHash <Boolean > ^ <DeltaLiteral>
    token = #number ifTrue: [^ self literalNumber].
    token = #character ifTrue: [^ self literalChar].
    token = #string ifTrue: [^ self literalString].
    token = #lbrace ifTrue:[^ self tuple].
    withHash ifTrue: [
        token = #hash
            ifTrue: [self nextToken]
            ifFalse: [self error: 'Primary expected']
        ].
    ^ token = #lparen
        ifTrue: [self literalArray]
        ifFalse: [self literalSymbol]! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
literalArray ^ <DeltaArray>
    |
    start <Int> 
    val <Symbol> 
    |
    start := scanner tokenBeg.
    val := self array.
    "self nextToken."
    ^self node: (DeltaArray new value: val) begin: start end: prevTokenEnd! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
literalChar ^ <DeltaChar>
    | start <Int>   val <Symbol>  |

    start := scanner tokenBeg.
    val := scanner tokenVal.
    self nextToken.
    ^self node: (DeltaChar new value: val) begin: start end: prevTokenEnd! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
literalNumber ^ <Self>
    | start <Int>  val <Object>  constructor <DeltaLiteral class>  |
    start := scanner tokenBeg.
    val := scanner tokenVal.
    self nextToken.
      constructor :=
        (val isKindOf: SmallInteger)
              ifTrue: [DeltaSmallInt]
              ifFalse:[(val isKindOf: Integer) ifTrue: [DeltaInt]
              ifFalse: [(val isKindOf: Float) ifTrue: [DeltaFloat]
              ifFalse: [self error: 'Number scanned is not a number']]].
    ^self node: (constructor new value: val) begin: start end: prevTokenEnd.! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
literalString ^ <DeltaString>
    | start <Int>  val <Symbol>  |

start := scanner tokenBeg.
val := scanner tokenVal.
self nextToken.
 ^self node: (DeltaString new value: val) begin: start end: prevTokenEnd! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
literalSymbol ^ <DeltaSymbol>
    | start <Int>  val <Symbol>  |

start := scanner tokenBeg.
val := self symbol.
 ^self node: (DeltaSymbol new value: val) begin: start end: prevTokenEnd! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
message ^ <DeltaMessage>
    ^ self
        ifUnary: [self unaryMsg]
        ifBinary: [self binaryMsg]
        ifKeyword: [self keywordMsg]
        else: [self error: 'Msg expected'].! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
messagePattern  ^ <MsgSignature>
    |
    pars  <OrdCltn[DeltaParameter]>
    pattern <DeltaMessagePattern> 
    |

    self openNonCodeScope.
    pars := OrderedCollection new.
    pattern := self msgPattern: pars isMessage: true.
    self closeScope.
    ^ pattern! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
method  ^ <DeltaMethod>
    |
    pars <OrdCltn[DeltaParameter]>
    pattern <DeltaMessagePattern> 
    method <DeltaMethod> 
    copiedPars  <OrdCltn[DeltaParameter]>
    |

    self openNonCodeScope. 
 " method header must not reference scope of method body"
    pars := OrderedCollection [DeltaParameter]new.
    pattern := self msgPattern: pars.
"header done, open code scope for method body"
    self openCodeScope.
    self deltaHack.
    self declare: (DeltaReceiver new name: #self type: (topScope at: #self) type).
   "#self must be present in method scope because from the compilers viewpoint
     it is not imported from an outer scope, so we duplicate the declaration."
  "For the same reason, we duplicate the parameters.
   Both these hacks will go away when the CodeScopes are factored out of the
   AST"
   copiedPars := OrderedCollection  [DeltaParameter] new.
   pars do: [: p <DeltaParameter> | 
                   self declare: (p class new  name: p name type: p type).
                   copiedPars add: (topScope at: p name).
                   ].
    method :=
        DeltaMethod new
            selector: pattern selector
            type: pattern type
            visibility: #public
            body: (self body: copiedPars).
    self closeScope.
    self check: #eos.
    ^self node: method begin: 1 end: scanner source size + 1! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
methodSignature  ^ <MsgSignature>
    |
    pars  <OrdCltn[DeltaParameter]>
    pattern <DeltaMessagePattern> 
    |

    self openNonCodeScope.
    pars := OrderedCollection new.
    pattern := self msgPattern: pars.
    self closeScope.
    ^ pattern type! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
mixinExpr 

! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
msgDeclaration

^self msgPattern:  OrderedCollection[DeltaParameter] new isMessage: true.
! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
msgPattern: pars <OrdCltn[DeltaParameter]>  ^ <DeltaMessagePattern>
"This message parses a message pattern - the header of a
Strongtalk method,  or a message declaration"

^self msgPattern: pars isMessage: false.! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
msgPattern: pars  <OrdCltn[DeltaParameter]> isMessage: isMsg <Boolean>  ^ <DeltaMessagePattern>
"This message parses a message pattern - the header of a
Strongtalk method,  or a message declaration"
    |
    sel <Str> 
    decl
    domain <VarOrdCltn[ObjectType]> 
    range <ObjectType> 
    type <DeltaMsgSignature> 
    tPat <OrdCltn[InferredTypeVar]> 
    msgPat <DeltaMessagePattern> 
    start <Int>  
    hasType <Boolean>  
    formals <OrdCltn[TypeFormal]> 
    variableDeclParser <[DeltaVar class]>
    msgSigConstructor <MsgSignature class>
    polyMsgSigConstructor <PolyMsgSignature class>
    inferenceTool <InferenceSugarTool>
    |

    isMsg ifTrue:[
                             variableDeclParser :=  [:dp <DeltaVar class> | self variableDeclForMsgDeclOf: dp parameters: pars].
                             msgSigConstructor := DeltaProtocolMsgSignature.
                             polyMsgSigConstructor := DeltaPolyProtocolMsgSignature.
                             ]
               ifFalse:[
                             variableDeclParser := [:dp <DeltaVar class> | self variableDecl: dp].
                             msgSigConstructor := DeltaMsgSignature.
                             polyMsgSigConstructor := DeltaPolyMsgSignature.
                              ].
    start := scanner tokenBeg.
"We assume initially that no explicit return type will be given"
    hasType := false.
" The header may contain 'def clauses' - references to type arguments
that should be automatically defined. The syntax for these is only
acceptable in certain contexts,  so here we explicitly set the necessary
flag so that such defs are acceptable."
    self defsAllowed: true.
"The first (and possibly only) part of a message pattern is a
selector, with value argument declarations. We parse this.
We use the block variableDeclParser to parse the formal arguments
and later check to see if a type argument pattern follows."
    domain := OrderedCollection[ObjectType]  new.
    self
        ifUnary: [
            sel := scanner tokenVal.
            self nextToken.
        ]
        ifBinary: [
            sel := scanner tokenVal.
            self nextToken.
            decl := variableDeclParser value: DeltaParameter.
            pars add: decl.
            domain add: decl declaredType.
        ]
        ifKeyword: [
            sel := ''.
            [token = #keyword] whileTrue: [
                sel := sel, scanner tokenVal asString.
                self nextToken.
                decl := variableDeclParser value: DeltaParameter.
                pars add: decl.
                domain add: decl declaredType.
            ]
        ]
        else: [self error: 'MsgPattern expected'].

"Having parsed the first part of the message pattern, we must
disallow further 'def clauses'"
    self defsAllowed: false.
"Now we check to see if a return type is explicitly declared.
We must see a '^' followed by a '<' marking the beginning of a type.
Otherwise, the '^' might be a return expression in a method body.
"
    ((token = #arrow) and: [scanner copy token = #less])
        ifTrue: [
            "accept ^ only if followed by a type."
			hasType := true. "note that an explicit return type was provided"
            self nextToken.
            range := self type.
        ]
        ifFalse: [
            range := self node: (DeltaTypeId new setId: #Self; scope: topScope) begin: prevTokenEnd end: prevTokenEnd "Self"
        ].

"Initially, we create a message signature node for the pattern just parsed"
    type := self
		node: (msgSigConstructor new domain: domain range: range)
		beginNode: (domain isEmpty ifTrue: [range] ifFalse: [domain first])
		endNode: range.

 "At this point,  we must determine whether any formal type arguments were
introduced by means of 'def clauses'. 
We use InferenceSugarTool to process type and collect such formals.
If there are none, formals will be set to an empty collection."

    inferenceTool :=
		DeltaInferenceSugarTool
			topScope: self topScope 
			errorBlock:
				[ :n <ASTNode> :s <Str> |
					error value:s value: (self nodeBeginFor: n)
				].
	type apply: inferenceTool.
	formals := inferenceTool formals.

"Explicitly declared formals may now follow. This is marked by the use '{{'.
These formals are parsed using the typePattern routine, and added to formals."
(token = #lbrace and: [scanner copy token ~= #lbrace])
         ifTrue: [
	     hasType := true.
             tPat := self typePattern.
             tPat do:[:tf <InferredTypeVar> | formals add: tf]].

"If any formal type arguments were declared, either using 'def clauses' or
explicitly or both, they will be stored in formals.  If formals is empty, we are
sure that there are none. If there are formals, the type of the message/method
must be a PolyMsgSignature, using the  formals defined, whose body is the
msg signature created earlier. Otherwise, the type created previously is
the type of the method/message.
"
     formals isEmpty ifFalse: [
             type := self
				node: (polyMsgSigConstructor new formals: formals body: type)
				beginNode: type
				endNode: (tPat isNil ifTrue: [type] ifFalse: [tPat last])
            ].

  isMsg ifTrue:[ type selector: sel asSymbol ].
  
"At this point, type is set correctly to be the type of the method/message, and the
pattern as a whole can be represented by a node using the parsed selector and type."
	msgPat := DeltaMessagePattern new selector: sel asSymbol type: type.

"?"
	^hasType
		ifTrue: [self node: msgPat begin: start endNode: type]
		ifFalse: [self node: msgPat begin: start end: prevTokenEnd]! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
msgSelector ^ <MsgSignatureInferenceClause>
    |
    id <Symbol> 
    sel <Symbol> 
    start <Int> 
    |

    start := self scanner tokenBeg.
    sel := self symbolLiteral.
    id := self get: #identifier.
    id = #message ifFalse:[^self error: '''message'' expected'].
    id := self get: #identifier.
    id = #of ifFalse:[^self error: '''of'' expected'].
    ^self 
		node: (DeltaMsgTypeSelection new target: self inferenceClause selector: sel) 
		begin: start 
		end: prevTokenEnd! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
msgSequence ^ <OrdCltn[DeltaMessage]>
    | seq <OrdCltn[DeltaMessage]>  |

    ^ token = #identifier
        ifTrue: [self  unaryMsgSequence]
        ifFalse: [
            self binarySel
                ifTrue: [self binaryMsgSequence]
                ifFalse: [OrderedCollection[DeltaMessage]  new add: self keywordMsg; yourself]
        ]! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
optionalTypeExpr ^ <TypeExpr>

^(token = #identifier or:[token = #lbracket or:[token = #lparen]]) 
	 ifTrue:[self typeExpr]
	 ifFalse:[DeltaNoTypeSpecifiedError new]! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
parameters: pars  ^ <Self>
    | start <Int>   |

    [token = #colon] whileTrue: [
        start := scanner tokenBeg.
        self nextToken.
        pars add: (self variableDecl: DeltaParameter).
    ].
    self check: #vbar! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
parseTreeFor: node <ASTNode>  ^ <ParseTree>

	^DeltaParseTree new 
			body: node 
			source: self scanner source
			nodePositions: nodePositions 
			commentPositions: 
			self scanner commentPositions
			
	
! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
primary ^ <Expression>
    | expr <Expression>  tas <OrdCltn[ObjectType]>  varNode <DeltaRef | DeltaLiteral>  idNode <DeltaVariable>  |
    token = #identifier
        ifTrue: [
                  expr := varNode := self variable.
                  token = #lbracket
                    ifTrue: [
                               varNode isRefNode ifTrue:[idNode := guaranteed <DeltaVariable>  varNode.

                              tas := self typeArguments.
                               expr := self
							node: (DeltaGenericApplicationExpression new apply: idNode to: tas)
							beginNode: idNode
							end: prevTokenEnd
                               ]]
        ]
        ifFalse: [
            token = #lparen
                ifTrue: [
                    self nextToken.
                    expr := self expression.
                    self check: #rparen
                ]
                ifFalse: [
                    token = #lbracket
                        ifTrue: [expr := self block]
                        ifFalse: [
                            token = #dlbrace
                                ifTrue: [expr := self primitive]
                                ifFalse: [expr := self literal: true]
                        ]
                ]
        ].
    ^ expr! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
primaryClassOrMixin ^ <ClassOrMixin>

| 
name <Symbol>  
tid <DeltaTypeId> 
tas <OrdCltn[ObjectType]>  
start <Int>   
constructor <GenericApplicationType class>  
tf <GenericApplicationType>  
cm <ClassOrMixin> 
|


   token = #lparen 
           ifTrue:[
                        self nextToken.
                        cm := self classOrMixin.
                        self check: #rparen.
                        ^cm
                        ].
    name := guaranteed <Symbol>  ( self get: #identifier).
    tf := tid := self node:(DeltaClassId new setId: name asSymbol;
                                       scope: topScope) 
                                       begin: (start := prevTokenBegin)
                                       end: prevTokenEnd .
    token = #lbracket
      ifTrue: [
                   constructor := DeltaGenericApplicationClassType.
                   tas := self typeArguments.
 
                   tf := self node: (constructor new apply: tid  to: tas)
                                                   begin: start
                                                   end: prevTokenEnd.
                   ].
    ^tf.
! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
primitive ^ <DeltaPrimitive|DeltaDLLCall>
    |  call <DeltaPrimitive | DeltaDLLCall>  |
    self check: #dlbrace.
    call :=
        token = #less
           ifTrue: [self dllCall]
           ifFalse: [self primitiveCall].
    self check: #drbrace.
    ^ call! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
primitiveCall ^ <DeltaPrimitive>
    | start <Int>  recv <DeltaVariable>  msg <Message>  |
    start := scanner tokenBeg.
    ((token = #identifier) and: [scanner tokenVal == #self])
        ifTrue: [recv := guaranteed <DeltaVariable>  (self variable)]
        ifFalse: [recv := nil].
    msg := self message.
    ^self node: (DeltaPrimitive new to: recv send: msg) begin: start endNode: msg
! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
returnTypeInferenceClause ^ <DeltaReturnTypeSelection>
    |  target <InferenceClause>  clause <DeltaReturnTypeSelection>  start <Int>  |

start := prevTokenBegin.
              (token = #identifier and:[
              scanner tokenVal = #of]) ifFalse:[self error: '''of'' expected'.].
self nextToken.
target :=self msgSelector.
clause := self node: (DeltaReturnTypeSelection new target: target) begin: start endNode: target.
^clause.! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
send ^ <OrdCltn[OrdCltn[DeltaMessage]]>
    | msgs < VarOrdCltn[OrdCltn[DeltaMessage]]>  cascadedMsgs <VarOrdCltn[DeltaMessage]>  |

    msgs := OrderedCollection[OrdCltn[DeltaMessage]]  new.
    cascadedMsgs := OrderedCollection[DeltaMessage]  new.
    msgs addFirst: self msgSequence.
    [token = #semicolon] whileTrue: [
        self nextToken.
        cascadedMsgs addLast: self message
    ].
    msgs addLast: cascadedMsgs.
   ^msgs.! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
statement ^ <Statement>
    | stat <Statement>  start <Int>  |
        ^token = #arrow
        ifTrue: [
            start := scanner tokenBeg.
            self nextToken.
            topScope doesReturn.
            self node: (DeltaReturnStat new return: self expression; scope: topScope) begin: start end: prevTokenEnd
        ]
        ifFalse: [self expression]! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
statements: stats  ^ <OrdCltn[Statement]>
    |
    t <Symbol> 
    |
    stats add: self statement.
    [(token = #period) and: [((t := scanner copy token) ~= #rbracket) and: [t ~= #eos]]] whileTrue: [
        self check: #period.
        stats add: self statement
    ].
    token = #period ifTrue: [self nextToken]! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
super
    | s "<DeltaVariable>" |

    topScope accessSelf.
    s := self node: (DeltaRef new decl: (topScope at: #super)) begin: scanner tokenBeg end: scanner tokenEnd.
    self  get: #identifier.
    ^ s! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
symbol ^ <Symbol>
    | sym <Symbol>   pos <Int>  |
    self
        ifUnary: [sym := scanner tokenVal. self nextToken]
        ifBinary: [sym := scanner tokenVal. self nextToken]
        ifKeyword: [
            sym := '' asSymbol.
            pos := scanner tokenBeg.
            [(token = #keyword) and: [pos = scanner tokenBeg]] whileTrue: [
                sym := sym, scanner tokenVal asString.
                pos := scanner tokenEnd.
                self nextToken
            ].
            sym := sym asSymbol
        ]
        else: [
            token = #string
                ifTrue: [sym := scanner tokenVal asSymbol. self nextToken]
                ifFalse: [self error: 'symbol expected']
        ].
    ^ sym! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
symbolLiteral ^ <Symbol>
    self check: #hash.
    ^ self symbol.! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
temporaries: temps  ^ <Self>
    self check: #vbar.
    [token = #identifier] whileTrue: [
        temps add: (self variableDecl: DeltaTemporary)
    ].
    self check: #vbar
! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
tuple ^ <DeltaTuple>
    | a <VarOrdCltn[Expression]>  start <Integer> |

    start := scanner tokenBeg.
    self check: #lbrace.
    a := OrderedCollection[Expression]  new.
    ((token ~= #rbrace) and: [token ~= #eos]) ifTrue: [a add: self expr].
    [(token ~= #rbrace) and: [token ~= #eos]] whileTrue: [
        self check: #period.
        (token ~= #rbrace) ifTrue:[a add: self expr].
    ].
    self check: #rbrace.
     ^self node: (DeltaTuple new value: a) begin: start end: prevTokenEnd! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
type ^ <TypeExpr>
    | type <TypeExpr>  |

    self check: #less.
    type := self typeExpr.
    self check: #greater.
    ^type! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
typeArgInferenceClause ^ <ObjectTypeInferenceClause>
"TypeArgInferenceClause = typeArg int for generic SymbolLiteral of InferenceClause"

| typeArgIndex <Integer> id <Symbol> gid <Symbol> start <Int> |

start :=  prevTokenBegin.
token = #number ifFalse:[self error: 'integer expected'].
typeArgIndex := scanner tokenVal.
self nextToken.
id := self get: #identifier.
id = #for ifFalse:[self error: '''for'' expected'].
id := self get: #identifier.
id = #generic ifFalse:[self error: '''generic'' expected'].
gid := self symbolLiteral.
id := self get: #identifier.
id = #of ifFalse:[^self error: '''of'' expected'].

^self 	node: (GenericFormalInferenceClause 	target: self inferenceClause
																	arg: typeArgIndex
																	id: gid)
			begin: start  end: prevTokenEnd
! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
typeArguments ^ <OrdCltn[ObjectType]>
    | tas <VarOrdCltn[ObjectType]>  |

    self check: #lbracket.
    tas := OrderedCollection[ObjectType]  new.
    tas addFirst: self typeExpr.
    [token = #comma] whileTrue: [
        self nextToken.
        tas addLast: self typeExpr.
    ].
    self check: #rbracket.
    ^tas! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
typeBoundQualifier ^ <Symbol>
    | id <Str>  |

"TypeBoundQualifier = 'subtypeOf:' | 'inheritedTypeOf:'"

id := self get: #keyword.
(id = #subtypeOf:) ifTrue:[^ id].
(id = #inheritedTypeOf:) ifFalse:[self error: '''subtypeOf:'' or ''inheritedTypeOf:'' expected'].
"id := self get: #identifier.
id = #types ifFalse:[self error: '''types'' expected']."
^#inheritedTypeOf:! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
typeExpr ^ <TypeExpr>
    |
constructor <DeltaUnionType class | DeltaProtocolMerge class | DeltaProtocolOverride class> 
te <TypeExpr> 
t2 <TypeTerm> 
	|

    te := self typeTerm.
    [(token = #vbar) | (token = #semicolon) | (token = #slash)]
      whileTrue: [
                       constructor := self constructorFor: token.
                       self nextToken.
                       t2 :=   self typeTerm.
                       te := self node: (constructor new type1: te type2: t2) beginNode: te endNode: t2
                       ].
    ^te! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
typeFactor ^ <TypeFactor>
    | name <Symbol>  tid <DeltaTypeId>  tas <OrdCltn[ObjectType]>  start <Int>   constructor <GenericApplicationType class>  tf <GenericApplicationType>  |

    token = #lbracket ifTrue:[^self blockType].
    token = #lparen ifTrue:[
        self nextToken.
            tf := self typeExpr.
            self check: #rparen.
            ^tf.
             ].
    name := guaranteed <Symbol>  ( self get: #identifier).
    tf := tid := self 
		node: (DeltaTypeId new setId: name asSymbol; scope: topScope)
		begin: prevTokenBegin
		end: prevTokenEnd.
    token = #lbracket
      ifTrue: [
                 constructor := DeltaGenericApplicationType.
                 tas := tid name asSymbol = #Fun
                             ifFalse:[
                                       tid name asSymbol = #Tuple 
                                               ifTrue:[constructor := DeltaTupleType]
                                               ifFalse:[tid name asSymbol = #VarTuple ifTrue:[constructor := DeltaVarTupleType]].
                                       self typeArguments]
                             ifTrue:[
                                       constructor := DeltaBlockApplicationType.
                                       self blockTypeArguments
                                       ].
                 tf := self node: (constructor new apply: tid to: tas) beginNode: tid end: prevTokenEnd.
                 ].
    ^tf.! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
typeFormalDecl ^ <InferredTypeVar>
    |  tid <Symbol>  id <Symbol>   tpc <TypeParamConstraint>  ic <InferenceClause>   |

id := self get: #identifier.
id = #where
  ifTrue:[
            tid := id := self get: #identifier.
            token = #less
                ifTrue:[tpc := self typeParamConstraint.]
                ifFalse:[tpc := Association key:#subtypeOf: value:(self node: (DeltaTypeId new setId: #Object; scope: DeltaGlobals) begin: prevTokenBegin end: prevTokenBegin)].
            id := self get: #identifier.
            id = #is
               ifTrue:[
                         ic := self inferenceClause.
                         ]
               ifFalse:[self error: ' ''is'' expected'].
            ]
  ifFalse:[self error: '''where'' expected'].
" The newly declared type formal must exist in a scope of its own. This is
because:
1. Each type formal must see the preceding type formals,
but not itself.
2. The type formals must be visible in the method scope, but not visible in the
    surrounding class.
"
self validatePolyTypeArg: tid in: topScope.
self openTypeArgScope.
^topScope at: tid put: (self node: (DeltaInferredTypeVar new name: tid bound: tpc value inferenceClause: ic subtype: tpc key = #subtypeOf:) begin: 0 end: 0).! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
typeParamConstraint ^ <TypeParamConstraint>
    | tbq <Symbol>  te <TypeExpr>  |

self check: #less.
tbq := #subtypeOf:.
token = #keyword
  ifTrue:[tbq := self typeBoundQualifier].
te := self typeExpr.
self check: #greater.
^Association key: tbq value: te! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
typePattern ^ <OrdCltn[InferredTypeVar]>
    | tfs <VarOrdCltn[InferredTypeVar]>   savedScope <Scope> |

self check: #lbrace.
tfs := OrderedCollection [InferredTypeVar]  new.
savedScope := self topScope.
"The type formals should not be parsed in the scope of the method,
but in the scope surrounding it. Then, each new type formal will introduce
a new scope. The innermost type formal scope is should be the superscope
of the method scope.
Consequently, we adjust topScope here, and readjust at the end"
self topScope: self topScope superScope.
tfs addFirst: self typeFormalDecl.

[token = #semicolon]
  whileTrue:[
                  self nextToken.
                  tfs addLast: self typeFormalDecl.
                  ].

self check: #rbrace.
savedScope superScope: self topScope.
self topScope: savedScope.
^tfs! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
typeTerm ^ <TypeTerm>
    |
    tTerm  <TypeTerm> 
    unarySel <Symbol> 
    stop <Int> 
    |
    tTerm := self typeFactor.
    [token = #identifier] whileTrue: [
        stop := scanner tokenEnd.
        unarySel := self get: #identifier.
        defsAllowed ifFalse:[unarySel = #def ifTrue:[self error: 'Type variable defs not allowed here'].].
        tTerm := self
			node: (DeltaUnaryTypeExpr new target: tTerm selector: unarySel)
			beginNode: tTerm 
			end: stop
    ].
    ^tTerm! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
unaryClassOrMixin ^ <ClassOrMixin>

| expr sel <Str> |

expr := self primaryClassOrMixin.
token = #identifier ifTrue:[
                                   sel := scanner tokenVal.
                                   (sel = #mixin  or:[sel = #delta])
                                      ifTrue:[
                                                   self get: #identifier.
                                                    expr := self node:(DeltaMixinDerivationNode new class: expr selector: sel asSymbol) begin: 0 end: 0
                                                    ].
                                   ].
^expr
       ! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
unaryExpr ^ <Expression>
    | expr <Expression>  msg <Message>  |
    expr := (token = #identifier and:[scanner tokenVal = #super])
                           ifTrue:[self super] ifFalse:[self primary.].

    [token = #identifier] whileTrue: [
		msg := self unaryMsg.
        expr := self node: (DeltaNormalSend new to: expr send: msg) beginNode: expr endNode: msg.
    ].
    ^ expr! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
unaryMsg ^ <DeltaMessage>
    | msg <DeltaMessage>  |
    token = #identifier ifFalse: [self halt].
    msg := self
		node: (DeltaMessage new send: scanner tokenVal with: OrderedCollection[Expression]  new)
		begin: scanner tokenBeg 
		end: scanner tokenEnd.
    self nextToken.
    ^ msg! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
unaryMsgSequence ^ <OrdCltn[DeltaMessage]>
    | msgs <VarOrdCltn[DeltaMessage]>  |

    msgs := OrderedCollection[DeltaMessage]  new.
    msgs addFirst: self unaryMsg.
    [token = #identifier] whileTrue:[msgs addLast: self unaryMsg.].
    [self binarySel] whileTrue: [msgs addLast: self binaryMsg.].
    token = #keyword ifTrue: [msgs addLast: self keywordMsg].
    ^ msgs! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
validatePolyTypeArg: ptn <Symbol> in: s <Scope>
" 
This method is designed to check if the type argument named ptn is already
defined in the current parametrically polymorphic method or message,
and to generate an error if this is the case. It recurses up the scope chain until
it reaches a scope that is not a polyArgScope - in other words, a scope that does 
not house polymorphic type arguments.
"
s isPolyArgScope ifFalse:[^self].
(s includesIndexLocally: ptn) ifTrue:[self error: ptn , ' already defined']
                                                       ifFalse:[self validatePolyTypeArg: ptn in: s superScope].! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
variable ^ <DeltaRef|DeltaLiteral>
    |
    name <Symbol> 
    var <DeltaVarDecl> 
    |
    name := self get: #identifier.

    "Check if pseudo variable:"
    name == #super ifTrue: [^self error: 'super is not a valid primary expression'].
    name == #nil ifTrue: [^self node: (DeltaNil new value: nil) begin: prevTokenBegin end: prevTokenEnd].
    name == #true ifTrue: [^self node: (DeltaBool new value: true) begin: prevTokenBegin end: prevTokenEnd].
    name == #false ifTrue: [^self node: (DeltaBool new value: false) begin: prevTokenBegin end: prevTokenEnd].

    "Do lookup:"
    var :=
        topScope
            at: name
            ifAbsent: (self undeclaredVariableHandler: name).

    ((var isReceiverNode) or: [var isInstVarNode]) ifTrue: [topScope accessSelf].
    ^self node: (DeltaRef new decl: var) begin: prevTokenBegin end: prevTokenEnd
! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
variableDecl: classOfVar <DeltaVar class > ^ <DeltaLocalVar>
    | name <Symbol>  type <ObjectType>  vdec <DeltaLocalVar>  start <Int>  |
    start := scanner tokenBeg.
    name := self get: #identifier.
    token = #less ifTrue: [type := self type]
                           ifFalse:[type := self node: (DeltaNoTypeSpecifiedError new) begin: start end: start + name size].
    (pseudoVars includes: name)
        ifTrue: [self error: 'predeclared pseudo variable']
        ifFalse: [
            vdec := classOfVar new name: name type: type.
            self declare: vdec
        ].
    ^self node: vdec begin: start end: prevTokenEnd.
! !

"August 22, 2009 -> 14:25:9"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
variableDeclForMsgDeclOf: classOfVar <DeltaVar class > parameters: p  <OrdCltn[DeltaParameter]> ^ <DeltaLocalVar>

"We take the parameter collection as an argument so we can tell what number of parameter we are
declaring. This is used to give the parameter a default name. Ugh"
    | name <Symbol>  type <ObjectType>  vdec <DeltaLocalVar>  start <Int>  |
    start := scanner tokenBeg.
    token = #identifier
        ifTrue: [name := self get: #identifier]
        ifFalse: [name :=  (p size + 1) printString asSymbol].     "Unique and invalid parameter name"
    token = #less ifTrue: [type := self type]
                           ifFalse:[type := self node: DeltaNoTypeSpecifiedError new begin: start end: start + name size].
    (pseudoVars includes: name)
        ifTrue: [self error: 'predeclared pseudo variable']
        ifFalse: [
            vdec := classOfVar new name: name type: type.
            self declare: vdec ].
	^self node: vdec begin: start end: prevTokenEnd
! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
variableDeclForMsgDeclaration: classOfVar <DeltaVar class > ^ <DeltaLocalVar>
    | name <Symbol>  type <ObjectType>  vdec <DeltaLocalVar>  start <Int>  |
    start := scanner tokenBeg.
    token = #identifier
        ifTrue: [name := self get: #identifier]
        ifFalse: [name := topScope nofParameters printString asSymbol].     "Unique and invalid parameter name"
    token = #less ifTrue: [type := self type]
                           ifFalse:[type := self node: DeltaNoTypeSpecifiedError new begin: start end: start + name size].
    (pseudoVars includes: name)
        ifTrue: [self error: 'predeclared pseudo variable']
        ifFalse: [
            vdec := classOfVar new name: name type: type.
            self declare: vdec ].
	^self node: vdec begin: start end: prevTokenEnd
! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'grammar-private' !
variance  ^ <Symbol>
| sym |
token = #identifier
  ifFalse:[^#covar]
  ifTrue:[
               sym := self get: #identifier.
               sym = #covariant ifTrue:[^#covar].
                sym = #covar ifTrue:[^#covar].
               sym = #contravariant ifTrue:[^#contra].
                sym = #contra ifTrue:[^#contra].
               sym = #unrelated ifTrue:[^#unrelated].
               self error: ' covar, contra or unrelated expected'.
               ].! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'node location - private' !
node: n <ASTNode> begin: b <Int> end: e <Int> ^<ASTNode>

	self assert: [(nodePositions includesKey: n) not].
	nodePositions at: n put: (b ,, e).
	^n! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'node location - private' !
node: n <ASTNode> begin: b <Int> endNode: en <ASTNode> ^<ASTNode>

	^self node: n begin: b end: ((nodePositions at: en) at2)! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'node location - private' !
node: n <ASTNode> beginNode: bn <ASTNode> end: e  <Int> ^<ASTNode>

	^self node: n begin: ((nodePositions at: bn) at1) end: e! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'node location - private' !
node: n <ASTNode> beginNode: bn <ASTNode> endNode: en <ASTNode> ^<ASTNode>

	^self node: n begin: ((nodePositions at: bn) at1) end: ((nodePositions at: en) at2)! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'node location - private' !
nodeBeginFor: n <ASTNode>  ^<Integer>

	self assert: [(nodePositions includesKey: n)].
	^(nodePositions at: n) at1
! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'node location - private' !
nodeEndFor: n <ASTNode>  ^<Integer>

	self assert: [(nodePositions includesKey: n)].
	^(nodePositions at: n) at2
! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'parsing' !
parseClassOrMixinExpr: s <Str>  within: aScope <DeltaScope >  ^ <ParseTree[ClassId | GenericApplicationClassType]>

	^self parseClassOrMixinExpr: s within: aScope ifError: [ :msg <Str> :pos <Int> | Transcript show: msg; cr. self halt].
! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'parsing' !
parseClassOrMixinExpr: s <Str>  within: aScope <DeltaScope > ifError: blk <[Str,Int]> ^ <ParseTree[ClassId | GenericApplicationClassType]>

    | expr <Expression>    errorBlock <[Str, Int, ^BottomType]>  |

   self open: (DeltaScanner new open: s ifError: blk)
            within: aScope
            ifError: blk.
expr := self classOrMixin.
 token = #eos ifFalse:[self error: 'unrecognized tokens at end of input'].
^self parseTreeFor: expr
! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'parsing' !
parseClassVarList: s <Str >   within: aScope <Scope>  ^ <OrdCltn[ParseTree[DeltaLocalVar]]>

    ^self parseClassVarList: s within: aScope ifError: [ :msg <Str>  :pos <Int>  | Transcript show: msg; cr. self halt]! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'parsing' !
parseClassVarList: s <Str > within: aScope <Scope> ifError: blk <[Str,Int]> ^ <OrdCltn[ParseTree[DeltaLocalVar]]>

     | vars <VarOrdCltn[DeltaVar]> |
    self open: (DeltaScanner new open: s ifError: blk)  within: aScope ifError: blk.
    vars := OrderedCollection[DeltaVarDecl]  new.
    [token = #identifier] whileTrue: [vars addLast: (self parseTreeFor: (self variableDecl: DeltaClassVar))].
    token = #eos ifFalse:[self error: 'unrecognized tokens at end of input'].
    ^ vars ! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'parsing' !
parseDoitExpr: src <Str> within: scope <Scope> ifError: blk <[Str,Int]> ^ <ParseTree[DeltaMethod]>
	"Parse a doit expression <expr> within a dummy method: doit [ <expr> ].
		The new scope used below shouldn't really be necessary, 	but currently 
		the compiler requires #self to be present in the method scope.
		This is accomplished by copying the declaration from the outer scope."
		
	|
	method <DeltaMethod>
	newScope <DeltaScope>
	prefix <Str>
	suffix <Str>
	errorBlk <[Str,Int]>
	|
	newScope := scope.
	(newScope includesIndex: #self)
		ifFalse: [	newScope := DeltaScope new initialize: newScope.
							newScope at: #self put: (DeltaReceiver new name: #self type: nil) ].
	prefix := 'doit ['.
	suffix := ']'.
	errorBlk := [ :msg <Str> :pos <Int> | ^blk value: msg value: pos - prefix size ].
	self open: (DeltaScanner new open: (prefix, src, suffix) ifError: errorBlk) within: newScope ifError: errorBlk.
	method  := self method.
	token = #eos ifFalse:[self error: 'unrecognized tokens at end of input'].
	^self parseTreeFor: method
! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'parsing' !
parseIdList: s <Str >   within: aScope <Scope>  ^ <OrdCltn[ParseTree[DeltaLocalVar]]>
    |
    vars <VarOrdCltn[DeltaRef]> 
    errorBlock <[Str, Int, ^BottomType]> 
    |
    errorBlock := [ :msg <Str>  :pos <Int>  | Transcript show: msg; cr. self halt].
    self open: (DeltaScanner new open: s ifError: errorBlock) within: aScope  ifError: errorBlock.
    vars := OrderedCollection[DeltaVarDecl]  new.
    [token = #identifier] whileTrue: [vars addLast: (self parseTreeFor: self variable)].
    ^ vars ! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'parsing' !
parseInstVarList: s <Str >  within: aScope <Scope>  ^ <OrdCltn[ParseTree[DeltaLocalVar]]>

    ^self parseInstVarList: s within: aScope ifError: [ :msg <Str>  :pos <Int>  | Transcript show: msg; cr. self halt]! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'parsing' !
parseInstVarList: s <Str >  within: aScope <Scope> ifError: blk <[Str,Int]> ^ <OrdCltn[ParseTree[DeltaLocalVar]]>
    | i
    vars <VarOrdCltn[DeltaVar]> 
    errorBlock <[Str, Int, ^BottomType]> 
    |
    self open: (DeltaScanner new open: s ifError: blk) within: aScope ifError: blk.
    vars := OrderedCollection[DeltaVarDecl]  new.
self deltaHack. "remove ordinal num when constructors are used"
    i := 1.
    [token = #identifier] whileTrue: [vars addLast: (self parseTreeFor: ((self variableDecl: DeltaInstVar) ordinalNumber: i)).
i := i + 1].
    token = #eos ifFalse:[self error: 'unrecognized tokens at end of input'].    
    ^ vars ! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'parsing' !
parseMessageDeclaration: s   <Str>  within: aScope <DeltaScope> ifError: blk <[Str,Int]> ^ <ParseTree[DeltaMessagePattern]>

	| mPattern <DeltaMessagePattern> | 
    self open: (DeltaScanner new open: s ifError: blk) within: aScope ifError: blk.
	mPattern := self messagePattern.
    token = #eos ifFalse:[self error: 'unrecognized tokens at end of input'].
	^self parseTreeFor: mPattern
! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'parsing' !
parseMethod: s  <Str>  within: aScope <DeltaScope> ifError: blk <[Str,Int]> ^ <ParseTree[DeltaMethod]>

    | method <DeltaMethod> |
    self open: (DeltaScanner new open: s ifError: blk) within: aScope ifError: blk.
    method  := self method.
    token = #eos ifFalse:[self error: 'unrecognized tokens at end of input'].
	^self parseTreeFor: method! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'parsing' !
parseMethodHeader: s   <Str>  within: aScope <DeltaScope> ifError: blk <[Str,Int]> ^ <ParseTree[DeltaMethod]>
	| mPattern <DeltaMessagePattern> mtd <DeltaMethod> codeBody <DeltaCodeBody> | 

    self open: (DeltaScanner new open: s ifError: blk) within: aScope ifError: blk.
	mPattern := self messagePattern.
	    codeBody :=
        DeltaCodeBody new
            parameters: OrderedCollection[DeltaVar] new
            temporaries: OrderedCollection[DeltaVar] new
            statements: OrderedCollection[DeltaStatement] new
            scope: topScope.
    mtd :=  DeltaMethod new
    				  selector: mPattern selector
    				  type: mPattern type
    				  visibility: #public.				
	^self parseTreeFor: mtd
! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'parsing' !
parseMethodSignature: s  <DeltaMethod>  within: aScope <DeltaScope> ifError: blk <[Str,Int]> ^ <ParseTree[MsgSignature]>

    |
    sig <MsgSignature>
    |

    self open: (DeltaScanner new open: s ifError: blk) within: aScope ifError: blk.
    sig  := self methodSignature.
	^self parseTreeFor: sig! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'parsing' !
parseMixinExpr: s <Str>  within: aScope <DeltaScope >  ^ <ParseTree[ClassId | GenericApplicationClassType]>

    | expr <Expression>    errorBlock <[Str, Int, ^BottomType]>  |

  errorBlock := [ :msg <Str> :pos <Int> | Transcript show: msg; cr. self halt].
   self open: (DeltaScanner new open: s ifError: errorBlock)
            within: aScope
            ifError: errorBlock.
expr := self classOrMixin.
 token = #eos ifFalse:[self error: 'unrecognized tokens at end of input'].
^self parseTreeFor: expr
! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'parsing' !
parseOptionalTypeExpr: s <Str >within: scope <DeltaScope >  ifError: blk <[Str,Int]> ^ <ParseTree[TypeExpr]>

	self open: (DeltaScanner new open: s ifError: blk)
		within: scope
		ifError: blk.
	^self parseTreeFor: self optionalTypeExpr
! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'parsing' !
parseRefList: s <Str >   within: aScope <Scope>  ^ <OrdCltn[ParseTree[DeltaLocalVar]]>
    |
    vars <VarOrdCltn[DeltaRef]> 
    errorBlock <[Str, Int, ^BottomType]> 
    |
    errorBlock := [ :msg <Str>  :pos <Int>  | Transcript show: msg; cr. self halt].
    self open: (DeltaScanner new open: s ifError: errorBlock) within: aScope  ifError: errorBlock.
    vars := OrderedCollection[DeltaVarDecl]  new.
    [token = #identifier] whileTrue: [vars addLast: (self parseTreeFor: self variable)].
    ^ vars ! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'parsing' !
parseType: s <Str > within: aScope <DeltaScope > ifError: blk <[Str, Int]>   ^ <ParseTree[DeltaType]>

| pt <ParseTree[DeltaType]> |

	self open: (DeltaScanner new open: s ifError: blk) within: aScope ifError: blk.
	pt := self parseTreeFor: self type.
	token = #eos ifFalse:[blk value: 'unrecognized tokens at end of input' value: prevTokenEnd].
	^pt
! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'parsing' !
parseTypeArgs: s <Str >  within: aScope <DeltaScope >   ^ <OrdCltn[ParseTree[DeltaTypeFormal]]>
    |
    tas <OrdCltn[DeltaTypeFormal]>
    errorBlock <[Str, Int, ^BottomType]> 
    |

    errorBlock := [ :msg <Str>  :pos <Int>  | Transcript show: msg; cr. self halt].
    self open: (DeltaScanner new open: s ifError: errorBlock) within: aScope ifError: errorBlock.
    tas := OrderedCollection[DeltaTypeFormal]  new.
    tas addFirst: (self parseTreeFor: self genericTypeArgument).
    [token = #comma] whileTrue: [
        self nextToken.
        tas addLast: (self parseTreeFor: self genericTypeArgument).
    ].
    token = #eos ifFalse:[self error: 'unrecognized tokens at end of input'].
    ^ tas ! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'parsing' !
parseTypeArgs: s <Str >  
within: aScope <DeltaScope >  
ifError: eb  <[Str,Int]> ^ <OrdCltn[ParseTree[DeltaTypeFormal]]>
    |
    tas <OrdCltn[ParseTree[DeltaTypeFormal]]>
    |

    self open: (DeltaScanner new open: s ifError: eb) within: aScope ifError: eb.
    tas := OrderedCollection[ParseTree[DeltaTypeFormal]]  new.
    tas addFirst: (self parseTreeFor: self genericTypeArgument).
    [token = #comma] whileTrue: [
        self nextToken.
        tas addLast: (self parseTreeFor: self genericTypeArgument).
    ].
    token = #eos ifFalse:[self error: 'unrecognized tokens at end of input'].
    ^ tas ! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'parsing' !
parseTypeExpr: s <Str > within: scope <DeltaScope > ^ <ParseTree[TypeExpr]>

	^self parseTypeExpr: s within: scope ifError: [ :msg <Str>  :pos <Int>  | Transcript show: msg; cr. self halt].
! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'parsing' !
parseTypeExpr: s <Str >within: scope <DeltaScope >  ifError: blk <[Str,Int]> ^ <ParseTree[TypeExpr]>

	self open: (DeltaScanner new open: s ifError: blk)
		within: scope
		ifError: blk.
	^self parseTreeFor: self typeExpr
! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'parsing' !
parseTypeFormalDecl: s <Str >  within: aScope <DeltaScope >   ^ <ParseTree[DeltaTypeFormal]>
    |
    tas <VarOrdCltn[DeltaTypeFormal]> 
    errorBlock <[Str, Int, ^BottomType]> 
    |

    errorBlock := [ :msg <Str>  :pos <Int>  | Transcript show: msg; cr. self halt].
    self open: (DeltaScanner new open: s ifError: errorBlock) within: aScope ifError: errorBlock.
    ^self  parseTreeFor: self typeFormalDecl.
 ! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'private' !
check: aToken <Symbol > ^ <Self>
    token = aToken ifFalse: [self error: aToken asString, ' expected'].
    self nextToken! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'private' !
closeScope ^ <Self>
    topScope := topScope superScope! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'private' !
constructorFor: operator <Symbol > ^ <DeltaUnionTypeclass|DeltaProtocolMergeclass|DeltaProtocolOverrideclass>
    operator = #vbar ifTrue: [^ DeltaUnionType].
    operator = #semicolon ifTrue: [^ DeltaProtocolMerge].
    operator = #slash
        ifTrue: [^ DeltaProtocolOverride]
        ifFalse: [^ self error: 'parser bug'].! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'private' !
convertToDeclRef: node ^ <Ref | GenericApplicationClassType>

^self 
	node: (node isRefNode
		ifTrue: [ DeltaClassId new setId: node name; scope: DeltaGlobals ]
		ifFalse: [ DeltaGenericApplicationClassType new apply: (self convertToDeclRef: node target) to: node actuals ])
	beginNode: node 
	endNode: node	
! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'private' !
declare: var
    topScope at: var name put: var ifThere: [self error: 'variable declared twice']! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'private' !
defsAllowed ^ <Boolean>

^defsAllowed! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'private' !
defsAllowed: d <Boolean>

defsAllowed := d.! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'private' !
error: aString <Str > ^ <BottomType>
    error isNil
        ifTrue: [super error: aString]
        ifFalse: [error value: aString value: scanner tokenBeg - 1]! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'private' !
get: aToken <Symbol > ^ <Symbol>
    | val <Symbol>  |
    token = aToken
        ifTrue: [val := scanner tokenVal. self nextToken. ^ val]
        ifFalse: [self error: aToken asString, ' expected'. " ^ nil - this should never get executed - it would cause a crash"]! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'private' !
nextToken ^ <Self>
    prevTokenBegin := scanner tokenBeg.
    prevTokenEnd := scanner tokenEnd.
    token := scanner token! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'private' !
open: aScanner <DeltaScanner >ifError: aBlock <[Str,Int,^BottomType] > ^ <Self>
    self open: aScanner within: nil ifError: aBlock! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'private' !
open: aScanner <DeltaScanner >within: aScope <DeltaScope >ifError: aBlock <[Str,Int,^BottomType] > ^ <Self>
    pseudoVars := #(self super nil true false).
    scanner := aScanner.
    error := aBlock.
    topScope := aScope.
    nodePositions := IdentityDictionary new.
    self defsAllowed: false.
    self nextToken! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'private' !
openCodeScope ^ <Self>
    topScope := DeltaCodeScope within: topScope! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'private' !
openNonCodeScope ^ <Self>
    topScope := DeltaScope within: topScope! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'private' !
openScope ^ <Self>
    topScope := DeltaCodeScope within: topScope! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'private' !
openTypeArgScope ^ <Self>
    topScope := DeltaPolyArgScope within: topScope! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'private' !
scanner ^ <DeltaScanner>
    ^scanner! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'private' !
topScope

^topScope! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'private' !
topScope: ts

topScope := ts.! !

"August 22, 2009 -> 14:25:10"!

! (Delta mirrorFor: #DeltaParser) methodsFor: 'private' !
undeclaredVariableHandler: name <Symbol>  ^ <[^BottomType]>

^ [(name at: 1) isLowercase
            ifTrue: [self error: 'undeclared variable ', name.]
            ifFalse: [ 
"
                            Transcript show: name asString, ' registered as undefined.' ; cr.
                            Delta installPlaceHolderNamed: name.
                            DeltaGlobals at: name.
"
                            Transcript show: 'Global ', name asString, ' is used but not defined so it has been added.' ; cr.
                            Delta declareGlobal: name type: '' initialValue: Delta nilObj.
                            DeltaGlobals at: name.
                            ]
    ].
! !

"August 22, 2009 -> 14:25:37"!

Delta define: #DeltaASTLocationTool as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'astNode astIndex count toEscape ')) !


"August 22, 2009 -> 14:25:37"!

Delta define: #DeltaASTLocationTool as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'astNode astIndex count toEscape ')) !


"August 22, 2009 -> 14:25:37"!

Delta define: #DeltaASTLocationTool as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'astNode astIndex count toEscape ')) !


"August 22, 2009 -> 14:25:37"!

Delta define: #DeltaASTLocationTool as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'astNode astIndex count toEscape ')) !


"August 22, 2009 -> 14:25:37"!

Delta define: #DeltaASTLocationTool as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'astNode astIndex count toEscape ')) !


"August 22, 2009 -> 14:25:37"!

Delta define: #DeltaASTLocationTool as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'astNode astIndex count toEscape ')) !


"August 22, 2009 -> 14:25:37"!

Delta define: #DeltaASTLocationTool as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'astNode astIndex count toEscape ')) !


"August 22, 2009 -> 14:25:37"!

Delta define: #DeltaASTLocationTool as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'astNode astIndex count toEscape ')) !


"August 22, 2009 -> 14:25:37"!

Delta define: #DeltaASTLocationTool as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'astNode astIndex count toEscape ')) !


"August 22, 2009 -> 14:25:37"!

Delta define: #DeltaASTLocationTool as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'astNode astIndex count toEscape ')) !


"August 22, 2009 -> 14:25:37"!

Delta define: #DeltaASTLocationTool as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'astNode astIndex count toEscape ')) !


"August 22, 2009 -> 14:25:37"!

(Delta mirrorFor: #DeltaASTLocationTool)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"August 22, 2009 -> 14:25:37"!

! (Delta mirrorFor: #DeltaASTLocationTool) classSide methodsFor: 'Unclassified' !
indexForNode: n <DeltaASTNode > startingFrom: root <DeltaASTNode >  ^ <Int>
	| tool <DeltaASTLocationTool>  |
	
	root isNil ifTrue:[^0].
	tool := self new astNode: n.
	tool toEscape: [^tool astIndex].
	root apply: tool.
	^0			"Not found"
! !

"August 22, 2009 -> 14:25:37"!

! (Delta mirrorFor: #DeltaASTLocationTool) classSide methodsFor: 'Unclassified' !
new ^<Instance>
	^super new initialize! !

"August 22, 2009 -> 14:25:37"!

! (Delta mirrorFor: #DeltaASTLocationTool) classSide methodsFor: 'Unclassified' !
nodeForIndex: i <Int >startingFrom: root <DeltaASTNode > ^ <DeltaASTNode>
	| tool <DeltaASTLocationTool>  |
	tool := self new astIndex: i.
	tool toEscape: [^tool astNode].
	root apply: tool.
	^nil		"Not found"! !

"August 22, 2009 -> 14:25:37"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
assignmentNode: node <DeltaMethod > ^ <Self>
    self check: node.
    node var apply: self.
    node expr apply: self.! !

"August 22, 2009 -> 14:25:37"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
astIndex ^ <Int>
    ^astIndex.! !

"August 22, 2009 -> 14:25:37"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
astIndex: i <Int > ^ <Self>
    astIndex := i.! !

"August 22, 2009 -> 14:25:37"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
astNode ^ <DeltaASTNode>
    ^astNode.! !

"August 22, 2009 -> 14:25:37"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
astNode: n <DeltaASTNode > ^ <Self>
    astNode := n.! !

"August 22, 2009 -> 14:25:37"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
blockApplicationTypeNode: node <BlockApplicationType > ^ <Self>

self genericApplicationTypeNode: node! !

"August 22, 2009 -> 14:25:37"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
blockNode: node <DeltaMethod > ^ <Self>
    self check: node.
    node body apply: self.
! !

"August 22, 2009 -> 14:25:37"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
cascadedSendNode: node <DeltaMethod > ^ <Self>
    self check: node.
    node prevSend apply: self.
    node msg apply: self.! !

"August 22, 2009 -> 14:25:37"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
check: n <DeltaASTNode > ^ <Self>

	self astNode isNil
		ifTrue: [self astIndex == self count								"Looking for index"
			ifTrue: [self astNode: n. self toEscape value]]
		ifFalse: [self astNode == n 											"Looking for node"
			ifTrue: [self astIndex: self count. self toEscape value]].
	self count: self count + 1.
! !

"August 22, 2009 -> 14:25:37"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
classVarNode: node <DeltaClassVar > ^ <Self>

self check: node.
node declaredType apply: self.
 
   ! !

"August 22, 2009 -> 14:25:37"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
codeBodyNode: node <DeltaCodeBody > ^ <Self>
    self check: node.
    node parameters do: [ :d <DeltaParameter>  | d apply: self ].
    node temporaries do: [ :d <DeltaTemporary>  | d apply: self ].
    node statements do: [ :d <DeltaStatement>  | d apply: self ]! !

"August 22, 2009 -> 14:25:37"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
count ^ <Int>
    ^count! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
count: c <Int > ^ <Self>
    count := c.! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
dllCallNode: node
    self check: node.
    node msg apply: self.! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
genericApplicationExpressionNode: node <DeltaGenericApplicationExpression > ^ <Self>
    self check: node.
    node actuals do: [ :d <DeltaType>  | d apply: self].
    node target apply: self.! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
genericApplicationTypeNode: node <DeltaGenericApplicationType > ^ <Self>
    self check: node.
    node actuals do: [ :d <DeltaType>  | d apply: self].
    node target apply: self.

! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
guaranteedNode: node <DeltaMethod > ^ <Self>
    self check: node.
    node declaredType apply: self.
    node expr apply: self.! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
initialize
	self count: 1! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
instVarNode: node <DeltaInstVar > ^ <Self>

self check: node.
node declaredType apply: self.
 
   ! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
literalNode: node <DeltaLiteral> ^ <Self>
    self check: node.! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
messageNode: node <DeltaStatementList > ^ <Self>
    self check: node.
    node args do: [ :s <DeltaExpression>  | s apply: self].! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
messagePatternNode: node <MessagePattern>

    self check: node.
    node type apply: self.


! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
methodDeclNode: node <DeltaMethod > ^ <Self>
    self check: node.
    node filteree apply: self.
! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
methodNode: node <DeltaMethod > ^ <Self>
    self check: node.
    node type apply: self.
    self deltaHack.
    node body notNil ifTrue: [node body apply: self].
! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
mixinCompositionNode: node <MixinCompositionNode>

self check: node.
node iMixin apply: self.
node oMixin apply: self.


! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
mixinDerivationNode: node

self check: node.
node klass apply: self.


! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
mixinInvocationNode: node <MixinInvocationNode>

self check: node.
node myMixin apply: self.
node myClass apply: self.

! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
msgSignatureNode: node <DeltaMsgSignature > ^ <Self>
    self check: node.
    node domain do: [ :d <DeltaType>  | d apply: self].
    node range apply: self.! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
normalSendNode: node <DeltaMethod > ^ <Self>
    self check: node.
    node recv apply: self.
    node msg apply: self.! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
parameterNode: node <DeltaParameter > ^ <Self>
	self check: node.
	node type apply: self.! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
polyMsgSignatureNode: node <PolyMsgSignature > ^ <Self>
	self check: node.
	node formals do: [ :d <TypeVar>  | d apply: self].
	node body apply: self.! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
primitiveNode: node <DeltaPrimitive > ^ <Self>
    self check: node.
    node recv isNil ifFalse:[node recv apply: self].
    node msg apply: self.! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
protocolMergeNode: node
	self check: node.
	node type1 apply: self.
	node type2 apply: self.! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
protocolOverrideNode: node
	self check: node.
	node type1 apply: self.
	node type2 apply: self.! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
refNode: node <DeltaRef > ^ <Self>
    self check: node.
	"Is this correct ?"! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
returnStatNode: node <DeltaReturnStat> ^ <Self>
    self check: node.
    node expr apply: self.
! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
statementListNode: node <DeltaStatementList > ^ <Self>
    self check: node.
    node code do: [ :s <DeltaStatement>  | s apply: self].! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
superSendNode: node <DeltaMethod > ^ <Self>
    self check: node.
    node msg apply: self.! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
temporaryNode: node <DeltaTemporary > ^ <Self>
	self check: node.
	node type apply: self.! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
toEscape ^ <[]>
    ^toEscape! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
toEscape: blk <[]>
	toEscape := blk! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
tupleNode: node <DeltaTuple>
	self check: node.
	node elements do:[:e | e apply: self]! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
tupleTypeNode: node <TupleType > ^ <Self>

self genericApplicationTypeNode: node! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
typeErrorNode: node <DeltaTypeError > ^ <Self>
    self check: node.! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
typeFormalNode: node <TypeFormal>

self check: node.
node typeVar apply: self.

! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
typeIdNode: node <DeltaTypeId > ^ <Self>
    self check: node.! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
typeVarNode: node <DeltaTypeVar > ^ <Self>
	self check: node.
	node declaredBound apply: self.
! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
unaryGenAppNode: node <DeltaUnaryGenApp>

self check: node.
node dual apply: self! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
unaryTypeExprNode: node <DeltaMethod > ^ <Self>
self deltaHack.
    self check: node.
    node target apply: self.
! !

"August 22, 2009 -> 14:25:38"!

! (Delta mirrorFor: #DeltaASTLocationTool) methodsFor: 'node traversal' !
unionTypeNode: node <UnionType>
	self check: node.
	node type1 apply: self.
	node type2 apply: self.! !

"August 22, 2009 -> 14:26:0"!

Delta define: #DeltaASTTool as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 22, 2009 -> 14:26:0"!

Delta define: #DeltaASTTool as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 22, 2009 -> 14:26:0"!

Delta define: #DeltaASTTool as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 22, 2009 -> 14:26:0"!

Delta define: #DeltaASTTool as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 22, 2009 -> 14:26:0"!

Delta define: #DeltaASTTool as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 22, 2009 -> 14:26:0"!

Delta define: #DeltaASTTool as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 22, 2009 -> 14:26:0"!

Delta define: #DeltaASTTool as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 22, 2009 -> 14:26:0"!

Delta define: #DeltaASTTool as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 22, 2009 -> 14:26:0"!

Delta define: #DeltaASTTool as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 22, 2009 -> 14:26:0"!

Delta define: #DeltaASTTool as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 22, 2009 -> 14:26:0"!

Delta define: #DeltaASTTool as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 22, 2009 -> 14:26:0"!

(Delta mirrorFor: #DeltaASTTool)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
accessMethodNode: node <Object > ^ <Self>
    ^ self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
andOrNode: node <Object > ^ <Self>
    ^ self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
assignmentNode: node <DeltaAssignment > ^ <Self>
    ^ self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
blockApplicationTypeNode: node <BlockApplicationType>
    self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
blockNode: node <DeltaBlock > ^ <Self>
    ^ self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
cascadedSendNode: node <DeltaCascadedSend > ^ <Self>
    ^ self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
classVarNode: node <DeltaClassVar > ^ <Self>
    ^ self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
codeBodyNode: cb <CodeBody>

self subclassResponsibility! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
dllCallNode: node
    self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
genericApplicationExpressionNode: node
    self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
genericApplicationTypeNode: node <GenericApplicationType>
    self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
globalVarNode: node <DeltaGlobalVar > ^ <Self>
    ^ self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
guaranteedNode: node
    self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
ifNode: node <Object > ^ <Self>
    ^ self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
instVarNode: node <DeltaInstVar > ^ <Self>
    ^ self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
literalNode: node <DeltaLiteral > ^ <Self>
    ^ self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
loopNode: node <Object > ^ <Self>
    ^ self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
messageNode: node <DeltaMessage > ^ <Self>
    ^ self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
messagePatternNode: node <MessagePattern>

self subclassResponsibility
! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
methodNode: node <DeltaMethod > ^ <Self>
    ^ self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
mixinCompositionNode: node

self subclassResponsibility


! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
mixinDerivationNode: node

self subclassResponsibility


! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
mixinInvocationNode: node

self subclassResponsibility


! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
normalSend: node
    self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
normalSendNode: node
    self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
parameterNode: node <DeltaParameter > ^ <Self>
    ^ self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
polyMsgSignatureNode: node <PolyMsgSignature > ^ <Self>

self subclassResponsibility! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
poolVarNode: node <DeltaPoolVar > ^ <Self>
    ^ self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
predictPrimitiveNode: node
    self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
primitiveCallNode: node
    self subclassResponsibility! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
primitiveNode: node <DeltaPrimitive > ^ <Self>
     self subclassResponsibility! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
protocolMergeNode: node <ProtocolMerge>

self subclassResponsibility
! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
protocolOverrideNode: node <ProtocolOverride>

self subclassResponsibility
! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
receiverNode: node <DeltaReceiver > ^ <Self>
    ^ self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
refNode: node <DeltaRef > ^ <Self>
    ^ self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
returnInstVarNode: node
    self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
returnStatNode: node <DeltaReturnStat > ^ <Self>
    ^ self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
superSendNode: node <DeltaSuperSend > ^ <Self>
    ^ self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
superVarNode: node <DeltaSuperVar > ^ <Self>
    ^ self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
temporaryNode: node <DeltaTemporary > ^ <Self>
    ^ self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
tupleTypeNode: node <TupleType>
    self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
tuplelNode: node <DeltaLiteral > ^ <Self>
    ^ self implementedBySubclass! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
typeFormalNode: node <TypeFormal>

self subclassResponsibility.! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
typeVarNode: node <TypeVar> 

self subclassResponsibility.! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
unaryGenAppNode: node <DeltaUnaryGenApp>

self subclassResponsibility! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
unaryTypeExprNode: node <UnaryTypeExpr>

self subclassResponsibility.! !

"August 22, 2009 -> 14:26:0"!

! (Delta mirrorFor: #DeltaASTTool) methodsFor: 'node traversal' !
unionTypeNode: node <UnionType>

self subclassResponsibility! !

"August 22, 2009 -> 14:26:22"!

Delta define: #DeltaASTPrinter as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'stream indent prec ')) !


"August 22, 2009 -> 14:26:22"!

Delta define: #DeltaASTPrinter as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'stream indent prec ')) !


"August 22, 2009 -> 14:26:22"!

Delta define: #DeltaASTPrinter as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'stream indent prec ')) !


"August 22, 2009 -> 14:26:22"!

Delta define: #DeltaASTPrinter as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'stream indent prec ')) !


"August 22, 2009 -> 14:26:22"!

Delta define: #DeltaASTPrinter as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'stream indent prec ')) !


"August 22, 2009 -> 14:26:22"!

Delta define: #DeltaASTPrinter as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'stream indent prec ')) !


"August 22, 2009 -> 14:26:22"!

Delta define: #DeltaASTPrinter as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'stream indent prec ')) !


"August 22, 2009 -> 14:26:22"!

Delta define: #DeltaASTPrinter as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'stream indent prec ')) !


"August 22, 2009 -> 14:26:22"!

Delta define: #DeltaASTPrinter as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'stream indent prec ')) !


"August 22, 2009 -> 14:26:22"!

Delta define: #DeltaASTPrinter as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'stream indent prec ')) !


"August 22, 2009 -> 14:26:22"!

Delta define: #DeltaASTPrinter as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'stream indent prec ')) !


"August 22, 2009 -> 14:26:22"!

(Delta mirrorFor: #DeltaASTPrinter)
comment: 
'Instance variables:

	stream		output stream

	indent		current indentation level, starting with 0 (no indentation)

	prec			current precedence level (of enclosing expression),
					starting with 0 (lowest precedence):

					0	precedence of keyword messages
					1	precedence of binary messages
					2	precedence of unary messages
	
 (c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) classSide methodsFor: 'Unclassified' !
new
	^ super new initialize! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
andOrNode: node
	| op |
	self assert: [ node isAndOrNode ].
	node isAnd
		ifTrue: [ op := ' and: ' ]
		ifFalse: [ op := ' or: ' ].
	self print: node recv.
	self write: op.
	self write: '[ '.
	self print: node arg.
	self write: ' ]'! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
assignmentNode: node
	self assert: [ node isAssignmentNode ].
	self print: node var.
	self write: ' := '.
	self print: node expr! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
blockNode: node
	| pars |
	self assert: [ node isBlockNode ].
	self write: '[] '.
	pars := node parameters.
	pars size > 0 ifTrue: [
		pars do: [ :par |
			self write: ':'.
			self write: par name.
			self write: ' '
		].
		self write: '| '
	].
	self print: node body.
	self write: ' []'! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
cascadedSendNode: node
	self assert: [ node isCascadedSendNode ].
	self print: node prevSend.
	self write: ' ; '.
	self print: node msg! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
classVarNode: node
	self assert: [ node isClassVarNode ].
	self write: node name! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
codeBodyNode: node
    | t first |
    self assert: [ node isCodeBodyNode ].

    "temporaries"
    t := node temporaries.
    t size > 0 ifTrue: [
        self write: '| '.
        t do: [ :var | self write: var name, ' '].
        self write: '|'.
        self ln
    ].

    "statements"
	first := true.
	node statements do: [ :stat |
		first
			ifTrue: [first := false]
			ifFalse: [
				self write: '.'.
				self ln
			].
		self print: stat
	]! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
ifNode: node
	| t e |
	self assert: [node isIfNode].
	node ifTrue
		ifTrue: [ t := ' ifTrue: '. e := ' ifFalse: ' ]
		ifFalse: [ e := ' ifTrue: '. t := ' ifFalse: ' ].
	node cond apply: self.
	self write: t.
	self write: '[ '.
	self indent: [
		self ln.
		self print: node then
	].
	self ln.
	self write: ' ]'.
	node else isNil ifFalse: [
		self write: e.
		self write: '[ '.
		self indent: [
			self ln.
			self print: node else
		].
		self ln.
		self write: ' ]'
	]! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
indent: block
	indent := indent + 1.
	block value.
	indent := indent - 1! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
initialize
	stream := Transcript.	"default stream"
	indent := 0.
	prec := 0! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
inlinedBlockNode: node
	self assert: [ node isInlinedBlockNode ].
	self write: '[ '.
	self print: node body.
	self write: ' ] value'! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
intersperse: sel with: args
	| nofArgs keys first |
	nofArgs := args size.

	"unary message"
	nofArgs = 0 ifTrue: [
		self write: sel.
		^ self
	].

	"binary message or keyword message with 1 argument"
	nofArgs = 1 ifTrue: [
		self write: sel.
		self write: ' '.
		((sel at: sel size) = $:)
			ifTrue: [self print: (args at: 1) within: 2]
			ifFalse: [self print: (args at: 1) within: 1].
		^ self
	].

	"keyword message"
	first := true.
	keys := sel asArrayOfSubstringsSeparatedBy: $:.
	1 to: args size do: [ :i |
		first
			ifTrue: [first := false]
			ifFalse: [self write: ' '].
		self write: (keys at: i).
		self write: ': '.
		self print: (args at: i) within: 2
	]! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
komment
	"
	Instance variables:

	stream		output stream

	indent		current indentation level, starting with 0 (no indentation)

	prec			current precedence level (of enclosing expression),
					starting with 0 (lowest precedence):

					0	precedence of keyword messages
					1	precedence of binary messages
					2	precedence of unary messages
	"! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
literalNode: node
	self assert: [ node isLiteralNode ].
	node isCharNode ifTrue: [ self write: '$' ].
	self write: node value printString! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
ln
	| i |
	stream cr.
	i := indent.
	[ i > 0 ] whileTrue: [ stream tab. i := i - 1 ]! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
loopNode: node
	self assert: [ node isLoopNode ].
	node prologue isNil ifFalse: [
		self print: node prologue.
		self write: '.'.
		self ln
	].
	self write: '[ '.
	self print: node cond.
	self write: ' ]'.
	node whileTrue
		ifTrue: [ self write: ' whileTrue' ]
		ifFalse: [ self write: ' whileFalse' ].
	node body isNil ifFalse: [
		self write: ': ['.
		self indent: [
			self ln.
			self print: node body
		].
		self ln.
		self write: ']'
	]
	! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
messageNode: node
	self assert: [ node isMessageNode ].
	self intersperse: node selector with: node arguments! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
methodNode: node <DeltaMethod > ^ <Self>
	self assert: [ node isMethodNode ].
	self intersperse: node selector with: node body parameters.
	self indent: [
		self ln.
		self print: node body
	].
	self ln! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
normalSendNode: node
	self assert: [ node isNormalSendNode ].
	self print: node recv.
	self write: ' '.
	self print: node msg! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
parameterNode: node
	self assert: [ node isParameterNode ].	
	self write: node name! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
predictPrimitiveNode: node
	self assert: [ node isPredictPrimitiveNode ].
	self write: '"predict ', node primitive, '"'! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
primitiveCallNode: node
	self assert: [ node isPrimitiveCallNode ].
	self write: node selector! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
print: node
	node apply: self! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
print: node on: aStream
	stream := aStream.
	self print: node! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
print: node within: p
	| prevPrec |
	prevPrec := prec.
	prec := p.
	node apply: self.
	prec := prevPrec! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
receiverNode: node
	self assert: [ node isReceiverNode ].	
	self write: node name! !

"August 22, 2009 -> 14:26:22"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
refNode: node
	self assert: [ node isRefNode ].
	self write: node decl name! !

"August 22, 2009 -> 14:26:23"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
returnStatNode: node
	self assert: [ node isReturnStatNode ].
	self write: '^ '.
	self print: node expr! !

"August 22, 2009 -> 14:26:23"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
selfSendNode: node
	self assert: [ node isSelfSendNode ].
	self write: 'self '.
	self print: node msg! !

"August 22, 2009 -> 14:26:23"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
superSendNode: node
	self assert: [ node isSuperSendNode ].
	self write: 'super '.
	self print: node msg! !

"August 22, 2009 -> 14:26:23"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
superVarNode: node
	self assert: [ node isSuperVarNode ].
	self write: node name! !

"August 22, 2009 -> 14:26:23"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
temporaryNode: node
	self assert: [ node isTemporaryNode ].	
	self write: node name! !

"August 22, 2009 -> 14:26:23"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
tupleNode: node
	self write: '{ '.
	node elements do: [: e | 
		e  apply: self.
		self write: '.'.
		].
	self write: ' }'.! !

"August 22, 2009 -> 14:26:23"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
typeVarNode: node
	self write: node name! !

"August 22, 2009 -> 14:26:23"!

! (Delta mirrorFor: #DeltaASTPrinter) methodsFor: 'Unclassified' !
write: s
	stream nextPutAll: s! !

"August 22, 2009 -> 14:26:42"!

Delta define: #DeltaReferenceGatherer as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'references ')) !


"August 22, 2009 -> 14:26:42"!

Delta define: #DeltaReferenceGatherer as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'references ')) !


"August 22, 2009 -> 14:26:42"!

Delta define: #DeltaReferenceGatherer as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'references ')) !


"August 22, 2009 -> 14:26:42"!

Delta define: #DeltaReferenceGatherer as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'references ')) !


"August 22, 2009 -> 14:26:42"!

Delta define: #DeltaReferenceGatherer as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'references ')) !


"August 22, 2009 -> 14:26:42"!

Delta define: #DeltaReferenceGatherer as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'references ')) !


"August 22, 2009 -> 14:26:42"!

Delta define: #DeltaReferenceGatherer as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'references ')) !


"August 22, 2009 -> 14:26:42"!

Delta define: #DeltaReferenceGatherer as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'references ')) !


"August 22, 2009 -> 14:26:42"!

Delta define: #DeltaReferenceGatherer as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'references ')) !


"August 22, 2009 -> 14:26:42"!

Delta define: #DeltaReferenceGatherer as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'references ')) !


"August 22, 2009 -> 14:26:42"!

Delta define: #DeltaReferenceGatherer as: (
(Class subclassOf: 'DeltaASTTool' instanceVariables: 'references ')) !


"August 22, 2009 -> 14:26:42"!

(Delta mirrorFor: #DeltaReferenceGatherer)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
assignmentNode: node <DeltaAssignment > ^ <Self>

node var apply: self.
node expr apply: self.! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
blockApplicationTypeNode: node <BlockApplicationType > ^ <Self>

self genericApplicationTypeNode: node! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
blockNode: node <DeltaBlock > ^ <Self>
    node body apply: self.! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
cascadedSendNode: node <DeltaCascadedSend > ^ <Self>

node msg apply: self.
node prevSend apply: self.! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
codeBodyNode: node <CodeBody>

node temporaries do:[:tmp  <VarDecl>  | tmp apply: self.].
node statements do:[:stmt  <Statement> | stmt apply: self.].! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
dllCallNode: node
     self deltaHack.! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
genericApplicationExpressionNode: node

node target apply: self.
node actuals do:[:actual  <ObjectType>  | actual apply: self].! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
genericApplicationTypeNode: node

node target apply: self.
node actuals do:[:actual  <ObjectType>  | actual apply: self].! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
guaranteedNode: node
 
node expr apply: self.
node declaredType apply: self.! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
initialize

self references: Set[Symbol] new.! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
literalNode: node <DeltaLiteral > ^ <Self>
    

"Should we do something for the case where the type of a literal changes?"! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
messageNode: node <DeltaMessage > ^ <Self>

node args do:[:arg  <Expression> | arg apply: self].! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
methodNode: node <DeltaMethod > ^ <Self>

node type apply: self.
node body isNil ifFalse:[node body apply: self].! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
msgSignatureNode: node <DeltaMsgSignature > ^ <Self>

    node domain do: [ :d <DeltaType>  | d apply: self.].
    node range apply: self.! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
normalSendNode: node

node recv apply: self.
node msg apply: self.! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
note: n <Symbol>

(DeltaGlobals at: n ifAbsent:[^self]).
self references add: n.! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
parameterNode: node <DeltaParameter > ^ <Self>

self varNode: node! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
polyMsgSignatureNode: node <PolyMsgSignature > ^ <Self>

    node formals do: [ :d <TypeVar>  | d apply: self.].
    node body apply: self.! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
primitiveCallNode: node

node recv isNil ifFalse:[node recv apply: self].
node msg apply: self.! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
primitiveNode: node <DeltaPrimitive > ^ <Self>
    ^ self primitiveCallNode: node! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
protocolMergeNode: node <ProtocolMerge>

node type1 apply: self.
node type2 apply: self.! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
protocolOverrideNode: node

node type1 apply: self.
node type2 apply: self.! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
refNode: node <DeltaRef > ^ <Self>

self note: node name.! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
references ^ <OrdCltn[Symbol]>

^references! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
references: r <OrdCltn[Symbol]> ^ <OrdCltn[Symbol]>

references := r! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
returnStatNode: node <DeltaReturnStat > ^ <Self>

node expr apply: self.! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
statementListNode: node <DeltaStatementList > ^ <Self>

node code apply: self.! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
temporaryNode: node <DeltaTemporary > ^ <Self>

self varNode: node.! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
tupleNode: node <DeltaTuple>
	node elements do:[:e | e apply: self]! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
tupleTypeNode: node <TupleType > ^ <Self>

self genericApplicationTypeNode: node! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
typeErrorNode: node <DeltaTypeError > ^ <Self>
! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
typeIdNode: node <DeltaTypeId > ^ <Self>

self note: node name.! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
typeVarNode: node <TypeVar> 

node declaredBound apply: self.! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
unaryTypeExprNode: node <DeltaUnaryTypeExpr > ^ <Self>

node target apply: self.! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
unionTypeNode: node

node type1 apply: self.
node type2 apply: self.! !

"August 22, 2009 -> 14:26:42"!

! (Delta mirrorFor: #DeltaReferenceGatherer) methodsFor: 'Unclassified' !
varNode: node <DeltaTemporary > ^ <Self>

node type apply: self.! !

"August 22, 2009 -> 14:58:4"!

"System saved" !
"August 23, 2009 -> 19:50:35"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"August 23, 2009 -> 19:50:35"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"August 23, 2009 -> 19:50:35"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"August 23, 2009 -> 19:50:35"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"August 23, 2009 -> 19:50:35"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"August 23, 2009 -> 19:50:35"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"August 23, 2009 -> 19:50:35"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"August 23, 2009 -> 19:50:35"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"August 23, 2009 -> 19:50:35"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"August 23, 2009 -> 19:50:35"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"August 23, 2009 -> 19:50:35"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"August 23, 2009 -> 19:50:35"!

(Delta mirrorFor: #TestCase)
comment: 
'A TestCase is a Command representing the future running of a test case. Create one with the class method #selector: aSymbol, passing the name of the method to be run when the test case runs.

When you discover a new fixture, subclass TestCase, declare instance variables for the objects in the fixture, override #setUp to initialize the variables, and possibly override# tearDown to deallocate any external resources allocated in #setUp.

When you are writing a test case method, send #assert: aBoolean when you want to check for an expected value. For example, you might say "self assert: socket isOpen" to test whether or not a socket is open at a point in a test.'!


"August 23, 2009 -> 19:50:35"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Accessing' !
allTestSelectors

	^(self sunitAllSelectors
		select: [:each | 'test*' sunitMatch: each])
		reject: [:each| each includes: $:]! !

"August 23, 2009 -> 19:50:35"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Accessing' !
resources

	^#()
			! !

"August 23, 2009 -> 19:50:35"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Accessing' !
sunitVersion
	^'3.1'
			! !

"August 23, 2009 -> 19:50:35"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Accessing' !
testSelectors

	^(self sunitSelectors 
		select: [:each | 'test*' sunitMatch: each])
		reject: [:each| each includes: $:]
			! !

"August 23, 2009 -> 19:50:35"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
buildSuite
	| suite |
	^self isAbstract
		ifTrue: 
			[suite := self suiteClass named: self name asString.
			self allSubclasses 
				do: [:each | each isAbstract ifFalse: [suite addTest: each buildSuiteFromSelectors]].
			suite]
		ifFalse: [self buildSuiteFromSelectors]
			! !

"August 23, 2009 -> 19:50:35"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
buildSuiteFromAllSelectors

	^self buildSuiteFromMethods: self allTestSelectors
			! !

"August 23, 2009 -> 19:50:35"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
buildSuiteFromLocalSelectors

	^self buildSuiteFromMethods: self testSelectors
			! !

"August 23, 2009 -> 19:50:35"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
buildSuiteFromMethods: testMethods

	^testMethods
		inject: (self suiteClass named: self name asString)
		into: [:suite :selector |
			suite
				addTest: (self selector: selector);
				yourself]
			! !

"August 23, 2009 -> 19:50:35"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
buildSuiteFromSelectors

	^self shouldInheritSelectors
		ifTrue: [self buildSuiteFromAllSelectors]
		ifFalse: [self buildSuiteFromLocalSelectors]
			! !

"August 23, 2009 -> 19:50:35"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
suiteClass
	^TestSuite
			! !

"August 23, 2009 -> 19:50:35"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Instance Creation' !
debug: aSymbol

	^(self selector: aSymbol) debug
			! !

"August 23, 2009 -> 19:50:35"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Instance Creation' !
run: aSymbol

	^(self selector: aSymbol) run
			! !

"August 23, 2009 -> 19:50:35"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Instance Creation' !
runAll

	[self suite run printOn: (Transcript cr; yourself)] fork! !

"August 23, 2009 -> 19:50:35"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Instance Creation' !
selector: aSymbol

	^self new setTestSelector: aSymbol
			! !

"August 23, 2009 -> 19:50:35"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Instance Creation' !
suite

	^self buildSuite
			! !

"August 23, 2009 -> 19:50:35"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Testing' !
isAbstract
	"Override to true if a TestCase subclass is Abstract and should not have
	TestCase instances built from it"

	^self sunitName = #TestCase
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Testing' !
shouldInheritSelectors
	"I should inherit from an Abstract superclass but not from a concrete one by default,
	 unless I have no testSelectors in which case I must be expecting to inherit them
	 from my superclass.  If a test case with selectors wants to inherit selectors from a
	 concrete superclass, override this to true in that subclass."

	^self superclass isAbstract
		or: [self testSelectors isEmpty]

"$QA Ignore:Sends system method(superclass)$"
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
assert: aBooleanOrBlock

	aBooleanOrBlock value ifFalse: [self signalFailure: 'Assertion failed']
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
assert: aBoolean description: aString
	aBoolean ifFalse: [
		self logFailure: aString.
		TestResult failure sunitSignalWith: aString]
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
assert: aBoolean description: aString resumable: resumableBoolean 
	| exception |
	aBoolean
		ifFalse: 
			[self logFailure: aString.
			exception := resumableBoolean
						ifTrue: [TestResult resumableFailure]
						ifFalse: [TestResult failure].
			exception sunitSignalWith: aString]
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
deny: aBoolean

	self assert: aBoolean not
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
deny: aBoolean description: aString
	self assert: aBoolean not description: aString
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
deny: aBoolean description: aString resumable: resumableBoolean 
	self
		assert: aBoolean not
		description: aString
		resumable: resumableBoolean
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
resources
	| allResources resourceQueue |
	allResources := Set new.
	resourceQueue := OrderedCollection new.
	resourceQueue addAll: self class resources.
	[resourceQueue isEmpty] whileFalse: [
		| next |
		next := resourceQueue removeFirst.
		allResources add: next.
		resourceQueue addAll: next resources].
	^allResources
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
selector
	^testSelector
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
should: aBlock
	self assert: aBlock value
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
should: aBlock description: aString
	self assert: aBlock value description: aString
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
should: aBlock raise: anExceptionalEvent 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent)
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
should: aBlock raise: anExceptionalEvent description: aString 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent)
		description: aString
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
should: aBlock raise: anException withExceptionDo: anotherBlock 

	^self assert: [self executeShould: aBlock inScopeOf: anException withExceptionDo: anotherBlock]! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
shouldnt: aBlock
	self deny: aBlock value
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
shouldnt: aBlock description: aString
	self deny: aBlock value description: aString
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
shouldnt: aBlock raise: anExceptionalEvent 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent) not
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
shouldnt: aBlock raise: anExceptionalEvent description: aString 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent) not 		description: aString
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
signalFailure: aString
	TestResult failure sunitSignalWith: aString! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Dependencies' !
addDependentToHierarchy: anObject 
	"an empty method. for Composite compability with TestSuite"


			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Dependencies' !
removeDependentFromHierarchy: anObject 
	"an empty method. for Composite compability with TestSuite"


			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Printing' !
echo

	Transcript cr.
	self printOn: Transcript! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Printing' !
printOn: aStream

	aStream
		nextPutAll: self class printString;
		nextPutAll: '>>#';
		nextPutAll: testSelector
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Private' !
executeShould: aBlock inScopeOf: anExceptionalEvent 
	^[aBlock value.
 	false] sunitOn: anExceptionalEvent
		do: [:ex | ex sunitExitWith: true]
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Private' !
executeShould: aBlock inScopeOf: anException withExceptionDo: anotherBlock

	^[aBlock value.
 	false] 
		on: anException
		do: [:exception | 
			anotherBlock value: exception.
			exception return: true]! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Private' !
performTest

	self perform: testSelector sunitAsSymbol
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Private' !
setTestSelector: aSymbol
	testSelector := aSymbol
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
debug
	self resources do: [:res | 
		res isAvailable ifFalse: [^res signalInitializationError]].
	[(self class selector: testSelector) runCase] 
		sunitEnsure: [self resources do: [:each | each reset]]
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
debugAsFailure
	| semaphore |
	semaphore := Semaphore new.
	self resources do: [:res | 
		res isAvailable ifFalse: [^res signalInitializationError]].
	[semaphore wait. self resources do: [:each | each reset]] fork.
	(self class selector: testSelector) runCaseAsFailure: semaphore.

			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
failureLog	
	^SUnitNameResolver defaultLogDevice

			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
isLogging
	"By default, we're not logging failures. If you override this in 
	a subclass, make sure that you override #failureLog"
	^true
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
logFailure: aString
	self isLogging ifTrue: [
		self failureLog 
			cr; 
			nextPutAll: aString; 
			flush]
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
openDebuggerOnFailingTestMethod
	"SUnit has halted one step in front of the failing test method. Step over the 'self halt' and 
	 send into 'self perform: testSelector' to see the failure from the beginning"

	self
		halt;
		performTest
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
run
	| result |
	result := TestResult new.
	self run: result.
	^result
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
run: aResult
	aResult runCase: self
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
runCase

	[self setUp.
	self performTest] sunitEnsure: [self tearDown]
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
runCaseAsFailure: aSemaphore
	[self setUp.
	self openDebuggerOnFailingTestMethod] sunitEnsure: [
		self tearDown.
		aSemaphore signal]
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
setUp
			! !

"August 23, 2009 -> 19:50:36"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
tearDown
			! !

"August 23, 2009 -> 19:50:44"!

Delta define: #Block as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 23, 2009 -> 19:50:44"!

Delta define: #Block as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 23, 2009 -> 19:50:44"!

Delta define: #Block as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 23, 2009 -> 19:50:44"!

Delta define: #Block as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 23, 2009 -> 19:50:44"!

Delta define: #Block as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 23, 2009 -> 19:50:44"!

Delta define: #Block as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 23, 2009 -> 19:50:44"!

Delta define: #Block as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 23, 2009 -> 19:50:44"!

Delta define: #Block as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 23, 2009 -> 19:50:44"!

Delta define: #Block as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 23, 2009 -> 19:50:44"!

Delta define: #Block as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 23, 2009 -> 19:50:44"!

Delta define: #Block as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"August 23, 2009 -> 19:50:44"!

(Delta mirrorFor: #Block)
comment: 
'Tags: %BlueBook

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.3 $
'!


"August 23, 2009 -> 19:50:44"!

! (Delta mirrorFor: #Block) classSide methodsFor: 'fancy control structures' !
exitFrom: blk <[[RET def,^BottomType], ^FALLOFF def]>  ^<RET | FALLOFF>

	^blk value: [ :ret <RET> | ^ret ]! !

"August 23, 2009 -> 19:50:44"!

! (Delta mirrorFor: #Block) classSide methodsFor: 'file out' !
fileOutSignature ^<Integer>
    ^75! !

"August 23, 2009 -> 19:50:44"!

! (Delta mirrorFor: #Block) methodsFor: 'arity' !
arity
	self subclassResponsibility! !

"August 23, 2009 -> 19:50:44"!

! (Delta mirrorFor: #Block) methodsFor: 'debugging' !
blockIsOptimized ^ <Boolean>

	^{{self primitiveBlockIsOptimized}}! !

"August 23, 2009 -> 19:50:44"!

! (Delta mirrorFor: #Block) methodsFor: 'debugging' !
blockMethod ^ <Method>

	^{{self primitiveBlockMethod}}! !

"August 23, 2009 -> 19:50:44"!

! (Delta mirrorFor: #Block) methodsFor: 'evaluating' !
value ^<Object>

	self error: 'Block with arguments invoked with none'! !

"August 23, 2009 -> 19:50:44"!

! (Delta mirrorFor: #Block) methodsFor: 'evaluating' !
valueWithArguments: a <Array[Object]> ^ <Object>
	^self subclassResponsibility! !

"August 23, 2009 -> 19:50:44"!

! (Delta mirrorFor: #Block) methodsFor: 'file out' !
fileOutOn: d <Dumper>
	self error: 'should not file out blocks'! !

"August 23, 2009 -> 19:50:44"!

! (Delta mirrorFor: #Block) methodsFor: 'private' !
validateValues: a <Array[Object]>
	self assert:[a size = self arity].! !

"August 23, 2009 -> 19:50:52"!

Delta define: #BlockWithEightArguments as: (
Generic forAll: '(A1 contra) , (A2 contra), (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra)  , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, ^R]')) !


"August 23, 2009 -> 19:50:52"!

Delta define: #BlockWithEightArguments as: (
Generic forAll: '(A1 contra) , (A2 contra), (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra)  , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, ^R]')) !


"August 23, 2009 -> 19:50:52"!

Delta define: #BlockWithEightArguments as: (
Generic forAll: '(A1 contra) , (A2 contra), (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra)  , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, ^R]')) !


"August 23, 2009 -> 19:50:52"!

Delta define: #BlockWithEightArguments as: (
Generic forAll: '(A1 contra) , (A2 contra), (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra)  , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, ^R]')) !


"August 23, 2009 -> 19:50:52"!

Delta define: #BlockWithEightArguments as: (
Generic forAll: '(A1 contra) , (A2 contra), (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra)  , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, ^R]')) !


"August 23, 2009 -> 19:50:52"!

Delta define: #BlockWithEightArguments as: (
Generic forAll: '(A1 contra) , (A2 contra), (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra)  , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, ^R]')) !


"August 23, 2009 -> 19:50:52"!

Delta define: #BlockWithEightArguments as: (
Generic forAll: '(A1 contra) , (A2 contra), (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra)  , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, ^R]')) !


"August 23, 2009 -> 19:50:52"!

Delta define: #BlockWithEightArguments as: (
Generic forAll: '(A1 contra) , (A2 contra), (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra)  , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, ^R]')) !


"August 23, 2009 -> 19:50:52"!

Delta define: #BlockWithEightArguments as: (
Generic forAll: '(A1 contra) , (A2 contra), (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra)  , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, ^R]')) !


"August 23, 2009 -> 19:50:52"!

Delta define: #BlockWithEightArguments as: (
Generic forAll: '(A1 contra) , (A2 contra), (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra)  , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, ^R]')) !


"August 23, 2009 -> 19:50:52"!

Delta define: #BlockWithEightArguments as: (
Generic forAll: '(A1 contra) , (A2 contra), (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra)  , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, ^R]')) !


"August 23, 2009 -> 19:50:52"!

Delta define: #BlockWithEightArguments as: (
Generic forAll: '(A1 contra) , (A2 contra), (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra)  , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, ^R]')) !


"August 23, 2009 -> 19:50:52"!

(Delta mirrorFor: #BlockWithEightArguments)
comment: 
'(c) 1996-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.2 $'!


"August 23, 2009 -> 19:50:52"!

! (Delta mirrorFor: #BlockWithEightArguments) methodsFor: 'arity' !
arity ^ <Integer>
	^8! !

"August 23, 2009 -> 19:50:52"!

! (Delta mirrorFor: #BlockWithEightArguments) methodsFor: 'evaluating' !
value: arg1 <A1> value: arg2 <A2> value: arg3 <A3> value: arg4 <A4> value: arg5 <A5> value: arg6 <A6> value: arg7 <A7> value: arg8 <A8>
    "Block dispatch method (vm generated)"
    ^{{self primitiveValue: arg1 value: arg2 value: arg3 value: arg4 value: arg5 value: arg6 value: arg7 value: arg8}}! !

"August 23, 2009 -> 19:50:52"!

! (Delta mirrorFor: #BlockWithEightArguments) methodsFor: 'evaluating' !
valueWithArguments: a <Array[Object]> ^ <R>
	self validateValues: a.
	^self value: (a at: 1) value: (a at: 2) value: (a at: 3)
			value: (a at: 4) value: (a at: 5) value: (a at: 6) 
			value: (a at: 7) value: (a at: 8)! !

"August 23, 2009 -> 19:50:58"!

Delta define: #BlockWithFiveArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra), (A5 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, ^R]')) !


"August 23, 2009 -> 19:50:58"!

Delta define: #BlockWithFiveArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra), (A5 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, ^R]')) !


"August 23, 2009 -> 19:50:58"!

Delta define: #BlockWithFiveArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra), (A5 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, ^R]')) !


"August 23, 2009 -> 19:50:58"!

Delta define: #BlockWithFiveArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra), (A5 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, ^R]')) !


"August 23, 2009 -> 19:50:58"!

Delta define: #BlockWithFiveArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra), (A5 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, ^R]')) !


"August 23, 2009 -> 19:50:58"!

Delta define: #BlockWithFiveArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra), (A5 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, ^R]')) !


"August 23, 2009 -> 19:50:58"!

Delta define: #BlockWithFiveArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra), (A5 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, ^R]')) !


"August 23, 2009 -> 19:50:58"!

Delta define: #BlockWithFiveArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra), (A5 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, ^R]')) !


"August 23, 2009 -> 19:50:58"!

Delta define: #BlockWithFiveArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra), (A5 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, ^R]')) !


"August 23, 2009 -> 19:50:58"!

Delta define: #BlockWithFiveArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra), (A5 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, ^R]')) !


"August 23, 2009 -> 19:50:58"!

Delta define: #BlockWithFiveArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra), (A5 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, ^R]')) !


"August 23, 2009 -> 19:50:58"!

Delta define: #BlockWithFiveArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra), (A5 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, ^R]')) !


"August 23, 2009 -> 19:50:58"!

(Delta mirrorFor: #BlockWithFiveArguments)
comment: 
'(c) 1996-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.2 $'!


"August 23, 2009 -> 19:50:58"!

! (Delta mirrorFor: #BlockWithFiveArguments) methodsFor: 'arity' !
arity ^ <Integer>
	^5! !

"August 23, 2009 -> 19:50:58"!

! (Delta mirrorFor: #BlockWithFiveArguments) methodsFor: 'evaluating' !
value: arg1 <A1> value: arg2 <A2> value: arg3 <A3> value: arg4 <A4> value: arg5 <A5>
    "Block dispatch method (vm generated)"
    ^{{self primitiveValue: arg1 value: arg2 value: arg3 value: arg4 value: arg5}}! !

"August 23, 2009 -> 19:50:58"!

! (Delta mirrorFor: #BlockWithFiveArguments) methodsFor: 'evaluating' !
valueWithArguments: a <Array[Object]> ^ <R>
	self validateValues: a.
	^self value: (a at: 1) value: (a at: 2) value: (a at: 3)
			value: (a at: 4) value: (a at: 5)! !

"August 23, 2009 -> 19:51:4"!

Delta define: #BlockWithFourArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, ^R]')) !


"August 23, 2009 -> 19:51:4"!

Delta define: #BlockWithFourArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, ^R]')) !


"August 23, 2009 -> 19:51:4"!

Delta define: #BlockWithFourArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, ^R]')) !


"August 23, 2009 -> 19:51:4"!

Delta define: #BlockWithFourArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, ^R]')) !


"August 23, 2009 -> 19:51:4"!

Delta define: #BlockWithFourArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, ^R]')) !


"August 23, 2009 -> 19:51:4"!

Delta define: #BlockWithFourArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, ^R]')) !


"August 23, 2009 -> 19:51:4"!

Delta define: #BlockWithFourArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, ^R]')) !


"August 23, 2009 -> 19:51:4"!

Delta define: #BlockWithFourArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, ^R]')) !


"August 23, 2009 -> 19:51:4"!

Delta define: #BlockWithFourArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, ^R]')) !


"August 23, 2009 -> 19:51:4"!

Delta define: #BlockWithFourArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, ^R]')) !


"August 23, 2009 -> 19:51:4"!

Delta define: #BlockWithFourArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, ^R]')) !


"August 23, 2009 -> 19:51:4"!

Delta define: #BlockWithFourArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, ^R]')) !


"August 23, 2009 -> 19:51:5"!

(Delta mirrorFor: #BlockWithFourArguments)
comment: 
'(c) 1996-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.2 $'!


"August 23, 2009 -> 19:51:5"!

! (Delta mirrorFor: #BlockWithFourArguments) methodsFor: 'arity' !
arity ^ <Integer>
	^4! !

"August 23, 2009 -> 19:51:5"!

! (Delta mirrorFor: #BlockWithFourArguments) methodsFor: 'evaluating' !
value: arg1 <A1> value: arg2 <A2> value: arg3 <A3> value: arg4 <A4>

    "Block dispatch method (vm generated)"
    ^{{self primitiveValue: arg1 value: arg2 value: arg3 value: arg4}}! !

"August 23, 2009 -> 19:51:5"!

! (Delta mirrorFor: #BlockWithFourArguments) methodsFor: 'evaluating' !
valueWithArguments: a <Array[Object]> ^ <R>
	self validateValues: a.
	^self value: (a at: 1) value: (a at: 2) value: (a at: 3)
			value: (a at: 4)! !

"August 23, 2009 -> 19:51:24"!

Delta define: #BlockWithNineArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra), (A9 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, A9, ^R]')) !


"August 23, 2009 -> 19:51:24"!

Delta define: #BlockWithNineArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra), (A9 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, A9, ^R]')) !


"August 23, 2009 -> 19:51:24"!

Delta define: #BlockWithNineArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra), (A9 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, A9, ^R]')) !


"August 23, 2009 -> 19:51:24"!

Delta define: #BlockWithNineArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra), (A9 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, A9, ^R]')) !


"August 23, 2009 -> 19:51:24"!

Delta define: #BlockWithNineArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra), (A9 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, A9, ^R]')) !


"August 23, 2009 -> 19:51:24"!

Delta define: #BlockWithNineArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra), (A9 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, A9, ^R]')) !


"August 23, 2009 -> 19:51:24"!

Delta define: #BlockWithNineArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra), (A9 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, A9, ^R]')) !


"August 23, 2009 -> 19:51:24"!

Delta define: #BlockWithNineArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra), (A9 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, A9, ^R]')) !


"August 23, 2009 -> 19:51:24"!

Delta define: #BlockWithNineArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra), (A9 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, A9, ^R]')) !


"August 23, 2009 -> 19:51:24"!

Delta define: #BlockWithNineArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra), (A9 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, A9, ^R]')) !


"August 23, 2009 -> 19:51:24"!

Delta define: #BlockWithNineArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra), (A9 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, A9, ^R]')) !


"August 23, 2009 -> 19:51:24"!

Delta define: #BlockWithNineArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (A8 contra), (A9 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, A8, A9, ^R]')) !


"August 23, 2009 -> 19:51:24"!

(Delta mirrorFor: #BlockWithNineArguments)
comment: 
'(c) 1996-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.2 $'!


"August 23, 2009 -> 19:51:24"!

! (Delta mirrorFor: #BlockWithNineArguments) methodsFor: 'arity' !
arity ^ <Integer>
	^9! !

"August 23, 2009 -> 19:51:24"!

! (Delta mirrorFor: #BlockWithNineArguments) methodsFor: 'evaluating' !
value: arg1 <A1> value: arg2 <A2> value: arg3 <A3> value: arg4 <A4> value: arg5 <A5> value: arg6 <A6> value: arg7 <A7> value: arg8 <A8> value: arg9 <A9>
    "Block dispatch method (vm generated)"
    ^{{self primitiveValue: arg1 value: arg2 value: arg3 value: arg4 value: arg5 value: arg6 value: arg7 value: arg8 value: arg9}}! !

"August 23, 2009 -> 19:51:24"!

! (Delta mirrorFor: #BlockWithNineArguments) methodsFor: 'evaluating' !
valueWithArguments: a <Array[Object]> ^ <R>
	self validateValues: a.
	^self value: (a at: 1) value: (a at: 2) value: (a at: 3)
			value: (a at: 4) value: (a at: 5) value: (a at: 6) 
			value: (a at: 7) value: (a at: 8) value: (a at: 9)! !

"August 23, 2009 -> 19:51:31"!

Delta define: #BlockWithOneArgument as: (
Generic forAll: '(A1 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, ^R]')) !


"August 23, 2009 -> 19:51:31"!

Delta define: #BlockWithOneArgument as: (
Generic forAll: '(A1 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, ^R]')) !


"August 23, 2009 -> 19:51:31"!

Delta define: #BlockWithOneArgument as: (
Generic forAll: '(A1 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, ^R]')) !


"August 23, 2009 -> 19:51:31"!

Delta define: #BlockWithOneArgument as: (
Generic forAll: '(A1 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, ^R]')) !


"August 23, 2009 -> 19:51:31"!

Delta define: #BlockWithOneArgument as: (
Generic forAll: '(A1 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, ^R]')) !


"August 23, 2009 -> 19:51:31"!

Delta define: #BlockWithOneArgument as: (
Generic forAll: '(A1 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, ^R]')) !


"August 23, 2009 -> 19:51:31"!

Delta define: #BlockWithOneArgument as: (
Generic forAll: '(A1 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, ^R]')) !


"August 23, 2009 -> 19:51:31"!

Delta define: #BlockWithOneArgument as: (
Generic forAll: '(A1 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, ^R]')) !


"August 23, 2009 -> 19:51:31"!

Delta define: #BlockWithOneArgument as: (
Generic forAll: '(A1 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, ^R]')) !


"August 23, 2009 -> 19:51:31"!

Delta define: #BlockWithOneArgument as: (
Generic forAll: '(A1 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, ^R]')) !


"August 23, 2009 -> 19:51:31"!

Delta define: #BlockWithOneArgument as: (
Generic forAll: '(A1 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, ^R]')) !


"August 23, 2009 -> 19:51:31"!

Delta define: #BlockWithOneArgument as: (
Generic forAll: '(A1 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, ^R]')) !


"August 23, 2009 -> 19:51:31"!

(Delta mirrorFor: #BlockWithOneArgument)
comment: 
'(c) 1996-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.2 $'!


"August 23, 2009 -> 19:51:31"!

! (Delta mirrorFor: #BlockWithOneArgument) methodsFor: 'arity' !
arity ^ <Integer>
	^1! !

"August 23, 2009 -> 19:51:31"!

! (Delta mirrorFor: #BlockWithOneArgument) methodsFor: 'evaluating' !
value: arg1 <A1>
    "Block dispatch method (vm generated)"
    ^{{self primitiveValue: arg1}}! !

"August 23, 2009 -> 19:51:31"!

! (Delta mirrorFor: #BlockWithOneArgument) methodsFor: 'evaluating' !
valueWithArguments: a <Array[Object]> ^ <R>
	self validateValues: a.
	^self value: a first! !

"August 23, 2009 -> 19:51:37"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"August 23, 2009 -> 19:51:37"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"August 23, 2009 -> 19:51:37"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"August 23, 2009 -> 19:51:37"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"August 23, 2009 -> 19:51:37"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"August 23, 2009 -> 19:51:37"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"August 23, 2009 -> 19:51:37"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"August 23, 2009 -> 19:51:37"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"August 23, 2009 -> 19:51:37"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"August 23, 2009 -> 19:51:37"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"August 23, 2009 -> 19:51:37"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"August 23, 2009 -> 19:51:37"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"August 23, 2009 -> 19:51:37"!

(Delta mirrorFor: #BlockWithoutArguments)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.4 $
'!


"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) classSide methodsFor: 'testing' !
test

	| v <Boolean> |
	
	[ v := false ] ensure: [ v := true ].
	self assert: [ v ].

	[ v := false ] ifCurtailed: [ v := true ].
	self assert: [ v not ].

	self testForUnwind: [ v := false ] onUnwind: [ v := true ].
	self assert: [ v ].

	self testForEnsure: [ v := false ] onUnwind: [ v := true ].
	self assert: [ v ]! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) classSide methodsFor: 'testing' !
testForEnsure: b <[]> onUnwind: b2 <[]> ^<Object>

	[ ^b value ] ensure: b2! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) classSide methodsFor: 'testing' !
testForUnwind: b <[]> onUnwind: b2 <[]> ^<Object>

	[ ^b value ] ifCurtailed: b2! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'Camp Smalltalk' !
sunitEnsure: aBlock
 
        ^self ensure: aBlock! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'Camp Smalltalk' !
sunitOn: anException do: aHandlerBlock
 
        ^self on: anException do: aHandlerBlock! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'arity' !
arity ^ <Integer>
	^0! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
critical ^<R>
	"This is used for very short, fast critical regions where the overhead or inconvenience
	  of a semaphore is not desired.  The argument is evaluated without any process context
	  switches taking place, so that it can perform atomic operations.  WARNING: the blk MUST
	  NOT do anything that might cause the process to block, such as any kind of I/O.  This
	  method is only appropriate for very fast atomic operations that are extremely reliable, since
	  no other processes will get a chance to run while it is being evaluated, and if it crashes,
	  it will not be debuggable, since the development & debugger processes will not be able to run."

	"%todo: implement this right.  NOTE: an interesting semantic idea: we could dramatically improve
	  the usefulnes of this if it was a critical region on the receiver, not on the system as a whole."

	^self value! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
ensure: f <[]> ^<R>

	"Use the following impl when vm bug fixed"
	"[ ^self value ] ifCurtailed: f"

	| result <R> |
	[ result := self value ] ifCurtailed: f.
	f value.
	^result! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
fork ^<Process>

	^self forkAt: Processor activePriority! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
forkAt: priority <Int> ^<Process>

	^self newProcess priority: priority; resume! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
ifCurtailed: protect <[]> ^<R>

	^guaranteed <R>
		  {{self primitiveUnwindProtect: protect
				ifFail: [ :err <Symbol> |	self shouldNotHappen ]
		  }}
! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
newProcess ^<Process>

	^Process for: self! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
profile

	Profiler do: self! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
repeat ^<BottomType>

	[ true ] whileTrue: [ self value ].
	self shouldNotHappen.! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
time ^<Int>

	^Time millisecondsToRun: self! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
userTime ^<Int>

	^Time userMillisecondsToRun: self! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
value ^<R>

    ^{{self primitiveValue}}! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
valueIfFail: fail <[^X def]>  ^<R | X>

	^self value! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
valueWithArguments: a <Array[Object]> ^ <R>
	self validateValues: a.
	^self value! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
verify
	"Evaluate the receiver, and generate an error if it does not return true.  This is different than
	  Object>>#assert: in that 1) it is a boolean block message, and 2) it ALWAYS evaluates, whereas
	  #assert: does not guarantee that it will evaluate the predicate.

	  Use verify in situations where you must ensure that the test is performed, for example when there
	  are side-effects that must take place, or if it is testing code that should always be performed.

	  Note that this message is only valid for blocks that return boolean values."

	"Note: we don't use self as the receiver for #error: below because it will currently
		prevent the block from being optimized away by the inliner"
	self value
		ifFalse: [ BlockWithoutArguments[Object] error: 'Assertion failed' ].

	"%hack %todo: remove this when compiler bug fixed"
	^nil! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
verify: message
	"Evaluate the receiver, and generate an error if it does not return true.  This is different than
	  Object>>#assert: in that 1) it is a boolean block message, and 2) it ALWAYS evaluates, whereas
	  #assert: does not guarantee that it will evaluate the predicate.

	  Use verify in situations where you must ensure that the test is performed, for example when there
	  are side-effects that must take place, or if it is testing code that should always be performed.

	  Note that this message is only valid for blocks that return boolean values."

	"Note: we don't use self as the receiver for #error: below because it will currently
		prevent the block from being optimized away by the inliner"
	self value
		ifFalse: [ BlockWithoutArguments[Object] error: 'Assertion failed: ', message ].

	"%hack %todo: remove this when compiler bug fixed"
	^nil! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
whileFalse ^<Object>

	^self whileFalse: []! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
whileFalse: blk <[]> ^<Object>

	"We can guarantee that self value is a Boolean in typesafe programs because the typechecker removes this
		  message from the protocol of blocks that don't return Booleans"
	(guaranteed <Boolean> (self value))
		ifFalse: [	blk value.
					[ (guaranteed <Boolean> (self value)) ]
						whileFalse: [ blk value ]	].
	^nil! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
whileTrue ^<Object>

	^self whileTrue: []! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
whileTrue: blk <[]> ^<Object>

	"We can guarantee that self value is a Boolean in typesafe programs because the typechecker removes this
		  message from the protocol of blocks that don't return Booleans"


	(guaranteed <Boolean> (self value))
		ifTrue: [	blk value.
					[ (guaranteed <Boolean> (self value)) ]
						whileTrue: [ blk value ]	].

	^nil! !

"August 23, 2009 -> 19:51:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'exceptions' !
on: exception do: handlerBlock

	^(LinkedExceptionHandler
		on: exception
		do: handlerBlock
		return: [:value | ^ value]) protect: self
! !

"August 23, 2009 -> 19:51:44"!

Delta define: #BlockWithSevenArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, ^R]')) !


"August 23, 2009 -> 19:51:44"!

Delta define: #BlockWithSevenArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, ^R]')) !


"August 23, 2009 -> 19:51:44"!

Delta define: #BlockWithSevenArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, ^R]')) !


"August 23, 2009 -> 19:51:44"!

Delta define: #BlockWithSevenArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, ^R]')) !


"August 23, 2009 -> 19:51:44"!

Delta define: #BlockWithSevenArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, ^R]')) !


"August 23, 2009 -> 19:51:44"!

Delta define: #BlockWithSevenArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, ^R]')) !


"August 23, 2009 -> 19:51:44"!

Delta define: #BlockWithSevenArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, ^R]')) !


"August 23, 2009 -> 19:51:44"!

Delta define: #BlockWithSevenArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, ^R]')) !


"August 23, 2009 -> 19:51:44"!

Delta define: #BlockWithSevenArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, ^R]')) !


"August 23, 2009 -> 19:51:44"!

Delta define: #BlockWithSevenArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, ^R]')) !


"August 23, 2009 -> 19:51:44"!

Delta define: #BlockWithSevenArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, ^R]')) !


"August 23, 2009 -> 19:51:44"!

Delta define: #BlockWithSevenArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (A7 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, A7, ^R]')) !


"August 23, 2009 -> 19:51:44"!

(Delta mirrorFor: #BlockWithSevenArguments)
comment: 
'(c) 1996-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.2 $'!


"August 23, 2009 -> 19:51:44"!

! (Delta mirrorFor: #BlockWithSevenArguments) methodsFor: 'arity' !
arity ^ <Integer>
	^7! !

"August 23, 2009 -> 19:51:44"!

! (Delta mirrorFor: #BlockWithSevenArguments) methodsFor: 'evaluating' !
value: arg1 <A1> value: arg2 <A2> value: arg3 <A3> value: arg4 <A4> value: arg5 <A5> value: arg6 <A6> value: arg7 <A7>
    "Block dispatch method (vm generated)"
    ^{{self primitiveValue: arg1 value: arg2 value: arg3 value: arg4 value: arg5 value: arg6 value: arg7}}! !

"August 23, 2009 -> 19:51:44"!

! (Delta mirrorFor: #BlockWithSevenArguments) methodsFor: 'evaluating' !
valueWithArguments: a <Array[Object]> ^ <R>
	self validateValues: a.
	^self value: (a at: 1) value: (a at: 2) value: (a at: 3)
			value: (a at: 4) value: (a at: 5) value: (a at: 6) 
			value: (a at: 7)! !

"August 23, 2009 -> 19:51:52"!

Delta define: #BlockWithSixArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, ^R]')) !


"August 23, 2009 -> 19:51:52"!

Delta define: #BlockWithSixArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, ^R]')) !


"August 23, 2009 -> 19:51:52"!

Delta define: #BlockWithSixArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, ^R]')) !


"August 23, 2009 -> 19:51:52"!

Delta define: #BlockWithSixArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, ^R]')) !


"August 23, 2009 -> 19:51:52"!

Delta define: #BlockWithSixArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, ^R]')) !


"August 23, 2009 -> 19:51:52"!

Delta define: #BlockWithSixArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, ^R]')) !


"August 23, 2009 -> 19:51:52"!

Delta define: #BlockWithSixArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, ^R]')) !


"August 23, 2009 -> 19:51:52"!

Delta define: #BlockWithSixArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, ^R]')) !


"August 23, 2009 -> 19:51:52"!

Delta define: #BlockWithSixArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, ^R]')) !


"August 23, 2009 -> 19:51:52"!

Delta define: #BlockWithSixArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, ^R]')) !


"August 23, 2009 -> 19:51:52"!

Delta define: #BlockWithSixArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, ^R]')) !


"August 23, 2009 -> 19:51:52"!

Delta define: #BlockWithSixArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (A4 contra) , (A5 contra) , (A6 contra) , (R covar)' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, A4, A5, A6, ^R]')) !


"August 23, 2009 -> 19:51:52"!

(Delta mirrorFor: #BlockWithSixArguments)
comment: 
'(c) 1996-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.2 $'!


"August 23, 2009 -> 19:51:52"!

! (Delta mirrorFor: #BlockWithSixArguments) methodsFor: 'arity' !
arity ^ <Integer>
	^6! !

"August 23, 2009 -> 19:51:52"!

! (Delta mirrorFor: #BlockWithSixArguments) methodsFor: 'evaluating' !
value: arg1 <A1> value: arg2 <A2> value: arg3 <A3> value: arg4 <A4> value: arg5 <A5> value: arg6 <A6>
    "Block dispatch method (vm generated)"
    ^{{self primitiveValue: arg1 value: arg2 value: arg3 value: arg4 value: arg5 value: arg6}}! !

"August 23, 2009 -> 19:51:52"!

! (Delta mirrorFor: #BlockWithSixArguments) methodsFor: 'evaluating' !
valueWithArguments: a <Array[Object]> ^ <R>
	self validateValues: a.
	^self value: (a at: 1) value: (a at: 2) value: (a at: 3)
			value: (a at: 4) value: (a at: 5) value: (a at: 6)! !

"August 23, 2009 -> 19:51:58"!

Delta define: #BlockWithThreeArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, ^R]')) !


"August 23, 2009 -> 19:51:58"!

Delta define: #BlockWithThreeArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, ^R]')) !


"August 23, 2009 -> 19:51:58"!

Delta define: #BlockWithThreeArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, ^R]')) !


"August 23, 2009 -> 19:51:58"!

Delta define: #BlockWithThreeArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, ^R]')) !


"August 23, 2009 -> 19:51:58"!

Delta define: #BlockWithThreeArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, ^R]')) !


"August 23, 2009 -> 19:51:58"!

Delta define: #BlockWithThreeArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, ^R]')) !


"August 23, 2009 -> 19:51:58"!

Delta define: #BlockWithThreeArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, ^R]')) !


"August 23, 2009 -> 19:51:58"!

Delta define: #BlockWithThreeArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, ^R]')) !


"August 23, 2009 -> 19:51:58"!

Delta define: #BlockWithThreeArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, ^R]')) !


"August 23, 2009 -> 19:51:58"!

Delta define: #BlockWithThreeArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, ^R]')) !


"August 23, 2009 -> 19:51:58"!

Delta define: #BlockWithThreeArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, ^R]')) !


"August 23, 2009 -> 19:51:58"!

Delta define: #BlockWithThreeArguments as: (
Generic forAll: '(A1 contra) , (A2 contra) , (A3 contra) , (R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, A3, ^R]')) !


"August 23, 2009 -> 19:51:58"!

(Delta mirrorFor: #BlockWithThreeArguments)
comment: 
'(c) 1996-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.2 $'!


"August 23, 2009 -> 19:51:58"!

! (Delta mirrorFor: #BlockWithThreeArguments) methodsFor: 'arity' !
arity ^ <Integer>
	^3! !

"August 23, 2009 -> 19:51:58"!

! (Delta mirrorFor: #BlockWithThreeArguments) methodsFor: 'evaluating' !
value: arg1 <A1> value: arg2 <A2> value: arg3 <A3>
    "Block dispatch method (vm generated)"
    ^{{self primitiveValue: arg1 value: arg2 value: arg3}}! !

"August 23, 2009 -> 19:51:58"!

! (Delta mirrorFor: #BlockWithThreeArguments) methodsFor: 'evaluating' !
valueWithArguments: a <Array[Object]> ^ <R>
	self validateValues: a.
	^self value: (a at: 1) value: (a at: 2) value: (a at: 3)! !

"August 23, 2009 -> 19:52:4"!

Delta define: #BlockWithTwoArguments as: (
Generic forAll: '(A1 contra), (A2 contra) , (R covar)  ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, ^R]')) !


"August 23, 2009 -> 19:52:4"!

Delta define: #BlockWithTwoArguments as: (
Generic forAll: '(A1 contra), (A2 contra) , (R covar)  ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, ^R]')) !


"August 23, 2009 -> 19:52:4"!

Delta define: #BlockWithTwoArguments as: (
Generic forAll: '(A1 contra), (A2 contra) , (R covar)  ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, ^R]')) !


"August 23, 2009 -> 19:52:4"!

Delta define: #BlockWithTwoArguments as: (
Generic forAll: '(A1 contra), (A2 contra) , (R covar)  ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, ^R]')) !


"August 23, 2009 -> 19:52:4"!

Delta define: #BlockWithTwoArguments as: (
Generic forAll: '(A1 contra), (A2 contra) , (R covar)  ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, ^R]')) !


"August 23, 2009 -> 19:52:4"!

Delta define: #BlockWithTwoArguments as: (
Generic forAll: '(A1 contra), (A2 contra) , (R covar)  ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, ^R]')) !


"August 23, 2009 -> 19:52:4"!

Delta define: #BlockWithTwoArguments as: (
Generic forAll: '(A1 contra), (A2 contra) , (R covar)  ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, ^R]')) !


"August 23, 2009 -> 19:52:4"!

Delta define: #BlockWithTwoArguments as: (
Generic forAll: '(A1 contra), (A2 contra) , (R covar)  ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, ^R]')) !


"August 23, 2009 -> 19:52:4"!

Delta define: #BlockWithTwoArguments as: (
Generic forAll: '(A1 contra), (A2 contra) , (R covar)  ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, ^R]')) !


"August 23, 2009 -> 19:52:4"!

Delta define: #BlockWithTwoArguments as: (
Generic forAll: '(A1 contra), (A2 contra) , (R covar)  ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, ^R]')) !


"August 23, 2009 -> 19:52:4"!

Delta define: #BlockWithTwoArguments as: (
Generic forAll: '(A1 contra), (A2 contra) , (R covar)  ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, ^R]')) !


"August 23, 2009 -> 19:52:4"!

Delta define: #BlockWithTwoArguments as: (
Generic forAll: '(A1 contra), (A2 contra) , (R covar)  ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[A1, A2, ^R]')) !


"August 23, 2009 -> 19:52:4"!

(Delta mirrorFor: #BlockWithTwoArguments)
comment: 
'(c) 1996-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.2 $'!


"August 23, 2009 -> 19:52:4"!

! (Delta mirrorFor: #BlockWithTwoArguments) methodsFor: 'arity' !
arity ^ <Integer>
	^2! !

"August 23, 2009 -> 19:52:4"!

! (Delta mirrorFor: #BlockWithTwoArguments) methodsFor: 'evaluating' !
value: arg1 <A1> value: arg2 <A2>
    "Block dispatch method (vm generated)"
    ^{{self primitiveValue: arg1 value: arg2}}! !

"August 23, 2009 -> 19:52:4"!

! (Delta mirrorFor: #BlockWithTwoArguments) methodsFor: 'evaluating' !
valueWithArguments: a <Array[Object]> ^ <R>
	self validateValues: a.
	^self value: (a at: 1) value: (a at: 2)! !

"August 23, 2009 -> 19:52:39"!

"System saved" !
"August 23, 2009 -> 20:40:53"!

! (Delta mirrorFor: #Object) methodsFor: 'utility' !
value

	^self! !

"August 23, 2009 -> 20:40:59"!

"System saved" !
"August 29, 2009 -> 1:31:51"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedByteAt: index <Integer> ^<Integer>

	^{{self primitiveSignedByteAt: index
				ifFail: [:err| self error: 'Unable to get signed byte'] }}! !

"August 29, 2009 -> 1:31:51"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedByteAt: index <Integer> ^<Integer>

	^{{self primitiveAlienSignedByteAt: index
				ifFail: [:err| self error: 'Unable to get signed byte'] }}! !

"August 29, 2009 -> 1:31:51"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
new: size <Integer> ^ <X>

	^(self primitiveNew: size + 4)
		size: size;
		initialize! !

"August 29, 2009 -> 1:31:51"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
size: anInteger <Integer>

	{{self primitiveAlienSize: anInteger
				ifFail: [:err| self error: 'failed to set alien size: ', err] }}! !

"August 29, 2009 -> 1:31:51"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
size ^<Integer>

	^{{self primitiveAlienSizeifFail: [:err| self error: 'failed to get alien size: ', err] }}! !

"August 29, 2009 -> 1:31:51"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedByteAt: index <Integer> ^<Integer>

	^{{self primitiveSignedByteAt: index
				ifFail: [:err| self error: 'Unable to get signed byte'] }}! !

"August 29, 2009 -> 1:31:51"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedByteAt: index <Integer> ^<Integer>

	^{{self primitiveAlienSignedByteAt: index
				ifFail: [:err| self error: 'Unable to get signed byte'] }}! !

"August 29, 2009 -> 1:31:51"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
new: size <Integer> ^ <X>

	^(self primitiveNew: size + 4)
		size: size;
		initialize! !

"August 29, 2009 -> 1:31:51"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
size: anInteger <Integer>

	{{self primitiveAlienSize: anInteger
				ifFail: [:err| self error: 'failed to set alien size: ', err] }}! !

"August 29, 2009 -> 1:31:51"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
size ^<Integer>

	^{{self primitiveAlienSizeifFail: [:err| self error: 'failed to get alien size: ', err] }}! !

"August 29, 2009 -> 1:31:51"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
addressField ^<Integer>

	^{{ self primitiveAlienAddressIfFail: [:err| self error: 'failed to get address of alien ', err] }}! !

"August 29, 2009 -> 1:31:51"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
addressField: anInteger <Integer>

	^{{ self primitiveAlienAddress: anInteger
					ifFail: [:err| self error: 'failed to set address of alien ', err] }}! !

"August 29, 2009 -> 1:32:25"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
size ^<Integer>

	^{{self primitiveAlienSizeIfFail: [:err| self error: 'failed to get alien size: ', err] }}! !

"August 29, 2009 -> 1:34:23"!

"System saved" !
"August 29, 2009 -> 1:38:0"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedByteAt: index <Integer> ^<Integer>

	^{{self primitiveAlienSignedByteAt: index
				ifFail: [:err| self error: 'Unable to get signed byte ', err] }}! !

"August 29, 2009 -> 1:38:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedByteAt: index <Integer> put: byte <Integer> ^<Integer>

	^{{self primitiveAlienSignedByteAt: index
				put: byte
				ifFail: [:err| self error: 'Unable to set signed byte ', err] }}! !

"August 29, 2009 -> 1:39:41"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedLongAt: index <Integer> ^<Integer>

	^{{self primitiveAlienSignedLongAt: index
				ifFail: [:err| self error: 'Unable to get signed long ', err] }}! !

"August 29, 2009 -> 1:40:15"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedLongAt: index <Integer> put: long <Integer>^<Integer>

	^{{self primitiveAlienSignedLongAt: index
				put: long
				ifFail: [:err| self error: 'Unable to get signed long ', err] }}! !

"August 29, 2009 -> 1:43:19"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> ^<Integer>

	^{{self primitiveAlienSignedShortAt: index
				ifFail: [:err| self error: 'Unable to get signed short ', err] }}! !

"August 29, 2009 -> 1:43:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> put: short <Integer> ^<Integer>

	^{{self primitiveAlienSignedShortAt: index
				put: short
				ifFail: [:err| self error: 'Unable to set signed short ', err] }}! !

"August 29, 2009 -> 1:44:13"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> ^<Integer>

	^{{self primitiveAlienUnsignedShortAt: index
				ifFail: [:err| self error: 'Unable to get unsigned short ', err] }}! !

"August 29, 2009 -> 1:44:31"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> put: short <Integer>^<Integer>

	^{{self primitiveAlienUnsignedShortAt: index
				put: short
				ifFail: [:err| self error: 'Unable to set unsigned short ', err] }}! !

"August 29, 2009 -> 1:44:55"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedByteAt: index <Integer> ^<Integer>

	^{{self primitiveAlienUnsignedByteAt: index
				ifFail: [:err| self error: 'Unable to get unsigned byte ', err] }}! !

"August 29, 2009 -> 1:45:20"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedByteAt: index <Integer> put: byte <Integer> ^<Integer>

	^{{self primitiveAlienUnsignedByteAt: index
				put: byte
				ifFail: [:err| self error: 'Unable to set unsigned byte ', err] }}! !

"August 29, 2009 -> 1:45:37"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedLongAt: index <Integer> ^<Integer>

	^{{self primitiveAlienUnsignedLongAt: index
				ifFail: [:err| self error: 'Unable to get unsigned long ', err] }}! !

"August 29, 2009 -> 1:45:56"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedLongAt: index <Integer> put: long <Integer>^<Integer>

	^{{self primitiveAlienUnsignedLongAt: index
				put: long
				ifFail: [:err| self error: 'Unable to set unsigned long ', err] }}! !

"August 29, 2009 -> 1:51:49"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedByteIndexOutOfRange

	self should: [self signedByteAt: 0] raise: Error! !

"August 29, 2009 -> 1:52:12"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedByteIndexOutOfRange

	self should: [self signedByteAt: 0] raise: Error.
	self should: [self signedByteAt: 5] raise: Error! !

"August 29, 2009 -> 1:53:53"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedShortIndexOutOfRange

	self should: [self signedShortAt: 0] raise: Error.
	self should: [self signedShortAt: 4] raise: Error! !

"August 29, 2009 -> 1:54:31"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedShortIndexOutOfRange

	self should: [self signedShortAt: 0 put: 1] raise: Error.
	self should: [self signedShortAt: 4 put: 1] raise: Error.
	self should: [self signedShortAt: 0] raise: Error.
	self should: [self signedShortAt: 4] raise: Error! !

"August 29, 2009 -> 1:55:2"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedByteIndexOutOfRange

	self should: [self signedByteAt: 0] raise: Error.
	self should: [self signedByteAt: 5] raise: Error.
	self should: [self signedByteAt: 0 put: 1] raise: Error.
	self should: [self signedByteAt: 5 put: 1] raise: Error! !

"August 29, 2009 -> 1:55:42"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedLongIndexOutOfRange

	self should: [self signedLongAt: 0] raise: Error.
	self should: [self signedLongAt: 2] raise: Error.
	self should: [self signedLongAt: 0 put: 1] raise: Error.
	self should: [self signedLongAt: 2 put: 1] raise: Error! !

"August 29, 2009 -> 1:56:18"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedLongIndexOutOfRange

	self should: [self unsignedLongAt: 0] raise: Error.
	self should: [self unsignedLongAt: 2] raise: Error.
	self should: [self unsignedLongAt: 0 put: 1] raise: Error.
	self should: [self unsignedLongAt: 2 put: 1] raise: Error! !

"August 29, 2009 -> 1:57:8"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedShortIndexOutOfRange

	self should: [self unsignedShortAt: 0 put: 1] raise: Error.
	self should: [self unsignedShortAt: 4 put: 1] raise: Error.
	self should: [self unsignedShortAt: 0] raise: Error.
	self should: [self unsignedShortAt: 4] raise: Error! !

"August 29, 2009 -> 1:57:41"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedByteIndexOutOfRange

	self should: [self unsignedByteAt: 0] raise: Error.
	self should: [self unsignedByteAt: 5] raise: Error.
	self should: [self unsignedByteAt: 0 put: 1] raise: Error.
	self should: [self unsignedByteAt: 5 put: 1] raise: Error! !

"August 29, 2009 -> 2:5:10"!

"System saved" !
"August 29, 2009 -> 14:59:34"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
rawNewC: size <Integer> ^ <X>

	^(self primitiveNew: 8)
		size: size negated;
		addressField: (self Cmalloc: size);
		initialize! !

"August 29, 2009 -> 14:59:35"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
newGC: size <Integer> ^<X>

	| alien address |
	alien := self primitiveNew: 8.
	alien size: size negated.
	address := self Ccalloc: size.
	GCMallocedAliens add: alien finalizing: address.
	^alien
		addressField: address;
		initialize
		! !

"August 29, 2009 -> 14:59:37"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
newC: size <Integer> ^ <X>

	^(self primitiveNew: 8)
		size: size negated;
		addressField: (self Ccalloc: size);
		initialize! !

"August 29, 2009 -> 14:59:40"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
atAddress: pointer <Integer> dataSize: dataSize <Integer> ^<X>

	^(self primitiveNew: 8)
		size: dataSize negated;
		addressField: pointer;
		yourself! !

"August 29, 2009 -> 15:0:6"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
forPointer: pointer <Integer> ^<X>

	^(self primitiveNew: 8)
		size: 0;
		addressField: pointer;
		yourself! !

"August 29, 2009 -> 15:1:37"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
atAddress: pointer <Integer> ^<X>

	^(self primitiveNew: 8)
		size: self dataSize negated;
		addressField: pointer;
		yourself! !

"August 29, 2009 -> 15:2:27"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: '') classVariables: 'GCMallocedAliens LoadedLibraries') !


"August 29, 2009 -> 15:3:37"!

"System saved" !
"August 29, 2009 -> 15:4:16"!

Delta define: #DirectAlienTest as: (
(Class subclassOf: 'AlienTest' instanceVariables: '')) !


"August 29, 2009 -> 15:4:37"!

! (Delta mirrorFor: #DirectAlienTest) methodsFor: 'fixture' !
setUp

	alien := Alien new: 4! !

"August 29, 2009 -> 15:5:9"!

! (Delta mirrorFor: #AlienTest) classSide methodsFor: 'test case' !
isAbstract

	^self == AlienTest! !

"August 29, 2009 -> 15:5:26"!

(Delta mirrorFor: #AlienTest) removeMethod: #setUp ifAbsent: [] !


"August 29, 2009 -> 15:5:40"!

"System saved" !
"August 29, 2009 -> 15:6:33"!

Delta define: #IndirectAlienTest as: (
(Class subclassOf: 'AlienTest' instanceVariables: '')) !


"August 29, 2009 -> 15:6:59"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'fixture' !
setUp

	alien := Alien newC: 4! !

"August 29, 2009 -> 15:7:42"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'fixture' !
tearDown

	[alien free]
		on: Error
		do: [:ignore|]! !

"August 29, 2009 -> 15:8:18"!

"System saved" !
"August 29, 2009 -> 15:9:28"!

Delta define: #PointerAlienTest as: (
(Class subclassOf: 'AlienTest' instanceVariables: 'pointer')) !


"August 29, 2009 -> 15:9:28"!

Delta define: #PointerAlienTest as: (
(Class subclassOf: 'AlienTest' instanceVariables: 'pointer')) !


"August 29, 2009 -> 15:9:28"!

Delta define: #PointerAlienTest as: (
(Class subclassOf: 'AlienTest' instanceVariables: 'pointer')) !


"August 29, 2009 -> 15:9:28"!

Delta define: #PointerAlienTest as: (
(Class subclassOf: 'AlienTest' instanceVariables: 'pointer')) !


"August 29, 2009 -> 15:9:28"!

Delta define: #PointerAlienTest as: (
(Class subclassOf: 'AlienTest' instanceVariables: 'pointer')) !


"August 29, 2009 -> 15:9:28"!

Delta define: #PointerAlienTest as: (
(Class subclassOf: 'AlienTest' instanceVariables: 'pointer')) !


"August 29, 2009 -> 15:9:28"!

Delta define: #PointerAlienTest as: (
(Class subclassOf: 'AlienTest' instanceVariables: 'pointer')) !


"August 29, 2009 -> 15:9:28"!

Delta define: #PointerAlienTest as: (
(Class subclassOf: 'AlienTest' instanceVariables: 'pointer')) !


"August 29, 2009 -> 15:9:28"!

Delta define: #PointerAlienTest as: (
(Class subclassOf: 'AlienTest' instanceVariables: 'pointer')) !


"August 29, 2009 -> 15:9:28"!

Delta define: #PointerAlienTest as: (
(Class subclassOf: 'AlienTest' instanceVariables: 'pointer')) !


"August 29, 2009 -> 15:9:28"!

Delta define: #PointerAlienTest as: (
(Class subclassOf: 'AlienTest' instanceVariables: 'pointer')) !


"August 29, 2009 -> 15:9:43"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'fixture' !
setUp

	alien := pointer := Alien forPointer: (Alien Ccalloc: 4)! !

"August 29, 2009 -> 15:10:16"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'testing' !
testDataSize

	self assert: alien dataSize == 0! !

"August 29, 2009 -> 15:10:34"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'testing' !
testFreeingTwiceShouldFail

	alien free.
	self should: [alien free] raise: Error! !

"August 29, 2009 -> 15:10:41"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'testing' !
testIsPointer

	self assert: alien isPointer! !

"August 29, 2009 -> 15:10:49"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'fixture' !
tearDown

	[alien free]
		on: Error
		do: [:ignore|]! !

"August 29, 2009 -> 15:11:5"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'fixture' !
setUp

	alien := Alien forPointer: (Alien Ccalloc: 4)! !

"August 29, 2009 -> 15:11:13"!

Delta define: #PointerAlienTest as: (
(Class subclassOf: 'AlienTest' instanceVariables: '')) !


"August 29, 2009 -> 15:11:54"!

"System saved" !
"August 29, 2009 -> 15:27:19"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'fixture' !
dataSize

	^4! !

"August 29, 2009 -> 15:27:19"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'fixture' !
setUp

	alien := Alien newC: self dataSize! !

"August 29, 2009 -> 15:27:19"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'fixture' !
dataSize

	^4! !

"August 29, 2009 -> 15:27:20"!

! (Delta mirrorFor: #DirectAlienTest) methodsFor: 'fixture' !
setUp

	alien := Alien new: self dataSize! !

"August 29, 2009 -> 15:27:20"!

(Delta mirrorFor: #IndirectAlienTest) removeMethod: #dataSize ifAbsent: [] !


"August 29, 2009 -> 15:27:20"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'fixture' !
setUp

	alien := Alien forPointer: (Alien Ccalloc: self dataSize)! !

"August 29, 2009 -> 15:28:47"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'testing' !
testSignedByteIndexOutOfRange

	self should: [alien signedByteAt: 0] raise: Error.
	self should: [alien signedByteAt: 0 put: 1] raise: Error! !

"August 29, 2009 -> 15:29:12"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedByteIndexOutOfRange

	self should: [alien signedByteAt: 0] raise: Error.
	self should: [alien signedByteAt: 5] raise: Error.
	self should: [alien signedByteAt: 0 put: 1] raise: Error.
	self should: [alien signedByteAt: 5 put: 1] raise: Error! !

"August 29, 2009 -> 15:30:22"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'testing' !
testSignedLongIndexOutOfRange

	self should: [alien signedLongAt: 0] raise: Error.
	self should: [alien signedLongAt: 0 put: 1] raise: Error! !

"August 29, 2009 -> 15:30:42"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedLongIndexOutOfRange

	self should: [alien signedLongAt: 0] raise: Error.
	self should: [alien signedLongAt: 2] raise: Error.
	self should: [alien signedLongAt: 0 put: 1] raise: Error.
	self should: [alien signedLongAt: 2 put: 1] raise: Error! !

"August 29, 2009 -> 15:31:18"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'testing' !
testSignedShortIndexOutOfRange

	self should: [alien signedShortAt: 0 put: 1] raise: Error.
	self should: [alien signedShortAt: 0] raise: Error! !

"August 29, 2009 -> 15:31:47"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedShortIndexOutOfRange

	self should: [alien signedShortAt: 0 put: 1] raise: Error.
	self should: [alien signedShortAt: 4 put: 1] raise: Error.
	self should: [alien signedShortAt: 0] raise: Error.
	self should: [alien signedShortAt: 4] raise: Error! !

"August 29, 2009 -> 15:32:13"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'testing' !
testUnsignedByteIndexOutOfRange

	self should: [alien unsignedByteAt: 0] raise: Error.
	self should: [alien unsignedByteAt: 0 put: 1] raise: Error! !

"August 29, 2009 -> 15:32:32"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedByteIndexOutOfRange

	self should: [alien unsignedByteAt: 0] raise: Error.
	self should: [alien unsignedByteAt: 5] raise: Error.
	self should: [alien unsignedByteAt: 0 put: 1] raise: Error.
	self should: [alien unsignedByteAt: 5 put: 1] raise: Error! !

"August 29, 2009 -> 15:32:59"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'testing' !
testUnsignedLongIndexOutOfRange

	self should: [alien unsignedLongAt: 0] raise: Error.
	self should: [alien unsignedLongAt: 0 put: 1] raise: Error! !

"August 29, 2009 -> 15:33:21"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedLongIndexOutOfRange

	self should: [alien unsignedLongAt: 0] raise: Error.
	self should: [alien unsignedLongAt: 2] raise: Error.
	self should: [alien unsignedLongAt: 0 put: 1] raise: Error.
	self should: [alien unsignedLongAt: 2 put: 1] raise: Error! !

"August 29, 2009 -> 15:34:0"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'testing' !
testUnsignedShortIndexOutOfRange

	self should: [alien unsignedShortAt: 0 put: 1] raise: Error.
	self should: [alien unsignedShortAt: 0] raise: Error! !

"August 29, 2009 -> 15:34:39"!

"System saved" !
"August 29, 2009 -> 15:35:36"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedByteIndexOutOfRange

	self should: [alien signedByteAt: 0] raise: Error.
	self should: [alien signedByteAt: self dataSize + 1] raise: Error.
	self should: [alien signedByteAt: 0 put: 1] raise: Error.
	self should: [alien signedByteAt: self dataSize + 1 put: 1] raise: Error! !

"August 29, 2009 -> 15:35:55"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedByteIndexOutOfRange

	self should: [alien unsignedByteAt: 0] raise: Error.
	self should: [alien unsignedByteAt: self dataSize + 1] raise: Error.
	self should: [alien unsignedByteAt: 0 put: 1] raise: Error.
	self should: [alien unsignedByteAt: self dataSize + 1 put: 1] raise: Error! !

"August 29, 2009 -> 15:36:15"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedShortIndexOutOfRange

	self should: [self unsignedShortAt: 0 put: 1] raise: Error.
	self should: [self unsignedShortAt: self dataSize put: 1] raise: Error.
	self should: [self unsignedShortAt: 0] raise: Error.
	self should: [self unsignedShortAt: self dataSize] raise: Error! !

"August 29, 2009 -> 15:36:37"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedShortIndexOutOfRange

	self should: [alien signedShortAt: 0 put: 1] raise: Error.
	self should: [alien signedShortAt: self dataSize put: 1] raise: Error.
	self should: [alien signedShortAt: 0] raise: Error.
	self should: [alien signedShortAt: self dataSize] raise: Error! !

"August 29, 2009 -> 15:37:3"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedLongIndexOutOfRange

	self should: [alien unsignedLongAt: 0] raise: Error.
	self should: [alien unsignedLongAt: self dataSize - 3] raise: Error.
	self should: [alien unsignedLongAt: 0 put: 1] raise: Error.
	self should: [alien unsignedLongAt: self dataSize - 3 put: 1] raise: Error! !

"August 29, 2009 -> 15:37:16"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testUnsignedLongIndexOutOfRange

	self should: [alien unsignedLongAt: 0] raise: Error.
	self should: [alien unsignedLongAt: self dataSize - 2] raise: Error.
	self should: [alien unsignedLongAt: 0 put: 1] raise: Error.
	self should: [alien unsignedLongAt: self dataSize - 2 put: 1] raise: Error! !

"August 29, 2009 -> 15:37:33"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testSignedLongIndexOutOfRange

	self should: [alien signedLongAt: 0] raise: Error.
	self should: [alien signedLongAt: self dataSize - 2] raise: Error.
	self should: [alien signedLongAt: 0 put: 1] raise: Error.
	self should: [alien signedLongAt: self dataSize - 2 put: 1] raise: Error! !

"August 29, 2009 -> 15:38:3"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'fixture' !
dataSize

	^8! !

"August 29, 2009 -> 15:38:18"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testDataSize

	self assert: alien dataSize == self dataSize! !

"August 29, 2009 -> 15:39:11"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testDoubleAccess

	alien doubleAt: 1 put: 1.0! !

"August 29, 2009 -> 15:40:10"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
doubleAt: index <Integer> put: double <Float> ^<Integer>

	^{{self primitiveAlienDoubleAt: index
				put: double
				ifFail: [:err| self error: 'Unable to set double ', err] }}! !

"August 29, 2009 -> 15:40:45"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testDoubleAccess

	alien doubleAt: 1 put: 1.0.
	self assert: (alien doubleAt: 1) = 1.0! !

"August 29, 2009 -> 15:41:13"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
doubleAt: index <Integer> ^<Integer>

	^{{self primitiveAlienDoubleAt: index
				ifFail: [:err| self error: 'Unable to get double ', err] }}! !

"August 29, 2009 -> 15:41:43"!

"System saved" !
"August 29, 2009 -> 15:44:52"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testDoubleIndexOutOfRange

	self should: [alien doubleAt: 0 put: 1.0] raise: Error.
	self should: [alien doubleAt: 0] raise: Error! !

"August 29, 2009 -> 15:45:15"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'testing' !
testDoubleIndexOutOfRange

	self should: [alien doubleAt: 0 put: 1.0] raise: Error.
	self should: [alien doubleAt: 0] raise: Error! !

"August 29, 2009 -> 15:45:42"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testDoubleIndexOutOfRange

	self should: [alien doubleAt: 0 put: 1.0] raise: Error.
	self should: [alien doubleAt: self dataSize - 6 put: 1.0] raise: Error.
	self should: [alien doubleAt: 0] raise: Error! !

"August 29, 2009 -> 15:46:0"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testDoubleIndexOutOfRange

	self should: [alien doubleAt: 0 put: 1.0] raise: Error.
	self should: [alien doubleAt: self dataSize - 6 put: 1.0] raise: Error.
	self should: [alien doubleAt: self dataSize - 6] raise: Error.
	self should: [alien doubleAt: 0] raise: Error! !

"August 29, 2009 -> 15:47:37"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testFloatAccess

	alien floatAt: 1 put: 1.0.
	self assert: (alien floatAt: 1) = 1.0! !

"August 29, 2009 -> 15:48:3"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
floatAt: index <Integer> put: double <Float> ^<Integer>

	^{{self primitiveAlienFloatAt: index
				put: double
				ifFail: [:err| self error: 'Unable to set float ', err] }}! !

"August 29, 2009 -> 15:48:29"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
floatAt: index <Integer> ^<Double>

	^{{self primitiveAlienFloatAt: index
				ifFail: [:err| self error: 'Unable to get float ', err] }}! !

"August 29, 2009 -> 15:48:37"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
floatAt: index <Integer> put: double <Float> ^<Float>

	^{{self primitiveAlienFloatAt: index
				put: double
				ifFail: [:err| self error: 'Unable to set float ', err] }}! !

"August 29, 2009 -> 15:48:44"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
doubleAt: index <Integer> put: double <Float> ^<Float>

	^{{self primitiveAlienDoubleAt: index
				put: double
				ifFail: [:err| self error: 'Unable to set double ', err] }}! !

"August 29, 2009 -> 15:48:50"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
doubleAt: index <Integer> ^<Float>

	^{{self primitiveAlienDoubleAt: index
				ifFail: [:err| self error: 'Unable to get double ', err] }}! !

"August 29, 2009 -> 15:49:45"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testFloatAccess

	alien floatAt: 1 put: 1.0.
	self assert: (alien floatAt: 1) = 1.0.
	alien floatAt: 1 put: 1.23456.
	self assert: (alien floatAt: 1) = 1.23456! !

"August 29, 2009 -> 15:50:31"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testFloatAccess

	alien floatAt: 1 put: 1.0.
	self assert: (alien floatAt: 1) = 1.0.
	alien floatAt: 1 put: 1.23456.
	self assert: ((alien floatAt: 1) - 1.23456) abs < 0.000001! !

"August 29, 2009 -> 15:50:51"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testFloatAccess

	alien floatAt: 1 put: 1.0.
	self assert: (alien floatAt: 1) = 1.0.
	alien floatAt: 1 put: 1.23456.
	self assert: ((alien floatAt: 1) - 1.23456) abs < 0.0000001! !

"August 29, 2009 -> 15:50:56"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testFloatAccess

	alien floatAt: 1 put: 1.0.
	self assert: (alien floatAt: 1) = 1.0.
	alien floatAt: 1 put: 1.23456.
	self assert: ((alien floatAt: 1) - 1.23456) abs < 0.00000001! !

"August 29, 2009 -> 15:51:2"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testFloatAccess

	alien floatAt: 1 put: 1.0.
	self assert: (alien floatAt: 1) = 1.0.
	alien floatAt: 1 put: 1.23456.
	self assert: ((alien floatAt: 1) - 1.23456) abs < 0.0000001! !

"August 29, 2009 -> 15:51:32"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testDoubleAccess

	alien doubleAt: 1 put: 1.0.
	self assert: (alien doubleAt: 1) = 1.0.
	alien doubleAt: 1 put: 1.23456.
	self assert: ((alien doubleAt: 1) - 1.23456) abs < 0.0000001! !

"August 29, 2009 -> 15:51:41"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testDoubleAccess

	alien doubleAt: 1 put: 1.0.
	self assert: (alien doubleAt: 1) = 1.0.
	alien doubleAt: 1 put: 1.23456.
	self assert: ((alien doubleAt: 1) - 1.23456) abs < 0.00000000001! !

"August 29, 2009 -> 15:51:48"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testDoubleAccess

	alien doubleAt: 1 put: 1.0.
	self assert: (alien doubleAt: 1) = 1.0.
	alien doubleAt: 1 put: 1.23456.
	self assert: ((alien doubleAt: 1) - 1.23456) abs < 0.000000000001! !

"August 29, 2009 -> 15:52:25"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testFloatAccess

	alien floatAt: 1 put: 1.0.
	self assert: (alien floatAt: 1) = 1.0.
	alien floatAt: 1 put: 1.23456.
	self assert: ((alien floatAt: 1) - 1.23456) abs < 0.0000001.
	self deny: ((alien floatAt: 1) - 1.23456) abs < 0.00000001! !

"August 29, 2009 -> 15:53:8"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testFloatIndexOutOfRange

	self should: [alien doubleAt: 0 put: 1.0] raise: Error.
	self should: [alien doubleAt: self dataSize - 6 put: 1.0] raise: Error.
	self should: [alien doubleAt: self dataSize - 6] raise: Error.
	self should: [alien doubleAt: 0] raise: Error! !

"August 29, 2009 -> 15:53:30"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'testing' !
testFloatIndexOutOfRange

	self should: [alien doubleAt: 0 put: 1.0] raise: Error.
	self should: [alien doubleAt: 0] raise: Error! !

"August 29, 2009 -> 15:57:37"!

"System saved" !
"August 29, 2009 -> 19:35:22"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testFreeAfter

	|arg|
	alien freeAfter: [:buf| arg := buf].
	self assert: alien == arg! !

"August 29, 2009 -> 19:35:22"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
freeAfter: aBlock <[Alien]>

	[aBlock value: self]
		value! !

"August 29, 2009 -> 19:35:22"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testFreeAfter

	|arg|
	self deny: alien address == 0.
	alien freeAfter: [:buf| arg := buf].
	self assert: alien == arg! !

"August 29, 2009 -> 19:35:22"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testFreeAfter

	|arg|
	self deny: alien address == 0.
	alien freeAfter: [:buf| arg := buf].
	self assert: alien == arg.
	self assert: alien address == 0! !

"August 29, 2009 -> 19:35:22"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
freeAfter: aBlock <[Alien]>

	[aBlock value: self]
		ensure: [self free]! !

"August 29, 2009 -> 19:35:22"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testPointer

	|pointer|
	pointer := alien pointer.
	self assert: pointer address == alien address.
	self assert: pointer size == 0! !

"August 29, 2009 -> 19:35:22"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
pointer

	^self class forPointer: self address! !

"August 29, 2009 -> 19:35:22"!

! (Delta mirrorFor: #DirectAlienTest) methodsFor: 'testing' !
testPointer

	self should: [alien pointer] raise: Error! !

"August 29, 2009 -> 19:35:22"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'testing' !
testPointer

	self should: [alien pointer] raise: Error! !

"August 29, 2009 -> 19:35:22"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
pointer

	self isPointer ifTrue: [self error:  'One cannot take the address of pointer Alien instances; they may move, and are already pointers'].
	^self class forPointer: self address! !

"August 29, 2009 -> 19:35:22"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testReplaceFrom

	|replacement|
	replacement := '12345678'.
	alien replaceFrom: 1 to: self dataSize with: replacement startingAt: 1.
	1 to: self dataSize do: [:i|
		self assert: (replacement at: i) == (Character value: (alien unsignedByteAt: i))
			description: 'Wrong value at ', i printString]! !

"August 29, 2009 -> 19:35:22"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
replaceFrom: start <Integer> to: stop <Integer> with: replacement <Alien|IndexedByteInstanceVariables> startingAt: replacementStart <Integer> ^ <self>

	! !

"August 29, 2009 -> 19:35:22"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
replaceFrom: start <Integer>
to: stop <Integer>
with: replacement <Alien|IndexedByteInstanceVariables>
startingAt: replacementStart <Integer> ^ <self>

	! !

"August 29, 2009 -> 19:35:22"!

(Delta mirrorFor: #Alien) removeMethod: #replaceFrom:to:with:startingAt: ifAbsent: [] !


"August 29, 2009 -> 19:35:22"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testReplaceFrom

	|replacement|
	replacement := ByteArray with: 1 with: 2 with: 3.
	alien replaceFrom: 1 to: 3 with: replacement startingAt: 1.
	1 to: self dataSize do: [:i|
		self assert: (replacement at: i) == (alien unsignedByteAt: i)
			description: 'Wrong value at ', i printString]! !

"August 29, 2009 -> 19:35:22"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testReplaceFrom

	|replacement|
	replacement := ByteArray withAll: #(1 2 3).
	alien replaceFrom: 1 to: 3 with: replacement startingAt: 1.
	1 to: self dataSize do: [:i|
		self assert: (replacement at: i) == (alien unsignedByteAt: i)
			description: 'Wrong value at ', i printString]! !

"August 29, 2009 -> 19:35:22"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
at: index <Integer> put: byte <SmallInteger> ^ <SmallInteger>

	^self signedByteAt: index put: byte! !

"August 29, 2009 -> 19:35:22"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testReplaceFrom

	|replacement|
	replacement := ByteArray withAll: #(1 2 3).
	alien replaceFrom: 1 to: 3 with: replacement startingAt: 1.
	1 to: 3 do: [:i|
		self assert: (replacement at: i) == (alien unsignedByteAt: i)
			description: 'Wrong value at ', i printString]! !

"August 29, 2009 -> 19:35:22"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
at: index <Integer> ^ <SmallInteger>

	^self signedByteAt: index! !

"August 29, 2009 -> 19:35:22"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testReplaceFrom

	|replacement|
	replacement := ByteArray withAll: #(1 2 3).
	alien replaceFrom: 1 to: 3 with: replacement startingAt: 1.
	1 to: 3 do: [:i|
		self assert: (replacement at: i) == (alien at: i)
			description: 'Wrong value at ', i printString]! !

"August 29, 2009 -> 19:37:28"!

"System saved" !
"August 30, 2009 -> 20:44:41"!

! (Delta mirrorFor: #Character) classSide methodsFor: 'constants' !
null ^<Character>
	"carriage-return"

	"%note: There should be an entry for all constants in #constantNameIfNone:"

	^self value: 0! !

"August 30, 2009 -> 20:45:8"!

! (Delta mirrorFor: #Character) classSide methodsFor: 'constants' !
nul ^<Character>
	"carriage-return"

	"%note: There should be an entry for all constants in #constantNameIfNone:"

	^self value: 0! !

"August 30, 2009 -> 20:45:14"!

! (Delta mirrorFor: #Character) methodsFor: 'printing' !
constantNameIfNone: blk <[^Str]> ^<Str>

	self = Character cr
		ifTrue: [ ^'cr' ].
	self = Character formFeed
		ifTrue: [ ^'formFeed' ].
	self = Character lf
		ifTrue: [ ^'lf' ].
	self = Character space
		ifTrue: [ ^'space' ].
	self = Character tab
		ifTrue: [ ^'tab' ].
	self = Character nul
		ifTrue: [ ^'nul' ].
	^blk value! !

"August 30, 2009 -> 20:45:18"!

(Delta mirrorFor: #Character) classSide removeMethod: #null ifAbsent: [] !


"August 30, 2009 -> 20:47:33"!

"System saved" !
"August 30, 2009 -> 22:42:41"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testReplaceFrom

	|replacement|
	replacement := ByteArray withAll: #(1 2 255).
	alien replaceFrom: 1 to: 3 with: replacement startingAt: 1.
	1 to: 3 do: [:i|
		self assert: (replacement at: i) == (alien at: i)
			description: 'Wrong value at ', i printString]! !

"August 30, 2009 -> 22:42:41"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
at: index <Integer> put: byte <SmallInteger> ^ <SmallInteger>

	^self unsignedByteAt: index put: byte! !

"August 30, 2009 -> 22:42:41"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
at: index <Integer> ^ <SmallInteger>

	^self unsignedByteAt: index! !

"August 30, 2009 -> 22:42:41"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testReplaceFromToWithStartingAt

	|replacement|
	replacement := ByteArray withAll: #(1 2 255).
	alien replaceFrom: 1 to: 3 with: replacement startingAt: 1.
	1 to: 3 do: [:i|
		self assert: (replacement at: i) == (alien at: i)
			description: 'Wrong value at ', i printString]! !

"August 30, 2009 -> 22:42:41"!

(Delta mirrorFor: #IndirectAlienTest) removeMethod: #testReplaceFrom ifAbsent: [] !


"August 30, 2009 -> 22:42:41"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testReplaceFromToWithStartingAt

	|replacement|
	replacement := ByteArray withAll: #(1 2 255).
	
	alien replaceFrom: 1 to: 3 with: replacement startingAt: 1.
	1 to: 3 do: [:i|
		self assert: (replacement at: i) == (alien at: i)
			description: 'Wrong value at ', i printString].
			
	alien replaceFrom: 2 to: 4 with: replacement startingAt: 1.
	1 to: 3 do: [:i|
		self assert: (replacement at: i) == (alien at: i + 1)
			description: 'Wrong value at ', i printString].! !

"August 30, 2009 -> 22:42:41"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testReplaceFromToWithStartingAt

	|replacement|
	replacement := ByteArray withAll: #(1 2 255).
	
	alien replaceFrom: 1 to: 3 with: replacement startingAt: 1.
	1 to: 3 do: [:i|
		self assert: (replacement at: i) == (alien unsignedAt: i)
			description: 'Wrong value at ', i printString].
			
	alien replaceFrom: 2 to: 4 with: replacement startingAt: 1.
	1 to: 3 do: [:i|
		self assert: (replacement at: i) == (alien unsignedAt: i + 1)
			description: 'Wrong value at ', i printString].! !

"August 30, 2009 -> 22:42:41"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testReplaceFromToWithStartingAt

	|replacement|
	replacement := ByteArray withAll: #(1 2 255).
	
	alien replaceFrom: 1 to: 3 with: replacement startingAt: 1.
	1 to: 3 do: [:i|
		self assert: (replacement at: i) == (alien unsignedByteAt: i)
			description: 'Wrong value at ', i printString].
			
	alien replaceFrom: 2 to: 4 with: replacement startingAt: 1.
	1 to: 3 do: [:i|
		self assert: (replacement at: i) == (alien unsignedByteAt: i + 1)
			description: 'Wrong value at ', i printString].! !

"August 30, 2009 -> 22:42:41"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testReplaceFromToWithStartingAtWithSymbol

	|replacement|
	replacement := #'123'.
	
	alien replaceFrom: 1 to: 3 with: replacement startingAt: 1.
	1 to: 3 do: [:i|
		self assert: (replacement at: i) == (alien unsignedByteAt: i)
			description: 'Wrong value at ', i printString].
			
	alien replaceFrom: 2 to: 4 with: replacement startingAt: 1.
	1 to: 3 do: [:i|
		self assert: (replacement at: i) == (alien unsignedByteAt: i + 1)
			description: 'Wrong value at ', i printString].! !

"August 30, 2009 -> 22:42:41"!

Delta define: #CharacterTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 30, 2009 -> 22:42:41"!

! (Delta mirrorFor: #CharacterTest) methodsFor: 'testing' !
testIsCharacter

	self assert: $A isCharacter.
	self deny: 1 isCharacter! !

"August 30, 2009 -> 22:42:41"!

(Delta mirrorFor: #IndirectAlienTest) removeMethod: #testReplaceFromToWithStartingAtWithSymbol ifAbsent: [] !


"August 30, 2009 -> 22:42:41"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testReplaceFromToWithStartingAt

	|replacement|
	replacement := ByteArray withAll: #(1 2 255).
	
	alien replaceFrom: 1 to: 3 with: replacement startingAt: 1.
	1 to: 3 do: [:i|
		self assert: (replacement at: i) == (alien unsignedByteAt: i)
			description: 'Wrong value at ', i printString].
			
	alien replaceFrom: 2 to: 4 with: replacement startingAt: 1.
	1 to: 3 do: [:i|
		self assert: (replacement at: i) == (alien unsignedByteAt: i + 1)
			description: 'Wrong value at ', i printString].! !

"August 30, 2009 -> 22:42:41"!

(Delta mirrorFor: #IndirectAlienTest) removeMethod: #testReplaceFromToWithStartingAt ifAbsent: [] !


"August 30, 2009 -> 22:42:41"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testStrcpy

	|contents|
	contents := #'12345678'.
	alien replaceFrom: 1 to: 8 with: (contents collect: [:c| c asciiValue]) startingAt: 1.! !

"August 30, 2009 -> 22:42:41"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testStrcpy

	|contents|
	contents := #'12345678'.
	alien replaceFrom: 1 to: 8 with: (contents collect: [:c| c asciiValue]) startingAt: 1.
	self assert: (contents asString = alien strcpy)! !

"August 30, 2009 -> 22:42:41"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strcpy

	|string|
	string := String new: self size.
	1 to: self size do: [:i|
		string at: i put: (Character value: (self unsignedByteAt: i))].
	^string! !

"August 30, 2009 -> 22:42:41"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strcpy

	|string|
	string := String new: self dataSize.
	1 to: self dataSize do: [:i|
		string at: i put: (Character value: (self unsignedByteAt: i))].
	^string! !

"August 30, 2009 -> 22:42:41"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testStrcpy

	|contents|
	contents := #'12345678'.
	alien replaceFrom: 1 to: 8 with: (contents collect: [:c| c asciiValue]) startingAt: 1.
	self assert: (contents asString = alien strcpy)
	
	alien unsignedByteAt: 5 put: 0.
	self assert: (contents asString copyFrom: 1 to: 4) = alien strcpy! !

"August 30, 2009 -> 22:42:41"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testStrcpy

	|contents|
	contents := #'12345678'.
	alien replaceFrom: 1 to: 8 with: (contents collect: [:c| c asciiValue]) startingAt: 1.
	self assert: (contents asString = alien strcpy).
	
	alien unsignedByteAt: 5 put: 0.
	self assert: (contents asString copyFrom: 1 to: 4) = alien strcpy! !

"August 30, 2009 -> 22:42:41"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strlen

	1 to: self dataSize do: [:i|	(self unsignedByteAt: i) == 0 ifTrue: [^ i - 1]].
	^self dataSize! !

"August 30, 2009 -> 22:42:41"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strcpy

	|string|
	string := String new: self strlen.
	1 to: self strlen do: [:i|
		string at: i put: (Character value: (self unsignedByteAt: i))].
	^string! !

"August 30, 2009 -> 22:42:41"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strcpy

	|string length|
	length := self strlen.
	string := String new: length.
	1 to: length do: [:i|
		string at: i put: (Character value: (self unsignedByteAt: i))].
	^string! !

"August 30, 2009 -> 22:42:41"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testStrcpyFrom

	|contents shortContents|
	contents := '12345678'.
	shortContents := contents asString copyFrom: 5 to: 8.
	alien replaceFrom: 1 to: 8 with: (contents collect: [:c| c asciiValue]) startingAt: 1.
	self assert: shortContents asString = (alien strcpyFrom: 5)! !

"August 30, 2009 -> 22:42:41"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strlenFrom: startIndex

	startIndex to: self dataSize do: [:i|	(self unsignedByteAt: i) == 0 ifTrue: [^ i - startIndex]].
	^self dataSize - startIndex! !

"August 30, 2009 -> 22:42:41"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strcpyFrom: startIndex

	|string length offset|
	length := self strlenFrom: startIndex.
	string := String new: length.
	offset := startIndex - 1.
	1 to: length do: [:i|
		string at: i put: (Character value: (self unsignedByteAt: i + offset))].
	^string! !

"August 30, 2009 -> 22:42:42"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testStrcpyFrom

	|contents shortContents actual|
	contents := '12345678'.
	shortContents := contents asString copyFrom: 5 to: 8.
	alien replaceFrom: 1 to: 8 with: (contents collect: [:c| c asciiValue]) startingAt: 1.
	actual := alien strcpyFrom: 5.
	self assert: shortContents asString = actual
		description: 'Expected :''',shortContents, ''', but was: ''',actual,''''! !

"August 30, 2009 -> 22:42:42"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strlenFrom: startIndex

	startIndex to: self dataSize do: [:i|	(self unsignedByteAt: i) == 0 ifTrue: [^ i - startIndex]].
	^self dataSize - startIndex + 1! !

"August 30, 2009 -> 22:42:42"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strcpy

	^self strcpyFrom: 1! !

"August 30, 2009 -> 22:42:42"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strlenStartingAt: startIndex

	startIndex to: self dataSize do: [:i|	(self unsignedByteAt: i) == 0 ifTrue: [^ i - startIndex]].
	^self dataSize - startIndex + 1! !

"August 30, 2009 -> 22:42:42"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testStrlen

	|contents|
	contents := #'12345678'.
	alien replaceFrom: 1 to: 8 with: (contents collect: [:c| c asciiValue]) startingAt: 1.
	self assert: alien strlen = 8! !

"August 30, 2009 -> 22:42:42"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strlen

	^self strlenStartingAt: 1! !

"August 30, 2009 -> 22:42:42"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strcpyFrom: startIndex

	|string length offset|
	length := self strlenStartingAt: startIndex.
	string := String new: length.
	offset := startIndex - 1.
	1 to: length do: [:i|
		string at: i put: (Character value: (self unsignedByteAt: i + offset))].
	^string! !

"August 30, 2009 -> 22:42:42"!

(Delta mirrorFor: #Alien) removeMethod: #strlenFrom: ifAbsent: [] !


"August 30, 2009 -> 22:42:42"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'testing' !
testStrcpy

	|contents|
	contents := #'12345678'.
	alien replaceFrom: 1 to: 7 with: (contents collect: [:c| c asciiValue]) startingAt: 1.
	alien unsignedByteAt: 8 put: 0.
	self assert: (contents asString copyFrom: 1 to: 7) = alien strcpy! !

"August 30, 2009 -> 22:42:42"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'testing' !
testStrcpy

	|contents actual expected|
	contents := #'12345678'.
	alien replaceFrom: 1 to: 7 with: (contents collect: [:c| c asciiValue]) startingAt: 1.
	alien unsignedByteAt: 8 put: 0.
	
	actual := alien strcpy.
	expected := contents asString copyFrom: 1 to: 7.
	self assert: expected = actual
		description: 'Expected: ''',expected,''', but was: ''',actual,''''! !

"August 30, 2009 -> 22:42:42"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strlenStartingAt: startIndex

	self dataSize == 0
		ifTrue: [|count|
					count := 1.
					[(self unsignedByteAt: count) == 0]
						whileFalse: [count := count + 1].
					^count - 1].
	startIndex to: self dataSize do: [:i| (self unsignedByteAt: i) == 0
																ifTrue: [^ i - startIndex]].
	^self dataSize - startIndex + 1! !

"August 30, 2009 -> 22:42:42"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
rawStrlenStartingAt: startIndex

	|count|
	count := 1.
	[(self unsignedByteAt: count) == 0]
		whileFalse: [count := count + 1].
	^count - 1! !

"August 30, 2009 -> 22:42:42"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strlenStartingAt: startIndex

	self dataSize == 0
		ifTrue: [^self rawStrlenStartingAt: 1].
	startIndex to: self dataSize do: [:i| (self unsignedByteAt: i) == 0
																ifTrue: [^ i - startIndex]].
	^self dataSize - startIndex + 1! !

"August 30, 2009 -> 22:42:42"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'testing' !
testStrcpyFrom

	|contents actual expected|
	contents := #'12345678'.
	alien replaceFrom: 1 to: 7 with: (contents collect: [:c| c asciiValue]) startingAt: 1.
	alien unsignedByteAt: 8 put: 0.
	
	actual := alien strcpyFrom: 3.
	expected := contents asString copyFrom: 3 to: 7.
	self assert: expected = actual
		description: 'Expected: ''',expected,''', but was: ''',actual,''''! !

"August 30, 2009 -> 22:43:5"!

"System saved" !
"August 30, 2009 -> 23:3:22"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
rawStrlenStartingAt: startIndex

	|index|
	index := startIndex.
	[(self unsignedByteAt: index) == 0]
		whileFalse: [index := index + 1].
	^index - startIndex! !

"August 30, 2009 -> 23:11:58"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'testing' !
testStrcpyFrom

	|contents actual expected|
	self halt.
	contents := #'12345678'.
	alien replaceFrom: 1 to: 7 with: (contents collect: [:c| c asciiValue]) startingAt: 1.
	alien unsignedByteAt: 8 put: 0.
	
	actual := alien strcpyFrom: 3.
	expected := contents asString copyFrom: 3 to: 7.
	self assert: expected = actual
		description: 'Expected: ''',expected,''', but was: ''',actual,''''! !

"August 30, 2009 -> 23:11:59"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'testing' !
testStrcpy

	|contents actual expected|
	self halt.
	contents := #'12345678'.
	alien replaceFrom: 1 to: 7 with: (contents collect: [:c| c asciiValue]) startingAt: 1.
	alien unsignedByteAt: 8 put: 0.
	
	actual := alien strcpy.
	expected := contents asString copyFrom: 1 to: 7.
	self assert: expected = actual
		description: 'Expected: ''',expected,''', but was: ''',actual,''''! !

"August 30, 2009 -> 23:19:34"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strlenStartingAt: startIndex

	self dataSize == 0
		ifTrue: [^self rawStrlenStartingAt: startIndex].
	startIndex to: self dataSize do: [:i| (self unsignedByteAt: i) == 0
																ifTrue: [^ i - startIndex]].
	^self dataSize - startIndex + 1! !

"August 30, 2009 -> 23:19:41"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'testing' !
testStrcpy

	|contents actual expected|
	contents := #'12345678'.
	alien replaceFrom: 1 to: 7 with: (contents collect: [:c| c asciiValue]) startingAt: 1.
	alien unsignedByteAt: 8 put: 0.
	
	actual := alien strcpy.
	expected := contents asString copyFrom: 1 to: 7.
	self assert: expected = actual
		description: 'Expected: ''',expected,''', but was: ''',actual,''''! !

"August 30, 2009 -> 23:19:51"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'testing' !
testStrcpyFrom

	|contents actual expected|
	contents := #'12345678'.
	alien replaceFrom: 1 to: 7 with: (contents collect: [:c| c asciiValue]) startingAt: 1.
	alien unsignedByteAt: 8 put: 0.
	
	actual := alien strcpyFrom: 3.
	expected := contents asString copyFrom: 3 to: 7.
	self assert: expected = actual
		description: 'Expected: ''',expected,''', but was: ''',actual,''''! !

"August 31, 2009 -> 0:9:43"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testReplaceFromToWithStartingAtWithString

	|replacement|
	replacement := '1234'.
	
	alien replaceFrom: 1 to: 4 with: replacement startingAt: 1.
	self assert: replacement = alien strcpy! !

"August 31, 2009 -> 0:34:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedByteAt: index <Integer> put: byte <Integer> ^<Integer>

	|c|
	c := byte isCharacter
				ifTrue: [byte asciiValue]
				ifFalse: [byte].
	^{{self primitiveAlienUnsignedByteAt: index
				put: c
				ifFail: [:err| self error: 'Unable to set unsigned byte ', err] }}! !

"August 31, 2009 -> 0:34:37"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedByteAt: index <Integer> put: byte <Integer|Character> ^<Integer>

	|c|
	c := byte isCharacter
				ifTrue: [byte asciiValue]
				ifFalse: [byte].
	^{{self primitiveAlienUnsignedByteAt: index
				put: c
				ifFail: [:err| self error: 'Unable to set unsigned byte ', err] }}! !

"August 31, 2009 -> 0:42:7"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testStrcpyUTF8

	|replacement|
	replacement := '1234'.
	
	alien replaceFrom: 1 to: 4 with: replacement startingAt: 1.
	self should: [alien strcpyUTF8]
		raise: Error
		withExceptionDo: [:ex| self assert: 'A hook for unimplemented code has been encountered' = ex message]! !

"August 31, 2009 -> 0:43:21"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testStrcpyUTF8Unimplemented

	|replacement|
	replacement := '1234'.
	
	alien replaceFrom: 1 to: 4 with: replacement startingAt: 1.
	self should: [alien strcpyUTF8]
		raise: Error
		withExceptionDo: [:ex| self assert: 'A hook for unimplemented code has been encountered' = ex messageText]! !

"August 31, 2009 -> 0:43:24"!

(Delta mirrorFor: #AlienTest) removeMethod: #testStrcpyUTF8 ifAbsent: [] !


"August 31, 2009 -> 0:44:1"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strcpyUTF8

	^self unimplemented! !

"August 31, 2009 -> 0:44:21"!

! (Delta mirrorFor: #AlienTest) methodsFor: 'testing' !
testStrcpyUTF8FromUnimplemented

	|replacement|
	replacement := '1234'.
	
	alien replaceFrom: 1 to: 4 with: replacement startingAt: 1.
	self should: [alien strcpyUTF8From: 1]
		raise: Error
		withExceptionDo: [:ex| self assert: 'A hook for unimplemented code has been encountered' = ex messageText]! !

"August 31, 2009 -> 0:44:33"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strcpyUTF8From: startIndex

	^self unimplemented! !

"August 31, 2009 -> 0:44:54"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strcpyUTF8

	^self strcpyFrom: 1! !

"August 31, 2009 -> 0:45:8"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strcpyUTF8

	^self strcpyUTF8From: 1! !

"August 31, 2009 -> 1:17:2"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testStrlenThroughPointerAt

	|contents|
	contents := '1234567'.
	alien replaceFrom: 1 to: 7 with: contents startingAt: 1.
	alien unsignedByteAt: 8 put: 0.
	(Alien newC: 4) freeAfter: [:pointer|
											pointer unsignedLongAt: 1 put: alien address.
											self assert: (pointer strlenThroughPointerAt: 1) == 7]! !

"August 31, 2009 -> 1:19:57"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
strlenThroughPointerAt: index

	^(Alien forPointer: (self unsignedLongAt: index))
		rawStrlenStartinAt: 1! !

"August 31, 2009 -> 1:20:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
strlenThroughPointerAt: index

	^(Alien forPointer: (self unsignedLongAt: index))
		rawStrlenStartingAt: 1! !

"August 31, 2009 -> 1:22:34"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testAutoFreeAfter

	|wasCalled|
	Alien autoFreeAfter: [:autoFree| wasCalled := true]! !

"August 31, 2009 -> 1:23:5"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testAutoFreeAfter

	|wasCalled|
	Alien autoFreeAfter: [:autoFree| wasCalled := true].
	self assert: wasCalled! !

"August 31, 2009 -> 1:24:51"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testAutoFreeAfter

	|wasCalled|
	Alien autoFreeAfter: [:autoFree|
									wasCalled := true.
									autoFree value: alien.
									self deny: alien address == 0].
	self assert: alien address == 0.
	self assert: wasCalled! !

"August 31, 2009 -> 1:25:50"!

! (Delta mirrorFor: #IndirectAlienTest) methodsFor: 'testing' !
testAutoFreeAfter

	|wasCalled toFree|
	Alien autoFreeAfter: [:autoFree|
									wasCalled := true.
									autoFree value: alien.
									self deny: alien address == 0.
									autoFree value: (toFree := Alien newC:4).
									self deny: alien address == 0].
	self assert: alien address == 0.
	self assert: alien address == 0.
	self assert: wasCalled! !

"August 31, 2009 -> 1:33:13"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'testing' !
testNewCString

	(Alien newCString: '12345678')
		freeAfter: [:pointer|
							self assert: 8 = pointer strlen.
							self assert: '12345678' = pointer strcpy]! !

"August 31, 2009 -> 1:35:18"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
newCString: string <String> ^ <Alien>

	^(Alien rawNewC: string size + 1)
		replaceFrom: 1
		to: string size
		with: string
		startingAt: 1;
		unsignedByteAt: string size + 1 put: 0;
		yourself! !

"August 31, 2009 -> 1:40:39"!

Delta define: #AlienClassTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 31, 2009 -> 1:41:29"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testNewCString

	(Alien newCString: '12345678')
		freeAfter: [:pointer|
							self assert: 8 = pointer strlen.
							self assert: '12345678' = pointer strcpy]! !

"August 31, 2009 -> 1:41:40"!

(Delta mirrorFor: #PointerAlienTest) removeMethod: #testNewCString ifAbsent: [] !


"August 31, 2009 -> 1:48:46"!

! (Delta mirrorFor: #ExternalProxy) methodsFor: 'accessing' !
asInteger ^<Int>
	"Like asSmallInteger, but can be used on ExternalData, since integers support this also,
		and it will eventually produce large integers when necessary"

	"%todo: enhance to support largeintegers when needed"
	^(self high << 16 + self low)! !

"August 31, 2009 -> 1:49:56"!

! (Delta mirrorFor: #ExternalProxy) methodsFor: 'accessing' !
asInteger ^<Int>
	"Like asSmallInteger, but can be used on ExternalData, since integers support this also,
		and it will eventually produce large integers when necessary"

	"%todo: enhance to support largeintegers when needed"
	^((self high bitShift: 16) + self low)! !

"August 31, 2009 -> 1:50:25"!

! (Delta mirrorFor: #ExternalProxy) methodsFor: 'accessing' !
asInteger ^<Int>
	"Like asSmallInteger, but can be used on ExternalData, since integers support this also,
		and it will eventually produce large integers when necessary"

	"%todo: enhance to support largeintegers when needed"
	^((self high asLargeInteger bitShift: 16) + self low)! !

"August 31, 2009 -> 1:51:7"!

! (Delta mirrorFor: #ExternalProxy) methodsFor: 'accessing' !
asInteger ^<Int>
	"Like asSmallInteger, but can be used on ExternalData, since integers support this also,
		and it will eventually produce large integers when necessary"

	"%todo: enhance to support largeintegers when needed"
	^((self high * 65536) + self low)! !

"August 31, 2009 -> 1:56:6"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testEnsureLoadedWin32

	|library|
	Platform == Win32Platform ifFalse: [^self].
	(Alien ensureLoaded: 'USER32.DLL')
		autoFreeAfter: [:library| |proxy|
								proxy := Platform DLLLoad: 'user'.
								self assert: library asUnsignedLong = proxy asInteger]
								! !

"August 31, 2009 -> 2:0:23"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
ensureLoaded: libraryName

	|proxy|
	proxy := ExternalProxy new.
	{{primitiveDLLLoad: libraryName result: proxy ifFail: [:err|] }}.
	^(Alien new: 4)
			unsignedLongAt: 1 put: proxy asInteger;
			yourself! !

"August 31, 2009 -> 2:1:52"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testEnsureLoadedWin32

	|library proxy|
	Platform == Win32Platform ifFalse: [^self].
	proxy := Platform DLLLoad: 'user'.
	library := Alien ensureLoaded: 'USER32.DLL'.
	self assert: library asUnsignedLong = proxy asInteger
								! !

"August 31, 2009 -> 2:2:37"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testEnsureLoadedWin32

	|library proxy|
	Platform == Win32Platform ifFalse: [^self].
	proxy := Platform DLLLoad: 'user'.
	library := Alien ensureLoaded: 'USER32.DLL'.
	self assert: library asUnsignedLong = proxy asInteger.
	self assert: library == (Alien ensureLoaded: 'USER32.DLL')! !

"August 31, 2009 -> 2:4:3"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
ensureLoaded: libraryName

	^LoadedLibraries
		at: libraryName
		ifAbsentPut: [|proxy|
							proxy := ExternalProxy new.
							{{primitiveDLLLoad: libraryName result: proxy ifFail: [:err|] }}.
							(Alien new: 4)
								unsignedLongAt: 1 put: proxy asInteger;
								yourself]! !

"August 31, 2009 -> 2:16:11"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'private - accessing' !
loadedLibraries

	LoadedLibraries isNil ifTrue: 
		[LoadedLibraries := Dictionary new].
	^LoadedLibraries! !

"August 31, 2009 -> 2:16:26"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
ensureLoaded: libraryName

	^self loadedLibraries
		at: libraryName
		ifAbsentPut: [|proxy|
							proxy := ExternalProxy new.
							{{primitiveDLLLoad: libraryName result: proxy ifFail: [:err|] }}.
							(Alien new: 4)
								unsignedLongAt: 1 put: proxy asInteger;
								yourself]! !

"August 31, 2009 -> 2:19:34"!

Delta define: #DictionaryTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 31, 2009 -> 2:22:28"!

! (Delta mirrorFor: #DictionaryTest) methodsFor: 'testing' !
testAtIfAbsentPut

	|dict|
	dict := Dictionary new.
	self assert: (dict at: 'a' ifAbsent: []) isNil.
	self assert: (dict at: 'a'
							ifAbsentPut: ['b']) = 'b'.
	self assert: (dict at: 'a'
							ifAbsentPut: ['c']) = 'b'
	! !

"August 31, 2009 -> 2:24:13"!

! (Delta mirrorFor: #HashedCollection) methodsFor: 'accessing' !
at: key <K> ifAbsentPut: block <[^X def]> ^ <E|X>

	! !

"August 31, 2009 -> 2:25:17"!

! (Delta mirrorFor: #HashedCollection) methodsFor: 'accessing' !
at: key <K> ifAbsentPut: block <[^X def]> ^ <E|X>

	^self at: key ifAbsent: [self at: key put: block value]! !

"August 31, 2009 -> 2:28:47"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'private - test support' !
unimplementedText

	[self unimplemented]
		on: Error
		do: [:ex|^ex messageText]! !

"August 31, 2009 -> 2:29:10"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testNewGCUnimplemented

	self should: [Alien newGC: 4]
		raise: Error
		withExceptionDo: [:ex| self assert: self unimplementedText = ex messageText]! !

"August 31, 2009 -> 2:30:1"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
newGC: size <Integer> ^<X>

	| alien address |
	self unimplemented.
	alien := self primitiveNew: 8.
	alien size: size negated.
	address := self Ccalloc: size.
	GCMallocedAliens add: alien finalizing: address.
	^alien
		addressField: address;
		initialize
		! !

"August 31, 2009 -> 2:32:23"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testPrimLoadLibraryWin32

	|library proxy|
	Platform == Win32Platform ifFalse: [^self].
	proxy := Platform DLLLoad: 'user'.
	library := Alien primLoadLibrary: 'USER32.DLL'.
	self assert: library = proxy asInteger! !

"August 31, 2009 -> 2:33:14"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
primLoadLibrary: libraryName

	|proxy|
	proxy := ExternalProxy new.
	{{primitiveDLLLoad: libraryName result: proxy ifFail: [:err|] }}.
	^proxy asInteger! !

"August 31, 2009 -> 2:35:56"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
ensureLoaded: libraryName

	^self loadedLibraries
		at: libraryName
		ifAbsentPut: [(Alien new: 4)
								unsignedLongAt: 1 put: (self primLoadLibrary: libraryName);
								yourself]! !

"August 31, 2009 -> 2:44:45"!

Delta define: #AlienLibraryTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 31, 2009 -> 2:45:0"!

! (Delta mirrorFor: #AlienLibraryTest) methodsFor: 'fixture' !
setUp

	! !

"August 31, 2009 -> 2:45:12"!

Delta define: #AlienLibraryTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'library')) !


"August 31, 2009 -> 2:46:33"!

! (Delta mirrorFor: #AlienLibraryTest) methodsFor: 'fixture' !
setUp

	self ensureWin32Or: [^self].
	library := Alien ensureLoaded: 'msvcrt.dll'
	! !

"August 31, 2009 -> 2:47:8"!

! (Delta mirrorFor: #AlienLibraryTest) methodsFor: 'fixture' !
ensureWin32Or: block

	Platform == Win32Platform
		ifFalse: [block value]! !

"August 31, 2009 -> 2:51:3"!

! (Delta mirrorFor: #AlienLibraryTest) methodsFor: 'testing' !
testPrimFindSymbol

	self ensureWin32Or: [^self].
	! !

"August 31, 2009 -> 2:52:52"!

"System saved" !
"August 31, 2009 -> 2:54:43"!

Delta define: #AlienLibraryTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'library proxy')) !


"August 31, 2009 -> 3:3:13"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLMapName: name <Str> ^<Str>
    name = 'user'       ifTrue: [^'USER32.DLL'].
    name = 'gdi'            ifTrue: [^'GDI32.DLL'].
    name = 'kernel'     ifTrue: [^'KERNEL32.DLL'].
    name = 'comdlg'     ifTrue: [^'COMDLG32.DLL'].
    "self error: 'Mapping ', name, ' not found'"
    ^name! !

"August 31, 2009 -> 3:4:27"!

Delta define: #AlienLibraryTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'library proxy address')) !


"August 31, 2009 -> 3:4:48"!

! (Delta mirrorFor: #AlienLibraryTest) methodsFor: 'fixture' !
setUp

	self ensureWin32Or: [^self].
	library := Alien ensureLoaded: 'msvcrt.dll'! !

"August 31, 2009 -> 3:6:9"!

! (Delta mirrorFor: #AlienLibraryTest) methodsFor: 'testing' !
testPrimFindSymbol

	self ensureWin32Or: [^self].
	self assert: (library primFindSymbol: 'sprintf')
						= (Platform DLLLookup: 'sprintf' in: 'msvcrt.dll') asInteger! !

"August 31, 2009 -> 3:11:25"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
primFindSymbol: symbolName <String> ^ <Integer>

	|result library|
	result := ExternalProxy new.
	library := ExternalProxy
						forHigh: (self unsignedShortAt: 3)
						low: (self unsignedShortAt: 1).
	{{primitiveDLLLookup: symbolName asSymbol
			in: library
			result: result
			ifFail: [:err | self error: err]}}.
	^result asInteger	! !

"August 31, 2009 -> 3:12:29"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
asExternalProxy ^<ExternalProxy>

	^ExternalProxy
		forHigh: (self unsignedShortAt: 3)
		low: (self unsignedShortAt: 1)! !

"August 31, 2009 -> 3:15:23"!

Delta define: #NotFoundError as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"August 31, 2009 -> 3:15:55"!

! (Delta mirrorFor: #AlienLibraryTest) methodsFor: 'testing' !
testPrimFindSymbolUnknown

	self ensureWin32Or: [^self].
	self should: (library primFindSymbol: 'unknownSymbol')
			raise: NotFoundError! !

"August 31, 2009 -> 3:16:47"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
primFindSymbol: symbolName <String> ^ <Integer>

	|result library|
	result := ExternalProxy new.
	library := ExternalProxy
						forHigh: (self unsignedShortAt: 3)
						low: (self unsignedShortAt: 1).
	{{primitiveDLLLookup: symbolName asSymbol
			in: library
			result: result
			ifFail: [:err | err == #NotFound
									ifTrue: [NotFoundError signal]
									ifFalse: [self error: err]]}}.
	^result asInteger	! !

"August 31, 2009 -> 3:21:5"!

! (Delta mirrorFor: #Error) methodsFor: 'priv handling' !
defaultAction

	Processor stopWithError: (ProcessExplicitError new msg: messageText isNil ifTrue: [''] ifFalse: [messageText])! !

"August 31, 2009 -> 3:21:25"!

! (Delta mirrorFor: #Error) methodsFor: 'priv handling' !
defaultAction

	Processor stopWithError: (ProcessExplicitError new msg: (messageText isNil ifTrue: [''] ifFalse: [messageText]))! !

"August 31, 2009 -> 3:22:57"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
messageText
"Return an exception's message text."
	^messageText isNil
		ifTrue: ['']
		ifFalse: [messageText]
		! !

"August 31, 2009 -> 3:23:16"!

! (Delta mirrorFor: #Error) methodsFor: 'priv handling' !
defaultAction

	Processor stopWithError: (ProcessExplicitError new msg: self messageText)! !

"August 31, 2009 -> 3:23:37"!

! (Delta mirrorFor: #AlienLibraryTest) methodsFor: 'testing' !
testPrimFindSymbolUnknown

	self ensureWin32Or: [^self].
	self should: [library primFindSymbol: 'unknownSymbol']
			raise: NotFoundError! !

"August 31, 2009 -> 3:28:24"!

"System saved" !
"August 31, 2009 -> 20:10:27"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
primFindSymbol: symbolName <String> ^ <Integer>

	|result library|
	result := ExternalProxy new.
	library := self asExternalProxy.
	{{primitiveDLLLookup: symbolName asSymbol
			in: library
			result: result
			ifFail: [:err | err == #NotFound
									ifTrue: [NotFoundError signal]
									ifFalse: [self error: err]]}}.
	^result asInteger	! !

"August 31, 2009 -> 20:10:27"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testLookupInLibraryWin32

	|function proxy|
	Platform == Win32Platform ifFalse: [^self].
	proxy := Platform DLLLookup: 'sprintf' in: 'msvcrt.dll'.
	function := Alien lookup: 'sprintf' inLibrary: 'msvcrt.dll'.
	self assert: function asUnsignedInteger = proxy asInteger! !

"August 31, 2009 -> 20:10:27"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'libraries' !
lookup: symbolName <String> inLibrary: libraryName <String> ^ <Alien>

	^(Alien primLoadLibrary: libraryName)
		primFindSymbol: symbolName! !

"August 31, 2009 -> 20:10:28"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'libraries' !
lookup: symbolName <String> inLibrary: libraryName <String> ^ <Alien>

	^(Alien forPointer: (Alien primLoadLibrary: libraryName))
		primFindSymbol: symbolName! !

"August 31, 2009 -> 20:10:28"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'libraries' !
lookup: symbolName <String> inLibrary: libraryName <String> ^ <Alien>

	^Alien forPointer: ((Alien ensureLoaded: libraryName)
										primFindSymbol: symbolName)! !

"August 31, 2009 -> 20:10:28"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'libraries' !
lookup: symbolName <String> inLibrary: libraryName <String> ^ <Alien>

	^self forPointer: ((Alien ensureLoaded: libraryName)
										primFindSymbol: symbolName)! !

"August 31, 2009 -> 20:10:28"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testLookupInLibraryWin32

	|function proxy|
	Platform == Win32Platform ifFalse: [^self].
	proxy := Platform DLLLookup: 'sprintf' in: 'msvcrt.dll'.
	function := Alien lookup: 'sprintf' inLibrary: 'msvcrt.dll'.
	self assert: function asUnsignedLong = proxy asInteger! !

"August 31, 2009 -> 20:10:28"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testLookupInLibraryWin32

	|function proxy|
	Platform == Win32Platform ifFalse: [^self].
	proxy := Platform DLLLookup: 'sprintf' in: 'msvcrt.dll'.
	function := Alien lookup: 'sprintf' inLibrary: 'msvcrt.dll'.
	self assert: function address = proxy asInteger! !

"August 31, 2009 -> 20:10:28"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testLookupOrNilInLibraryWin32

	|function proxy|
	Platform == Win32Platform ifFalse: [^self].
	proxy := Platform DLLLookup: 'sprintf' in: 'msvcrt.dll'.
	function := Alien lookup: 'sprintf' inLibrary: 'msvcrt.dll'.
	self assert: function address = proxy asInteger
	self assert: (Alien lookup: 'unknown' inLibrary: 'msvcrt.dll') isNil! !

"August 31, 2009 -> 20:10:28"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testLookupOrNilInLibraryWin32

	|function proxy|
	Platform == Win32Platform ifFalse: [^self].
	proxy := Platform DLLLookup: 'sprintf' in: 'msvcrt.dll'.
	function := Alien lookupOrNil: 'sprintf' inLibrary: 'msvcrt.dll'.
	self assert: function address = proxy asInteger
	self assert: (Alien lookupOrNil: 'unknown' inLibrary: 'msvcrt.dll') isNil! !

"August 31, 2009 -> 20:10:28"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'libraries' !
lookupOrNil: symbolName <String> inLibrary: libraryName <String> ^ <Alien>

	^[self lookupOrNil: symbolName inLibrary: libraryName]
			on: NotFoundError
			do: [:err| nil]! !

"August 31, 2009 -> 20:20:28"!

"System saved" !
"August 31, 2009 -> 20:23:25"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'libraries' !
lookupOrNil: symbolName <String> inLibrary: libraryName <String> ^ <Alien>

	^[self lookup: symbolName inLibrary: libraryName]
			on: NotFoundError
			do: [:err| nil]! !

"August 31, 2009 -> 20:24:20"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testLookupOrNilInLibraryWin32

	|function proxy|
	Platform == Win32Platform ifFalse: [^self].
	proxy := Platform DLLLookup: 'sprintf' in: 'msvcrt.dll'.
	function := Alien lookupOrNil: 'sprintf' inLibrary: 'msvcrt.dll'.
	self assert: function address = proxy asInteger.
	self assert: (Alien lookupOrNil: 'unknown' inLibrary: 'msvcrt.dll') isNil! !

"August 31, 2009 -> 20:53:29"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testLookupClockWin32

	|function proxy|
	Platform == Win32Platform ifFalse: [^self].
	function := Alien lookupOrNil: 'clock' inLibrary: 'msvcrt.dll'.
! !

"August 31, 2009 -> 20:53:41"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testLookupClockWin32

	|function proxy|
	Platform == Win32Platform ifFalse: [^self].
	function := Alien lookup: 'clock' inLibrary: 'msvcrt.dll'.
! !

"August 31, 2009 -> 20:54:8"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testLookupClockWin32

	|function proxy|
	Platform == Win32Platform ifFalse: [^self].
	function := Alien lookup: 'clock' inLibrary: 'msvcrt.dll'.
	function halt! !

"August 31, 2009 -> 20:55:30"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testLookupClockWin32

	|function result|
	Platform == Win32Platform ifFalse: [^self].
	function := Alien lookup: 'clock' inLibrary: 'msvcrt.dll'.
	result := Alien new: 8.
	function primFFICall: result! !

"August 31, 2009 -> 20:55:55"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testLookupClockWin32

	|function result|
	Platform == Win32Platform ifFalse: [^self].
	function := Alien lookup: 'clock' inLibrary: 'msvcrt.dll'.
	result := Alien new: 8.
	function primFFICallResult: result! !

"August 31, 2009 -> 20:56:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien>! !

"August 31, 2009 -> 21:0:17"!

"System saved" !
"September 1, 2009 -> 2:20:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien>

	{{primitiveAlienCallResult: result ifFail: [:err| self error: err]}}! !

"September 1, 2009 -> 2:20:17"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien>

	{{self primitiveAlienCallResult: result ifFail: [:err| self error: err]}}! !

"September 1, 2009 -> 2:37:50"!

"System saved" !
"September 7, 2009 -> 18:34:26"!

Delta define: #UndefinedObjectTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"September 7, 2009 -> 18:34:56"!

! (Delta mirrorFor: #UndefinedObjectTest) methodsFor: 'testing' !
testAsAlien

	self assert: nil asAlien == 0! !

"September 7, 2009 -> 18:35:52"!

! (Delta mirrorFor: #UndefinedObject) methodsFor: 'Aliens-converting' !
asAlien

	^0! !

"September 7, 2009 -> 18:37:0"!

Delta define: #AlienTrueTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"September 7, 2009 -> 18:37:24"!

! (Delta mirrorFor: #AlienTrueTest) methodsFor: 'testing' !
testAsAlien

	self assert: true asAlien == 1! !

"September 7, 2009 -> 18:38:33"!

! (Delta mirrorFor: #True) methodsFor: 'Aliens-converting' !
asAlien

	^1! !

"September 7, 2009 -> 18:38:50"!

Delta define: #AlienFalseTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"September 7, 2009 -> 18:39:12"!

! (Delta mirrorFor: #AlienFalseTest) methodsFor: 'testing' !
testAsAlien

	self assert: false asAlien == 0! !

"September 7, 2009 -> 18:39:50"!

! (Delta mirrorFor: #False) methodsFor: 'Aliens-converting' !
asAlien

	^0! !

"September 7, 2009 -> 18:40:49"!

Delta define: #AlienStringTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"September 7, 2009 -> 18:43:4"!

! (Delta mirrorFor: #AlienStringTest) methodsFor: 'testing' !
testAsAlien

	|alien|
	alien := '123456' asString.
	self assert: (alien size = 7).
	self assert: '123456' = alien strcpy
	! !

"September 7, 2009 -> 18:44:14"!

! (Delta mirrorFor: #AlienStringTest) methodsFor: 'testing' !
testAsAlien

	|alien|
	alien := '123456' asAlien.
	self assert: (alien size = 7).
	self assert: '123456' = alien strcpy
	! !

"September 7, 2009 -> 18:45:11"!

! (Delta mirrorFor: #AlienStringTest) methodsFor: 'testing' !
testAsAlien

	|alien string|
	string := '123456' asString.
	alien := string asAlien.
	self assert: (alien size = 7).
	self assert: string = alien strcpy
	! !

"September 7, 2009 -> 18:48:21"!

! (Delta mirrorFor: #AlienStringTest) methodsFor: 'testing' !
testAsAlien

	|alien string|
	string := '123456' asString.
	alien := string asAlien.
	self assert: (alien size abs = 7).
	self assert: string = alien strcpy
	! !

"September 7, 2009 -> 18:49:1"!

! (Delta mirrorFor: #String) methodsFor: 'Aliens-converting' !
asAlien

	^(Alien newC: self size + 1)
		replaceFrom: 1 to: self size with: self startingAt: 1
	! !

"September 7, 2009 -> 18:57:20"!

Delta define: #AlienFunctionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"September 7, 2009 -> 18:57:49"!

Delta define: #AlienFunctionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'function')) !


"September 7, 2009 -> 18:59:17"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'private - test support' !
ensureWin32Or: block

	Platform == Win32Platform
		ifFalse: [block value]! !

"September 7, 2009 -> 18:59:36"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'fixture' !
setUp

	self ensureWin32Or: [^self].
	function := Alien 
							lookup: 'sprintf'
							inLibrary: 'msvcrt.dll'! !

"September 7, 2009 -> 19:5:52"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithTwoArgs
	
	self ensureWin32Or: [^self].
	Alien
		autoFreeAfter: [:free|
			|result formatString|
			result := free value: (Alien newC: 200).
			formatString = '12345' asString.
			function primFFICallResult: nil
							with: result
							with: (free value: formatString asAlien).
			self assert: formatString = result strcpy]! !

"September 7, 2009 -> 19:8:1"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'fixture' !
libcName
	
	Platform == Win32Platform
		ifTrue: [^'msvcrt.dll'].
	Platform == MacOSXPlatform
		ifTrue: [^'libc.dylib'].
	Platform == UnixPlatform
		ifTrue: [^'libc.6.so']
	self error: 'Unsupported platform'! !

"September 7, 2009 -> 19:8:18"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'fixture' !
setUp

	self ensureWin32Or: [^self].
	function := Alien 
							lookup: 'sprintf'
							inLibrary: self libcName! !

"September 7, 2009 -> 19:8:27"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'fixture' !
setUp

	function := Alien 
							lookup: 'sprintf'
							inLibrary: self libcName! !

"September 7, 2009 -> 19:8:31"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithTwoArgs
	
	Alien
		autoFreeAfter: [:free|
			|result formatString|
			result := free value: (Alien newC: 200).
			formatString = '12345' asString.
			function primFFICallResult: nil
							with: result
							with: (free value: formatString asAlien).
			self assert: formatString = result strcpy]! !

"September 7, 2009 -> 19:8:35"!

(Delta mirrorFor: #AlienFunctionTest) removeMethod: #ensureWin32Or: ifAbsent: [] !


"September 7, 2009 -> 19:12:0"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|nil> with: arg1 <Alien|SmallInteger> with: arg2 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result ifFail: [:err| self error: err]}}! !

"September 7, 2009 -> 19:12:24"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|nil> with: arg1 <Alien|SmallInteger> with: arg2 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			ifFail: [:err| self error: err]}}! !

"September 7, 2009 -> 19:13:45"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithTwoArgs
	
	Alien
		autoFreeAfter: [:free|
			|result formatString|
			result := free value: (Alien newC: 200).
			formatString := '12345' asString.
			function primFFICallResult: nil
							with: result
							with: (free value: formatString asAlien).
			self assert: formatString = result strcpy]! !

"September 7, 2009 -> 19:54:10"!

"System saved" !
"September 7, 2009 -> 20:34:30"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithTwoArgs
	
	Alien
		autoFreeAfter: [:free|
			|result formatString|
			result := free value: (Alien newC: 200).
			formatString := '12345' asString.
			function primFFICallResult: nil
							with: result
							with: (free value: formatString asAlien pointer).
			self assert: formatString = result strcpy]! !

"September 7, 2009 -> 20:34:59"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithTwoArgs
	
	Alien
		autoFreeAfter: [:free|
			|result formatString|
			result := free value: (Alien newC: 200).
			formatString := '12345' asString.
			function primFFICallResult: nil
							with: result
							with: (free value: formatString asAlien) pointer.
			self assert: formatString = result strcpy]! !

"September 7, 2009 -> 20:35:14"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithTwoArgs
	
	Alien
		autoFreeAfter: [:free|
			|result formatString|
			result := free value: (Alien newC: 200).
			formatString := '12345' asString.
			function primFFICallResult: nil
							with: result pointer
							with: (free value: formatString asAlien) pointer.
			self assert: formatString = result strcpy]! !

"September 7, 2009 -> 20:37:3"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithThreeArgs
	
	Alien
		autoFreeAfter: [:free|
			|result formatString|
			result := free value: (Alien newC: 200).
			formatString := '%d' asString.
			function primFFICallResult: nil
							with: result pointer
							with: (free value: formatString asAlien) pointer
							with: 1.
			self assert: '1' asString = result strcpy]! !

"September 7, 2009 -> 20:38:2"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|nil>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			with: arg3
			ifFail: [:err| self error: err]}}! !

"September 7, 2009 -> 20:38:45"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithFourArgs
	
	Alien
		autoFreeAfter: [:free|
			|result formatString|
			result := free value: (Alien newC: 200).
			formatString := '%d %d' asString.
			function primFFICallResult: nil
							with: result pointer
							with: (free value: formatString asAlien) pointer
							with: 1
							with: 2.
			self assert: '1 2' asString = result strcpy]! !

"September 7, 2009 -> 20:40:31"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithFourArgs
	
	Alien
		autoFreeAfter: [:free|
			|result formatString|
			result := free value: (Alien newC: 200).
			formatString := '%d %d' asString.
			function primFFICallResult: nil
							with: result pointer
							with: (free value: formatString asAlien) pointer
							with: ((free value: (Alien newC: 4))
										signedLongAt: 1 put: 1;
										yourself)
							with: 2.
			self assert: '1 2' asString = result strcpy]! !

"September 7, 2009 -> 20:41:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|nil>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			with: arg3
			with: arg4
			ifFail: [:err| self error: err]}}! !

"September 7, 2009 -> 20:43:8"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithFourArgs
	
	Alien
		autoFreeAfter: [:free|
			|formattedString formatString result|
			result := Alien new: 4.
			formattedString := free value: (Alien newC: 200).
			formatString := '%d %d' asString.
			function primFFICallResult: result
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: ((free value: (Alien newC: 4))
										signedLongAt: 1 put: 1;
										yourself)
							with: 2.
			self assert: '1 2' asString = formattedString strcpy.
			self assert: 3 == result asUnsignedLong]! !

"September 7, 2009 -> 20:44:59"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithFourArgs
	
	Alien
		autoFreeAfter: [:free|
			|formattedString formatString result1|
			result1 := Alien new: 4.
			formattedString := free value: (Alien newC: 200).
			formatString := '%d %d' asString.
			function primFFICallResult: result1
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: ((free value: (Alien newC: 4))
										signedLongAt: 1 put: 1;
										yourself)
							with: 2.
			self assert: '1 2' asString = formattedString strcpy.
			self assert: 3 == result1 asUnsignedLong]! !

"September 7, 2009 -> 20:45:15"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithThreeArgs
	
	Alien
		autoFreeAfter: [:free|
			|result1 formatString|
			result1 := free value: (Alien newC: 200).
			formatString := '%d' asString.
			function primFFICallResult: nil
							with: result1 pointer
							with: (free value: formatString asAlien) pointer
							with: 1.
			self assert: '1' asString = result1 strcpy]! !

"September 7, 2009 -> 20:45:28"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithTwoArgs
	
	Alien
		autoFreeAfter: [:free|
			|result1 formatString|
			result1 := free value: (Alien newC: 200).
			formatString := '12345' asString.
			function primFFICallResult: nil
							with: result1 pointer
							with: (free value: formatString asAlien) pointer.
			self assert: formatString = result1 strcpy]! !

"September 7, 2009 -> 20:45:33"!

Delta define: #AlienFunctionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'function
result')) !


"September 7, 2009 -> 20:46:0"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithFourArgs
	
	Alien
		autoFreeAfter: [:free|
			|formattedString formatString |
			result := Alien new: 4.
			formattedString := free value: (Alien newC: 200).
			formatString := '%d %d' asString.
			function primFFICallResult: result
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: ((free value: (Alien newC: 4))
										signedLongAt: 1 put: 1;
										yourself)
							with: 2.
			self assert: '1 2' asString = formattedString strcpy.
			self assert: 3 == result asUnsignedLong]! !

"September 7, 2009 -> 20:46:49"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithThreeArgs
	
	Alien
		autoFreeAfter: [:free|
			|formatString|
			result := free value: (Alien newC: 200).
			formatString := '%d' asString.
			function primFFICallResult: nil
							with: result pointer
							with: (free value: formatString asAlien) pointer
							with: 1.
			self assert: '1' asString = result strcpy]! !

"September 7, 2009 -> 20:47:7"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithTwoArgs
	
	Alien
		autoFreeAfter: [:free|
			|formatString|
			result := free value: (Alien newC: 200).
			formatString := '12345' asString.
			function primFFICallResult: nil
							with: result pointer
							with: (free value: formatString asAlien) pointer.
			self assert: formatString = result strcpy]! !

"September 7, 2009 -> 20:47:40"!

Delta define: #AlienFunctionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'function
result
formattedString')) !


"September 7, 2009 -> 20:47:49"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithFourArgs
	
	Alien
		autoFreeAfter: [:free|
			|formatString |
			result := Alien new: 4.
			formattedString := free value: (Alien newC: 200).
			formatString := '%d %d' asString.
			function primFFICallResult: result
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: ((free value: (Alien newC: 4))
										signedLongAt: 1 put: 1;
										yourself)
							with: 2.
			self assert: '1 2' asString = formattedString strcpy.
			self assert: 3 == result asUnsignedLong]! !

"September 7, 2009 -> 20:48:18"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithThreeArgs
	
	Alien
		autoFreeAfter: [:free|
			|formatString|
			formattedString := free value: (Alien newC: 200).
			formatString := '%d' asString.
			function primFFICallResult: nil
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: 1.
			self assert: '1' asString = formattedString strcpy]! !

"September 7, 2009 -> 20:48:28"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithTwoArgs
	
	Alien
		autoFreeAfter: [:free|
			|formatString|
			formattedString := free value: (Alien newC: 200).
			formatString := '12345' asString.
			function primFFICallResult: nil
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer.
			self assert: formatString = formattedString strcpy]! !

"September 7, 2009 -> 20:49:34"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'fixture' !
setUp

	function := Alien 
							lookup: 'sprintf'
							inLibrary: self libcName.
	result := Alien new: 4.
	formattedString := Alien newC: 200! !

"September 7, 2009 -> 20:49:53"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'fixture' !
tearDown

	formattedString free! !

"September 7, 2009 -> 20:50:7"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithFourArgs
	
	Alien
		autoFreeAfter: [:free|
			|formatString |
			formatString := '%d %d' asString.
			function primFFICallResult: result
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: ((free value: (Alien newC: 4))
										signedLongAt: 1 put: 1;
										yourself)
							with: 2.
			self assert: '1 2' asString = formattedString strcpy.
			self assert: 3 == result asUnsignedLong]! !

"September 7, 2009 -> 20:50:11"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithThreeArgs
	
	Alien
		autoFreeAfter: [:free|
			|formatString|
			formatString := '%d' asString.
			function primFFICallResult: nil
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: 1.
			self assert: '1' asString = formattedString strcpy]! !

"September 7, 2009 -> 20:50:12"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithTwoArgs
	
	Alien
		autoFreeAfter: [:free|
			|formatString|
			formatString := '12345' asString.
			function primFFICallResult: nil
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer.
			self assert: formatString = formattedString strcpy]! !

"September 7, 2009 -> 20:52:56"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithThreeArgs
	
	Alien autoFreeAfter: [:free|
			|formatString|
			formatString := '%d' asString.
			function primFFICallResult: nil
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: 1].
	self assert: '1' asString = formattedString strcpy! !

"September 7, 2009 -> 20:52:57"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithFiveArgs
	
	Alien autoFreeAfter: [:free|
			|formatString |
			formatString := '%d %d %d' asString.
			function primFFICallResult: result
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: 1
							with: 2
							with: 3].
	self assert: '1 2 3' asString = formattedString strcpy.
	self assert: 5 == result asUnsignedLong! !

"September 7, 2009 -> 20:53:32"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|nil>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			with: arg3
			with: arg4
			with: arg5
			ifFail: [:err| self error: err]}}! !

"September 7, 2009 -> 20:54:34"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithSixArgs
	
	Alien autoFreeAfter: [:free|
			|formatString |
			formatString := '%d %d %d %d' asString.
			function primFFICallResult: result
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: 1
							with: 2
							with: 3
							with: 4].
	self assert: '1 2 3 4' asString = formattedString strcpy.
	self assert: 7 == result asUnsignedLong! !

"September 7, 2009 -> 20:55:1"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|nil>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			with: arg3
			with: arg4
			with: arg5
			with: arg6
			ifFail: [:err| self error: err]}}! !

"September 7, 2009 -> 20:55:32"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithSevenArgs
	
	Alien autoFreeAfter: [:free|
			|formatString |
			formatString := '%d %d %d %d %d' asString.
			function primFFICallResult: result
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: 1
							with: 2
							with: 3
							with: 4
							with: 5].
	self assert: '1 2 3 4 5' asString = formattedString strcpy.
	self assert: 9 == result asUnsignedLong! !

"September 7, 2009 -> 20:56:6"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|nil>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			with: arg3
			with: arg4
			with: arg5
			with: arg6
			with: arg7
			ifFail: [:err| self error: err]}}! !

"September 7, 2009 -> 20:56:36"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithEightArgs
	
	Alien autoFreeAfter: [:free|
			|formatString |
			formatString := '%d %d %d %d %d %d' asString.
			function primFFICallResult: result
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: 1
							with: 2
							with: 3
							with: 4
							with: 5
							with: 6].
	self assert: '1 2 3 4 5 6' asString = formattedString strcpy.
	self assert: 11 == result asUnsignedLong! !

"September 7, 2009 -> 20:58:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|nil>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger>
with: arg8 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: { arg1. arg2. arg3. arg4. arg5. arg6. arg7. arg8 }
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 9:53:8"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithNineArgs
	
	Alien autoFreeAfter: [:free|
			|formatString |
			formatString := '%d %d %d %d %d %d %d' asString.
			function primFFICallResult: result
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: 1
							with: 2
							with: 3
							with: 4
							with: 5
							with: 6
							with: 7].
	self assert: '1 2 3 4 5 6 7' asString = formattedString strcpy.
	self assert: 13 == result asUnsignedLong! !

"September 8, 2009 -> 9:53:50"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|nil>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger>
with: arg8 <Alien|SmallInteger>
with: arg9 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: { arg1. arg2. arg3. arg4. arg5. arg6. arg7. arg8. arg9 }
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 9:54:17"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithTenArgs
	
	Alien autoFreeAfter: [:free|
			|formatString |
			formatString := '%d %d %d %d %d %d %d %d' asString.
			function primFFICallResult: result
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: 1
							with: 2
							with: 3
							with: 4
							with: 5
							with: 6
							with: 7
							with: 8].
	self assert: '1 2 3 4 5 6 7 8' asString = formattedString strcpy.
	self assert: 15 == result asUnsignedLong! !

"September 8, 2009 -> 9:54:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|nil>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger>
with: arg8 <Alien|SmallInteger>
with: arg9 <Alien|SmallInteger>
with: arg10 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: { arg1. arg2. arg3. arg4. arg5. arg6. arg7. arg8. arg9. arg10 }
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 9:55:21"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithElevenArgs
	
	Alien autoFreeAfter: [:free|
			|formatString |
			formatString := '%d %d %d %d %d %d %d %d %d' asString.
			function primFFICallResult: result
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: 1
							with: 2
							with: 3
							with: 4
							with: 5
							with: 6
							with: 7
							with: 8
							with: 9].
	self assert: '1 2 3 4 5 6 7 8 9' asString = formattedString strcpy.
	self assert: 17 == result asUnsignedLong! !

"September 8, 2009 -> 9:55:45"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|nil>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger>
with: arg8 <Alien|SmallInteger>
with: arg9 <Alien|SmallInteger>
with: arg10 <Alien|SmallInteger>
with: arg11 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: { arg1. arg2. arg3. arg4. arg5. arg6. arg7. arg8. arg9. arg10. arg11 }
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 9:56:25"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithTwelveArgs
	
	Alien autoFreeAfter: [:free|
			|formatString |
			formatString := '%d %d %d %d %d %d %d %d %d %d' asString.
			function primFFICallResult: result
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: 1
							with: 2
							with: 3
							with: 4
							with: 5
							with: 6
							with: 7
							with: 8
							with: 9
							with: 10].
	self assert: '1 2 3 4 5 6 7 8 9 10' asString = formattedString strcpy.
	self assert: 20 == result asUnsignedLong! !

"September 8, 2009 -> 9:57:5"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|nil>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger>
with: arg8 <Alien|SmallInteger>
with: arg9 <Alien|SmallInteger>
with: arg10 <Alien|SmallInteger>
with: arg11 <Alien|SmallInteger>
with: arg12 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: { arg1. arg2. arg3. arg4. arg5. arg6. arg7. arg8. arg9. arg10. arg11. arg12 }
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 9:57:38"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien>
with: arg1 <Alien|UndefinedObject>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger>
with: arg8 <Alien|SmallInteger>
with: arg9 <Alien|SmallInteger>
with: arg10 <Alien|SmallInteger>
with: arg11 <Alien|SmallInteger>
with: arg12 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: { arg1. arg2. arg3. arg4. arg5. arg6. arg7. arg8. arg9. arg10. arg11. arg12 }
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 9:57:48"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien>
with: arg1 <Alien|UndefinedObject>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger>
with: arg8 <Alien|SmallInteger>
with: arg9 <Alien|SmallInteger>
with: arg10 <Alien|SmallInteger>
with: arg11 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: { arg1. arg2. arg3. arg4. arg5. arg6. arg7. arg8. arg9. arg10. arg11 }
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 9:57:58"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien>
with: arg1 <Alien|UndefinedObject>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger>
with: arg8 <Alien|SmallInteger>
with: arg9 <Alien|SmallInteger>
with: arg10 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: { arg1. arg2. arg3. arg4. arg5. arg6. arg7. arg8. arg9. arg10 }
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 9:58:7"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien>
with: arg1 <Alien|UndefinedObject>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger>
with: arg8 <Alien|SmallInteger>
with: arg9 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: { arg1. arg2. arg3. arg4. arg5. arg6. arg7. arg8. arg9 }
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 9:58:14"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien>
with: arg1 <Alien|UndefinedObject>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger>
with: arg8 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: { arg1. arg2. arg3. arg4. arg5. arg6. arg7. arg8 }
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 9:58:24"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien>
with: arg1 <Alien|UndefinedObject>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			with: arg3
			with: arg4
			with: arg5
			with: arg6
			with: arg7
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 9:58:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien>
with: arg1 <Alien|UndefinedObject>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			with: arg3
			with: arg4
			with: arg5
			with: arg6
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 9:58:47"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien>
with: arg1 <Alien|UndefinedObject>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			with: arg3
			with: arg4
			with: arg5
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 9:58:54"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien>
with: arg1 <Alien|UndefinedObject>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			with: arg3
			with: arg4
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 9:59:1"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien>
with: arg1 <Alien|UndefinedObject>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			with: arg3
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 9:59:16"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien> with: arg1 <Alien|UndefinedObject> with: arg2 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 10:3:13"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject> with: arg1 <Alien|SmallInteger> with: arg2 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 10:3:42"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			with: arg3
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 10:3:49"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			with: arg3
			with: arg4
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 10:3:58"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			with: arg3
			with: arg4
			with: arg5
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 10:4:10"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			with: arg3
			with: arg4
			with: arg5
			with: arg6
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 10:4:16"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			with: arg3
			with: arg4
			with: arg5
			with: arg6
			with: arg7
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 10:4:25"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger>
with: arg8 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: { arg1. arg2. arg3. arg4. arg5. arg6. arg7. arg8 }
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 10:4:47"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger>
with: arg8 <Alien|SmallInteger>
with: arg9 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: { arg1. arg2. arg3. arg4. arg5. arg6. arg7. arg8. arg9 }
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 10:4:57"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger>
with: arg8 <Alien|SmallInteger>
with: arg9 <Alien|SmallInteger>
with: arg10 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: { arg1. arg2. arg3. arg4. arg5. arg6. arg7. arg8. arg9. arg10 }
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 10:5:17"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger>
with: arg8 <Alien|SmallInteger>
with: arg9 <Alien|SmallInteger>
with: arg10 <Alien|SmallInteger>
with: arg11 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: { arg1. arg2. arg3. arg4. arg5. arg6. arg7. arg8. arg9. arg10. arg11 }
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 10:5:26"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger>
with: arg8 <Alien|SmallInteger>
with: arg9 <Alien|SmallInteger>
with: arg10 <Alien|SmallInteger>
with: arg11 <Alien|SmallInteger>
with: arg12 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: { arg1. arg2. arg3. arg4. arg5. arg6. arg7. arg8. arg9. arg10. arg11. arg12 }
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 10:26:29"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithArguments
	
	Alien autoFreeAfter: [:free|
			|formatString|
			formatString := '%d' asString.
			function primFFICallResult: nil
							withArguments: { formattedString pointer.
														(free value: formatString asAlien) pointer.
														1 } ].
	self assert: '1' asString = formattedString strcpy! !

"September 8, 2009 -> 10:27:33"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
withArguments: arguments <Array[Alien|SmallInteger]> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: arguments
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 10:27:56"!

Delta define: #AlienFunctionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'sprintf
function
result
formattedString')) !


"September 8, 2009 -> 10:28:4"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'fixture' !
setUp

	sprintf := function := Alien 
							lookup: 'sprintf'
							inLibrary: self libcName.
	result := Alien new: 4.
	formattedString := Alien newC: 200! !

"September 8, 2009 -> 10:28:15"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithArguments
	
	Alien autoFreeAfter: [:free|
			|formatString|
			formatString := '%d' asString.
			sprintf primFFICallResult: nil
							withArguments: { formattedString pointer.
														(free value: formatString asAlien) pointer.
														1 } ].
	self assert: '1' asString = formattedString strcpy! !

"September 8, 2009 -> 10:28:24"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithEightArgs
	
	Alien autoFreeAfter: [:free|
			|formatString |
			formatString := '%d %d %d %d %d %d' asString.
			sprintf primFFICallResult: result
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: 1
							with: 2
							with: 3
							with: 4
							with: 5
							with: 6].
	self assert: '1 2 3 4 5 6' asString = formattedString strcpy.
	self assert: 11 == result asUnsignedLong! !

"September 8, 2009 -> 10:28:44"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithFiveArgs
	
	Alien autoFreeAfter: [:free|
			|formatString |
			formatString := '%d %d %d' asString.
			sprintf primFFICallResult: result
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: 1
							with: 2
							with: 3].
	self assert: '1 2 3' asString = formattedString strcpy.
	self assert: 5 == result asUnsignedLong! !

"September 8, 2009 -> 10:28:45"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithElevenArgs
	
	Alien autoFreeAfter: [:free|
			|formatString |
			formatString := '%d %d %d %d %d %d %d %d %d' asString.
			sprintf primFFICallResult: result
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: 1
							with: 2
							with: 3
							with: 4
							with: 5
							with: 6
							with: 7
							with: 8
							with: 9].
	self assert: '1 2 3 4 5 6 7 8 9' asString = formattedString strcpy.
	self assert: 17 == result asUnsignedLong! !

"September 8, 2009 -> 10:28:56"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithFourArgs
	
	Alien
		autoFreeAfter: [:free|
			|formatString |
			formatString := '%d %d' asString.
			sprintf primFFICallResult: result
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: ((free value: (Alien newC: 4))
										signedLongAt: 1 put: 1;
										yourself)
							with: 2.
			self assert: '1 2' asString = formattedString strcpy.
			self assert: 3 == result asUnsignedLong]! !

"September 8, 2009 -> 10:29:3"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithNineArgs
	
	Alien autoFreeAfter: [:free|
			|formatString |
			formatString := '%d %d %d %d %d %d %d' asString.
			sprintf primFFICallResult: result
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: 1
							with: 2
							with: 3
							with: 4
							with: 5
							with: 6
							with: 7].
	self assert: '1 2 3 4 5 6 7' asString = formattedString strcpy.
	self assert: 13 == result asUnsignedLong! !

"September 8, 2009 -> 10:29:10"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithSevenArgs
	
	Alien autoFreeAfter: [:free|
			|formatString |
			formatString := '%d %d %d %d %d' asString.
			sprintf primFFICallResult: result
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: 1
							with: 2
							with: 3
							with: 4
							with: 5].
	self assert: '1 2 3 4 5' asString = formattedString strcpy.
	self assert: 9 == result asUnsignedLong! !

"September 8, 2009 -> 10:29:20"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithTwelveArgs
	
	Alien autoFreeAfter: [:free|
			|formatString |
			formatString := '%d %d %d %d %d %d %d %d %d %d' asString.
			sprintf primFFICallResult: result
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: 1
							with: 2
							with: 3
							with: 4
							with: 5
							with: 6
							with: 7
							with: 8
							with: 9
							with: 10].
	self assert: '1 2 3 4 5 6 7 8 9 10' asString = formattedString strcpy.
	self assert: 20 == result asUnsignedLong! !

"September 8, 2009 -> 10:29:30"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithThreeArgs
	
	Alien autoFreeAfter: [:free|
			|formatString|
			formatString := '%d' asString.
			sprintf primFFICallResult: nil
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: 1].
	self assert: '1' asString = formattedString strcpy! !

"September 8, 2009 -> 10:29:37"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithTenArgs
	
	Alien autoFreeAfter: [:free|
			|formatString |
			formatString := '%d %d %d %d %d %d %d %d' asString.
			sprintf primFFICallResult: result
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: 1
							with: 2
							with: 3
							with: 4
							with: 5
							with: 6
							with: 7
							with: 8].
	self assert: '1 2 3 4 5 6 7 8' asString = formattedString strcpy.
	self assert: 15 == result asUnsignedLong! !

"September 8, 2009 -> 10:29:49"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithTwoArgs
	
	Alien
		autoFreeAfter: [:free|
			|formatString|
			formatString := '12345' asString.
			sprintf primFFICallResult: nil
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer.
			self assert: formatString = formattedString strcpy]! !

"September 8, 2009 -> 10:30:12"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'fixture' !
setUp

	sprintf := Alien 
							lookup: 'sprintf'
							inLibrary: self libcName.
	result := Alien new: 4.
	formattedString := Alien newC: 200! !

"September 8, 2009 -> 10:30:23"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithSixArgs
	
	Alien autoFreeAfter: [:free|
			|formatString |
			formatString := '%d %d %d %d' asString.
			sprintf primFFICallResult: result
							with: formattedString pointer
							with: (free value: formatString asAlien) pointer
							with: 1
							with: 2
							with: 3
							with: 4].
	self assert: '1 2 3 4' asString = formattedString strcpy.
	self assert: 7 == result asUnsignedLong! !

"September 8, 2009 -> 10:30:36"!

Delta define: #AlienFunctionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'sprintf
labs
result
formattedString')) !


"September 8, 2009 -> 10:31:28"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'fixture' !
setUp

	sprintf := Alien lookup: 'sprintf' inLibrary: self libcName.
	labs := Alien lookup: 'labs' inLibrary: self libcName.
	result := Alien new: 4.
	formattedString := Alien newC: 200! !

"September 8, 2009 -> 10:33:23"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithOneArg

	labs primFFICallResult: result
			with: -1.
	self assert: 1 == result asSignedLong! !

"September 8, 2009 -> 10:33:46"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject> with: arg1 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			ifFail: [:err| self error: err]}}! !

"September 8, 2009 -> 10:34:44"!

"System saved" !
"September 8, 2009 -> 22:53:38"!

Delta define: #TestAlien as: (
(Class subclassOf: 'Alien' instanceVariables: '')) !


"September 8, 2009 -> 22:54:10"!

! (Delta mirrorFor: #TestAlien) classSide methodsFor: 'instance creation' !
dataSize

	^8! !

"September 8, 2009 -> 22:56:16"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'private - test support' !
libcName

	Platform == Win32Platform
		ifTrue: [^'msvcrt.dll'].
	Platform == MacOSXPlatform
		ifTrue: [^'libc.dylib'].
	Platform == UnixPlatform
		ifTrue: [^'libc.6.so'].
	self error: 'Platform set incorrectly'! !

"September 8, 2009 -> 22:56:37"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testLookupClockWin32

	|function result|
	Platform == Win32Platform ifFalse: [^self].
	function := Alien lookup: 'clock' inLibrary: self libcName.
	result := Alien new: 8.
	function primFFICallResult: result! !

"September 8, 2009 -> 22:57:19"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testLookupClockWin32

	|function result|
	function := Alien lookup: 'clock' inLibrary: self libcName.
	result := Alien new: 8.
	function primFFICallResult: result! !

"September 8, 2009 -> 22:59:8"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testNewForCallbackArgs

	|alien|
	alien := TestAlien newForCallbackArgs.
	self assert: alien size == TestAlien dataSize negated.
	self assert: alien address == 0! !

"September 8, 2009 -> 23:0:14"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
newForCallbackArgs

	^(self new: 8)
		size: self dataSize negated;
		yourself! !

"September 8, 2009 -> 23:16:25"!

Delta define: #Callback as: (
(Class subclassOf: 'CallBack' instanceVariables: '')) !


"September 8, 2009 -> 23:16:50"!

Delta define: #Callback as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"September 8, 2009 -> 23:16:50"!

Delta define: #Callback as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"September 8, 2009 -> 23:16:50"!

Delta define: #Callback as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"September 8, 2009 -> 23:16:50"!

Delta define: #Callback as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"September 8, 2009 -> 23:16:50"!

Delta define: #Callback as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"September 8, 2009 -> 23:16:50"!

Delta define: #Callback as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"September 8, 2009 -> 23:16:50"!

Delta define: #Callback as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"September 8, 2009 -> 23:16:50"!

Delta define: #Callback as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"September 8, 2009 -> 23:16:50"!

Delta define: #Callback as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"September 8, 2009 -> 23:16:50"!

Delta define: #Callback as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"September 8, 2009 -> 23:16:50"!

Delta define: #Callback as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"September 8, 2009 -> 23:18:24"!

"System saved" !
"September 9, 2009 -> 1:3:12"!

Delta define: #CallbackTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"September 9, 2009 -> 1:3:12"!

! (Delta mirrorFor: #CallbackTest) methodsFor: 'testing' !
testBlockArgsClass

	|callback|
	callback := Callback
							block: [:args :result|]
							argsClass: TestAlien
					! !

"September 9, 2009 -> 1:3:12"!

! (Delta mirrorFor: #Callback) classSide methodsFor: 'instance creation' !
block: block <[Alien, Alien]> argsClass: class <Alien class> ^ <Callback>

	^self new! !

"September 9, 2009 -> 1:3:12"!

! (Delta mirrorFor: #CallbackTest) methodsFor: 'testing' !
testBlockArgsClass

	|callback proxy|
	callback := Callback
							block: [:args :result|]
							argsClass: TestAlien.
	(proxy := ExternalProxy new)
		malloc: 4.
	proxy smallIntegerAt: 1 put: 1.! !

"September 9, 2009 -> 1:3:12"!

! (Delta mirrorFor: #CallbackTest) methodsFor: 'testing' !
testBlockArgsClass

	|callback proxy|
	[callback := Callback
							block: [:args :result|]
							argsClass: TestAlien.
	(proxy := ExternalProxy new)
		malloc: 4.
	proxy smallIntegerAt: 1 put: 1.]
		ensure: [proxy free]! !

"September 9, 2009 -> 1:3:12"!

! (Delta mirrorFor: #CallbackTest) methodsFor: 'testing' !
testBlockArgsClass

	|callback proxy|
	[callback := Callback
							block: [:args :result|]
							argsClass: TestAlien.
	(proxy := ExternalProxy new)
		malloc: 4.
	proxy smallIntegerAt: 1 put: 1.]
		ensure: [proxy isNull ifFalse: [proxy free]]! !

"September 9, 2009 -> 1:3:12"!

! (Delta mirrorFor: #CallbackTest) methodsFor: 'testing' !
testBlockArgsClass

	|callback proxy|
	callback := Callback
							block: [:args :result|]
							argsClass: TestAlien.
	(proxy := ExternalProxy new)
		malloc: 4.
	proxy smallIntegerAt: 1 put: 1.! !

"September 9, 2009 -> 1:3:12"!

! (Delta mirrorFor: #CallbackTest) methodsFor: 'testing' !
testBlockArgsClass

	|callback stack wasCalled|
	wasCalled := false.
	callback := Callback
							block: [:args :result| wasCalled := true]
							argsClass: TestAlien.
	(stack := ExternalProxy new)
		malloc: 4.
	stack smallIntegerAt: 1 put: 1.
	callback evaluate: stack! !

"September 9, 2009 -> 1:3:12"!

! (Delta mirrorFor: #Callback) classSide methodsFor: 'instance creation' !
block: block <[Alien, Alien]> argsClass: class <Alien class> ^ <Callback>

	^(self new)
			block: [:stack| block value: nil value: nil];
			yourself! !

"September 9, 2009 -> 1:3:12"!

! (Delta mirrorFor: #CallbackTest) methodsFor: 'testing' !
testBlockArgsClass

	|callback stack wasCalled|
	wasCalled := false.
	callback := Callback
							block: [:args :result|
										wasCalled := true
										self assert: args address == stack asInteger]
							argsClass: TestAlien.
	(stack := ExternalProxy new)
		malloc: 4.
	stack smallIntegerAt: 1 put: 1.
	callback evaluate: stack! !

"September 9, 2009 -> 1:3:12"!

! (Delta mirrorFor: #CallbackTest) methodsFor: 'testing' !
testBlockArgsClass

	|callback stack wasCalled|
	wasCalled := false.
	callback := Callback
							block: [:args :result|
										wasCalled := true.
										self assert: args address == stack asInteger]
							argsClass: TestAlien.
	(stack := ExternalProxy new)
		malloc: 4.
	stack smallIntegerAt: 1 put: 1.
	callback evaluate: stack! !

"September 9, 2009 -> 1:3:12"!

! (Delta mirrorFor: #Callback) classSide methodsFor: 'instance creation' !
block: block <[Alien, Alien]> argsClass: class <Alien class> ^ <Callback>

	^(self new)
			block: [:stack| block value: nil value: nil]
			argsProxy: class newForCallbackArgs;
			yourself! !

"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #Callback) methodsFor: 'instance initialization' !
block: block <[Alien, Alien]> argsProxy: args <Alien>

	self block: block;
		argsProxy: args! !

"September 9, 2009 -> 1:3:13"!

Delta define: #Callback as: (
(Class subclassOf: 'CallBack' instanceVariables: '')) !


"September 9, 2009 -> 1:3:13"!

Delta define: #Callback as: (
(Class subclassOf: 'CallBack' instanceVariables: '')) !


"September 9, 2009 -> 1:3:13"!

Delta define: #Callback as: (
(Class subclassOf: 'CallBack' instanceVariables: '')) !


"September 9, 2009 -> 1:3:13"!

Delta define: #Callback as: (
(Class subclassOf: 'CallBack' instanceVariables: '')) !


"September 9, 2009 -> 1:3:13"!

Delta define: #Callback as: (
(Class subclassOf: 'CallBack' instanceVariables: '')) !


"September 9, 2009 -> 1:3:13"!

Delta define: #Callback as: (
(Class subclassOf: 'CallBack' instanceVariables: '')) !


"September 9, 2009 -> 1:3:13"!

Delta define: #Callback as: (
(Class subclassOf: 'CallBack' instanceVariables: '')) !


"September 9, 2009 -> 1:3:13"!

Delta define: #Callback as: (
(Class subclassOf: 'CallBack' instanceVariables: 'argsProxy')) !


"September 9, 2009 -> 1:3:13"!

Delta define: #Callback as: (
(Class subclassOf: 'CallBack' instanceVariables: 'argsProxy')) !


"September 9, 2009 -> 1:3:13"!

Delta define: #Callback as: (
(Class subclassOf: 'CallBack' instanceVariables: 'argsProxy')) !


"September 9, 2009 -> 1:3:13"!

Delta define: #Callback as: (
(Class subclassOf: 'CallBack' instanceVariables: 'argsProxy')) !


"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #Callback) methodsFor: 'restricted-accessing' !
argsProxy: args <Alien>

	argsProxy := args! !

"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #Callback) methodsFor: 'restricted-accessing' !
argsProxy ^<Alien>

	^argsProxy! !

"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #Callback) classSide methodsFor: 'instance creation' !
block: block <[Alien, Alien]> argsClass: class <Alien class> ^ <Callback>

	^(self new)
			block: block
			argsProxy: class newForCallbackArgs;
			yourself! !

"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #Callback) methodsFor: 'instance initialization' !
block: block <[Alien, Alien]> argsProxy: args <Alien>

	self block: [:stack|
						args address: stack asInteger.
						block value: argsProxy value: nil]! !

"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #Callback) methodsFor: 'instance initialization' !
block: block <[Alien, Alien]> argsProxy: args <Alien>

	self block: [:stack|
						args addressField: stack asInteger.
						block value: argsProxy value: nil]! !

"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #Callback) methodsFor: 'instance initialization' !
block: block <[Alien, Alien]> argsProxy: args <Alien>

	self block: [:stack|
						args addressField: stack asInteger.
						block value: args value: nil]! !

"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #CallbackTest) methodsFor: 'testing' !
testBlockArgsClass

	|callback stack wasCalled|
	wasCalled := false.
	callback := Callback
							block: [:args :result|
										wasCalled := true.
										self assert: args address == stack asInteger.
										result returnInteger: -3]
							argsClass: TestAlien.
	(stack := ExternalProxy new)
		malloc: 4.
	stack smallIntegerAt: 1 put: 1.
	self assert: (callback evaluate: stack) == -3! !

"September 9, 2009 -> 1:3:13"!

Delta define: #FFICallbackReturnValue as: (
(Class subclassOf: 'Alien' instanceVariables: '')) !


"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #FFICallbackReturnValue) classSide methodsFor: 'instance creation' !
dataSize

	^16! !

"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #FFICallbackReturnValue) methodsFor: 'accessing' !
returnInteger: value <Integer>! !

"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #Callback) methodsFor: 'instance initialization' !
block: block <[Alien, Alien]> argsProxy: args <Alien>

	self block: [:stack|
						|result|
						result := FFICallbackReturnValue new.
						args addressField: stack asInteger.
						block value: args value: result.
						result]! !

"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #Callback) methodsFor: 'instance initialization' !
block: block <[Alien, Alien]> argsProxy: args <Alien>

	self block: [:stack|
						|result|
						result := FFICallbackReturnValue new.
						args addressField: stack asInteger.
						block value: args value: result.
						result value]! !

"September 9, 2009 -> 1:3:13"!

Delta define: #FFICallbackReturnValueTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #FFICallbackReturnValueTest) methodsFor: 'testing' !
testValueShouldReturnIntegerWhenInteger

	|alien|
	alien := FFICallbackReturnValue new.
	alien returnInteger: 1.
	self assert: 1 == alien value! !

"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #FFICallbackReturnValue) methodsFor: 'accessing' !
returnInteger: value <Integer>

	self signedLongAt: 9 put: value! !

"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #FFICallbackReturnValue) methodsFor: 'accessing' !
value

	^self signedLongAt: 9! !

"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #FFICallbackReturnValueTest) methodsFor: 'testing' !
testValueShouldReturnFloatWhenFloat

	|alien|
	alien := FFICallbackReturnValue new.
	alien returnFloat: 1.0.
	self assert: 1.0 == alien value! !

"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #FFICallbackReturnValueTest) methodsFor: 'testing' !
testValueShouldReturnFloatWhenFloat

	|alien|
	alien := FFICallbackReturnValue new.
	alien returnDouble: 1.0.
	self assert: 1.0 == alien value! !

"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #FFICallbackReturnValue) methodsFor: 'accessing' !
returnDouble: value <Integer>

	self signedDoubleAt: 9 put: value! !

"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #FFICallbackReturnValue) methodsFor: 'accessing' !
returnDouble: value <Integer>

	self doubleAt: 9 put: value! !

"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #FFICallbackReturnValue) methodsFor: 'accessing' !
returnDouble: value <Integer>

	self unsignedByteAt: 1 put: 1.
	self doubleAt: 9 put: value! !

"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #FFICallbackReturnValue) methodsFor: 'accessing' !
value

	|type|
	(type := self asUnsignedByte) == 0
		ifTrue: [^self signedLongAt: 9].
	type == 1
		ifTrue: [^self doubleAt: 9] ! !

"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #FFICallbackReturnValue) methodsFor: 'accessing' !
returnInteger: value <Integer>

	self unsignedByteAt: 1 put: 0.
	self signedLongAt: 9 put: value! !

"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #FFICallbackReturnValueTest) methodsFor: 'testing' !
testValueShouldReturnFloatWhenFloat

	|alien value|
	alien := FFICallbackReturnValue new.
	alien returnDouble: 1.0.
	self assert: 1.0 == (value := alien value)! !

"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #FFICallbackReturnValueTest) methodsFor: 'testing' !
testValueShouldReturnFloatWhenFloat

	|alien value|
	alien := FFICallbackReturnValue new.
	alien returnDouble: 1.0.
	self assert: 1.0 = (value := alien value)! !

"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #FFICallbackReturnValueTest) methodsFor: 'testing' !
testValueShouldReturnFloatWhenFloat

	|alien value|
	alien := FFICallbackReturnValue new.
	alien returnDouble: 1.0.
	self assert: 1.0 = alien value! !

"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #FFICallbackReturnValue) methodsFor: 'restricted-accessing' !
dataOffset

	^9! !

"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #FFICallbackReturnValue) methodsFor: 'accessing' !
returnDouble: value <Integer>

	self unsignedByteAt: 1 put: 1.
	self doubleAt: self dataOffset put: value! !

"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #FFICallbackReturnValue) methodsFor: 'accessing' !
returnInteger: value <Integer>

	self unsignedByteAt: 1 put: 0.
	self signedLongAt: self dataOffset put: value! !

"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #FFICallbackReturnValue) methodsFor: 'restricted-accessing' !
value

	|type|
	(type := self asUnsignedByte) == 0
		ifTrue: [^self signedLongAt: self dataOffset].
	type == 1
		ifTrue: [^self doubleAt: self dataOffset] ! !

"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #FFICallbackReturnValue) methodsFor: 'restricted-accessing' !
type

	^self asUnsignedByte! !

"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #FFICallbackReturnValue) methodsFor: 'restricted-accessing' !
value

	self type == 0
		ifTrue: [^self signedLongAt: self dataOffset].
	self type == 1
		ifTrue: [^self doubleAt: self dataOffset] ! !

"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #FFICallbackReturnValue) methodsFor: 'restricted-accessing' !
typeOffset

	^1! !

"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #FFICallbackReturnValue) methodsFor: 'restricted-accessing' !
type

	^self unsignedByteAt: self typeOffset! !

"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #FFICallbackReturnValue) methodsFor: 'accessing' !
returnInteger: value <Integer>

	self unsignedByteAt: self typeOffset put: 0.
	self signedLongAt: self dataOffset put: value! !

"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #FFICallbackReturnValue) methodsFor: 'accessing' !
returnDouble: value <Integer>

	self unsignedByteAt: self typeOffset put: 1.
	self doubleAt: self dataOffset put: value! !

"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #FFICallbackReturnValue) methodsFor: 'accessing' !
type: type <Integer>

	self unsignedByteAt: self typeOffset put: type! !

"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #FFICallbackReturnValue) methodsFor: 'accessing' !
returnInteger: value <Integer>

	self type: 0.
	self signedLongAt: self dataOffset put: value! !

"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #FFICallbackReturnValue) methodsFor: 'accessing' !
returnDouble: value <Integer>

	self type: 1.
	self doubleAt: self dataOffset put: value! !

"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #CallbackTest) methodsFor: 'testing' !
testBlockArgsClass

	|callback stack wasCalled|
	wasCalled := false.
	callback := Callback
							block: [:args :result|
										wasCalled := true.
										self assert: args address == stack asInteger.
										result returnInteger: -3]
							argsClass: TestAlien.
	(stack := ExternalProxy new)
		malloc: 4.
	stack smallIntegerAt: 1 put: 1.
	self assert: (callback evaluate: stack) == -3.
	self assert: (CallBackArray at: callback index) == callback! !

"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #CallbackTest) methodsFor: 'fixture' !
setUp! !

"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #Callback) methodsFor: 'restricted-accessing' !
index

	^self smallIntegerAt: 2! !

"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #Callback) classSide methodsFor: 'instance creation' !
block: block <[Alien, Alien]> argsClass: class <Alien class> ^ <Callback>

	|callback|
	callback := self new.
	CallBackArray add: callback.
	{{primitiveCallbackRegisterCCall: CallBackArray size
		result: callback
		ifFail: [:err | self error: err]}}.
	callback
		block: block
		argsProxy: class newForCallbackArgs.
	^callback! !

"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #Callback) classSide methodsFor: 'instance creation' !
block: block <[Alien, Alien]> argsClass: class <Alien class> ^ <Callback>

	|callback|
	callback := self new.
	CallBackArray add: callback.
	{{primitiveCallBackRegisterCCall: CallBackArray size
		result: callback
		ifFail: [:err | self error: err]}}.
	callback
		block: block
		argsProxy: class newForCallbackArgs.
	^callback! !

"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #Callback) methodsFor: 'restricted-accessing' !
index

	^self smallIntegerAt: 1! !

"September 9, 2009 -> 1:3:13"!

Delta define: #CallbackTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"September 9, 2009 -> 1:3:13"!

Delta define: #CallbackTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"September 9, 2009 -> 1:3:13"!

Delta define: #CallbackTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"September 9, 2009 -> 1:3:13"!

Delta define: #CallbackTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"September 9, 2009 -> 1:3:13"!

Delta define: #CallbackTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"September 9, 2009 -> 1:3:13"!

Delta define: #CallbackTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"September 9, 2009 -> 1:3:13"!

Delta define: #CallbackTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"September 9, 2009 -> 1:3:13"!

Delta define: #CallbackTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'callback
stack
wasCalled')) !


"September 9, 2009 -> 1:3:13"!

Delta define: #CallbackTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'callback
stack
wasCalled')) !


"September 9, 2009 -> 1:3:13"!

Delta define: #CallbackTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'callback
stack
wasCalled')) !


"September 9, 2009 -> 1:3:13"!

Delta define: #CallbackTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'callback
stack
wasCalled')) !


"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #CallbackTest) methodsFor: 'testing' !
testBlockArgsClass

	wasCalled := false.
	callback := Callback
							block: [:args :result|
										wasCalled := true.
										self assert: args address == stack asInteger.
										result returnInteger: -3]
							argsClass: TestAlien.
	(stack := ExternalProxy new)
		malloc: 4.
	stack smallIntegerAt: 1 put: 1.
	self assert: (callback evaluate: stack) == -3.
	self assert: (CallBackArray at: callback index) == callback! !

"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #CallbackTest) methodsFor: 'fixture' !
setUp

	wasCalled := false.
	callback := Callback
							block: [:args :result|
										wasCalled := true.
										self assert: args address == stack asInteger.
										result returnInteger: -3]
							argsClass: TestAlien.
! !

"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #CallbackTest) methodsFor: 'testing' !
testBlockArgsClass

	(stack := ExternalProxy new)
		malloc: 4.
	stack smallIntegerAt: 1 put: 1.
	self assert: (callback evaluate: stack) == -3.
	self assert: (CallBackArray at: callback index) == callback! !

"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #CallbackTest) methodsFor: 'fixture' !
setUp

	wasCalled := false.
	callback := Callback
							block: [:args :result|
										wasCalled := true.
										self assert: args address == stack asInteger.
										result returnInteger: -3]
							argsClass: TestAlien.
	(stack := ExternalProxy new)
		malloc: 4.
! !

"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #CallbackTest) methodsFor: 'testing' !
testBlockArgsClass

	stack smallIntegerAt: 1 put: 1.
	self assert: (callback evaluate: stack) == -3.
	self assert: (CallBackArray at: callback index) == callback! !

"September 9, 2009 -> 1:3:13"!

! (Delta mirrorFor: #CallbackTest) methodsFor: 'fixture' !
tearDown

	callback isNull
		ifFalse: [callback free]! !

"September 9, 2009 -> 1:6:26"!

(Delta mirrorFor: #Callback) removeMethod: #argsProxy ifAbsent: [] !


"September 9, 2009 -> 1:6:28"!

(Delta mirrorFor: #Callback) removeMethod: #argsProxy: ifAbsent: [] !


"September 9, 2009 -> 1:6:35"!

Delta define: #Callback as: (
(Class subclassOf: 'CallBack' instanceVariables: '')) !


"September 9, 2009 -> 1:7:27"!

"System saved" !
"September 9, 2009 -> 1:11:53"!

! (Delta mirrorFor: #Callback) methodsFor: 'evaluation' !
evaluate: stack

	^block value: stack! !

"September 9, 2009 -> 1:23:12"!

! (Delta mirrorFor: #CallBack) methodsFor: 'deleting' !
free
	|index|
	index := self index.
	{{primitiveCallBackUnregister: self ifFail: [:err| self error: err]}}.
	CallBackArray at: index put: nil.! !

"September 9, 2009 -> 1:25:33"!

! (Delta mirrorFor: #CallbackTest) methodsFor: 'fixture' !
tearDown

	(callback isNil or: [callback isNull])
		ifFalse: [callback free]! !

"September 9, 2009 -> 1:43:14"!

! (Delta mirrorFor: #CallbackTest) methodsFor: 'testing' !
testBlockArgsClass

	callback := Callback
							block: [:args :result|
										wasCalled := true.
										self assert: args address == stack asInteger.
										result returnInteger: -3]
							argsClass: TestAlien.
	stack smallIntegerAt: 1 put: 1.
	self assert: (callback evaluate: stack) == -3.
	self assert: (CallBackArray at: callback index) == callback! !

"September 9, 2009 -> 1:43:15"!

! (Delta mirrorFor: #CallbackTest) methodsFor: 'fixture' !
setUp

	wasCalled := false.
	(stack := ExternalProxy new)
		malloc: 4.
! !

"September 9, 2009 -> 1:45:16"!

Delta define: #TestInvokeArgs as: (
(Class subclassOf: 'Alien' instanceVariables: '')) !


"September 9, 2009 -> 1:45:38"!

! (Delta mirrorFor: #TestInvokeArgs) classSide methodsFor: 'instance creation' !
dataSize

	^8! !

"September 9, 2009 -> 1:46:13"!

! (Delta mirrorFor: #TestInvokeArgs) methodsFor: 'accessing' !
first

	^self signedLongAt: 1! !

"September 9, 2009 -> 1:46:21"!

! (Delta mirrorFor: #TestInvokeArgs) methodsFor: 'accessing' !
second

	^self signedLongAt: 5! !

"September 9, 2009 -> 1:49:11"!

! (Delta mirrorFor: #CallbackTest) methodsFor: 'testing' !
testInvokeCallback

	callback := Callback
							block: [:args :result|
										wasCalled := true.
										self assert: args first == 10.
										self assert: args second == 5.
										result returnInteger: args first + args second]
							argsClass: TestInvokeArgs.
	self assert: wasCalled.
	self assert: (CCallback invoke: callback) == 15
	! !

"September 9, 2009 -> 1:49:23"!

! (Delta mirrorFor: #CallbackTest) methodsFor: 'testing' !
testInvokeCallback

	callback := Callback
							block: [:args :result|
										wasCalled := true.
										self assert: args first == 10.
										self assert: args second == 5.
										result returnInteger: args first + args second]
							argsClass: TestInvokeArgs.
	self assert: wasCalled.
	self assert: (CCallBack invoke: callback) == 15
	! !

"September 9, 2009 -> 1:49:34"!

(Delta mirrorFor: #CCallback) removeDefinitionIfFail: [] !


"September 9, 2009 -> 1:50:34"!

! (Delta mirrorFor: #CallbackTest) methodsFor: 'testing' !
testInvokeCallback

	callback := Callback
							block: [:args :result|
										wasCalled := true.
										self assert: args first == 10.
										self assert: args second == 5.
										result returnInteger: args first + args second]
							argsClass: TestInvokeArgs.
	self assert: (CCallBack invoke: callback) == 15.
	self assert: wasCalled
	! !

"September 9, 2009 -> 2:29:46"!

"System saved" !
"September 9, 2009 -> 20:5:3"!

! (Delta mirrorFor: #CallbackTest) methodsFor: 'testing' !
testInvokeCCallback

	callback := Callback
							block: [:args :result|
										wasCalled := true.
										self assert: args first == 10.
										self assert: args second == 5.
										result returnInteger: args first + args second]
							argsClass: TestInvokeArgs.
	self assert: (CCallBack invoke: callback) == 15.
	self assert: wasCalled
	! !

"September 9, 2009 -> 20:5:3"!

(Delta mirrorFor: #CallbackTest) removeMethod: #testInvokeCallback ifAbsent: [] !


"September 9, 2009 -> 20:5:3"!

! (Delta mirrorFor: #CallbackTest) methodsFor: 'testing' !
testInvokeStdcallCallback

	callback := Callback
							block: [:args :result|
										wasCalled := true.
										self assert: args first == 10.
										self assert: args second == 5.
										result returnInteger: args first + args second]
							stdcallArgsClass: TestInvokeArgs.
	self assert: (CCallBack invoke: callback) == 15.
	self assert: wasCalled
	! !

"September 9, 2009 -> 20:5:3"!

! (Delta mirrorFor: #Callback) classSide methodsFor: 'instance creation' !
block: block <[Alien, Alien]> stdcallArgsClass: class <Alien class> ^ <Callback>

	|callback|
	callback := self new.
	CallBackArray add: callback.
	{{primitiveCallBackRegisterPascallCall: CallBackArray size
		numberOfArguments: ((class dataSize + 3) / 4) asInteger
		result: callback
		ifFail: [:err | self error: err]}}.
	callback
		block: block
		argsProxy: class newForCallbackArgs.
	^callback! !

"September 9, 2009 -> 20:5:3"!

! (Delta mirrorFor: #Callback) classSide methodsFor: 'instance creation' !
block: block <[Alien, Alien]> stdcallArgsClass: class <Alien class> ^ <Callback>

	|callback|
	callback := self new.
	CallBackArray add: callback.
	{{primitiveCallBackRegisterPascalCall: CallBackArray size
		numberOfArguments: ((class dataSize + 3) / 4) asInteger
		result: callback
		ifFail: [:err | self error: err]}}.
	callback
		block: block
		argsProxy: class newForCallbackArgs.
	^callback! !

"September 9, 2009 -> 20:5:3"!

! (Delta mirrorFor: #CallbackTest) methodsFor: 'testing' !
testInvokeCCallback

	callback := Callback
							block: [:args :result|
										wasCalled := true.
										self assert: args first == 10.
										self assert: args second == 5.
										result returnInteger: args first + args second]
							argsClass: TestInvokeArgs.
	self assert: (CCallBack invoke: callback) == 15.
	self assert: wasCalled
	! !

"September 9, 2009 -> 20:5:3"!

! (Delta mirrorFor: #CallbackTest) methodsFor: 'testing' !
testInvokeStdcallCallback

	callback := Callback
							block: [:args :result|
										wasCalled := true.
										self assert: args first == 10.
										self assert: args second == 5.
										result returnInteger: args first + args second]
							stdcallArgsClass: TestInvokeArgs.
	self assert: (CCallBack invoke: callback) == 15.
	self assert: wasCalled
	! !

"September 9, 2009 -> 20:5:3"!

! (Delta mirrorFor: #Callback) classSide methodsFor: 'instance creation' !
block: block <[Alien, Alien]> stdcallArgsClass: class <Alien class> ^ <Callback>

	|callback|
	callback := self new.
	CallBackArray add: callback.
	{{primitiveCallBackRegisterPascallCall: CallBackArray size
		numberOfArguments: ((class dataSize + 3) / 4) asInteger
		result: callback
		ifFail: [:err | self error: err]}}.
	callback
		block: block
		argsProxy: class newForCallbackArgs.
	^callback! !

"September 9, 2009 -> 20:5:3"!

! (Delta mirrorFor: #Callback) classSide methodsFor: 'instance creation' !
block: block <[Alien, Alien]> stdcallArgsClass: class <Alien class> ^ <Callback>

	|callback|
	callback := self new.
	CallBackArray add: callback.
	{{primitiveCallBackRegisterPascalCall: CallBackArray size
		numberOfArguments: ((class dataSize + 3) / 4) asInteger
		result: callback
		ifFail: [:err | self error: err]}}.
	callback
		block: block
		argsProxy: class newForCallbackArgs.
	^callback! !

"September 9, 2009 -> 20:5:4"!

! (Delta mirrorFor: #CallbackTest) methodsFor: 'testing' !
testInvokeStdcallCallback

	callback := Callback
							block: [:args :result|
										wasCalled := true.
										self assert: args first == 10.
										self assert: args second == 5.
										result returnInteger: args first + args second]
							stdcallArgsClass: TestInvokeArgs.
	self assert: (APICallBack invoke: callback) == 15.
	self assert: wasCalled
	! !

"September 9, 2009 -> 20:7:16"!

"System saved" !
"September 9, 2009 -> 20:28:48"!

! (Delta mirrorFor: #Callback) classSide methodsFor: 'instance creation' !
block: block <[Alien, Alien]> stdcallArgsClass: class <Alien class> ^ <Callback>

	|callback|
	callback := self new.
	CallBackArray add: callback.
	{{primitiveCallBackRegisterPascalCall: CallBackArray size
		numberOfArguments: ((class dataSize + 3) // 4)
		result: callback
		ifFail: [:err | self error: err]}}.
	callback
		block: block
		argsProxy: class newForCallbackArgs.
	^callback! !

"September 9, 2009 -> 20:33:43"!

! (Delta mirrorFor: #CallbackTest) methodsFor: 'testing' !
invokeCCallbackWithNLR

	callback := Callback
							block: [:args :result| ^#nlr]
							argsClass: TestInvokeArgs.
	CCallBack invoke: callback
	! !

"September 9, 2009 -> 20:34:16"!

! (Delta mirrorFor: #CallbackTest) methodsFor: 'testing' !
testInvokeCCallbackWithNLR

	self assert: #nlr == self invokeCCallbackWithNLR
	! !

"September 9, 2009 -> 20:35:32"!

! (Delta mirrorFor: #CallbackTest) methodsFor: 'testing' !
invokePascalCallbackWithNLR

	callback := Callback
							block: [:args :result| ^#nlr]
							stdcallArgsClass: TestInvokeArgs.
	APICallBack invoke: callback
	! !

"September 9, 2009 -> 20:35:49"!

! (Delta mirrorFor: #CallbackTest) methodsFor: 'testing' !
invokeStdcallCallbackWithNLR

	callback := Callback
							block: [:args :result| ^#nlr]
							stdcallArgsClass: TestInvokeArgs.
	APICallBack invoke: callback
	! !

"September 9, 2009 -> 20:35:52"!

(Delta mirrorFor: #CallbackTest) removeMethod: #invokePascalCallbackWithNLR ifAbsent: [] !


"September 9, 2009 -> 20:36:3"!

! (Delta mirrorFor: #CallbackTest) methodsFor: 'testing' !
testInvokeStdcallCallbackWithNLR

	self assert: #nlr == self invokeStdcallCallbackWithNLR
	! !

"September 9, 2009 -> 20:37:17"!

! (Delta mirrorFor: #CallbackTest) methodsFor: 'testing' !
testBlockArgsClass

	callback := Callback
							block: [:args :result|
										wasCalled := true.
										self assert: args address == stack asInteger.
										result returnInteger: -3]
							argsClass: TestAlien.
	stack smallIntegerAt: 1 put: 1.
	self assert: (callback evaluate: stack) == -3.
	self assert: (CallBackArray at: callback index) == callback
	self assert: callback thunk = callback asInteger! !

"September 9, 2009 -> 20:43:36"!

! (Delta mirrorFor: #CallbackTest) methodsFor: 'testing' !
testBlockArgsClass

	callback := Callback
							block: [:args :result|
										wasCalled := true.
										self assert: args address == stack asInteger.
										result returnInteger: -3]
							argsClass: TestAlien.
	stack smallIntegerAt: 1 put: 1.
	self assert: (callback evaluate: stack) == -3.
	self assert: (CallBackArray at: callback index) == callback
	self assert: callback thunk address = callback asInteger! !

"September 9, 2009 -> 20:44:49"!

! (Delta mirrorFor: #Callback) methodsFor: 'accessing' !
thunk

	^Alien forPointer: self asInteger! !

"September 9, 2009 -> 20:45:20"!

! (Delta mirrorFor: #CallbackTest) methodsFor: 'testing' !
testBlockArgsClass

	callback := Callback
							block: [:args :result|
										wasCalled := true.
										self assert: args address == stack asInteger.
										result returnInteger: -3]
							argsClass: TestAlien.
	stack smallIntegerAt: 1 put: 1.
	self assert: (callback evaluate: stack) == -3.
	self assert: (CallBackArray at: callback index) == callback.
	self assert: callback thunk address = callback asInteger! !

"September 9, 2009 -> 20:45:54"!

! (Delta mirrorFor: #Callback) methodsFor: 'accessing' !
thunk ^<Alien>

	^Alien forPointer: self asInteger! !

"September 9, 2009 -> 21:2:9"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'fixture' !
libcName
	
	Platform == Win32Platform
		ifTrue: [^'msvcrt.dll'].
	Platform == MacOSXPlatform
		ifTrue: [^'libc.dylib'].
	Platform == UnixPlatform
		ifTrue: [^'libc.so.6']
	self error: 'Unsupported platform'! !

"September 9, 2009 -> 21:2:15"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'private - test support' !
libcName

	Platform == Win32Platform
		ifTrue: [^'msvcrt.dll'].
	Platform == MacOSXPlatform
		ifTrue: [^'libc.dylib'].
	Platform == UnixPlatform
		ifTrue: [^'libc.so.6'].
	self error: 'Platform set incorrectly'! !

"September 9, 2009 -> 21:9:40"!

Delta define: #AlienDemoTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"September 9, 2009 -> 21:11:26"!

! (Delta mirrorFor: #AlienDemoTest) methodsFor: 'test-support' !
libcName

	Platform == Win32Platform
		ifTrue: [^'msvcrt.dll'].
	Platform == MacOSXPlatform
		ifTrue: [^'libc.dylib'].
	Platform == UnixPlatform
		ifTrue: [^'libc.so.6'].
	self error: 'Unknow platform'! !

"September 9, 2009 -> 21:29:44"!

"System saved" !
"September 9, 2009 -> 21:46:24"!

Delta define: #UnsafeAlien as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"September 9, 2009 -> 21:47:25"!

"System saved" !
"September 10, 2009 -> 0:12:20"!

! (Delta mirrorFor: #UnsafeAlien) classSide methodsFor: 'instance creation' !
forPointerTo: bytes <IndexedByteInstanceVariables> ^ <UnsafeAlien>

	^self new
		nonPointerObject: bytes;
		yourself
		! !

"September 10, 2009 -> 0:12:58"!

Delta define: #UnsafeAlien as: (
(Class subclassOf: 'Object' instanceVariables: 'nonPointerObject <IndexedByteInstanceVariables>')) !


"September 10, 2009 -> 0:13:6"!

! (Delta mirrorFor: #UnsafeAlien) methodsFor: 'accessing' !
object

	^nonPointerObject! !

"September 10, 2009 -> 0:13:50"!

! (Delta mirrorFor: #UnsafeAlien) methodsFor: 'initialization' !
nonPointerObject: bytes <IndexedByteInstanceVariables>

	nonPointerObject := bytes! !

"September 10, 2009 -> 0:17:43"!

"System saved" !
"September 12, 2009 -> 19:8:56"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallLabsWithOneArg

	labs primFFICallResult: result
			with: -1.
	self assert: 1 == result asSignedLong! !

"September 12, 2009 -> 19:9:1"!

(Delta mirrorFor: #AlienFunctionTest) removeMethod: #testCallSprintfWithOneArg ifAbsent: [] !


"September 12, 2009 -> 19:13:40"!

! (Delta mirrorFor: #AlienFunctionTest) methodsFor: 'testing' !
testCallSprintfWithUnsafeAlienTarget
	
	Alien
		autoFreeAfter: [:free|
			|formatString bytes string unsafe|
			bytes := ByteArray new: 6.
			unsafe := UnsafeAlien forPointerTo: bytes.
			formatString := '12345' asString.
			sprintf primFFICallResult: nil
							with: unsafe
							with: (free value: formatString asAlien) pointer.
			self assert: formatString = (bytes copyWithSize: 5) asString]! !

"September 12, 2009 -> 19:16:8"!

"System saved" !
"September 12, 2009 -> 19:23:37"!

! (Delta mirrorFor: #AlienDemoTest) methodsFor: 'testing' !
testSprintf

	| r s |
	(Alien lookup: 'sprintf' inLibrary: Alien libcName)
		primFFICallResult: (r := Alien new: 4)
		withArguments: { UnsafeAlien forPointerTo: (s := ByteArray new: 1024).
						 			UnsafeAlien forPointerTo: 'Hello World %d %x !!!!'. "only works for symbols"
						 			123.
						 			48879}.
	self assert: 'Hello World 123 beef !!!!' = (s copyFrom: 1 to: (r signedLongAt: 1) - 1) asString! !

"September 12, 2009 -> 19:26:42"!

! (Delta mirrorFor: #AlienDemoTest) methodsFor: 'testing' !
testSprintf

	| r s |
	(Alien lookup: 'sprintf' inLibrary: self libcName)
		primFFICallResult: (r := Alien new: 4)
		withArguments: { UnsafeAlien forPointerTo: (s := ByteArray new: 1024).
						 			UnsafeAlien forPointerTo: 'Hello World %d %x !!!!'. "only works for symbols"
						 			123.
						 			48879}.
	self assert: 'Hello World 123 beef !!!!' = (s copyFrom: 1 to: (r signedLongAt: 1) - 1) asString! !

"September 12, 2009 -> 19:32:26"!

! (Delta mirrorFor: #ByteArray) methodsFor: 'copying' !
copyFrom: start <Int> to: stop <Int>   ^<VarSeqCltn[EX]>
	{where EX is returnType of #anElement message of receiverType}

	"The guarantee is typesafe since the inference clause guarantees that E < EX at the call site"
	| copy <VarSeqCltn[EX]> safeme <SeqCltn[EX]> |
	safeme := guaranteed <SeqCltn[EX]> self.
	copy := guaranteed <VarSeqCltn[EX]> (self class new: (stop - start) + 1).
	copy replaceFrom: 1 to: copy size with: safeme startingAt: start.
	^copy! !

"September 12, 2009 -> 19:33:25"!

! (Delta mirrorFor: #AlienDemoTest) methodsFor: 'testing' !
testSprintf

	| r s |
	(Alien lookup: 'sprintf' inLibrary: self libcName)
		primFFICallResult: (r := Alien new: 4)
		withArguments: { UnsafeAlien forPointerTo: (s := ByteArray new: 1024).
						 			UnsafeAlien forPointerTo: 'Hello World %d %x !!!!'. "only works for symbols"
						 			123.
						 			48879}.
	self assert: 'Hello World 123 beef !!!!' = (s copyFrom: 1 to: (r signedLongAt: 1)) asString! !

"September 12, 2009 -> 19:33:46"!

! (Delta mirrorFor: #AlienDemoTest) methodsFor: 'testing' !
testSprintf

	| r s |
	(Alien lookup: 'sprintf' inLibrary: self libcName)
		primFFICallResult: (r := Alien new: 4)
		withArguments: { UnsafeAlien forPointerTo: (s := ByteArray new: 1024).
						 			UnsafeAlien forPointerTo: 'Hello World %d %x !!!!'. "only works for symbols"
						 			123.
						 			48879}.
	self assert: 'Hello World 123 BEEF !!!!' = (s copyFrom: 1 to: (r signedLongAt: 1)) asString! !

"September 12, 2009 -> 19:34:15"!

! (Delta mirrorFor: #AlienDemoTest) methodsFor: 'testing' !
testSprintf

	| r s actual |
	(Alien lookup: 'sprintf' inLibrary: self libcName)
		primFFICallResult: (r := Alien new: 4)
		withArguments: { UnsafeAlien forPointerTo: (s := ByteArray new: 1024).
						 			UnsafeAlien forPointerTo: 'Hello World %d %x !!!!'. "only works for symbols"
						 			123.
						 			48879}.
	actual := (s copyFrom: 1 to: (r signedLongAt: 1)) asString.
	self assert: 'Hello World 123 BEEF !!!!' = actual! !

"September 12, 2009 -> 19:36:44"!

! (Delta mirrorFor: #AlienDemoTest) methodsFor: 'testing' !
testSprintf

	| r s actual |
	(Alien lookup: 'sprintf' inLibrary: self libcName)
		primFFICallResult: (r := Alien new: 4)
		withArguments: { UnsafeAlien forPointerTo: (s := ByteArray new: 1024).
						 			UnsafeAlien forPointerTo: 'Hello World %d %x !!!!'. "only works for symbols"
						 			123.
						 			48879}.
	actual := (s copyFrom: 1 to: (r signedLongAt: 1)) asString.
	Transcript show: actual.
	self assert: 'Hello World 123 BEEF !!!!' = actual! !

"September 12, 2009 -> 19:38:21"!

! (Delta mirrorFor: #AlienDemoTest) methodsFor: 'testing' !
testSprintf

	| r s actual |
	(Alien lookup: 'sprintf' inLibrary: self libcName)
		primFFICallResult: (r := Alien new: 4)
		withArguments: { UnsafeAlien forPointerTo: (s := ByteArray new: 1024).
						 			UnsafeAlien forPointerTo: 'Hello World %d %x !!!!'. "only works for symbols"
						 			123.
						 			48879}.
	Transcript print: (r asSignedLong).
	actual := (s copyFrom: 1 to: (r signedLongAt: 1)) asString.
	Transcript show: actual.
	self assert: 'Hello World 123 beef !!!!' = actual! !

"September 12, 2009 -> 19:40:35"!

! (Delta mirrorFor: #AlienDemoTest) methodsFor: 'testing' !
testSprintf

	| r s actual |
	(Alien lookup: 'sprintf' inLibrary: self libcName)
		primFFICallResult: (r := Alien new: 4)
		withArguments: { UnsafeAlien forPointerTo: (s := ByteArray new: 1024).
						 			UnsafeAlien forPointerTo: ('Hello World %d %x !!!!', Character nul) asSymbol. "only works for symbols"
						 			123.
						 			48879}.
	Transcript print: (r asSignedLong).
	actual := (s copyFrom: 1 to: (r signedLongAt: 1)) asString.
	Transcript show: actual.
	self assert: 'Hello World 123 beef !!!!' = actual! !

"September 12, 2009 -> 19:41:11"!

! (Delta mirrorFor: #AlienDemoTest) methodsFor: 'testing' !
testSprintf

	| r s actual |
	(Alien lookup: 'sprintf' inLibrary: self libcName)
		primFFICallResult: (r := Alien new: 4)
		withArguments: { UnsafeAlien forPointerTo: (s := ByteArray new: 1024).
						 			UnsafeAlien forPointerTo: ('Hello World %d %x !!!!', (String with: Character nul)) asSymbol. "only works for symbols"
						 			123.
						 			48879}.
	Transcript print: (r asSignedLong).
	actual := (s copyFrom: 1 to: (r signedLongAt: 1)) asString.
	Transcript show: actual.
	self assert: 'Hello World 123 beef !!!!' = actual! !

"September 12, 2009 -> 19:46:59"!

! (Delta mirrorFor: #AlienDemoTest) methodsFor: 'testing' !
testCqsort
	"Call the libc qsort function (which requires a callback)."
"	| cb rand nElements sizeofDouble values orig sort |
	rand:= Random new.
	values:= Alien newC: (nElements:= 100) * (sizeofDouble:= 8).
	1 to: values dataSize by: sizeofDouble do:
		[:i| values doubleAt: i put: rand next].
	orig:= (1 to: values dataSize by: sizeofDouble) collect: [:i| values doubleAt: i].
	cb:= Callback
			block: [:args :result|
					result returnInteger: ((args first doubleAt: 1) - (args second doubleAt: 1)) sign]
			argsClass: QsortCompare.
	(Alien lookup: 'qsort' inLibrary: libcName)
		primFFICallResult: nil
		with: values pointer
		with: nElements
		with: sizeofDouble
		with: cb thunk.
	sort:= (1 to: values dataSize by: sizeofDouble) collect: [:i| values doubleAt: i].
	values free.
	^orig -> sort"! !

"September 12, 2009 -> 19:47:37"!

! (Delta mirrorFor: #AlienDemoTest) methodsFor: 'testing' !
testCqsort
	"Call the libc qsort function (which requires a callback)."
	| cb rand nElements sizeofDouble values orig sort |
	rand:= Random new.
"	values:= Alien newC: (nElements:= 100) * (sizeofDouble:= 8).
	1 to: values dataSize by: sizeofDouble do:
		[:i| values doubleAt: i put: rand next].
	orig:= (1 to: values dataSize by: sizeofDouble) collect: [:i| values doubleAt: i].
	cb:= Callback
			block: [:args :result|
					result returnInteger: ((args first doubleAt: 1) - (args second doubleAt: 1)) sign]
			argsClass: QsortCompare.
	(Alien lookup: 'qsort' inLibrary: libcName)
		primFFICallResult: nil
		with: values pointer
		with: nElements
		with: sizeofDouble
		with: cb thunk.
	sort:= (1 to: values dataSize by: sizeofDouble) collect: [:i| values doubleAt: i].
	values free.
	^orig -> sort"! !

"September 12, 2009 -> 19:47:43"!

! (Delta mirrorFor: #AlienDemoTest) methodsFor: 'testing' !
testCqsort
	"Call the libc qsort function (which requires a callback)."
	| cb rand nElements sizeofDouble values orig sort |
	rand:= Random new.
	values:= Alien newC: (nElements:= 100) * (sizeofDouble:= 8).
"	1 to: values dataSize by: sizeofDouble do:
		[:i| values doubleAt: i put: rand next].
	orig:= (1 to: values dataSize by: sizeofDouble) collect: [:i| values doubleAt: i].
	cb:= Callback
			block: [:args :result|
					result returnInteger: ((args first doubleAt: 1) - (args second doubleAt: 1)) sign]
			argsClass: QsortCompare.
	(Alien lookup: 'qsort' inLibrary: libcName)
		primFFICallResult: nil
		with: values pointer
		with: nElements
		with: sizeofDouble
		with: cb thunk.
	sort:= (1 to: values dataSize by: sizeofDouble) collect: [:i| values doubleAt: i].
	values free.
	^orig -> sort"! !

"September 12, 2009 -> 21:12:50"!

! (Delta mirrorFor: #AlienDemoTest) methodsFor: 'testing' !
testSprintf

	| r s actual |
	(Alien lookup: 'sprintf' inLibrary: self libcName)
		primFFICallResult: (r := Alien new: 4)
		withArguments: { UnsafeAlien forPointerTo: (s := ByteArray new: 1024).
						 			UnsafeAlien forPointerTo: ('Hello World %d %x !!!!', (String with: Character nul)) asSymbol. "only works for symbols"
						 			123.
						 			48879}.
	actual := (s copyFrom: 1 to: (r signedLongAt: 1)) asString.
	self assert: 'Hello World 123 beef !!!!' = actual! !

"September 12, 2009 -> 21:13:40"!

"System saved" !
"September 13, 2009 -> 17:1:17"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLMapName: name <Str> ^<Str>
	(name endsWith: '.dylib') ifTrue: [^name].
    name = 'libc' ifTrue: [^'libc.dylib'].
    ^name, '.dylib'! !

"September 13, 2009 -> 17:50:18"!

Delta define: #ReadStringTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"September 13, 2009 -> 17:50:28"!

(Delta mirrorFor: #ReadStringTest) removeDefinitionIfFail: [] !


"September 13, 2009 -> 17:50:37"!

Delta define: #StringTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"September 13, 2009 -> 17:52:0"!

! (Delta mirrorFor: #StringTest) methodsFor: 'testing' !
testEndsWith

	| source |
	source := 'Elvis' asString.
	self assert: (source endsWith: 'vis')! !

"September 13, 2009 -> 17:57:25"!

! (Delta mirrorFor: #String) methodsFor: 'comparing' !
endsWith: chars <SequenceableCollection[Character]>

	^(self indicesOfSubCollection: chars
			startingAt: 1) last + chars size - 1 = self size
			! !

"September 13, 2009 -> 17:58:14"!

! (Delta mirrorFor: #StringTest) methodsFor: 'testing' !
testEndsWith

	| source |
	source := 'Elvis' asString.
	self assert: (source endsWith: 'vis').
	self deny: (source endsWith: 'El').! !

"September 13, 2009 -> 17:58:41"!

! (Delta mirrorFor: #StringTest) methodsFor: 'testing' !
testEndsWith

	| source |
	source := 'Elvis' asString.
	self assert: (source endsWith: 'vis').
	self deny: (source endsWith: 'El').
	self deny: (source endsWith: 'the').! !

"September 13, 2009 -> 18:0:5"!

! (Delta mirrorFor: #String) methodsFor: 'comparing' !
endsWith: chars <SequenceableCollection[Character]>

	| indices <Collection[Integer]> |
	indices := (self indicesOfSubCollection: chars startingAt: 1).
	indices isEmpty ifTrue: [^false].
	^indices last + chars size - 1 = self size
			! !

"September 13, 2009 -> 18:0:28"!

! (Delta mirrorFor: #String) methodsFor: 'comparing' !
endsWith: chars <SequenceableCollection[Character]>

	| indices <Collection[Integer]> |
	indices := (self indicesOfSubCollection: chars).
	indices isEmpty ifTrue: [^false].
	^indices last + chars size - 1 = self size
			! !

"September 13, 2009 -> 18:2:12"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLMapName: name <Str> ^<Str>
	(name contains: '.so') ifTrue: [^name].
    name = 'libc' ifTrue: [^'libc.so.6'].
    ^name, '.so'! !

"September 13, 2009 -> 18:2:33"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLMapName: name <Str> ^<Str>
	(name includes: '.so') ifTrue: [^name].
    name = 'libc' ifTrue: [^'libc.so.6'].
    ^name, '.so'! !

"September 13, 2009 -> 18:8:32"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLMapName: name <Str> ^<Str>
	name indexOfSubCollection: '.so'
			startingAt: 1
			ifAbsent: [name = 'libc' ifTrue: [^'libc.so.6'].
    						^name, '.so'].
    ^name    ! !

"September 13, 2009 -> 18:10:11"!

! (Delta mirrorFor: #StringTest) methodsFor: 'testing' !
testIndexOfSubCollectionStartingAtIfAbsent

	| source |
	source := 'Elvis' asString.
	self assert: (source indexOfSubCollection: 'vis'
								startingAt: 1
								ifAbsent: [self fail])! !

"September 13, 2009 -> 18:10:50"!

! (Delta mirrorFor: #StringTest) methodsFor: 'testing' !
testIndexOfSubCollectionStartingAtIfAbsent

	| source |
	source := 'Elvis' asString.
	self assert: (source indexOfSubCollection: 'vis'
								startingAt: 1
								ifAbsent: [self fail]) = 3! !

"September 13, 2009 -> 18:12:11"!

! (Delta mirrorFor: #StringTest) methodsFor: 'testing' !
testIndexOfSubCollectionStartingAtIfAbsent

	| source |
	source := 'Elvis' asString.
	self assert: (source indexOfSubCollection: 'vis'
								startingAt: 1
								ifAbsent: [self fail]) = 3.
	self assert: (source indexOfSubCollection: 'lv'
								startingAt: 1
								ifAbsent: [self fail]) = 2.! !

"September 13, 2009 -> 18:14:37"!

"System saved" !
"September 13, 2009 -> 18:22:32"!

! (Delta mirrorFor: #StringTest) methodsFor: 'testing' !
testEndsWith

	| source |
	source := 'Elvis' asString.
	self assert: (source endsWith: 'vis').
	self assert: ('Elvis' endsWith: 'vis').
	self deny: (source endsWith: 'El').
	self deny: (source endsWith: 'the').! !

"September 13, 2009 -> 18:23:37"!

! (Delta mirrorFor: #ReadString) methodsFor: 'comparing-case sensitive' !
endsWith: chars <SequenceableCollection[Character]>

	| indices <Collection[Integer]> |
	indices := (self indicesOfSubCollection: chars).
	indices isEmpty ifTrue: [^false].
	^indices last + chars size - 1 = self size! !

"September 13, 2009 -> 18:23:44"!

(Delta mirrorFor: #String) removeMethod: #endsWith: ifAbsent: [] !


"September 13, 2009 -> 18:24:13"!

"System saved" !
"September 19, 2009 -> 16:24:0"!

! (Delta mirrorFor: #Font) methodsFor: 'restricted-win32' !
charGlyphFor: c <Character> paint: paint <Paint>  ^<CharacterGlyph>
	"Return the Glyph for the specified character of this font that will render
	  using the paint p."

	| curmap <CanonicalCharGlyphs> gl <CharacterGlyph> code <Int> |
	
	"We must cache the curmap in a local variable so that we can avoid a critical
			region"
	curmap := self currentMap.
	
	(curmap == nil or: [ curmap paint ~~ paint and: [ curmap paint ~= paint ]])
		ifTrue: [	curmap := self uncachedMapFor: paint.
						self currentMap: curmap.	].

	code := c unicodeValue.
	code = 0 ifTrue: [code := $. unicodeValue].
	code > curmap size
		ifTrue: [	curmap := curmap copyWithSize: c unicodeValue.
						self currentMap: curmap.
						self critical:
							[	self allMaps include: curmap. ].
					].

	gl := curmap at: c unicodeValue.
	gl == nil
		ifTrue: [	gl := CharacterGlyph buildFor: c painter: curmap painter.
						curmap at: c unicodeValue put: gl.	 ].
	^gl
! !

"September 19, 2009 -> 16:26:11"!

! (Delta mirrorFor: #Font) methodsFor: 'restricted-win32' !
charGlyphFor: c <Character> paint: paint <Paint>  ^<CharacterGlyph>
	"Return the Glyph for the specified character of this font that will render
	  using the paint p."

	| curmap <CanonicalCharGlyphs> gl <CharacterGlyph> code <Int> ch <Character> |
	
	"We must cache the curmap in a local variable so that we can avoid a critical
			region"
	curmap := self currentMap.
	
	(curmap == nil or: [ curmap paint ~~ paint and: [ curmap paint ~= paint ]])
		ifTrue: [	curmap := self uncachedMapFor: paint.
						self currentMap: curmap.	].
	ch := c unicodeValue = 0 ifTrue: [$.] ifFalse: [c].
	code := ch unicodeValue.
	code > curmap size
		ifTrue: [	curmap := curmap copyWithSize: ch unicodeValue.
						self currentMap: curmap.
						self critical:
							[	self allMaps include: curmap. ].
					].

	gl := curmap at: ch unicodeValue.
	gl == nil
		ifTrue: [	gl := CharacterGlyph buildFor: ch painter: curmap painter.
						curmap at: ch unicodeValue put: gl.	 ].
	^gl
! !

"September 19, 2009 -> 16:34:55"!

(Delta mirrorFor: #Classifier) removeDefinitionIfFail: [] !


"September 19, 2009 -> 16:36:16"!

"System saved" !
"September 20, 2009 -> 20:0:47"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
methodSource ^<Str>

	^self activation vmPrettyPrint! !

"September 20, 2009 -> 20:0:47"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildCodeView ^<Visual>

	| cv <CodeView> vmSrc <Str> strm <CharacterReadStream> gls <OrdCltn[CharacterGlyph]> |

	"Construct vm source with highligthed bci"
	vmSrc := self methodSource.
	strm := vmSrc readStream.
	gls := OrderedCollection[CharacterGlyph] new: vmSrc size.
	(vmSrc occurrencesOf: self currentByteCodeSeparatorCharacter) = 2
		ifTrue: [	gls addAll: (self standardTextForString: (strm upTo: self currentByteCodeSeparatorCharacter) painter: self codePainter).
						gls addAll: (self standardTextForString: (strm upTo: self currentByteCodeSeparatorCharacter) painter: self codeBCIPainter) ].
	gls addAll: (self standardTextForString: strm contentsRemaining painter: self codePainter).
	
	cv := CodeView forText.
	cv doneBlock: [ :b <Boolean> :onSuccess <[]> | b ifTrue: onSuccess ].	"Dummy for now, we are not showing the real source code"
	cv model: gls.
	^self editorBorderFor: cv
! !

"September 20, 2009 -> 20:0:47"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
methodSource2 ^<Str>

	|method mirror fail|
	fail := [:e| ^self activation vmPrettyPrint].
	mirror := Mirror on: self activation receiver class.
	method := mirror compiledMethodAt: self activation method selector ifFail: fail.
	

	fail value: nil! !

"September 20, 2009 -> 20:0:47"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
vmMethodSource ^<Str>

	^self activation vmPrettyPrint! !

"September 20, 2009 -> 20:0:47"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
methodSource2 ^<Str>

	|method mirror selector|
	self activation method isBlockMethod ifTrue: [^self vmMethodSource].
	selector := self activation method selector.
	mirror := Mirror on: self activation receiver class.
	method := mirror compiledMethodAt: selector ifFail: [:e| ^self vmMethodSource].
	^(self activation method == method)
		ifTrue: [mirror sourceForSelector: selector]
		ifFalse: [self vmMethodSource]! !

"September 20, 2009 -> 20:0:47"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
methodSource ^<Str>

	|method mirror selector|
	self activation method isBlockMethod ifTrue: [^self vmMethodSource].
	selector := self activation method selector.
	mirror := Mirror on: self activation receiver class.
	method := mirror compiledMethodAt: selector ifFail: [:e| ^self vmMethodSource].
	^(self activation method == method)
		ifTrue: [mirror sourceForSelector: selector]
		ifFalse: [self vmMethodSource]! !

"September 20, 2009 -> 20:0:47"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
methodSource ^<Str>

	|method mirror selector|
	self activation method isBlockMethod ifTrue: [^self vmMethodSource].
	selector := self activation method selector.
	mirror := Mirror on: self activation receiver class.
	method := mirror compiledMethodAt: selector ifFail: [^self vmMethodSource].
	^(self activation method == method)
		ifTrue: [mirror sourceForSelector: selector]
		ifFalse: [self vmMethodSource]! !

"September 20, 2009 -> 20:0:47"!

(Delta mirrorFor: #ActivationOutliner) removeMethod: #methodSource2 ifAbsent: [] !


"September 20, 2009 -> 20:0:47"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
mirror ^<ClassMirror>

	^Mirror on: self activation receiver class! !

"September 20, 2009 -> 20:0:47"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
methodSource ^<Str>

	|method selector|
	self activation method isBlockMethod ifTrue: [^self vmMethodSource].
	selector := self activation method selector.
	method := self mirror compiledMethodAt: selector ifFail: [^self vmMethodSource].
	^(self activation method == method)
		ifTrue: [self mirror sourceForSelector: selector]
		ifFalse: [self vmMethodSource]! !

"September 20, 2009 -> 20:0:47"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
hasSelector ^<Boolean>

	^self activation method isBlockMethod not! !

"September 20, 2009 -> 20:0:47"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
methodSource ^<Str>

	|method selector|
	self hasSelector ifFalse: [^self vmMethodSource].
	selector := self activation method selector.
	method := self mirror compiledMethodAt: selector ifFail: [^self vmMethodSource].
	^(self activation method == method)
		ifTrue: [self mirror sourceForSelector: selector]
		ifFalse: [self vmMethodSource]! !

"September 20, 2009 -> 20:0:47"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
selector ^<Symbol>

	^self activation method selector! !

"September 20, 2009 -> 20:0:47"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
methodSource ^<Str>

	|method|
	self hasSelector ifFalse: [^self vmMethodSource].
	method := self mirror compiledMethodAt: self selector 
										ifFail: [^self vmMethodSource].
	^(self activation method == method)
		ifTrue: [self mirror sourceForSelector: self selector]
		ifFalse: [self vmMethodSource]! !

"September 20, 2009 -> 20:0:47"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
method

	^self mirror compiledMethodAt: self selector 
						ifFail: []! !

"September 20, 2009 -> 20:0:47"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
hasSelector ^<Boolean>

	^self activation method isBlockMethod not
		and: [self method == self activation method]! !

"September 20, 2009 -> 20:3:5"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
isBlockActivation ^<Boolean>

	^self activation method isBlockMethod! !

"September 20, 2009 -> 20:3:19"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
hasSelector ^<Boolean>

	^self isBlockActivation not
		and: [self method == self activation method]! !

"September 20, 2009 -> 20:3:45"!

"System saved" !
"September 21, 2009 -> 20:38:43"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
methodSource ^<Str>

	|method|
	self hasSelector ifFalse: [^self vmMethodSource].
	method := self mirror compiledMethodAt: self selector 
										ifFail: [^self vmMethodSource].
	^(self activation method == self method)
		ifTrue: [self mirror sourceForSelector: self selector]
		ifFalse: [self vmMethodSource]! !

"September 21, 2009 -> 20:38:43"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
methodSource ^<Str>

	|method|
	self hasSelector ifFalse: [^self vmMethodSource].
	^(self activation method == self method)
		ifTrue: [self mirror sourceForSelector: self selector]
		ifFalse: [self vmMethodSource]! !

"September 21, 2009 -> 20:38:43"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
methodSource ^<Str>

	^self hasSelector
		ifTrue: [self mirror sourceForSelector: self selector]
		ifFalse: [self vmMethodSource]! !

"September 21, 2009 -> 20:38:43"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'private' !
ActivationOutliner

	^ActivationOutliner! !

"September 21, 2009 -> 20:38:43"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'private' !
outlinerFor: activation <Activation> open: b <Boolean>

	^(self ActivationOutliner
			on: activation
			debugger: self)
				open: b;
				imbeddedVisual! !

"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #Debugger as: (
(Class subclassOf: 'StackTraceInspector' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

! (Delta mirrorFor: #Debugger) methodsFor: 'restricted' !
ActivationOutline

	^EditableActivationOutliner! !

"September 21, 2009 -> 20:38:44"!

! (Delta mirrorFor: #Debugger) methodsFor: 'restricted' !
ActivationOutliner

	^EditableActivationOutliner! !

"September 21, 2009 -> 20:38:44"!

(Delta mirrorFor: #Debugger) removeMethod: #ActivationOutline ifAbsent: [] !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:44"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner mixin |> MessageDeclarationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

! (Delta mirrorFor: #EditableActivationOutliner) methodsFor: 'private' !
initialOpenState

	^false! !

"September 21, 2009 -> 20:38:45"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
isMethodActivation ^<Boolean>

	^self activation isSmalltalk and: [self activation method isBlockMethod not]! !

"September 21, 2009 -> 20:38:45"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
hasSelector ^<Boolean>

	^self isMethodActivation
		and: [self method == self activation method]! !

"September 21, 2009 -> 20:38:45"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
hasSelector ^<Boolean>

	^self isMethodActivation! !

"September 21, 2009 -> 20:38:45"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
method

	|method mirror|
	self mirror compiledMethodAt: self selector 
						ifFail: []! !

"September 21, 2009 -> 20:38:45"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
isBlockActivation ^<Boolean>

	^self activation isSmalltalk and: [self activation method isBlockMethod]! !

"September 21, 2009 -> 20:38:45"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
method

	|method mirror|
	mirror := Mirror on: self activation receiver class.
	[mirror isNil]
		whileFalse: [method := mirror compiledMethodAt: self selector ifFail: [].
							method isNil ifFalse: [^method].
							mirror := mirror superclass].
	^nil! !

"September 21, 2009 -> 20:38:45"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
mirror

	|method mirror|
	mirror := Mirror on: self activation receiver class.
	[mirror isNil]
		whileFalse: [method := mirror compiledMethodAt: self selector ifFail: [].
							method isNil ifFalse: [^mirror].
							mirror := mirror superclass].
	^nil! !

"September 21, 2009 -> 20:38:45"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
methodSource ^<Str>

	^(self hasSelector and: [self mirror notNil])
		ifTrue: [self mirror sourceForSelector: self selector]
		ifFalse: [self vmMethodSource]! !

"September 21, 2009 -> 20:38:45"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
method

	^self mirror isNil
		ifTrue: [nil]
		ifFalse: [self mirror compiledMethodAt: self selector]! !

"September 21, 2009 -> 20:38:45"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
mirror

	|mirror|
	mirror := Mirror on: self activation receiver class.
	[mirror isNil]
		whileFalse: [(mirror hasSelector: self selector) ifTrue: [^mirror].
							mirror := mirror superclass].
	^nil! !

"September 21, 2009 -> 20:38:45"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
sourceAsCharGlyphs ^<Visual>

	| vmSrc <Str> strm <CharacterReadStream> gls <OrdCltn[CharacterGlyph]> |

	"Construct vm source with highligthed bci"
	vmSrc := self methodSource.
	strm := vmSrc readStream.
	gls := OrderedCollection[CharacterGlyph] new: vmSrc size.
	(vmSrc occurrencesOf: self currentByteCodeSeparatorCharacter) = 2
		ifTrue: [	gls addAll: (self standardTextForString: (strm upTo: self currentByteCodeSeparatorCharacter) painter: self codePainter).
						gls addAll: (self standardTextForString: (strm upTo: self currentByteCodeSeparatorCharacter) painter: self codeBCIPainter) ].
	gls addAll: (self standardTextForString: strm contentsRemaining painter: self codePainter).
	^gls
! !

"September 21, 2009 -> 20:38:45"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
sourceAsCharGlyphs ^<CharGlyphs>

	| vmSrc <Str> strm <CharacterReadStream> gls <OrdCltn[CharacterGlyph]> |

	"Construct vm source with highligthed bci"
	vmSrc := self methodSource.
	strm := vmSrc readStream.
	gls := OrderedCollection[CharacterGlyph] new: vmSrc size.
	(vmSrc occurrencesOf: self currentByteCodeSeparatorCharacter) = 2
		ifTrue: [	gls addAll: (self standardTextForString: (strm upTo: self currentByteCodeSeparatorCharacter) painter: self codePainter).
						gls addAll: (self standardTextForString: (strm upTo: self currentByteCodeSeparatorCharacter) painter: self codeBCIPainter) ].
	gls addAll: (self standardTextForString: strm contentsRemaining painter: self codePainter).
	^gls
! !

"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:45"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:46"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:46"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:46"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:46"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:46"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:46"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:46"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:46"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:46"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:46"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:46"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:46"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:46"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:46"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:46"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:46"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:46"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:46"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:46"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:46"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:46"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:46"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:46"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:46"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:46"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:46"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:46"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:46"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:46"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:46"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:46"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:46"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'MessageDeclarationOutliner mixin |> ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 20:38:46"!

! (Delta mirrorFor: #EditableActivationOutliner) methodsFor: 'private' !
initActivation: a <Activation> debugger: d <StackTraceInspector>

	super initActivation: a
		debugger: d.
	! !

"September 21, 2009 -> 20:38:46"!

! (Delta mirrorFor: #EditableActivationOutliner) methodsFor: 'private' !
initActivation: a <Activation> debugger: d <StackTraceInspector>

	super initActivation: a
		debugger: d.
	self isMethodActivation
		ifTrue: [selector := self activation method selector]! !

"September 21, 2009 -> 20:38:46"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
isExterernal ^ <Boolean>

	^self activation isSmalltalk not! !

"September 21, 2009 -> 20:38:46"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildClosedHeader ^ <Visual>

	| selector <Symbol> args <Array[Object]> row <Row[Visual]> |
	
	"Check type of activation"
	self isExternal
		ifTrue: [	^(StringGlyph for: 'External activation' painter: self codePainter) asVisual ].

	selector := self activation method enclosingMethod selector.
	args := self activation arguments.
	row := Row[Visual] new.
	
	self activation method isBlockMethod
		ifTrue: [		"Add block parens interspersed with arguments"
							row add: (StringGlyph for: '[' painter: self codePainter) asVisual.
							args do: [ :arg <Object> |
								row add: (StringGlyph for: ':' painter: self selectorPainter) asVisual.
								row add: (self
									buildLabel: (self safePrintString: arg)
									painter: self codePainter
									action: [ (Inspector on: arg) launch ]) ].
							row add: (StringGlyph for: '] in ' painter: self codePainter) asVisual.
							row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
		ifFalse: [	"Add receiver"
							| receiver <Object> |
							receiver := self activation receiver.
							row add: (self
								buildLabel: (self safePrintString: receiver)
								painter: self codePainter
								action: [ (Inspector on: receiver) launch ]).
							row add: (StringGlyph for: '>> ' painter: self codePainter) asVisual.
							"Add selector interspersed with arguments"
							args size = 0
								ifTrue: [		row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
								ifFalse: [	| strm <CharacterReadStream> |
													strm := selector readStream.
													args do: [ :arg <Object> |
														row add: (StringGlyph for: (strm upTo: $:), ':' painter: self selectorPainter) asVisual.
														row add: (self
															buildLabel: (self safePrintString: arg)
															painter: self codePainter
															action: [ (Inspector on: arg) launch ]) ]
												]
						].
	^row! !

"September 21, 2009 -> 20:38:46"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildExternalHeader ^ <Visual>

	^(StringGlyph for: 'External activation' painter: self codePainter) asVisual! !

"September 21, 2009 -> 20:38:46"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildClosedHeader ^ <Visual>

	| selector <Symbol> args <Array[Object]> row <Row[Visual]> |
	
	"Check type of activation"
	self isExternal
		ifTrue: [	^self buildExternalHeader].

	selector := self activation method enclosingMethod selector.
	args := self activation arguments.
	row := Row[Visual] new.
	
	self activation method isBlockMethod
		ifTrue: [		"Add block parens interspersed with arguments"
							row add: (StringGlyph for: '[' painter: self codePainter) asVisual.
							args do: [ :arg <Object> |
								row add: (StringGlyph for: ':' painter: self selectorPainter) asVisual.
								row add: (self
									buildLabel: (self safePrintString: arg)
									painter: self codePainter
									action: [ (Inspector on: arg) launch ]) ].
							row add: (StringGlyph for: '] in ' painter: self codePainter) asVisual.
							row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
		ifFalse: [	"Add receiver"
							| receiver <Object> |
							receiver := self activation receiver.
							row add: (self
								buildLabel: (self safePrintString: receiver)
								painter: self codePainter
								action: [ (Inspector on: receiver) launch ]).
							row add: (StringGlyph for: '>> ' painter: self codePainter) asVisual.
							"Add selector interspersed with arguments"
							args size = 0
								ifTrue: [		row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
								ifFalse: [	| strm <CharacterReadStream> |
													strm := selector readStream.
													args do: [ :arg <Object> |
														row add: (StringGlyph for: (strm upTo: $:), ':' painter: self selectorPainter) asVisual.
														row add: (self
															buildLabel: (self safePrintString: arg)
															painter: self codePainter
															action: [ (Inspector on: arg) launch ]) ]
												]
						].
	^row! !

"September 21, 2009 -> 20:38:46"!

! (Delta mirrorFor: #EditableActivationOutliner) methodsFor: 'private' !
buildClosedHeader

	^self isExternal
		ifTrue: [self buildExternalHeader]
		ifFalse: [super buildClosedHeader]! !

"September 21, 2009 -> 21:3:23"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 21:3:23"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 21:3:23"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 21:3:23"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 21:3:23"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 21:3:23"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 21:3:23"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 21:3:23"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 21:3:23"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 21:3:23"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 21:3:23"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner' instanceVariables: '')) !


"September 21, 2009 -> 21:4:1"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
isExternal ^ <Boolean>

	^self activation isSmalltalk not! !

"September 21, 2009 -> 21:4:10"!

(Delta mirrorFor: #ActivationOutliner) removeMethod: #isExterernal ifAbsent: [] !


"September 21, 2009 -> 21:6:5"!

! (Delta mirrorFor: #EditableActivationOutliner) methodsFor: 'private' !
buildClosedHeader2

	^self isExternal
		ifTrue: [self buildExternalHeader]
		ifFalse: [super buildClosedHeader]! !

"September 21, 2009 -> 21:6:9"!

! (Delta mirrorFor: #EditableActivationOutliner) methodsFor: 'private' !
buildClosedHeader ^ <Visual>

	| selector <Symbol> args <Array[Object]> row <Row[Visual]> |
	
	"Check type of activation"
	self isExternal
		ifTrue: [	^self buildExternalHeader].

	selector := self activation method enclosingMethod selector.
	args := self activation arguments.
	row := Row[Visual] new.
	
	self activation method isBlockMethod
		ifTrue: [		"Add block parens interspersed with arguments"
							row add: (StringGlyph for: '[' painter: self codePainter) asVisual.
							args do: [ :arg <Object> |
								row add: (StringGlyph for: ':' painter: self selectorPainter) asVisual.
								row add: (self
									buildLabel: (self safePrintString: arg)
									painter: self codePainter
									action: [ (Inspector on: arg) launch ]) ].
							row add: (StringGlyph for: '] in ' painter: self codePainter) asVisual.
							row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
		ifFalse: [	"Add receiver"
							| receiver <Object> |
							receiver := self activation receiver.
							row add: (self
								buildLabel: (self safePrintString: receiver)
								painter: self codePainter
								action: [ (Inspector on: receiver) launch ]).
							row add: (StringGlyph for: '>> ' painter: self codePainter) asVisual.
							"Add selector interspersed with arguments"
							args size = 0
								ifTrue: [		row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
								ifFalse: [	| strm <CharacterReadStream> |
													strm := selector readStream.
													args do: [ :arg <Object> |
														row add: (StringGlyph for: (strm upTo: $:), ':' painter: self selectorPainter) asVisual.
														row add: (self
															buildLabel: (self safePrintString: arg)
															painter: self codePainter
															action: [ (Inspector on: arg) launch ]) ]
												]
						].
	^row! !

"September 21, 2009 -> 21:7:12"!

! (Delta mirrorFor: #EditableActivationOutliner) methodsFor: 'private' !
buildExternalHeader ^ <Visual>

	^(StringGlyph for: 'External activation' painter: self codePainter) asVisual! !

"September 21, 2009 -> 21:7:23"!

! (Delta mirrorFor: #EditableActivationOutliner) methodsFor: 'private' !
buildCodeView ^<Visual>

	| cv <CodeView> vmSrc <Str> strm <CharacterReadStream> gls <OrdCltn[CharacterGlyph]> |

	"Construct vm source with highligthed bci"
	vmSrc := self methodSource.
	strm := vmSrc readStream.
	gls := OrderedCollection[CharacterGlyph] new: vmSrc size.
	(vmSrc occurrencesOf: self currentByteCodeSeparatorCharacter) = 2
		ifTrue: [	gls addAll: (self standardTextForString: (strm upTo: self currentByteCodeSeparatorCharacter) painter: self codePainter).
						gls addAll: (self standardTextForString: (strm upTo: self currentByteCodeSeparatorCharacter) painter: self codeBCIPainter) ].
	gls addAll: (self standardTextForString: strm contentsRemaining painter: self codePainter).
	
	cv := CodeView forText.
	cv doneBlock: [ :b <Boolean> :onSuccess <[]> | b ifTrue: onSuccess ].	"Dummy for now, we are not showing the real source code"
	cv model: gls.
	^self editorBorderFor: cv
! !

"September 21, 2009 -> 21:7:36"!

! (Delta mirrorFor: #EditableActivationOutliner) methodsFor: 'private' !
hasSelector ^<Boolean>

	^self isMethodActivation! !

"September 21, 2009 -> 21:7:45"!

! (Delta mirrorFor: #EditableActivationOutliner) methodsFor: 'private' !
isBlockActivation ^<Boolean>

	^self activation isSmalltalk and: [self activation method isBlockMethod]! !

"September 21, 2009 -> 21:7:55"!

! (Delta mirrorFor: #EditableActivationOutliner) methodsFor: 'private' !
isExternal ^ <Boolean>

	^self activation isSmalltalk not! !

"September 21, 2009 -> 21:8:5"!

! (Delta mirrorFor: #EditableActivationOutliner) methodsFor: 'private' !
isMethodActivation ^<Boolean>

	^self activation isSmalltalk and: [self activation method isBlockMethod not]! !

"September 21, 2009 -> 21:8:13"!

! (Delta mirrorFor: #EditableActivationOutliner) methodsFor: 'private' !
method

	^self mirror isNil
		ifTrue: [nil]
		ifFalse: [self mirror compiledMethodAt: self selector]! !

"September 21, 2009 -> 21:8:23"!

! (Delta mirrorFor: #EditableActivationOutliner) methodsFor: 'private' !
methodSource ^<Str>

	^(self hasSelector and: [self mirror notNil])
		ifTrue: [self mirror sourceForSelector: self selector]
		ifFalse: [self vmMethodSource]! !

"September 21, 2009 -> 21:8:32"!

! (Delta mirrorFor: #EditableActivationOutliner) methodsFor: 'private' !
mirror

	|mirror|
	mirror := Mirror on: self activation receiver class.
	[mirror isNil]
		whileFalse: [(mirror hasSelector: self selector) ifTrue: [^mirror].
							mirror := mirror superclass].
	^nil! !

"September 21, 2009 -> 21:8:41"!

! (Delta mirrorFor: #EditableActivationOutliner) methodsFor: 'private' !
selector ^<Symbol>

	^self activation method selector! !

"September 21, 2009 -> 21:8:51"!

! (Delta mirrorFor: #EditableActivationOutliner) methodsFor: 'private' !
sourceAsCharGlyphs ^<CharGlyphs>

	| vmSrc <Str> strm <CharacterReadStream> gls <OrdCltn[CharacterGlyph]> |

	"Construct vm source with highligthed bci"
	vmSrc := self methodSource.
	strm := vmSrc readStream.
	gls := OrderedCollection[CharacterGlyph] new: vmSrc size.
	(vmSrc occurrencesOf: self currentByteCodeSeparatorCharacter) = 2
		ifTrue: [	gls addAll: (self standardTextForString: (strm upTo: self currentByteCodeSeparatorCharacter) painter: self codePainter).
						gls addAll: (self standardTextForString: (strm upTo: self currentByteCodeSeparatorCharacter) painter: self codeBCIPainter) ].
	gls addAll: (self standardTextForString: strm contentsRemaining painter: self codePainter).
	^gls! !

"September 21, 2009 -> 21:9:1"!

! (Delta mirrorFor: #EditableActivationOutliner) methodsFor: 'private' !
vmMethodSource ^<Str>

	^self activation vmPrettyPrint! !

"September 21, 2009 -> 21:10:17"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"September 21, 2009 -> 21:10:17"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"September 21, 2009 -> 21:10:17"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"September 21, 2009 -> 21:10:17"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"September 21, 2009 -> 21:10:17"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"September 21, 2009 -> 21:10:17"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"September 21, 2009 -> 21:10:17"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"September 21, 2009 -> 21:10:17"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"September 21, 2009 -> 21:10:17"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"September 21, 2009 -> 21:10:17"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"September 21, 2009 -> 21:10:17"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"September 21, 2009 -> 21:10:17"!

(Delta mirrorFor: #ActivationOutliner)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"September 21, 2009 -> 21:10:17"!

! (Delta mirrorFor: #ActivationOutliner) classSide methodsFor: 'instance creation' !
on: a <Activation> ^ <Instance>

	^self new initActivation: a! !

"September 21, 2009 -> 21:10:17"!

! (Delta mirrorFor: #ActivationOutliner) classSide methodsFor: 'instance creation' !
on: a <Activation> debugger: debugger<StackTraceInspector> ^ <Instance>

	^self new initActivation: a debugger: debugger! !

"September 21, 2009 -> 21:10:17"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'accessing' !
activation ^ <Activation>

	^activation! !

"September 21, 2009 -> 21:10:17"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildActions ^ <Visual>

	| row <Row[Visual]> |

	row := Row[Button] new.
	row add: (Button
						labeled: 'Step into'
						action: [:b <Button> | debugger singleStep: self activation]).
	row add: (Button 
						labeled: 'Step over'
						action: [:b <Button> | debugger stepNext: self activation]).
	row add: (Button
						labeled: 'Step out'
						action: [:b <Button> | debugger stepReturn: self activation]).
	^row! !

"September 21, 2009 -> 21:10:17"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildBody ^<Visual>

	| col <Column[Visual]> |

	col := Column[Visual] new.
	col add: self buildActions;
		add: self buildCodeView.
	^col
! !

"September 21, 2009 -> 21:10:17"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildClosedHeader ^ <Visual>

	| selector <Symbol> args <Array[Object]> row <Row[Visual]> |
	
	"Check type of activation"
	self activation isSmalltalk
		ifFalse: [	^(StringGlyph for: 'External activation' painter: self codePainter) asVisual ].

	selector := self activation method enclosingMethod selector.
	args := self activation arguments.
	row := Row[Visual] new.
	
	self activation method isBlockMethod
		ifTrue: [		"Add block parens interspersed with arguments"
							row add: (StringGlyph for: '[' painter: self codePainter) asVisual.
							args do: [ :arg <Object> |
								row add: (StringGlyph for: ':' painter: self selectorPainter) asVisual.
								row add: (self
									buildLabel: (self safePrintString: arg)
									painter: self codePainter
									action: [ (Inspector on: arg) launch ]) ].
							row add: (StringGlyph for: '] in ' painter: self codePainter) asVisual.
							row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
		ifFalse: [	"Add receiver"
							| receiver <Object> |
							receiver := self activation receiver.
							row add: (self
								buildLabel: (self safePrintString: receiver)
								painter: self codePainter
								action: [ (Inspector on: receiver) launch ]).
							row add: (StringGlyph for: '>> ' painter: self codePainter) asVisual.
							"Add selector interspersed with arguments"
							args size = 0
								ifTrue: [		row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
								ifFalse: [	| strm <CharacterReadStream> |
													strm := selector readStream.
													args do: [ :arg <Object> |
														row add: (StringGlyph for: (strm upTo: $:), ':' painter: self selectorPainter) asVisual.
														row add: (self
															buildLabel: (self safePrintString: arg)
															painter: self codePainter
															action: [ (Inspector on: arg) launch ]) ]
												]
						].
	^row! !

"September 21, 2009 -> 21:10:17"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildCodeView ^<Visual>

	| cv <CodeView> vmSrc <Str> strm <CharacterReadStream> gls <OrdCltn[CharacterGlyph]> |

	"Construct vm source with highligthed bci"
	vmSrc := self activation vmPrettyPrint.
	strm := vmSrc readStream.
	gls := OrderedCollection[CharacterGlyph] new: vmSrc size.
	(vmSrc occurrencesOf: self currentByteCodeSeparatorCharacter) = 2
		ifTrue: [	gls addAll: (self standardTextForString: (strm upTo: self currentByteCodeSeparatorCharacter) painter: self codePainter).
						gls addAll: (self standardTextForString: (strm upTo: self currentByteCodeSeparatorCharacter) painter: self codeBCIPainter) ].
	gls addAll: (self standardTextForString: strm contentsRemaining painter: self codePainter).
	
	cv := CodeView forText.
	cv doneBlock: [ :b <Boolean> :onSuccess <[]> | b ifTrue: onSuccess ].	"Dummy for now, we are not showing the real source code"
	cv model: gls.
	^self editorBorderFor: cv
! !

"September 21, 2009 -> 21:10:17"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
currentByteCodeSeparatorCharacter ^ <Character>

	^Character value: 16r1B
! !

"September 21, 2009 -> 21:10:17"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
initialPacifiedState ^ <Boolean>

	^self activation isSmalltalk not! !

"September 21, 2009 -> 21:10:17"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
safePrintString: aValue

	^[aValue printString]
		on: Error
		do: [:ex|'??instance of ', aValue class name]! !

"September 21, 2009 -> 21:10:17"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private-initialization' !
initActivation: a <Activation>

	activation := a! !

"September 21, 2009 -> 21:10:17"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private-initialization' !
initActivation: a <Activation> debugger: d <StackTraceInspector>

	activation := a.
	debugger := d! !

"September 21, 2009 -> 21:11:14"!

"System saved" !
"September 22, 2009 -> 2:39:24"!

! (Delta mirrorFor: #EditableActivationOutliner) methodsFor: 'private' !
buildClosedBlockHeader

	|selector args row|
	selector := self activation method enclosingMethod selector.
	args := self activation arguments.
	row := Row[Visual] new.
	
	"Add block parens interspersed with arguments"
	row add: (StringGlyph for: '[' painter: self codePainter) asVisual.
	args do: [ :arg <Object> |
					row add: (StringGlyph for: ':' painter: self selectorPainter) asVisual.
					row add: (self
										buildLabel: (self safePrintString: arg)
										painter: self codePainter
										action: [ (Inspector on: arg) launch ]) ].
	row add: (StringGlyph for: '] in ' painter: self codePainter) asVisual.
	row add: (StringGlyph for: selector painter: self selectorPainter) asVisual.
		
	^row! !

"September 22, 2009 -> 2:39:24"!

! (Delta mirrorFor: #EditableActivationOutliner) methodsFor: 'private' !
buildClosedMethodHeader ^ <Visual>

	| selector <Symbol> args <Array[Object]> row <Row[Visual]> receiver <Object> |
	selector := self activation method enclosingMethod selector.
	args := self activation arguments.
	row := Row[Visual] new.
	
	"Add receiver"
	receiver := self activation receiver.
	row add: (self
						buildLabel: (self safePrintString: receiver)
						painter: self codePainter
						action: [ (Inspector on: receiver) launch ]).
	row add: (StringGlyph for: '>> ' painter: self codePainter) asVisual.
	"Add selector interspersed with arguments"
	args size = 0
		ifTrue: [		row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
		ifFalse: [	| strm <CharacterReadStream> |
					strm := selector readStream.
					args do: [ :arg <Object> |
									row add: (StringGlyph for: (strm upTo: $:), ':' painter: self selectorPainter) asVisual.
									row add: (self
														buildLabel: (self safePrintString: arg)
														painter: self codePainter
														action: [ (Inspector on: arg) launch ]) ]].
	^row! !

"September 22, 2009 -> 2:39:24"!

! (Delta mirrorFor: #EditableActivationOutliner) methodsFor: 'private' !
buildClosedHeader ^ <Visual>

	| selector <Symbol> args <Array[Object]> row <Row[Visual]> |
	
	"Check type of activation"
	^self isExternal
		ifTrue: [self buildExternalHeader]
		ifFalse: [self isBlockMethod
							ifTrue: [self buildClosedBlockHeader]
							ifFalse: [self buildClosedMethodHeader]]! !

"September 22, 2009 -> 2:39:24"!

! (Delta mirrorFor: #EditableActivationOutliner) methodsFor: 'private' !
buildClosedHeader ^ <Visual>
	
	^self isExternal
		ifTrue: [self buildExternalHeader]
		ifFalse: [self isBlockMethod
							ifTrue: [self buildClosedBlockHeader]
							ifFalse: [self buildClosedMethodHeader]]! !

"September 22, 2009 -> 2:39:24"!

(Delta mirrorFor: #EditableActivationOutliner) removeMethod: #buildClosedHeader2 ifAbsent: [] !


"September 22, 2009 -> 2:39:24"!

! (Delta mirrorFor: #EditableActivationOutliner) methodsFor: 'private' !
buildClosedBlockHeader

	|selector args row|
	selector := self activation method enclosingMethod selector.
	args := self activation arguments.
	row := Row[Visual] new.
	
	"Add block parens interspersed with arguments"
	row add: (StringGlyph for: '[' painter: self codePainter) asVisual.
	args do: [ :arg <Object> |
					row add: (StringGlyph for: ':' painter: self selectorPainter) asVisual.
					row add: (self
										buildLabel: (self safePrintString: arg)
										painter: self codePainter
										action: [ (Inspector on: arg) launch ]) ].
	row add: (StringGlyph for: '] in ' painter: self codePainter) asVisual.
	row add: (StringGlyph for: selector painter: self selectorPainter) asVisual.
		
	^row! !

"September 22, 2009 -> 2:39:24"!

! (Delta mirrorFor: #EditableActivationOutliner) methodsFor: 'private' !
buildClosedMethodHeader ^ <Visual>

	| selector <Symbol> args <Array[Object]> row <Row[Visual]> receiver <Object> |
	selector := self activation method enclosingMethod selector.
	args := self activation arguments.
	row := Row[Visual] new.
	
	"Add receiver"
	receiver := self activation receiver.
	row add: (self
						buildLabel: (self safePrintString: receiver)
						painter: self codePainter
						action: [ (Inspector on: receiver) launch ]).
	row add: (StringGlyph for: '>> ' painter: self codePainter) asVisual.
	"Add selector interspersed with arguments"
	args size = 0
		ifTrue: [		row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
		ifFalse: [	| strm <CharacterReadStream> |
					strm := selector readStream.
					args do: [ :arg <Object> |
									row add: (StringGlyph for: (strm upTo: $:), ':' painter: self selectorPainter) asVisual.
									row add: (self
														buildLabel: (self safePrintString: arg)
														painter: self codePainter
														action: [ (Inspector on: arg) launch ]) ]].
	^row! !

"September 22, 2009 -> 2:39:24"!

! (Delta mirrorFor: #EditableActivationOutliner) methodsFor: 'private' !
buildClosedHeader ^ <Visual>

	| selector <Symbol> args <Array[Object]> row <Row[Visual]> |
	
	"Check type of activation"
	^self isExternal
		ifTrue: [self buildExternalHeader]
		ifFalse: [self isBlockMethod
							ifTrue: [self buildClosedBlockHeader]
							ifFalse: [self buildClosedMethodHeader]]! !

"September 22, 2009 -> 2:39:24"!

! (Delta mirrorFor: #EditableActivationOutliner) methodsFor: 'private' !
buildClosedHeader ^ <Visual>
	
	^self isExternal
		ifTrue: [self buildExternalHeader]
		ifFalse: [self isBlockMethod
							ifTrue: [self buildClosedBlockHeader]
							ifFalse: [self buildClosedMethodHeader]]! !

"September 22, 2009 -> 2:39:24"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner' instanceVariables: '')) !


"September 22, 2009 -> 2:39:24"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner' instanceVariables: '')) !


"September 22, 2009 -> 2:39:24"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner' instanceVariables: '')) !


"September 22, 2009 -> 2:39:24"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner' instanceVariables: '')) !


"September 22, 2009 -> 2:39:24"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner' instanceVariables: '')) !


"September 22, 2009 -> 2:39:24"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner' instanceVariables: '')) !


"September 22, 2009 -> 2:39:24"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner' instanceVariables: '')) !


"September 22, 2009 -> 2:39:24"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner' instanceVariables: 'selector')) !


"September 22, 2009 -> 2:39:24"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner' instanceVariables: 'selector')) !


"September 22, 2009 -> 2:39:24"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner' instanceVariables: 'selector')) !


"September 22, 2009 -> 2:39:24"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner' instanceVariables: 'selector')) !


"September 22, 2009 -> 2:39:24"!

! (Delta mirrorFor: #EditableActivationOutliner) methodsFor: 'private' !
initActivation: a <Activation> debugger: d <StackTraceInspector>

	super initActivation: a
		debugger: d.
	self isMethodActivation
		ifTrue: [selector := self activation method selector]! !

"September 22, 2009 -> 2:39:24"!

(Delta mirrorFor: #EditableActivationOutliner) removeMethod: #initActivation:debugger: ifAbsent: [] !


"September 22, 2009 -> 2:39:24"!

! (Delta mirrorFor: #EditableActivationOutliner) methodsFor: 'private' !
methodMirror

	|mirror|
	mirror := Mirror on: self activation receiver class.
	[mirror isNil]
		whileFalse: [(mirror hasSelector: self selector) ifTrue: [^mirror].
							mirror := mirror superclass].
	^nil! !

"September 22, 2009 -> 2:39:24"!

! (Delta mirrorFor: #EditableActivationOutliner) methodsFor: 'private' !
blockMirror

	|homeMethod selector|
	homeMethod := self activation method enclosingMethod.
	[homeMethod enclosingMethod isNil] whileFalse: [homeMethod := homeMethod enclosingMethod].
	
	selector := homeMethod selector.
	Smalltalk classesReflectiveDo: [:mirror| ((mirror hasSelector: selector) 
																		and: [(mirror compiledMethodAt: selector ifFail: [:a :b|]) ==homeMethod])
																		ifTrue: [^mirror]].
	^nil! !

"September 22, 2009 -> 2:39:25"!

! (Delta mirrorFor: #EditableActivationOutliner) methodsFor: 'private' !
mirror

	^self isBlockActivation
		ifTrue: [self blockMirror]
		ifFalse: [self methodMirror]! !

"September 22, 2009 -> 2:39:25"!

! (Delta mirrorFor: #EditableActivationOutliner) methodsFor: 'private' !
methodSource ^<Str>

	^self mirror isNil
		ifTrue: [self vmMethodSource]
		ifFalse: [self mirror sourceForSelector: self selector]! !

"September 22, 2009 -> 2:40:42"!

Delta define: #EditableActivationOutliner as: (
(Class subclassOf: 'ActivationOutliner' instanceVariables: 'selector mirror')) !


"September 22, 2009 -> 2:41:53"!

! (Delta mirrorFor: #EditableActivationOutliner) methodsFor: 'private' !
findMirror

	^self isBlockActivation
		ifTrue: [self blockMirror]
		ifFalse: [self methodMirror]! !

"September 22, 2009 -> 2:43:15"!

! (Delta mirrorFor: #EditableActivationOutliner) methodsFor: 'private' !
mirror

	mirror isNil
		ifTrue: [mirror := self findMirror.
					mirror isNil ifTrue: [mirror := self]].
	^mirror == self
		ifTrue: [nil]
		ifFalse: [mirror]! !

"September 22, 2009 -> 2:44:5"!

! (Delta mirrorFor: #EditableActivationOutliner) methodsFor: 'private' !
findHomeMethod

	|homeMethod selector|
	homeMethod := self activation method enclosingMethod.
	[homeMethod enclosingMethod isNil] whileFalse: [homeMethod := homeMethod enclosingMethod].
	
	^homeMethod! !

"September 22, 2009 -> 2:46:45"!

! (Delta mirrorFor: #EditableActivationOutliner) methodsFor: 'private' !
findHomeMethod

	|homeMethod selector|
	homeMethod := self activation method enclosingMethod.
	[homeMethod isBlockMethod] whileTrue: [homeMethod := homeMethod enclosingMethod].
	
	^homeMethod! !

"September 22, 2009 -> 2:47:12"!

! (Delta mirrorFor: #EditableActivationOutliner) methodsFor: 'private' !
findHomeMethod

	|homeMethod selector|
	homeMethod := self activation method enclosingMethod.
	[homeMethod isBlockMethod]
		whileTrue: [homeMethod := homeMethod enclosingMethod].
	
	^homeMethod! !

"September 22, 2009 -> 2:48:12"!

! (Delta mirrorFor: #EditableActivationOutliner) methodsFor: 'private' !
findHomeMethod

	|method|
	method := self activation method.
	[method isBlockMethod]
		whileTrue: [method := method enclosingMethod].
	
	^method! !

"September 22, 2009 -> 2:48:56"!

! (Delta mirrorFor: #EditableActivationOutliner) methodsFor: 'private' !
selector ^<Symbol>

	selector isNil
		ifTrue: [selector := self isBlockActivation
											ifTrue: [self findHomeMethod selector]
											ifFalse: [self activation method selector]].
	^selector! !

"September 22, 2009 -> 2:50:27"!

! (Delta mirrorFor: #EditableActivationOutliner) methodsFor: 'private' !
blockMirror

	|homeMethod selector|
	homeMethod := self findHomeMethod.
	selector := homeMethod selector.
	Smalltalk classesReflectiveDo: [:mirror| ((mirror hasSelector: selector) 
																		and: [(mirror compiledMethodAt: selector ifFail: [:a :b|]) ==homeMethod])
																		ifTrue: [^mirror]].
	^nil! !

"September 22, 2009 -> 2:51:36"!

"System saved" !
"September 22, 2009 -> 2:52:38"!

! (Delta mirrorFor: #EditableActivationOutliner) methodsFor: 'private' !
buildClosedHeader ^ <Visual>
	
	^self isExternal
		ifTrue: [self buildExternalHeader]
		ifFalse: [self isBlockActivation
							ifTrue: [self buildClosedBlockHeader]
							ifFalse: [self buildClosedMethodHeader]]! !

"September 23, 2009 -> 10:31:1"!

"System saved" !
"September 27, 2009 -> 11:54:29"!

Delta define: #NewspeakObject as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"September 27, 2009 -> 11:54:43"!

Delta define: #NewspeakObject as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"September 27, 2009 -> 11:55:8"!

Delta define: #NewspeakObject as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"September 27, 2009 -> 11:58:46"!

! (Delta mirrorFor: #NewspeakObject) classSide methodsFor: 'accessing' !
enclosingObject

	^enclosingObject! !

"September 27, 2009 -> 11:59:4"!

! (Delta mirrorFor: #NewspeakObject) classSide methodsFor: 'accessing' !
enclosingObject: value

	enclosingObject := value! !

"September 27, 2009 -> 12:23:23"!

"System saved" !
"September 27, 2009 -> 12:26:36"!

Delta define: #NS1 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: '')) !


"September 27, 2009 -> 12:33:0"!

! (Delta mirrorFor: #NS1) classSide methodsFor: 'test' !
name: symbol

	name := symbol! !

"September 27, 2009 -> 12:33:35"!

(Delta mirrorFor: #NS1) classSide removeMethod: #name: ifAbsent: [] !


"September 27, 2009 -> 12:36:38"!

! (Delta mirrorFor: #NS1) classSide methodsFor: 'test' !
name: symbol

	name := symbol! !

"September 27, 2009 -> 12:36:55"!

"System saved" !
"September 27, 2009 -> 12:37:32"!

(Delta mirrorFor: #NS1) classSide removeMethod: #name: ifAbsent: [] !


"September 27, 2009 -> 12:37:45"!

"System saved" !
"September 29, 2009 -> 0:16:10"!

Delta define: #ClassDefinitionOutliner as: (
(Class subclassOf: 'ClassOrMixinDefinitionOutliner[AbstractClassMirror]' instanceVariables: 'superclassOutliner <SuperclassOutliner>
classInstanceVariableOutliner <InstanceVariableOutliner>')) !


"September 29, 2009 -> 0:17:4"!

Delta define: #ClassDefinitionOutliner as: (
(Class subclassOf: 'ClassOrMixinDefinitionOutliner[AbstractClassMirror]' instanceVariables: 'superclassOutliner <SuperclassOutliner>
classInstanceVariableOutliner <InstanceVariableOutliner>
addingClassInstanceVariables <Boolean>')) !


"September 29, 2009 -> 0:17:37"!

! (Delta mirrorFor: #ClassDefinitionOutliner) methodsFor: 'private' !
addingClassInstanceVariables ^ <Boolean>

	^addingClassInstanceVariables! !

"September 29, 2009 -> 0:19:53"!

! (Delta mirrorFor: #ClassDefinitionOutliner) methodsFor: 'private' !
addingClassInstanceVariables: value <Boolean>

	addingClassInstanceVariables := value! !

"September 29, 2009 -> 0:20:1"!

! (Delta mirrorFor: #ClassDefinitionOutliner) methodsFor: 'private-initialization' !
initialize

	super initialize.
	self addingClassInstanceVariables: false! !

"September 29, 2009 -> 0:22:41"!

! (Delta mirrorFor: #ClassDefinitionOutliner) methodsFor: 'private' !
classInstanceVariableOutliner ^ <InstanceVariableOutliner>

	^classInstanceVariableOutliner! !

"September 29, 2009 -> 0:22:57"!

! (Delta mirrorFor: #ClassDefinitionOutliner) methodsFor: 'private' !
classInstanceVariableOutliner: outliner <InstanceVariableOutliner>

	classInstanceVariableOutliner := outliner! !

"September 29, 2009 -> 0:23:29"!

! (Delta mirrorFor: #ClassDefinitionOutliner) methodsFor: 'private' !
insertRemainingDefinition: col <Column[Visual]>

	super insertRemainingDefinition: col.
 	(self mirror classSide instanceVariableString isEmpty not or: [ self addingInstVars ])
		ifTrue: [		self classInstVarOutliner: (InstanceVariableOutliner for: self mirror classSide).
							col add: (self addChild: self classInstVarOutliner) imbeddedVisual ]
		ifFalse: [	self classInstVarOutliner: nil ].
! !

"September 29, 2009 -> 0:24:48"!

! (Delta mirrorFor: #ClassDefinitionOutliner) methodsFor: 'private' !
insertRemainingDefinition: col <Column[Visual]>

	super insertRemainingDefinition: col.
 	(self mirror classSide instanceVariableString isEmpty not or: [ self addingInstVars ])
		ifTrue: [		self classInstanceVariableOutliner: (InstanceVariableOutliner for: self mirror classSide).
							col add: (self addChild: self classInstanceVariableOutliner) imbeddedVisual ]
		ifFalse: [	self classInstanceVariableOutliner: nil ].
! !

"September 29, 2009 -> 0:26:43"!

! (Delta mirrorFor: #ClassDefinitionOutliner) methodsFor: 'control' !
addClassInstanceVariables

	self open: true.
	self addingClassInstanceVariables: true.
	[ self updateBody ] ensure: [ self addingClassInstanceVariables: false ].
	self classInstanceVariableOutliner notNil
		ifTrue: [ self inSessionProcessDo: [ 
							self classInstanceVariableOutliner becomeFocusIfFail: [] ] ]! !

"September 29, 2009 -> 0:27:38"!

! (Delta mirrorFor: #ClassDefinitionOutliner) methodsFor: 'private' !
insertRemainingDefinition: col <Column[Visual]>

	super insertRemainingDefinition: col.
 	(self mirror classSide instanceVariableString isEmpty not or: [ self addingClassInstanceVariables ])
		ifTrue: [		self classInstanceVariableOutliner: (InstanceVariableOutliner for: self mirror classSide).
							col add: (self addChild: self classInstanceVariableOutliner) imbeddedVisual ]
		ifFalse: [	self classInstanceVariableOutliner: nil ].
! !

"September 29, 2009 -> 0:29:32"!

Delta define: #NewspeakObject as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"September 29, 2009 -> 0:30:28"!

Delta define: #ClassInstanceVariableOutliner as: (
(Class subclassOf: 'InstanceVariableOutliner' instanceVariables: '')) !


"September 29, 2009 -> 0:30:50"!

! (Delta mirrorFor: #ClassInstanceVariableOutliner) methodsFor: 'private' !
header

	^'Class instance variables'! !

"September 29, 2009 -> 0:31:17"!

! (Delta mirrorFor: #ClassDefinitionOutliner) methodsFor: 'private' !
insertRemainingDefinition: col <Column[Visual]>

	super insertRemainingDefinition: col.
 	(self mirror classSide instanceVariableString isEmpty not or: [ self addingClassInstanceVariables ])
		ifTrue: [		self classInstanceVariableOutliner: (ClassInstanceVariableOutliner for: self mirror classSide).
							col add: (self addChild: self classInstanceVariableOutliner) imbeddedVisual ]
		ifFalse: [	self classInstanceVariableOutliner: nil ].
! !

"September 29, 2009 -> 0:31:33"!

Delta define: #NewspeakObject as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"September 29, 2009 -> 0:33:49"!

"System saved" !
"September 30, 2009 -> 1:13:11"!

! (Delta mirrorFor: #Class) classSide methodsFor: 'constructors' !
subclassOf: superRef  <Str> 
instanceVariables: instVarsString <Str>
classInstanceVariables: classInstVarsString <Str> ^ <ClassMirror> 
    "Creation of a Delta class constructor"
| c <ClassMirror> |

c := ClassMirror  subclassOf: superRef instanceVariables: instVarsString.
c mixin classSide instanceVariables: classInstVarsString.
AbstractClassMirror flushSubclassHierarchyCache.
^c! !

"September 30, 2009 -> 1:13:26"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
basicDefinitionString   ^ <Str>
| classVarStr protocolStr classProtocolStr stream first |

classVarStr := self mixin classVariableString.
protocolStr := self mixin supportedProtocolString.
classProtocolStr := self mixin classSide supportedProtocolString.

stream := (String new: 20) writeStream.
self superclass isNil
	ifTrue: [
		stream nextPutAll: '(Class delta)'.
		self mixin instanceVariableString isEmpty ifFalse: [
			stream nextPutAll: ' instanceVariables: '.
			stream nextPutAll: self mixin instanceVariableString asString printString]]
	ifFalse: [
		stream nextPutAll: '(Class subclassOf: '.
		stream nextPutAll: self mixin superclassTypeString asString printString.
		stream nextPutAll: ' instanceVariables: '.
		stream nextPutAll: self mixin instanceVariableString asString printString.
		stream nextPutAll: ' classInstanceVariables: '.
		stream nextPutAll: self mixin classSide instanceVariableString asString printString, ')'].

first := true.
classVarStr isEmpty ifFalse: [
	first ifTrue: [ first := false ] ifFalse: [ stream nextPut: $; ].
	stream nextPutAll: ' classVariables: ', classVarStr asString printString].
protocolStr isEmpty ifFalse: [
	first ifTrue: [ first := false ] ifFalse: [ stream nextPut: $; ].
	stream nextPutAll: ' protocols: ', protocolStr asString printString].
classProtocolStr isEmpty ifFalse: [
	first ifTrue: [ first := false ] ifFalse: [ stream nextPut: $; ].
	stream nextPutAll: ' classProtocols: ', classProtocolStr asString printString].
self isAbstract ifTrue:[
	first ifTrue: [ first := false ] ifFalse: [ stream nextPut: $; ].
	stream nextPutAll: ' abstract'].
self extensionsAreSubtypes ifFalse:[
	first ifTrue: [ first := false ] ifFalse: [ stream nextPut: $; ].
	stream nextPutAll: ' extensionsAreNotSubtypes'].
self isSubtype ifFalse:[
	first ifTrue: [ first := false ] ifFalse: [ stream nextPut: $; ].
	stream nextPutAll: ' notSubtype'].
self isBranded ifFalse:[
	first ifTrue: [ first := false ] ifFalse: [ stream nextPut: $; ].
	stream nextPutAll: ' unbranded'].

^stream contents
! !

"September 30, 2009 -> 1:14:24"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 1:15:42"!

"System saved" !
"September 30, 2009 -> 1:18:56"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
basicDefinitionString   ^ <Str>
| classVarStr protocolStr classProtocolStr stream first |

classVarStr := self mixin classVariableString.
protocolStr := self mixin supportedProtocolString.
classProtocolStr := self mixin classSide supportedProtocolString.

stream := (String new: 20) writeStream.
self superclass isNil
	ifTrue: [
		stream nextPutAll: '(Class delta)'.
		self mixin instanceVariableString isEmpty ifFalse: [
			stream nextPutAll: ' instanceVariables: '.
			stream nextPutAll: self mixin instanceVariableString asString printString]]
	ifFalse: [|classInstVars|
		stream nextPutAll: '(Class subclassOf: '.
		stream nextPutAll: self mixin superclassTypeString asString printString.
		stream nextPutAll: ' instanceVariables: '.
		stream nextPutAll: self mixin instanceVariableString asString printString.
		classInstVars := self mixin classSide instanceVariableString.
		classInstVars isEmpty
			ifFalse: [stream nextPutAll: ' classInstanceVariables: '.
						stream nextPutAll: self mixin classSide instanceVariableString asString printString].
		stream nextPutAll: ')'].

first := true.
classVarStr isEmpty ifFalse: [
	first ifTrue: [ first := false ] ifFalse: [ stream nextPut: $; ].
	stream nextPutAll: ' classVariables: ', classVarStr asString printString].
protocolStr isEmpty ifFalse: [
	first ifTrue: [ first := false ] ifFalse: [ stream nextPut: $; ].
	stream nextPutAll: ' protocols: ', protocolStr asString printString].
classProtocolStr isEmpty ifFalse: [
	first ifTrue: [ first := false ] ifFalse: [ stream nextPut: $; ].
	stream nextPutAll: ' classProtocols: ', classProtocolStr asString printString].
self isAbstract ifTrue:[
	first ifTrue: [ first := false ] ifFalse: [ stream nextPut: $; ].
	stream nextPutAll: ' abstract'].
self extensionsAreSubtypes ifFalse:[
	first ifTrue: [ first := false ] ifFalse: [ stream nextPut: $; ].
	stream nextPutAll: ' extensionsAreNotSubtypes'].
self isSubtype ifFalse:[
	first ifTrue: [ first := false ] ifFalse: [ stream nextPut: $; ].
	stream nextPutAll: ' notSubtype'].
self isBranded ifFalse:[
	first ifTrue: [ first := false ] ifFalse: [ stream nextPut: $; ].
	stream nextPutAll: ' unbranded'].

^stream contents
! !

"September 30, 2009 -> 1:19:21"!

"System saved" !
"September 30, 2009 -> 22:46:45"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 22:46:47"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 22:46:47"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 22:46:47"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 22:46:47"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 22:46:47"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 22:46:47"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 22:46:47"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 22:46:47"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 22:46:47"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 22:46:47"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 22:53:31"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 22:53:36"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 22:53:36"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 22:53:36"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 22:53:36"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 22:53:36"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 22:53:36"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 22:53:36"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 22:53:36"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 22:53:36"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 22:56:56"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 22:59:48"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
body ^ <ClassMirror>

| newBody <ClassMirror> |

self superclassTypeString isEmpty "This is Object"
   ifTrue:[newBody := Class delta]
   ifFalse:[newBody :=  (Class subclassOf: self superclassTypeString
                                                         instanceVariables: self instanceVariableString).
                  ].
newBody := newBody
                                    classVariables: self classVariableString;
                                    protocols: self supportedProtocolString;
                                    classProtocols: self classSide supportedProtocolString.
newBody mixin classSide instanceVariables: self classSide instanceVariableString.

self isAbstract ifTrue:[newBody abstract].
self extensionsAreSubtypes ifFalse:[newBody extensionsAreNotSubtypes].
self isSubtype ifFalse:[newBody notSubtype].
self isBranded ifFalse:[newBody unbranded].
^newBody

         ! !

"September 30, 2009 -> 23:0:3"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:0:5"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:0:5"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:0:5"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:0:5"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:0:5"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:0:5"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:0:5"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:0:5"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:0:5"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:0:5"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:0:35"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: '' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:1:1"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: '')) !


"September 30, 2009 -> 23:1:9"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: '')) !


"September 30, 2009 -> 23:1:11"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: '')) !


"September 30, 2009 -> 23:1:11"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: '')) !


"September 30, 2009 -> 23:1:11"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: '')) !


"September 30, 2009 -> 23:1:11"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: '')) !


"September 30, 2009 -> 23:1:11"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: '')) !


"September 30, 2009 -> 23:1:11"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: '')) !


"September 30, 2009 -> 23:1:11"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:1:11"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:1:11"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:1:11"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:2:37"!

! (Delta mirrorFor: #Class) classSide methodsFor: 'constructors' !
subclassOf: superRef  <Str>  instanceVariables: instVarsString <Str> ^ <ClassMirror> 
    "Creation of a Delta class constructor"

	^self subclassOf: superRef
			instanceVariables: instVarsString
			classInstanceVariables: ''! !

"September 30, 2009 -> 23:3:13"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:3:13"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:3:13"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:3:13"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:3:13"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:3:13"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:3:13"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:3:13"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:3:13"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:3:13"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:3:13"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:3:29"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:3:29"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:3:29"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:3:29"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:3:29"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:3:29"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:3:29"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:3:29"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:3:29"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:3:29"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:3:29"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:4:6"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:4:6"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:4:6"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:4:6"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:4:6"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:4:6"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:4:6"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:4:6"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:4:6"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:4:6"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:4:6"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:4:19"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:4:19"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:4:19"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:4:19"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:4:19"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:4:19"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:4:19"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:4:19"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:4:19"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:4:19"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:4:19"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:8:16"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
classInstanceVariables: iv  <Str>

self mixin classSide instanceVariables: iv! !

"September 30, 2009 -> 23:8:21"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
initializeSubclassOf: s  <Str> instanceVariables: instVars  <Str> classInstanceVariables: classInstVars <Str>

    self initialize.
    self superclass: s.
    self instanceVariables: instVars.
    self classInstanceVariables: classInstVars! !

"September 30, 2009 -> 23:8:28"!

! (Delta mirrorFor: #ClassMirror) classSide methodsFor: 'Unclassified' !
subclassOf: s <Str> instanceVariables: instVars <Str> classInstanceVariables: classInstVars <Str> ^ <Instance>
    ^self new
    	initializeSubclassOf: s
    	instanceVariables: instVars
    	classInstanceVariables: classInstVars! !

"September 30, 2009 -> 23:8:39"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:8:39"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:8:39"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:8:39"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:8:39"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:8:39"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:8:39"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:8:39"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:8:39"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:8:39"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:8:39"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:8:43"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:8:43"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:8:43"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:8:43"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:8:43"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:8:43"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:8:43"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:8:43"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:8:43"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:8:43"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:8:43"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:9:20"!

! (Delta mirrorFor: #Class) classSide methodsFor: 'constructors' !
subclassOf: superRef  <Str> 
instanceVariables: instVarsString <Str>
classInstanceVariables: classInstVarsString <Str> ^ <ClassMirror> 
    "Creation of a Delta class constructor"
| c <ClassMirror> |

c := ClassMirror
			subclassOf: superRef
			instanceVariables: instVarsString
			classInstanceVariables: classInstVarsString.
AbstractClassMirror flushSubclassHierarchyCache.
^c! !

"September 30, 2009 -> 23:9:25"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:9:25"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:9:25"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:9:25"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:9:25"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:9:25"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:9:25"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:9:25"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:9:25"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:9:25"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:9:25"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:9:29"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:9:29"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:9:29"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:9:29"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:9:29"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:9:29"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:9:29"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:9:29"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:9:29"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:9:29"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:9:29"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:10:27"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
body ^ <ClassMirror>

| newBody <ClassMirror> |

self superclassTypeString isEmpty "This is Object"
   ifTrue:[newBody := Class delta]
   ifFalse:[newBody :=  (Class subclassOf: self superclassTypeString
                                                         instanceVariables: self instanceVariableString).
                  ].
newBody := newBody
                                    classVariables: self classVariableString;
                                    protocols: self supportedProtocolString;
                                    classProtocols: self classSide supportedProtocolString.
newBody classInstanceVariables: self classSide instanceVariableString.

self isAbstract ifTrue:[newBody abstract].
self extensionsAreSubtypes ifFalse:[newBody extensionsAreNotSubtypes].
self isSubtype ifFalse:[newBody notSubtype].
self isBranded ifFalse:[newBody unbranded].
^newBody

         ! !

"September 30, 2009 -> 23:10:32"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:10:32"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:10:32"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:10:32"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:10:32"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:10:32"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:10:32"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:10:32"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:10:32"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:10:32"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:10:32"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:10:36"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:10:36"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:10:36"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:10:36"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:10:36"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:10:36"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:10:36"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:10:36"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:10:36"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one')) !


"September 30, 2009 -> 23:10:36"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:10:36"!

Delta define: #NS2 as: (
(Class subclassOf: 'NewspeakObject' instanceVariables: 'one' classInstanceVariables: 'two')) !


"September 30, 2009 -> 23:12:51"!

"System saved" !
"September 30, 2009 -> 23:14:59"!

(Delta mirrorFor: #Top2) removeDefinitionIfFail: [] !


"September 30, 2009 -> 23:15:21"!

"System saved" !
"September 30, 2009 -> 23:17:11"!

Delta define: #ClassTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"September 30, 2009 -> 23:18:59"!

! (Delta mirrorFor: #ClassTest) methodsFor: 'testing' !
testClassInstanceVariableCreation

	self assert: (Smalltalk at: #ClassTestIvars123 ifAbsent: []) isNil! !

"September 30, 2009 -> 23:19:56"!

! (Delta mirrorFor: #ClassTest) methodsFor: 'testing' !
classFixture

	^Smalltalk at: #ClassTestIvars123 ifAbsent: []! !

"September 30, 2009 -> 23:20:11"!

! (Delta mirrorFor: #ClassTest) methodsFor: 'testing' !
testClassInstanceVariableCreation

	self assert: self classFixture isNil! !

"September 30, 2009 -> 23:25:42"!

! (Delta mirrorFor: #ClassTest) methodsFor: 'fixture' !
tearDown

	self classFixture isNil
		ifFalse: [(Mirror on: self classFixture) removeDefinitionIfFail: [:err| self signalFailure: err]]! !

"September 30, 2009 -> 23:28:10"!

! (Delta mirrorFor: #ClassTest) methodsFor: 'testing' !
testClassInstanceVariableCreation

	self assert: self classFixture isNil.
	Delta define: #ClassTestIvars123 as: (
		Class subclassOf: 'Object'
			instanceVariables: 'one'
			classInstanceVariables: 'two three').
	self deny: self classFixture isNil! !

"September 30, 2009 -> 23:28:11"!

Delta define: #ClassTestIvars123 as: (
(Class subclassOf: 'Object' instanceVariables: 'one' classInstanceVariables: 'two three')) !


"September 30, 2009 -> 23:28:12"!

(Delta mirrorFor: #ClassTestIvars123) removeDefinitionIfFail: [] !


"September 30, 2009 -> 23:28:17"!

Delta define: #ClassTestIvars123 as: (
(Class subclassOf: 'Object' instanceVariables: 'one' classInstanceVariables: 'two three')) !


"September 30, 2009 -> 23:28:17"!

(Delta mirrorFor: #ClassTestIvars123) removeDefinitionIfFail: [] !


"September 30, 2009 -> 23:29:25"!

! (Delta mirrorFor: #ClassTest) methodsFor: 'testing' !
fixtureClassName

	^#ClassTestIvars123! !

"September 30, 2009 -> 23:29:37"!

! (Delta mirrorFor: #ClassTest) methodsFor: 'testing' !
classFixture

	^Smalltalk at: self fixtureClassName ifAbsent: []! !

"September 30, 2009 -> 23:33:1"!

! (Delta mirrorFor: #ClassTest) methodsFor: 'testing' !
testClassInstanceVariableCreation

	self assert: self classFixture isNil.
	Delta define: self fixtureClassName as: (
		Class subclassOf: 'Object'
			instanceVariables: 'one'
			classInstanceVariables: 'two three').
	self deny: self classFixture isNil.
	self assert: (Mirror on: self classFixture) mixin classSide instanceVariableString = 'two three'! !

"September 30, 2009 -> 23:33:2"!

Delta define: #ClassTestIvars123 as: (
(Class subclassOf: 'Object' instanceVariables: 'one' classInstanceVariables: 'two three')) !


"September 30, 2009 -> 23:33:2"!

(Delta mirrorFor: #ClassTestIvars123) removeDefinitionIfFail: [] !


"September 30, 2009 -> 23:33:19"!

Delta define: #ClassTestIvars123 as: (
(Class subclassOf: 'Object' instanceVariables: 'one' classInstanceVariables: 'two three')) !


"September 30, 2009 -> 23:33:19"!

(Delta mirrorFor: #ClassTestIvars123) removeDefinitionIfFail: [] !


"September 30, 2009 -> 23:34:17"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
classInstanceVariableString

	^self mixin classSide instanceVariableString! !

"September 30, 2009 -> 23:34:30"!

! (Delta mirrorFor: #ClassTest) methodsFor: 'testing' !
testClassInstanceVariableCreation

	self assert: self classFixture isNil.
	Delta define: self fixtureClassName as: (
		Class subclassOf: 'Object'
			instanceVariables: 'one'
			classInstanceVariables: 'two three').
	self deny: self classFixture isNil.
	self assert: (Mirror on: self classFixture) classInstanceVariableString = 'two three'! !

"September 30, 2009 -> 23:34:32"!

Delta define: #ClassTestIvars123 as: (
(Class subclassOf: 'Object' instanceVariables: 'one' classInstanceVariables: 'two three')) !


"September 30, 2009 -> 23:34:32"!

(Delta mirrorFor: #ClassTestIvars123) removeDefinitionIfFail: [] !


"September 30, 2009 -> 23:36:2"!

! (Delta mirrorFor: #ClassTest) methodsFor: 'testing' !
testClassInstanceVariableCreation

	self assert: self classFixture isNil.
	
	Delta define: self fixtureClassName as: (
		Class subclassOf: 'Object'
			instanceVariables: 'one'
			classInstanceVariables: 'two three').
	
	self deny: self classFixture isNil.
	self assert: (Mirror on: self classFixture) classInstanceVariableString = 'two three'! !

"September 30, 2009 -> 23:36:36"!

! (Delta mirrorFor: #ClassTest) methodsFor: 'testing' !
testClassInstanceVariableCreation

	self assert: self classFixture isNil.
	
	Delta define: self fixtureClassName as: (
		Class subclassOf: 'Object'
			instanceVariables: 'one'
			classInstanceVariables: 'two three').
	
	self deny: self classFixture isNil.
	self assert: (Mirror on: self classFixture) classInstanceVariableString = 'two three'.
	self assert: (Mirror on: self classFixture) instanceVariableString = 'one'! !

"September 30, 2009 -> 23:36:39"!

Delta define: #ClassTestIvars123 as: (
(Class subclassOf: 'Object' instanceVariables: 'one' classInstanceVariables: 'two three')) !


"September 30, 2009 -> 23:36:39"!

(Delta mirrorFor: #ClassTestIvars123) removeDefinitionIfFail: [] !


"September 30, 2009 -> 23:37:43"!

! (Delta mirrorFor: #ClassTest) methodsFor: 'testing' !
testClassInstanceVariableCreation

	|mirror|
	self assert: self classFixture isNil.
	
	Delta define: self fixtureClassName as: (
		Class subclassOf: 'Object'
			instanceVariables: 'one'
			classInstanceVariables: 'two three').
	
	self deny: self classFixture isNil.
	
	mirror := Mirror on: self classFixture.
	self assert: mirror classInstanceVariableString = 'two three'.
	self assert: mirror instanceVariableString = 'one'! !

"September 30, 2009 -> 23:37:45"!

Delta define: #ClassTestIvars123 as: (
(Class subclassOf: 'Object' instanceVariables: 'one' classInstanceVariables: 'two three')) !


"September 30, 2009 -> 23:37:45"!

(Delta mirrorFor: #ClassTestIvars123) removeDefinitionIfFail: [] !


"September 30, 2009 -> 23:38:28"!

! (Delta mirrorFor: #ClassTest) methodsFor: 'testing' !
testCreateClassWithInstanceAndClassInstanceVariables

	|mirror|
	self assert: self classFixture isNil.
	
	Delta define: self fixtureClassName as: (
		Class subclassOf: 'Object'
			instanceVariables: 'one'
			classInstanceVariables: 'two three').
	
	self deny: self classFixture isNil.
	
	mirror := Mirror on: self classFixture.
	self assert: mirror classInstanceVariableString = 'two three'.
	self assert: mirror instanceVariableString = 'one'! !

"September 30, 2009 -> 23:38:31"!

(Delta mirrorFor: #ClassTest) removeMethod: #testClassInstanceVariableCreation ifAbsent: [] !


"September 30, 2009 -> 23:38:33"!

Delta define: #ClassTestIvars123 as: (
(Class subclassOf: 'Object' instanceVariables: 'one' classInstanceVariables: 'two three')) !


"September 30, 2009 -> 23:38:33"!

(Delta mirrorFor: #ClassTestIvars123) removeDefinitionIfFail: [] !


"September 30, 2009 -> 23:39:47"!

"System saved" !
"October 1, 2009 -> 22:19:19"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
initIndexDict ^ <Dictionary[Symbol,Cltn[Str]]>

	indexDict isNil ifTrue: [ 
		self indexDict: Dictionary[Symbol,Cltn[String]] new.
		self isPersistent ifTrue: [
			self parseIndexFile ] ]! !

"October 1, 2009 -> 22:19:19"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
indexDict ^ <Dictionary[Symbol,Cltn[Str]]>

	self initIndexDict.
	^indexDict! !

"October 1, 2009 -> 22:19:20"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
storeIndexFile

	| ws <CharOutputStream> |
	self initIndexDict.
	self makeBackupIndex.
	BootStrapping
		ifTrue: [ ws := self indexFile charOutputStream ]
		ifFalse: [  ws := self indexFile writeStream ].
	[
		ws nextPutAll: self handlerId; cr.
		self indexDict associationsDo: [ :a <Association[Symbol, Cltn[Str]]> |
	 		ws deltaNextChunkPut: a key.
			a value do: [ :e <Str> | 
				ws cr; deltaNextChunkPut: e ].
			ws nextPut: $ ; nextPut: $!!; cr ].
		BootStrapping ifFalse: [ ws truncate ]
	] ensure: [
		ws close
	]
! !

"October 1, 2009 -> 22:19:51"!

Delta define: #Top as: (
(Class subclassOf: '' instanceVariables: '')) !


"October 1, 2009 -> 22:21:6"!

(Delta mirrorFor: #Top) removeDefinitionIfFail: [] !


"October 1, 2009 -> 23:21:15"!

"System saved" !
"October 11, 2009 -> 21:42:16"!

Delta define: #NewspeakMetaclass as: (
(Class subclassOf: 'Metaclass' instanceVariables: '')) !


"October 11, 2009 -> 21:44:28"!

Delta define: #NS3 as: (
(Class subclassOf: 'NS1' instanceVariables: '')) !


"October 11, 2009 -> 21:44:40"!

"System saved" !
"October 11, 2009 -> 21:48:3"!

! (Delta mirrorFor: #NS1) classSide methodsFor: 'testing' !
one

	^2! !

"October 11, 2009 -> 21:51:12"!

(Delta mirrorFor: #NS3) removeDefinitionIfFail: [] !


"October 11, 2009 -> 21:51:27"!

(Delta mirrorFor: #NS1) classSide removeMethod: #one ifAbsent: [] !


"October 11, 2009 -> 21:56:12"!

"System saved" !
"October 11, 2009 -> 21:57:13"!

(Delta mirrorFor: #NewspeakMetaclass) removeDefinitionIfFail: [] !


"October 11, 2009 -> 21:57:21"!

"System saved" !
"October 15, 2009 -> 0:39:48"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
scavengeIfPossible

	self scavengeGarbage! !

"October 15, 2009 -> 0:42:15"!

"System saved" !
"October 15, 2009 -> 0:46:34"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
canScavenge

	^{{primitiveCanScavenge}}! !

"October 15, 2009 -> 0:47:20"!

"System saved" !
"October 15, 2009 -> 0:52:48"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
scavengeIfPossible

	self canScavenge
		ifTrue: [self scavengeGarbage]! !

"October 15, 2009 -> 0:53:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
scavengeAndAllocate: allocateBlock ifExpand: expansionBlock

	|expansions |
	expansions := self expansionCount.
	self scavengeIfPossible.
	^(expansions ~~ self expansionCount)
			ifTrue: [self collectAndAllocate: allocateBlock
								ifExpand: expansionBlock]
			ifFalse: [allocateBlock
								value: false
								value: [:e1| self reportNonAllocationFailure: e1.
													allocateBlock
															value: true
															value: [:e2| self reportNonAllocationFailure: e2.
																				self collectAndAllocate: allocateBlock
																						ifExpand: expansionBlock]]]! !

"October 15, 2009 -> 0:54:52"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
collectIfPossible

	self canScavenge
		ifTrue: [self collectGarbage]! !

"October 15, 2009 -> 0:55:12"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
collectAndAllocate: allocateBlock ifExpand: expansionBlock

	self collectIfPossible.
	self growIfNecessary.
	^[allocateBlock
			value: false
			value: [:e|
						self reportNonAllocationFailure: e.
						allocateBlock
							value: true
							value: [:e1|
										self reportNonAllocationFailure: e1.
										expansionBlock value.
										allocateBlock
											value: true
											value: [:e2| nil error: e2]]]]
			ensure: [self shrinkIfPossible]! !

"October 15, 2009 -> 0:56:33"!

"System saved" !
"October 17, 2009 -> 16:18:13"!

Delta define: #Top as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"October 17, 2009 -> 16:20:4"!

(Delta mirrorFor: #Top) removeDefinitionIfFail: [] !


"October 17, 2009 -> 16:20:16"!

"System saved" !
"November 16, 2009 -> 1:56:21"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"November 16, 2009 -> 1:56:21"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"November 16, 2009 -> 1:56:21"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"November 16, 2009 -> 1:56:21"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"November 16, 2009 -> 1:56:21"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"November 16, 2009 -> 1:56:21"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"November 16, 2009 -> 1:56:21"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"November 16, 2009 -> 1:56:21"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"November 16, 2009 -> 1:56:21"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"November 16, 2009 -> 1:56:21"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"November 16, 2009 -> 1:56:21"!

Delta define: #StackTraceInspector as: (
(Class subclassOf: 'ProgrammingEnvironment' instanceVariables: 'process <Process>
activationOutliners <Column[Visual]>') classVariables: 'Debuggers <Dict[Process, StackTraceInspector]>') !


"November 16, 2009 -> 1:56:21"!

(Delta mirrorFor: #StackTraceInspector)
comment: 
'Display for process stack trace (abort, continue, and command line debug possible).
 (c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"November 16, 2009 -> 1:56:21"!

! (Delta mirrorFor: #StackTraceInspector) classSide methodsFor: 'instance creation' !
on: p <Process> ^ <Instance>

	|debugger|
	(debugger := self new) initProcess: p.
	self debuggers at: p put: debugger.
	^debugger! !

"November 16, 2009 -> 1:56:21"!

! (Delta mirrorFor: #StackTraceInspector) classSide methodsFor: 'instance creation' !
openOn: p <Process>
	
	(self debuggers
				at: p
				ifAbsent: [^(self on: p) launch]) rebuild! !

"November 16, 2009 -> 1:56:21"!

! (Delta mirrorFor: #StackTraceInspector) classSide methodsFor: 'private - accessing' !
debuggers ^<Dict[Process,StackTraceInspector]>

	Debuggers isNil
		ifTrue: [Debuggers := Dictionary[Process, StackTraceInspector] new].
	^Debuggers! !

"November 16, 2009 -> 1:56:21"!

! (Delta mirrorFor: #StackTraceInspector) classSide methodsFor: 'private - accessing' !
removeDebugger: debugger <StackTraceInspector>

	self debuggers
		removeAt: debugger process
		ifAbsent: []! !

"November 16, 2009 -> 1:56:21"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'accessing' !
process ^ <Process>

	^process! !

"November 16, 2009 -> 1:56:21"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'accessing' !
windowTitle ^ <Str>

	self process processError isNil ifTrue: [^''].
	^self process processError name! !

"November 16, 2009 -> 1:56:21"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'control' !
abortProcess

	"Process get aborted by default when stack trace inspector is closed"
	self remove.
	self closeTopWindow

! !

"November 16, 2009 -> 1:56:21"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'control' !
closeRequest: toClose <[]>

	"Abort inspected process when window closes"
	self remove.
	self process isNil
		ifFalse: [	self process terminate ].
	super closeRequest: toClose! !

"November 16, 2009 -> 1:56:21"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'control' !
closeTopWindow

	|topWindow|
	topWindow := self visual topWindow.
	topWindow isNil
		ifFalse: [topWindow requestClose]! !

"November 16, 2009 -> 1:56:21"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'control' !
continueProcess

	|topWindow|
	self remove.
	self process resume.
	self process: nil.		"Don't terminate process when window closes"
	topWindow := self visual topWindow.
	topWindow isNil
		ifFalse: [topWindow requestClose]! !

"November 16, 2009 -> 1:56:21"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'control' !
singleStep: activation <Activation>

	self resumeAfter: [{{primitiveActivationSingleStep: activation
										ifFail: [:err <Symbol> | self error: err]}}]! !

"November 16, 2009 -> 1:56:21"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'control' !
stepNext: activation <Activation>

	self resumeAfter: [{{primitiveActivationStepNext: activation
										ifFail: [:err <Symbol> | self error: err]}}]! !

"November 16, 2009 -> 1:56:21"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'control' !
stepReturn: activation <Activation>

	self resumeAfter: [{{primitiveActivationStepReturn: activation
										ifFail: [:err <Symbol> | self error: err]}}]! !

"November 16, 2009 -> 1:56:21"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'control' !
transferToConsoleDebugger

	self process stopInEvaluator.
	self process: nil.		"Don't terminate process when window closes"
	self requestCloseIfTopWindow.
! !

"November 16, 2009 -> 1:56:21"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'menus' !
hasMenu ^ <Boolean>

	^true! !

"November 16, 2009 -> 1:56:21"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'menus' !
menuBar ^ <Menu>

	^Menu new
		add: self fileMenu;
		add: self processMenu! !

"November 16, 2009 -> 1:56:21"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'menus' !
processMenu ^ <Menu>

	^Menu new
		name: '&Process';
		add: (MenuAction new
					name: '&Abort';
					action: [ self abortProcess ] );
		add: (MenuAction new
					name: '&Continue';
					active: [ self process processError continuable ];
					action: [ self continueProcess ] );
		add: (MenuAction new
					name: '&Transfer to console debugger';
					action: [ self transferToConsoleDebugger ] )
! !

"November 16, 2009 -> 1:56:21"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'private' !
ActivationOutliner

	^ActivationOutliner! !

"November 16, 2009 -> 1:56:21"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'private' !
addActivationsTo: col <Column[Visual]>

	| stack <Array[Activation]> start <Int> |
	stack := self process activationStack.
	start := 1 "+ self process processError topFramesIgnored".
	
	"Add first activation open"
	self assert: [ start < stack size ].
	col add: (self outlinerFor: (stack at: start)
						open: true).
	start+1 to: stack size do: [ :i <Int> |
		| a <Activation> |
		a := stack at: i.
		a isBlockValueActivation
			ifFalse: [	col add: (self outlinerFor: a open: false) ]
	]! !

"November 16, 2009 -> 1:56:21"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'private' !
buildBareVisualTop: top <Boolean> ^ <Visual>

	activationOutliners := Column[Visual] new.
	self addActivationsTo: activationOutliners.
	^activationOutliners
! !

"November 16, 2009 -> 1:56:21"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'private' !
outlinerFor: activation <Activation> open: b <Boolean>

	^(self ActivationOutliner
			on: activation
			debugger: self)
				open: b;
				imbeddedVisual! !

"November 16, 2009 -> 1:56:21"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'private' !
process: p <Process>

	process := p! !

"November 16, 2009 -> 1:56:21"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'private' !
rebuild

	self inSessionProcessDo:
		[activationOutliners removeAll.
		self addActivationsTo: activationOutliners]! !

"November 16, 2009 -> 1:56:21"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'private' !
remove

	self class removeDebugger: self! !

"November 16, 2009 -> 1:56:21"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'private' !
resumeAfter: block

	block value.
	self process resume! !

"November 16, 2009 -> 1:56:21"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'private' !
step: activation setup: block

	block value: activation.
	self process resume! !

"November 16, 2009 -> 1:56:21"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'private-initialization' !
initProcess: p <Process>

	self assert: [ p processError notNil ].
	self process: p.
! !

"November 16, 2009 -> 1:56:28"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"November 16, 2009 -> 1:56:28"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"November 16, 2009 -> 1:56:28"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"November 16, 2009 -> 1:56:28"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"November 16, 2009 -> 1:56:28"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"November 16, 2009 -> 1:56:28"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"November 16, 2009 -> 1:56:28"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"November 16, 2009 -> 1:56:28"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"November 16, 2009 -> 1:56:28"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"November 16, 2009 -> 1:56:28"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"November 16, 2009 -> 1:56:28"!

Delta define: #ActivationOutliner as: (
(Class subclassOf: 'CommonProgEnvOutliner' instanceVariables: 'activation <Activation>
debugger <StackTraceInspector>')) !


"November 16, 2009 -> 1:56:28"!

(Delta mirrorFor: #ActivationOutliner)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"November 16, 2009 -> 1:56:28"!

! (Delta mirrorFor: #ActivationOutliner) classSide methodsFor: 'instance creation' !
on: a <Activation> ^ <Instance>

	^self new initActivation: a! !

"November 16, 2009 -> 1:56:28"!

! (Delta mirrorFor: #ActivationOutliner) classSide methodsFor: 'instance creation' !
on: a <Activation> debugger: debugger<StackTraceInspector> ^ <Instance>

	^self new initActivation: a debugger: debugger! !

"November 16, 2009 -> 1:56:28"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'accessing' !
activation ^ <Activation>

	^activation! !

"November 16, 2009 -> 1:56:28"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
activationVariableView: variable <Object> ^<Visual>

	^self
		activationVariableView: (self safePrintString: variable)
		value: variable! !

"November 16, 2009 -> 1:56:28"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
activationVariableView: label <Str> value: variable <Object> ^<Visual>

	^self
		buildLabel: label
		painter: self codePainter
		action: [ (Inspector on: variable) launch ]! !

"November 16, 2009 -> 1:56:28"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildActions ^ <Visual>

	| row <Row[Visual]> |

	row := Row[Button] new.
	row add: (Button
						labeled: 'Step into'
						action: [:b <Button> | debugger singleStep: self activation]).
	row add: (Button 
						labeled: 'Step over'
						action: [:b <Button> | debugger stepNext: self activation]).
	row add: (Button
						labeled: 'Step out'
						action: [:b <Button> | debugger stepReturn: self activation]).
	row add: Glue xStretchy.
	^row! !

"November 16, 2009 -> 1:56:28"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildBody ^<Visual>

	| col <Column[Visual]> row <Row[Visual]> |

	col := Column[Visual] new.
	row := Row[Visual] new.
	row add: self buildCodeView;
		add: self buildTemporariesView.
	col add: self buildActions;
		add: row.
	^col
! !

"November 16, 2009 -> 1:56:28"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildClosedHeader ^ <Visual>

	| selector <Symbol> args <Array[Object]> row <Row[Visual]> |
	
	"Check type of activation"
	self activation isSmalltalk
		ifFalse: [	^(StringGlyph for: 'External activation' painter: self codePainter) asVisual ].

	selector := self activation method enclosingMethod selector.
	args := self activation arguments.
	row := Row[Visual] new.
	
	self activation method isBlockMethod
		ifTrue: [		"Add block parens interspersed with arguments"
							row add: (StringGlyph for: '[' painter: self codePainter) asVisual.
							args do: [ :arg <Object> |
								row add: (StringGlyph for: ':' painter: self selectorPainter) asVisual.
								row add: (self activationVariableView: arg)].
							row add: (StringGlyph for: '] in ' painter: self codePainter) asVisual.
							row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
		ifFalse: [	"Add receiver"
							| receiver <Object> |
							receiver := self activation receiver.
							row add: (self activationVariableView: receiver).
							row add: (StringGlyph for: '>> ' painter: self codePainter) asVisual.
							"Add selector interspersed with arguments"
							args size = 0
								ifTrue: [		row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
								ifFalse: [	| strm <CharacterReadStream> |
													strm := selector readStream.
													args do: [ :arg <Object> |
														row add: (StringGlyph for: (strm upTo: $:), ':' painter: self selectorPainter) asVisual.
														row add: (self activationVariableView: arg) ]
												]
						].
	^row! !

"November 16, 2009 -> 1:56:28"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildCodeView ^<Visual>

	| cv <CodeView> vmSrc <Str> strm <CharacterReadStream> gls <OrdCltn[CharacterGlyph]> |

	"Construct vm source with highligthed bci"
	vmSrc := self activation vmPrettyPrint.
	strm := vmSrc readStream.
	gls := OrderedCollection[CharacterGlyph] new: vmSrc size.
	(vmSrc occurrencesOf: self currentByteCodeSeparatorCharacter) = 2
		ifTrue: [	gls addAll: (self standardTextForString: (strm upTo: self currentByteCodeSeparatorCharacter) painter: self codePainter).
						gls addAll: (self standardTextForString: (strm upTo: self currentByteCodeSeparatorCharacter) painter: self codeBCIPainter) ].
	gls addAll: (self standardTextForString: strm contentsRemaining painter: self codePainter).
	
	cv := CodeView forText.
	cv doneBlock: [ :b <Boolean> :onSuccess <[]> | b ifTrue: onSuccess ].	"Dummy for now, we are not showing the real source code"
	cv model: gls.
	^self editorBorderFor: cv
! !

"November 16, 2009 -> 1:56:28"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildExternalHeader ^ <Visual>

	^(StringGlyph for: 'External activation' painter: self codePainter) asVisual! !

"November 16, 2009 -> 1:56:28"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildTemporariesView ^ <Visual>

	| column <Column[Visual]> |
	column := Column[Visual] new.
	self activation temporaries
		do: [:temp| column add: (self activationVariableView: temp key
														value: temp value)].
	^column
! !

"November 16, 2009 -> 1:56:28"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
currentByteCodeSeparatorCharacter ^ <Character>

	^Character value: 16r1B
! !

"November 16, 2009 -> 1:56:28"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
hasSelector ^<Boolean>

	^self isMethodActivation! !

"November 16, 2009 -> 1:56:28"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
initialPacifiedState ^ <Boolean>

	^self activation isSmalltalk not! !

"November 16, 2009 -> 1:56:28"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
isBlockActivation ^<Boolean>

	^self activation isSmalltalk and: [self activation method isBlockMethod]! !

"November 16, 2009 -> 1:56:28"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
isExternal ^ <Boolean>

	^self activation isSmalltalk not! !

"November 16, 2009 -> 1:56:28"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
isMethodActivation ^<Boolean>

	^self activation isSmalltalk and: [self activation method isBlockMethod not]! !

"November 16, 2009 -> 1:56:28"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
method

	^self mirror isNil
		ifTrue: [nil]
		ifFalse: [self mirror compiledMethodAt: self selector]! !

"November 16, 2009 -> 1:56:28"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
methodSource ^<Str>

	^(self hasSelector and: [self mirror notNil])
		ifTrue: [self mirror sourceForSelector: self selector]
		ifFalse: [self vmMethodSource]! !

"November 16, 2009 -> 1:56:28"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
mirror

	|mirror|
	mirror := Mirror on: self activation receiver class.
	[mirror isNil]
		whileFalse: [(mirror hasSelector: self selector) ifTrue: [^mirror].
							mirror := mirror superclass].
	^nil! !

"November 16, 2009 -> 1:56:28"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
safePrintString: aValue

	^[aValue printString]
		on: Error
		do: [:ex|'??instance of ', aValue class name]! !

"November 16, 2009 -> 1:56:28"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
selector ^<Symbol>

	^self activation method selector! !

"November 16, 2009 -> 1:56:29"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
sourceAsCharGlyphs ^<CharGlyphs>

	| vmSrc <Str> strm <CharacterReadStream> gls <OrdCltn[CharacterGlyph]> |

	"Construct vm source with highligthed bci"
	vmSrc := self methodSource.
	strm := vmSrc readStream.
	gls := OrderedCollection[CharacterGlyph] new: vmSrc size.
	(vmSrc occurrencesOf: self currentByteCodeSeparatorCharacter) = 2
		ifTrue: [	gls addAll: (self standardTextForString: (strm upTo: self currentByteCodeSeparatorCharacter) painter: self codePainter).
						gls addAll: (self standardTextForString: (strm upTo: self currentByteCodeSeparatorCharacter) painter: self codeBCIPainter) ].
	gls addAll: (self standardTextForString: strm contentsRemaining painter: self codePainter).
	^gls
! !

"November 16, 2009 -> 1:56:29"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
vmMethodSource ^<Str>

	^self activation vmPrettyPrint! !

"November 16, 2009 -> 1:56:29"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private-initialization' !
initActivation: a <Activation>

	activation := a! !

"November 16, 2009 -> 1:56:29"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private-initialization' !
initActivation: a <Activation> debugger: d <StackTraceInspector>

	activation := a.
	debugger := d! !

"November 16, 2009 -> 1:56:57"!

"System saved" !
"December 6, 2009 -> 18:26:8"!

Delta define: #LargeIntegerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"December 6, 2009 -> 18:26:8"!

Delta define: #LargeIntegerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"December 6, 2009 -> 18:26:8"!

Delta define: #LargeIntegerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"December 6, 2009 -> 18:26:8"!

Delta define: #LargeIntegerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"December 6, 2009 -> 18:26:8"!

Delta define: #LargeIntegerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"December 6, 2009 -> 18:26:8"!

Delta define: #LargeIntegerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"December 6, 2009 -> 18:26:8"!

Delta define: #LargeIntegerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"December 6, 2009 -> 18:26:8"!

Delta define: #LargeIntegerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"December 6, 2009 -> 18:26:8"!

Delta define: #LargeIntegerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"December 6, 2009 -> 18:26:8"!

Delta define: #LargeIntegerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"December 6, 2009 -> 18:26:8"!

Delta define: #LargeIntegerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"December 6, 2009 -> 18:26:8"!

(Delta mirrorFor: #LargeIntegerTest)
comment: 
''!


"December 6, 2009 -> 18:26:8"!

! (Delta mirrorFor: #LargeIntegerTest) methodsFor: 'testing' !
testBitAnd

	self assert: (1 asLargeInteger bitAnd: 1 asLargeInteger) = 1! !

"December 6, 2009 -> 18:26:8"!

! (Delta mirrorFor: #LargeIntegerTest) methodsFor: 'testing' !
testBitAndComplex

	self assert: (16rFFFFFFFF bitAnd: 16rF0F0F0F0) = 16rF0F0F0F0! !

"December 6, 2009 -> 18:26:8"!

! (Delta mirrorFor: #LargeIntegerTest) methodsFor: 'testing' !
testBitAndWithDouble

	self assert: (16rFFFFFFFF bitAnd: 1.0) = 1! !

"December 6, 2009 -> 18:26:8"!

! (Delta mirrorFor: #LargeIntegerTest) methodsFor: 'testing' !
testBitAndWithSmallInteger

	self assert: (16rFFFFFFFF bitAnd: 1) = 1! !

"December 6, 2009 -> 18:26:8"!

! (Delta mirrorFor: #LargeIntegerTest) methodsFor: 'testing' !
testBitOr

	self assert: (1 asLargeInteger bitOr:  -1 asLargeInteger) = -1! !

"December 6, 2009 -> 18:26:8"!

! (Delta mirrorFor: #LargeIntegerTest) methodsFor: 'testing' !
testBitOrWithDouble

	self assert: (16rFFFFFFFE bitOr: 1.0) = 16rFFFFFFFF! !

"December 6, 2009 -> 18:26:8"!

! (Delta mirrorFor: #LargeIntegerTest) methodsFor: 'testing' !
testBitOrWithSmallInteger

	self assert: (16rFFFFFFFE bitOr: 1) = 16rFFFFFFFF! !

"December 6, 2009 -> 18:26:8"!

! (Delta mirrorFor: #LargeIntegerTest) methodsFor: 'testing' !
testBitShiftWithPositiveShift

	self assert: (2 asLargeInteger bitShift: 1) = 4! !

"December 6, 2009 -> 18:26:8"!

! (Delta mirrorFor: #LargeIntegerTest) methodsFor: 'testing' !
testBitXor

	self assert: (1 asLargeInteger bitXor:  -1 asLargeInteger) = -2! !

"December 6, 2009 -> 18:26:8"!

! (Delta mirrorFor: #LargeIntegerTest) methodsFor: 'testing' !
testBitXorWithDouble

	self assert: (16rFFFFFFFF bitXor: 1.0) = 16rFFFFFFFE! !

"December 6, 2009 -> 18:26:8"!

! (Delta mirrorFor: #LargeIntegerTest) methodsFor: 'testing' !
testBitXorWithSmallInteger

	self assert: (16rFFFFFFFE bitXor: 16rF) = 16rFFFFFFF1! !

"December 6, 2009 -> 18:26:8"!

! (Delta mirrorFor: #LargeIntegerTest) methodsFor: 'testing' !
testDivision

	self assert: 16r100000000 // 16r10000 = 16r10000! !

"December 6, 2009 -> 18:26:8"!

! (Delta mirrorFor: #LargeIntegerTest) methodsFor: 'testing' !
testDivisionWithLargeNegativeDividend

	self assert: -16r100000001 // 16r100000000 = -16r2! !

"December 6, 2009 -> 18:26:8"!

! (Delta mirrorFor: #LargeIntegerTest) methodsFor: 'testing' !
testDivisionWithLargeNegativeDivisor

	self assert: 16r111111111 // -16r111111110 = -16r2! !

"December 6, 2009 -> 18:26:8"!

! (Delta mirrorFor: #LargeIntegerTest) methodsFor: 'testing' !
testDivisionWithNegativeDividend

	self assert: -16r100000001 // 16r10000 = -16r10001! !

"December 6, 2009 -> 18:26:8"!

! (Delta mirrorFor: #LargeIntegerTest) methodsFor: 'testing' !
testDivisionWithNegativeDivisor

	self assert: 16r100000001 // -16r10000 = -16r10001! !

"December 6, 2009 -> 18:26:8"!

! (Delta mirrorFor: #LargeIntegerTest) methodsFor: 'testing' !
testDivisionWithRounding

	self assert: 16r100000001 // 16r10000 = 16r10000! !

"December 6, 2009 -> 18:26:8"!

! (Delta mirrorFor: #LargeIntegerTest) methodsFor: 'testing' !
testIntegerDivisionNegativeDenominator

	self assert: (1 negated asLargeInteger isKindOf: LargeInteger).
	self assert: 1 asLargeInteger // 2 negated asLargeInteger = -1.
	self assert: 3 asLargeInteger // 2 negated asLargeInteger = -2! !

"December 6, 2009 -> 18:26:8"!

! (Delta mirrorFor: #LargeIntegerTest) methodsFor: 'testing' !
testIntegerDivisionNegativeNumerator

	self assert: (1 negated asLargeInteger isKindOf: LargeInteger).
	self assert: 1 negated asLargeInteger // 2 asLargeInteger = -1.
	self assert: 3 negated asLargeInteger // 2 asLargeInteger = -2! !

"December 6, 2009 -> 18:26:8"!

! (Delta mirrorFor: #LargeIntegerTest) methodsFor: 'testing' !
testIntegerDivisionNegativeNumeratorAndDenominator

	self assert: (1 negated asLargeInteger isKindOf: LargeInteger).
	self assert: 1 negated asLargeInteger // 2 negated asLargeInteger = 0.
	self assert: 3 negated asLargeInteger // 2 negated asLargeInteger = 1! !

"December 6, 2009 -> 18:26:8"!

! (Delta mirrorFor: #LargeIntegerTest) methodsFor: 'testing' !
testQuo

	self assert: (16r100000000 quo: 16r10000) = 16r10000! !

"December 6, 2009 -> 18:26:8"!

! (Delta mirrorFor: #LargeIntegerTest) methodsFor: 'testing' !
testQuoWithLargeNegativeDivisor

	self assert: (16r111111111 quo: -16r111111110) = -16r1! !

"December 6, 2009 -> 18:26:8"!

! (Delta mirrorFor: #LargeIntegerTest) methodsFor: 'testing' !
testQuoWithNegativeDividend

	self assert: (-16r100000001 quo: 16r10000) = -16r10000! !

"December 6, 2009 -> 18:26:8"!

! (Delta mirrorFor: #LargeIntegerTest) methodsFor: 'testing' !
testQuoWithNegativeDivisor

	self assert: (16r100000001 quo: -16r10000) = -16r10000! !

"December 6, 2009 -> 18:26:8"!

! (Delta mirrorFor: #LargeIntegerTest) methodsFor: 'testing' !
testQuoWithRounding

	self assert: (16r100000001 quo: 16r10000) = 16r10000! !

"December 6, 2009 -> 18:26:8"!

! (Delta mirrorFor: #LargeIntegerTest) methodsFor: 'testing' !
testRemWithLargeNegativeDivisor

	| result |
	result := (16r111111111 rem: -16r111111110).
	self assert: result = 1! !

"December 6, 2009 -> 18:26:8"!

! (Delta mirrorFor: #LargeIntegerTest) methodsFor: 'testing' !
testShiftLeft

	self assert: 2 asLargeInteger >> 1 = 1! !

"December 6, 2009 -> 18:26:8"!

! (Delta mirrorFor: #LargeIntegerTest) methodsFor: 'testing' !
testShiftLeftWithError

	self should: [2 asLargeInteger >> -1]
			raise: Error! !

"December 6, 2009 -> 18:26:8"!

! (Delta mirrorFor: #LargeIntegerTest) methodsFor: 'testing' !
testShiftRight

	self assert: 2 asLargeInteger << 1 = 4! !

"December 6, 2009 -> 18:26:8"!

! (Delta mirrorFor: #LargeIntegerTest) methodsFor: 'testing' !
testShiftRightWithError

	self should: [2 asLargeInteger << -1]
			raise: Error! !

"December 6, 2009 -> 18:26:8"!

! (Delta mirrorFor: #LargeIntegerTest) methodsFor: 'testing' !
testUnderflow

	self deny: SmallInteger maxVal + 1 * 8 + 1 negated = -1! !

"December 6, 2009 -> 18:26:22"!

Delta define: #LargeInteger as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Integer' instanceVariables: '')) !


"December 6, 2009 -> 18:26:22"!

Delta define: #LargeInteger as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Integer' instanceVariables: '')) !


"December 6, 2009 -> 18:26:22"!

Delta define: #LargeInteger as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Integer' instanceVariables: '')) !


"December 6, 2009 -> 18:26:22"!

Delta define: #LargeInteger as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Integer' instanceVariables: '')) !


"December 6, 2009 -> 18:26:22"!

Delta define: #LargeInteger as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Integer' instanceVariables: '')) !


"December 6, 2009 -> 18:26:22"!

Delta define: #LargeInteger as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Integer' instanceVariables: '')) !


"December 6, 2009 -> 18:26:22"!

Delta define: #LargeInteger as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Integer' instanceVariables: '')) !


"December 6, 2009 -> 18:26:22"!

Delta define: #LargeInteger as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Integer' instanceVariables: '')) !


"December 6, 2009 -> 18:26:22"!

Delta define: #LargeInteger as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Integer' instanceVariables: '')) !


"December 6, 2009 -> 18:26:22"!

Delta define: #LargeInteger as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Integer' instanceVariables: '')) !


"December 6, 2009 -> 18:26:22"!

Delta define: #LargeInteger as: (
(Class subclassOf: 'IndexedByteInstanceVariables |> Integer' instanceVariables: '')) !


"December 6, 2009 -> 18:26:22"!

(Delta mirrorFor: #LargeInteger)
comment: 
'Implements infinite precision integer arithmetic.  This class should never be referred
to directly by user code.

Tags: %BlueBook

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.1 $
'!


"December 6, 2009 -> 18:26:22"!

! (Delta mirrorFor: #LargeInteger) classSide methodsFor: 'restricted-to floats' !
forFloat: f <Float> ^<LargeInteger>

	^{{self primitiveIndexedByteLargeIntegerFromFloat: f ifFail: [ :err <Symbol> | self error: err ] }}	 	 ! !

"December 6, 2009 -> 18:26:22"!

! (Delta mirrorFor: #LargeInteger) classSide methodsFor: 'restricted-to integers' !
forSmallInteger: sm <SmallInteger> ^<LargeInteger>

	^guaranteed <LargeInteger>
		{{self primitiveIndexedByteLargeIntegerFromSmallInteger: sm
			ifFail: [ :err <Symbol> | self error: err ]
	 	 }}! !

"December 6, 2009 -> 18:26:22"!

! (Delta mirrorFor: #LargeInteger) classSide methodsFor: 'testing' !
test

	[ (SmallInteger maxVal + 1) class = LargeInteger ] verify.
	[ ((SmallInteger maxVal + 1) - 1) class = SmallInteger ] verify.
	[ ((SmallInteger maxVal + 1) - 1) = SmallInteger maxVal ] verify.
	[ ((SmallInteger maxVal + 1) - SmallInteger maxVal) = 1 ] verify.
	[ ((SmallInteger maxVal * 2) // 2) = SmallInteger maxVal ] verify.
	[ ((SmallInteger maxVal + SmallInteger maxVal ) // 2) = SmallInteger maxVal ] verify.
	[ ((SmallInteger maxVal * 2 ) - (SmallInteger maxVal * 2 )) = 0 ] verify.

	[ (SmallInteger maxVal * 3 ) > (SmallInteger maxVal * 2 ) ] verify.
	[ (SmallInteger maxVal * -3 ) < (SmallInteger maxVal * 2 ) ] verify.
	[ SmallInteger maxVal < (SmallInteger maxVal * 2 ) ] verify.
	[ (SmallInteger maxVal * -3 ) = (SmallInteger maxVal * -3 ) ] verify.
	[ (SmallInteger maxVal * -3 ) ~= (SmallInteger maxVal * 3 ) ] verify.
	[ (SmallInteger maxVal * 3 ) = (SmallInteger maxVal * 3 ) ] verify.
	[ ((SmallInteger maxVal * -3) * -1 ) = (SmallInteger maxVal * 3 ) ] verify.
	[ SmallInteger maxVal = (((SmallInteger maxVal * -3) * -1 ) // 3)  ] verify.
	[ ((SmallInteger maxVal * -3) / (SmallInteger maxVal * -3)) = 1 ] verify.
	[ ((SmallInteger maxVal * 2) / (SmallInteger maxVal * 3)) = (2/3) ] verify.
	[ ((((SmallInteger maxVal * 2) * 2.0) // 2) / (SmallInteger maxVal * 3)) = (2/3) ] verify.


	[ 20 factorial printString =  '2432902008176640000' ] verify.
	[ 20 factorial =  (Integer readFrom: '2432902008176640000' readStream) ] verify.
! !

"December 6, 2009 -> 18:26:22"!

! (Delta mirrorFor: #LargeInteger) methodsFor: 'bit operations' !
<< bits <Int> ^ <Int>

	bits < 0 ifTrue: [self error: 'shift right should not be negative'].
	^self bitShift: bits! !

"December 6, 2009 -> 18:26:22"!

! (Delta mirrorFor: #LargeInteger) methodsFor: 'bit operations' !
>> bits <Int> ^ <Int>

	bits < 0 ifTrue: [self error: 'shift left should not be negative'].
	^self bitShift: bits negated! !

"December 6, 2009 -> 18:26:22"!

! (Delta mirrorFor: #LargeInteger) methodsFor: 'bit operations' !
bitAnd: arg <Number> ^ <Int>

	^{{self primitiveIndexedByteLargeIntegerAnd: arg
				ifFail: [:err|
							#FirstArgumentHasWrongType == err
								ifTrue: [super bitAnd: arg]
								ifFalse: [self error: err]]}}! !

"December 6, 2009 -> 18:26:22"!

! (Delta mirrorFor: #LargeInteger) methodsFor: 'bit operations' !
bitOr: arg <Number> ^ <Int>

	^{{self primitiveIndexedByteLargeIntegerOr: arg
				ifFail: [:err|
							#FirstArgumentHasWrongType == err
								ifTrue: [super bitOr: arg]
								ifFalse: [self error: err]]}}! !

"December 6, 2009 -> 18:26:22"!

! (Delta mirrorFor: #LargeInteger) methodsFor: 'bit operations' !
bitShift: bits <Int> ^ <Int>

	^{{self primitiveIndexedByteLargeIntegerShift: bits
				ifFail: [:err | self error: err]}}! !

"December 6, 2009 -> 18:26:22"!

! (Delta mirrorFor: #LargeInteger) methodsFor: 'bit operations' !
bitXor: arg <Number> ^ <Int>

	^{{self primitiveIndexedByteLargeIntegerXor: arg
				ifFail: [:err|
							#FirstArgumentHasWrongType == err
								ifTrue: [super bitXor: arg]
								ifFalse: [self error: err]]}}! !

"December 6, 2009 -> 18:26:22"!

! (Delta mirrorFor: #LargeInteger) methodsFor: 'converting' !
asFloat ^ <Float>

	^{{ self primitiveIndexedByteLargeIntegerAsFloatIfFail: [ :err <Symbol> | self error: err ] }}
! !

"December 6, 2009 -> 18:26:22"!

! (Delta mirrorFor: #LargeInteger) methodsFor: 'operations' !
// arg <Number> ^<Int>

	^{{self primitiveIndexedByteLargeIntegerDiv: arg
			ifFail: [ :err <Symbol> |
							^err == #FirstArgumentHasWrongType
								ifTrue: [ super // arg ]
								ifFalse: [ self error: 'LargeInteger //: ', err ]
					  ]
		}}! !

"December 6, 2009 -> 18:26:22"!

! (Delta mirrorFor: #LargeInteger) methodsFor: 'operations' !
rem: arg <Number> ^ <Number>

	^{{self primitiveIndexedByteLargeIntegerRem: arg asLargeInteger
				ifFail: [ :err <Symbol> | self nonPrimitiveRem: arg error: err ]}}! !

"December 6, 2009 -> 18:26:22"!

! (Delta mirrorFor: #LargeInteger) methodsFor: 'printing' !
printOn: strm <CharOutputStream>

	"reimplemented to use print string primitive, which is much faster"
	strm putAll: self printString! !

"December 6, 2009 -> 18:26:22"!

! (Delta mirrorFor: #LargeInteger) methodsFor: 'printing' !
printString ^<Str>

	| ba <ByteArray> size <Integer> |
	ba := {{self primitiveIndexedByteLargeIntegerToStringBase: 10 ifFail:
		[ :err <Symbol> |	self error: err ]
	}}.
	"Right now the primitive returns a byte array with trailing zeroes. Robert will fix this"
	size := ba size.
	[ 0 = (ba at: size) and: [ size > 1] ] whileTrue: [ size := size - 1 ].
	^(ba copyWithSize: size) asString! !

"December 6, 2009 -> 18:26:22"!

! (Delta mirrorFor: #LargeInteger) methodsFor: 'private' !
compareToLargeInteger: li <LargeInteger> ^<Int>

	| result <Int> |
	result := {{self primitiveIndexedByteLargeIntegerCompare: li
						ifFail: [ :err <Symbol> | self error: err ]
				   }}.
	^result > 0
		ifTrue: [ 1 ]
		ifFalse: [ result < 0
							ifTrue: [ -1 ]
							ifFalse: [ 0 ]
					 ]! !

"December 6, 2009 -> 18:26:22"!

! (Delta mirrorFor: #LargeInteger) methodsFor: 'private' !
nonPrimitiveDiv: a <Number> error: err <Symbol> ^<Int>
	"This is invoked on primitive failure"

	^err == #FirstArgumentHasWrongType
			ifTrue: [ super // a ]
			ifFalse: [ self error: 'LargeInteger //: ', err ]! !

"December 6, 2009 -> 18:26:22"!

! (Delta mirrorFor: #LargeInteger) methodsFor: 'private' !
nonPrimitiveRem: a <Number> error: err <Symbol> ^<Int>
	"This is invoked on primitive failure"

	^err == #FirstArgumentHasWrongType
			ifTrue: [ super rem: a ]
			ifFalse: [ self error: 'LargeInteger rem: ', err ]! !

"December 6, 2009 -> 18:26:22"!

! (Delta mirrorFor: #LargeInteger) methodsFor: 'restricted-double dispatching' !
addFromInteger: o <Integer> ^<Integer>

	^{{self primitiveIndexedByteLargeIntegerAdd: o asLargeInteger
			ifFail: [ :err <Symbol> | self error: err ]
		}}! !

"December 6, 2009 -> 18:26:22"!

! (Delta mirrorFor: #LargeInteger) methodsFor: 'restricted-double dispatching' !
equalFromInteger: o <Integer> ^<Boolean>

	^0 = {{self primitiveIndexedByteLargeIntegerCompare: o asLargeInteger
		ifFail: [ :err <Symbol> | self error: err ]
	}}! !

"December 6, 2009 -> 18:26:22"!

! (Delta mirrorFor: #LargeInteger) methodsFor: 'restricted-double dispatching' !
lessFromInteger: o <Integer> ^<Boolean>

	^0 < {{self primitiveIndexedByteLargeIntegerCompare: o asLargeInteger
		ifFail: [ :err <Symbol> | self error: err ]
	}}! !

"December 6, 2009 -> 18:26:22"!

! (Delta mirrorFor: #LargeInteger) methodsFor: 'restricted-double dispatching' !
multiplyFromInteger: o <Integer> ^<Integer>

	^{{self primitiveIndexedByteLargeIntegerMultiply: o asLargeInteger
		ifFail: [ :err <Symbol> | self error: err ]
	}}.
! !

"December 6, 2009 -> 18:26:22"!

! (Delta mirrorFor: #LargeInteger) methodsFor: 'restricted-double dispatching' !
remFromInteger: o <Integer> ^<Integer>

	^{{self primitiveIndexedByteLargeIntegerRem: o asLargeInteger
		ifFail: [ :err <Symbol> | self error: err ]
	}}! !

"December 6, 2009 -> 18:26:22"!

! (Delta mirrorFor: #LargeInteger) methodsFor: 'restricted-double dispatching' !
subtractFromInteger: o <Integer> ^<Integer>

	^o asLargeInteger subtractLargeInteger: self! !

"December 6, 2009 -> 18:26:23"!

! (Delta mirrorFor: #LargeInteger) methodsFor: 'restricted-to large integers' !
asLargeInteger ^<LargeInteger>

	^self! !

"December 6, 2009 -> 18:26:23"!

! (Delta mirrorFor: #LargeInteger) methodsFor: 'restricted-to large integers' !
subtractLargeInteger: li <LargeInteger> ^<Integer>

	^{{self primitiveIndexedByteLargeIntegerSubtract: li
		ifFail: [ :err <Symbol> | self error: err ]
	}}! !

"December 6, 2009 -> 18:26:37"!

Delta define: #Integer as: (
(Class subclassOf: 'RationalNumber' instanceVariables: '') abstract) !


"December 6, 2009 -> 18:26:37"!

Delta define: #Integer as: (
(Class subclassOf: 'RationalNumber' instanceVariables: '') abstract) !


"December 6, 2009 -> 18:26:37"!

Delta define: #Integer as: (
(Class subclassOf: 'RationalNumber' instanceVariables: '') abstract) !


"December 6, 2009 -> 18:26:37"!

Delta define: #Integer as: (
(Class subclassOf: 'RationalNumber' instanceVariables: '') abstract) !


"December 6, 2009 -> 18:26:37"!

Delta define: #Integer as: (
(Class subclassOf: 'RationalNumber' instanceVariables: '') abstract) !


"December 6, 2009 -> 18:26:37"!

Delta define: #Integer as: (
(Class subclassOf: 'RationalNumber' instanceVariables: '') abstract) !


"December 6, 2009 -> 18:26:37"!

Delta define: #Integer as: (
(Class subclassOf: 'RationalNumber' instanceVariables: '') abstract) !


"December 6, 2009 -> 18:26:37"!

Delta define: #Integer as: (
(Class subclassOf: 'RationalNumber' instanceVariables: '') abstract) !


"December 6, 2009 -> 18:26:37"!

Delta define: #Integer as: (
(Class subclassOf: 'RationalNumber' instanceVariables: '') abstract) !


"December 6, 2009 -> 18:26:37"!

Delta define: #Integer as: (
(Class subclassOf: 'RationalNumber' instanceVariables: '') abstract) !


"December 6, 2009 -> 18:26:37"!

Delta define: #Integer as: (
(Class subclassOf: 'RationalNumber' instanceVariables: '') abstract) !


"December 6, 2009 -> 18:26:37"!

(Delta mirrorFor: #Integer)
comment: 
'%notes:
    - This class implements generalized algorithms that handle both large and small integers.
    -  >,>=,<= are not implemented here for generalized integers; the Magnitude versions
          are fine.  SmallInteger implements its own for efficiency.
    * When the generalized algorithms are written, they should be designed to coerce either or
          both of receiver and argument to largeinteger format if they are smallintegers, because
         the overflow/underflow code in SmallInteger depends on that.

Tags: %BlueBook %User

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.
'!


"December 6, 2009 -> 18:26:37"!

! (Delta mirrorFor: #Integer) classSide methodsFor: 'utility' !
readFrom: s <CharInputStream> ^<Int>

	| negative <Boolean> i <Int> |
	s atEnd
		ifTrue: [ ^ 0 ].
	negative := s peek = $-.
	negative
		ifTrue: [ s next ].
	i := 0.
	[ s atEnd not and: [ s peek isDigit ] ]
		whileTrue: [	i := (i*10) + s next digitValue
	].
	negative
		ifTrue: [ i := i negated ].
	^i! !

"December 6, 2009 -> 18:26:37"!

! (Delta mirrorFor: #Integer) methodsFor: 'accessing' !
denominator ^<Integer>
	^1! !

"December 6, 2009 -> 18:26:37"!

! (Delta mirrorFor: #Integer) methodsFor: 'accessing' !
hash ^<Int>

	^self! !

"December 6, 2009 -> 18:26:37"!

! (Delta mirrorFor: #Integer) methodsFor: 'accessing' !
hexDigitAt: nybble <Int> ^<Character>
	"Return the hex character for the ith nybble (4 bits, index of lowest sig. = 1)"

	^'0123456789ABCDEF'
		at: ((self bitShift: (nybble - 1 * 4) negated) bitAnd: 16rF) + 1! !

"December 6, 2009 -> 18:26:37"!

! (Delta mirrorFor: #Integer) methodsFor: 'accessing' !
identityHash ^<Int>

	^self! !

"December 6, 2009 -> 18:26:37"!

! (Delta mirrorFor: #Integer) methodsFor: 'accessing' !
negated ^<Int>

	^self zero - self! !

"December 6, 2009 -> 18:26:37"!

! (Delta mirrorFor: #Integer) methodsFor: 'accessing' !
numerator ^<Integer>
	^self! !

"December 6, 2009 -> 18:26:37"!

! (Delta mirrorFor: #Integer) methodsFor: 'benchmarking' !
benchFib  "Handy send-heavy benchmark"
	"(result // seconds to run) = approx calls per second"
	" | r t |
	  t _ Time millisecondsToRun: [r _ 26 benchFib].
	  (r * 1000) // t"
	"138000 on a Mac 8100/100"
	^ self < 2
		ifTrue: [1] 
		ifFalse: [(self-1) benchFib + (self-2) benchFib + 1]! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'benchmarking' !
recurse
	self > 0 ifTrue: [
		(self - 1) recurse.
		(self - 1) recurse.
	]! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'benchmarking' !
sumTo: end <Int>  ^<Int>
	| sum <Int> | 
	sum := 0.
	self to: end do: [ :i <Int> | sum := sum + i ].
	^sum! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'bit operations' !
allMask: mask <Integer> ^<Boolean>

	^(self bitAnd: mask) = mask! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'bit operations' !
anyMask: mask <Integer> ^<Boolean>

	^(self bitAnd: mask) ~= 0! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'bit operations' !
bitAnd: o <X> ^<Self|X>
		{where X <Integer> is arg 1}

	^o bitAndFromInteger: self! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'bit operations' !
bitAt: index <Int> ^<Int>
	"Return the bit at the specified bit index, with the low bit being index 1"

	^1 bitAnd: (self bitShift: (1 - index))! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'bit operations' !
bitInvert ^<Int>

	^-1 - self! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'bit operations' !
bitOr: o <X> ^<Self|X>
		{where X <Integer> is arg 1}

	^o bitOrFromInteger: self! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'bit operations' !
bitShift: shift <Int> ^<Int>

	self unimplemented! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'bit operations' !
bitXor: o <X> ^<Self|X>
		{where X <Integer> is arg 1}

	^o bitXorFromInteger: self! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'bit operations' !
highBit ^<SmallInt>

	self unimplemented! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'bit operations' !
noMask: mask <Integer> ^<Boolean>

	^(self bitAnd: mask) = 0! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'bit operations' !
rawBitShift: numBits <Int> ^<Int>
	"This is like bit shift, except that the result is truncated to a smallinteger, rather than
		overflowing to a largeinteger.  The receiver cannot be a largeinteger."

	self error: 'this message only works for small integers'! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'comparison' !
< a <Number> ^<Boolean>

	^a lessFromInteger: self! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'comparison' !
= a <Object> ^<Boolean>

"%todo: use this typesafe version when coerce: is fast
	^(Number coerce: a else: [ ^false ]) equalFromInteger: self
"
	^a Number
		ifTrue: [ (guaranteed <Number> a) equalFromInteger: self ]
		ifFalse: [ false ]
! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'comparison' !
@= other <ExternalData> ^<Boolean>
	"Compares two ExternalData objects to each other.  This will coerce between integers and proxies
	  as needed"
	"%opt- this builds two proxies when comparing two integers; use double dispatching instead"

	^other = self asExternalProxy! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'comparison' !
@~= other <ExternalData> ^<Boolean>
	"Compares two ExternalData objects to each other.  This will coerce between integers and proxies
	  as needed"

	^(self @= other) not! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'constants' !
unit ^<Integer>

	^1! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'constants' !
zero ^<Integer>

	^0! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'converting' !
asExternalProxy ^<ExternalProxy>

	^ExternalProxy forInt: self! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'converting' !
asFloat ^<Float>
	self unimplemented! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'converting' !
asInteger ^<Integer>

	^self! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'iteration' !
timesRepeat: f <[]> ^<Object>

	1 to: self do: [ :i <Int> |
		f value  ].
	^nil! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'iteration' !
to: stop <Int> by: step <Int> do: f <[Int]> ^<Object>

	| v <Int> |
	v := self.
	step < 0
		ifFalse: [ [ v <= stop ]
					whileTrue: [	f value: v.
								v := v + step  ]]
		ifTrue: [ [ v >= stop ]
					whileTrue: [ f value: v.
								v := v + step  ]].
	^nil! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'iteration' !
to: stop <Int> do: f <[Int]> ^<Object>

	| v <Int> |
	v := self.
	[ v <= stop ]
		whileTrue: [	f value: v.
					v := v + 1  ].
	^nil! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'iteration' !
to: stop <Int> intervals: n <Int> do: f <[Int]> ^<Object>
	"Evaluate f with n + 1 values as evenly spaced 
	 as possible between the
	 receiver and stop, inclusive."

	| interval <RationalNumber> current <RationalNumber> |
	interval := (stop - self) / n.
	current := self.
	n + 1 timesRepeat:
		[	f value: current asInteger.
			current := current + interval.	].! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'mathematical functions' !
factorial ^<Int>

	self assert: [ self >= self zero ].
	^self <= 1
		ifTrue: [ 1 ]
		ifFalse: [ self * (self - 1) factorial ]! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'mathematical functions' !
nfib ^<Int>
	^self <= 1
			ifTrue: [1]
			ifFalse: [(self - 1) nfib +
							(self - 2) nfib +
							1]! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'operations' !
* a <Number> ^<X>
			{where X <Number> is returnType of #multiplyFromInteger: message of arg 1}
	"%generated code- do not modify"
	^guaranteed <X> (a multiplyFromInteger: self)! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'operations' !
+ a <Number> ^<X>
			{where X <Number> is returnType of #addFromInteger: message of arg 1}
	"%generated code- do not modify"
	^guaranteed <X> (a addFromInteger: self)! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'operations' !
- a <Number> ^<X>
			{where X <Number> is returnType of #subtractFromInteger: message of arg 1}
	"%generated code- do not modify"
	^guaranteed <X> (a subtractFromInteger: self)! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'operations' !
/ a <Number> ^<X>
			{where X <Number> is returnType of #divideFromInteger: message of arg 1}
	"%generated code- do not modify"
	^guaranteed <X> (a divideFromInteger: self)! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'operations' !
// arg <Number> ^<Int>

	"%todo: fix when coerce is fast"
	| cl <Class> |
	cl := arg class.
	^cl == LargeInteger
		ifTrue: [ self asLargeInteger // arg ]
		ifFalse: [ cl == SmallInteger
							ifTrue: [ self asLargeInteger // (guaranteed <SmallInteger> arg) asLargeInteger ]
							ifFalse: [ super // arg ]
					 ]! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'operations' !
\\ a <Number> ^<X>
			{where X <Number> is returnType of #moduloFromInteger: message of arg 1}
	"%generated code- do not modify"
	^guaranteed <X> (a moduloFromInteger: self)! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'operations' !
abs ^<Integer>

	^self < self zero
		ifTrue: [ self negated ]
		ifFalse: [ self ]! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'operations' !
ceiling ^<Int>

	^self! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'operations' !
floor ^<Int>

	^self! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'operations' !
gcd: other <Integer> ^<Integer>
	"greatest common divisor"

	| myabs <Int> otherabs <Int> lower <Int> higher <Int> |
	myabs := self abs.
	otherabs := other abs.

	myabs < otherabs
		ifTrue: [	lower := myabs.
						higher := otherabs.	]
		ifFalse: [	lower := otherabs.
						higher := myabs.		].
	[ lower == 0 ]
		whileFalse:
			[	| oldHigher <Int> |
				oldHigher := higher.
				higher := lower.
				lower := oldHigher \\ lower.	].
	^higher! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'operations' !
rem: a <Number> ^<X>
			{where X <Number> is returnType of #remFromInteger: message of arg 1}
	^guaranteed <X> (a remFromInteger: self)! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'operations' !
truncated ^<Int>

	^self! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'printing' !
printBareHexDigits: nDigits <Int> on: strm <CharOutputStream>

	nDigits to: 1 by: -1
		do: [ :i <Int> |
					strm put: (self hexDigitAt: i) ]! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'printing' !
printBareHexOn: strm <CharOutputStream>

	(self = (self bitAnd: 16rF))
		ifFalse: [ (self bitShift: -4) printBareHexOn: strm ].
	strm put: (self hexDigitAt: 1).! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'printing' !
printHexOn: strm <CharOutputStream>

	strm putAll: '16r'.
	self printBareHexOn: strm.! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'printing' !
printOn: strm <CharOutputStream>

	self printOn: strm radix: 10! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'printing' !
printOn: strm <CharOutputStream> radix: radix <Int>

	| abs <Int> |
	self negative
		ifTrue: [	strm nextPut: $-.
						abs := self negated. ]
		ifFalse: [	abs := self. ].
	abs printNonNegativeOn: strm radix: radix! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'private-proxy double dispatching' !
bitAndFromSmallInteger: other <SmallInteger> ^<ExternalData>

	^self bitAnd: other! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'private-proxy double dispatching' !
bitOrFromSmallInteger: other <SmallInteger> ^<Int>

	^self bitOr: other! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'proxy operations' !
externalBitAnd: other <ExternalData> ^<ExternalData>

	"this happens only if receiver is a largeinteger, since
		these messages are overridden in SmallInteger"
	self error: 'Attempt to do external data operations on a LargeInteger'! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'proxy operations' !
externalBitOr: other <ExternalData> ^<ExternalData>

		"this happens only if receiver is a largeinteger, since
		these messages are overridden in SmallInteger"
	self error: 'Attempt to do external data operations on a LargeInteger'! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'proxy operations' !
hasBitsSet: mask <ExternalData> ^<Boolean>

	"this happens only if receiver is a largeinteger, since
		these messages are overridden in SmallInteger"
	self error: 'Attempt to do external data operations on a LargeInteger'! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'restricted-double dispatching' !
addFromInteger: o <Integer> ^<Integer>

	^o + self asLargeInteger! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'restricted-double dispatching' !
addFromSmallInteger: o <SmallInteger> ^<Integer>
	"%generated code- do not modify"
	^self addFromInteger: o! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'restricted-double dispatching' !
bitAndFromInteger: arg <Integer>

	self unimplemented! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'restricted-double dispatching' !
bitOrFromInteger: arg <Integer>

	self unimplemented! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'restricted-double dispatching' !
equalFromInteger: o <Integer> ^<Boolean>

	^o = self asLargeInteger! !

"December 6, 2009 -> 18:26:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'restricted-double dispatching' !
equalFromSmallInteger: o <SmallInteger> ^<Boolean>
	"%generated code- do not modify"
	^self equalFromInteger: o! !

"December 6, 2009 -> 18:26:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'restricted-double dispatching' !
lessFromInteger: o <Integer> ^<Boolean>

	^o < self asLargeInteger! !

"December 6, 2009 -> 18:26:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'restricted-double dispatching' !
lessFromSmallInteger: o <SmallInteger> ^<Boolean>
	"%generated code- do not modify"
	^self lessFromInteger: o! !

"December 6, 2009 -> 18:26:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'restricted-double dispatching' !
moduloFromInteger: o <Integer> ^<Integer>

	| tmp <Int> |
	tmp :=  self asLargeInteger.
	^o - ((o // tmp) * tmp)! !

"December 6, 2009 -> 18:26:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'restricted-double dispatching' !
moduloFromSmallInteger: o <SmallInteger> ^<Integer>
	"%generated code- do not modify"
	^o \\ self! !

"December 6, 2009 -> 18:26:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'restricted-double dispatching' !
multiplyFromInteger: o <Integer> ^<Integer>

	^o * self asLargeInteger! !

"December 6, 2009 -> 18:26:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'restricted-double dispatching' !
multiplyFromSmallInteger: o <SmallInteger> ^<Integer>
	"%generated code- do not modify"
	^self multiplyFromInteger: o! !

"December 6, 2009 -> 18:26:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'restricted-double dispatching' !
remFromInteger: o <Integer> ^<Integer>

	self unimplemented! !

"December 6, 2009 -> 18:26:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'restricted-double dispatching' !
subtractFromInteger: o <Integer> ^<Integer>

	^o - self asLargeInteger! !

"December 6, 2009 -> 18:26:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'restricted-double dispatching' !
subtractFromSmallInteger: o <SmallInteger> ^<Integer>
	"%generated code- do not modify"
	^self subtractFromInteger: o! !

"December 6, 2009 -> 18:26:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'restricted-to integers' !
printNonNegativeOn: strm <CharOutputStream> radix: radix <Int>
	"Like printOn:radix:, but assumes the receiver is nonnegative"

	| digit <Int> |
	self >= radix
		ifTrue: [	(self // radix) printNonNegativeOn: strm radix: radix.
						digit := self \\ radix. ]
		ifFalse: [ digit := self ].
	strm put: (Character digitValue: digit).! !

"December 6, 2009 -> 18:26:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'restricted-to large integers' !
asLargeInteger ^<LargeInteger>
	"This message must ONLY be sent by large integers to construct a temporary large integer
		during mixed-mode integer operations.  The result of this message must NEVER be
		used by other code, since large integers that can be encoded as SmallIntegers
		are never supposed to exist outside the large integer class"

	self subclassResponsibility! !

"December 6, 2009 -> 18:26:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'truncation and rounding' !
rounded ^<Int>

	^self! !

"December 6, 2009 -> 18:27:1"!

Delta define: #SmallInteger as: (
(Class subclassOf: 'Integer' instanceVariables: '') classVariables: 'MinVal <Integer>
		MaxVal <Integer>
		') !


"December 6, 2009 -> 18:27:1"!

Delta define: #SmallInteger as: (
(Class subclassOf: 'Integer' instanceVariables: '') classVariables: 'MinVal <Integer>
		MaxVal <Integer>
		') !


"December 6, 2009 -> 18:27:1"!

Delta define: #SmallInteger as: (
(Class subclassOf: 'Integer' instanceVariables: '') classVariables: 'MinVal <Integer>
		MaxVal <Integer>
		') !


"December 6, 2009 -> 18:27:1"!

Delta define: #SmallInteger as: (
(Class subclassOf: 'Integer' instanceVariables: '') classVariables: 'MinVal <Integer>
		MaxVal <Integer>
		') !


"December 6, 2009 -> 18:27:1"!

Delta define: #SmallInteger as: (
(Class subclassOf: 'Integer' instanceVariables: '') classVariables: 'MinVal <Integer>
		MaxVal <Integer>
		') !


"December 6, 2009 -> 18:27:1"!

Delta define: #SmallInteger as: (
(Class subclassOf: 'Integer' instanceVariables: '') classVariables: 'MinVal <Integer>
		MaxVal <Integer>
		') !


"December 6, 2009 -> 18:27:1"!

Delta define: #SmallInteger as: (
(Class subclassOf: 'Integer' instanceVariables: '') classVariables: 'MinVal <Integer>
		MaxVal <Integer>
		') !


"December 6, 2009 -> 18:27:1"!

Delta define: #SmallInteger as: (
(Class subclassOf: 'Integer' instanceVariables: '') classVariables: 'MinVal <Integer>
		MaxVal <Integer>
		') !


"December 6, 2009 -> 18:27:1"!

Delta define: #SmallInteger as: (
(Class subclassOf: 'Integer' instanceVariables: '') classVariables: 'MinVal <Integer>
		MaxVal <Integer>
		') !


"December 6, 2009 -> 18:27:1"!

Delta define: #SmallInteger as: (
(Class subclassOf: 'Integer' instanceVariables: '') classVariables: 'MinVal <Integer>
		MaxVal <Integer>
		') !


"December 6, 2009 -> 18:27:1"!

Delta define: #SmallInteger as: (
(Class subclassOf: 'Integer' instanceVariables: '') classVariables: 'MinVal <Integer>
		MaxVal <Integer>
		') !


"December 6, 2009 -> 18:27:1"!

(Delta mirrorFor: #SmallInteger)
comment: 
'Implements limited precision integer arithmetic, overflowing into
infinite precision arithmetic.  This class should normally not be
referred to directly by user code.

Tags: %BlueBook

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.9 $
'!


"December 6, 2009 -> 18:27:1"!

! (Delta mirrorFor: #SmallInteger) classSide methodsFor: 'constants' !
maxVal ^<Integer>

	^MaxVal! !

"December 6, 2009 -> 18:27:1"!

! (Delta mirrorFor: #SmallInteger) classSide methodsFor: 'constants' !
minVal ^<Integer>

	^MinVal! !

"December 6, 2009 -> 18:27:1"!

! (Delta mirrorFor: #SmallInteger) classSide methodsFor: 'file out' !
fileOutSignature ^<Integer>
    ^66! !

"December 6, 2009 -> 18:27:1"!

! (Delta mirrorFor: #SmallInteger) classSide methodsFor: 'initialization' !
initialize

	MaxVal := self computedMaxVal.
	MinVal := MaxVal negated - 1.! !

"December 6, 2009 -> 18:27:1"!

! (Delta mirrorFor: #SmallInteger) classSide methodsFor: 'instance creation' !
primitiveNew ^<Instance>

	self shouldNotImplement! !

"December 6, 2009 -> 18:27:1"!

! (Delta mirrorFor: #SmallInteger) classSide methodsFor: 'private' !
computedMaxVal ^<SmallInteger>

	| v <SmallInt> |
	v := 3.
	[	| newV <SmallInt> |
		newV := v times: 2 ifFail: [ ^v ].
		v := newV +!! 1.	"Set the low bit"
		] repeat! !

"December 6, 2009 -> 18:27:1"!

! (Delta mirrorFor: #SmallInteger) classSide methodsFor: 'testing' !
test

	| r <Random> |
	r := Random new.
	-10000 to: 10000 do:
		[ :i <Int> |
			| strm <CharReadWriteStream> ps <Str> norm <Str> |
			strm := (String new: 5) writeStream.
			i printOn: strm.
			ps := i printString.
			norm := strm contentsWritten.
			[ ps = strm contentsWritten ] verify.
		].! !

"December 6, 2009 -> 18:27:1"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'accessing' !
identityHash ^<Int>

	^self! !

"December 6, 2009 -> 18:27:1"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'bit operations' !
bitAnd: o <X> ^<Self|X>
		{where X <Integer> is arg 1}

	^guaranteed <Self|X>
		{{self primitiveBitAnd: o ifFail: [ :err <Symbol> |  super bitAnd: o ]}}! !

"December 6, 2009 -> 18:27:1"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'bit operations' !
bitOr: o <X> ^<Self|X>
		{where X <Integer> is arg 1}

	^guaranteed <Self|X>
		{{self primitiveBitOr: o ifFail: [ :err <Symbol> |  super bitOr: o ]}}! !

"December 6, 2009 -> 18:27:1"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'bit operations' !
bitShift: numBits <Int> ^<Int>

	^{{self primitiveBitShift: numBits
		ifFail: [ :err <Symbol> | super bitShift: numBits ]}}! !

"December 6, 2009 -> 18:27:1"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'bit operations' !
bitXor: o <X> ^<Self|X>
		{where X <Integer> is arg 1}

	^guaranteed <Self|X>
		{{self primitiveBitXor: o ifFail: [ :err <Symbol> |  super bitOr: o ]}}! !

"December 6, 2009 -> 18:27:1"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'bit operations' !
rawBitShift: numBits <Int> ^<Int>

	^{{self primitiveRawBitShift: numBits
		ifFail: [ :err <Symbol> | super rawBitShift: numBits ]}}! !

"December 6, 2009 -> 18:27:1"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'bit operations-un-mixed-mode' !
bareBitShift: numBits <SmallInt> ^<SmallInt>
	"Like bitShift:, but drops bits off the high end if needed
	 rather than overflow into a large integer."

	^{{self primitiveBitShift: numBits
		ifFail: [ :err <Symbol> | self error: 'SmallInteger bareBitShift: ', err  ]}}! !

"December 6, 2009 -> 18:27:1"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'comparison' !
< a <Number> ^<Boolean>

	^{{self primitiveLessThan: a
		ifFail: [ :err <Symbol> |
				a lessFromSmallInteger: self	]}}! !

"December 6, 2009 -> 18:27:1"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'comparison' !
<= a <Number> ^<Boolean>

	^{{self primitiveLessThanOrEqual: a
		ifFail: [ :err <Symbol> | super <= a	]}}! !

"December 6, 2009 -> 18:27:1"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'comparison' !
= a <Object> ^<Boolean>

	^{{self primitiveSmallIntegerEqual: a 
		ifFail: [ :err <Symbol> |
						self nonPrimitiveEqual: a ]}}! !

"December 6, 2009 -> 18:27:1"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'comparison' !
> a <Number> ^<Boolean>

	^{{self primitiveGreaterThan: a
		ifFail: [ :err <Symbol> | super > a	]}}! !

"December 6, 2009 -> 18:27:1"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'comparison' !
>= a <Number> ^<Boolean>

	^{{self primitiveGreaterThanOrEqual: a
		ifFail: [ :err <Symbol> | super >= a	]}}! !

"December 6, 2009 -> 18:27:1"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'comparison' !
@= other <ExternalData> ^<Boolean>
	"Compares two ExternalData objects to each other.  This will coerce between integers and proxies
	  as needed"

	^{{self primitiveSmallIntegerEqual: other 
		ifFail: [ :err <Symbol> |
						err = #FirstArgumentHasWrongType
							ifTrue: [ other = self asExternalProxy ]
							ifFalse: [ self error: err ]  ] }}! !

"December 6, 2009 -> 18:27:1"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'comparison' !
~= a <Object> ^<Boolean>

	^{{self primitiveSmallIntegerNotEqual: a 
		ifFail: [ :err <Symbol> | super ~= a ]}}! !

"December 6, 2009 -> 18:27:1"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'converting' !
asFloat ^<Float>

	^{{self primitiveAsFloat}}! !

"December 6, 2009 -> 18:27:1"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'converting' !
asSmallInteger ^<SmallInt>

	^self! !

"December 6, 2009 -> 18:27:1"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'debugging' !
asObject ^<Object>
	"Returns the object in object id table at index 'self'"
	
	^{{self primitiveAsObjectIfFail: [ :err <Symbol> | self error: err]}}! !

"December 6, 2009 -> 18:27:1"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'file out' !
fileOutOn:  d <Dumper>
    self >= 0 ifTrue: [
		d putByte: 48.
		d putInteger: self.
    ] ifFalse: [
		d putByte: 45.
		d putInteger: self abs.
    ]! !

"December 6, 2009 -> 18:27:1"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'operations' !
* a <Number> ^<X>
			{where X <Number> is returnType of #multiplyFromSmallInteger: message of arg 1}
	^guaranteed <X> {{self primitiveMultiply: a
		ifFail: [ :err <Symbol> |
				self nonPrimitiveMultiply: a error: err ]}}! !

"December 6, 2009 -> 18:27:1"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'operations' !
+ a <Number> ^<X>
			{where X <Number> is returnType of #addFromSmallInteger: message of arg 1}
	^guaranteed <X> {{self primitiveAdd: a
		ifFail: [ :err <Symbol> |
				self nonPrimitiveAdd: a error: err ]}}! !

"December 6, 2009 -> 18:27:2"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'operations' !
- a <Number> ^<X>
			{where X <Number> is returnType of #subtractFromSmallInteger: message of arg 1}
	^guaranteed <X> {{self primitiveSubtract: a
		ifFail: [ :err <Symbol> |
				self nonPrimitiveSubtract: a error: err ]}}! !

"December 6, 2009 -> 18:27:2"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'operations' !
/ a <Number> ^<X>
			{where X <Number> is returnType of #divideFromSmallInteger: message of arg 1}
	"%generated code- do not modify"
	^guaranteed <X> (a divideFromSmallInteger: self)! !

"December 6, 2009 -> 18:27:2"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'operations' !
// arg <Number> ^<Int>
	"The integer quotient of self / arg, with truncation towards negative infinity"

	^{{self primitiveDiv: arg
		ifFail: [ :err <Symbol> |
				self nonPrimitiveDiv: arg error: err	]}}! !

"December 6, 2009 -> 18:27:2"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'operations' !
\\ a <Number> ^<X>
			{where X <Number> is returnType of #moduloFromSmallInteger: message of arg 1}
	^guaranteed <X> {{self primitiveMod: a
		ifFail: [ :err <Symbol> |
				self nonPrimitiveModulo: a error: err ]}}! !

"December 6, 2009 -> 18:27:2"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'operations' !
quo: arg <Number> ^<Int>

	^{{self primitiveQuo: arg
		ifFail: [ :err <Symbol> |
				self nonPrimitiveQuo: arg error: err	]}}! !

"December 6, 2009 -> 18:27:2"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'operations-un-mixed-mode' !
*!! a <SmallInt> ^<SmallInt>
	"un-mixed-mode multiplication.  This causes a runtime error on overflow or underflow.  If it returns, you are guaranteed that the
	  result is a SmallInteger."
	^guaranteed <X> {{self primitiveMultiply: a
		ifFail: [ :err <Symbol> |
				self error: 'SmallInteger un-mixed-mode multiplication: ', err ]	}}! !

"December 6, 2009 -> 18:27:2"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'operations-un-mixed-mode' !
+!! a <SmallInt> ^<SmallInt>
	"un-mixed-mode addition.  This causes a runtime error on overflow or underflow.  If it returns, you are guaranteed that the
	  result is a SmallInteger."
	^guaranteed <X> {{self primitiveAdd: a
		ifFail: [ :err <Symbol> |
				self error: 'SmallInteger un-mixed-mode addition: ', err ]	}}! !

"December 6, 2009 -> 18:27:2"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'operations-un-mixed-mode' !
-!! a <SmallInt> ^<SmallInt>
	"un-mixed-mode subtraction.  This causes a runtime error on overflow or underflow.  If it returns, you are guaranteed that the
	  result is a SmallInteger."
	^guaranteed <X> {{self primitiveSubtract: a
		ifFail: [ :err <Symbol> |
				self error: 'SmallInteger un-mixed-mode subtraction: ', err ]	}}! !

"December 6, 2009 -> 18:27:2"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'operations-un-mixed-mode' !
/!! a <SmallInt> ^<SmallInt>
	"un-mixed-mode integer division.  This causes a runtime error on overflow or underflow.  If it returns, you are guaranteed that the
	  result is a SmallInteger."
	^guaranteed <X> {{self primitiveDiv: a
		ifFail: [ :err <Symbol> |
				self error: 'SmallInteger un-mixed-mode division: ', err ]	}}! !

"December 6, 2009 -> 18:27:2"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'operations-un-mixed-mode' !
\!! a <SmallInt> ^<SmallInt>
	"un-mixed-mode integer modulo.  This causes a runtime error on overflow or underflow.  If it returns, you are guaranteed that the
	  result is a SmallInteger."
	^guaranteed <X> {{self primitiveMod: a
		ifFail: [ :err <Symbol> |
				self error: 'SmallInteger un-mixed-mode modulo: ', err ]	}}! !

"December 6, 2009 -> 18:27:2"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'operations-un-mixed-mode' !
times: a <SmallInt> ifFail: f <[^X def]> ^<SmallInt | X>
	"un-mixed-mode multiplication with a failure block executed on overflow or underflow."

	^{{self primitiveMultiply: a
		ifFail: [ :err <Symbol> |
						err = #SmallIntegerOverflow
								ifTrue: [ f value ]
								ifFalse: [ self error: err ] 		]}}! !

"December 6, 2009 -> 18:27:2"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'patch' !
printCharacter
	"%remove when TempTranscript gone"

    {{self primitivePrintCharacterIfFail: [:err <Symbol> | self error: err ]}}
! !

"December 6, 2009 -> 18:27:2"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'printing' !
printString ^<Str>

	| digits <Int> abs <Int> s <String> zeroCode <Int> i <Int> |
	self negative
		ifTrue: [	abs := self negated. ]
		ifFalse: [	abs := self. ].
	digits := self digitsForAbs: abs.

	abs == self
		ifFalse: [	i := 1.
						digits := digits + 1.
						s := String new: digits.
						s at: 1 put: $-.
						]
		ifTrue: [	i := 0.
						s := String new: digits. ].

	zeroCode := $0 unicodeValue.
	[	s at: digits putUnicode: zeroCode + (abs \\ 10).
		digits := digits - 1.
		digits > i
		]	whileTrue: [ abs := abs // 10 ].
	^s! !

"December 6, 2009 -> 18:27:2"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'private' !
digitsForAbs: v <Int> ^<Int>

	v < 10
		ifTrue: [ ^1 ].
	v < 100
		ifTrue: [ ^2 ].
	v < 1000
		ifTrue: [ ^3 ].
	v < 10000
		ifTrue: [ ^4 ].
	v < 100000
		ifTrue: [ ^5 ].
	v < 1000000
		ifTrue: [ ^6 ].
	v < 10000000
		ifTrue: [ ^7 ].
	v < (10000*10000)			"v < 100000000"		"cannot parse this bootstrapped"
		ifTrue: [ ^8 ].
	v < (100000*10000)		"v < 1000000000"	"cannot parse this bootstrapped"
		ifTrue: [ ^9 ].
	^10	"Smallintegers can't be any bigger"! !

"December 6, 2009 -> 18:27:2"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'private' !
nonPrimitiveAdd: a <Number> error: err <Symbol> ^<Number>
	"This is invoked on primitive failure"

	^err == #FirstArgumentHasWrongType
			ifTrue: [  a addFromSmallInteger: self ]
			ifFalse: [ err == #SmallIntegerOverflow 
								ifTrue:  [ a addFromInteger: self ]
								ifFalse: [ self error: 'SmallInteger addition: ', err]	]! !

"December 6, 2009 -> 18:27:2"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'private' !
nonPrimitiveDiv: a <Number> error: err <Symbol> ^<Int>
	"This is invoked on primitive failure"

	^err == #FirstArgumentHasWrongType
			ifTrue: [ super // a ]
			ifFalse: [ self error: 'SmallInteger //: ', err ]! !

"December 6, 2009 -> 18:27:2"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'private' !
nonPrimitiveEqual: a <Object> ^<Boolean>
	"This is invoked on primitive equality failure"

"%todo: use this typesafe version when coerce: is fast
	^(Number coerce: a else: [ ^false ]) equalFromFloat: self
"
	^a Number
		ifTrue: [ (guaranteed <Number> a) equalFromSmallInteger: self ]
		ifFalse: [ false ]


! !

"December 6, 2009 -> 18:27:2"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'private' !
nonPrimitiveModulo: a <Number> error: err <Symbol> ^<Number>
	"This is invoked on primitive failure"

	^err == #FirstArgumentHasWrongType
					ifTrue: [ a moduloFromSmallInteger: self ]
					ifFalse: [ err == #SmallIntegerOverflow
							ifTrue: [ "The guarantee is typesafe because the primitive verified
												it"
											self moduloFromInteger: (guaranteed <Integer> a) ]
							ifFalse: [ self error: 'SmallInteger modulo: ', err ]	]! !

"December 6, 2009 -> 18:27:2"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'private' !
nonPrimitiveMultiply: a <Number> error: err <Symbol> ^<Number>
	"This is invoked on primitive failure"

	^err == #FirstArgumentHasWrongType
		ifTrue: [  a multiplyFromSmallInteger: self ]
		ifFalse: [ err == #SmallIntegerOverflow 
							ifTrue:  [ a multiplyFromInteger: self ]
							ifFalse: [ self error: 'SmallInteger multiply: ', err]	]! !

"December 6, 2009 -> 18:27:2"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'private' !
nonPrimitiveQuo: a <Number> error: err <Symbol> ^<Int>
	"This is invoked on primitive failure"

	^err == #FirstArgumentHasWrongType
			ifTrue: [ super quo: a ]
			ifFalse: [ self error: 'SmallInteger quo: ', err ]! !

"December 6, 2009 -> 18:27:2"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'private' !
nonPrimitiveSubtract: a <Number> error: err <Symbol> ^<Number>
	"This is invoked on primitive subtraction failure"

	^err == #FirstArgumentHasWrongType
		ifTrue: [  a subtractFromSmallInteger: self ]
		ifFalse: [ err == #SmallIntegerOverflow 
							ifTrue:  [ a subtractFromInteger: self ]
							ifFalse: [ self error: 'SmallInteger subtraction: ', err]	]! !

"December 6, 2009 -> 18:27:2"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'private-proxy double dispatching' !
bitAndFromProxy: other <ExternalProxy> ^<ExternalProxy>

	^other bitAndFromProxy: self asExternalProxy! !

"December 6, 2009 -> 18:27:2"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'private-proxy double dispatching' !
bitOrFromProxy: other <ExternalProxy> ^<ExternalProxy>

	^other bitOrFromProxy: self asExternalProxy! !

"December 6, 2009 -> 18:27:2"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'proxy operations' !
externalBitAnd: other <ExternalData> ^<ExternalData>

	^other bitAndFromSmallInteger: self! !

"December 6, 2009 -> 18:27:2"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'proxy operations' !
externalBitOr: other <ExternalData> ^<ExternalData>

	^other bitOrFromSmallInteger: self! !

"December 6, 2009 -> 18:27:2"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'proxy operations' !
hasBitsSet: mask <ExternalData> ^<Boolean>

	^(self externalBitAnd: mask) @= mask! !

"December 6, 2009 -> 18:27:2"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'restricted-double dispatching' !
addFromSmallInteger: o <SmallInteger> ^<Int>
	self error: 'can''t happen because of double dispatching, but need for typing'! !

"December 6, 2009 -> 18:27:2"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'restricted-double dispatching' !
bitAndFromInteger: arg <Integer> ^ <Integer>

	^arg bitAnd: self asLargeInteger! !

"December 6, 2009 -> 18:27:2"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'restricted-double dispatching' !
bitOrFromInteger: arg <Integer> ^ <Integer>

	^arg bitOr: self asLargeInteger! !

"December 6, 2009 -> 18:27:2"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'restricted-double dispatching' !
bitXorFromInteger: arg <Integer> ^ <Integer>

	^arg bitXor: self asLargeInteger! !

"December 6, 2009 -> 18:27:2"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'restricted-double dispatching' !
equalFromSmallInteger: o <SmallInteger> ^<Boolean>
	self error: 'can''t happen because of double dispatching'! !

"December 6, 2009 -> 18:27:2"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'restricted-double dispatching' !
lessFromSmallInteger: o <SmallInteger> ^<Boolean>
	self error: 'can''t happen because of double dispatching'! !

"December 6, 2009 -> 18:27:2"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'restricted-double dispatching' !
moduloFromSmallInteger: o <SmallInteger> ^<SmallInteger>
	self error: 'can''t happen because of double dispatching'! !

"December 6, 2009 -> 18:27:2"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'restricted-double dispatching' !
multiplyFromSmallInteger: o <SmallInteger> ^<Int>
	self error: 'can''t happen because of double dispatching, but need for typing'! !

"December 6, 2009 -> 18:27:2"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'restricted-double dispatching' !
subtractFromSmallInteger: o <SmallInteger> ^<Int>
	self error: 'can''t happen because of double dispatching, but need for typing'! !

"December 6, 2009 -> 18:27:2"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'restricted-to large integers' !
asLargeInteger ^<LargeInteger>

	^LargeInteger forSmallInteger: self! !

"December 6, 2009 -> 18:28:30"!

Delta define: #Number as: (
(Class subclassOf: 'Magnitude[Number] mixin |> Object' instanceVariables: '') abstract) !


"December 6, 2009 -> 18:28:30"!

Delta define: #Number as: (
(Class subclassOf: 'Magnitude[Number] mixin |> Object' instanceVariables: '') abstract) !


"December 6, 2009 -> 18:28:30"!

Delta define: #Number as: (
(Class subclassOf: 'Magnitude[Number] mixin |> Object' instanceVariables: '') abstract) !


"December 6, 2009 -> 18:28:30"!

Delta define: #Number as: (
(Class subclassOf: 'Magnitude[Number] mixin |> Object' instanceVariables: '') abstract) !


"December 6, 2009 -> 18:28:30"!

Delta define: #Number as: (
(Class subclassOf: 'Magnitude[Number] mixin |> Object' instanceVariables: '') abstract) !


"December 6, 2009 -> 18:28:30"!

Delta define: #Number as: (
(Class subclassOf: 'Magnitude[Number] mixin |> Object' instanceVariables: '') abstract) !


"December 6, 2009 -> 18:28:30"!

Delta define: #Number as: (
(Class subclassOf: 'Magnitude[Number] mixin |> Object' instanceVariables: '') abstract) !


"December 6, 2009 -> 18:28:30"!

Delta define: #Number as: (
(Class subclassOf: 'Magnitude[Number] mixin |> Object' instanceVariables: '') abstract) !


"December 6, 2009 -> 18:28:30"!

Delta define: #Number as: (
(Class subclassOf: 'Magnitude[Number] mixin |> Object' instanceVariables: '') abstract) !


"December 6, 2009 -> 18:28:30"!

Delta define: #Number as: (
(Class subclassOf: 'Magnitude[Number] mixin |> Object' instanceVariables: '') abstract) !


"December 6, 2009 -> 18:28:30"!

Delta define: #Number as: (
(Class subclassOf: 'Magnitude[Number] mixin |> Object' instanceVariables: '') abstract) !


"December 6, 2009 -> 18:28:30"!

(Delta mirrorFor: #Number)
comment: 
'Tags: %BlueBook %User

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.3 $
'!


"December 6, 2009 -> 18:28:30"!

! (Delta mirrorFor: #Number) classSide methodsFor: 'instance creation' !
new ^<Instance>

	self shouldNotImplement! !

"December 6, 2009 -> 18:28:30"!

! (Delta mirrorFor: #Number) classSide methodsFor: 'testing' !
test
	"self test"

	self	testEquals;
		testRelationals;
		testArithmetic.! !

"December 6, 2009 -> 18:28:30"!

! (Delta mirrorFor: #Number) classSide methodsFor: 'testing' !
testArithmetic
	"self testArithmetic"
	| eps <Float> |
	eps := 0.00000001.
	
		"+"
		[ 3+3 = 6 ] verify. [ 1+(2/3) = (5/3) ] verify. [ 1 + 2.0 isWithin: eps of: 3.0 ] verify.
		[ 3.0 + 3.0 isWithin: eps of:  6.0 ] verify. [ 1.0 + (2/3) isWithin: eps of: 5/3 ] verify. [ 1.0 + 2 isWithin: eps of: 3.0] verify.
		[ (1/3 + 1/6) = (2/9) ] verify. [ 2/3 + (1 asFloat/ 3 asFloat) isWithin: eps of: 1 ] verify.

		"-"
		[ 3-1 = 2 ] verify. [ 1-(2/3) = (1/3) ] verify. [ 1 - 2.0 isWithin: eps of: -1.0 ] verify.
		[ 3.0 - 2.0 isWithin: eps of:  1.0 ] verify. [ 1.0 - (2/3) isWithin: eps of: 1/3 ] verify. [ 1.0 - 2 isWithin: eps of: -1.0] verify.
		[ (1/3 - 1/6) = (-1/9) ] verify. [ 4/3 - (1 asFloat/ 3 asFloat) isWithin: eps of: 1 ] verify.

		"*"
		[ 2*3 = 6 ] verify. [ 2*3.0 isWithin: eps of: 6.0 ] verify. [ 3*(1/3) = 1 ] verify.
		[ 2.0 *3.0 isWithin: eps of: 6.0 ] verify. [ 2.0*(1/2) isWithin: eps of: 1 ] verify. [ 2.0 * 3 isWithin: eps of: 6 ] verify.
		[ 2/3 * (1/3) = (2/9) ] verify. [ 2/3 * (1 asFloat / 3 asFloat) isWithin: eps of: 2/9 ] verify. [ 2/3 * 2 = (4/3) ] verify.

		"/"
		[ 6/3 = 2 ] verify. [ 6/3.0 isWithin: eps of: 2 ] verify. [ 3/(1/3) = 9 ] verify.
		[ 6.0 / 2 isWithin: eps of: 3 ] verify. [ 6.0 / 2.0 isWithin: eps of: 3 ] verify. [ 6.0 / (1/3) isWithin: eps of: 18 ] verify. 
		[ 2/3/(1/2) = (4/3) ] verify. [ 2/3/0.5 isWithin: eps of: 4/3 ] verify. [ 2/3/2 = (1/3) ] verify.

		"//"
		[ 7 // 2 = 3 ] verify. [ 7 // 2.0 isWithin: eps of: 3 ] verify. [ 7 // (1/2) = 14 ] verify. [ -7 // 2 = -4 ] verify.
		[ 7.0 // 2.0 = 3 ] verify. [ 7.0 // 2 isWithin: eps of: 3 ] verify. [ 7.0 // (1/2) = 14 ] verify. [ -7.0 // 2 = -4 ] verify.
		[ 7/3 // (2/3) = 3 ] verify. [  -7/3 // (2/3) = -4 ] verify.

		"\\"
		[ 7 \\ 2 = 1 ] verify. [ 7 \\ 2.0 isWithin: eps of: 1 ] verify. [ (7+ 1/3) \\ (1/2) = (1/6) ] verify. [ -7 \\ 2 = 1 ] verify.
		[ 7.0 \\ 2.0 isWithin: eps of: 1.0 ] verify.
		[ 7.0 \\ 2 isWithin: eps of: 1 ] verify.
		[ (7.0 + (1/3) asFloat) \\ (1/2) isWithin: eps of: 1/3 ] verify.
		[ -7.0 \\ 2 isWithin: eps of: 1 ] verify.
		[ 7/3 \\ (2/3) = (1/3) ] verify. [  -7/3 \\ (2/3) = (1/3) ] verify.
! !

"December 6, 2009 -> 18:28:30"!

! (Delta mirrorFor: #Number) classSide methodsFor: 'testing' !
testEquals
	"self testEquals"

	"=, ~="
	[ 123 == 123 ] verify. [ (-2 == -3) not ] verify.
	[ 123 = 123 ] verify. [ 123 ~= -123 ] verify.
	[ 123 = (246/2) ] verify. [ 123 ~= (246/3) ] verify.
	[ 123 = 123.0 ] verify. [ 123 ~= 123.1 ] verify.

	[ 123.0 = 123.0 ] verify. [ 123.0 ~= 123.4 ] verify.
	[ 123.0 = 123 ] verify. [ 123.0 ~= 124 ] verify.
	[ 0.5 = (1/2) ] verify. [ -0.5 = (1/-2) ] verify. [ 0.5 ~= (1/3) ] verify.

	[ (3/4) = (6/8) ] verify. [ (3/4) ~= (1/4) ] verify.
	[ (1/3) = (1.0 / 3.0) ] verify. [ (1/3) ~= 0.33333 ] verify.
	[ (2/3) * 3 = 2 ] verify.
	[ (-10/-5) = 2 ] verify. [ (-10/5) = -2 ] verify. [ (10/-5) = -2 ] verify.

! !

"December 6, 2009 -> 18:28:31"!

! (Delta mirrorFor: #Number) classSide methodsFor: 'testing' !
testRelationals
	"self testRelationals"

	"<"
	[ 123 < 125 ] verify. [ (123 < 122) not ] verify.
	[ 123 < 124.0 ] verify. [ (123 < 122.0) not ] verify.
	[ 2 < (11/5) ] verify. [ (2 < (9/5)) not ] verify.

	[ 123.0 < 124.0 ] verify. 
	[ 123.0 < 124 ] verify.
	[ 2.0 < (11/5) ] verify.

	[ (11/5) < (12/5) ] verify. [ ((11/5) < (9/5)) not ] verify. [ (9/5) < (10/5) ] verify.
	[ ((11/5) < (11/5)) not ] verify.
	[ (-4/5) < 0 ] verify. [ (4/-5) < (-3/5) ] verify. [ (2/3) < (-4/-3) ] verify.
	[ 2/3 < 1 ] verify. [ (4/3 < 1) not ] verify.
	[ 2/3 < 1.0 ] verify. [ (4/3 < 1.0) not ] verify.

	">"
	[ 123 > 122 ] verify. [ (121 > 122) not ] verify.
	[ 123 > 122.0 ] verify. [ (123 > 124.0) not ] verify.
	[ 2 > (9/5) ] verify. [ (2 > (11/5)) not ] verify.

	[ 124.0 > 123.0 ] verify. 
	[ 124.0 > 123 ] verify.
	[ 2.0 > (9/5) ] verify.

	[ (12/5) > (11/5) ] verify. [ ((9/5) > (11/5)) not ] verify. [ (10/5) > (9/5) ] verify.
	[ ((11/5) > (11/5)) not ] verify.
	[ (-4/5) > -1 ] verify. [ (3/-5) > (-4/5) ] verify. [ (4/3) > (-2/-3) ] verify.
	[ 2/3 > 0 ] verify. [ (4/3 > 2) not ] verify.
	[ 2/3 > 0.0 ] verify. [ (4/3 > 2.0) not ] verify.

	"<="
	[ 1 <= 2 ] verify. [ 2 <= 2 ] verify. [ (2 <= 1)not ] verify.
	[ 1.0 <= 2.0 ] verify. [ 2.0 <= 2.0 ] verify. [ (2.0 <= 1.0)not ] verify.
	[ 0.666 <= (2/3) ] verify. [ (0.666 <= (1/3) ) not ] verify.

	">="
	[ 1 >= 0 ] verify. [ (1 >= 2) not ] verify. [ 1 >= 1 ] verify.
	[ 1.0 >= 0.0 ] verify. [ (1.0 >= 2.0) not ] verify. [ 1.0 >= 1.0 ] verify.
	[ 0.66 >= (1/3)  ] verify. [ (0.66 >= (2/3)) not ] verify.
	[ (1/3) >= (1/3) ] verify. [ (2/3) >= (1/3) ] verify.

	">"
	[ 1 > 0 ] verify. [ (1 > 2) not ] verify. [ (1 > 1) not ] verify.
	[ 1.0 > 0.0 ] verify. [ (1.0 > 2.0) not ] verify. [ (1.0 > 1.0) not ] verify.
	[ 0.66 > (1/3)  ] verify. [ (0.66 > (2/3)) not ] verify.
	[ ((1/3) > (1/3)) not ] verify. [ (2/3) > (1/3) ] verify.

	"min:"
	[ (4 min: 5) = 4 ] verify. [ (5 min: 4) = 4 ] verify. [  (5 min: 4.0) = 4.0 ] verify. [ (1 min: 2/3)  = (2/3) ] verify.

	"max:"
	[ (5 max: 4) = 5 ] verify. [ (5 max: 4) = 5 ] verify. [  (5 max: 4.0) = 5 ] verify. [ (1 max: 4/3)  = (4/3) ] verify.

	"between:and:"
	[ 2 between: 1 and: 3 ] verify. [ 3 between: 3 and: 4 ] verify. [ (2 between: 3 and: 4) not ] verify.

! !

"December 6, 2009 -> 18:28:31"!

! (Delta mirrorFor: #Number) methodsFor: 'benchmarking' !
higherOf: aNumber <Number> ^<Number>
    ^(self min: aNumber)! !

"December 6, 2009 -> 18:28:31"!

! (Delta mirrorFor: #Number) methodsFor: 'benchmarking' !
isAbove: aNumber <Number> ^<Boolean>
    ^self < aNumber! !

"December 6, 2009 -> 18:28:31"!

! (Delta mirrorFor: #Number) methodsFor: 'benchmarking' !
isLeftOf: aNumber <Number> ^<Boolean>
    ^self < aNumber! !

"December 6, 2009 -> 18:28:31"!

! (Delta mirrorFor: #Number) methodsFor: 'benchmarking' !
leftMost: aNumber <Number> ^<Number>
    ^(self min: aNumber)! !

"December 6, 2009 -> 18:28:31"!

! (Delta mirrorFor: #Number) methodsFor: 'benchmarking' !
lowerOf: aNumber <Number> ^<Number>
    ^(self max: aNumber)! !

"December 6, 2009 -> 18:28:31"!

! (Delta mirrorFor: #Number) methodsFor: 'benchmarking' !
rightMost: aNumber <Number> ^<Number>
    ^(self max: aNumber)! !

"December 6, 2009 -> 18:28:31"!

! (Delta mirrorFor: #Number) methodsFor: 'constants' !
unit ^<Number>
	"The unit value, in whatever representation is appropriate for each subclass"

	self subclassResponsibility! !

"December 6, 2009 -> 18:28:31"!

! (Delta mirrorFor: #Number) methodsFor: 'constants' !
zero ^<Number>
	"zero, in whatever representation is appropriate for each subclass"

	self subclassResponsibility! !

"December 6, 2009 -> 18:28:31"!

! (Delta mirrorFor: #Number) methodsFor: 'converting' !
@ yval <Number>  ^<Point>
	"return a point with the receiver as x, and yval as y"

	^Point x: self y: yval! !

"December 6, 2009 -> 18:28:31"!

! (Delta mirrorFor: #Number) methodsFor: 'converting' !
asFloat ^<Float>

	self subclassResponsibility! !

"December 6, 2009 -> 18:28:31"!

! (Delta mirrorFor: #Number) methodsFor: 'converting' !
asInteger ^<Integer>

	self subclassResponsibility! !

"December 6, 2009 -> 18:28:31"!

! (Delta mirrorFor: #Number) methodsFor: 'converting' !
degreesToRadians ^<Number>

	self unimplemented! !

"December 6, 2009 -> 18:28:31"!

! (Delta mirrorFor: #Number) methodsFor: 'converting' !
radiansToDegrees ^<Number>

	self unimplemented! !

"December 6, 2009 -> 18:28:31"!

! (Delta mirrorFor: #Number) methodsFor: 'copying' !
copy ^<Instance>
	^self! !

"December 6, 2009 -> 18:28:31"!

! (Delta mirrorFor: #Number) methodsFor: 'fake brands' !
Number ^<Boolean>

	^true! !

"December 6, 2009 -> 18:28:31"!

! (Delta mirrorFor: #Number) methodsFor: 'iteration' !
to: stop <Number> ^<Interval>

	^Interval from: self to: stop! !

"December 6, 2009 -> 18:28:31"!

! (Delta mirrorFor: #Number) methodsFor: 'iteration' !
to: stop <Number> by: step <Number> ^<Interval>

	^Interval from: self to: stop by: step! !

"December 6, 2009 -> 18:28:31"!

! (Delta mirrorFor: #Number) methodsFor: 'mathematical functions' !
arcCos ^<Number>

	self unimplemented! !

"December 6, 2009 -> 18:28:31"!

! (Delta mirrorFor: #Number) methodsFor: 'mathematical functions' !
arcSin ^<Number>

	self unimplemented! !

"December 6, 2009 -> 18:28:31"!

! (Delta mirrorFor: #Number) methodsFor: 'mathematical functions' !
arcTan ^<Number>

	self unimplemented! !

"December 6, 2009 -> 18:28:31"!

! (Delta mirrorFor: #Number) methodsFor: 'mathematical functions' !
cos ^<Number>

	self unimplemented! !

"December 6, 2009 -> 18:28:31"!

! (Delta mirrorFor: #Number) methodsFor: 'mathematical functions' !
exp ^<Number>
	self unimplemented! !

"December 6, 2009 -> 18:28:31"!

! (Delta mirrorFor: #Number) methodsFor: 'mathematical functions' !
floorLog: radix <Number> ^<Int>
	self unimplemented! !

"December 6, 2009 -> 18:28:31"!

! (Delta mirrorFor: #Number) methodsFor: 'mathematical functions' !
ln ^<Number>
	self unimplemented! !

"December 6, 2009 -> 18:28:31"!

! (Delta mirrorFor: #Number) methodsFor: 'mathematical functions' !
log: o <Number> ^<Number>
	self unimplemented! !

"December 6, 2009 -> 18:28:31"!

! (Delta mirrorFor: #Number) methodsFor: 'mathematical functions' !
raisedTo: power <Number> ^<Number>
	self unimplemented! !

"December 6, 2009 -> 18:28:31"!

! (Delta mirrorFor: #Number) methodsFor: 'mathematical functions' !
raisedToInteger: power <Int> ^<Number>
	self unimplemented! !

"December 6, 2009 -> 18:28:31"!

! (Delta mirrorFor: #Number) methodsFor: 'mathematical functions' !
sin ^<Number>

	self unimplemented! !

"December 6, 2009 -> 18:28:31"!

! (Delta mirrorFor: #Number) methodsFor: 'mathematical functions' !
sqrt ^<Number>
	
	^self asFloat sqrt! !

"December 6, 2009 -> 18:28:31"!

! (Delta mirrorFor: #Number) methodsFor: 'mathematical functions' !
tan ^<Number>

	self unimplemented! !

"December 6, 2009 -> 18:28:31"!

! (Delta mirrorFor: #Number) methodsFor: 'operations' !
* a <Number> ^<Number>
			{where X <Number> is arg 1}

	self subclassResponsibility! !

"December 6, 2009 -> 18:28:31"!

! (Delta mirrorFor: #Number) methodsFor: 'operations' !
+ a <Number> ^<Number>
			{where X <Number> is arg 1}

	self subclassResponsibility! !

"December 6, 2009 -> 18:28:31"!

! (Delta mirrorFor: #Number) methodsFor: 'operations' !
- a <Number> ^<Number>
			{where X <Number> is arg 1}

	self subclassResponsibility! !

"December 6, 2009 -> 18:28:31"!

! (Delta mirrorFor: #Number) methodsFor: 'operations' !
/ a <Number> ^<Number>
			{where X <Number> is arg 1}

	self subclassResponsibility! !

"December 6, 2009 -> 18:28:31"!

! (Delta mirrorFor: #Number) methodsFor: 'operations' !
// arg <Number> ^<Int>
	"Integer quotient with truncation towards negative infinity"

	^(self / arg) floor! !

"December 6, 2009 -> 18:28:31"!

! (Delta mirrorFor: #Number) methodsFor: 'operations' !
\\ a <Number> ^<Number>
			{where X <Number> is arg 1}
	"Modulo, implemented with truncation towards negative infinity"

	self subclassResponsibility! !

"December 6, 2009 -> 18:28:31"!

! (Delta mirrorFor: #Number) methodsFor: 'operations' !
abs ^<Number>

	^self < self zero
		ifTrue: [ self negated ]
		ifFalse: [ self ]! !

"December 6, 2009 -> 18:28:31"!

! (Delta mirrorFor: #Number) methodsFor: 'operations' !
isWithin: epsilon <Number> of: other <Number> ^<Boolean>
	"Test whether the 'distance' from the receiver to other is less than or equal to
	  epsilon. This is the right way to compare floating point numbers, or numbers in different
	  representations, for equality"

	^(self - other) abs <= epsilon! !

"December 6, 2009 -> 18:28:31"!

! (Delta mirrorFor: #Number) methodsFor: 'operations' !
negated ^<Number>

	^self zero - self! !

"December 6, 2009 -> 18:28:31"!

! (Delta mirrorFor: #Number) methodsFor: 'operations' !
quo: n <Number> ^<Int>
	"Integer quotient with truncation towards zero"

	^(self / n) truncated ! !

"December 6, 2009 -> 18:28:31"!

! (Delta mirrorFor: #Number) methodsFor: 'operations' !
reciprocol ^<Number>

	^self unit/self! !

"December 6, 2009 -> 18:28:31"!

! (Delta mirrorFor: #Number) methodsFor: 'operations' !
rem: n <Number> ^<Number>

	self unimplemented! !

"December 6, 2009 -> 18:28:31"!

! (Delta mirrorFor: #Number) methodsFor: 'operations' !
squared ^<Number>

	^self * self! !

"December 6, 2009 -> 18:28:32"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
addFromFloat: o <Float> ^<Number>
	"%generated code- do not modify"
	^self asFloat + o! !

"December 6, 2009 -> 18:28:32"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
addFromInteger: o <Integer> ^<Number>
	"%generated code- do not modify"
	^self + o asFloat! !

"December 6, 2009 -> 18:28:32"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
addFromRationalNumber: o <RationalNumber> ^<Number>
	"%generated code- do not modify"
	^self + o asFloat! !

"December 6, 2009 -> 18:28:32"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
addFromSmallInteger: o <SmallInteger> ^<Number>
	"%generated code- do not modify"
	^self + o asFloat! !

"December 6, 2009 -> 18:28:32"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
bitAndFromInteger: arg <Integer> ^ <Integer>

	^arg bitAnd: self asInteger! !

"December 6, 2009 -> 18:28:32"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
bitOrFromInteger: arg <Integer> ^ <Integer>

	^arg bitOr: self asInteger! !

"December 6, 2009 -> 18:28:32"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
bitXorFromInteger: arg <Integer> ^ <Integer>

	^arg bitXor: self asInteger! !

"December 6, 2009 -> 18:28:32"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
divideFromFloat: o <Float> ^<Number>
	"%generated code- do not modify"
	^o / self asFloat! !

"December 6, 2009 -> 18:28:32"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
divideFromInteger: o <Integer> ^<Number>
	"%generated code- do not modify"
	^o asFloat / self! !

"December 6, 2009 -> 18:28:32"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
divideFromRationalNumber: o <RationalNumber> ^<Number>
	"%generated code- do not modify"
	^o asFloat / self! !

"December 6, 2009 -> 18:28:32"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
divideFromSmallInteger: o <SmallInteger> ^<Number>
	"%generated code- do not modify"
	^o asFloat / self! !

"December 6, 2009 -> 18:28:32"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
equalFromFloat: o <Float> ^<Boolean>
	"%generated code- do not modify"
	^o = self asFloat! !

"December 6, 2009 -> 18:28:32"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
equalFromInteger: o <Integer> ^<Boolean>
	"%generated code- do not modify"
	^self = o asFloat! !

"December 6, 2009 -> 18:28:32"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
equalFromRationalNumber: o <RationalNumber> ^<Boolean>
	"%generated code- do not modify"
	^self = o asFloat! !

"December 6, 2009 -> 18:28:32"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
equalFromSmallInteger: o <SmallInteger> ^<Boolean>
	"%generated code- do not modify"
	^self = o asFloat! !

"December 6, 2009 -> 18:28:32"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
expandRect: r <Rect> ^<Rect>

	^Rectangle
		left: r left - self
		right: r right + self
		top: r top - self
		bottom: r bottom + self! !

"December 6, 2009 -> 18:28:32"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
insetRect: r <Rect> ^<Rect>

	^Rectangle
		left: r left + self
		right: r right - self
		top: r top + self
		bottom: r bottom - self! !

"December 6, 2009 -> 18:28:32"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
lessFromFloat: o <Float> ^<Boolean>
	"%generated code- do not modify"
	^o < self asFloat! !

"December 6, 2009 -> 18:28:32"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
lessFromInteger: o <Integer> ^<Boolean>
	"%generated code- do not modify"
	^o asFloat < self! !

"December 6, 2009 -> 18:28:32"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
lessFromRationalNumber: o <RationalNumber> ^<Boolean>
	"%generated code- do not modify"
	^o asFloat < self! !

"December 6, 2009 -> 18:28:32"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
lessFromSmallInteger: o <SmallInteger> ^<Boolean>
	"%generated code- do not modify"
	^o asFloat < self! !

"December 6, 2009 -> 18:28:32"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
moduloFromFloat: o <Float> ^<Number>
	"%generated code- do not modify"
	^o \\ self asFloat! !

"December 6, 2009 -> 18:28:32"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
moduloFromInteger: o <Integer> ^<Number>
	"%generated code- do not modify"
	^o asFloat \\ self! !

"December 6, 2009 -> 18:28:32"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
moduloFromRationalNumber: o <RationalNumber> ^<Number>
	"%generated code- do not modify"
	^o asFloat \\ self! !

"December 6, 2009 -> 18:28:32"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
moduloFromSmallInteger: o <SmallInteger> ^<Number>
	"%generated code- do not modify"
	^o asFloat \\ self! !

"December 6, 2009 -> 18:28:32"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
multiplyFromFloat: o <Float> ^<Number>
	"%generated code- do not modify"
	^self asFloat * o! !

"December 6, 2009 -> 18:28:32"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
multiplyFromInteger: o <Integer> ^<Number>
	"%generated code- do not modify"
	^self * o asFloat! !

"December 6, 2009 -> 18:28:32"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
multiplyFromRationalNumber: o <RationalNumber> ^<Number>
	"%generated code- do not modify"
	^self * o asFloat! !

"December 6, 2009 -> 18:28:32"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
multiplyFromSmallInteger: o <SmallInteger> ^<Number>
	"%generated code- do not modify"
	^self * o asFloat! !

"December 6, 2009 -> 18:28:32"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
subtractFromFloat: o <Float> ^<Number>
	"%generated code- do not modify"
	^o - self asFloat! !

"December 6, 2009 -> 18:28:32"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
subtractFromInteger: o <Integer> ^<Number>
	"%generated code- do not modify"
	^o asFloat - self! !

"December 6, 2009 -> 18:28:32"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
subtractFromRationalNumber: o <RationalNumber> ^<Number>
	"%generated code- do not modify"
	^o asFloat - self! !

"December 6, 2009 -> 18:28:32"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
subtractFromSmallInteger: o <SmallInteger> ^<Number>
	"%generated code- do not modify"
	^o asFloat - self! !

"December 6, 2009 -> 18:28:32"!

! (Delta mirrorFor: #Number) methodsFor: 'testing' !
even ^<Boolean>

	^(self \\ 2) = 0! !

"December 6, 2009 -> 18:28:32"!

! (Delta mirrorFor: #Number) methodsFor: 'testing' !
negative ^<Boolean>

	^self < self zero! !

"December 6, 2009 -> 18:28:32"!

! (Delta mirrorFor: #Number) methodsFor: 'testing' !
odd ^<Boolean>

	^(self \\ 2) ~= 0! !

"December 6, 2009 -> 18:28:32"!

! (Delta mirrorFor: #Number) methodsFor: 'testing' !
positive ^<Boolean>

	^self >= self zero! !

"December 6, 2009 -> 18:28:32"!

! (Delta mirrorFor: #Number) methodsFor: 'testing' !
sign ^<Number>

	^self > self zero
		ifTrue: [ self unit ]
		ifFalse: [ self < self zero ifTrue: [ self unit negated ] ifFalse: [ self zero ] ]! !

"December 6, 2009 -> 18:28:32"!

! (Delta mirrorFor: #Number) methodsFor: 'testing' !
strictlyPositive ^<Boolean>

	^self > self zero! !

"December 6, 2009 -> 18:28:32"!

! (Delta mirrorFor: #Number) methodsFor: 'truncation and rounding' !
ceiling ^<Int>
	"Return the receiver truncated to the nearest integer towards positive infinity"

	self unimplemented! !

"December 6, 2009 -> 18:28:32"!

! (Delta mirrorFor: #Number) methodsFor: 'truncation and rounding' !
floor ^<Int>
	"Return the receiver truncated to the nearest integral value towards negative infinity"

	| t <Int> |
	^self < self zero
		ifFalse: [ self truncated ]
		ifTrue: [	
				t := self truncated.
				t = self
					ifTrue: [ t ]
					ifFalse: [ t - 1 ]	]! !

"December 6, 2009 -> 18:28:32"!

! (Delta mirrorFor: #Number) methodsFor: 'truncation and rounding' !
roundTo: n <Number> ^<Number>

	self unimplemented! !

"December 6, 2009 -> 18:28:32"!

! (Delta mirrorFor: #Number) methodsFor: 'truncation and rounding' !
rounded ^<Int>
	"The nearest integral value to the receiver.  When this is ambiguous (e.g. -1.5), choose the
		integral value farthest away from 0 (in the above example, -2)."

"%todo: use the version below when quo: is implemented for doubles
	^((self + self + self sign) quo: (self unit + self unit)) asInteger
"

	^self negative
		ifFalse: [ (self + 0.5d) truncated ]
		ifTrue: [ (self - 0.5d) truncated ]! !

"December 6, 2009 -> 18:28:32"!

! (Delta mirrorFor: #Number) methodsFor: 'truncation and rounding' !
truncateTo: grid <Number> ^<Number>

	^(self quo: grid) * grid! !

"December 6, 2009 -> 18:28:32"!

! (Delta mirrorFor: #Number) methodsFor: 'truncation and rounding' !
truncated ^<Int>
	"Return the receiver truncated to the nearest integral value towards 0."

	self subclassResponsibility! !

"December 6, 2009 -> 18:29:7"!

Delta define: #ClassTestIvars123 as: (
(Class subclassOf: 'Object' instanceVariables: 'one' classInstanceVariables: 'two three')) !


"December 6, 2009 -> 18:29:7"!

(Delta mirrorFor: #ClassTestIvars123) removeDefinitionIfFail: [] !


"December 6, 2009 -> 18:31:9"!

"System saved" !
"December 14, 2009 -> 0:34:26"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUsedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"December 14, 2009 -> 0:34:26"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUsedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"December 14, 2009 -> 0:34:26"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUsedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"December 14, 2009 -> 0:34:26"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUsedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"December 14, 2009 -> 0:34:26"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUsedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"December 14, 2009 -> 0:34:27"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUsedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"December 14, 2009 -> 0:34:27"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUsedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"December 14, 2009 -> 0:34:27"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUsedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"December 14, 2009 -> 0:34:27"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUsedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"December 14, 2009 -> 0:34:27"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUsedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"December 14, 2009 -> 0:34:27"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUsedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"December 14, 2009 -> 0:34:27"!

(Delta mirrorFor: #AlienWeakTable)
comment: 
''!


"December 14, 2009 -> 0:34:27"!

! (Delta mirrorFor: #AlienWeakTable) classSide methodsFor: 'instance creation' !
newForOwner: owner
	^self new initializeWithOwner: owner! !

"December 14, 2009 -> 0:34:27"!

! (Delta mirrorFor: #AlienWeakTable) methodsFor: 'adding' !
add: anObject finalizing: postMortemFinalizationTag
	"Register a new object in the table, with the associated tag.
	 The object is held onto weakly, the tag--strongly. The tag
	 will be passed to the owner as the argument of #finalize:
	 some time after the object is garbage collected."

	| size start delta |
	accessProtect critical:
		[size := strongArray size.
		 start := firstUnusedIndex].
	start to: size do:
		[:i|
		(strongArray at: i) == nil ifTrue:
			[accessProtect critical:
				[weakArray at: i put: anObject.
				 strongArray at: i put: postMortemFinalizationTag.
				 firstUnusedIndex := i + 1.
				 i > lastUsedIndex ifTrue: [lastUsedIndex := i]].
			 ^anObject]].
	delta := size min: 4096.
	accessProtect critical:
		[(weakArray := weakArray copyGrownBy: delta)
			 at: size + 1 put: anObject.
		 (strongArray := strongArray  copyGrownBy: delta)
			at: size put: postMortemFinalizationTag.
		 firstUnusedIndex := size + 1.
		 lastUsedIndex := size].
	^anObject! !

"December 14, 2009 -> 0:34:27"!

! (Delta mirrorFor: #AlienWeakTable) methodsFor: 'initialization' !
initializeWithOwner: anOwner

	accessProtect := Semaphore forMutualExclusion.
	firstUnusedIndex := 1.
	lastUsedIndex := 0.
	weakArray := WeakArray new: 1024.
	strongArray := Array new: 1024.
	owner := anOwner.
	weakArray addWeakDependent: (BlockDependent
															updateBlock: [:aspect| self finalizeValues])! !

"December 14, 2009 -> 0:34:43"!

Delta define: #BlockDependent as: (
(Class subclassOf: 'Object' instanceVariables: 'updateBlock <[X]>')) !


"December 14, 2009 -> 0:34:43"!

(Delta mirrorFor: #BlockDependent)
comment: 
''!


"December 14, 2009 -> 0:34:43"!

! (Delta mirrorFor: #BlockDependent) classSide methodsFor: 'instance creation' !
asTwoArg: block

	| arity |
	arity := block arity.
	arity == 2 ifTrue: [^block].
	arity == 1 ifTrue: [^[:aspect :value | block value: aspect]].
	arity == 0 ifTrue: [^[:aspect :value | block value]].
	^[:aspect :value| |args|
		args := Array new:  arity.
		args at: 1 put: aspect.
		args at: 2 put: value.
		block valueWithArguments: args]	! !

"December 14, 2009 -> 0:34:43"!

! (Delta mirrorFor: #BlockDependent) classSide methodsFor: 'instance creation' !
updateBlock: block <[]>

	^self new
		initialize: (self asTwoArg: block);
		yourself! !

"December 14, 2009 -> 0:34:43"!

! (Delta mirrorFor: #BlockDependent) methodsFor: 'dependencies' !
update: aspect

	updateBlock
		value: aspect
		with: nil! !

"December 14, 2009 -> 0:34:43"!

! (Delta mirrorFor: #BlockDependent) methodsFor: 'dependencies' !
update: aspect with: value

	updateBlock
		value: aspect
		value: value! !

"December 14, 2009 -> 0:34:43"!

! (Delta mirrorFor: #BlockDependent) methodsFor: 'priviate-initialization' !
initialize: block

	updateBlock := block! !

"December 14, 2009 -> 0:35:4"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUsedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"December 14, 2009 -> 0:35:4"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUsedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"December 14, 2009 -> 0:35:4"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUsedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"December 14, 2009 -> 0:35:4"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUsedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"December 14, 2009 -> 0:35:4"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUsedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"December 14, 2009 -> 0:35:4"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUsedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"December 14, 2009 -> 0:35:4"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUsedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"December 14, 2009 -> 0:35:4"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUsedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"December 14, 2009 -> 0:35:4"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUsedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"December 14, 2009 -> 0:35:4"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUsedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"December 14, 2009 -> 0:35:4"!

Delta define: #AlienWeakTable as: (
(Class subclassOf: 'Object' instanceVariables: 'accessProtect <Semaphore>
firstUnusedIndex <Integer>
lastUsedIndex <Integer>
weakArray <WeakArray>
strongArray <Array>
owner <Object>')) !


"December 14, 2009 -> 0:35:4"!

(Delta mirrorFor: #AlienWeakTable)
comment: 
''!


"December 14, 2009 -> 0:35:4"!

! (Delta mirrorFor: #AlienWeakTable) classSide methodsFor: 'instance creation' !
newForOwner: owner
	^self new initializeWithOwner: owner! !

"December 14, 2009 -> 0:35:4"!

! (Delta mirrorFor: #AlienWeakTable) methodsFor: 'adding' !
add: anObject finalizing: postMortemFinalizationTag
	"Register a new object in the table, with the associated tag.
	 The object is held onto weakly, the tag--strongly. The tag
	 will be passed to the owner as the argument of #finalize:
	 some time after the object is garbage collected."

	| size start delta |
	accessProtect critical:
		[size := strongArray size.
		 start := firstUnusedIndex].
	start to: size do:
		[:i|
		(strongArray at: i) == nil ifTrue:
			[accessProtect critical:
				[weakArray at: i put: anObject.
				 strongArray at: i put: postMortemFinalizationTag.
				 firstUnusedIndex := i + 1.
				 i > lastUsedIndex ifTrue: [lastUsedIndex := i]].
			 ^anObject]].
	delta := size min: 4096.
	accessProtect critical:
		[(weakArray := weakArray copyGrownBy: delta)
			 at: size + 1 put: anObject.
		 (strongArray := strongArray  copyGrownBy: delta)
			at: size put: postMortemFinalizationTag.
		 firstUnusedIndex := size + 1.
		 lastUsedIndex := size].
	^anObject! !

"December 14, 2009 -> 0:35:4"!

! (Delta mirrorFor: #AlienWeakTable) methodsFor: 'initialization' !
initializeWithOwner: anOwner

	accessProtect := Semaphore forMutualExclusion.
	firstUnusedIndex := 1.
	lastUsedIndex := 0.
	weakArray := WeakArray new: 1024.
	strongArray := Array new: 1024.
	owner := anOwner.
	weakArray addWeakDependent: (BlockDependent
															updateBlock: [:aspect| self finalizeValues])! !

"December 14, 2009 -> 0:35:15"!

Delta define: #Object as: (
(Class delta)) !


"December 14, 2009 -> 0:35:15"!

(Delta mirrorFor: #Object)
comment: 
'This is the class implementing behavior common to all objects.

Subclass responsibilities:
    %responsibility copying
        Any class with instance variables whose values should not be shared between copies of an instance should
        override #postCopy to copy them as necessary, as well as sending "super postCopy".   Classes whose instances
        are immutable and can be shared can override #copy to return self.
    %responsibility hash
        If you override the #= method, you must override the #hash method if necessary
            to ensure that all objects that are = have hash values that are = too.  For example,
        if you override #= in class YourPoint to test that both x and y are the same, you
        must override #hash to do something like: (^self x hash bitXor: self y hash), so
        that the hash value depends upon the hash values of all the values you are
        comparing.

Tags: %BlueBook %User

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license
'!


"December 14, 2009 -> 0:35:15"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'file out' !
fileOutSignature ^<Integer>
    ^67! !

"December 14, 2009 -> 0:35:15"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'instance creation' !
new ^<Instance>
	"Create and return an initialized instance of this class."

	"%remove when inlining working:"
	^VM new: self
"
	^guaranteed <Instance> (super new)
"! !

"December 14, 2009 -> 0:35:15"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'instance creation' !
new2

	^{{primitiveNew: self
			ifFail: [:e|
						VM handleFailure: e
								allocate: [:tenured :failBlock| VM new: self ifFail: failBlock]
								ifExpand: [VM expand]]}}! !

"December 14, 2009 -> 0:35:15"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'instance creation' !
new3 ^<Instance>
	"Create and return an initialized instance of this class."

	"%remove when inlining working:"
	^{{self primitiveNew2IfFail: [ :err <Symbol> |]}}
"
	^guaranteed <Instance> (super new)
"! !

"December 14, 2009 -> 0:35:15"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'instance creation' !
oldnew ^<Instance>
	"Create and return an initialized instance of this class."

	"%remove when inlining working:"
	^{{self primitiveNewIfFail: [ :err <Symbol> |
		VM scavengeGarbage.
		{{self primitiveNewIfFail: [:err <Symbol> |
			Transcript show: err; cr.
			VM isGCPending
				ifTrue: [VM waitForGC.
							{{self primitiveNewIfFail: [:err <Symbol> |
								VM expand: (VMMirror on: self) instanceSize.
								VM deferredGC.
								{{self primitiveNewIfFail: [:err <Symbol> |
																		self error: err]}}]}}]
				ifFalse: [VM expand: (VMMirror on: self) instanceSize.
							VM deferredGC.
							{{self primitiveNewIfFail: [:err <Symbol> |
																	self error: err]}}].
			]}}
		]}}
"
	^guaranteed <Instance> (super new)
"! !

"December 14, 2009 -> 0:35:15"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'private' !
primitiveNew ^<Instance>
	"%todo: Call this basicNew if in commonbase"

	"This method produces an uninitialized instance of this class. It should not be overridden"

	"This is the point at which Strongtalk starts to know about the type relationship between
	 classes & instances"

	^guaranteed <Instance> (super primitiveNew)! !

"December 14, 2009 -> 0:35:15"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'reflection' !
coerce: o <Object> ^<Instance>

	^self coerce: o else: [ self error: 'Coercion failed with no failure code' ]! !

"December 14, 2009 -> 0:35:15"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'reflection' !
coerce: o <Object> do: blk <[Instance]>

	blk value: (self coerce: o else: [ ^self ])! !

"December 14, 2009 -> 0:35:15"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'reflection' !
coerce: o <Object> do: blk <[Instance,^Y def]> else: fail <[^X def]>   ^<Y|X>

	"%remove when typecase correctly implemented."
	^blk value: (self coerce: o else: [ ^fail value ])! !

"December 14, 2009 -> 0:35:15"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'reflection' !
coerce: o <Object> else: fail <[^X def]>   ^<Instance|X>

	"%remove when typecase correctly implemented."
	^(o isKindOf: self)
		ifTrue: [ guaranteed <Instance> o ]
		ifFalse: [ fail value ]! !

"December 14, 2009 -> 0:35:15"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'reflection' !
isSupportedBy: o <Object> ^<Boolean>

	self coerce: o else: [ ^false ].
	^true! !

"December 14, 2009 -> 0:35:15"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'utility' !
yourself ^<Self>
	"A handy message for syntactic convenience.  Useful in a message cascade when
	 you want the receiver of the previous message, but it doesn't return self, e.g.
		(Dictionary new) at: 1 put: 2; yourself
	 returns the new dictionary, rather than 2"

	^self! !

"December 14, 2009 -> 0:35:16"!

! (Delta mirrorFor: #Object) methodsFor: 'Camp Smalltalk' !
sunitAddDependent: anObject
 
        self addDependent: anObject! !

"December 14, 2009 -> 0:35:16"!

! (Delta mirrorFor: #Object) methodsFor: 'Camp Smalltalk' !
sunitChanged: anAspect
 
        self changed: anAspect! !

"December 14, 2009 -> 0:35:16"!

! (Delta mirrorFor: #Object) methodsFor: 'Camp Smalltalk' !
sunitChanged: anAspect with: value
 
        self changed: anAspect with: value! !

"December 14, 2009 -> 0:35:16"!

! (Delta mirrorFor: #Object) methodsFor: 'Camp Smalltalk' !
sunitRemoveDependent: anObject
 
        self removeDependent: anObject! !

"December 14, 2009 -> 0:35:16"!

! (Delta mirrorFor: #Object) methodsFor: 'accessing' !
hash ^<Int>
	"Return a hash value that is the same as that returned by any
	 object which is = to the receiver.  This usually means that you 
	 must override this method too if you override ="

	^self identityHash! !

"December 14, 2009 -> 0:35:16"!

! (Delta mirrorFor: #Object) methodsFor: 'accessing' !
identityHash ^<Integer>
	"Return a hash value based on the receiver's identity"

	^{{ self primitiveHash }}! !

"December 14, 2009 -> 0:35:16"!

! (Delta mirrorFor: #Object) methodsFor: 'bootstrap-temporary' !
deltaHack

	"Called by methods that should be revisited after bootstrap"! !

"December 14, 2009 -> 0:35:16"!

! (Delta mirrorFor: #Object) methodsFor: 'bootstrap-temporary' !
isAssociationOop ^ <Boolean>
	self deltaHack.
	^self isKindOf: GlobalAssociation.! !

"December 14, 2009 -> 0:35:16"!

! (Delta mirrorFor: #Object) methodsFor: 'bootstrap-temporary' !
isBehavior ^ <Boolean>
	self deltaHack.
	^self isKindOf: Behavior.! !

"December 14, 2009 -> 0:35:16"!

! (Delta mirrorFor: #Object) methodsFor: 'bootstrap-temporary' !
isBoolean ^ <Boolean>
	self deltaHack.
	^self isKindOf: Boolean.! !

"December 14, 2009 -> 0:35:16"!

! (Delta mirrorFor: #Object) methodsFor: 'bootstrap-temporary' !
isCharacter ^ <Boolean>
	self deltaHack.
	^self isKindOf: Character.! !

"December 14, 2009 -> 0:35:16"!

! (Delta mirrorFor: #Object) methodsFor: 'bootstrap-temporary' !
isCollection ^ <Boolean>
	self deltaHack.
	^self isKindOf: Collection[Object].! !

"December 14, 2009 -> 0:35:16"!

! (Delta mirrorFor: #Object) methodsFor: 'bootstrap-temporary' !
isError ^ <Boolean>
	self deltaHack.
	^false ! !

"December 14, 2009 -> 0:35:16"!

! (Delta mirrorFor: #Object) methodsFor: 'bootstrap-temporary' !
isInteger ^ <Boolean>
	self deltaHack.
	^self isKindOf: Integer.! !

"December 14, 2009 -> 0:35:16"!

! (Delta mirrorFor: #Object) methodsFor: 'bootstrap-temporary' !
isMethodOop ^ <Boolean>
	self deltaHack.
	^self isKindOf: Method.! !

"December 14, 2009 -> 0:35:16"!

! (Delta mirrorFor: #Object) methodsFor: 'bootstrap-temporary' !
isOop ^ <Boolean>
	self deltaHack.
	^true! !

"December 14, 2009 -> 0:35:16"!

! (Delta mirrorFor: #Object) methodsFor: 'bootstrap-temporary' !
isSmallInteger ^ <Boolean>
	self deltaHack.
	^self isKindOf: SmallInteger! !

"December 14, 2009 -> 0:35:16"!

! (Delta mirrorFor: #Object) methodsFor: 'bootstrap-temporary' !
isString ^ <Boolean>
	self deltaHack.
	^(self isKindOf: String) or:[self isSymbol].! !

"December 14, 2009 -> 0:35:16"!

! (Delta mirrorFor: #Object) methodsFor: 'bootstrap-temporary' !
isSymbol ^ <Boolean>
	self deltaHack.
	^self isKindOf: Symbol.! !

"December 14, 2009 -> 0:35:16"!

! (Delta mirrorFor: #Object) methodsFor: 'bootstrap-temporary' !
isSymbolOop ^ <Boolean>
	self deltaHack.
	^self isSymbol! !

"December 14, 2009 -> 0:35:16"!

! (Delta mirrorFor: #Object) methodsFor: 'bootstrap-temporary' !
printValue
	self deltaHack.
	{{self primitivePrintValue}}! !

"December 14, 2009 -> 0:35:16"!

! (Delta mirrorFor: #Object) methodsFor: 'copying' !
copy ^<Instance>
	"Create and return a copy of the receiver.  Objects that are immutable and cannot be copied may return
	 themselves.  Objects contained by this object that are externally accessible objects and  are 	 considered
	 'separate' from  the receiver (such as the elements of a collection) are not copied.

	Subclasses must override postCopy if they contain private information that should not be shared
	after a copy."

	^self shallowCopy postCopy! !

"December 14, 2009 -> 0:35:16"!

! (Delta mirrorFor: #Object) methodsFor: 'dependencies' !
addDependent: o <Object>

	"Objects that aren't models don't need to store dependents, since they don't do notification.  To
	  add support for BlueBook-style dependency notification to a class, mix-in or inherit from 
	  NotifyingObject."! !

"December 14, 2009 -> 0:35:16"!

! (Delta mirrorFor: #Object) methodsFor: 'dependencies' !
removeDependent: o <Object>

	"Objects that aren't models don't need to store dependents, since they don't do notification"! !

"December 14, 2009 -> 0:35:17"!

! (Delta mirrorFor: #Object) methodsFor: 'dependencies' !
update: aspect <Object> 
! !

"December 14, 2009 -> 0:35:17"!

! (Delta mirrorFor: #Object) methodsFor: 'dependencies' !
update: aspect <Object> with: value <Object>

	self update: aspect
! !

"December 14, 2009 -> 0:35:17"!

! (Delta mirrorFor: #Object) methodsFor: 'fake brands' !
Number ^<Boolean>
	^false! !

"December 14, 2009 -> 0:35:17"!

! (Delta mirrorFor: #Object) methodsFor: 'fake brands' !
Str ^<Boolean>
	^false! !

"December 14, 2009 -> 0:35:17"!

! (Delta mirrorFor: #Object) methodsFor: 'file out' !
fileOutBodyOn: d <Dumper>
	| start <Integer> end <Integer> |
	"File out instance variables"
	start	:= self fileOutHeaderSize.
	end		:=	(Reflection classOf: self)	 fileOutNonIndexableSize.
	start + 1 to: end do: [:index <Integer> |
		(self fileOutInstVarAt: index) fileOutOn: d
	]! !

"December 14, 2009 -> 0:35:17"!

! (Delta mirrorFor: #Object) methodsFor: 'file out' !
fileOutHeaderOn: d <Dumper>
	d	putByte: 		self fileOutSignature.
	d	putInteger:	self fileOutSize.
	(Reflection classOf: self)		fileOutOn: d! !

"December 14, 2009 -> 0:35:17"!

! (Delta mirrorFor: #Object) methodsFor: 'file out' !
fileOutHeaderSize ^<Integer>
	^(Reflection classOf: self) fileOutInstanceHeaderSize! !

"December 14, 2009 -> 0:35:17"!

! (Delta mirrorFor: #Object) methodsFor: 'file out' !
fileOutInstVarAt: index <Integer> ^<Object>
	^{{self primitiveInstVarAt: index ifFail: [:err <Symbol> | self error: err]}}! !

"December 14, 2009 -> 0:35:17"!

! (Delta mirrorFor: #Object) methodsFor: 'file out' !
fileOutSignature ^<Integer>
    ^99! !

"December 14, 2009 -> 0:35:17"!

! (Delta mirrorFor: #Object) methodsFor: 'file out' !
fileOutSize ^<Integer>
	^{{self primitiveOopSize}}! !

"December 14, 2009 -> 0:35:17"!

! (Delta mirrorFor: #Object) methodsFor: 'performing' !
perform: selector <"Symbol"BottomType> ^<Object>
	"Send the message selector to the receiver with no arguments, and return the result.
	 This can potentially result in a run-time error if the receiver doesn't implement
	 the message, or if the method needs a different number of arguments, or if an argument
	 is of an incorrect type. 

	The  type BottomType is used so that you have to put in an explicit guarantee to make
	 your code typecheck.  Although this is really a trick, we consider it sensible because you
     are in fact taking over the  typechecker's responsiblity to guarantee that the perform
	 will work."

	^{{self primitivePerform: selector
			ifFail: [ :err <Symbol> |
							self error: err ]
	  }}! !

"December 14, 2009 -> 0:35:17"!

! (Delta mirrorFor: #Object) methodsFor: 'performing' !
perform: selector <Symbol>
with: arg1 <BottomType>
^<Object>

	"Send the message selector to the receiver with 1 arguments, and return the result.
	 This can potentially result in a run-time error if the receiver doesn't implement
	 the message, or if the method needs a different number of arguments, or if an argument
	 is of an incorrect type.

	The  type BottomType is used so that you have to put in an explicit guarantee to make
	 your code typecheck.  Although this is really a trick, we consider it sensible because you
         are in fact taking over the  typechecker's responsiblity to guarantee that the perform
	 will work."

	^{{self primitivePerform: selector
			with: arg1
			ifFail: [ :err <Symbol> |
							self error: err ]
	  }}
! !

"December 14, 2009 -> 0:35:17"!

! (Delta mirrorFor: #Object) methodsFor: 'performing' !
perform: selector <Symbol>
with: arg1 <BottomType>
with: arg2 <BottomType>
^<Object>

	"Send the message selector to the receiver with 2 arguments, and return the result.
	 This can potentially result in a run-time error if the receiver doesn't implement
	 the message, or if the method needs a different number of arguments, or if an argument
	 is of an incorrect type.

	The  type BottomType is used so that you have to put in an explicit guarantee to make
	 your code typecheck.  Although this is really a trick, we consider it sensible because you
         are in fact taking over the  typechecker's responsiblity to guarantee that the perform
	 will work."

	^{{self primitivePerform: selector
			with: arg1
			with: arg2
			ifFail: [ :err <Symbol> |
							self error: err ]
	  }}
! !

"December 14, 2009 -> 0:35:17"!

! (Delta mirrorFor: #Object) methodsFor: 'performing' !
perform: selector <Symbol>
with: arg1 <BottomType>
with: arg2 <BottomType>
with: arg3 <BottomType>
^<Object>

	"Send the message selector to the receiver with 3 arguments, and return the result.
	 This can potentially result in a run-time error if the receiver doesn't implement
	 the message, or if the method needs a different number of arguments, or if an argument
	 is of an incorrect type.

	The  type BottomType is used so that you have to put in an explicit guarantee to make
	 your code typecheck.  Although this is really a trick, we consider it sensible because you
         are in fact taking over the  typechecker's responsiblity to guarantee that the perform
	 will work."

	^{{self primitivePerform: selector
			with: arg1
			with: arg2
			with: arg3
			ifFail: [ :err <Symbol> |
							self error: err ]
	  }}
! !

"December 14, 2009 -> 0:35:17"!

! (Delta mirrorFor: #Object) methodsFor: 'performing' !
perform: selector <Symbol>
withArguments: args <SeqCltn[Object]>
^<Object>

	"Send the message selector to the receiver with 4 arguments, and return the result.
	 This can potentially result in a run-time error if the receiver doesn't implement
	 the message, or if the method needs a different number of arguments, or if an argument
	 is of an incorrect type.

	The  type BottomType is used so that you have to put in an explicit guarantee to make
	 your code typecheck.  Although this is really a trick, we consider it sensible because you
         are in fact taking over the  typechecker's responsiblity to guarantee that the perform
	 will work."

	^{{self primitivePerform: selector
			arguments: args
			ifFail: [ :err <Symbol> |
							self error: err ]
	  }}
! !

"December 14, 2009 -> 0:35:17"!

! (Delta mirrorFor: #Object) methodsFor: 'printing' !
print

	self printOn: Platform errorStream.
	Platform errorStream cr.! !

"December 14, 2009 -> 0:35:17"!

! (Delta mirrorFor: #Object) methodsFor: 'printing' !
printOn: strm <CharOutputStream>

	| nm <Str> |
	nm := self class name.
	strm	nextPutAll: (self articleFor: nm);
			nextPut: Character space;
			nextPutAll: nm.! !

"December 14, 2009 -> 0:35:17"!

! (Delta mirrorFor: #Object) methodsFor: 'printing' !
printString ^<Str>
	"Return a string that holds a readable but terse representation of the receiver"

	| strm <CharWriteStream> |
	strm := CharacterReadWriteStream on: (String new: 8).
	self printOn: strm.
	^strm contentsWritten! !

"December 14, 2009 -> 0:35:18"!

! (Delta mirrorFor: #Object) methodsFor: 'printing' !
vmPrint
     "%remove"
	{{self primitivePrint}}! !

"December 14, 2009 -> 0:35:18"!

! (Delta mirrorFor: #Object) methodsFor: 'private' !
articleFor: s <Str> ^<Str>

	^(s at: 1) isVowel
			ifTrue: [ 'an' ]
			ifFalse: [ 'a' ]! !

"December 14, 2009 -> 0:35:18"!

! (Delta mirrorFor: #Object) methodsFor: 'private' !
assert: predicate <[^Boolean]>
	"Assert that the predicate is true.   If it is false, the program is considered to have failed.  It is STRONGLY encouraged that you
	 sprinkle assertions liberally through your code, to doublecheck that your designs are correct.  When you are running in a
  	 high performance production environment, and wish to gain every bit of performance at the expense of some extra program
	 validity checks, you can change inProduction to return true, so that none of the assertions are checked.
	 Because of this, you should not put code with side effects in assert blocks, since they will not be executed
	 in production environments.  See BooleanBlock>>verify for an alternative that always tests."

	self inProduction
		ifFalse: [ predicate verify ]! !

"December 14, 2009 -> 0:35:18"!

! (Delta mirrorFor: #Object) methodsFor: 'private' !
postCopy
	"This is sent to an object that is the result of a shallowCopy to allow it to copy any subobjects
	  that should not be shared.  Subclasses should override this if they have such subobjects."
! !

"December 14, 2009 -> 0:35:18"!

! (Delta mirrorFor: #Object) methodsFor: 'private' !
shallowCopy ^<Instance>
	"Create a bitwise copy of the current object.  This is not public because the new object shares the
	 values of all of the receiver's instance variables, which may violate the design of the receiver's class.
	 The postCopy message fixes such undesired sharing, after the fact"

	^guaranteed <Instance>
		{{self primitiveShallowCopyIfFail: [ :err <Symbol> | self error: err ]}}! !

"December 14, 2009 -> 0:35:18"!

! (Delta mirrorFor: #Object) methodsFor: 'private' !
shallowCopyTenured ^<Instance>
	"As shallowCopy, but forces the copy to be in old space"

	^guaranteed <Instance>
		{{self primitiveCopyTenuredIfFail: [ :err <Symbol> | self error: err ]}} ! !

"December 14, 2009 -> 0:35:18"!

! (Delta mirrorFor: #Object) methodsFor: 'private- file out' !
fileOutOn: d <Dumper>

	"%bug: this method should NOT be called fileOutOn:,
		since this is NOT Smalltalk fileOut, but image save
		code.  This conflicts with the real fileOutOn:, which
		is implemented in DefinitionWriter"
		
	d at: self ifPresent: [ :id <Integer> |
		d putByte: 51.
		d putInteger: id.
	] ifAbsentPut: [ :id <Integer> |
		self fileOutHeaderOn: d.
		self fileOutBodyOn: d.
	]! !

"December 14, 2009 -> 0:35:18"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
doesNotUnderstand: m <Message> ^<BottomType>
	"Processor stopWithError: (ProcessDoesNotUnderstandError new message: m)"
	(MessageNotUnderstood message: m) signal! !

"December 14, 2009 -> 0:35:18"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
error: msg <Str> ^<BottomType>

	"Processor stopWithError: (ProcessExplicitError new msg: msg)"
	Error signal: msg! !

"December 14, 2009 -> 0:35:18"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
halt

	"Processor stopWithError: ProcessHaltError new."
	Halt signal
! !

"December 14, 2009 -> 0:35:18"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
shouldNotHappen ^<BottomType>

	self error: 'This shouldn''t happen'.! !

"December 14, 2009 -> 0:35:18"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
shouldNotImplement ^<BottomType>

	self error: 'A message that cannot be supported by this class has been sent to an instance'.! !

"December 14, 2009 -> 0:35:18"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
subclassResponsibility ^<BottomType>

	"Note: In the Strongtalk language, a method whose body consists of only 
	 'self subclassResponsibility' is considered a declaration, which subclasses
	  must implement for concrete subclasses"

	self error: 'A message that should be implemented but is not has been sent to this object'.! !

"December 14, 2009 -> 0:35:18"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
unimplemented ^<BottomType>

	self error: 'A hook for unimplemented code has been encountered'! !

"December 14, 2009 -> 0:35:18"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
vmHalt

	{{primitiveVMBreakpoint}}! !

"December 14, 2009 -> 0:35:18"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
vmHalt: condition

	condition ifTrue: [self vmHalt]! !

"December 14, 2009 -> 0:35:18"!

! (Delta mirrorFor: #Object) methodsFor: 'private-initialization' !
initialize

	"This initialize method does NOT have to be called by subclasses.  It is here
		as a stub so that mixins can have an initialize method that sends super initialize so
		that they work when invoked in the presence superclass initialize methods.
		** Note that this method is NOT called by Object>>new; subclasses must provide a
		#new method to invoke it if needed."

	"do nothing"! !

"December 14, 2009 -> 0:35:18"!

! (Delta mirrorFor: #Object) methodsFor: 'private-reflective' !
actualClass ^<Self class>

	^{{self primitiveClass}}! !

"December 14, 2009 -> 0:35:18"!

! (Delta mirrorFor: #Object) methodsFor: 'private-reflective' !
become: otherObject <BottomType>
	"Replace all references to the receiver anywhere in this image with references to otherObject, instead.

	This is a very dangerous message that should only be used if you really know what you are doing. Note that ALL
	references are changed, including 'self' in any currently active method contexts for the receiver,
	which means that instance variables could be accessed incorrectly, etc.  Note that this also means that the receiver
	becomes COMPLETELY inaccessible.
	 Also, this is not typesafe, and the type of the argument has been chosen to force typed code to insert an 
	 explicit guarantee, to avoid 'accidental' type-safety holes.  "

	"self unimplemented"
	{{ self primitiveBecome: otherObject ifFail: [:error| self error: error] }}! !

"December 14, 2009 -> 0:35:18"!

! (Delta mirrorFor: #Object) methodsFor: 'private-system testing' !
inProduction ^<Boolean>

	"Indicates whether the system should emphasis speed over extra design validity checks.
     You can change this to return true for production applications.
     For example, when this is true, assertions (see #assert) are not checked."

	^true! !

"December 14, 2009 -> 0:35:18"!

! (Delta mirrorFor: #Object) methodsFor: 'reflective' !
== other <Object> ^<Boolean>
	"test whether the receiver is identical to (completely interchangeable with) other"

	^{{self primitiveEqual: other}}! !

"December 14, 2009 -> 0:35:19"!

! (Delta mirrorFor: #Object) methodsFor: 'reflective' !
class ^<Object class>
	"Return the effective class of this object.  This is reflective, and thus indiscriminate
	  use is considered bad style.

	  Unlike in some other Smalltalk implementations, it
	  is ok to override this method to return something other than the real class of the
	  receiver, in situations where one class is trying to completely emulate another.

	  If you are writing Strongtalk code that needs to send a class message that you have
	  written to the receiver's class, you should use the #actualClass message, which is
	  private.

	  Truly reflective tools such as inspectors, etc. that need to get at the actual class
	  of an object o should use the message (Reflection classOf: o).  The idea behind this
	  scheme is that an object should be able (as much as feasible) to hide its
	  implementation behind its message interface (including its actual class) from
	  user code.  This allows, for example, forwarding objects (or proxies, etc), to act
	  as if they have the same class as the object they are forwarding to, without breaking
	  any system invariant, or breaking debugging and inspecting tools.  At the moment,
	  the only exception to this rule is that the #== message may not be overridden, for
	  performance reasons."

	^{{self primitiveClass}}! !

"December 14, 2009 -> 0:35:19"!

! (Delta mirrorFor: #Object) methodsFor: 'reflective' !
isKindOf: beh <Behavior> ^<Boolean>
	| current <Behavior> |

	current := Reflection classOf: self.

	"%remove %hack: until coerce is fast, we put a simple cache
		here to speed this up when it is relatively monomorphic.
	    This is NOT safe when preemption is on"
	(current == CurrentClassCacheForIsKindOf
			and: [ beh == BehCacheForIsKindOf ])
		ifTrue: [   ^ResultCacheForIsKindOf ].

	CurrentClassCacheForIsKindOf := current.
	BehCacheForIsKindOf := beh.

	[ current = beh ]
		whileFalse: [ current := current superclassIfAbsent: [ ^ResultCacheForIsKindOf := false ] ].
	^ResultCacheForIsKindOf := true! !

"December 14, 2009 -> 0:35:19"!

! (Delta mirrorFor: #Object) methodsFor: 'reflective' !
isMemberOf: behavior <Behavior> ^<Boolean>

	^self actualClass = behavior! !

"December 14, 2009 -> 0:35:19"!

! (Delta mirrorFor: #Object) methodsFor: 'reflective' !
respondsTo: selector <Symbol> ^<Boolean>

	self unimplemented! !

"December 14, 2009 -> 0:35:19"!

! (Delta mirrorFor: #Object) methodsFor: 'reflective' !
species ^<Object class>

	^self actualClass! !

"December 14, 2009 -> 0:35:19"!

! (Delta mirrorFor: #Object) methodsFor: 'reflective' !
~~ other <Object> ^<Boolean>
	"test whether the receiver is not identical to (not completely interchangeable with) other"

	^(self == other) 
		ifTrue: [ false ] "for speed"
		ifFalse: [ true ]! !

"December 14, 2009 -> 0:35:19"!

! (Delta mirrorFor: #Object) methodsFor: 'restricted-finalization' !
finalize
" no live references to the receiver exist. Clean up any external
  resources owned by the receiver. The receiver may be resurrected.
  Default is to do nothing"! !

"December 14, 2009 -> 0:35:19"!

! (Delta mirrorFor: #Object) methodsFor: 'testing' !
= other <Object> ^<Boolean>
	"test whether this object and other are equivalent (as close to the same
	 as possible without necessarily being ==).  
	
	 By default this is the same as ==.  Subclasses that redefine this must ensure
	 that: 1) the method works with ANY object passed in as an argument
	 (you CANNOT assume that the other object is of any particular type/class)
	 2) if two objects are =, their #hash values are = too
	 "

	^self == other! !

"December 14, 2009 -> 0:35:19"!

! (Delta mirrorFor: #Object) methodsFor: 'testing' !
isNil ^<Boolean>
	"test whether the receiver is nil.  This method should not be overridden by application programmers."

	^false! !

"December 14, 2009 -> 0:35:19"!

! (Delta mirrorFor: #Object) methodsFor: 'testing' !
isPoint ^<Boolean>
	"%todo: remove when coercion is fast.  Don't write code that depends on this!!"

	^false! !

"December 14, 2009 -> 0:35:19"!

! (Delta mirrorFor: #Object) methodsFor: 'testing' !
notNil ^<Boolean>
	"test whether the receiver is not nil.  This method should not be overridden by users."

	^true! !

"December 14, 2009 -> 0:35:19"!

! (Delta mirrorFor: #Object) methodsFor: 'testing' !
~= other <Object> ^<Boolean>
	"not ="

	^(self = other)
		ifTrue: [ false ]
		ifFalse: [ true ]! !

"December 14, 2009 -> 0:35:19"!

! (Delta mirrorFor: #Object) methodsFor: 'utility' !
,, other <Y def> ^<VarTuple[X,Y]>
			{where X is receiverType}
	"Return a 2 element tuple containing the receiver as its first element, and other as its second."

	| safeself <X> |
	"this guarantee is safe because of the inference clause"
	safeself := guaranteed <X> self.
"%todo: use real tuple class"
	^guaranteed <VarTuple[X,Y]> (Association[X,Y] key: safeself value: other)! !

"December 14, 2009 -> 0:35:19"!

! (Delta mirrorFor: #Object) methodsFor: 'utility' !
-> other <Y def> ^<VarAssoc[X,Y]>
	{where X is receiverType}

	| safeself <X> |
	"this guarantee is safe because of the inference clause"
	safeself := guaranteed <X> self.

	^Association[X,Y] key: safeself value: other! !

"December 14, 2009 -> 0:35:19"!

! (Delta mirrorFor: #Object) methodsFor: 'utility' !
test: i <Int> is: predicate <[^Boolean]>

	predicate value ifFalse: [
		Platform errorStream show: 'Test '; print: i; show: ' failed'; cr.
		self error: 'Test failed'.	]! !

"December 14, 2009 -> 0:35:19"!

! (Delta mirrorFor: #Object) methodsFor: 'utility' !
value

	^self! !

"December 14, 2009 -> 0:35:19"!

! (Delta mirrorFor: #Object) methodsFor: 'utility' !
yourself ^<Self>

	"This message is used for syntactic convenience to get at the original receiver
	  in a cascade, so as to avoid creating a temporary variable.  Example:
		OrderedCollection[E] class method
			with: <E> ^<Instance>

		  		^(self new: 1) addLast: val; yourself

	 In this example, yourself is needed to return the new ordered collection, because
	 the #addLast: message returns val, not the ordered collection."! !

"December 14, 2009 -> 0:35:33"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"December 14, 2009 -> 0:35:33"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"December 14, 2009 -> 0:35:33"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"December 14, 2009 -> 0:35:33"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"December 14, 2009 -> 0:35:33"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"December 14, 2009 -> 0:35:33"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"December 14, 2009 -> 0:35:33"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"December 14, 2009 -> 0:35:33"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"December 14, 2009 -> 0:35:33"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"December 14, 2009 -> 0:35:33"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"December 14, 2009 -> 0:35:33"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"December 14, 2009 -> 0:35:33"!

(Delta mirrorFor: #Process)
comment: 
'Tags: %BlueBook %User

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license
'!


"December 14, 2009 -> 0:35:33"!

! (Delta mirrorFor: #Process) classSide methodsFor: 'file out' !
fileOutSignature ^<Integer>
    ^80! !

"December 14, 2009 -> 0:35:33"!

! (Delta mirrorFor: #Process) classSide methodsFor: 'instance creation' !
for: block <[]> ^<Instance>
	"Create and return a new process that will execute the block at the
	 specified priority.  The new process is suspended."

	| i <Instance> |
	i := (guaranteed <Instance>
		{{self primitiveProcessCreate: [ i recordId. block value ]
				ifFail: [ :err <Symbol> | self error: err ]
		}}
	  ) initFor: block.
	^i! !

"December 14, 2009 -> 0:35:33"!

! (Delta mirrorFor: #Process) classSide methodsFor: 'instance creation' !
primitiveCreate: block! !

"December 14, 2009 -> 0:35:33"!

! (Delta mirrorFor: #Process) methodsFor: 'accessing' !
priority ^<Int>

	^priority! !

"December 14, 2009 -> 0:35:33"!

! (Delta mirrorFor: #Process) methodsFor: 'accessing' !
priority: prio <Int>

	priority := prio! !

"December 14, 2009 -> 0:35:33"!

! (Delta mirrorFor: #Process) methodsFor: 'accessing' !
processError ^ <ProcessError>

	^processError
! !

"December 14, 2009 -> 0:35:33"!

! (Delta mirrorFor: #Process) methodsFor: 'accessing' !
status ^<Symbol>
	"One of:
		#Initialized				- State right after creation.
		#Yielded					- Gave up control by calling yield.
		#InAsyncDLL			- Gave up control but continues to execute asynchronous DLL.
		#Stopped				- Gave up control by calling stop.
		#Preempted			- Was preempted by system.
		#Running					- Currently running
		#Completed			- Ran to completion.
		#Killed						- The process has been terminated.
		#BooleanError		- A boolean was expected at hardcoded control structure.
		#LookupError			- The receiver does not understand doesNotUnderstand:.
		#PrimitiveLookupError	- Binding a primitive failed.
		#DLLLookupError				 - Binding a DLL function failed.
		#NLRError				- Context for NLR did not exist.
		#StackOverflow		- Stack exhausted.
	"

	^{{self primitiveProcessStatus}}! !

"December 14, 2009 -> 0:35:33"!

! (Delta mirrorFor: #Process) methodsFor: 'control' !
resume

	Processor resume: self! !

"December 14, 2009 -> 0:35:33"!

! (Delta mirrorFor: #Process) methodsFor: 'control' !
suspend

	Processor suspend: self.
	Processor activeProcess = self
		ifTrue: [ self yield ]! !

"December 14, 2009 -> 0:35:33"!

! (Delta mirrorFor: #Process) methodsFor: 'control' !
terminate

	Processor terminating: self.
	self vmTerminate.	! !

"December 14, 2009 -> 0:35:33"!

! (Delta mirrorFor: #Process) methodsFor: 'control' !
waitUntilDead
	"can be called after a process has been terminated to wait until it has completed
		unwinding its stack etc, and is truly dead.  This loops currently, so it is not
		a good way for waiting for the death of a process that has not been terminated.
		This may never return if the process that has been terminated does not ever
		finish cleaning up."
	
	[ self running ]
		whileTrue: [ Processor yield ]! !

"December 14, 2009 -> 0:35:33"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handle: exception

	^self handlerChain handle: exception! !

"December 14, 2009 -> 0:35:33"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"December 14, 2009 -> 0:35:33"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain: aHandler

	handlerChain := aHandler! !

"December 14, 2009 -> 0:35:33"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
inEnvironment: aHandler do: block

	| oldHandler |
	oldHandler := self handlerChain.
	handlerChain := aHandler.
	block
		ensure: [handlerChain := oldHandler]! !

"December 14, 2009 -> 0:35:33"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
popHandler

	| poppedHandler |
	handlerChain := (poppedHandler := self handlerChain) nextHandler.
	^poppedHandler! !

"December 14, 2009 -> 0:35:33"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
pushHandler: handler

	handler nextHandler: self handlerChain.
	handlerChain := handler ! !

"December 14, 2009 -> 0:35:33"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
resetExceptionEnvironment

	handlerChain := nil

! !

"December 14, 2009 -> 0:35:34"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
resetHandlers

	handlerChain := nil

! !

"December 14, 2009 -> 0:35:34"!

! (Delta mirrorFor: #Process) methodsFor: 'file out' !
fileOutSignature ^<Integer>
    ^112! !

"December 14, 2009 -> 0:35:34"!

! (Delta mirrorFor: #Process) methodsFor: 'private' !
register

	Processor register: self.! !

"December 14, 2009 -> 0:35:34"!

! (Delta mirrorFor: #Process) methodsFor: 'private' !
vmTerminate

	{{self primitiveProcessTerminateIfFail: [ :err <Symbol> | self error: err ]}}! !

"December 14, 2009 -> 0:35:34"!

! (Delta mirrorFor: #Process) methodsFor: 'private-initialization' !
initFor: block <[]>

	body := block.

	self register.
	
! !

"December 14, 2009 -> 0:35:34"!

! (Delta mirrorFor: #Process) methodsFor: 'private-initialization' !
recordId

	win32Handle := Platform currentThreadId! !

"December 14, 2009 -> 0:35:34"!

! (Delta mirrorFor: #Process) methodsFor: 'restricted' !
activationStack ^ <Array[Activation]>

	^{{self primitiveProcessStackLimit: 100 ifFail: [ :err <CompressedSymbol>  | self error: err]}}! !

"December 14, 2009 -> 0:35:34"!

! (Delta mirrorFor: #Process) methodsFor: 'restricted' !
processError: e <ProcessError>

	processError := e
! !

"December 14, 2009 -> 0:35:34"!

! (Delta mirrorFor: #Process) methodsFor: 'restricted' !
stopInEvaluator

	Processor stopInEvaluator: self! !

"December 14, 2009 -> 0:35:34"!

! (Delta mirrorFor: #Process) methodsFor: 'restricted' !
traceStack

	{{self primitiveProcessTraceStack: 20 ifFail: [ :err <Symbol> | self error: err]}}
! !

"December 14, 2009 -> 0:35:34"!

! (Delta mirrorFor: #Process) methodsFor: 'restricted' !
win32Handle ^<Win32Handle>
	"This is valid only after the process has begun to actually execute"

	^win32Handle! !

"December 14, 2009 -> 0:35:34"!

! (Delta mirrorFor: #Process) methodsFor: 'restricted' !
yield
	{{primitiveProcessYield}}! !

"December 14, 2009 -> 0:35:34"!

! (Delta mirrorFor: #Process) methodsFor: 'testing' !
dead

	^self status == #Killed! !

"December 14, 2009 -> 0:35:34"!

! (Delta mirrorFor: #Process) methodsFor: 'testing' !
running ^<Boolean>
	"Not suspended, dying, or dead. (This includes processes blocked in async dll calls)"

	^Processor isRunning: self! !

"December 14, 2009 -> 0:35:34"!

! (Delta mirrorFor: #Process) methodsFor: 'testing' !
suspended ^<Boolean>
	"Not on the running list, but can be resumed"

	| s <Symbol> |
	self running
		ifTrue: [ ^false ].
	s := self status.
	^s == #Yielded
		or: [ s == #InAsyncDLL
		or: [ s == #Initialized
		or: [ s == #Preempted
		or: [ s == #Stopped ]   ]]]! !

"December 14, 2009 -> 0:35:44"!

Delta define: #WeakArray as: (
Generic forAll: 'E ' body: ((Class subclassOf: 'IndexedNextOfKinInstanceVariables[E] |> Array[E]' instanceVariables: ''))) !


"December 14, 2009 -> 0:35:44"!

Delta define: #WeakArray as: (
Generic forAll: 'E ' body: ((Class subclassOf: 'IndexedNextOfKinInstanceVariables[E] |> Array[E]' instanceVariables: ''))) !


"December 14, 2009 -> 0:35:44"!

Delta define: #WeakArray as: (
Generic forAll: 'E ' body: ((Class subclassOf: 'IndexedNextOfKinInstanceVariables[E] |> Array[E]' instanceVariables: ''))) !


"December 14, 2009 -> 0:35:44"!

Delta define: #WeakArray as: (
Generic forAll: 'E ' body: ((Class subclassOf: 'IndexedNextOfKinInstanceVariables[E] |> Array[E]' instanceVariables: ''))) !


"December 14, 2009 -> 0:35:44"!

Delta define: #WeakArray as: (
Generic forAll: 'E ' body: ((Class subclassOf: 'IndexedNextOfKinInstanceVariables[E] |> Array[E]' instanceVariables: ''))) !


"December 14, 2009 -> 0:35:44"!

Delta define: #WeakArray as: (
Generic forAll: 'E ' body: ((Class subclassOf: 'IndexedNextOfKinInstanceVariables[E] |> Array[E]' instanceVariables: ''))) !


"December 14, 2009 -> 0:35:44"!

Delta define: #WeakArray as: (
Generic forAll: 'E ' body: ((Class subclassOf: 'IndexedNextOfKinInstanceVariables[E] |> Array[E]' instanceVariables: '') classVariables: 'FinalizationProcess <Process>
FinalizationSemaphore <Semaphore>')) !


"December 14, 2009 -> 0:35:44"!

Delta define: #WeakArray as: (
Generic forAll: 'E ' body: ((Class subclassOf: 'IndexedNextOfKinInstanceVariables[E] |> Array[E]' instanceVariables: 'dependents <NotifyingObject>') classVariables: 'FinalizationProcess <Process>
FinalizationSemaphore <Semaphore>')) !


"December 14, 2009 -> 0:35:44"!

Delta define: #WeakArray as: (
Generic forAll: 'E ' body: ((Class subclassOf: 'IndexedNextOfKinInstanceVariables[E] |> Array[E]' instanceVariables: 'dependents <NotifyingObject>') classVariables: 'FinalizationProcess <Process>
FinalizationSemaphore <Semaphore>')) !


"December 14, 2009 -> 0:35:44"!

Delta define: #WeakArray as: (
Generic forAll: 'E ' body: ((Class subclassOf: 'IndexedNextOfKinInstanceVariables[E] |> Array[E]' instanceVariables: 'dependents <NotifyingObject>') classVariables: 'FinalizationProcess <Process>
FinalizationSemaphore <Semaphore>')) !


"December 14, 2009 -> 0:35:44"!

Delta define: #WeakArray as: (
Generic forAll: 'E ' body: ((Class subclassOf: 'IndexedNextOfKinInstanceVariables[E] |> Array[E]' instanceVariables: 'dependents <NotifyingObject>') classVariables: 'FinalizationProcess <Process>
FinalizationSemaphore <Semaphore>')) !


"December 14, 2009 -> 0:35:44"!

Delta define: #WeakArray as: (
Generic forAll: 'E ' body: ((Class subclassOf: 'IndexedNextOfKinInstanceVariables[E] |> Array[E]' instanceVariables: 'dependents <NotifyingObject>') classVariables: 'FinalizationProcess <Process>
FinalizationSemaphore <Semaphore>')) !


"December 14, 2009 -> 0:35:44"!

(Delta mirrorFor: #WeakArray)
comment: 
'Implements Arrays whose elements are checked by the garbage collector
to see if their memory would be reclaimed if they weren''t referenced by a
WeakArray.  This is called a ''near-death experience''.   The weak array is notified
whenever such a reference is detected by the collector, with the message
hadNearDeathExperience:.  By default, this message just nils out any
references to the object, so that it can be reclaimed on the next garbage
collection. 

Compatibility note:
This kind of WeakArray is not quite the same as the WeakArrays implemented
in some other Smalltalks.  Other WeakArrays implement ''post-facto'' notification,
which some company has patented.  Our WeakArrays actually are more flexible,
since they implement notification before-the-fact of object collection, so that
the contents of the object are still accessible.  For example, if this was used to
hold references to open file descriptors, upon notification, the file descriptor can
be closed, and then its reference nilled out so that it can be collected.  With
previous WeakArrays, the descriptor gets collected before you find out that it
was destroyed, so you have to keep the information needed to close the file
in some additional data structure.

Tags: %User

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license
'!


"December 14, 2009 -> 0:35:44"!

! (Delta mirrorFor: #WeakArray) classSide methodsFor: 'initialization' !
initialize

	self startFinalizationProcess! !

"December 14, 2009 -> 0:35:44"!

! (Delta mirrorFor: #WeakArray) classSide methodsFor: 'instance creation' !
new: size <Int>

	self startFinalizationProcess.
	^(super new: size)
		initialize;
		yourself! !

"December 14, 2009 -> 0:35:44"!

! (Delta mirrorFor: #WeakArray) classSide methodsFor: 'private-finalization' !
checkNotification
	[ 
		{{primitiveNotificationQueueGetIfFail: [ :err |^self]}}  notify.
	] repeat.! !

"December 14, 2009 -> 0:35:44"!

! (Delta mirrorFor: #WeakArray) classSide methodsFor: 'private-finalization' !
finalizationBlock

	^[[[self checkNotification]
			on: Error
			do: [:error| self handleFinalizationError: error] .
		self finalizationSemaphore wait] repeat]! !

"December 14, 2009 -> 0:35:44"!

! (Delta mirrorFor: #WeakArray) classSide methodsFor: 'private-finalization' !
finalizationPriority

	"%TODO revisit once Process prioritization implemented"
	^Processor activePriority! !

"December 14, 2009 -> 0:35:44"!

! (Delta mirrorFor: #WeakArray) classSide methodsFor: 'private-finalization' !
finalizationProcess

	^FinalizationProcess! !

"December 14, 2009 -> 0:35:44"!

! (Delta mirrorFor: #WeakArray) classSide methodsFor: 'private-finalization' !
finalizationSemaphore

	self initFinalizationSemaphore.
	^FinalizationSemaphore! !

"December 14, 2009 -> 0:35:44"!

! (Delta mirrorFor: #WeakArray) classSide methodsFor: 'private-finalization' !
handleFinalizationError: error

	FinalizationProcess := nil.
	error pass! !

"December 14, 2009 -> 0:35:44"!

! (Delta mirrorFor: #WeakArray) classSide methodsFor: 'private-finalization' !
hasFinalizationProcess

	^self finalizationProcess notNil
		and: [self finalizationProcess running]! !

"December 14, 2009 -> 0:35:44"!

! (Delta mirrorFor: #WeakArray) classSide methodsFor: 'private-finalization' !
initFinalizationSemaphore

	FinalizationSemaphore isNil
		ifTrue: [FinalizationSemaphore := Semaphore new]! !

"December 14, 2009 -> 0:35:44"!

! (Delta mirrorFor: #WeakArray) classSide methodsFor: 'private-finalization' !
startFinalizationProcess

	self hasFinalizationProcess ifTrue: [^self].
	self terminateFinalizationProcess.
	self initFinalizationSemaphore.
	FinalizationProcess := self finalizationBlock forkAt: self finalizationPriority! !

"December 14, 2009 -> 0:35:44"!

! (Delta mirrorFor: #WeakArray) classSide methodsFor: 'private-finalization' !
terminateFinalizationProcess

	true ifTrue: [^self]. "%TODO remove when stack overflow issue fixed"
	self finalizationProcess notNil
		ifTrue: [[self finalizationProcess terminate]
						on: Error
						do: [:ignore|]]! !

"December 14, 2009 -> 0:35:44"!

! (Delta mirrorFor: #WeakArray) classSide methodsFor: 'restricted to VM-finalization' !
signalFinalization

	self finalizationSemaphore waitWouldBlock
		ifTrue: [self finalizationSemaphore signal]! !

"December 14, 2009 -> 0:35:45"!

! (Delta mirrorFor: #WeakArray) methodsFor: 'notification' !
hadNearDeathExperience: anObject
	^{{primitiveHadNearDeathExperience: anObject}}! !

"December 14, 2009 -> 0:35:45"!

! (Delta mirrorFor: #WeakArray) methodsFor: 'notification' !
notify
	1 to: self size do: [ :index |
		| victim |
		(self hadNearDeathExperience: (victim := self at: index)) ifTrue: [
			self at: index put: nil.
			dependents changed: #finalize with: victim
		]
	]! !

"December 14, 2009 -> 0:35:45"!

! (Delta mirrorFor: #WeakArray) methodsFor: 'private-initialization' !
initialize

	dependents := NotifyingObject new! !

"December 14, 2009 -> 0:35:45"!

! (Delta mirrorFor: #WeakArray) methodsFor: 'weak dependents' !
addWeakDependent: dependent

	dependents addDependent: dependent! !

"December 14, 2009 -> 0:35:45"!

! (Delta mirrorFor: #WeakArray) methodsFor: 'weak dependents' !
removeWeakDependent: dependent

	dependents removeDependent: dependent! !

"December 14, 2009 -> 0:35:52"!

Delta define: #WeakArrayTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"December 14, 2009 -> 0:35:52"!

(Delta mirrorFor: #WeakArrayTest)
comment: 
''!


"December 14, 2009 -> 0:35:52"!

! (Delta mirrorFor: #WeakArrayTest) methodsFor: 'testing' !
testNotifiesWeakDependentOnObjectDeath

| array object dependent victim |
object := Object new.
dependent := BlockDependent updateBlock: [:aspect :object | victim := object].
array := WeakArray new: 1.
array at: 1 put: object.
array addWeakDependent: dependent.
VM collectGarbage.
self assert: victim isNil description: 'victim should still have references'.
object := nil.
VM collectGarbage.
Processor yield.
self deny: victim isNil description: 'victim not dying'! !

"December 14, 2009 -> 0:36:3"!

Delta define: #FinalizationDependent as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"December 14, 2009 -> 0:36:3"!

(Delta mirrorFor: #FinalizationDependent)
comment: 
'A dependent that can be registered with a WeakArray
instance to receive notification about terminal objects.
'!


"December 14, 2009 -> 0:36:3"!

! (Delta mirrorFor: #FinalizationDependent) methodsFor: 'dependencies' !
update: aspect with: victim

	#finalize == aspect ifFalse: [^self].
	victim finalize! !

"December 14, 2009 -> 0:36:10"!

Delta define: #FinalizationNotifier as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"December 14, 2009 -> 0:36:10"!

(Delta mirrorFor: #FinalizationNotifier)
comment: 
''!


"December 14, 2009 -> 0:36:10"!

! (Delta mirrorFor: #FinalizationNotifier) methodsFor: 'restricted-finalization' !
finalize

	Transcript cr; print: self! !

"December 14, 2009 -> 0:36:21"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore ScavengeCount AllocFailureCount') !


"December 14, 2009 -> 0:36:21"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore ScavengeCount AllocFailureCount') !


"December 14, 2009 -> 0:36:21"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore ScavengeCount AllocFailureCount') !


"December 14, 2009 -> 0:36:21"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore ScavengeCount AllocFailureCount') !


"December 14, 2009 -> 0:36:21"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore ScavengeCount AllocFailureCount') !


"December 14, 2009 -> 0:36:21"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore ScavengeCount AllocFailureCount') !


"December 14, 2009 -> 0:36:21"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore ScavengeCount AllocFailureCount') !


"December 14, 2009 -> 0:36:21"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore ScavengeCount AllocFailureCount') !


"December 14, 2009 -> 0:36:21"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore ScavengeCount AllocFailureCount') !


"December 14, 2009 -> 0:36:21"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore ScavengeCount AllocFailureCount') !


"December 14, 2009 -> 0:36:21"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore ScavengeCount AllocFailureCount') !


"December 14, 2009 -> 0:36:21"!

(Delta mirrorFor: #VM)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"December 14, 2009 -> 0:36:21"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: class

	^{{primitiveNew: class
			tenured: false
			ifFail: [:e| self handleNew: class failure: e]}}! !

"December 14, 2009 -> 0:36:21"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: indexableClass size: size

	^{{primitiveIndexedObjectNew: indexableClass
			size: size
			tenured: false
			ifFail: [:e| self handleNew: indexableClass
										size: size
										failure: e]}}! !

"December 14, 2009 -> 0:36:21"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
newBytes: byteClass size: size

	^{{primitiveIndexedByteNew: byteClass
			size: size
			tenured: false
			ifFail: [:e| self handleNewBytes: byteClass
										size: size
										failure: e]}}! !

"December 14, 2009 -> 0:36:21"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
newDoubleBytes: doubleByteClass size: size

	^{{primitiveIndexedDoubleByteNew: doubleByteClass
			size: size
			tenured: false
			ifFail: [:e| self handleNewDoubleBytes: doubleByteClass
										size: size
										failure: e]}}! !

"December 14, 2009 -> 0:36:21"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'benchmarking' !
benchmarkNew: iterations

	|elapsed|
	self resetProfiler.
	self engageProfiler.
	elapsed := Time millisecondsToRun: [
								VM privateBenchmarkNew: iterations].
	self disengageProfiler.
	self printProfile.
	Transcript cr; show: elapsed printString.! !

"December 14, 2009 -> 0:36:21"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'benchmarking' !
benchmarkNewNew: iterations

	|elapsed|
	self resetProfiler.
	self engageProfiler.
	self resetAllocCounts.
	elapsed := Time millisecondsToRun: [
								VM privateBenchmarkNewNew: iterations].
	self disengageProfiler.
	self printProfile.
	Transcript cr; show: elapsed printString.
	Transcript cr; show: self allocFailures printString! !

"December 14, 2009 -> 0:36:21"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'benchmarking' !
privateBenchmarkNew: iterations

	iterations timesRepeat: [Object new3]! !

"December 14, 2009 -> 0:36:21"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'benchmarking' !
privateBenchmarkNewNew: iterations

	iterations timesRepeat: [VM new: Object]! !

"December 14, 2009 -> 0:36:21"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'boolean flags' !
compiledCodeOnly: value <True|False>
	self booleanAt: #CompiledCodeOnly put: value! !

"December 14, 2009 -> 0:36:21"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'boolean flags' !
traceDoubleByteArrayPrimitives: value <True|False>
	self booleanAt: #TraceDoubleByteArrayPrims put: value! !

"December 14, 2009 -> 0:36:21"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'boolean flags' !
traceProxyPrimitives: value <True|False>
	self booleanAt: #TraceProxyPrims put: value! !

"December 14, 2009 -> 0:36:21"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'boolean flags' !
useInliningDatabase ^<Boolean>

	^VM booleanAt: #UseInliningDatabase! !

"December 14, 2009 -> 0:36:21"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'boolean flags' !
useInliningDatabase: f <Boolean>

	VM booleanAt: #UseInliningDatabase put: f! !

"December 14, 2009 -> 0:36:21"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'boolean flags' !
wizardMode ^<True|False>
	^self booleanAt: #WizardMode! !

"December 14, 2009 -> 0:36:21"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'boolean flags' !
wizardMode: value <True|False>
	self booleanAt: #WizardMode put: value! !

"December 14, 2009 -> 0:36:21"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'debugging' !
invocationCounterLimit ^ <Int>

	^{{primitiveInterpreterInvocationCounterLimit}}! !

"December 14, 2009 -> 0:36:21"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'debugging' !
invocationCounterLimit: limit <Int>

	{{primitiveSetInterpreterInvocationCounterLimitTo: limit
		ifFail: [ :err <Symbol> | self error: err ]}}! !

"December 14, 2009 -> 0:36:21"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'debugging' !
printCompilation ^<Boolean>

	^self vmFlagAt: #PrintCompilation! !

"December 14, 2009 -> 0:36:21"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'debugging' !
printCompilation: flag <Boolean>

	self vmFlagAt: #PrintCompilation put: flag! !

"December 14, 2009 -> 0:36:21"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'debugging' !
printInlining ^<Boolean>

	^self vmFlagAt: #PrintInlining! !

"December 14, 2009 -> 0:36:21"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'debugging' !
printInlining: flag <Boolean>

	flag
		ifTrue: [ self printCompilation: flag. ].
	self vmFlagAt: #PrintInlining put: flag! !

"December 14, 2009 -> 0:36:21"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'debugging' !
printScavenge ^<Boolean>

	^self vmFlagAt: #PrintScavenge! !

"December 14, 2009 -> 0:36:21"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'debugging' !
printScavenge: flag <Boolean>

	self vmFlagAt: #PrintScavenge put: flag! !

"December 14, 2009 -> 0:36:21"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'debugging' !
printZone

	{{primitivePrintZone}}! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'debugging' !
recompilation ^<Boolean>

	^self vmFlagAt: #UseRecompilation! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'debugging' !
recompilation: flag <Boolean>

	self vmFlagAt: #UseRecompilation put: flag! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
collectGarbage

	{{self primitiveGarbageCollect}}.
	WeakArray signalFinalization! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
deferredGC

	GCSemaphore := Semaphore new.
	[self collectGarbage.
	GCSemaphore signal] fork! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
initializeGCProcess

GCProcess := [| delay |
							delay := Delay forMilliseconds: 500.
							[delay wait.
							VM objectMemorySize > 0.95
								ifTrue: [VM collectGarbage]] repeat] fork! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
isGCPending

	^GCSemaphore notNil! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
needsNewGCProcess

	^GCProcess isNil
		or: [(GCProcess running
					or: [GCProcess suspended]) not]! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
objectMemorySize

	^{{self primitiveObjectMemorySize}}! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
scavengeGarbage
	"Collect very recent garbage.  This is fast, but does not collect all garbage.
		(i.e. it scavenges the object nursery) "

	{{self primitiveScavenge}}.
	WeakArray signalFinalization! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
startGCProcess

	self needsNewGCProcess
		ifTrue: [self initializeGCProcess]! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
stopGCProcess

	self needsNewGCProcess
		ifFalse: [GCProcess terminate]! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
waitForGC

	GCSemaphore isNil
		ifTrue: [self deferredGC]
		ifFalse:[GCSemaphore wait.
					GCSemaphore := nil]! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'integer flags' !
numberOfBlockAllocations
	^self smallIntegerAt: #NumberOfBlockAllocations! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'integer flags' !
numberOfContextAllocations
	^self smallIntegerAt: #NumberOfContextAllocations! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'integer flags' !
survivorSpaceSize

	^(self smallIntegerAt: #SurvivorSize) * 1024! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'integer operations' !
numberOfMethodInvocations
	^{{primitiveNumberOfMethodInvocations}}! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'integer operations' !
numberOfNMethodInvocations
	^{{primitiveNumberOfNMethodInvocations}}! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'lookup' !
numberOfLookupCacheMisses
	"Number of lookups that missed both the primary and secondary lookup cache"
	^{{primitiveNumberOfLookupCacheMisses}}! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'lookup' !
numberOfPrimaryLookupCacheHits
	"Number of lookups where the result were located in the primary cache"
	^{{primitiveNumberOfPrimaryLookupCacheHits}}! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'lookup' !
numberOfSecondaryLookupCacheHits
	"Number of lookups where the result were located in the secondary cache"
	^{{primitiveNumberOfPrimaryLookupCacheHits}}! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private' !
booleanAt: name <Symbol> ^<SmallInteger>
	^{{primitiveBooleanFlagAt: name ifFail: [:err | self error: self]}}! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private' !
booleanAt: name <Symbol> put: value <True|False> ^<SmallInteger>
	^{{primitiveBooleanFlagAt: name put: value ifFail: [:err | self error: err]}}! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private' !
error: msg <Symbol> ^ <Boolean>
	"ignore flags that are not defined in product version"
	^ false! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private' !
smallIntegerAt: name <Symbol> ^<SmallInteger>
	^{{primitiveSmallIntegerFlagAt: name ifFail: [:err | self error: self]}}! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private' !
smallIntegerAt: name <Symbol> put: value <SmallInteger> ^<SmallInteger>
	^{{primitiveSmallIntegerFlagAt: name put: value  ifFail: [:err | self error: self]}}! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private' !
vmFlagAt: name <Symbol>  ^<Boolean>

	^{{primitiveBooleanFlagAt: name
			ifFail: [ :err <Symbol> | self error: err ]}}! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private' !
vmFlagAt: name <Symbol> put:  flag <Boolean>

	{{primitiveBooleanFlagAt: name put: flag
			ifFail: [ :err <Symbol> | self error: err ]}}! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
K

	^1024! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
allocFailures

	^AllocFailureCount! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
allocate: allocateBlock ifExpand: expansionBlock

	^allocateBlock
			value: false
			value: [:e|
							self reportNonAllocationFailure: e.
							self spaceToScavenge
									ifTrue: [self scavengeAndAllocate: allocateBlock
															ifExpand: expansionBlock]
									ifFalse: [self collectAndAllocate: allocateBlock
															ifExpand: expansionBlock]]! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
canScavenge

	^{{primitiveCanScavenge}}! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
collectAndAllocate: allocateBlock ifExpand: expansionBlock

	self collectIfPossible.
	self growIfNecessary.
	^[allocateBlock
			value: false
			value: [:e|
						self reportNonAllocationFailure: e.
						allocateBlock
							value: true
							value: [:e1|
										self reportNonAllocationFailure: e1.
										expansionBlock value.
										allocateBlock
											value: true
											value: [:e2| nil error: e2]]]]
			ensure: [self shrinkIfPossible]! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
collectIfPossible

	self canScavenge
		ifTrue: [self collectGarbage]! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
expand

	|expansionSize|
	expansionSize := (self smallIntegerAt: #ObjectHeapExpandSize) * self K.
	self expand: expansionSize! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
expand: expansionSize

	{{primitiveExpandMemory: expansionSize}}! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
expand: class size: size

	|nonIndexableSizeInOops|
	nonIndexableSizeInOops := self fixedSize: class.
	self expand: (nonIndexableSizeInOops + size) * self oopSize! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
expandBytes: class size: size

	|nonIndexableSizeInOops|
	nonIndexableSizeInOops := self fixedSize: class.
	self expand: (nonIndexableSizeInOops * self oopSize + size)! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
expandDoubleBytes: class size: size

	|nonIndexableSizeInOops|
	nonIndexableSizeInOops := self fixedSize: class.
	self expand: (nonIndexableSizeInOops * self oopSize + (size * 2))! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
expansionCount

	^ {{primitiveExpansions}}! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
expansionSize

	^(self smallIntegerAt: #ObjectHeapExpandSize) * self K! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
fixedSize: class

	^ {{primitiveBehaviorNonIndexableSizeOf: class ifFail: [:err| nil error: err]}} + 1! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
freeSpace

	^{{primitiveFreeSpace}}! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
growBarrier

	^(self smallIntegerAt: #ObjectHeapExpandSize) * VM K! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
growIfNecessary

	self freeSpace < self growBarrier
		ifTrue: [self expand]! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
handleFailure: error allocate: allocateBlock ifExpand: expansionBlock

	self reportNonAllocationFailure: error.
	^self spaceToScavenge
				ifTrue: [self scavengeAndAllocate: allocateBlock
										ifExpand: expansionBlock]
				ifFalse: [self collectAndAllocate: allocateBlock
										ifExpand: expansionBlock]! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
handleNew: class failure: error

	self incFailureCount.
	^self handleFailure: error
			allocate: [:tenured :failBlock| self new: class tenured: tenured ifFail: failBlock]
			ifExpand: [self expand]! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
handleNew: class size: size failure: error

	self incFailureCount.
	^self handleFailure: error
			allocate: [:tenured :failBlock| self new: class size: size tenured: tenured ifFail: failBlock]
			ifExpand: [self expand: class size: size]! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
handleNewBytes: class size: size failure: error

	self incFailureCount.
	^self handleFailure: error
			allocate: [:tenured :failBlock|
								self newBytes: class
										size: size
										tenured: tenured
										ifFail: failBlock]
			ifExpand: [self expandBytes: class size: size]! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
handleNewDoubleBytes: class size: size failure: error

	self incFailureCount.
	^self handleFailure: error
			allocate: [:tenured :failBlock|
								self newDoubleBytes: class
										size: size
										tenured: tenured
										ifFail: failBlock]
			ifExpand: [self expandDoubleBytes: class size: size]! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
incFailureCount

	AllocFailureCount isNil
		ifTrue: [AllocFailureCount := 1]
		ifFalse: [AllocFailureCount := AllocFailureCount + 1]! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
new: class ifFail: failureBlock

	^{{primitiveNew: class
			ifFail: [:e| failureBlock value: e]}}! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
new: class size: size ifFail: failureBlock

	^{{primitiveNew: class
			ifFail: [:e| failureBlock value: e]}}! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
new: class size: size tenured: tenured ifFail: failureBlock

	^{{primitiveIndexedObjectNew: class
			size: size
			tenured: tenured
			ifFail: [:e| failureBlock value: e]}}! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
new: class tenured: tenured ifFail: failureBlock

	^{{primitiveNew: class
			tenured: tenured
			ifFail: [:e| failureBlock value: e]}}! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
newBytes: class size: size tenured: tenured ifFail: failureBlock

	^{{primitiveIndexedByteNew: class
			size: size
			tenured: tenured
			ifFail: [:e| failureBlock value: e]}}! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
newDoubleBytes: class size: size tenured: tenured ifFail: failureBlock

	^{{primitiveIndexedDoubleByteNew: class
			size: size
			tenured: tenured
			ifFail: [:e| failureBlock value: e]}}! !

"December 14, 2009 -> 0:36:22"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
oopSize

	^{{primitiveSizeOfOop}}! !

"December 14, 2009 -> 0:36:23"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
reportNonAllocationFailure: errorSymbol

	(errorSymbol == #FailedAllocation)
		ifFalse: [nil error: errorSymbol printString, ' reported during allocation']! !

"December 14, 2009 -> 0:36:23"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
resetAllocCounts

	ScavengeCount := 0.
	AllocFailureCount := 0.! !

"December 14, 2009 -> 0:36:23"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
resetScavengeCount

	ScavengeCount := 0! !

"December 14, 2009 -> 0:36:23"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
scavengeAndAllocate: allocateBlock ifExpand: expansionBlock

	|expansions |
	expansions := self expansionCount.
	self scavengeIfPossible.
	^(expansions ~~ self expansionCount)
			ifTrue: [self collectAndAllocate: allocateBlock
								ifExpand: expansionBlock]
			ifFalse: [allocateBlock
								value: false
								value: [:e1| self reportNonAllocationFailure: e1.
													allocateBlock
															value: true
															value: [:e2| self reportNonAllocationFailure: e2.
																				self collectAndAllocate: allocateBlock
																						ifExpand: expansionBlock]]]! !

"December 14, 2009 -> 0:36:23"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
scavengeIfPossible

	self canScavenge
		ifTrue: [self scavengeGarbage]! !

"December 14, 2009 -> 0:36:23"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
shrink: size

	{{primitiveShrinkMemory: size}}! !

"December 14, 2009 -> 0:36:23"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
shrinkBarrier

	^(self smallIntegerAt: #ObjectHeapExpandSize) * 3 * VM K! !

"December 14, 2009 -> 0:36:23"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
shrinkIfPossible

	self freeSpace > self shrinkBarrier
		ifTrue: [|amountToShrink|
						amountToShrink := self freeSpace - self shrinkBarrier.
						self shrink: amountToShrink]! !

"December 14, 2009 -> 0:36:23"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
spaceToScavenge

	^self freeSpace > (2 * self survivorSpaceSize)	! !

"December 14, 2009 -> 0:36:23"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'profiling' !
disengageProfiler

	{{primitiveFlatProfilerDisengage}}.! !

"December 14, 2009 -> 0:36:23"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'profiling' !
engageProfiler

	{{primitiveFlatProfilerEngage: Processor activeProcess ifFail: [:e| nil error: e]}}.! !

"December 14, 2009 -> 0:36:23"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'profiling' !
printProfile

	{{primitiveFlatProfilerPrint}}! !

"December 14, 2009 -> 0:36:23"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'profiling' !
resetProfiler
	{{primitiveFlatProfilerReset}}! !

"December 14, 2009 -> 0:36:23"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'system control' !
quit
	"Terminate the virtual machine"

	{{primitiveQuit}}.! !

"December 14, 2009 -> 0:36:23"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'system control' !
quitUI
	"Terminate the user interface"
	
	{{<user ExternalProxy PostQuitMessage> arg: 0}}.
! !

"December 14, 2009 -> 0:36:23"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'wrappers' !
nmethodHistogram: blk
	{{primitiveClearNMethodCounters}}.
	blk value.
	{{primitivePrintNMethodCounterHistogram: 20 ifFail: [:err | self error: err]}}! !

"December 14, 2009 -> 0:36:23"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'wrappers' !
traceLookupMissesFor: blk <[]>
	|a b c| 
	a := VM numberOfPrimaryLookupCacheHits.
	b := VM numberOfSecondaryLookupCacheHits.
	c := VM numberOfLookupCacheMisses.

	blk  value.

	Transcript
					show:  (VM numberOfPrimaryLookupCacheHits - a) printString; tab
				;	show:  (VM numberOfSecondaryLookupCacheHits - b) printString; tab
				;	show:  (VM numberOfLookupCacheMisses - c) printString; cr.
! !

"December 14, 2009 -> 0:36:52"!

Delta define: #ClassTestIvars123 as: (
(Class subclassOf: 'Object' instanceVariables: 'one' classInstanceVariables: 'two three')) !


"December 14, 2009 -> 0:36:52"!

(Delta mirrorFor: #ClassTestIvars123) removeDefinitionIfFail: [] !


"December 14, 2009 -> 0:37:25"!

"System saved" !
"December 14, 2009 -> 2:17:29"!

! (Delta mirrorFor: #AlienWeakTable) methodsFor: 'initialization' !
initializeWithOwner: anOwner

	accessProtect := Semaphore forMutualExclusion.
	firstUnusedIndex := 1.
	lastUsedIndex := 0.
	weakArray := WeakArray new: 1024.
	strongArray := Array new: 1024.
	owner := anOwner.
	weakArray addWeakDependent: (BlockDependent
															updateBlock: [:aspect :object | self finalizeValues])! !

"December 14, 2009 -> 2:17:40"!

"System saved" !
"December 14, 2009 -> 21:5:36"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testPointer

	self assert: (Alien lookup: 'VirtualQuery' inLibrary: 'kernel32') isPointer! !

"December 14, 2009 -> 21:6:49"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testPointer

	|virtualQuery|
	virtualQuery := (Alien lookup: 'VirtualQuery' inLibrary: 'kernel32').
	self assert: virtualQuery isPointer.
	self deny: virtualQuery address == 0! !

"December 14, 2009 -> 21:10:51"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testPointer

	|virtualQuery result buffer|
	result := Alien newC: 4.
	buffer := Alien newC: 28.
	virtualQuery := (Alien lookup: 'VirtualQuery' inLibrary: 'kernel32').
	self assert: virtualQuery isPointer.
	self deny: virtualQuery address == 0.
	virtualQuery
		primFFICallResult: result
		with: buffer
		with: 28.
	Transcript print: (result asSignedLong)! !

"December 14, 2009 -> 21:12:6"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testPointer

	|virtualQuery result buffer ptr|
	result := Alien newC: 4.
	ptr := Alien forPointer: 0.
	buffer := Alien newC: 28.
	virtualQuery := (Alien lookup: 'VirtualQuery' inLibrary: 'kernel32').
	self assert: virtualQuery isPointer.
	self deny: virtualQuery address == 0.
	virtualQuery
		primFFICallResult: result
		with: buffer
		with: 28.
	Transcript print: (result asSignedLong)! !

"December 14, 2009 -> 21:12:18"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testPointer

	|virtualQuery result buffer ptr|
	result := Alien newC: 4.
	ptr := Alien forPointer: 0.
	buffer := Alien newC: 28.
	virtualQuery := (Alien lookup: 'VirtualQuery' inLibrary: 'kernel32').
	self assert: virtualQuery isPointer.
	self deny: virtualQuery address == 0.
	virtualQuery
		primFFICallResult: result
		with: ptr
		with: buffer
		with: 28.
	Transcript print: (result asSignedLong)! !

"December 14, 2009 -> 21:12:26"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testPointer

	|virtualQuery result buffer ptr|
	result := Alien newC: 4.
	ptr := Alien forPointer: 1.
	buffer := Alien newC: 28.
	virtualQuery := (Alien lookup: 'VirtualQuery' inLibrary: 'kernel32').
	self assert: virtualQuery isPointer.
	self deny: virtualQuery address == 0.
	virtualQuery
		primFFICallResult: result
		with: ptr
		with: buffer
		with: 28.
	Transcript print: (result asSignedLong)! !

"December 14, 2009 -> 21:12:47"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testPointer

	|virtualQuery result buffer ptr|
	result := Alien newC: 4.
	ptr := Alien forPointer: 16r7FFFFFFF.
	buffer := Alien newC: 28.
	virtualQuery := (Alien lookup: 'VirtualQuery' inLibrary: 'kernel32').
	self assert: virtualQuery isPointer.
	self deny: virtualQuery address == 0.
	virtualQuery
		primFFICallResult: result
		with: ptr
		with: buffer
		with: 28.
	Transcript print: (result asSignedLong)! !

"December 14, 2009 -> 21:14:36"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testPointer

	|virtualQuery result buffer ptr getError|
	result := Alien newC: 4.
	ptr := Alien forPointer: 16r7FFFFFFF.
	buffer := Alien newC: 28.
	virtualQuery := (Alien lookup: 'VirtualQuery' inLibrary: 'kernel32').
	getError := (Alien lookup: 'GetLastError' inLibrary: 'kernel32').
	self assert: virtualQuery isPointer.
	self deny: virtualQuery address == 0.
	virtualQuery
		primFFICallResult: result
		with: ptr
		with: buffer
		with: 28.
	Transcript print: (result asSignedLong).
	getError
		primFFICallResult: result.
	Transcript cr; print: (result asSignedLong)! !

"December 14, 2009 -> 21:16:11"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testPointer

	|virtualQuery result buffer ptr getError|
	result := Alien newC: 4.
	ptr := Alien forPointer: 16r7FFFFFFF.
	buffer := Alien newC: 28.
	virtualQuery := (Alien lookup: 'VirtualQuery' inLibrary: 'kernel32').
	getError := (Alien lookup: 'GetLastError' inLibrary: 'kernel32').
	self assert: virtualQuery isPointer.
	self deny: virtualQuery address == 0.
	virtualQuery
		primFFICallResult: result
		with: ptr
		with: buffer
		with: 28.
	Transcript cr; print: (result asSignedLong).
	getError
		primFFICallResult: result.
	Transcript cr; print: (result asSignedLong)! !

"December 14, 2009 -> 21:27:10"!

Delta define: #WeakSetTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"December 14, 2009 -> 21:28:6"!

! (Delta mirrorFor: #WeakSetTest) methodsFor: 'testing' !
testAddShouldAddItemToSet

	| set |
	set := WeakSet new! !

"December 14, 2009 -> 21:28:37"!

(Delta mirrorFor: #WeakSet) removeDefinitionIfFail: [] !


"December 14, 2009 -> 21:28:43"!

Delta define: #WeakSet as: (
(Class subclassOf: 'Set' instanceVariables: '')) !


"December 14, 2009 -> 21:29:58"!

! (Delta mirrorFor: #WeakSet) methodsFor: 'private-computations' !
newTableWithSize: tableSize <Int> ^ <WeakArray[A|Object]>

	^WeakArray[A|Object] new: tableSize! !

"December 14, 2009 -> 21:33:16"!

! (Delta mirrorFor: #WeakSetTest) methodsFor: 'testing' !
testAddShouldAddItemToSet

	| set victim finalizedObject listener dead |
	set := WeakSet new.
	victim := Object new.
	set add: victim.
	self assert: (set includes: victim).
	listener := BlockDependent
						updateBlock: [:aspect :obj | dead := obj].
	set addWeakDependent: listener.
	victim := nil.
	VM collectGarbage.
	Processor yield! !

"December 14, 2009 -> 21:34:22"!

! (Delta mirrorFor: #WeakSet) methodsFor: 'weak dependents' !
addWeakDependent: dependent! !

"December 14, 2009 -> 21:34:44"!

! (Delta mirrorFor: #WeakSetTest) methodsFor: 'testing' !
testAddShouldAddItemToSet

	| set victim finalizedObject listener dead |
	set := WeakSet new.
	victim := Object new.
	set add: victim.
	self assert: (set includes: victim).
	listener := BlockDependent
						updateBlock: [:aspect :obj | dead := obj].
	set addWeakDependent: listener.
	victim := nil.
	VM collectGarbage.
	Processor yield.
	self deny: dead isNil! !

"December 14, 2009 -> 21:35:11"!

Delta define: #WeakSet as: (
(Class subclassOf: 'Set' instanceVariables: 'dependents <NotifyingObject>
')) !


"December 14, 2009 -> 21:35:28"!

! (Delta mirrorFor: #WeakSet) methodsFor: 'weak dependents' !
addWeakDependent: dependent

	dependents addDependent: dependent! !

"December 14, 2009 -> 21:37:14"!

Delta define: #WeakSet as: (
(Class subclassOf: 'Set' instanceVariables: 'dependents <NotifyingObject>
tableDependent <BlockDependent>
')) !


"December 14, 2009 -> 21:39:37"!

! (Delta mirrorFor: #WeakSet) methodsFor: 'private-initialization' !
initCapacity: cap <Int>

	dependents := NotifyingObject new.
	tableDependent := BlockDependent
										updateBlock: [:aspect :victim |
																dependents
																	changed: #finalize
																	with: victim]! !

"December 14, 2009 -> 21:40:13"!

! (Delta mirrorFor: #WeakSet) methodsFor: 'private-initialization' !
initCapacity: cap <Int>

	dependents := NotifyingObject new.
	tableDependent := BlockDependent
										updateBlock: [:aspect :victim |
																dependents
																	changed: #finalize
																	with: victim].
	super initCapacity: cap! !

"December 14, 2009 -> 21:41:12"!

! (Delta mirrorFor: #WeakSet) methodsFor: 'private-accessing' !
table: newTable <WeakArray[A|Object]>

	self table isNil
		ifFalse: [self table removeWeakDependent: tableDependent].
	newTable addWeakDependent: tableDependent! !

"December 14, 2009 -> 21:43:15"!

! (Delta mirrorFor: #WeakSet) methodsFor: 'private-accessing' !
table: newTable <WeakArray[A|Object]>

	self table isNil
		ifFalse: [self table removeWeakDependent: tableDependent].
	newTable addWeakDependent: tableDependent.
	super table: newTable! !

"December 14, 2009 -> 21:44:21"!

! (Delta mirrorFor: #WeakSetTest) methodsFor: 'testing' !
testAddShouldAddItemToSet

	| set victim finalizedObject listener dead |
	set := WeakSet new.
	victim := Object new.
	set add: victim.
	self assert: (set includes: victim).
	listener := BlockDependent
						updateBlock: [:aspect :obj | dead := obj].
	set addWeakDependent: listener.
	victim := nil.
	VM collectGarbage.
	Processor yield.
	self deny: dead isNil.
	self deny: (set includes: dead)! !

"December 14, 2009 -> 21:44:45"!

! (Delta mirrorFor: #WeakSetTest) methodsFor: 'testing' !
testAddShouldAddItemToSet

	| set victim finalizedObject listener dead |
	set := WeakSet new.
	victim := Object new.
	set add: victim.
	self assert: (set includes: victim).
	listener := BlockDependent
						updateBlock: [:aspect :obj | dead := obj].
	set addWeakDependent: listener.
	victim := nil.
	VM collectGarbage.
	Processor yield.
	self deny: dead isNil.
	self deny: (set includes: dead).
	set add: dead.
	self assert: (set includes: dead)! !

"December 14, 2009 -> 21:46:9"!

! (Delta mirrorFor: #WeakSetTest) methodsFor: 'testing' !
testRemovedWeakDependentShouldNotReceiveUpdate

	| set victim finalizedObject listener dead |
	set := WeakSet new.
	victim := Object new.
	set add: victim.
	self assert: (set includes: victim).
	listener := BlockDependent
						updateBlock: [:aspect :obj | dead := obj].
	set addWeakDependent: listener.
	set removeWeakDependent: listener.
	victim := nil.
	VM collectGarbage.
	Processor yield.
	self assert: dead isNil! !

"December 14, 2009 -> 21:46:26"!

! (Delta mirrorFor: #WeakSet) methodsFor: 'weak dependents' !
removeWeakDependent: dependent

	dependents removeDependent: dependent! !

"December 14, 2009 -> 21:50:55"!

! (Delta mirrorFor: #WeakSetTest) methodsFor: 'testing' !
testShouldOnlyNotifyOncePerObjectFollowingGrowth

	| set finalizedObject listener dead strong count|
	count := 0.
	set := WeakSet new.
	strong := Set new.
	100 timesRepeat: [|object|
								set add: (object := Object new).
								strong add: object].
	self assert: set size == 100.
	listener := BlockDependent
						updateBlock: [:aspect :obj | count := count + 1].
	set addWeakDependent: listener.
	strong := nil.
	VM collectGarbage.
	Processor yield.
	self assert: count == 100! !

"December 14, 2009 -> 21:51:21"!

! (Delta mirrorFor: #WeakSetTest) methodsFor: 'testing' !
testShouldOnlyNotifyOncePerObjectFollowingGrowth

	| set finalizedObject listener dead strong count|
	count := 0.
	set := WeakSet new.
	strong := Set new.
	100 timesRepeat: [|object|
								set add: (object := Object new).
								strong add: object].
	self assert: set size == 100.
	listener := BlockDependent
						updateBlock: [:aspect :obj | count := count + 1].
	set addWeakDependent: listener.
	strong := nil.
	VM collectGarbage.
	Processor yield.
	self assert: count = 100! !

"December 14, 2009 -> 21:54:51"!

! (Delta mirrorFor: #WeakSetTest) methodsFor: 'testing' !
testShouldOnlyNotifyOncePerObjectFollowingGrowth

	| set finalizedObject listener dead strong count|
	count := 0.
	set := WeakSet new: 4.
	strong := Set new: 4.
	5 timesRepeat: [|object|
								set add: (object := Object new).
								strong add: object].
	self assert: set size = 5.
	listener := BlockDependent
						updateBlock: [:aspect :obj | count := count + 1].
	set addWeakDependent: listener.
	strong := nil.
	VM collectGarbage.
	Processor yield.
	self assert: count = 5! !

"December 14, 2009 -> 21:55:50"!

! (Delta mirrorFor: #WeakSetTest) methodsFor: 'testing' !
add: count <int> to: set <Set>

	count timesRepeat: [set add: Object new]! !

"December 14, 2009 -> 21:56:14"!

! (Delta mirrorFor: #WeakSetTest) methodsFor: 'testing' !
testShouldOnlyNotifyOncePerObjectFollowingGrowth

	| set finalizedObject listener dead strong count|
	count := 0.
	set := WeakSet new: 4.
	strong := Set new: 4.
	self add: 5 to: strong.
	set addAll: strong.
	self assert: set size = 5.
	listener := BlockDependent
						updateBlock: [:aspect :obj | count := count + 1].
	set addWeakDependent: listener.
	strong := nil.
	VM collectGarbage.
	Processor yield.
	self assert: count = 5! !

"December 14, 2009 -> 21:56:40"!

! (Delta mirrorFor: #WeakSetTest) methodsFor: 'testing' !
testShouldOnlyNotifyOncePerObjectFollowingGrowth

	| set finalizedObject listener dead strong count|
	count := 0.
	set := WeakSet new: 4.
	strong := Set new: 4.
	self add: 5 to: strong.
	set addAll: strong.
	self assert: set size = 5.
	listener := BlockDependent
						updateBlock: [:aspect :obj | count := count + 1].
	set addWeakDependent: listener.
	strong := nil.
	VM collectGarbage.
	Processor yield.
	self assert: count = 5.
	self assert: set size = 0! !

"December 14, 2009 -> 21:58:34"!

! (Delta mirrorFor: #WeakSet) methodsFor: 'private-initialization' !
initCapacity: cap <Int>

	dependents := NotifyingObject new.
	tableDependent := BlockDependent
										updateBlock: [:aspect :victim |
																self size: self size - 1.
																dependents
																	changed: #finalize
																	with: victim].
	super initCapacity: cap! !

"December 14, 2009 -> 22:5:22"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testNewGCUnimplemented

	|gcAlien weak res|
	gcAlien := Alien newGC: 4.
	weak := WeakSet new.
	weak add: gcAlien.
	weak addWeakDependent: (BlockDependent updateBlock: [:a :dead| res := dead]).
	self deny: gcAlien address = 0.
	gcAlien := nil.
	VM collectGarbage.
	Processor yield.
	self deny: res isNil.
	self assert: res address = 0! !

"December 14, 2009 -> 22:6:46"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'private - accessing' !
gcMallocedAliens ^<WeakSet>

	GCMallocedAliens isNil ifTrue: [GCMallocedAliens := WeakSet new].
	^GCMallocedAliens! !

"December 14, 2009 -> 22:8:38"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'private - accessing' !
gcMallocedAliens ^<WeakSet>

	GCMallocedAliens isNil
		ifTrue: [GCMallocedAliens := WeakSet new.
					GCMallocedAliens addWeakDependent: (BlockDependent update: [:aspect :alien| alien primFree])].
	^GCMallocedAliens! !

"December 14, 2009 -> 22:9:3"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
newGC: size <Integer> ^<X>

	| alien address |
	alien := self primitiveNew: 8.
	alien size: size negated.
	address := self Ccalloc: size.
	self gcMallocedAliens add: alien.
	^alien
		addressField: address;
		initialize
		! !

"December 14, 2009 -> 22:11:50"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'private - accessing' !
gcMallocedAliens ^<WeakSet>

	GCMallocedAliens isNil
		ifTrue: [GCMallocedAliens := WeakSet new.
					GCMallocedAliens addWeakDependent: (BlockDependent update: [:aspect :alien| alien free])].
	^GCMallocedAliens! !

"December 14, 2009 -> 22:12:7"!

(Delta mirrorFor: #AlienClassTest) removeMethod: #testPointer ifAbsent: [] !


"December 14, 2009 -> 22:37:47"!

(Delta mirrorFor: #GCMallocedAlient) removeDefinitionIfFail: [] !


"December 14, 2009 -> 22:42:19"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'private - accessing' !
gcMallocedAliens ^<WeakSet>

	GCMallocedAliens isNil
		ifTrue: [GCMallocedAliens := WeakSet new.
					GCMallocedAliens addWeakDependent: (
						BlockDependent update: [:aspect :alien|
																[alien free]
																	on: Error
																	do: [:err| Transcript cr; print: err]])].
	^GCMallocedAliens! !

"December 14, 2009 -> 22:43:7"!

(Delta mirrorFor: #GCMallocedAlienst) removeDefinitionIfFail: [] !


"December 14, 2009 -> 22:43:44"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'private - accessing' !
gcMallocedAliens ^<WeakSet>

	GCMallocedAliens isNil
		ifTrue: [GCMallocedAliens := WeakSet new.
					GCMallocedAliens addWeakDependent: (
						BlockDependent update: [:aspect :alien|
																[Transcript cr; show: 'freeing alien'.
																alien free]
																	on: Error
																	do: [:err| Transcript cr; print: err]])].
	^GCMallocedAliens! !

"December 14, 2009 -> 22:48:32"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'private - accessing' !
gcMallocedAliens ^<WeakSet>

	GCMallocedAliens isNil
		ifTrue: [GCMallocedAliens := WeakSet new.
					GCMallocedAliens addWeakDependent: (
						BlockDependent updateBlock: [:aspect :alien|
																[Transcript cr; show: 'freeing alien'.
																alien free]
																	on: Error
																	do: [:err| Transcript cr; print: err]])].
	^GCMallocedAliens! !

"December 14, 2009 -> 22:51:51"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testNewGCUnimplemented

	|gcAlien weak res|
	gcAlien := Alien newGC: 4.
	weak := WeakSet new.
	weak add: gcAlien.
	weak addWeakDependent: (BlockDependent updateBlock: [:a :dead| res := dead]).
	self deny: gcAlien address = 0.
	gcAlien := nil.
	VM collectGarbage.
	(Delay forMilliseconds: 10) wait.
	self deny: res isNil.
	self assert: res address = 0! !

"December 14, 2009 -> 22:52:44"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'private - accessing' !
gcMallocedAliens ^<WeakSet>

	GCMallocedAliens isNil
		ifTrue: [GCMallocedAliens := WeakSet new.
					GCMallocedAliens addWeakDependent: (
						BlockDependent updateBlock: [:aspect :alien | alien free])].
	^GCMallocedAliens! !

"December 14, 2009 -> 22:53:32"!

! (Delta mirrorFor: #AlienClassTest) methodsFor: 'testing' !
testNewGCShouldBeFreedAfterGC

	|gcAlien weak res|
	gcAlien := Alien newGC: 4.
	weak := WeakSet new.
	weak add: gcAlien.
	weak addWeakDependent: (BlockDependent updateBlock: [:a :dead| res := dead]).
	self deny: gcAlien address = 0.
	gcAlien := nil.
	VM collectGarbage.
	(Delay forMilliseconds: 10) wait.
	self deny: res isNil.
	self assert: res address = 0! !

"December 14, 2009 -> 22:53:37"!

(Delta mirrorFor: #AlienClassTest) removeMethod: #testNewGCUnimplemented ifAbsent: [] !


"December 14, 2009 -> 23:1:35"!

"System saved" !
"December 19, 2009 -> 17:42:59"!

Delta define: #Top as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"December 19, 2009 -> 17:42:59"!

! (Delta mirrorFor: #ClassVMMirror) methodsFor: 'accessing' !
superclass: class <Class> 
	
{{primitiveSetSuperClassOf: self reflectee
	toClass: class
	ifFail: [:err| self error: 'Unable to change superclass of ', self name, ' to ', class name]}}
! !

"December 19, 2009 -> 17:42:59"!

! (Delta mirrorFor: #ClassVMMirror) methodsFor: 'accessing' !
superclass: class <Class> 
	
{{primitiveSetSuperClassOf: self reflectee
	toClass: class
	ifFail: [:err| |name|
				class isNil
					ifTrue: [name := nil]
					ifFalse: [name := class name].
				self error: 'Unable to change superclass of ', self name, ' to ', name]}}
! !

"December 19, 2009 -> 17:42:59"!

! (Delta mirrorFor: #ClassVMMirror) methodsFor: 'accessing' !
superclass: class <Class> 
	
{{primitiveSetSuperclassOf: self reflectee
	toClass: class
	ifFail: [:err| |name|
				class isNil
					ifTrue: [name := nil]
					ifFalse: [name := class name].
				self error: 'Unable to change superclass of ', self name, ' to ', name]}}
! !

"December 19, 2009 -> 17:42:59"!

! (Delta mirrorFor: #ClassVMMirror) methodsFor: 'accessing' !
superclassDepth ^ <Integer>

"Return the classes depth in the hierarchy"

^self superclass isNil
   ifTrue:[0]
   ifFalse:[self superclass depth]
               

! !

"December 19, 2009 -> 17:42:59"!

! (Delta mirrorFor: #ClassVMMirror) methodsFor: 'accessing' !
depth ^ <Integer>

"Return the classes depth in the hierarchy"

^self superclassDepth + 1
               

! !

"December 19, 2009 -> 17:42:59"!

! (Delta mirrorFor: #Top) methodsFor: 'proxy support' !
doesNotUnderstand: message <Message>

	nil error: 'MNU'! !

"December 19, 2009 -> 17:42:59"!

! (Delta mirrorFor: #Top) methodsFor: 'proxy support' !
doesNotUnderstand: message <Message>

	^(MessageNotUnderstood message: message)
			signal! !

"December 19, 2009 -> 17:42:59"!

Delta define: #Top as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"December 19, 2009 -> 17:42:59"!

Delta define: #Top as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"December 19, 2009 -> 17:42:59"!

Delta define: #Top as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"December 19, 2009 -> 17:42:59"!

Delta define: #Top as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"December 19, 2009 -> 17:42:59"!

Delta define: #Top as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"December 19, 2009 -> 17:42:59"!

Delta define: #Top as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"December 19, 2009 -> 17:42:59"!

Delta define: #Top as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"December 19, 2009 -> 17:42:59"!

Delta define: #Top as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"December 19, 2009 -> 17:42:59"!

Delta define: #Top as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"December 19, 2009 -> 17:42:59"!

Delta define: #Top as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"December 19, 2009 -> 17:42:59"!

Delta define: #Top as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"December 19, 2009 -> 17:42:59"!

! (Delta mirrorFor: #ClassVMMirror) methodsFor: 'accessing' !
superclass: class <Class> 
	
{{primitiveSetSuperClassOf: self reflectee
	toClass: class
	ifFail: [:err| self error: 'Unable to change superclass of ', self name, ' to ', class name]}}
! !

"December 19, 2009 -> 17:42:59"!

! (Delta mirrorFor: #ClassVMMirror) methodsFor: 'accessing' !
superclass: class <Class> 
	
{{primitiveSetSuperClassOf: self reflectee
	toClass: class
	ifFail: [:err| |name|
				class isNil
					ifTrue: [name := nil]
					ifFalse: [name := class name].
				self error: 'Unable to change superclass of ', self name, ' to ', name]}}
! !

"December 19, 2009 -> 17:42:59"!

! (Delta mirrorFor: #ClassVMMirror) methodsFor: 'accessing' !
superclass: class <Class> 
	
{{primitiveSetSuperclassOf: self reflectee
	toClass: class
	ifFail: [:err| |name|
				class isNil
					ifTrue: [name := nil]
					ifFalse: [name := class name].
				self error: 'Unable to change superclass of ', self name, ' to ', name]}}
! !

"December 19, 2009 -> 17:42:59"!

! (Delta mirrorFor: #ClassVMMirror) methodsFor: 'accessing' !
superclassDepth ^ <Integer>

"Return the classes depth in the hierarchy"

^self superclass isNil
   ifTrue:[0]
   ifFalse:[self superclass depth]
               

! !

"December 19, 2009 -> 17:42:59"!

! (Delta mirrorFor: #ClassVMMirror) methodsFor: 'accessing' !
depth ^ <Integer>

"Return the classes depth in the hierarchy"

^self superclassDepth + 1
               

! !

"December 19, 2009 -> 17:42:59"!

! (Delta mirrorFor: #Top) methodsFor: 'proxy support' !
doesNotUnderstand: message <Message>

	nil error: 'MNU'! !

"December 19, 2009 -> 17:42:59"!

! (Delta mirrorFor: #Top) methodsFor: 'proxy support' !
doesNotUnderstand: message <Message>

	^(MessageNotUnderstood message: message)
			signal! !

"December 19, 2009 -> 17:42:59"!

! (Delta mirrorFor: #VMMirror) classSide methodsFor: 'instance creation' !
on: o <Object> ^ <VMMirror>

	"This is not object-oriented at all but it keeps the VM reflection system separate."
	| format <Symbol> class <Behavior> |
	class := Reflection classOf: o.
	format := {{primitiveBehaviorVMType: class ifFail: [:e <CompressedSymbol> | self error: e]}}.
	format = #Oops ifTrue: [ ^OopsVMMirror new reflectee: o ].
	format = #SmallInteger ifTrue: [ ^SmallIntegerVMMirror new reflectee: o ].
	format = #Symbol ifTrue: [	^SymbolVMMirror new reflectee: o ].
	format = #Method ifTrue: [ ^MethodVMMirror new reflectee: o ].
	format = #Array ifTrue: [	^ArrayVMMirror new reflectee: o ].
	format = #ByteArray ifTrue: [	^ByteArrayVMMirror new reflectee: o ].
	format = #Block ifTrue: [	^BlockVMMirror new reflectee: o ].
	format = #Context ifTrue: [	^ContextVMMirror new reflectee: o ].
	format = #Process ifTrue: [	^ProcessVMMirror new reflectee: o ].
	format = #Proxy ifTrue: [	^ProxyVMMirror new reflectee: o ].
	format = #Activation ifTrue: [	^ActivationVMMirror new reflectee: o ].
	format = #Mixin ifTrue: [	^MixinVMMirror new reflectee: o ].
	format = #GlobalAssociation ifTrue: [	^GlobalAssociationVMMirror new reflectee: o ].
	format = #Float ifTrue: [ ^FloatVMMirror new reflectee: o ].
	format = #WeakArray ifTrue: [	^WeakArrayVMMirror new reflectee: o ].
	format = #DoubleByteArray ifTrue: [	^DoubleByteArrayVMMirror new reflectee: o ].
	format = #FloatValueArray ifTrue: [	^FloatValueArrayVMMirror new reflectee: o ].
	format = #Class ifTrue: [	
		format := {{primitiveBehaviorVMType: o ifFail: [:e <CompressedSymbol> | self error: e]}}.
		format = #Oops ifTrue: [	^OopsClassVMMirror new reflectee: o ].
		format = #SmallInteger ifTrue: [ ^SmallIntegerClassVMMirror new reflectee: o ].
		format = #Symbol ifTrue: [	^SymbolClassVMMirror new reflectee: o ].
		format = #Method ifTrue: [ ^MethodClassVMMirror new reflectee: o ].
		format = #Array ifTrue: [	^ArrayClassVMMirror new reflectee: o ].
		format = #ByteArray ifTrue: [	^ByteArrayClassVMMirror new reflectee: o ].
		format = #Block ifTrue: [	^BlockClassVMMirror new reflectee: o ].
		format = #Context ifTrue: [	^ContextClassVMMirror new reflectee: o ].
		format = #Process ifTrue: [	^ProcessClassVMMirror new reflectee: o ].
		format = #Proxy ifTrue: [	^ProxyClassVMMirror new reflectee: o ].
		format = #Activation ifTrue: [	^ActivationClassVMMirror new reflectee: o ].
		format = #Mixin ifTrue: [	^MixinClassVMMirror new reflectee: o ].
		format = #GlobalAssociation ifTrue: [	^GlobalAssociationClassVMMirror new reflectee: o ].
		format = #Float ifTrue: [ ^FloatClassVMMirror new reflectee: o ].
		format = #WeakArray ifTrue: [	^WeakArrayClassVMMirror new reflectee: o ].
		format = #DoubleByteArray ifTrue: [	^DoubleByteArrayClassVMMirror new reflectee: o ].
		format = #FloatValueArray ifTrue: [	^FloatValueArrayClassVMMirror new reflectee: o ].
		format = #Class  ifTrue: [	^ClassClassVMMirror new reflectee: o ].
	].
	self shouldNotHappen.
! !

"December 19, 2009 -> 17:42:59"!

! (Delta mirrorFor: #ClassVMMirror) methodsFor: 'accessing' !
superclass: class <Class> 
	
{{primitiveSetSuperClassOf: self reflectee
	toClass: class
	ifFail: [:err| self error: 'Unable to change superclass of ', self name, ' to ', class name]}}
! !

"December 19, 2009 -> 17:42:59"!

! (Delta mirrorFor: #ClassVMMirror) methodsFor: 'accessing' !
superclass: class <Class> 
	
{{primitiveSetSuperClassOf: self reflectee
	toClass: class
	ifFail: [:err| |name|
				class isNil
					ifTrue: [name := nil]
					ifFalse: [name := class name].
				self error: 'Unable to change superclass of ', self name, ' to ', name]}}
! !

"December 19, 2009 -> 17:43:0"!

! (Delta mirrorFor: #ClassVMMirror) methodsFor: 'accessing' !
superclass: class <Class> 
	
{{primitiveSetSuperclassOf: self reflectee
	toClass: class
	ifFail: [:err| |name|
				class isNil
					ifTrue: [name := nil]
					ifFalse: [name := class name].
				self error: 'Unable to change superclass of ', self name, ' to ', name]}}
! !

"December 19, 2009 -> 17:43:0"!

! (Delta mirrorFor: #ClassVMMirror) methodsFor: 'accessing' !
superclassDepth ^ <Integer>

"Return the classes depth in the hierarchy"

^self superclass isNil
   ifTrue:[0]
   ifFalse:[self superclass depth]
               

! !

"December 19, 2009 -> 17:43:0"!

! (Delta mirrorFor: #ClassVMMirror) methodsFor: 'accessing' !
depth ^ <Integer>

"Return the classes depth in the hierarchy"

^self superclassDepth + 1
               

! !

"December 19, 2009 -> 17:43:0"!

! (Delta mirrorFor: #Top) methodsFor: 'proxy support' !
doesNotUnderstand: message <Message>

	nil error: 'MNU'! !

"December 19, 2009 -> 17:43:0"!

! (Delta mirrorFor: #Top) methodsFor: 'proxy support' !
doesNotUnderstand: message <Message>

	^(MessageNotUnderstood message: message)
			signal! !

"December 19, 2009 -> 17:43:0"!

! (Delta mirrorFor: #ClassVMMirror) methodsFor: 'accessing' !
superclass: class <Class> 
	
{{primitiveSetSuperClassOf: self reflectee
	toClass: class
	ifFail: [:err| self error: 'Unable to change superclass of ', self name, ' to ', class name]}}
! !

"December 19, 2009 -> 17:43:0"!

! (Delta mirrorFor: #ClassVMMirror) methodsFor: 'accessing' !
superclass: class <Class> 
	
{{primitiveSetSuperClassOf: self reflectee
	toClass: class
	ifFail: [:err| |name|
				class isNil
					ifTrue: [name := nil]
					ifFalse: [name := class name].
				self error: 'Unable to change superclass of ', self name, ' to ', name]}}
! !

"December 19, 2009 -> 17:43:0"!

! (Delta mirrorFor: #ClassVMMirror) methodsFor: 'accessing' !
superclass: class <Class> 
	
{{primitiveSetSuperclassOf: self reflectee
	toClass: class
	ifFail: [:err| |name|
				class isNil
					ifTrue: [name := nil]
					ifFalse: [name := class name].
				self error: 'Unable to change superclass of ', self name, ' to ', name]}}
! !

"December 19, 2009 -> 17:43:0"!

! (Delta mirrorFor: #ClassVMMirror) methodsFor: 'accessing' !
superclassDepth ^ <Integer>

"Return the classes depth in the hierarchy"

^self superclass isNil
   ifTrue:[0]
   ifFalse:[self superclass depth]
               

! !

"December 19, 2009 -> 17:43:0"!

! (Delta mirrorFor: #ClassVMMirror) methodsFor: 'accessing' !
depth ^ <Integer>

"Return the classes depth in the hierarchy"

^self superclassDepth + 1
               

! !

"December 19, 2009 -> 17:43:0"!

! (Delta mirrorFor: #Top) methodsFor: 'proxy support' !
doesNotUnderstand: message <Message>

	nil error: 'MNU'! !

"December 19, 2009 -> 17:43:0"!

! (Delta mirrorFor: #Top) methodsFor: 'proxy support' !
doesNotUnderstand: message <Message>

	^(MessageNotUnderstood message: message)
			signal! !

"December 19, 2009 -> 17:43:0"!

! (Delta mirrorFor: #VMMirror) classSide methodsFor: 'instance creation' !
on: o <Object> ^ <VMMirror>

	"This is not object-oriented at all but it keeps the VM reflection system separate."
	| format <Symbol> class <Behavior> |
	class := Reflection classOf: o.
	format := {{primitiveBehaviorVMType: class ifFail: [:e <CompressedSymbol> | self error: e]}}.
	format = #Oops ifTrue: [ ^OopsVMMirror new reflectee: o ].
	format = #SmallInteger ifTrue: [ ^SmallIntegerVMMirror new reflectee: o ].
	format = #Symbol ifTrue: [	^SymbolVMMirror new reflectee: o ].
	format = #Method ifTrue: [ ^MethodVMMirror new reflectee: o ].
	format = #Array ifTrue: [	^ArrayVMMirror new reflectee: o ].
	format = #ByteArray ifTrue: [	^ByteArrayVMMirror new reflectee: o ].
	format = #Block ifTrue: [	^BlockVMMirror new reflectee: o ].
	format = #Context ifTrue: [	^ContextVMMirror new reflectee: o ].
	format = #Process ifTrue: [	^ProcessVMMirror new reflectee: o ].
	format = #Proxy ifTrue: [	^ProxyVMMirror new reflectee: o ].
	format = #Activation ifTrue: [	^ActivationVMMirror new reflectee: o ].
	format = #Mixin ifTrue: [	^MixinVMMirror new reflectee: o ].
	format = #GlobalAssociation ifTrue: [	^GlobalAssociationVMMirror new reflectee: o ].
	format = #Float ifTrue: [ ^FloatVMMirror new reflectee: o ].
	format = #WeakArray ifTrue: [	^WeakArrayVMMirror new reflectee: o ].
	format = #DoubleByteArray ifTrue: [	^DoubleByteArrayVMMirror new reflectee: o ].
	format = #FloatValueArray ifTrue: [	^FloatValueArrayVMMirror new reflectee: o ].
	format = #Class ifTrue: [	
		format := {{primitiveBehaviorVMType: o ifFail: [:e <CompressedSymbol> | self error: e]}}.
		format = #Oops ifTrue: [	^OopsClassVMMirror new reflectee: o ].
		format = #SmallInteger ifTrue: [ ^SmallIntegerClassVMMirror new reflectee: o ].
		format = #Symbol ifTrue: [	^SymbolClassVMMirror new reflectee: o ].
		format = #Method ifTrue: [ ^MethodClassVMMirror new reflectee: o ].
		format = #Array ifTrue: [	^ArrayClassVMMirror new reflectee: o ].
		format = #ByteArray ifTrue: [	^ByteArrayClassVMMirror new reflectee: o ].
		format = #Block ifTrue: [	^BlockClassVMMirror new reflectee: o ].
		format = #Context ifTrue: [	^ContextClassVMMirror new reflectee: o ].
		format = #Process ifTrue: [	^ProcessClassVMMirror new reflectee: o ].
		format = #Proxy ifTrue: [	^ProxyClassVMMirror new reflectee: o ].
		format = #Activation ifTrue: [	^ActivationClassVMMirror new reflectee: o ].
		format = #Mixin ifTrue: [	^MixinClassVMMirror new reflectee: o ].
		format = #GlobalAssociation ifTrue: [	^GlobalAssociationClassVMMirror new reflectee: o ].
		format = #Float ifTrue: [ ^FloatClassVMMirror new reflectee: o ].
		format = #WeakArray ifTrue: [	^WeakArrayClassVMMirror new reflectee: o ].
		format = #DoubleByteArray ifTrue: [	^DoubleByteArrayClassVMMirror new reflectee: o ].
		format = #FloatValueArray ifTrue: [	^FloatValueArrayClassVMMirror new reflectee: o ].
		format = #Class  ifTrue: [	^ClassClassVMMirror new reflectee: o ].
	].
	self shouldNotHappen.
! !

"December 19, 2009 -> 17:43:0"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
safePrintString: aValue

	^[aValue printString]
		on: Error
		do: [:ex|'??instance of ', (Reflection classOf: aValue) name]! !

"December 19, 2009 -> 17:43:0"!

! (Delta mirrorFor: #OopsVMMirror) methodsFor: 'printing' !
safePrintString ^ <Str>

	| strm <CharWriteStream> cn <Str> |
	nil == self reflectee ifTrue: [ ^nil printString ].
	true == self reflectee ifTrue: [ ^true printString ].	
	false == self reflectee ifTrue: [ ^false printString ].
	strm := CharacterReadWriteStream on: (String new: 8).
	cn := (Reflection classOf: self reflectee) name.
	strm	nextPutAll: (self articleFor: cn);
				nextPut: Character space;
				nextPutAll: cn.
	^strm contentsWritten
! !

"December 19, 2009 -> 17:43:0"!

! (Delta mirrorFor: #ClassHierarchyOutliner) methodsFor: 'private' !
class: cl <Class> isClassKindOf: othercl <Class> ^<Boolean>

	| up <Class> |
	up := cl.
	[	up = othercl
			ifTrue: [ ^true ].
		up := Class coerce: (up superclassIfAbsent: [ ^false ])
	] repeat! !

"December 19, 2009 -> 17:43:0"!

Delta define: #ErrorCollection as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"December 19, 2009 -> 17:43:0"!

Delta define: #ErrorCollection as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"December 19, 2009 -> 17:43:0"!

Delta define: #ErrorCollection as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"December 19, 2009 -> 17:43:0"!

Delta define: #ErrorCollection as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"December 19, 2009 -> 17:43:0"!

Delta define: #ErrorCollection as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"December 19, 2009 -> 17:43:0"!

Delta define: #ErrorCollection as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"December 19, 2009 -> 17:43:0"!

Delta define: #ErrorCollection as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"December 19, 2009 -> 17:43:0"!

Delta define: #ErrorCollection as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"December 19, 2009 -> 17:43:0"!

Delta define: #ErrorCollection as: (
(Class subclassOf: 'Error' instanceVariables: 'errors <OrderedCollection[Error]>')) !


"December 19, 2009 -> 17:43:0"!

Delta define: #ErrorCollection as: (
(Class subclassOf: 'Error' instanceVariables: 'errors <OrderedCollection[Error]>')) !


"December 19, 2009 -> 17:43:0"!

Delta define: #ErrorCollection as: (
(Class subclassOf: 'Error' instanceVariables: 'errors <OrderedCollection[Error]>')) !


"December 19, 2009 -> 17:43:0"!

Delta define: #ErrorCollection as: (
(Class subclassOf: 'Error' instanceVariables: 'errors <OrderedCollection[Error]>')) !


"December 19, 2009 -> 17:43:0"!

! (Delta mirrorFor: #ErrorCollection) classSide methodsFor: 'instance creation' !
errors: errors <OrderedCollection[Error]>

	^ self new
			errors: errors;
			yourself! !

"December 19, 2009 -> 17:43:0"!

! (Delta mirrorFor: #ErrorCollection) methodsFor: 'private-initialization' !
errors: someErrors <OrderedCollection[Error]>

	errors := OrderedCollection withAll: someErrors! !

"December 19, 2009 -> 17:43:0"!

! (Delta mirrorFor: #ErrorCollection) methodsFor: 'accessing' !
errors

	^errors! !

"December 19, 2009 -> 17:43:0"!

! (Delta mirrorFor: #Inspector) methodsFor: 'private' !
updateNonsafeFields: queue <SharedQueue[Tuple[Int, Str]]>
	"Compute unsafe print stings and push them on queue"
	
	| errors |
	errors := OrderedCollection new.
	[	self oops do: [ :t <Tuple[Int,Object]> |
								[queue nextPut: t at1 ,, (self printOop: t at2)]
									on: Error
									do: [:ex| errors add: ex.
											ex return]].
		errors isEmpty
			ifFalse: [(ErrorCollection errors: errors) signal]
	] ensure:[ 
		queue close ]! !

"December 19, 2009 -> 17:43:0"!

Delta define: #Top as: (
(Class delta)) !


"December 19, 2009 -> 17:43:0"!

! (Delta mirrorFor: #VMMirror) methodsFor: 'accessing' !
reflecteeClassName

	^(Reflection classOf: self reflectee) name! !

"December 19, 2009 -> 17:43:0"!

! (Delta mirrorFor: #Inspector) methodsFor: 'accessing' !
windowTitle ^ <Str>

	^'Inspector on ', self mirror reflecteeClassName! !

"December 19, 2009 -> 17:43:0"!

Delta define: #ClassTestIvars123 as: (
(Class subclassOf: 'Object' instanceVariables: 'one' classInstanceVariables: 'two three')) !


"December 19, 2009 -> 17:43:0"!

(Delta mirrorFor: #ClassTestIvars123) removeDefinitionIfFail: [] !


"December 19, 2009 -> 17:43:59"!

"System saved" !
"December 19, 2009 -> 17:50:51"!

! (Delta mirrorFor: #WeakArray) classSide methodsFor: 'private-finalization' !
finalizationBlock

	^[[[self checkNotification.
		 self finalizationSemaphore wait] repeat]
			on: Error
			do: [:error| self handleFinalizationError: error]]! !

"December 19, 2009 -> 17:51:16"!

! (Delta mirrorFor: #WeakArray) classSide methodsFor: 'private-finalization' !
hasFinalizationProcess

	^self finalizationProcess notNil! !

"December 19, 2009 -> 17:51:39"!

"System saved" !
"December 19, 2009 -> 19:14:33"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
runScript: filename <Str>

	[	| file <FilePath> |
		file := FilePath for: filename.
		file exists
			ifFalse: [	Transcript show: 'Error: script file ''', filename, ''' not found.'; cr.
							^self	].
		file charInputStream fileIn.
		VM quit
	] fork! !

"December 19, 2009 -> 19:14:57"!

"System saved" !
"December 20, 2009 -> 1:0:43"!

! (Delta mirrorFor: #OopsVMMirror) methodsFor: 'accessing' !
instVarAt: index <SmallInt> put: value <Object>

	{{ primitiveInstVarOf: self reflectee
			at: index + self reflectee fileOutHeaderSize
			put: value
			ifFail: [:err | self error: 'Unable to set instance variable, ', index printString, ', of ', self reflectee printString] }}! !

"December 20, 2009 -> 1:0:43"!

! (Delta mirrorFor: #OopsVMMirror) methodsFor: 'accessing' !
instVarAt: index <SmallInt> ^ <Object>

	^self reflectee fileOutInstVarAt: index! !

"December 20, 2009 -> 1:2:33"!

"System saved" !
"December 20, 2009 -> 11:21:41"!

! (Delta mirrorFor: #OopsVMMirror) methodsFor: 'accessing' !
instVarAt: index <SmallInt> ^ <Object>

	^self reflectee fileOutInstVarAt: index + self reflectee fileOutHeaderSize! !

"December 20, 2009 -> 11:21:54"!

"System saved" !
"December 20, 2009 -> 11:36:29"!

! (Delta mirrorFor: #CodeView) methodsFor: 'control' !
showItBlock ^<[]>

	^[| oop <Object> pstr <Str> result <Visual> |
	oop := self computeValueIfFail: [^self].
	pstr := oop printString.
	result := (StringGlyph for: pstr painter: self showItPainter) asVisual withBackdrop: self showItBackdrop.
	result := (PressHandler for: result) onPress: [ (Inspector on: oop) launch ].
	result := (PopUpMenuHandler for: result) menuBlock: [ self showItMenuFor: result text: pstr ].
	self replaceModelFrom: self selectionEnd to: self selectionEnd withGlyphs: (Array[Array[Glyph]] with: (Array[Glyph] with: result)).
	self selection: self selectionEnd ,, self selectionEnd]
! !

"December 20, 2009 -> 11:36:46"!

! (Delta mirrorFor: #CodeView) methodsFor: 'control' !
showIt

	self showItBlock fork
! !

"December 20, 2009 -> 11:38:32"!

! (Delta mirrorFor: #CodeView) methodsFor: 'control' !
inspectItBlock ^ <[]>

	^[(Inspector on: (self computeValueIfFail: [^self])) launch]
! !

"December 20, 2009 -> 11:39:15"!

! (Delta mirrorFor: #CodeView) methodsFor: 'control' !
inspectIt

	self inspectItBlock fork
! !

"December 20, 2009 -> 11:46:5"!

! (Delta mirrorFor: #CodeView) methodsFor: 'control' !
inspectItBlock ^ <[]>

	^[| success result |
		success := true.
		result := self computeValueIfFail: [success := false].
		success ifTrue: [(Inspector on: result) launch]]! !

"December 20, 2009 -> 11:48:16"!

! (Delta mirrorFor: #CodeView) methodsFor: 'control' !
computeValueIfSuccess: block <[X]>

	block value: (self computeValueIfFail: [^self])! !

"December 20, 2009 -> 11:49:9"!

! (Delta mirrorFor: #CodeView) methodsFor: 'control' !
inspectItBlock ^ <[]>

	^[self computeValueIfSuccess: [:result | (Inspector on: result) launch]]! !

"December 20, 2009 -> 11:52:47"!

! (Delta mirrorFor: #CodeView) methodsFor: 'control' !
showItBlock ^<[]>

	^[self computeValueIfSuccess: [:oop | | pstr <Str> result <Visual> |
													pstr := oop printString.
													result := (StringGlyph
																		for: pstr
																		painter: self showItPainter) asVisual
																		withBackdrop: self showItBackdrop.
													result := (PressHandler for: result)
																		onPress: [ (Inspector on: oop) launch ].
													result := (PopUpMenuHandler for: result)
																		menuBlock: [ self showItMenuFor: result text: pstr ].
													self replaceModelFrom: self selectionEnd
															to: self selectionEnd
															withGlyphs: (Array[Array[Glyph]] with: (Array[Glyph] with: result)).
													self selection: self selectionEnd ,, self selectionEnd]]
! !

"December 20, 2009 -> 11:55:3"!

"System saved" !
"December 20, 2009 -> 12:4:36"!

"System saved" !
"December 20, 2009 -> 12:5:29"!

"System saved" !
"December 20, 2009 -> 12:5:36"!

"System saved" !
"December 20, 2009 -> 12:6:24"!

"System saved" !
"December 24, 2009 -> 2:8:46"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file out-private' !
fileOutDefinition: m <Mirror> directory: dir <FilePath> world: w <Str> openGroups: ogs <Dictionary[Str, CharOutputStream]>

	| defStream <CharOutputStream> |
	defStream := CharacterInputOutputConverter on: (dir, (FilePath for: m fileName)) writeStream.
	[ (DefinitionWriter for: m) fileOutOn: defStream ] ensure: [ defStream close ].
	(self groupFor: w directory: dir openGroups: ogs)
		nextPutAll: 'Delta fileInFromFile: ', m fileName printString, ' !!'; cr; flush.
	(self groupFor: m group directory: dir openGroups: ogs)
		nextPutAll: 'Delta fileInFromFile: ', m fileName printString, ' !!'; cr; flush.
! !

"December 24, 2009 -> 2:8:46"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file out-private' !
groupFor: name <Str>  directory: dir <FilePath> openGroups: ogs <Dictionary[Str, CharOutputStream]> ^ <CharOutputStream>

	| file <FilePath> rs <CharInputStream> ws <CharOutputStream> revision <Str> |
	(ws := ogs at: name ifAbsent: [ nil ]) notNil
		ifTrue: [	^ws ].
	file := dir, (FilePath for: (name, self groupFileExtension)).
	file exists
		ifTrue: 	[	rs := file charInputStream.
							[ revision := rs nextChunk ] ensure: [ rs close ] ]
		ifFalse: 	[	revision := self defaultFileoutRevision ].
	ws := file charOutputStream.
	ws nextPut: $"; nextPut: revision; nextPut: $"; cr.
	^ogs at: name put: ws! !

"December 24, 2009 -> 2:8:46"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file out-private' !
groupFor: name <Str>  directory: dir <FilePath> openGroups: ogs <Dictionary[Str, CharOutputStream]> ^ <CharOutputStream>

	| file <FilePath> rs <CharInputStream> ws <CharOutputStream> revision <Str> |
	(ws := ogs at: name ifAbsent: [ nil ]) notNil
		ifTrue: [	^ws ].
	file := dir, (FilePath for: (name, self groupFileExtension)).
	file exists
		ifTrue: 	[	rs := file charInputStream.
							[ revision := rs nextChunk ] ensure: [ rs close ] ]
		ifFalse: 	[	revision := self defaultFileoutRevision ].
	ws := file charOutputStream.
	ws nextPut: $"; nextPutAll: revision; nextPut: $"; cr.
	^ogs at: name put: ws! !

"December 24, 2009 -> 2:8:46"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file out-private' !
fileOutDefinition: m <Mirror> directory: dir <FilePath> world: w <Str> openGroups: ogs <Dictionary[Str, CharOutputStream]>

	| defStream <CharOutputStream> |
	defStream := CharacterInputOutputConverter on: (dir, (FilePath for: m fileName)) writeStream.
	[ (DefinitionWriter for: m) fileOutOn: defStream ] ensure: [ defStream close ].
	(self groupFor: w directory: dir openGroups: ogs)
		nextPutAll: 'Delta fileInFromFile: ', m fileName printString, ' !!'; cr; flush.
	(self groupFor: m group directory: dir openGroups: ogs)
		nextPutAll: 'Delta fileInFromFile: ', m fileName printString, ' !!'; cr; flush.
! !

"December 24, 2009 -> 2:8:46"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file out-private' !
groupFor: name <Str>  directory: dir <FilePath> openGroups: ogs <Dictionary[Str, CharOutputStream]> ^ <CharOutputStream>

	| file <FilePath> rs <CharInputStream> ws <CharOutputStream> revision <Str> |
	(ws := ogs at: name ifAbsent: [ nil ]) notNil
		ifTrue: [	^ws ].
	file := dir, (FilePath for: (name, self groupFileExtension)).
	file exists
		ifTrue: 	[	rs := file charInputStream.
							[ revision := rs nextChunk ] ensure: [ rs close ] ]
		ifFalse: 	[	revision := self defaultFileoutRevision ].
	ws := file charOutputStream.
	ws nextPut: $"; nextPut: revision; nextPut: $"; cr.
	^ogs at: name put: ws! !

"December 24, 2009 -> 2:8:46"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file out-private' !
groupFor: name <Str>  directory: dir <FilePath> openGroups: ogs <Dictionary[Str, CharOutputStream]> ^ <CharOutputStream>

	| file <FilePath> rs <CharInputStream> ws <CharOutputStream> revision <Str> |
	(ws := ogs at: name ifAbsent: [ nil ]) notNil
		ifTrue: [	^ws ].
	file := dir, (FilePath for: (name, self groupFileExtension)).
	file exists
		ifTrue: 	[	rs := file charInputStream.
							[ revision := rs nextChunk ] ensure: [ rs close ] ]
		ifFalse: 	[	revision := self defaultFileoutRevision ].
	ws := file charOutputStream.
	ws nextPut: $"; nextPutAll: revision; nextPut: $"; cr.
	^ogs at: name put: ws! !

"December 24, 2009 -> 2:8:46"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file out-private' !
fileOutDefinition: m <Mirror> directory: dir <FilePath> world: w <Str> openGroups: ogs <Dictionary[Str, CharOutputStream]>

	| defStream <CharOutputStream> |
	defStream := CharacterInputOutputConverter on: (dir, (FilePath for: m fileName)) writeStream.
	[ (DefinitionWriter for: m) fileOutOn: defStream ] ensure: [ defStream close ].
	(self groupFor: w directory: dir openGroups: ogs)
		nextPutAll: 'Delta fileInFromFile: (FilePath for: ', m fileName printString, ') !!'; cr; flush.
	(self groupFor: m group directory: dir openGroups: ogs)
		nextPutAll: 'Delta fileInFromFile: (FilePath for: ', m fileName printString, ') !!'; cr; flush.
! !

"December 24, 2009 -> 2:8:46"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file out-private' !
defaultFileoutRevision ^ <Str>

	^'"$Revi', 'sion:$"'			"Protect string from RCS !!"! !

"December 24, 2009 -> 2:8:46"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file out-private' !
groupFor: name <Str>  directory: dir <FilePath> openGroups: ogs <Dictionary[Str, CharOutputStream]> ^ <CharOutputStream>

	| file <FilePath> rs <CharInputStream> ws <CharOutputStream> revision <Str> |
	(ws := ogs at: name ifAbsent: [ nil ]) notNil
		ifTrue: [	^ws ].
	file := dir, (FilePath for: (name, self groupFileExtension)).
	file exists
		ifTrue: 	[	rs := file charInputStream.
							[ revision := rs nextChunk ] ensure: [ rs close ] ]
		ifFalse: 	[	revision := self defaultFileoutRevision ].
	ws := file charOutputStream.
	ws nextChunkPut: revision; cr.
	^ogs at: name put: ws! !

"December 24, 2009 -> 2:8:46"!

! (Delta mirrorFor: #UnixFilePath) classSide methodsFor: 'instance creation' !
currentDirectory: file <FilePath>

    	| result <Alien> name <Alien> setCurrentDirectory <Alien> |
    	setCurrentDirectory := Alien lookup: 'SetCurrentDirectoryA' inLibrary: 'kernel32.dll'.
    	result := Alien new: 4.
    	name := file name asString asAlien.
    	[setCurrentDirectory
    		primFFICallResult: result
    		with: name pointer.
    	result asBoolean ifFalse: [self error: 'Unable to cd to directory ', file name]]
    		ensure: [name free]
	! !

"December 24, 2009 -> 2:8:46"!

! (Delta mirrorFor: #FilePath) classSide methodsFor: 'instance creation' !
currentDirectory: file <FilePath>

	^Platform pathClass currentDirectory: file! !

"December 24, 2009 -> 2:8:46"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file out-private' !
fileOutDefinition: m <Mirror> directory: dir <FilePath> world: w <Str> openGroups: ogs <Dictionary[Str, CharOutputStream]>

	| defStream <CharOutputStream> |
	defStream := CharacterInputOutputConverter on: (dir, (FilePath for: m fileName)) writeStream.
	[ (DefinitionWriter for: m) fileOutOn: defStream ] ensure: [ defStream close ].
	(self groupFor: w directory: dir openGroups: ogs)
		nextPutAll: 'Delta fileInFromFile: ', m fileName printString, ' !!'; cr; flush.
	(self groupFor: m group directory: dir openGroups: ogs)
		nextPutAll: 'Delta fileInFromFile: ', m fileName printString, ' !!'; cr; flush.
! !

"December 24, 2009 -> 2:8:46"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file out-private' !
groupFor: name <Str>  directory: dir <FilePath> openGroups: ogs <Dictionary[Str, CharOutputStream]> ^ <CharOutputStream>

	| file <FilePath> rs <CharInputStream> ws <CharOutputStream> revision <Str> |
	(ws := ogs at: name ifAbsent: [ nil ]) notNil
		ifTrue: [	^ws ].
	file := dir, (FilePath for: (name, self groupFileExtension)).
	file exists
		ifTrue: 	[	rs := file charInputStream.
							[ revision := rs nextChunk ] ensure: [ rs close ] ]
		ifFalse: 	[	revision := self defaultFileoutRevision ].
	ws := file charOutputStream.
	ws nextPut: $"; nextPut: revision; nextPut: $"; cr.
	^ogs at: name put: ws! !

"December 24, 2009 -> 2:8:46"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file out-private' !
groupFor: name <Str>  directory: dir <FilePath> openGroups: ogs <Dictionary[Str, CharOutputStream]> ^ <CharOutputStream>

	| file <FilePath> rs <CharInputStream> ws <CharOutputStream> revision <Str> |
	(ws := ogs at: name ifAbsent: [ nil ]) notNil
		ifTrue: [	^ws ].
	file := dir, (FilePath for: (name, self groupFileExtension)).
	file exists
		ifTrue: 	[	rs := file charInputStream.
							[ revision := rs nextChunk ] ensure: [ rs close ] ]
		ifFalse: 	[	revision := self defaultFileoutRevision ].
	ws := file charOutputStream.
	ws nextPut: $"; nextPutAll: revision; nextPut: $"; cr.
	^ogs at: name put: ws! !

"December 24, 2009 -> 2:8:46"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file out-private' !
fileOutDefinition: m <Mirror> directory: dir <FilePath> world: w <Str> openGroups: ogs <Dictionary[Str, CharOutputStream]>

	| defStream <CharOutputStream> |
	defStream := CharacterInputOutputConverter on: (dir, (FilePath for: m fileName)) writeStream.
	[ (DefinitionWriter for: m) fileOutOn: defStream ] ensure: [ defStream close ].
	(self groupFor: w directory: dir openGroups: ogs)
		nextPutAll: 'Delta fileInFromFile: ', m fileName printString, ' !!'; cr; flush.
	(self groupFor: m group directory: dir openGroups: ogs)
		nextPutAll: 'Delta fileInFromFile: ', m fileName printString, ' !!'; cr; flush.
! !

"December 24, 2009 -> 2:8:46"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file out-private' !
groupFor: name <Str>  directory: dir <FilePath> openGroups: ogs <Dictionary[Str, CharOutputStream]> ^ <CharOutputStream>

	| file <FilePath> rs <CharInputStream> ws <CharOutputStream> revision <Str> |
	(ws := ogs at: name ifAbsent: [ nil ]) notNil
		ifTrue: [	^ws ].
	file := dir, (FilePath for: (name, self groupFileExtension)).
	file exists
		ifTrue: 	[	rs := file charInputStream.
							[ revision := rs nextChunk ] ensure: [ rs close ] ]
		ifFalse: 	[	revision := self defaultFileoutRevision ].
	ws := file charOutputStream.
	ws nextPut: $"; nextPut: revision; nextPut: $"; cr.
	^ogs at: name put: ws! !

"December 24, 2009 -> 2:8:46"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file out-private' !
groupFor: name <Str>  directory: dir <FilePath> openGroups: ogs <Dictionary[Str, CharOutputStream]> ^ <CharOutputStream>

	| file <FilePath> rs <CharInputStream> ws <CharOutputStream> revision <Str> |
	(ws := ogs at: name ifAbsent: [ nil ]) notNil
		ifTrue: [	^ws ].
	file := dir, (FilePath for: (name, self groupFileExtension)).
	file exists
		ifTrue: 	[	rs := file charInputStream.
							[ revision := rs nextChunk ] ensure: [ rs close ] ]
		ifFalse: 	[	revision := self defaultFileoutRevision ].
	ws := file charOutputStream.
	ws nextPut: $"; nextPutAll: revision; nextPut: $"; cr.
	^ogs at: name put: ws! !

"December 24, 2009 -> 2:8:46"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file out-private' !
fileOutDefinition: m <Mirror> directory: dir <FilePath> world: w <Str> openGroups: ogs <Dictionary[Str, CharOutputStream]>

	| defStream <CharOutputStream> |
	defStream := CharacterInputOutputConverter on: (dir, (FilePath for: m fileName)) writeStream.
	[ (DefinitionWriter for: m) fileOutOn: defStream ] ensure: [ defStream close ].
	(self groupFor: w directory: dir openGroups: ogs)
		nextPutAll: 'Delta fileInFromFile: (FilePath for: ', m fileName printString, ') !!'; cr; flush.
	(self groupFor: m group directory: dir openGroups: ogs)
		nextPutAll: 'Delta fileInFromFile: (FilePath for: ', m fileName printString, ') !!'; cr; flush.
! !

"December 24, 2009 -> 2:8:46"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file out-private' !
defaultFileoutRevision ^ <Str>

	^'"$Revi', 'sion:$"'			"Protect string from RCS !!"! !

"December 24, 2009 -> 2:8:47"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file out-private' !
groupFor: name <Str>  directory: dir <FilePath> openGroups: ogs <Dictionary[Str, CharOutputStream]> ^ <CharOutputStream>

	| file <FilePath> rs <CharInputStream> ws <CharOutputStream> revision <Str> |
	(ws := ogs at: name ifAbsent: [ nil ]) notNil
		ifTrue: [	^ws ].
	file := dir, (FilePath for: (name, self groupFileExtension)).
	file exists
		ifTrue: 	[	rs := file charInputStream.
							[ revision := rs nextChunk ] ensure: [ rs close ] ]
		ifFalse: 	[	revision := self defaultFileoutRevision ].
	ws := file charOutputStream.
	ws nextChunkPut: revision; cr.
	^ogs at: name put: ws! !

"December 24, 2009 -> 2:8:47"!

! (Delta mirrorFor: #UnixFilePath) classSide methodsFor: 'instance creation' !
currentDirectory: file <FilePath>

    	| result <Alien> name <Alien> setCurrentDirectory <Alien> |
    	setCurrentDirectory := Alien lookup: 'SetCurrentDirectoryA' inLibrary: 'kernel32.dll'.
    	result := Alien new: 4.
    	name := file name asString asAlien.
    	[setCurrentDirectory
    		primFFICallResult: result
    		with: name pointer.
    	result asBoolean ifFalse: [self error: 'Unable to cd to directory ', file name]]
    		ensure: [name free]
	! !

"December 24, 2009 -> 2:8:47"!

! (Delta mirrorFor: #FilePath) classSide methodsFor: 'instance creation' !
currentDirectory: file <FilePath>

	^Platform pathClass currentDirectory: file! !

"December 24, 2009 -> 2:8:47"!

! (Delta mirrorFor: #CodeView) methodsFor: 'control' !
showItBlock ^<[]>

	^[self computeValueIfSuccess: [:oop | | pstr <Str> result <Visual> |
													pstr := oop printString.
													self inSessionProcessDo: [
														result := (StringGlyph
																			for: pstr
																			painter: self showItPainter) asVisual
																			withBackdrop: self showItBackdrop.
														result := (PressHandler for: result)
																			onPress: [ (Inspector on: oop) launch ].
														result := (PopUpMenuHandler for: result)
																			menuBlock: [ self showItMenuFor: result text: pstr ].
														self replaceModelFrom: self selectionEnd
																to: self selectionEnd
																withGlyphs: (Array[Array[Glyph]] with: (Array[Glyph] with: result)).
														self selection: self selectionEnd ,, self selectionEnd]]]
! !

"December 24, 2009 -> 2:8:47"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file out-private' !
fileOutDefinition: m <Mirror> directory: dir <FilePath> world: w <Str> openGroups: ogs <Dictionary[Str, CharOutputStream]>

	| defStream <CharOutputStream> |
	defStream := CharacterInputOutputConverter on: (dir, (FilePath for: m fileName)) writeStream.
	[ (DefinitionWriter for: m) fileOutOn: defStream ] ensure: [ defStream close ].
	(self groupFor: w directory: dir openGroups: ogs)
		nextPutAll: 'Delta fileInFromFile: ', m fileName printString, ' !!'; cr; flush.
	(self groupFor: m group directory: dir openGroups: ogs)
		nextPutAll: 'Delta fileInFromFile: ', m fileName printString, ' !!'; cr; flush.
! !

"December 24, 2009 -> 2:8:47"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file out-private' !
groupFor: name <Str>  directory: dir <FilePath> openGroups: ogs <Dictionary[Str, CharOutputStream]> ^ <CharOutputStream>

	| file <FilePath> rs <CharInputStream> ws <CharOutputStream> revision <Str> |
	(ws := ogs at: name ifAbsent: [ nil ]) notNil
		ifTrue: [	^ws ].
	file := dir, (FilePath for: (name, self groupFileExtension)).
	file exists
		ifTrue: 	[	rs := file charInputStream.
							[ revision := rs nextChunk ] ensure: [ rs close ] ]
		ifFalse: 	[	revision := self defaultFileoutRevision ].
	ws := file charOutputStream.
	ws nextPut: $"; nextPut: revision; nextPut: $"; cr.
	^ogs at: name put: ws! !

"December 24, 2009 -> 2:8:47"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file out-private' !
groupFor: name <Str>  directory: dir <FilePath> openGroups: ogs <Dictionary[Str, CharOutputStream]> ^ <CharOutputStream>

	| file <FilePath> rs <CharInputStream> ws <CharOutputStream> revision <Str> |
	(ws := ogs at: name ifAbsent: [ nil ]) notNil
		ifTrue: [	^ws ].
	file := dir, (FilePath for: (name, self groupFileExtension)).
	file exists
		ifTrue: 	[	rs := file charInputStream.
							[ revision := rs nextChunk ] ensure: [ rs close ] ]
		ifFalse: 	[	revision := self defaultFileoutRevision ].
	ws := file charOutputStream.
	ws nextPut: $"; nextPutAll: revision; nextPut: $"; cr.
	^ogs at: name put: ws! !

"December 24, 2009 -> 2:8:47"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file out-private' !
fileOutDefinition: m <Mirror> directory: dir <FilePath> world: w <Str> openGroups: ogs <Dictionary[Str, CharOutputStream]>

	| defStream <CharOutputStream> |
	defStream := CharacterInputOutputConverter on: (dir, (FilePath for: m fileName)) writeStream.
	[ (DefinitionWriter for: m) fileOutOn: defStream ] ensure: [ defStream close ].
	(self groupFor: w directory: dir openGroups: ogs)
		nextPutAll: 'Delta fileInFromFile: ', m fileName printString, ' !!'; cr; flush.
	(self groupFor: m group directory: dir openGroups: ogs)
		nextPutAll: 'Delta fileInFromFile: ', m fileName printString, ' !!'; cr; flush.
! !

"December 24, 2009 -> 2:8:47"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file out-private' !
groupFor: name <Str>  directory: dir <FilePath> openGroups: ogs <Dictionary[Str, CharOutputStream]> ^ <CharOutputStream>

	| file <FilePath> rs <CharInputStream> ws <CharOutputStream> revision <Str> |
	(ws := ogs at: name ifAbsent: [ nil ]) notNil
		ifTrue: [	^ws ].
	file := dir, (FilePath for: (name, self groupFileExtension)).
	file exists
		ifTrue: 	[	rs := file charInputStream.
							[ revision := rs nextChunk ] ensure: [ rs close ] ]
		ifFalse: 	[	revision := self defaultFileoutRevision ].
	ws := file charOutputStream.
	ws nextPut: $"; nextPut: revision; nextPut: $"; cr.
	^ogs at: name put: ws! !

"December 24, 2009 -> 2:8:47"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file out-private' !
groupFor: name <Str>  directory: dir <FilePath> openGroups: ogs <Dictionary[Str, CharOutputStream]> ^ <CharOutputStream>

	| file <FilePath> rs <CharInputStream> ws <CharOutputStream> revision <Str> |
	(ws := ogs at: name ifAbsent: [ nil ]) notNil
		ifTrue: [	^ws ].
	file := dir, (FilePath for: (name, self groupFileExtension)).
	file exists
		ifTrue: 	[	rs := file charInputStream.
							[ revision := rs nextChunk ] ensure: [ rs close ] ]
		ifFalse: 	[	revision := self defaultFileoutRevision ].
	ws := file charOutputStream.
	ws nextPut: $"; nextPutAll: revision; nextPut: $"; cr.
	^ogs at: name put: ws! !

"December 24, 2009 -> 2:8:47"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file out-private' !
fileOutDefinition: m <Mirror> directory: dir <FilePath> world: w <Str> openGroups: ogs <Dictionary[Str, CharOutputStream]>

	| defStream <CharOutputStream> |
	defStream := CharacterInputOutputConverter on: (dir, (FilePath for: m fileName)) writeStream.
	[ (DefinitionWriter for: m) fileOutOn: defStream ] ensure: [ defStream close ].
	(self groupFor: w directory: dir openGroups: ogs)
		nextPutAll: 'Delta fileInFromFile: (FilePath for: ', m fileName printString, ') !!'; cr; flush.
	(self groupFor: m group directory: dir openGroups: ogs)
		nextPutAll: 'Delta fileInFromFile: (FilePath for: ', m fileName printString, ') !!'; cr; flush.
! !

"December 24, 2009 -> 2:8:47"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file out-private' !
defaultFileoutRevision ^ <Str>

	^'"$Revi', 'sion:$"'			"Protect string from RCS !!"! !

"December 24, 2009 -> 2:8:47"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file out-private' !
groupFor: name <Str>  directory: dir <FilePath> openGroups: ogs <Dictionary[Str, CharOutputStream]> ^ <CharOutputStream>

	| file <FilePath> rs <CharInputStream> ws <CharOutputStream> revision <Str> |
	(ws := ogs at: name ifAbsent: [ nil ]) notNil
		ifTrue: [	^ws ].
	file := dir, (FilePath for: (name, self groupFileExtension)).
	file exists
		ifTrue: 	[	rs := file charInputStream.
							[ revision := rs nextChunk ] ensure: [ rs close ] ]
		ifFalse: 	[	revision := self defaultFileoutRevision ].
	ws := file charOutputStream.
	ws nextChunkPut: revision; cr.
	^ogs at: name put: ws! !

"December 24, 2009 -> 2:8:47"!

! (Delta mirrorFor: #UnixFilePath) classSide methodsFor: 'instance creation' !
currentDirectory: file <FilePath>

    	| result <Alien> name <Alien> setCurrentDirectory <Alien> |
    	setCurrentDirectory := Alien lookup: 'SetCurrentDirectoryA' inLibrary: 'kernel32.dll'.
    	result := Alien new: 4.
    	name := file name asString asAlien.
    	[setCurrentDirectory
    		primFFICallResult: result
    		with: name pointer.
    	result asBoolean ifFalse: [self error: 'Unable to cd to directory ', file name]]
    		ensure: [name free]
	! !

"December 24, 2009 -> 2:8:47"!

! (Delta mirrorFor: #FilePath) classSide methodsFor: 'instance creation' !
currentDirectory: file <FilePath>

	^Platform pathClass currentDirectory: file! !

"December 24, 2009 -> 2:8:47"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file out-private' !
fileOutDefinition: m <Mirror> directory: dir <FilePath> world: w <Str> openGroups: ogs <Dictionary[Str, CharOutputStream]>

	| defStream <CharOutputStream> |
	defStream := CharacterInputOutputConverter on: (dir, (FilePath for: m fileName)) writeStream.
	[ (DefinitionWriter for: m) fileOutOn: defStream ] ensure: [ defStream close ].
	(self groupFor: w directory: dir openGroups: ogs)
		nextPutAll: 'Delta fileInFromFile: ', m fileName printString, ' !!'; cr; flush.
	(self groupFor: m group directory: dir openGroups: ogs)
		nextPutAll: 'Delta fileInFromFile: ', m fileName printString, ' !!'; cr; flush.
! !

"December 24, 2009 -> 2:8:47"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file out-private' !
groupFor: name <Str>  directory: dir <FilePath> openGroups: ogs <Dictionary[Str, CharOutputStream]> ^ <CharOutputStream>

	| file <FilePath> rs <CharInputStream> ws <CharOutputStream> revision <Str> |
	(ws := ogs at: name ifAbsent: [ nil ]) notNil
		ifTrue: [	^ws ].
	file := dir, (FilePath for: (name, self groupFileExtension)).
	file exists
		ifTrue: 	[	rs := file charInputStream.
							[ revision := rs nextChunk ] ensure: [ rs close ] ]
		ifFalse: 	[	revision := self defaultFileoutRevision ].
	ws := file charOutputStream.
	ws nextPut: $"; nextPut: revision; nextPut: $"; cr.
	^ogs at: name put: ws! !

"December 24, 2009 -> 2:8:47"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file out-private' !
groupFor: name <Str>  directory: dir <FilePath> openGroups: ogs <Dictionary[Str, CharOutputStream]> ^ <CharOutputStream>

	| file <FilePath> rs <CharInputStream> ws <CharOutputStream> revision <Str> |
	(ws := ogs at: name ifAbsent: [ nil ]) notNil
		ifTrue: [	^ws ].
	file := dir, (FilePath for: (name, self groupFileExtension)).
	file exists
		ifTrue: 	[	rs := file charInputStream.
							[ revision := rs nextChunk ] ensure: [ rs close ] ]
		ifFalse: 	[	revision := self defaultFileoutRevision ].
	ws := file charOutputStream.
	ws nextPut: $"; nextPutAll: revision; nextPut: $"; cr.
	^ogs at: name put: ws! !

"December 24, 2009 -> 2:8:47"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file out-private' !
fileOutDefinition: m <Mirror> directory: dir <FilePath> world: w <Str> openGroups: ogs <Dictionary[Str, CharOutputStream]>

	| defStream <CharOutputStream> |
	defStream := CharacterInputOutputConverter on: (dir, (FilePath for: m fileName)) writeStream.
	[ (DefinitionWriter for: m) fileOutOn: defStream ] ensure: [ defStream close ].
	(self groupFor: w directory: dir openGroups: ogs)
		nextPutAll: 'Delta fileInFromFile: ', m fileName printString, ' !!'; cr; flush.
	(self groupFor: m group directory: dir openGroups: ogs)
		nextPutAll: 'Delta fileInFromFile: ', m fileName printString, ' !!'; cr; flush.
! !

"December 24, 2009 -> 2:8:47"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file out-private' !
groupFor: name <Str>  directory: dir <FilePath> openGroups: ogs <Dictionary[Str, CharOutputStream]> ^ <CharOutputStream>

	| file <FilePath> rs <CharInputStream> ws <CharOutputStream> revision <Str> |
	(ws := ogs at: name ifAbsent: [ nil ]) notNil
		ifTrue: [	^ws ].
	file := dir, (FilePath for: (name, self groupFileExtension)).
	file exists
		ifTrue: 	[	rs := file charInputStream.
							[ revision := rs nextChunk ] ensure: [ rs close ] ]
		ifFalse: 	[	revision := self defaultFileoutRevision ].
	ws := file charOutputStream.
	ws nextPut: $"; nextPut: revision; nextPut: $"; cr.
	^ogs at: name put: ws! !

"December 24, 2009 -> 2:8:47"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file out-private' !
groupFor: name <Str>  directory: dir <FilePath> openGroups: ogs <Dictionary[Str, CharOutputStream]> ^ <CharOutputStream>

	| file <FilePath> rs <CharInputStream> ws <CharOutputStream> revision <Str> |
	(ws := ogs at: name ifAbsent: [ nil ]) notNil
		ifTrue: [	^ws ].
	file := dir, (FilePath for: (name, self groupFileExtension)).
	file exists
		ifTrue: 	[	rs := file charInputStream.
							[ revision := rs nextChunk ] ensure: [ rs close ] ]
		ifFalse: 	[	revision := self defaultFileoutRevision ].
	ws := file charOutputStream.
	ws nextPut: $"; nextPutAll: revision; nextPut: $"; cr.
	^ogs at: name put: ws! !

"December 24, 2009 -> 2:8:47"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file out-private' !
fileOutDefinition: m <Mirror> directory: dir <FilePath> world: w <Str> openGroups: ogs <Dictionary[Str, CharOutputStream]>

	| defStream <CharOutputStream> |
	defStream := CharacterInputOutputConverter on: (dir, (FilePath for: m fileName)) writeStream.
	[ (DefinitionWriter for: m) fileOutOn: defStream ] ensure: [ defStream close ].
	(self groupFor: w directory: dir openGroups: ogs)
		nextPutAll: 'Delta fileInFromFile: (FilePath for: ', m fileName printString, ') !!'; cr; flush.
	(self groupFor: m group directory: dir openGroups: ogs)
		nextPutAll: 'Delta fileInFromFile: (FilePath for: ', m fileName printString, ') !!'; cr; flush.
! !

"December 24, 2009 -> 2:8:47"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file out-private' !
defaultFileoutRevision ^ <Str>

	^'"$Revi', 'sion:$"'			"Protect string from RCS !!"! !

"December 24, 2009 -> 2:8:47"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file out-private' !
groupFor: name <Str>  directory: dir <FilePath> openGroups: ogs <Dictionary[Str, CharOutputStream]> ^ <CharOutputStream>

	| file <FilePath> rs <CharInputStream> ws <CharOutputStream> revision <Str> |
	(ws := ogs at: name ifAbsent: [ nil ]) notNil
		ifTrue: [	^ws ].
	file := dir, (FilePath for: (name, self groupFileExtension)).
	file exists
		ifTrue: 	[	rs := file charInputStream.
							[ revision := rs nextChunk ] ensure: [ rs close ] ]
		ifFalse: 	[	revision := self defaultFileoutRevision ].
	ws := file charOutputStream.
	ws nextChunkPut: revision; cr.
	^ogs at: name put: ws! !

"December 24, 2009 -> 2:8:47"!

! (Delta mirrorFor: #UnixFilePath) classSide methodsFor: 'instance creation' !
currentDirectory: file <FilePath>

    	| result <Alien> name <Alien> setCurrentDirectory <Alien> |
    	setCurrentDirectory := Alien lookup: 'SetCurrentDirectoryA' inLibrary: 'kernel32.dll'.
    	result := Alien new: 4.
    	name := file name asString asAlien.
    	[setCurrentDirectory
    		primFFICallResult: result
    		with: name pointer.
    	result asBoolean ifFalse: [self error: 'Unable to cd to directory ', file name]]
    		ensure: [name free]
	! !

"December 24, 2009 -> 2:8:47"!

! (Delta mirrorFor: #FilePath) classSide methodsFor: 'instance creation' !
currentDirectory: file <FilePath>

	^Platform pathClass currentDirectory: file! !

"December 24, 2009 -> 2:8:47"!

! (Delta mirrorFor: #CodeView) methodsFor: 'control' !
showItBlock ^<[]>

	^[self computeValueIfSuccess: [:oop | | pstr <Str> result <Visual> |
													pstr := oop printString.
													self inSessionProcessDo: [
														result := (StringGlyph
																			for: pstr
																			painter: self showItPainter) asVisual
																			withBackdrop: self showItBackdrop.
														result := (PressHandler for: result)
																			onPress: [ (Inspector on: oop) launch ].
														result := (PopUpMenuHandler for: result)
																			menuBlock: [ self showItMenuFor: result text: pstr ].
														self replaceModelFrom: self selectionEnd
																to: self selectionEnd
																withGlyphs: (Array[Array[Glyph]] with: (Array[Glyph] with: result)).
														self selection: self selectionEnd ,, self selectionEnd]]]
! !

"December 24, 2009 -> 2:8:47"!

! (Delta mirrorFor: #Win32FilePath) classSide methodsFor: 'instance creation' !
currentDirectory: file <FilePath>

	| name result setCurrentDirectory |
	name := file name asString asAlien.
	[result := Alien new: 4.
	setCurrentDirectory := Alien lookup: 'SetCurrentDirectoryA' inLibrary: 'kernel32.dll'.
	setCurrentDirectory
		primFFICalloutResult: result
		with: name pointer.
	result asBoolean ifFalse: [self error: 'Could not change directory']]
		ensure: [name free]! !

"December 24, 2009 -> 2:8:47"!

! (Delta mirrorFor: #Win32FilePath) classSide methodsFor: 'instance creation' !
currentDirectory: file <FilePath>

	| name result setCurrentDirectory |
	name := file name asString asAlien.
	[result := Alien new: 4.
	setCurrentDirectory := Alien lookup: 'SetCurrentDirectoryA' inLibrary: 'kernel32.dll'.
	setCurrentDirectory
		primFFICallResult: result
		with: name pointer.
	result asBoolean ifFalse: [self error: 'Could not change directory']]
		ensure: [name free]! !

"December 24, 2009 -> 2:8:47"!

! (Delta mirrorFor: #Win32FilePath) classSide methodsFor: 'instance creation' !
currentDirectory: file <FilePath>

	| name result setCurrentDirectory |
	name := file name asString asAlien.
	[result := Alien new: 4.
	setCurrentDirectory := Alien lookup: 'SetCurrentDirectoryA' inLibrary: 'kernel32.dll'.
	setCurrentDirectory
		primFFICallResult: result
		with: name pointer.
	(result boolAt: 1) ifFalse: [self error: 'Could not change directory']]
		ensure: [name free]! !

"December 24, 2009 -> 2:11:23"!

"System saved" !
"December 24, 2009 -> 16:4:38"!

! (Delta mirrorFor: #UnixFilePath) classSide methodsFor: 'instance creation' !
currentDirectory: file <FilePath>

    	| result <Alien> name <Alien> chdir <Alien> |
    	chdir := Alien lookup: 'chdir' inLibrary: 'libc.so.6'.
    	result := Alien new: 4.
    	name := file name asString asAlien.
    	[chdir
    		primFFICallResult: result
    		with: name pointer.
    	result asSignedLong = 0 ifFalse: [self error: 'Unable to cd to directory ', file name]]
    		ensure: [name free]
	! !

"December 24, 2009 -> 16:4:38"!

Delta define: #FilePathTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"December 24, 2009 -> 16:4:38"!

Delta define: #FilePathTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"December 24, 2009 -> 16:4:38"!

Delta define: #FilePathTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"December 24, 2009 -> 16:4:38"!

Delta define: #FilePathTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"December 24, 2009 -> 16:4:38"!

Delta define: #FilePathTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"December 24, 2009 -> 16:4:38"!

Delta define: #FilePathTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"December 24, 2009 -> 16:4:38"!

Delta define: #FilePathTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"December 24, 2009 -> 16:4:38"!

Delta define: #FilePathTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"December 24, 2009 -> 16:4:38"!

Delta define: #FilePathTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'created <Boolean>
tmpDir <FilePath>
file <FilePath>')) !


"December 24, 2009 -> 16:4:38"!

Delta define: #FilePathTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'created <Boolean>
tmpDir <FilePath>
file <FilePath>')) !


"December 24, 2009 -> 16:4:38"!

Delta define: #FilePathTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'created <Boolean>
tmpDir <FilePath>
file <FilePath>')) !


"December 24, 2009 -> 16:4:38"!

Delta define: #FilePathTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'created <Boolean>
tmpDir <FilePath>
file <FilePath>')) !


"December 24, 2009 -> 16:4:38"!

! (Delta mirrorFor: #FilePathTest) methodsFor: 'restricted-test support' !
setUp

	tmpDir := FilePath for: 'tmpDir'.
	self deny: tmpDir exists.
	tmpDir createDirectoryIfFail: 
		[:err |
		created := false.
		self error: err].
	created := true.
	file := tmpDir, (FilePattern for: 'tmpFile')! !

"December 24, 2009 -> 16:4:38"!

! (Delta mirrorFor: #FilePathTest) methodsFor: 'restricted-test support' !
tearDown

	created
		ifTrue: [FilePath tryToDeleteTestDir: tmpDir]! !

"December 24, 2009 -> 16:4:38"!

Delta define: #FilePathTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'created <Boolean>
tmpDir <FilePath>
file <FilePath>')) !


"December 24, 2009 -> 16:4:38"!

Delta define: #FilePathTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'created <Boolean>
tmpDir <FilePath>
file <FilePath>')) !


"December 24, 2009 -> 16:4:38"!

Delta define: #FilePathTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'created <Boolean>
tmpDir <FilePath>
file <FilePath>')) !


"December 24, 2009 -> 16:4:38"!

Delta define: #FilePathTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'created <Boolean>
tmpDir <FilePath>
file <FilePath>')) !


"December 24, 2009 -> 16:4:38"!

Delta define: #FilePathTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'created <Boolean>
tmpDir <FilePath>
file <FilePath>')) !


"December 24, 2009 -> 16:4:38"!

Delta define: #FilePathTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'created <Boolean>
tmpDir <FilePath>
file <FilePath>')) !


"December 24, 2009 -> 16:4:38"!

Delta define: #FilePathTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'created <Boolean>
tmpDir <FilePath>
file <FilePath>')) !


"December 24, 2009 -> 16:4:38"!

Delta define: #FilePathTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'created <Boolean>
tmpDir <FilePath>
file <FilePath>
cwd <FilePath>')) !


"December 24, 2009 -> 16:4:38"!

Delta define: #FilePathTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'created <Boolean>
tmpDir <FilePath>
file <FilePath>
cwd <FilePath>')) !


"December 24, 2009 -> 16:4:38"!

Delta define: #FilePathTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'created <Boolean>
tmpDir <FilePath>
file <FilePath>
cwd <FilePath>')) !


"December 24, 2009 -> 16:4:38"!

Delta define: #FilePathTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'created <Boolean>
tmpDir <FilePath>
file <FilePath>
cwd <FilePath>')) !


"December 24, 2009 -> 16:4:38"!

! (Delta mirrorFor: #FilePathTest) methodsFor: 'restricted-test support' !
setUp

	cwd := FilePath currentDirectory.
	tmpDir := FilePath for: 'tmpDir'.
	self deny: tmpDir exists.
	tmpDir createDirectoryIfFail: 
		[:err |
		created := false.
		self error: err].
	created := true.
	file := tmpDir, (FilePattern for: 'tmpFile')! !

"December 24, 2009 -> 16:4:38"!

! (Delta mirrorFor: #FilePathTest) methodsFor: 'restricted-test support' !
tearDown

	FilePath currentDirectory: cwd.
	created
		ifTrue: [FilePath tryToDeleteTestDir: tmpDir]! !

"December 24, 2009 -> 16:4:38"!

! (Delta mirrorFor: #FilePathTest) methodsFor: 'restricted-test support' !
setUp

	cwd := FilePath currentDirectory.
	tmpDir := FilePath for: 'tmpDir'.
	self deny: tmpDir exists.
	tmpDir createDirectoryIfFail: 
		[:err |
		created := false.
		self error: err].
	created := true! !

"December 24, 2009 -> 16:4:38"!

! (Delta mirrorFor: #FilePathTest) methodsFor: 'testing' !
testContainingDirectoryOfFileInCurrentDirectoryShouldBeDot

	FilePath currentDirectory: tmpDir.
	file := FilePath for: 'testfile'.
	self assert: '.' = file containingDirectory name! !

"December 24, 2009 -> 16:4:38"!

! (Delta mirrorFor: #FilePath) methodsFor: 'accessing' !
containingDirectory ^<FilePath>

	"use when coerce: works with mixins"
"	^FilePath coerce: super containingDirectory"
	| directory <FilePath> |
	directory := guaranteed <FilePath> (super containingDirectory).
	^directory ifNil: [FilePath for: '.']! !

"December 24, 2009 -> 16:4:38"!

! (Delta mirrorFor: #FilePath) methodsFor: 'accessing' !
containingDirectory ^<FilePath>

	"use when coerce: works with mixins"
"	^FilePath coerce: super containingDirectory"
	| directory <FilePath> |
	directory := guaranteed <FilePath> (super containingDirectory).
	^directory isNil
		ifTrue: [FilePath for: '.']
		ifFalse: [directory]! !

"December 24, 2009 -> 16:4:38"!

(Delta mirrorFor: #TestRunner) classSide removeMethod: #new ifAbsent: [] !


"December 24, 2009 -> 16:4:38"!

! (Delta mirrorFor: #TestRunner) classSide methodsFor: 'instance creation' !
open
	"(TestRunner open)"
        ^self new launch! !

"December 24, 2009 -> 16:4:38"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList errorsList failuresList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testList := (ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:)
								withPopUpMenuSource: [^self listBoxPopUpMenu].
	failuresList := ListModel
									on: self
									items: #failuresList
									selected: #selectedFailureTest
									select: #debugFailureTest:.
	errorsList := ListModel
									on: self
									items: #errorsList
									selected: #selectedErrorTest
									select: #debugErrorTest:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: testList with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: failuresList with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: errorsList with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: passFailText imbeddedVisual))
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: detailsText imbeddedVisual))
																			with: (textEqualizer for: resultsRow)).
	self updateAll.
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"December 24, 2009 -> 16:4:38"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
listBoxPopUpMenu ^<Menu>

	^Menu new
		name: 'Actions';
		add: (MenuAction new
					name: 'Add test class';
					action: [])! !

"December 24, 2009 -> 16:4:38"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList errorsList failuresList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testList := (ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:)
								withPopUpMenuSource: [self listBoxPopUpMenu].
	failuresList := ListModel
									on: self
									items: #failuresList
									selected: #selectedFailureTest
									select: #debugFailureTest:.
	errorsList := ListModel
									on: self
									items: #errorsList
									selected: #selectedErrorTest
									select: #debugErrorTest:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: testList with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: failuresList with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: errorsList with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: passFailText imbeddedVisual))
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: detailsText imbeddedVisual))
																			with: (textEqualizer for: resultsRow)).
	self updateAll.
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"December 24, 2009 -> 16:4:38"!

Delta define: #TestRunner as: (
(Class subclassOf: 'ProgrammingEnvironment mixin |> (NotifyingObject mixin |> Application)' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"December 24, 2009 -> 16:4:38"!

Delta define: #TestRunner as: (
(Class subclassOf: 'ProgrammingEnvironment mixin |> (NotifyingObject mixin |> Application)' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"December 24, 2009 -> 16:4:38"!

Delta define: #TestRunner as: (
(Class subclassOf: 'ProgrammingEnvironment mixin |> (NotifyingObject mixin |> Application)' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"December 24, 2009 -> 16:4:38"!

Delta define: #TestRunner as: (
(Class subclassOf: 'ProgrammingEnvironment mixin |> (NotifyingObject mixin |> Application)' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"December 24, 2009 -> 16:4:38"!

Delta define: #TestRunner as: (
(Class subclassOf: 'ProgrammingEnvironment mixin |> (NotifyingObject mixin |> Application)' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"December 24, 2009 -> 16:4:38"!

Delta define: #TestRunner as: (
(Class subclassOf: 'ProgrammingEnvironment mixin |> (NotifyingObject mixin |> Application)' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"December 24, 2009 -> 16:4:38"!

Delta define: #TestRunner as: (
(Class subclassOf: 'ProgrammingEnvironment mixin |> (NotifyingObject mixin |> Application)' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"December 24, 2009 -> 16:4:38"!

Delta define: #TestRunner as: (
(Class subclassOf: 'ProgrammingEnvironment mixin |> (NotifyingObject mixin |> Application)' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"December 24, 2009 -> 16:4:38"!

Delta define: #TestRunner as: (
(Class subclassOf: 'ProgrammingEnvironment mixin |> (NotifyingObject mixin |> Application)' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"December 24, 2009 -> 16:4:38"!

Delta define: #TestRunner as: (
(Class subclassOf: 'ProgrammingEnvironment mixin |> (NotifyingObject mixin |> Application)' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"December 24, 2009 -> 16:4:38"!

Delta define: #TestRunner as: (
(Class subclassOf: 'ProgrammingEnvironment mixin |> (NotifyingObject mixin |> Application)' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"December 24, 2009 -> 16:4:38"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
listBoxPopUpMenu ^<Menu>

	^Menu new
		name: 'Actions';
		add: (MenuAction new
					name: 'Add test class';
					action: [self addSubclassTo: (Mirror on: TestCase)])! !

"December 24, 2009 -> 16:4:38"!

! (Delta mirrorFor: #BlockDependent) methodsFor: 'dependencies' !
update: aspect

	self update: aspect with: nil! !

"December 24, 2009 -> 16:4:52"!

"System saved" !
"December 24, 2009 -> 19:5:23"!

! (Delta mirrorFor: #NotifyingObject) methodsFor: 'accessing' !
removeDependent: o <Object>

	self dependents remove: o ifAbsent: []! !

"December 24, 2009 -> 19:5:23"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
update: aspect with: value

	self refreshTests! !

"December 24, 2009 -> 19:5:23"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'private-control' !
closeRequest: toClose <[]>

	Smalltalk removeDependent: self.
	super closeRequest: toClose! !

"December 24, 2009 -> 19:5:23"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList errorsList failuresList |
	Smalltalk addDependent: self.
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testList := (ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:)
								withPopUpMenuSource: [self listBoxPopUpMenu].
	failuresList := ListModel
									on: self
									items: #failuresList
									selected: #selectedFailureTest
									select: #debugFailureTest:.
	errorsList := ListModel
									on: self
									items: #errorsList
									selected: #selectedErrorTest
									select: #debugErrorTest:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: testList with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: failuresList with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: errorsList with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: passFailText imbeddedVisual))
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: detailsText imbeddedVisual))
																			with: (textEqualizer for: resultsRow)).
	self updateAll.
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"December 24, 2009 -> 19:6:10"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
update: aspect with: value

	self inSessionDo: [self refreshTests]! !

"December 24, 2009 -> 19:6:24"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
update: aspect with: value

	self inSessionProcessDo: [self refreshTests]! !

"December 24, 2009 -> 19:6:55"!

Delta define: #NewTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"December 24, 2009 -> 19:7:12"!

(Delta mirrorFor: #NewTest) removeDefinitionIfFail: [] !


"December 24, 2009 -> 19:10:16"!

"System saved" !
"December 24, 2009 -> 21:20:16"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn errorsList failuresList |
	Smalltalk addDependent: self.
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testsList := (ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:)
								withPopUpMenuSource: [self listBoxPopUpMenu].
	failuresList := ListModel
									on: self
									items: #failuresList
									selected: #selectedFailureTest
									select: #debugFailureTest:.
	errorsList := ListModel
									on: self
									items: #errorsList
									selected: #selectedErrorTest
									select: #debugErrorTest:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: testsList with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: failuresList with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: errorsList with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: passFailText imbeddedVisual))
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: detailsText imbeddedVisual))
																			with: (textEqualizer for: resultsRow)).
	self updateAll.
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"December 24, 2009 -> 21:20:16"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
listBoxPopUpMenu ^<Menu>

	^Menu new
		name: 'Actions';
		add: (MenuAction new
					name: 'Add test class';
					action: [self addSubclassTo: (Mirror on: TestCase)]);
		add: (MenuAction new
					name: 'Browse';
					action: [self browseSelectedTest])! !

"December 24, 2009 -> 21:20:16"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
browseSelectedTest! !

"December 24, 2009 -> 21:20:16"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
selectedTestClass

	^testSuite isNil ifFalse: [testSuite asSymbol sunitAsClass]! !

"December 24, 2009 -> 21:20:16"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
runOneTest
        "Cursor execute showWhile:
                ["
	testSuite notNil
		ifTrue: [self runWindow.
						result := self selectedTestClass suite run.
						self updateWindow: result]
 		ifFalse: [self runWindow.
						self displayPassFail: 'No Test Suite Selected']
       "]"! !

"December 24, 2009 -> 21:20:16"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
listBoxPopUpMenu ^<Menu>

	^Menu new
		name: 'Actions';
		add: (MenuAction new
					name: 'Add test class';
					action: [self addSubclassTo: (Mirror on: TestCase)]);
		add: (MenuAction new
					name: 'Browse';
					active: [self selectedTestClass notNil];
					action: [self browseSelectedTest])! !

"December 24, 2009 -> 21:20:16"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
browseSelectedTest

	(ClassOutliner for: (Mirror on: self selectedTestClass)) launch! !

"December 24, 2009 -> 21:20:16"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
addSubclass

	self addSubclassTo: (self selectedTestClass isNil
										ifTrue: [TestCase]
										ifFalse: [self selectedTestClass])! !

"December 24, 2009 -> 21:20:16"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
listBoxPopUpMenu ^<Menu>

	^Menu new
		name: 'Actions';
		add: (MenuAction new
					name: 'Add test class';
					action: [self addSubclass]);
		add: (MenuAction new
					name: 'Browse';
					active: [self selectedTestClass notNil];
					action: [self browseSelectedTest])! !

"December 24, 2009 -> 21:20:52"!

"System saved" !
"December 25, 2009 -> 11:47:32"!

! (Delta mirrorFor: #Symbol) methodsFor: 'converting' !
asAlien

	^self asString asAlien! !

"December 25, 2009 -> 11:47:43"!

! (Delta mirrorFor: #ClassOutliner) methodsFor: 'private' !
buildToolBar

	super buildToolBar.
	self toolBar addSpace.
	self toolBar
		addButtonWithImageFrom: 'resources/sunit.png'
		action: [:b | Transcript cr; show: 'SUnit pressed!!']! !

"December 25, 2009 -> 11:48:16"!

! (Delta mirrorFor: #ClassOutliner) methodsFor: 'private' !
buildToolBar

	super buildToolBar.
	self toolBar addSpace.
	self toolBar
		addButtonWithImageFrom: 'resources/sunit.bmp'
		action: [:b | Transcript cr; show: 'SUnit pressed!!']! !

"December 25, 2009 -> 11:48:56"!

! (Delta mirrorFor: #ClassOutliner) methodsFor: 'private' !
buildToolBar

	super buildToolBar.
	self toolBar addSpace.
	self toolBar
		addButtonWithImageFrom: 'resources/sunit.bmp'
		action: [:b | TestRunner open]! !

"December 25, 2009 -> 11:49:38"!

! (Delta mirrorFor: #ClassOutliner) methodsFor: 'private' !
launchSunit

TestRunner open! !

"December 25, 2009 -> 11:49:57"!

! (Delta mirrorFor: #ClassOutliner) methodsFor: 'private' !
launchSUnit

TestRunner open! !

"December 25, 2009 -> 11:49:58"!

! (Delta mirrorFor: #ClassOutliner) methodsFor: 'private' !
buildToolBar

	super buildToolBar.
	self toolBar addSpace.
	self toolBar
		addButtonWithImageFrom: 'resources/sunit.bmp'
		action: [:b | self launchSUnit]! !

"December 25, 2009 -> 12:34:51"!

(Delta mirrorFor: #ClassOutliner) removeMethod: #launchSunit ifAbsent: [] !


"December 25, 2009 -> 12:40:55"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
selectTestClass: testClass <Class>

	testClass isNil ifTrue: [^self].
	self selectedSuite: (tests indexOf: testClass name)! !

"December 25, 2009 -> 12:40:57"!

! (Delta mirrorFor: #TestRunner) classSide methodsFor: 'instance creation' !
openOn: testClass <Class>
	"(TestRunner open)"
        ^self new
        	selectTestClass: testClass;
        	launch! !

"December 25, 2009 -> 12:41:16"!

! (Delta mirrorFor: #ClassOutliner) methodsFor: 'private' !
launchSUnit

TestRunner openOn: self mirror reflectee! !

"December 25, 2009 -> 12:45:13"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updateAll

	self changed: #tests.
	self changed: #selectedSuite.
	self changed: #details.
	self changed: #passFail.
	self refreshWindow! !

"December 25, 2009 -> 12:46:10"!

"System saved" !
"December 26, 2009 -> 23:28:25"!

Delta define: #Smalltalk as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'InitializingTypeInfo <Boolean>
	ClassesWithSubclasses <IdentitySet[Class]> 
	Cache <IdentityDict[Symbol, GlobalAssociation]>
	DependencyObject <NotifyingObject>
		"We have an explicit dependency object since one has to mix in
			NotifyingObject mixin to get dependency behavior. Smalltalk is
			currently just a class, so this is not possible."
	FileInDirectory <FilePath>') !


"December 26, 2009 -> 23:29:17"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file in - temporary' !
fileInDirectory

	FileInDirectory isNil
		ifTrue: [FileInDirectory := FilePath currentDirectory].
	^FileInDirectory! !

"December 26, 2009 -> 23:29:42"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file in - temporary' !
fileInDirectory: directory <FilePath>

	FileInDirectory := directory! !

"December 26, 2009 -> 23:29:51"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file in - temporary' !
fileInDirectory ^ <FilePath>

	FileInDirectory isNil
		ifTrue: [FileInDirectory := FilePath currentDirectory].
	^FileInDirectory! !

"December 26, 2009 -> 23:31:28"!

! (Delta mirrorFor: #FilePath) methodsFor: 'testing' !
isFullPath

	self subclassResponsibility! !

"December 26, 2009 -> 23:32:26"!

(Delta mirrorFor: #FilePath) removeMethod: #isFullPath ifAbsent: [] !


"December 26, 2009 -> 23:36:2"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file in - temporary' !
fileInFromAbsFile: file <FilePath>

	| stream <CharInputStream> |
	stream := file charInputStream.
	[ stream fileIn ] ensure: [ stream close ].! !

"December 26, 2009 -> 23:36:44"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file in - temporary' !
fileInFromFile: file <FilePath>

	| absFile <FilePath> |
	absFile := file isAbsolute
						ifTrue: [file]
						ifFalse: [self fileInDirectory, file].
	
	self fileInFromAbsFile: absFile! !

"December 26, 2009 -> 23:38:34"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file in - temporary' !
fileInFromAbsFile: file <FilePath>

	| stream <CharInputStream> savedDirectory <FilePath> |
	savedDirectory := self fileInDirectory.
	self fileInDirectory: file containingDirectory.
	[stream := file charInputStream.
	[ stream fileIn ] ensure: [ stream close ]]
		ensure: [self fileInDirectory: savedDirectory]! !

"December 26, 2009 -> 23:39:35"!

Delta define: #UnsafeAlien as: (
(Class subclassOf: 'Object' instanceVariables: 'nonPointerObject <IndexedByteInstanceVariables>')) !


"December 26, 2009 -> 23:39:35"!

Delta define: #UnsafeAlien as: (
(Class subclassOf: 'Object' instanceVariables: 'nonPointerObject <IndexedByteInstanceVariables>')) !


"December 26, 2009 -> 23:39:35"!

Delta define: #UnsafeAlien as: (
(Class subclassOf: 'Object' instanceVariables: 'nonPointerObject <IndexedByteInstanceVariables>')) !


"December 26, 2009 -> 23:39:35"!

Delta define: #UnsafeAlien as: (
(Class subclassOf: 'Object' instanceVariables: 'nonPointerObject <IndexedByteInstanceVariables>')) !


"December 26, 2009 -> 23:39:35"!

Delta define: #UnsafeAlien as: (
(Class subclassOf: 'Object' instanceVariables: 'nonPointerObject <IndexedByteInstanceVariables>')) !


"December 26, 2009 -> 23:39:35"!

Delta define: #UnsafeAlien as: (
(Class subclassOf: 'Object' instanceVariables: 'nonPointerObject <IndexedByteInstanceVariables>')) !


"December 26, 2009 -> 23:39:35"!

Delta define: #UnsafeAlien as: (
(Class subclassOf: 'Object' instanceVariables: 'nonPointerObject <IndexedByteInstanceVariables>')) !


"December 26, 2009 -> 23:39:35"!

Delta define: #UnsafeAlien as: (
(Class subclassOf: 'Object' instanceVariables: 'nonPointerObject <IndexedByteInstanceVariables>')) !


"December 26, 2009 -> 23:39:35"!

Delta define: #UnsafeAlien as: (
(Class subclassOf: 'Object' instanceVariables: 'nonPointerObject <IndexedByteInstanceVariables>')) !


"December 26, 2009 -> 23:39:35"!

Delta define: #UnsafeAlien as: (
(Class subclassOf: 'Object' instanceVariables: 'nonPointerObject <IndexedByteInstanceVariables>')) !


"December 26, 2009 -> 23:39:35"!

Delta define: #UnsafeAlien as: (
(Class subclassOf: 'Object' instanceVariables: 'nonPointerObject <IndexedByteInstanceVariables>')) !


"December 26, 2009 -> 23:39:35"!

(Delta mirrorFor: #UnsafeAlien)
comment: 
''!


"December 26, 2009 -> 23:39:35"!

! (Delta mirrorFor: #UnsafeAlien) classSide methodsFor: 'instance creation' !
forPointerTo: bytes <IndexedByteInstanceVariables> ^ <UnsafeAlien>

	^self new
		nonPointerObject: bytes;
		yourself
		! !

"December 26, 2009 -> 23:39:35"!

! (Delta mirrorFor: #UnsafeAlien) methodsFor: 'accessing' !
object

	^nonPointerObject! !

"December 26, 2009 -> 23:39:35"!

! (Delta mirrorFor: #UnsafeAlien) methodsFor: 'initialization' !
nonPointerObject: bytes <IndexedByteInstanceVariables>

	nonPointerObject := bytes! !

"December 26, 2009 -> 23:40:54"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file in - temporary' !
fileInFromAbsFile: file <FilePath>

	| stream <CharInputStream> savedDirectory <FilePath> |
	Transcript cr; show: 'Filing in from file ', file name.
	savedDirectory := self fileInDirectory.
	self fileInDirectory: file containingDirectory.
	[stream := file charInputStream.
	[ stream fileIn ] ensure: [ stream close ]]
		ensure: [self fileInDirectory: savedDirectory]! !

"December 26, 2009 -> 23:41:6"!

Delta define: #UnsafeAlien as: (
(Class subclassOf: 'Object' instanceVariables: 'nonPointerObject <IndexedByteInstanceVariables>')) !


"December 26, 2009 -> 23:41:6"!

Delta define: #UnsafeAlien as: (
(Class subclassOf: 'Object' instanceVariables: 'nonPointerObject <IndexedByteInstanceVariables>')) !


"December 26, 2009 -> 23:41:6"!

Delta define: #UnsafeAlien as: (
(Class subclassOf: 'Object' instanceVariables: 'nonPointerObject <IndexedByteInstanceVariables>')) !


"December 26, 2009 -> 23:41:6"!

Delta define: #UnsafeAlien as: (
(Class subclassOf: 'Object' instanceVariables: 'nonPointerObject <IndexedByteInstanceVariables>')) !


"December 26, 2009 -> 23:41:6"!

Delta define: #UnsafeAlien as: (
(Class subclassOf: 'Object' instanceVariables: 'nonPointerObject <IndexedByteInstanceVariables>')) !


"December 26, 2009 -> 23:41:6"!

Delta define: #UnsafeAlien as: (
(Class subclassOf: 'Object' instanceVariables: 'nonPointerObject <IndexedByteInstanceVariables>')) !


"December 26, 2009 -> 23:41:6"!

Delta define: #UnsafeAlien as: (
(Class subclassOf: 'Object' instanceVariables: 'nonPointerObject <IndexedByteInstanceVariables>')) !


"December 26, 2009 -> 23:41:6"!

Delta define: #UnsafeAlien as: (
(Class subclassOf: 'Object' instanceVariables: 'nonPointerObject <IndexedByteInstanceVariables>')) !


"December 26, 2009 -> 23:41:6"!

Delta define: #UnsafeAlien as: (
(Class subclassOf: 'Object' instanceVariables: 'nonPointerObject <IndexedByteInstanceVariables>')) !


"December 26, 2009 -> 23:41:6"!

Delta define: #UnsafeAlien as: (
(Class subclassOf: 'Object' instanceVariables: 'nonPointerObject <IndexedByteInstanceVariables>')) !


"December 26, 2009 -> 23:41:6"!

Delta define: #UnsafeAlien as: (
(Class subclassOf: 'Object' instanceVariables: 'nonPointerObject <IndexedByteInstanceVariables>')) !


"December 26, 2009 -> 23:41:6"!

(Delta mirrorFor: #UnsafeAlien)
comment: 
''!


"December 26, 2009 -> 23:41:6"!

! (Delta mirrorFor: #UnsafeAlien) classSide methodsFor: 'instance creation' !
forPointerTo: bytes <IndexedByteInstanceVariables> ^ <UnsafeAlien>

	^self new
		nonPointerObject: bytes;
		yourself
		! !

"December 26, 2009 -> 23:41:6"!

! (Delta mirrorFor: #UnsafeAlien) methodsFor: 'accessing' !
object

	^nonPointerObject! !

"December 26, 2009 -> 23:41:6"!

! (Delta mirrorFor: #UnsafeAlien) methodsFor: 'initialization' !
nonPointerObject: bytes <IndexedByteInstanceVariables>

	nonPointerObject := bytes! !

"December 26, 2009 -> 23:42:34"!

"System saved" !
"December 27, 2009 -> 12:26:26"!

Delta define: #ClassTestIvars123 as: (
(Class subclassOf: 'Object' instanceVariables: 'one' classInstanceVariables: 'two three')) !


"December 27, 2009 -> 12:26:26"!

(Delta mirrorFor: #ClassTestIvars123) removeDefinitionIfFail: [] !


"December 27, 2009 -> 12:26:58"!

Delta define: #ClassTestIvars123 as: (
(Class subclassOf: 'Object' instanceVariables: 'one' classInstanceVariables: 'two three')) !


"December 27, 2009 -> 12:26:58"!

(Delta mirrorFor: #ClassTestIvars123) removeDefinitionIfFail: [] !


"December 27, 2009 -> 12:27:50"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updateAll

	self changed: #tests.
	"self changed: #selectedSuite."
	self changed: #details.
	self changed: #passFail.
	self refreshWindow! !

"December 27, 2009 -> 12:27:56"!

Delta define: #ClassTestIvars123 as: (
(Class subclassOf: 'Object' instanceVariables: 'one' classInstanceVariables: 'two three')) !


"December 27, 2009 -> 12:27:56"!

(Delta mirrorFor: #ClassTestIvars123) removeDefinitionIfFail: [] !


"December 27, 2009 -> 12:28:10"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updateAll

	self changed: #tests.
	self changed: #selectedSuite.
	self changed: #details.
	self changed: #passFail.
	self refreshWindow! !

"December 27, 2009 -> 12:32:14"!

! (Delta mirrorFor: #TextModel) methodsFor: 'notification' !
update: anAspect

	anAspect == aspect
		ifTrue: [view
						inSessionProcessDo: [view model: (model perform: aspect)]]! !

"December 27, 2009 -> 12:32:45"!

! (Delta mirrorFor: #TextModel) methodsFor: 'notification' !
update: anAspect

	anAspect == aspect
		ifTrue: [model
						inSessionProcessDo: [view model: (model perform: aspect)]]! !

"December 27, 2009 -> 12:32:56"!

Delta define: #ClassTestIvars123 as: (
(Class subclassOf: 'Object' instanceVariables: 'one' classInstanceVariables: 'two three')) !


"December 27, 2009 -> 12:32:56"!

(Delta mirrorFor: #ClassTestIvars123) removeDefinitionIfFail: [] !


"December 27, 2009 -> 12:33:29"!

! (Delta mirrorFor: #TextModel) methodsFor: 'notification' !
update: anAspect

Transcript cr; show: 'Updating text view'.
	anAspect == aspect
		ifTrue: [model
						inSessionProcessDo: [view model: (model perform: aspect)]]! !

"December 27, 2009 -> 12:33:37"!

Delta define: #ClassTestIvars123 as: (
(Class subclassOf: 'Object' instanceVariables: 'one' classInstanceVariables: 'two three')) !


"December 27, 2009 -> 12:33:37"!

(Delta mirrorFor: #ClassTestIvars123) removeDefinitionIfFail: [] !


"December 27, 2009 -> 12:34:17"!

! (Delta mirrorFor: #TextModel) methodsFor: 'notification' !
update: anAspect

	anAspect == aspect
		ifTrue: [
			Transcript cr; show: 'Updating text view'.
			model inSessionProcessDo: [view model: (model perform: aspect)]]! !

"December 27, 2009 -> 12:34:28"!

Delta define: #ClassTestIvars123 as: (
(Class subclassOf: 'Object' instanceVariables: 'one' classInstanceVariables: 'two three')) !


"December 27, 2009 -> 12:34:28"!

(Delta mirrorFor: #ClassTestIvars123) removeDefinitionIfFail: [] !


"December 27, 2009 -> 12:35:49"!

! (Delta mirrorFor: #TextModel) methodsFor: 'notification' !
update: anAspect

	anAspect == aspect
		ifTrue: [
			| newText |
			newText := (model perform: aspect).
			Transcript cr; show: 'Updating text view ', aspect, ' = ', newText.
			model inSessionProcessDo: [view model: newText]]! !

"December 27, 2009 -> 12:36:14"!

Delta define: #ClassTestIvars123 as: (
(Class subclassOf: 'Object' instanceVariables: 'one' classInstanceVariables: 'two three')) !


"December 27, 2009 -> 12:36:14"!

(Delta mirrorFor: #ClassTestIvars123) removeDefinitionIfFail: [] !


"December 27, 2009 -> 12:48:50"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updateAll

	self changed: #tests.
	self changed: #selectedSuite.
	self changed: #details.
	self changed: #passFail.
	"self refreshWindow"! !

"December 27, 2009 -> 12:49:3"!

Delta define: #ClassTestIvars123 as: (
(Class subclassOf: 'Object' instanceVariables: 'one' classInstanceVariables: 'two three')) !


"December 27, 2009 -> 12:49:3"!

(Delta mirrorFor: #ClassTestIvars123) removeDefinitionIfFail: [] !


"December 27, 2009 -> 12:49:33"!

Delta define: #ClassTestIvars123 as: (
(Class subclassOf: 'Object' instanceVariables: 'one' classInstanceVariables: 'two three')) !


"December 27, 2009 -> 12:49:33"!

(Delta mirrorFor: #ClassTestIvars123) removeDefinitionIfFail: [] !


"December 27, 2009 -> 12:51:29"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
update: aspect with: value
self halt.
	self inSessionProcessDo: [self refreshTests]! !

"December 27, 2009 -> 12:51:37"!

(Delta mirrorFor: #ClassTestIvars123) removeDefinitionIfFail: [] !


"December 27, 2009 -> 12:52:21"!

(Delta mirrorFor: #ClassTestIvars123) removeDefinitionIfFail: [] !


"December 27, 2009 -> 12:53:27"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
update: aspect with: value
"notification from Delta of update to classes in system"
	self inSessionProcessDo: [self refreshTests]! !

"December 27, 2009 -> 12:58:16"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshTests

        tests := self buildTests.
        self changed: #tests.
        testSuite := nil.
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.
        self changed: #selectedFailureTest.             "added rew"
        self changed: #selectedErrorTest.               "added rew"
        self changed: #selectedSuite.
        "self refreshWindow"! !

"December 27, 2009 -> 12:58:25"!

Delta define: #ClassTestIvars123 as: (
(Class subclassOf: 'Object' instanceVariables: 'one' classInstanceVariables: 'two three')) !


"December 27, 2009 -> 12:58:25"!

(Delta mirrorFor: #ClassTestIvars123) removeDefinitionIfFail: [] !


"December 27, 2009 -> 13:0:58"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshTests

        tests := self buildTests.
        self changed: #tests.
        testSuite := nil.
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.
        self changed: #selectedFailureTest.             "added rew"
        self changed: #selectedErrorTest.               "added rew"
        self changed: #selectedSuite.
        self refreshWindow! !

"December 27, 2009 -> 13:1:17"!

! (Delta mirrorFor: #ClassTest) methodsFor: 'fixture' !
tearDown

	self classFixture isNil
		ifFalse: [(Mirror on: self classFixture) removeDefinitionIfFail: [:err| self signalFailure: err]].
	Processor yield! !

"December 27, 2009 -> 13:1:25"!

Delta define: #ClassTestIvars123 as: (
(Class subclassOf: 'Object' instanceVariables: 'one' classInstanceVariables: 'two three')) !


"December 27, 2009 -> 13:1:25"!

(Delta mirrorFor: #ClassTestIvars123) removeDefinitionIfFail: [] !


"December 27, 2009 -> 13:7:27"!

! (Delta mirrorFor: #TextModel) methodsFor: 'notification' !
update: anAspect

	anAspect == aspect
		ifTrue: [
			| newText |
			newText := (model perform: aspect).
			newText = 'N/A'
				ifTrue: [self halt].
			Transcript cr; show: 'Updating text view ', aspect, ' = ', newText.
			model inSessionProcessDo: [view model: newText]]! !

"December 27, 2009 -> 13:7:38"!

Delta define: #ClassTestIvars123 as: (
(Class subclassOf: 'Object' instanceVariables: 'one' classInstanceVariables: 'two three')) !


"December 27, 2009 -> 13:7:38"!

(Delta mirrorFor: #ClassTestIvars123) removeDefinitionIfFail: [] !


"December 27, 2009 -> 13:11:19"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
update: aspect with: value
"notification from Delta of update to classes in system"
	self inSessionProcessDo: [self refreshTests].
	Processor yield! !

"December 27, 2009 -> 13:12:2"!

Delta define: #ClassTestIvars123 as: (
(Class subclassOf: 'Object' instanceVariables: 'one' classInstanceVariables: 'two three')) !


"December 27, 2009 -> 13:12:2"!

(Delta mirrorFor: #ClassTestIvars123) removeDefinitionIfFail: [] !


"December 27, 2009 -> 13:31:10"!

"System saved" !
"December 28, 2009 -> 12:14:41"!

Delta define: #ClassTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"December 28, 2009 -> 12:14:41"!

Delta define: #ClassTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"December 28, 2009 -> 12:14:41"!

Delta define: #ClassTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"December 28, 2009 -> 12:14:41"!

Delta define: #ClassTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"December 28, 2009 -> 12:14:41"!

Delta define: #ClassTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"December 28, 2009 -> 12:14:41"!

Delta define: #ClassTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"December 28, 2009 -> 12:14:41"!

Delta define: #ClassTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"December 28, 2009 -> 12:14:41"!

Delta define: #ClassTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"December 28, 2009 -> 12:14:41"!

Delta define: #ClassTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"December 28, 2009 -> 12:14:41"!

Delta define: #ClassTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"December 28, 2009 -> 12:14:41"!

Delta define: #ClassTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"December 28, 2009 -> 12:14:41"!

(Delta mirrorFor: #ClassTest)
comment: 
''!


"December 28, 2009 -> 12:14:41"!

! (Delta mirrorFor: #ClassTest) methodsFor: 'fixture' !
tearDown

	self classFixture isNil
		ifFalse: [(Mirror on: self classFixture) removeDefinitionIfFail: [:err| self signalFailure: err]].
	Processor yield! !

"December 28, 2009 -> 12:14:41"!

! (Delta mirrorFor: #ClassTest) methodsFor: 'testing' !
classFixture

	^Smalltalk at: self fixtureClassName ifAbsent: []! !

"December 28, 2009 -> 12:14:41"!

! (Delta mirrorFor: #ClassTest) methodsFor: 'testing' !
fixtureClassName

	^#ClassTestIvars123! !

"December 28, 2009 -> 12:14:41"!

! (Delta mirrorFor: #ClassTest) methodsFor: 'testing' !
testCreateClassWithInstanceAndClassInstanceVariables

	|mirror|
	self assert: self classFixture isNil.
	
	Delta define: self fixtureClassName as: (
		Class subclassOf: 'Object'
			instanceVariables: 'one'
			classInstanceVariables: 'two three').
	
	self deny: self classFixture isNil.
	
	mirror := Mirror on: self classFixture.
	self assert: mirror classInstanceVariableString = 'two three'.
	self assert: mirror instanceVariableString = 'one'! !

"December 28, 2009 -> 12:14:42"!

Delta define: #InstanceVariableOutliner as: (
(Class subclassOf: 'DefinitionItemOutliner' instanceVariables: '')) !


"December 28, 2009 -> 12:14:42"!

Delta define: #InstanceVariableOutliner as: (
(Class subclassOf: 'DefinitionItemOutliner' instanceVariables: '')) !


"December 28, 2009 -> 12:14:42"!

Delta define: #InstanceVariableOutliner as: (
(Class subclassOf: 'DefinitionItemOutliner' instanceVariables: '')) !


"December 28, 2009 -> 12:14:42"!

Delta define: #InstanceVariableOutliner as: (
(Class subclassOf: 'DefinitionItemOutliner' instanceVariables: '')) !


"December 28, 2009 -> 12:14:42"!

Delta define: #InstanceVariableOutliner as: (
(Class subclassOf: 'DefinitionItemOutliner' instanceVariables: '')) !


"December 28, 2009 -> 12:14:42"!

Delta define: #InstanceVariableOutliner as: (
(Class subclassOf: 'DefinitionItemOutliner' instanceVariables: '')) !


"December 28, 2009 -> 12:14:42"!

Delta define: #InstanceVariableOutliner as: (
(Class subclassOf: 'DefinitionItemOutliner' instanceVariables: '')) !


"December 28, 2009 -> 12:14:42"!

Delta define: #InstanceVariableOutliner as: (
(Class subclassOf: 'DefinitionItemOutliner' instanceVariables: '')) !


"December 28, 2009 -> 12:14:42"!

Delta define: #InstanceVariableOutliner as: (
(Class subclassOf: 'DefinitionItemOutliner' instanceVariables: '')) !


"December 28, 2009 -> 12:14:42"!

Delta define: #InstanceVariableOutliner as: (
(Class subclassOf: 'DefinitionItemOutliner' instanceVariables: '')) !


"December 28, 2009 -> 12:14:42"!

Delta define: #InstanceVariableOutliner as: (
(Class subclassOf: 'DefinitionItemOutliner' instanceVariables: '')) !


"December 28, 2009 -> 12:14:42"!

(Delta mirrorFor: #InstanceVariableOutliner)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"December 28, 2009 -> 12:14:42"!

! (Delta mirrorFor: #InstanceVariableOutliner) methodsFor: 'accessing' !
locator ^ <ClassVarLocator>

^InstVarLocator ofDefinition: self mirror basicLocator! !

"December 28, 2009 -> 12:14:42"!

! (Delta mirrorFor: #InstanceVariableOutliner) methodsFor: 'control' !
referencesToInstVar

	self launchListDialogWithPainter: Painter default
		title: 'Select instance variable'
		contents: self instVarNames
		multi: false
		action: [:items|
			| references instVar |
			instVar := self instVarNames at: items anElement.
			references := Smalltalk 
										referencesToInstVarName: instVar
										for: self mirror mixin reflectee halt.
			self
				launchSelectorListWithPainter: Painter default
				title: 'References to instance variable "', instVar, '"'
				contents: references]! !

"December 28, 2009 -> 12:14:42"!

! (Delta mirrorFor: #InstanceVariableOutliner) methodsFor: 'menus' !
hasMenu ^<Boolean>

	^true! !

"December 28, 2009 -> 12:14:42"!

! (Delta mirrorFor: #InstanceVariableOutliner) methodsFor: 'menus' !
menuBar ^<Menu>

	^Menu new
		add: (MenuAction new
					name: 'References...';
					action: [ self referencesToInstVar ])
! !

"December 28, 2009 -> 12:14:42"!

! (Delta mirrorFor: #InstanceVariableOutliner) methodsFor: 'private' !
aspectForUpdate ^ <Symbol>

	^#instanceVariables
! !

"December 28, 2009 -> 12:14:42"!

! (Delta mirrorFor: #InstanceVariableOutliner) methodsFor: 'private' !
header ^ <Str>

	^'Instance variables'! !

"December 28, 2009 -> 12:14:42"!

! (Delta mirrorFor: #InstanceVariableOutliner) methodsFor: 'private' !
instVarNames

	| names |
	names := OrderedCollection new.
	self mirror instanceVariablesDo: [:var|
		names add: var name].
	^names
		! !

"December 28, 2009 -> 12:14:42"!

! (Delta mirrorFor: #InstanceVariableOutliner) methodsFor: 'private' !
modelAsCharGlyphs ^ <CharGlyphs>

	| tool <ASTtoRichTextTool[CharGlyph]> pts <Cltn[ParseTree]> |
	self useRichTextForSources
		ifTrue: [
			pts := DeltaParser new
							parseInstVarList: self mirror instanceVariableString 
							within: (DeltaScope within: nil)
							ifError: [ :msg <Str> :pos <Int> | self shouldNotHappen ].
			^pts isEmpty
				ifTrue: [ 		OrderedCollection[CharGlyphs] new ]
				ifFalse: [ 	self richTextForParseTrees: pts ] ]
		ifFalse: [
			^self standardTextForString: self mirror instanceVariableString painter: self codePainter ]

! !

"December 28, 2009 -> 12:14:42"!

! (Delta mirrorFor: #InstanceVariableOutliner) methodsFor: 'private' !
storeAndOnSuccess: blk <[]>

	"The right way to do this is to have a #instanceVariables:ifFail: in ClassMirror and MixinDeclMirror
		that will parse and	update accordingly.
		
		In the meantime, we parse an extra time here to check for errors and call #instanceVariables: afterwards.
		This should be changed shortly."
		
	| ivs <Str> eval <Str> constructor <Mirror> |
	self deltaHack.
	ivs := self charGlyphModelAsString: self codeView.
	DeltaParser new 
		parseInstVarList: ivs
		within: (DeltaScope within: nil)
		ifError: [ :msg <Str> :pos <Int> | ^self showParseError: msg at: pos in: self codeView ].
	self mirror instanceVariables: ivs.
	blk value.
! !

"December 28, 2009 -> 12:14:42"!

! (Delta mirrorFor: #InstanceVariableOutliner) methodsFor: 'typechecking' !
typecheck

self typecheckAction:[self mirror typecheckInstVars]
		title: 'Typechecking ', self mirror name, ' instance variables'.! !

"December 28, 2009 -> 12:14:42"!

Delta define: #Smalltalk as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'InitializingTypeInfo <Boolean>
	ClassesWithSubclasses <IdentitySet[Class]> 
	Cache <IdentityDict[Symbol, GlobalAssociation]>
	DependencyObject <NotifyingObject>
		"We have an explicit dependency object since one has to mix in
			NotifyingObject mixin to get dependency behavior. Smalltalk is
			currently just a class, so this is not possible."
	FileInDirectory <FilePath>') !


"December 28, 2009 -> 12:14:42"!

Delta define: #Smalltalk as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'InitializingTypeInfo <Boolean>
	ClassesWithSubclasses <IdentitySet[Class]> 
	Cache <IdentityDict[Symbol, GlobalAssociation]>
	DependencyObject <NotifyingObject>
		"We have an explicit dependency object since one has to mix in
			NotifyingObject mixin to get dependency behavior. Smalltalk is
			currently just a class, so this is not possible."
	FileInDirectory <FilePath>') !


"December 28, 2009 -> 12:14:42"!

Delta define: #Smalltalk as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'InitializingTypeInfo <Boolean>
	ClassesWithSubclasses <IdentitySet[Class]> 
	Cache <IdentityDict[Symbol, GlobalAssociation]>
	DependencyObject <NotifyingObject>
		"We have an explicit dependency object since one has to mix in
			NotifyingObject mixin to get dependency behavior. Smalltalk is
			currently just a class, so this is not possible."
	FileInDirectory <FilePath>') !


"December 28, 2009 -> 12:14:42"!

Delta define: #Smalltalk as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'InitializingTypeInfo <Boolean>
	ClassesWithSubclasses <IdentitySet[Class]> 
	Cache <IdentityDict[Symbol, GlobalAssociation]>
	DependencyObject <NotifyingObject>
		"We have an explicit dependency object since one has to mix in
			NotifyingObject mixin to get dependency behavior. Smalltalk is
			currently just a class, so this is not possible."
	FileInDirectory <FilePath>') !


"December 28, 2009 -> 12:14:42"!

Delta define: #Smalltalk as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'InitializingTypeInfo <Boolean>
	ClassesWithSubclasses <IdentitySet[Class]> 
	Cache <IdentityDict[Symbol, GlobalAssociation]>
	DependencyObject <NotifyingObject>
		"We have an explicit dependency object since one has to mix in
			NotifyingObject mixin to get dependency behavior. Smalltalk is
			currently just a class, so this is not possible."
	FileInDirectory <FilePath>') !


"December 28, 2009 -> 12:14:42"!

Delta define: #Smalltalk as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'InitializingTypeInfo <Boolean>
	ClassesWithSubclasses <IdentitySet[Class]> 
	Cache <IdentityDict[Symbol, GlobalAssociation]>
	DependencyObject <NotifyingObject>
		"We have an explicit dependency object since one has to mix in
			NotifyingObject mixin to get dependency behavior. Smalltalk is
			currently just a class, so this is not possible."
	FileInDirectory <FilePath>') !


"December 28, 2009 -> 12:14:42"!

Delta define: #Smalltalk as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'InitializingTypeInfo <Boolean>
	ClassesWithSubclasses <IdentitySet[Class]> 
	Cache <IdentityDict[Symbol, GlobalAssociation]>
	DependencyObject <NotifyingObject>
		"We have an explicit dependency object since one has to mix in
			NotifyingObject mixin to get dependency behavior. Smalltalk is
			currently just a class, so this is not possible."
	FileInDirectory <FilePath>') !


"December 28, 2009 -> 12:14:42"!

Delta define: #Smalltalk as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'InitializingTypeInfo <Boolean>
	ClassesWithSubclasses <IdentitySet[Class]> 
	Cache <IdentityDict[Symbol, GlobalAssociation]>
	DependencyObject <NotifyingObject>
		"We have an explicit dependency object since one has to mix in
			NotifyingObject mixin to get dependency behavior. Smalltalk is
			currently just a class, so this is not possible."
	FileInDirectory <FilePath>') !


"December 28, 2009 -> 12:14:42"!

Delta define: #Smalltalk as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'InitializingTypeInfo <Boolean>
	ClassesWithSubclasses <IdentitySet[Class]> 
	Cache <IdentityDict[Symbol, GlobalAssociation]>
	DependencyObject <NotifyingObject>
		"We have an explicit dependency object since one has to mix in
			NotifyingObject mixin to get dependency behavior. Smalltalk is
			currently just a class, so this is not possible."
	FileInDirectory <FilePath>') !


"December 28, 2009 -> 12:14:42"!

Delta define: #Smalltalk as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'InitializingTypeInfo <Boolean>
	ClassesWithSubclasses <IdentitySet[Class]> 
	Cache <IdentityDict[Symbol, GlobalAssociation]>
	DependencyObject <NotifyingObject>
		"We have an explicit dependency object since one has to mix in
			NotifyingObject mixin to get dependency behavior. Smalltalk is
			currently just a class, so this is not possible."
	FileInDirectory <FilePath>') !


"December 28, 2009 -> 12:14:42"!

Delta define: #Smalltalk as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'InitializingTypeInfo <Boolean>
	ClassesWithSubclasses <IdentitySet[Class]> 
	Cache <IdentityDict[Symbol, GlobalAssociation]>
	DependencyObject <NotifyingObject>
		"We have an explicit dependency object since one has to mix in
			NotifyingObject mixin to get dependency behavior. Smalltalk is
			currently just a class, so this is not possible."
	FileInDirectory <FilePath>') !


"December 28, 2009 -> 12:14:42"!

(Delta mirrorFor: #Smalltalk)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"December 28, 2009 -> 12:14:42"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'accessing' !
assocAt: key <Str> ^ <GlobalAssociation>

^self assocAt: key ifAbsent:[self error: key, ' not found in System Dictionary'].! !

"December 28, 2009 -> 12:14:42"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'accessing' !
assocAt: key <Str>  ifAbsent: blk <[]> ^ <GlobalAssociation>

^self cache at: key ifAbsent: blk! !

"December 28, 2009 -> 12:14:42"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'accessing' !
at: key <Str> ^ <Object>

^self at: key ifAbsent: [self error: key, ' not found in System Dictionary']! !

"December 28, 2009 -> 12:14:42"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'accessing' !
at: key <Str> ifAbsent: blk <[^Object]> ^ <Object>

	^(self cache at: key ifAbsent: [^blk value]) value! !

"December 28, 2009 -> 12:14:42"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'accessing' !
at: key <Str> put: value <Object> ^ <Object>

| assoc <GlobalAssociation> |
self flushCache.
(assoc := self assocAt: key ifAbsent: [nil]) isNil
	ifTrue: [		{{primitiveSmalltalkAt: key Put: value ifFail: [ :err <Symbol> |  self error: err ]}}.
						self cache at: key put: (self uncachedAssocAt: key) ]
	ifFalse: [	self changedRemoveKey: key value: assoc value.
						assoc value: value ].
self changedAddKey: key value: value.
^value! !

"December 28, 2009 -> 12:14:42"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'accessing' !
removeKey: key <Str> ^ <Object>

^self removeKey: key ifAbsent: [self error: key, ' not found in System Dictionary']! !

"December 28, 2009 -> 12:14:42"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'accessing' !
removeKey: key <Str> ifAbsent: blk <[^Object]> ^ <Object>

| assoc <GlobalAssociation> |

self flushCache.
1 to: self size do: [ :index <Int> |
	assoc := {{primitiveSmalltalkAt: index ifFail: [ :err <Symbol> |  self error: err ]}}.
	assoc key = key ifTrue: [
		{{primitiveSmalltalkRemoveAt: index ifFail: [ :err <Symbol> |  self error: err ]}}.
		self changedRemoveKey: key  value: assoc value.
		^key ].
].
^blk value! !

"December 28, 2009 -> 12:14:42"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'accessing' !
size ^ <SmallInteger>

^{{primitiveSmalltalkSize}}! !

"December 28, 2009 -> 12:14:42"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'binding' !
declareGlobal: name <Symbol> type: type <Str>

^self declareGlobal: name type: type initialValue:self nilObj
   ! !

"December 28, 2009 -> 12:14:42"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'binding' !
declareGlobal: name <Symbol>  type: type <Str> ifFail: blk <[Str, ^DoesNotMatter]>

^self declareGlobal: name type: type initialValue:self nilObj ifFail: blk
   ! !

"December 28, 2009 -> 12:14:42"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'binding' !
declareGlobal: name <Symbol>  type: type <Str> ifThere: blk <[Str, ^DoesNotMatter]>

^self declareGlobal: name type: type initialValue:self nilObj ifThere: blk
   ! !

"December 28, 2009 -> 12:14:42"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'binding' !
declareGlobal: name <Symbol> type: type <Str>  initialValue: initVal <Object>

self declareGlobal: name type: type initialValue: initVal ifThere:[ :msg <Str>  | Transcript show: msg; cr].
   ! !

"December 28, 2009 -> 12:14:42"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'binding' !
declareGlobal: name <Symbol> type: type <Str> initialValue: initVal <Object> ifFail: blk <[Str, ^BottomType]>

self assert:[type isString].
self assert:[name isString or:[name isSymbol]].
(self includesKey: name) ifTrue: [ ^blk value: 'already defined'].
self at: name asSymbol put: initVal.
(GlobalVariableMirror on: (self assocAt: name)) declaredType: type ifFail: [: s <Str> :i <Int> | blk value: s].
! !

"December 28, 2009 -> 12:14:42"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'binding' !
declareGlobal: name <Symbol> type: type <Str> initialValue: initVal <Object> ifThere: blk <[Str, ^BottomType]>

self assert:[type isString].
self assert:[name isString or:[name isSymbol]].
(self includesKey: name) ifTrue: [ blk value: 'already defined'].
self at: name asSymbol put: initVal.
(GlobalVariableMirror on: (self assocAt: name)) declaredType: type ifFail: [: s <Str> :i <Int> | blk value: s].! !

"December 28, 2009 -> 12:14:42"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'binding' !
define: name <Symbol>  as: constructor <Mirror>
    self define: name as: constructor category: nil! !

"December 28, 2009 -> 12:14:42"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'binding' !
define: name <Symbol> as: constructor <Mirror> category: cat <Symbol>

	"Define or change entry based on the constructor"

	self at: name
		ifAbsent: [DeltaGlobals at: name put: (constructor placeHolderFor: name).].
                 
	constructor name: name ifFail:[: e <Str> | self error: 'Could not install ', name, ' : ', e.].   
	(self assocAt: name) makeConstant.            

	DeltaGlobals removeKey: name ifAbsent:[].
	ClassesWithSubclasses := nil		"Potential class hierarchy change occurred, clear cached info"
! !

"December 28, 2009 -> 12:14:42"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'binding' !
let: aSymbol <Symbol> be: aString <Str>
	"Define type alias based on aString"

self let: aSymbol be: aString ifFail: [:e <Str> | self error: e]
! !

"December 28, 2009 -> 12:14:42"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'binding' !
let: aSymbol <Symbol> be: aString <Str> ifFail: fb <[Str, ^DoesNotMatter]>
	"Define type alias based on aString"

	| entry <Object> |

     entry := self at: aSymbol ifAbsent: [
		self at: aSymbol put:  ((TypeAliasMirror on: (TypeAlias new name: aSymbol)) alias: aString) reflectee].
     entry class = TypeAlias 
            ifFalse:[
                           (self assocAt: aSymbol) isConstant 
                                    ifTrue:[fb value: 'Cannot define type alias ', aSymbol, ' . Remove ', entry class name, ' ', aSymbol, ' first. '].
                           self at: aSymbol put: entry
                           ].  
	"Existing entry will be overridden"
	(self assocAt: aSymbol) makeConstant.
	(TypeAliasMirror on: entry) alias: aString.

	"This version parses and sets source twice if code is legal."
	self deltaHack.
	"There no handling of dependencies. Also, only aliases for types are allowed. 
	Also, this should probably work as part of the general scheme for converting among entities"
! !

"December 28, 2009 -> 12:14:42"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'dependencies' !
addDependent: o <Object>

	DependencyObject addDependent: o ! !

"December 28, 2009 -> 12:14:42"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'dependencies' !
changedAddKey: key <Object> value: value <Object>

	DependencyObject changed: #addGlobal with: key ,, value! !

"December 28, 2009 -> 12:14:42"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'dependencies' !
changedRemoveKey: key <Object> value: oldValue <Object>

	DependencyObject changed: #removeGlobal with: key ,, oldValue! !

"December 28, 2009 -> 12:14:42"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'dependencies' !
removeDependent: o <Object>

	DependencyObject removeDependent: o ! !

"December 28, 2009 -> 12:14:42"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'evaluation' !
blockToEvaluateFor: src <Str> ifError: blk <[Str,Int,^X def]> ^<[] | X>
	"Build and return a block that when evaluated executes src, which is a piece of top-level smalltalk source code"

	^self blockToEvaluateFor: src receiver: nil ifError: blk
! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'evaluation' !
blockToEvaluateFor: src <Str> receiver: oop <Object> ifError: blk <[Str,Int,^X def]> ^<[] | X>
	"Build and return a block that when evaluated executes src,  which is a piece of smalltalk source code in scope of oop"

	| scope <DeltaScope> ast <DeltaMethod> method <Method> |
	scope := DeltaUntypedClassScope for: (AbstractClassMirror on: oop class).
	ast := (DeltaParser new parseDoitExpr: src within: scope ifError: [ :m <Str> :p <Int> | ^blk value: m value: p ]) body.
	ast := DeltaRewriter new rewrite: ast.
	method := (DeltaCompiler forClass: nil optimize: false ifError: [self error: 'Compilation error']) compileDoit: ast.
	^method convertToClosure: oop
! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'evaluation' !
evaluate: src <Str> ifError: blk <[Str,Int,^X def]> ^<Object | X>
	"Execute src which is a piece of top-level smalltalk source code"
	
	^(self blockToEvaluateFor: src ifError: [ :err <Str> :spot <Int> |	^blk value: err value: spot ]) value
! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'evaluation' !
evaluate: src <Str> receiver: oop <Object> ifError: blk <[Str,Int,^X def]> ^<Object | X>
	"Execute src which is a piece of smalltalk source code in the scope of oop"
	
	^(self blockToEvaluateFor: src receiver: oop ifError: [ :err <Str> :spot <Int> | ^blk value: err value: spot ]) value
! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'evaluation' !
recompileAllMethods

	| counter <Int> |
	counter := 0.
	self classesAndMixinsReflectiveDo: [ :mirror <ClassMirror|MixinMirror> |
		Platform errorStream show: 'Recompiling ', mirror name; cr.
		mirror recompileAllMethodsIfFail: [ self shouldNotHappen ].
		"(counter := counter + 1) = 20
			ifTrue: [	counter := 0. VM collectGarbage ]"
	]

! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file in - temporary' !
fileInDirectory ^ <FilePath>

	FileInDirectory isNil
		ifTrue: [FileInDirectory := FilePath currentDirectory].
	^FileInDirectory! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file in - temporary' !
fileInDirectory: directory <FilePath>

	FileInDirectory := directory! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file in - temporary' !
fileInFromAbsFile: file <FilePath>

	| stream <CharInputStream> savedDirectory <FilePath> |
	Transcript cr; show: 'Filing in from file ', file name.
	savedDirectory := self fileInDirectory.
	self fileInDirectory: file containingDirectory.
	[stream := file charInputStream.
	[ stream fileIn ] ensure: [ stream close ]]
		ensure: [self fileInDirectory: savedDirectory]! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file in - temporary' !
fileInFromFile: file <FilePath>

	| absFile <FilePath> |
	absFile := file isAbsolute
						ifTrue: [file]
						ifFalse: [self fileInDirectory, file].
	
	self fileInFromAbsFile: absFile! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file in - temporary' !
fileInWorld
"Temporary hack to build clean source base. Use this only if you know
what you are doing!!"
| i <Integer>  pc <OrderedCollection[Str]> |
i := 0.
self classesDo:[:c <Class> | 
                           self fileInFromFile: (FilePath for: 'world\', c name,'.dlt').
                           i > 99 ifTrue:[ i := 0.
                           Type zapAllTypes.
                            VM collectGarbage.] ifFalse:[i := i + 1.].
                           ].                                                    
                           Transcript show: 'Done with classes'; cr.
self mixinsDo:[:m <Mixin> | 
                           m isMeta ifFalse:[self fileInFromFile: (FilePath for: 'world\',m name,'.dlt')].
                           ].
 self typeAliasesDo:[:t <TypeAlias> | 
                           self fileInFromFile: (FilePath for: 'world\', t name,'.str').
                           ].
                           
 pc := OrderedCollection[Str] new.
self protocolsDo:[:p <Protocol> | pc add: p name].
pc do:[:n <Str> | self removeKey: n].

pc do:[:pn <Str> | 
                           self fileInFromFile: (FilePath for: 'world\', pn,'.str').
                           ].! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file out' !
fileOutWorldToFile: file <FilePath>

	| 	openGroups <Dictionary[Str,CharOutputStream]> 
		worldDir <FilePath> 
		worldName <Str> 
		ap <IdentitySet[Object]>
		sortedClasses <SortedCollection[Class]>
		sortedMixins <SortedCollection[Mixin]>
		sortedProtocols <SortedCollection[Protocol]>
		sortedTypeAliases <SortedCollection[TypeAlias]>
		sortedGlobalVariables <SortedCollection[GlobalAssociation]>
		|

	sortedClasses := SortedCollection[Class] sortBlock: [ :e1 <Class> :e2 <Class> | e1 name <= e2 name ].
	Smalltalk classesDo: [ :class <Class> | sortedClasses add: class ].
	sortedMixins := SortedCollection[Mixin] sortBlock: [ :e1 <Mixin> :e2 <Mixin> | e1 name <= e2 name ].
	Smalltalk mixinsDo: [ :mixin <Mixin> | sortedMixins add: mixin ].	
	sortedProtocols := SortedCollection[Protocol] sortBlock: [ :e1 <Protocol> :e2 <Protocol> | e1 name <= e2 name ].
	Smalltalk protocolsDo: [ :protocol <Protocol> | sortedProtocols add: protocol ].	
	sortedTypeAliases := SortedCollection[TypeAlias] sortBlock: [ :e1 <TypeAlias> :e2 <TypeAlias> | e1 name <= e2 name ].
	Smalltalk typeAliasesDo: [ :alias <TypeAlias> | sortedTypeAliases add: alias  ].
	sortedGlobalVariables := SortedCollection[GlobalAssociation] 
															sortBlock: [ :e1 <GlobalAssociation> :e2 <GlobalAssociation> | 
																					e1 key <= e2 key ].
	Smalltalk globalVariablesDo: [ :global <GlobalAssociation> | sortedGlobalVariables add: global  ].

	openGroups := Dictionary[Str,CharOutputStream] new.
	worldName := file elements last name readStream upTo: $. .
	worldDir := file containingDirectory.
	ap := IdentitySet[Object] new.
	[	
		sortedClasses do: [ :class <Class> |
			self traverseClass: class alreadyProcessed: ap do: [ :e <Class|Mixin> | 
				self fileOutDefinition: (Mirror on: e) directory: worldDir world: worldName openGroups: openGroups ] ].
		sortedMixins do: [ :mixin <Mixin> |
			self traverseMixin: mixin alreadyProcessed: ap do: [ :e <Class|Mixin> | 
				self fileOutDefinition: (Mirror on: e) directory: worldDir world: worldName openGroups: openGroups ] ].
		sortedProtocols do: [ :e <Protocol> | 
			self fileOutDefinition: (ProtocolMirror on: e) directory: worldDir world: worldName openGroups: openGroups ].
		sortedTypeAliases do: [ :e <TypeAlias> | 
			self fileOutDefinition: (TypeAliasMirror on: e) directory: worldDir world: worldName openGroups: openGroups ].
		sortedGlobalVariables do: [ :e <GlobalAssociation> | | g <GlobalVariableMirror> |
			g := GlobalVariableMirror on: e.
			g declaredTypeString isEmpty 
				ifFalse:[self fileOutDefinition: g directory: worldDir world: worldName openGroups: openGroups ]].
	] ensure: [
		openGroups do: [ :stream <CharOutputStream> | stream close ]
	].
	(Workspace coerce: Transcript) visual
		promptOk: 'File out world done'
		title: 'Information'
		type: #exclamation
		action: []
! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file out-private' !
defaultFileoutRevision ^ <Str>

	^'"$Revi', 'sion:$"'			"Protect string from RCS !!"! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file out-private' !
fileOutDefinition: m <Mirror> directory: dir <FilePath> world: w <Str> openGroups: ogs <Dictionary[Str, CharOutputStream]>

	| defStream <CharOutputStream> |
	defStream := CharacterInputOutputConverter on: (dir, (FilePath for: m fileName)) writeStream.
	[ (DefinitionWriter for: m) fileOutOn: defStream ] ensure: [ defStream close ].
	(self groupFor: w directory: dir openGroups: ogs)
		nextPutAll: 'Delta fileInFromFile: (FilePath for: ', m fileName printString, ') !!'; cr; flush.
	(self groupFor: m group directory: dir openGroups: ogs)
		nextPutAll: 'Delta fileInFromFile: (FilePath for: ', m fileName printString, ') !!'; cr; flush.
! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file out-private' !
groupFileExtension ^ <Str>

	^'.gr'! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file out-private' !
groupFor: name <Str>  directory: dir <FilePath> openGroups: ogs <Dictionary[Str, CharOutputStream]> ^ <CharOutputStream>

	| file <FilePath> rs <CharInputStream> ws <CharOutputStream> revision <Str> |
	(ws := ogs at: name ifAbsent: [ nil ]) notNil
		ifTrue: [	^ws ].
	file := dir, (FilePath for: (name, self groupFileExtension)).
	file exists
		ifTrue: 	[	rs := file charInputStream.
							[ revision := rs nextChunk ] ensure: [ rs close ] ]
		ifFalse: 	[	revision := self defaultFileoutRevision ].
	ws := file charOutputStream.
	ws nextChunkPut: revision; cr.
	^ogs at: name put: ws! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file out-private' !
traverseClass: class <Class> alreadyProcessed: ap <IdentitySet[Object]> do: blk <[Class|Mixin]>

	| sc <Behavior> mvm <MixinVMMirror> master <Class> |
	(ap includes: class) 
		ifTrue: [	^self ].
	sc := class superclassIfAbsent: [ nil ].
	sc notNil
		ifTrue: [	self traverseClass: sc alreadyProcessed: ap do: blk ].
	mvm := (ClassVMMirror on: class) mixin.
	master := mvm masterInvocation.
	master == class
		ifTrue: [		blk value: class ]
		ifFalse: [	master isNil
								ifTrue: [		self traverseMixin: mvm reflectee alreadyProcessed: ap do: blk ]
								ifFalse: [	self traverseClass: master alreadyProcessed: ap do: blk ] ].
    ap add: class
! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file out-private' !
traverseMixin: mixin <Mixin> alreadyProcessed: ap <IdentitySet[Object]> do: blk <[Class|Mixin]>

	| sct <Type> |
	(ap includes: mixin) 
		ifTrue: [	^self ].
	sct := (Type for: mixin) superclassType.
	sct notNil
		ifTrue: [	self traverseClass: sct classObj alreadyProcessed: ap do: blk ].
	blk value: mixin.
    ap add: mixin
! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'initialization' !
initialize
	DeltaCache := Dictionary new.
	BootStrapping := true.
	Delta := Smalltalk.
	DeltaGlobals := DeltaGlobalScope new initialize: Delta.
	Type := DeltaType.
	Type init.
	DeltaCopyDownMethods := false.
	DeltaTracePrimitiveCalls := false.
	DeltaHCodeGenerator initializeBCTable.
	DeltaScanner initialize.
	MixinDeclMirror init.
	self initializeUpdateInfo.
	EnableFloatValues := true.
	AutoFloatConversion := false.
	ReportTypeLoading := false.
	DependencyObject := NotifyingObject new.
! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'initializing type info - temporary' !
addBasicTypeStructureForClass: class

self addBasicTypeStructureForInvocation: class.
self addBasicTypeStructureForMixin: class mixin.
! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'initializing type info - temporary' !
addBasicTypeStructureForInvocation: class

class typeInfo: (DeltaMixinInvocationSide new initialize klass: class).
class klass typeInfo: (DeltaMixinInvocationSide new initialize klass: class klass).
class typeInfo dual: class klass typeInfo.
class klass typeInfo dual: class typeInfo.

! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'initializing type info - temporary' !
addBasicTypeStructureForMixin: mixin

| cDecl mixinTypeInfo classSideTypeInfo mirror i |

Type typeData at: mixin ifAbsent: [ 
	cDecl := DeltaClassUpdate new  abstract: false; 
                                                       branded: true; 
                                                       monotonic: true; 
                                                       subtype: true.
	mixinTypeInfo :=  DeltaSideUpdate new initialize.
	cDecl instanceSide: mixinTypeInfo.

	classSideTypeInfo := DeltaSideUpdate new initialize classDecl: cDecl.

	mixin typeInfo: mixinTypeInfo.
	mixin classMixin typeInfo: classSideTypeInfo.

	"Add instvar and classvar decls to scopes"

	mirror := MixinVMMirror on: mixin.

	i := 1.
	mirror instVarNamesDo: [ :n | 
		mixinTypeInfo scope at: n put: ((DeltaInstVar new name: n type: nil) ordinalNumber: i). i := i + 1].
	mirror classVarNamesDo: [ :n |
		| var |
		var := DeltaClassVar new name: n type: nil.
		mixinTypeInfo scope at: n put: var.
		classSideTypeInfo scope at: n put: var]
]! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'initializing type info - temporary' !
addBasicTypeStructureToObject

| class cDecl mixinTypeInfo |


class := self at: #Object.
class typeInfo: (DeltaObjectInvocationSide new initialize klass: class).
class klass typeInfo: (DeltaObjectClassInvocationSide new initialize klass: class klass).
class typeInfo dual: class klass typeInfo.
class klass typeInfo dual: class typeInfo.


cDecl := DeltaClassUpdate new abstract: false; 
                                                       branded: true; 
                                                       monotonic: true; 
                                                       subtype: true.
mixinTypeInfo :=  DeltaSide new initialize.
cDecl instanceSide: mixinTypeInfo.

class mixin typeInfo: mixinTypeInfo.
class mixin classMixin typeInfo: (DeltaObjectClassSide new initialize classDecl: cDecl).
! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'initializing type info - temporary' !
addSuperclassTypeStructureForClass: class

self addSuperclassTypeStructureForInvocation: class.
class isMixinInvocation ifFalse: [
	class mixin typeInfo superclassType:(self classReferenceTo: class superclass).
	class klass mixin typeInfo superclassType: (self metaclassReferenceTo: class superclass)].
! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'initializing type info - temporary' !
addSuperclassTypeStructureForInvocation: class

class typeInfo superclassType: (self classReferenceTo: class superclass).
class klass typeInfo superclassType: (self metaclassReferenceTo: class superclass).
! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'initializing type info - temporary' !
addSuperclassTypeStructureToObject

| class  object |

object := self at: #Object.
class := self at: #Class.

"set up Object superclass type info on class side, at invocation and at mixin"
self addBasicTypeStructureForClass: class.

class typeInfo mixinType: class mixin typeInfo.
class klass typeInfo mixinType: class klass mixin typeInfo.

object klass typeInfo superclassType:(self classReferenceTo: class).
object klass mixin typeInfo superclassType: (self classReferenceTo: class).
! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'initializing type info - temporary' !
addTypeStructureForClass: class
| sc mi currentStatus |
Type typeData at: class ifAbsent: [
	currentStatus := self initializingTypeInfo.
	self initializingTypeInfo: true.
	sc := class superclassIfAbsent: [nil].
	sc notNil ifTrue: [
		self addTypeStructureForClass: sc.
		sc isMixinInvocation ifTrue: [
			mi := (MixinVMMirror on: sc mixin) masterInvocation.
			mi notNil ifTrue: [
				self addTypeStructureForClass: mi ]]].

	self addBasicTypeStructureForClass: class.
	class typeInfo mixinType: class mixin typeInfo.
	class klass typeInfo mixinType: class klass mixin typeInfo.
	self addSuperclassTypeStructureForClass: class.
	self initializingTypeInfo: currentStatus.
 ].
! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'initializing type info - temporary' !
addTypeStructureForMixin: mixin

| currentStatus |
currentStatus := self initializingTypeInfo.
self initializingTypeInfo: true.
self addBasicTypeStructureForMixin: mixin.
self initializingTypeInfo: currentStatus
! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'initializing type info - temporary' !
addTypeStructureToAllClasses

self addTypeStructureToObject.
self klassesDo:[:c |                            
                          c name = #Class
                               ifFalse:[c name = #Object ifFalse:[self addTypeStructureForClass: c]]
                               ifTrue:[self addSuperclassTypeStructureForClass: c].                                                               
                               ].! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'initializing type info - temporary' !
addTypeStructureToAllNamedMixins

self mixinsDo: [ :m | self addTypeStructureForMixin: m ].
! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'initializing type info - temporary' !
addTypeStructureToObject

| class |

self addBasicTypeStructureToObject.
class := self at: #Object.
class klass typeInfo mixinType: class klass mixin typeInfo.
self addSuperclassTypeStructureToObject.



! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'initializing type info - temporary' !
classReferenceTo: class <Class> ^ <DeltaClassId | DeltaMixinInvocationNode>
| node <DeltaMixinInvocationNode> |

^class isMixinInvocation
	ifTrue: [
		node := DeltaMixinInvocationNode new mix: (self mixinReferenceTo: class mixin) on: (self classReferenceTo: class 

superclass).
		node classObj: class.
		node]
	ifFalse: [
		DeltaClassId new setId: class name; scope: DeltaGlobals]
! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'initializing type info - temporary' !
initializeTypeInfo

	self initializingTypeInfo: true.
	self updateInvocationInfo.
	self initializingTypeInfo: false.

! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'initializing type info - temporary' !
initializeUpdateInfo

	self initializingTypeInfo: true.
	self updateInvocationInfo.
	self initializingTypeInfo: false.

! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'initializing type info - temporary' !
initializingTypeInfo ^ <Boolean>
	^InitializingTypeInfo! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'initializing type info - temporary' !
initializingTypeInfo: b
	InitializingTypeInfo := b! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'initializing type info - temporary' !
klassesDo: aBlock
	| sc |
	self initializingTypeInfo ifFalse: [self error: 'Should not be called'].
	self do: [ :e | e class class = Metaclass ifTrue: [
		aBlock value: e.
		sc := e superclassIfAbsent: [nil].
		[sc notNil] whileTrue: [
			sc isMixinInvocation
				ifTrue: [ 
					aBlock value: sc.
					sc := sc superclassIfAbsent: [nil]]
				ifFalse: [
					sc := nil]]]].
! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'initializing type info - temporary' !
metaclassReferenceTo: class

^(self classReferenceTo: class) dualClassType! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'initializing type info - temporary' !
mixinReferenceTo: mixin
| id |
id := DeltaClassId new setId: mixin name; scope: DeltaGlobals.
(MixinVMMirror on: mixin) masterInvocation isNil
	ifTrue: [^id]
	ifFalse: [^DeltaMixinDerivationNode new class: id selector: #mixin]
! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'initializing type info - temporary' !
updateInvocationInfo

	self klassesDo: [ :class | (MixinDeclMirror on: class mixin) addInvocation: class ].
	! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'iterating' !
associationsDo: blk <[GlobalAssociation]>

	| assoc <GlobalAssociation> |
	1 to: self size do: [ :index <Int> |
		assoc := {{primitiveSmalltalkAt: index ifFail: [ :err <Symbol> |  self error: err ]}}.
		blk value: assoc.
	]
! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'iterating' !
classesAndMixinsReflectiveDo: blk <[ClassMirror|MixinMirror]>

	self classesReflectiveDo: blk.
	self mixinsReflectiveDo: blk.
! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'iterating' !
classesDo: aBlock <[Class]>

	self constantsDo: [ :e <Object> | Metaclass = (Reflection classOf: (Reflection classOf: e)) ifTrue: [aBlock value: e]].! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'iterating' !
classesReflectiveDo: blk <[ClassMirror]>

	self classesDo: [ :class <Class> |
		blk value: (ClassMirror on: class).
		blk value: (ClassMirror on: class) classSide ].

! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'iterating' !
constantsDo: blk <[Object]>

	self associationsDo: [ :assoc <GlobalAssociation> | 
		assoc isConstant
			ifTrue: [ blk value: assoc value ] 
	]
! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'iterating' !
definitionsDo: blk <[Class | Mixin | Protocol | TypeAlias]>

	self classesDo: blk.
	self mixinsDo: blk.
	self protocolsDo: blk.
	self typeAliasesDo: blk.
! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'iterating' !
definitionsReflectiveDo: blk <[ClassMirror | MixinMirror | ProtocolMirror | TypeAliasMirror]>

	self classesReflectiveDo: blk.
	self mixinsReflectiveDo: blk.
	self protocolsReflectiveDo: blk.
	self typeAliasesReflectiveDo: blk.
! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'iterating' !
do: blk <[Object]>

	self associationsDo: [ :assoc <GlobalAssociation> | 
		blk value: assoc value ]
! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'iterating' !
globalVariablesDo: blk <[GlobalAssociation]>

self associationsDo:
	[: a <GlobalAssociation> |
		(Reflection isGlobalVariable: a)
			ifTrue: [blk value: a]
	].! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'iterating' !
globalVariablesReflectiveDo: blk <[GlobalVariableMirror]>

Smalltalk globalVariablesDo:
	[: a <GlobalAssociation> |
		blk value: (GlobalVariableMirror on: a)
	].! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'iterating' !
keysDo: blk <[Symbol]>

	self associationsDo: [ :assoc <GlobalAssociation> | 
		blk value: assoc key
	]
! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'iterating' !
mixinsDo: blk <[Mixin]>

	self constantsDo: [ :e  <Object> | ClassMixin = (Reflection classOf: e) ifTrue: [blk value: e]].! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'iterating' !
mixinsReflectiveDo: blk <[MixinMirror]>

	self mixinsDo: [ :mixin <Mixin> |
		blk value: (MixinMirror on: mixin).
		blk value: (MixinMirror on: mixin) classSide ].
! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'iterating' !
protocolsDo: blk <[Protocol]>

	self constantsDo: [ :e <Object>  | Protocol = (Reflection classOf: e) ifTrue: [blk value: e]].
! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'iterating' !
protocolsReflectiveDo: blk <[ProtocolMirror]>

	self protocolsDo: [ :protocol <Protocol> |
		blk value: (ProtocolMirror on: protocol).
		blk value: (ProtocolMirror on: protocol) classSide ].

! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'iterating' !
typeAliasesDo: blk <[TypeAlias]>

	self constantsDo: [ :e <Object> | TypeAlias = (Reflection classOf: e)  ifTrue: [blk value: e]].
! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'iterating' !
typeAliasesReflectiveDo: blk <[TypeAliasMirror]>

	self typeAliasesDo: [ :alias <TypeAlias> |
		blk value: (TypeAliasMirror on: alias) ].

! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'licensing and credits' !
credits

Transcript cr;
  show: 'Lars Bak'; cr;
  show: 'Gilad Bracha'; cr;
  show: 'Steffen Grarup'; cr;
  show: 'Robert Griesemer'; cr;
  show: 'David Griswold'; cr;
  show: 'Urs Hoelzle'; cr.! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'licensing and credits' !
license

	(HTMLView new model: (URL forFilePath: self sourceLicensePath)) launch
! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'licensing and credits' !
sourceLicensePath ^ <FilePath>

^FilePath currentDirectory, (FilePath for: 'sourceLicense.html')! !

"December 28, 2009 -> 12:14:43"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'oop creation - temporary' !
createLiteral: value <Object> ^ <Object>

	"Called from the bytecode compiler for literal nodes"
	"Eventually, the scanner/parser should create literals
	directly, thus createLiteral doesn't have to do anything anymore - gri 4/10/96"
	value == true ifTrue: [ ^ true ].
	value == false ifTrue: [ ^ false ].
	value == nil ifTrue: [ ^ nil ].

     value isCharacter ifTrue:[^value]. "Literal characters"
	value isSymbol ifTrue: [ ^value ].						"Literal symbols"
	value isString ifTrue: [ ^value asSymbol ].			"Literal strings"
	value isCollection ifTrue: [								"Literal arrays"
		| a <Array[Object]> |
		a := Array new: value size.
		1 to: value size do: [ :i | a at: i put: (self createLiteral: (value at: i) value) ].
		^a shallowCopyTenured ].
	^value shallowCopyTenured							"Other literals (tenuring actually only needed 

for floats)"
! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'oop creation - temporary' !
createMethod: sel code: code nofArgs: nofArgs flags: flags debugInfo: info

	| bytes <ByteArray> oops <Array> oopIndex <Int> |

	self assert: [code size \\ 4 = 0].
	bytes := ByteArray new: code size.
	oops := Array new: code size // 4.
	oopIndex := 1.
	[oopIndex <= oops size] whileTrue: [
		| e <Object> bcIndex <Int> |
		bcIndex := ((oopIndex - 1) * 4) + 1.
		e := code at: bcIndex.
		(code holdsOopAt: bcIndex)
			ifFalse: [
				oops at: oopIndex put: 0.					"Add void entry (void entries are smi 0)"
				bytes at: bcIndex put: e.					"Add byte code"
				1 to: 3 do: [ :i <Int> | 							"Add next 3 byte codes"
					e := code at: bcIndex + i.
					self assert: [e isSmallInteger].
					bytes at:  bcIndex + i put: e]]				
			ifTrue: [
				oops at: oopIndex put: e.					"Add oop to object array"
				bytes at: bcIndex put: 0.					"Add zero to byte array"
				1 to: 3 do: [ :i <Int> | 							"Fill byte array with 4 zeroes"
					| ee <Object> |
					ee := code at: bcIndex + i.
					self assert: [e == ee].
					bytes at:  bcIndex + i put: 0]].
		oopIndex := oopIndex + 1].

	^{{primitiveConstructMethod: sel flags: flags nofArgs: nofArgs debugInfo: info scopeInfo shallowCopyTenured bytes: bytes oops: oops ifFail: [:e <CompressedSymbol> | self error: 'Method creation failed: ', e]}}.! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'oop creation - temporary' !
createObjArray: c <Cltn[Object]> ^ <Array[Object]>

	^c asArray! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'oop creation - temporary' !
createSymbol: str <String> ^ <Symbol>

	^str asSymbol! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'oop creation - temporary' !
falseObj
	^false! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'oop creation - temporary' !
nilObj
	^nil! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'oop creation - temporary' !
trueObj
	^true! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'private' !
buildCache

	Cache := Dictionary[Symbol, GlobalAssociation] new: self size.
	self vmAssociationsDo:
			[ :assoc <GlobalAssociation> |
				Cache at: assoc key put: assoc]! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'private' !
cache ^<VarDict[Symbol,Object]>

	Cache == nil
		ifTrue: [ self buildCache ].
	^Cache! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'private' !
computeClassesWithSubclasses ^<IdentitySet[Class]>

	"Computes a set of all classes (including anonymous mixin invocations) that have at least one subclass"

	| set <IdentitySet[Class]> sc <Class> |

	set := IdentitySet[Class] new.
	Smalltalk classesDo: [ :e <Object> |
		e class class == Metaclass 
			ifTrue: [	sc := (guaranteed <Behavior> e) superclassIfAbsent: [nil].
							[ sc notNil ] 
								whileTrue: [	set add: sc.
													(ClassVMMirror on: sc) isMixinInvocation 
														ifTrue: [ 	sc := sc superclassIfAbsent: [nil] ]
														ifFalse: [	sc := nil ] ] ] ].
     ^set
! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'private' !
flushCache

	Cache := nil.
	ClassesWithSubclasses := nil.! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'private' !
uncachedAssocAt: key <Object> ^ <GlobalAssociation>

^self uncachedAssocAt: key ifAbsent: [self error: key, ' not found'].! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'private' !
uncachedAssocAt: key <Object> ifAbsent: blk <[^GlobalAssociation]> ^ <GlobalAssociation>

self associationsDo:[:a <GlobalAssociation> | a key = key ifTrue:[^a]].
^blk value.! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'private' !
vmAssociationsDo: blk <[GlobalAssociation]>

| assoc <GlobalAssociation> |
1 to: self size do: [ :index <Int> |
	assoc := {{primitiveSmalltalkAt: index ifFail: [ :err <Symbol> |  self error: err ]}}.
	blk value: assoc
].! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'typechecker-needs' !
behaviorHierarchy ^ <Array[Symbol]>
" Returns an array of names of the superclasses of Object class"
^#(Object Behavior Class)! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'typechecker-needs' !
includesKey: k <Symbol> ^ <Boolean>

self at: k ifAbsent: [^false].
^true
! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'typechecking' !
typecheckWorld

	Type  doChecks: 
		[	Smalltalk classesDo: [: e <Class> | self typecheckMirror: (Mirror on: e)].
			Smalltalk mixinsDo: [: e <Mixin> | self typecheckMirror: (Mirror on: e)].
			Smalltalk protocolsDo: [: e <Protocol> | self typecheckMirror: (Mirror on: e)].
			Smalltalk typeAliasesDo: [: e <TypeAlias> | (Mirror on: e) typecheck].
			DeltaGlobals globalVariablesDo:
				[: e <DeltaGlobalVar> | 
					| ga <GlobalAssociation> |
					ga := Smalltalk 	assocAt: e name 
									ifAbsent: [		Transcript show: e name, ' missing from global scope'; cr.  
															nil ].
					nil = ga ifFalse:[(Mirror on: ga) typecheck].
				].																			
        ].
! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'typechecking private' !
typecheckMirror: m <Mirror>

	m typecheck. 
	m classSide typecheck
! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'utility' !
classesWithSubclasses ^<IdentitySet[Class]>

	"Answers a set of all classes (including anonymous mixin invocations) that have at least one subclass"

	ClassesWithSubclasses isNil
		ifTrue: [	ClassesWithSubclasses := self computeClassesWithSubclasses ].
	^ClassesWithSubclasses! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'utility' !
implementorsMatching: pattern <Str> ^ <SeqCltn[Tuple[Mirror, Symbol]]>

	| result <OrderedCollection[Tuple[Mirror, Symbol]]> |
	result := OrderedCollection[Tuple[Mirror, Symbol]] new.
	self classesAndMixinsReflectiveDo: [ :m <ClassMirror|MixinMirror> |
		(m selectorsMatching: pattern) do: [ :selector <Symbol> | result add: m,,selector ] ].
	self protocolsReflectiveDo: [ :m <ProtocolMirror> |
		(m selectorsMatching: pattern) do: [ :selector <Symbol> | result add: m,,selector ] ].
	^result asSortedCollection: [ :t1 <Tuple[Mirror, Symbol]> :t2 <Tuple[Mirror, Symbol]> | t1 at1 name < t2 at1 name or: [ t1 at1 name = t2 at1 name and: [ t1 at2 <= t2 at2 ] ] ].
	! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'utility' !
implementorsOf: selector <Symbol> ^ <SeqCltn[Tuple[Mirror, Symbol]]>

	| result <OrderedCollection[Tuple[Mirror, Symbol]]> |
	result := OrderedCollection[Tuple[Mirror, Symbol]] new.
	self classesAndMixinsReflectiveDo: [ :m <ClassMirror|MixinMirror> |
		(m hasSelector: selector)
			ifTrue: [	result add: m,,selector ] ].
	self protocolsReflectiveDo: [ :m <ProtocolMirror> |
		(m hasSelector: selector)
			ifTrue: [	result add: m,,selector ] ].
	^result asSortedCollection: [ :t1 <Tuple[Mirror, Symbol]> :t2 <Tuple[Mirror, Symbol]> | t1 at1 name < t2 at1 name or: [ t1 at1 name = t2 at1 name and: [ t1 at2 <= t2 at2 ] ] ].
! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'utility' !
mirrorFor: key <Symbol> ^ <Mirror>

	^self mirrorFor: key ifAbsent: [ self error: key, ' not found in System Dictionary' ]! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'utility' !
mirrorFor: key <Symbol> ifAbsent: blk <[^X def]> ^ <Mirror | X>

	| assoc <GlobalAssociation> |
	assoc := self assocAt: key ifAbsent: [ ^blk value ].
	^(Reflection isGlobalVariable: assoc)
		ifTrue: [		Mirror on: assoc ]
		ifFalse: [	Mirror on: assoc value ]! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'utility' !
referencesToGlobalName: name <Symbol> ^ <SeqCltn[Tuple[Mirror, Symbol]]>

	| result <OrderedCollection[Tuple[Mirror, Symbol]]> |
	result := OrderedCollection[Tuple[Mirror, Symbol]] new.
	self classesAndMixinsReflectiveDo: [ :m <ClassMirror|MixinMirror> |
		m compiledMethodsDo: [ :method <Method> | 		"We use compiled methods here since otherwise type info will have to be loaded"
			(method referencesGlobalName: name)
				ifTrue: [	result add: m,,method selector ] ] ].
	^result asSortedCollection: [ :t1 <Tuple[Mirror, Symbol]> :t2 <Tuple[Mirror, Symbol]> | t1 at1 name < t2 at1 name or: [ t1 at1 name = t2 at1 name and: [ t1 at2 <= t2 at2 ] ] ].! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'utility' !
referencesToInstVarName: name <Symbol> for: holder <Mixin> ^ <SeqCltn[Tuple[Mirror, Symbol]]>

	| result <OrderedCollection[Tuple[Mirror, Symbol]]> |
	result := OrderedCollection[Tuple[Mirror, Symbol]] new.
	self classesAndMixinsReflectiveDo: [ :m <ClassMirror|MixinMirror> |
		m compiledMethodsDo: [ :method <Method> | 		"We use compiled methods here since otherwise type info will have to be loaded"
			(method referencesInstVarName: name for: holder)
				ifTrue: [	result add: m,,method selector ] ] ].
	^result asSortedCollection: [ :t1 <Tuple[Mirror, Symbol]> :t2 <Tuple[Mirror, Symbol]> | t1 at1 name < t2 at1 name or: [ t1 at1 name = t2 at1 name and: [ t1 at2 <= t2 at2 ] ] ].! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'utility' !
renameGroup: grp <Dict[Symbol, Symbol]>

self definitionsReflectiveDo:[: dm <Mirror> |
	dm isMeta 
			ifFalse:[dm renameGroup: grp]
			].
self globalVariablesReflectiveDo:[:gm <Mirror> | gm renameGroup: grp].
! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'utility' !
sendersMatching: pattern <Str> ^ <SeqCltn[Tuple[Mirror, Symbol]]>

	| result <OrderedCollection[Tuple[Mirror, Symbol]]> |
	result := OrderedCollection[Tuple[Mirror, Symbol]] new.
	self classesAndMixinsReflectiveDo: [ :m <ClassMirror|MixinMirror> |
		m compiledMethodsDo: [ :method <Method> | 		"We use compiled methods here since otherwise type info will have to be loaded"
			(method referencesSenderMatching: pattern)
				ifTrue: [	result add: m,,method selector ] ] ].
	^result asSortedCollection: [ :t1 <Tuple[Mirror, Symbol]> :t2 <Tuple[Mirror, Symbol]> | t1 at1 name < t2 at1 name or: [ t1 at1 name = t2 at1 name and: [ t1 at2 <= t2 at2 ] ] ].! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'utility' !
sendersOf: selector <Symbol> ^ <SeqCltn[Tuple[Mirror, Symbol]]>

	| result <OrderedCollection[Tuple[Mirror, Symbol]]> |
	result := OrderedCollection[Tuple[Mirror, Symbol]] new.
	self classesAndMixinsReflectiveDo: [ :m <ClassMirror|MixinMirror> |
		m compiledMethodsDo: [ :method <Method> | 		"We use compiled methods here since otherwise type info will have to be loaded"
			(method referencesSender: selector)
				ifTrue: [	result add: m,,method selector ] ] ].
	^result asSortedCollection: [ :t1 <Tuple[Mirror, Symbol]> :t2 <Tuple[Mirror, Symbol]> | t1 at1 name < t2 at1 name or: [ t1 at1 name = t2 at1 name and: [ t1 at2 <= t2 at2 ] ] ].! !

"December 28, 2009 -> 12:14:44"!

Delta define: #TestRunner as: (
(Class subclassOf: 'ProgrammingEnvironment mixin |> (NotifyingObject mixin |> Application)' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"December 28, 2009 -> 12:14:44"!

Delta define: #TestRunner as: (
(Class subclassOf: 'ProgrammingEnvironment mixin |> (NotifyingObject mixin |> Application)' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"December 28, 2009 -> 12:14:44"!

Delta define: #TestRunner as: (
(Class subclassOf: 'ProgrammingEnvironment mixin |> (NotifyingObject mixin |> Application)' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"December 28, 2009 -> 12:14:44"!

Delta define: #TestRunner as: (
(Class subclassOf: 'ProgrammingEnvironment mixin |> (NotifyingObject mixin |> Application)' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"December 28, 2009 -> 12:14:44"!

Delta define: #TestRunner as: (
(Class subclassOf: 'ProgrammingEnvironment mixin |> (NotifyingObject mixin |> Application)' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"December 28, 2009 -> 12:14:44"!

Delta define: #TestRunner as: (
(Class subclassOf: 'ProgrammingEnvironment mixin |> (NotifyingObject mixin |> Application)' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"December 28, 2009 -> 12:14:44"!

Delta define: #TestRunner as: (
(Class subclassOf: 'ProgrammingEnvironment mixin |> (NotifyingObject mixin |> Application)' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"December 28, 2009 -> 12:14:44"!

Delta define: #TestRunner as: (
(Class subclassOf: 'ProgrammingEnvironment mixin |> (NotifyingObject mixin |> Application)' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"December 28, 2009 -> 12:14:44"!

Delta define: #TestRunner as: (
(Class subclassOf: 'ProgrammingEnvironment mixin |> (NotifyingObject mixin |> Application)' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"December 28, 2009 -> 12:14:44"!

Delta define: #TestRunner as: (
(Class subclassOf: 'ProgrammingEnvironment mixin |> (NotifyingObject mixin |> Application)' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"December 28, 2009 -> 12:14:44"!

Delta define: #TestRunner as: (
(Class subclassOf: 'ProgrammingEnvironment mixin |> (NotifyingObject mixin |> Application)' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"December 28, 2009 -> 12:14:44"!

(Delta mirrorFor: #TestRunner)
comment: 
'Test runner for SUnit tests. To launch doit on the following:-

	(TestRunner open)'!


"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #TestRunner) classSide methodsFor: 'instance creation' !
open
	"(TestRunner open)"
        ^self new launch! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #TestRunner) classSide methodsFor: 'instance creation' !
openOn: testClass <Class>
	"(TestRunner open)"
        ^self new
        	selectTestClass: testClass;
        	launch! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'accessing' !
details

        ^details! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'accessing' !
errors

        ^errors! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'accessing' !
errorsList

        ^self errors collect: [:error | error printString]! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'accessing' !
failures

        ^failures! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'accessing' !
formatTime: aTime
        aTime hour > 0 ifTrue: [^aTime hour printString , 'h'].
        aTime minutes > 0 ifTrue: [^aTime minutes printString , 'min'].
        ^aTime second printString , ' sec'! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'accessing' !
passFail

        ^passFail! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'accessing' !
suite
        ^TestCase buildSuite! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'accessing' !
tests

        ^ tests! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'accessing' !
timeSinceLastPassAsString: aResult
        (lastPass isNil or: [aResult hasPassed not]) ifTrue: [^ ''].
        ^ ', ' , (self formatTime: (Time now subtractTime: lastPass)) , '
since last Pass'! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
debugButtonLabel
        ^ 'DEBUG'! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
debugState

        ^true! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
errorColor
        ^ Paint red! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
failColor
        ^ Paint yellow! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
passColor
        ^ Paint green! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
refreshButtonLabel
        ^ 'Refresh'! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
refreshButtonState

        ^true! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
runButtonLabel
        ^ 'Run All'! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
runButtonState

        ^true! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
runOneButtonLabel
        ^ 'Run'! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
windowLabel

        ^'SUnit Camp Smalltalk ', TestCase sunitVersion, ' Test Runner'! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := self buildTests.
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
addSubclass

	self addSubclassTo: (self selectedTestClass isNil
										ifTrue: [TestCase]
										ifFalse: [self selectedTestClass])! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
browseSelectedTest

	(ClassOutliner for: (Mirror on: self selectedTestClass)) launch! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn errorsList failuresList |
	Smalltalk addDependent: self.
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testsList := (ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:)
								withPopUpMenuSource: [self listBoxPopUpMenu].
	failuresList := ListModel
									on: self
									items: #failuresList
									selected: #selectedFailureTest
									select: #debugFailureTest:.
	errorsList := ListModel
									on: self
									items: #errorsList
									selected: #selectedErrorTest
									select: #debugErrorTest:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: testsList with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: failuresList with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: errorsList with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: passFailText imbeddedVisual))
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: detailsText imbeddedVisual))
																			with: (textEqualizer for: resultsRow)).
	self updateAll.
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
font

	^Font forSpec: (FontSpec new points: 8; typeface: 'Times Roman')! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
frameWithBorderAndBackdrop: visual

	^(visual with3DBorder)
			backdrop: (Painter new);
			yourself! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
listBoxPopUpMenu ^<Menu>

	^Menu new
		name: 'Actions';
		add: (MenuAction new
					name: 'Add test class';
					action: [self addSubclass]);
		add: (MenuAction new
					name: 'Browse';
					active: [self selectedTestClass notNil];
					action: [self browseSelectedTest])! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
textViewOn: aspect

	^TextModel
			on: self
			aspect: aspect! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'notificaition' !
visualAllocated

"	self refreshWindow"! !

"December 28, 2009 -> 12:14:44"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'private-control' !
closeRequest: toClose <[]>

	Smalltalk removeDependent: self.
	super closeRequest: toClose! !

"December 28, 2009 -> 12:14:45"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
debugErrorTest: anInteger
        selectedErrorTest := anInteger.				"added rew"
        selectedFailureTest := 0.							"added rew"
        self changed: #selectedFailureTest.		"added rew"
        self changed: #selectedErrorTest.			"added rew"
        (anInteger ~= 0)
                ifTrue: [[(result errors at: anInteger) debug] fork]! !

"December 28, 2009 -> 12:14:45"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
debugFailureTest: anInteger

        (anInteger ~= 0)
                ifTrue: [[(self failures at: anInteger) debugAsFailure] fork].

        selectedFailureTest := anInteger.
        selectedErrorTest := 0.
        self changed: #selectedErrorTest.
        self changed: #selectedFailureTest! !

"December 28, 2009 -> 12:14:45"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
debugTest! !

"December 28, 2009 -> 12:14:45"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
runOneTest
        "Cursor execute showWhile:
                ["
	testSuite notNil
		ifTrue: [self runWindow.
						result := self selectedTestClass suite run.
						self updateWindow: result]
 		ifFalse: [self runWindow.
						self displayPassFail: 'No Test Suite Selected']
       "]"! !

"December 28, 2009 -> 12:14:45"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
runTests
	"Cursor execute showWhile:["
	self runWindow.
	result := TestResult new.
	self suite tests
		do:[:each|
				self displayPassFail: 'Running ', each name.
				Processor yield.
				each run: result.
				self updateWindow: result]
	"]."
! !

"December 28, 2009 -> 12:14:45"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
selectTestClass: testClass <Class>

	testClass isNil ifTrue: [^self].
	self selectedSuite: (tests indexOf: testClass name)! !

"December 28, 2009 -> 12:14:45"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
selectedErrorTest
        ^selectedErrorTest! !

"December 28, 2009 -> 12:14:45"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
selectedFailureTest

        ^selectedFailureTest! !

"December 28, 2009 -> 12:14:45"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
selectedSuite

        ^selectedSuite! !

"December 28, 2009 -> 12:14:45"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
selectedSuite: anInteger
        anInteger ~= 0 ifTrue: [testSuite := tests at: anInteger].
        selectedSuite := selectedSuite = anInteger
                                        ifTrue:[0]
                                        ifFalse:[anInteger].
        selectedFailureTest := 0.
        selectedErrorTest := 0.
        self changed: #selectedFailureTest.             "added rew"
        self changed: #selectedErrorTest.               "added rew" 
        self changed: #selectedSuite! !

"December 28, 2009 -> 12:14:45"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
selectedTestClass

	^testSuite isNil ifFalse: [testSuite asSymbol sunitAsClass]! !

"December 28, 2009 -> 12:14:45"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'test processing' !
errorLog
	^SUnitNameResolver defaultLogDevice! !

"December 28, 2009 -> 12:14:45"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'test processing' !
showResult

	self errorLog cr;cr; show: '==== SUnit ======== Start ===='.
	self
		showResultSummary;
		showResultDefects.
	self errorLog cr; show: '==== SUnit ========== End ===='; cr.! !

"December 28, 2009 -> 12:14:45"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'test processing' !
showResultDefects

	(self result failureCount > 0)
		ifTrue: [
			self errorLog cr; show: '---- SUnit ----- Failures ----'.
			self result failures do: [:failure |
				self errorLog crtab; show: failure printString]].
	(self result errorCount > 0)
		ifTrue: [
			self errorLog cr; show: '---- SUnit ------- Errors ----'.
			self result errors do: [:error |
				self errorLog crtab; show: error printString]].! !

"December 28, 2009 -> 12:14:45"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'test processing' !
showResultSummary

	| message summary |
	message := (self result runCount = self result correctCount)
		ifTrue: [self successMessage]
		ifFalse: [self failureMessage].
	self errorLog crtab; show: message.
	summary :=
		self result runCount printString, ' run, ',
		self result failureCount printString, ' failed, ',
		self result errorCount printString, ' errors (',
		self duration printString, ' ms)'.
	self errorLog crtab; show: summary.! !

"December 28, 2009 -> 12:14:45"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
buildTests

	^(TestCase allSubclasses collect: [:each | each name])
			asSortedCollection:[:a :b| a asString <= b asString]! !

"December 28, 2009 -> 12:14:45"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
displayDetails: aString
        details := aString.
        self changed: #details! !

"December 28, 2009 -> 12:14:45"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
displayErrors: anOrderedCollection

        errors := anOrderedCollection.
        self changed: #errorsList! !

"December 28, 2009 -> 12:14:45"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
displayFailures: anOrderedCollection

        failures := anOrderedCollection.
        self changed: #failuresList! !

"December 28, 2009 -> 12:14:45"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
displayPassFail: aString
        passFail := aString.
        self changed: #passFail! !

"December 28, 2009 -> 12:14:45"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
failuresList

	^self failures collect: [:failure | failure printString]! !

"December 28, 2009 -> 12:14:45"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshTests

        tests := self buildTests.
        self changed: #tests.
        testSuite := nil.
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.
        self changed: #selectedFailureTest.             "added rew"
        self changed: #selectedErrorTest.               "added rew"
        self changed: #selectedSuite.
        self refreshWindow! !

"December 28, 2009 -> 12:14:45"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshWindow

        self refreshWindow: 'N/A'! !

"December 28, 2009 -> 12:14:45"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshWindow: passFailString

        self updatePartColors: Paint white.
        self updateErrors: TestResult new.
        self updateFailures: TestResult new.
        self displayPassFail: passFailString.
        self displayDetails: '...'! !

"December 28, 2009 -> 12:14:45"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
runWindow

        self refreshWindow:  'Running...'! !

"December 28, 2009 -> 12:14:45"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
update: aspect with: value
"notification from Delta of update to classes in system"
	self inSessionProcessDo: [self refreshTests].
	Processor yield! !

"December 28, 2009 -> 12:14:45"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updateAll

	self changed: #tests.
	self changed: #selectedSuite.
	self changed: #details.
	self changed: #passFail.
	"self refreshWindow"! !

"December 28, 2009 -> 12:14:45"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updateDetails: aTestResult

	| detailString |
	detailString := aTestResult printString , (self timeSinceLastPassAsString: aTestResult).
	self displayDetails: detailString.
	aTestResult hasPassed
		ifTrue: [lastPass := Time now]! !

"December 28, 2009 -> 12:14:45"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updateErrors: aTestResult

        self displayErrors: aTestResult errors! !

"December 28, 2009 -> 12:14:45"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updateFailures: aTestResult

        self displayFailures: aTestResult failures asOrderedCollection! !

"December 28, 2009 -> 12:14:45"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updatePartColors: aColor

	passFailText visual backgroundPainter paint: aColor.
	detailsText visual backgroundPainter paint: aColor! !

"December 28, 2009 -> 12:14:45"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updatePassFail: aTestResult

	| message |
	message := aTestResult hasPassed
								ifTrue: ['Pass']
								ifFalse: ['Fail'].
	self displayPassFail: message! !

"December 28, 2009 -> 12:14:45"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updateWindow: aTestResult
        aTestResult hasPassed
                ifTrue: [self updatePartColors: self passColor]
                ifFalse: [aTestResult hasErrors
									ifTrue: [self updatePartColors: self errorColor]
									ifFalse: [self updatePartColors: self failColor]].
        self updatePassFail: aTestResult.
        self updateDetails: aTestResult.
        self updateFailures: aTestResult.
        self updateErrors: aTestResult! !

"December 28, 2009 -> 12:14:45"!

Delta define: #TextModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the contents "
aspect "  the aspect of the model "
view " the view to be updated with the contents "')) !


"December 28, 2009 -> 12:14:45"!

Delta define: #TextModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the contents "
aspect "  the aspect of the model "
view " the view to be updated with the contents "')) !


"December 28, 2009 -> 12:14:45"!

Delta define: #TextModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the contents "
aspect "  the aspect of the model "
view " the view to be updated with the contents "')) !


"December 28, 2009 -> 12:14:45"!

Delta define: #TextModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the contents "
aspect "  the aspect of the model "
view " the view to be updated with the contents "')) !


"December 28, 2009 -> 12:14:45"!

Delta define: #TextModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the contents "
aspect "  the aspect of the model "
view " the view to be updated with the contents "')) !


"December 28, 2009 -> 12:14:45"!

Delta define: #TextModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the contents "
aspect "  the aspect of the model "
view " the view to be updated with the contents "')) !


"December 28, 2009 -> 12:14:45"!

Delta define: #TextModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the contents "
aspect "  the aspect of the model "
view " the view to be updated with the contents "')) !


"December 28, 2009 -> 12:14:45"!

Delta define: #TextModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the contents "
aspect "  the aspect of the model "
view " the view to be updated with the contents "')) !


"December 28, 2009 -> 12:14:45"!

Delta define: #TextModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the contents "
aspect "  the aspect of the model "
view " the view to be updated with the contents "')) !


"December 28, 2009 -> 12:14:45"!

Delta define: #TextModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the contents "
aspect "  the aspect of the model "
view " the view to be updated with the contents "')) !


"December 28, 2009 -> 12:14:45"!

Delta define: #TextModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the contents "
aspect "  the aspect of the model "
view " the view to be updated with the contents "')) !


"December 28, 2009 -> 12:14:45"!

(Delta mirrorFor: #TextModel)
comment: 
''!


"December 28, 2009 -> 12:14:45"!

! (Delta mirrorFor: #TextModel) classSide methodsFor: 'instance creation' !
on: aModel aspect: aspect

	^self new
			on: aModel
			aspect: aspect! !

"December 28, 2009 -> 12:14:45"!

! (Delta mirrorFor: #TextModel) methodsFor: 'initialization' !
on: aModel aspect: anAspect

	view := TextView forString.
	view
		isMultiLine: true;
		model: '';
		paint: Paint black.
	model := aModel.
	aspect := anAspect.
	model addDependent: self.
	^view! !

"December 28, 2009 -> 12:14:45"!

! (Delta mirrorFor: #TextModel) methodsFor: 'notification' !
update: anAspect

	anAspect == aspect
		ifTrue: [
			| newText |
			newText := (model perform: aspect).
			
			model inSessionProcessDo: [
			Transcript cr; show: 'Updating text view ', aspect, ' = ', newText.
				"newText = 'N/A'
					ifTrue: [self halt]."
				view model: newText]]! !

"December 28, 2009 -> 12:52:23"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'utility' !
referencesToInstVarName: name <Symbol> for: holder <Mixin> ^ <SeqCltn[Tuple[Mirror, Symbol]]>

	| result <OrderedCollection[Tuple[Mirror, Symbol]]> |
	result := OrderedCollection[Tuple[Mirror, Symbol]] new.
	self classesReflectiveDo: [ :m <ClassMirror> |
		m compiledMethodsDo: [ :method <Method> | 		"We use compiled methods here since otherwise type info will have to be loaded"
			(method referencesInstVarName: name for: m mixin reflectee)
				ifTrue: [	result add: m,,method selector ] ] ].
	^result asSortedCollection: [ :t1 <Tuple[Mirror, Symbol]> :t2 <Tuple[Mirror, Symbol]> | t1 at1 name < t2 at1 name or: [ t1 at1 name = t2 at1 name and: [ t1 at2 <= t2 at2 ] ] ].! !

"December 28, 2009 -> 12:53:22"!

! (Delta mirrorFor: #InstanceVariableOutliner) methodsFor: 'control' !
referencesToInstVar

	self launchListDialogWithPainter: Painter default
		title: 'Select instance variable'
		contents: self instVarNames
		multi: false
		action: [:items|
			| references instVar |
			instVar := self instVarNames at: items anElement.
			references := Smalltalk 
										referencesToInstVarName: instVar
										for: self mirror mixin reflectee.
			self
				launchSelectorListWithPainter: Painter default
				title: 'References to instance variable "', instVar, '"'
				contents: references]! !

"December 28, 2009 -> 12:55:32"!

! (Delta mirrorFor: #InstanceVariableOutliner) methodsFor: 'control' !
referencesToInstVar: instVar <Symbol>

	| references |
	references := Smalltalk 
							referencesToInstVarName: instVar
							for: self mirror mixin reflectee.
	self
		launchSelectorListWithPainter: Painter default
		title: 'References to instance variable "', instVar, '"'
		contents: references! !

"December 28, 2009 -> 12:57:18"!

! (Delta mirrorFor: #InstanceVariableOutliner) methodsFor: 'control' !
referencesToInstVar

	self instVarNames size = 1
		ifTrue: [^self referencesToInstVar: (self instVarNames anElement)].
	self launchListDialogWithPainter: Painter default
		title: 'Select instance variable'
		contents: self instVarNames
		multi: false
		action: [:items|
			self referencesToInstVar: (self instVarNames at: items anElement)]! !

"December 28, 2009 -> 13:10:41"!

! (Delta mirrorFor: #ClassVMMirror) methodsFor: 'accessing' !
superclasses ^ <Cltn[Class]>

"Return the class' superclasses"

	|superclasses sc|
	superclasses := OrderedCollection new.
	sc := Reflection superclassOf: self reflectee.
	[sc notNil]
		whileTrue: [superclasses add: sc.
							sc := Reflection superclassOf: sc].
	^superclasses
               

! !

"December 28, 2009 -> 13:17:17"!

! (Delta mirrorFor: #ClassVMMirror) methodsFor: 'accessing' !
superclasses ^ <Cltn[Class]>

"Return the class' superclasses"

	|superclasses sc|
	superclasses := OrderedCollection new.
	sc := self superclass.
	[sc notNil]
		whileTrue: [superclasses add: sc reflectee.
							sc := sc superclass].
	^superclasses
               

! !

"December 28, 2009 -> 14:0:40"!

! (Delta mirrorFor: #ClassVMMirror) methodsFor: 'accessing' !
supermixins ^ <Cltn[Mixin]>

"Return the class' superclasses"

	|superclasses sc|
	superclasses := OrderedCollection new.
	sc := self superclass.
	[sc notNil]
		whileTrue: [superclasses add: sc mixin reflectee.
							sc := sc superclass].
	^superclasses
               

! !

"December 28, 2009 -> 16:4:34"!

! (Delta mirrorFor: #ClassVMMirror) methodsFor: 'accessing' !
inheritsFrom: aMixin <Mixin>

	self superclasses do: [:sc|
		(ClassVMMirror on: sc) 	mixin reflectee == aMixin
			ifTrue: [^true]].
	^false
! !

"December 28, 2009 -> 16:10:11"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'utility' !
referencesToInstVarName: name <Symbol> for: holder <Mixin> ^ <SeqCltn[Tuple[Mirror, Symbol]]>

	| result <OrderedCollection[Tuple[Mirror, Symbol]]> |
	result := OrderedCollection[Tuple[Mirror, Symbol]] new.
	self classesReflectiveDo: [ :m <ClassMirror> |
		((ClassVMMirror on: m reflectee) inheritsFrom: holder)
			ifTrue: [m compiledMethodsDo: [ :method <Method> | 		"We use compiled methods here since otherwise type info will have to be loaded"
							(method referencesInstVarName: name for: m mixin reflectee)
								ifTrue: [	result add: m,,method selector ]]]].
	^result asSortedCollection: [ :t1 <Tuple[Mirror, Symbol]> :t2 <Tuple[Mirror, Symbol]> | t1 at1 name < t2 at1 name or: [ t1 at1 name = t2 at1 name and: [ t1 at2 <= t2 at2 ] ] ].! !

"December 28, 2009 -> 16:11:50"!

! (Delta mirrorFor: #ClassVMMirror) methodsFor: 'accessing' !
superclasses ^ <Cltn[Class]>

"Return the class' superclasses"

	|superclasses sc|
	superclasses := OrderedCollection with: self reflectee.
	sc := self superclass.
	[sc notNil]
		whileTrue: [superclasses add: sc reflectee.
							sc := sc superclass].
	^superclasses
               

! !

"December 28, 2009 -> 16:12:25"!

! (Delta mirrorFor: #ClassVMMirror) methodsFor: 'accessing' !
superclasses ^ <Cltn[Class]>

"Return the class' superclasses"

	|superclasses sc|
	superclasses := OrderedCollection new.
	sc := self superclass.
	[sc notNil]
		whileTrue: [superclasses add: sc reflectee.
							sc := sc superclass].
	^superclasses
               

! !

"December 28, 2009 -> 16:12:55"!

! (Delta mirrorFor: #ClassVMMirror) methodsFor: 'accessing' !
inheritsFrom: aMixin <Mixin>

	self mixin reflectee == aMixin
		ifTrue: [^true].
	self superclasses do: [:sc|
		(ClassVMMirror on: sc) mixin reflectee == aMixin
			ifTrue: [^true]].
	^false
! !

"December 28, 2009 -> 16:14:48"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'utility' !
referencesToInstVarName: name <Symbol> for: holder <Mixin> ^ <SeqCltn[Tuple[Mirror, Symbol]]>

	| result <OrderedCollection[Tuple[Mirror, Symbol]]> |
	result := OrderedCollection[Tuple[Mirror, Symbol]] new.
	self classesReflectiveDo: [ :m <ClassMirror> |
		((ClassVMMirror on: m reflectee) inheritsFrom: holder)
			ifTrue: [m compiledMethodsDo: [ :method <Method> | 		"We use compiled methods here since otherwise type info will have to be loaded"
							(method referencesInstVarName: name for: m mixin reflectee)
								ifTrue: [	result add: m,,method selector ]]]].
	^result asSortedCollection: [ :t1 <Tuple[Mirror, Symbol]> :t2 <Tuple[Mirror, Symbol]> |
												t1 at1 name < t2 at1 name
													or: [ t1 at1 name = t2 at1 name and: [ t1 at2 <= t2 at2 ] ] ].! !

"December 28, 2009 -> 16:23:24"!

! (Delta mirrorFor: #ReadString) methodsFor: 'copying' !
trimBlanks

	^self stringCopyFrom: 1 to: self lastNonBlank
	! !

"December 28, 2009 -> 16:24:39"!

! (Delta mirrorFor: #ReadString) methodsFor: 'copying' !
lastNonBlank

	self size to: 1 by: -1 do: [:i|
		(self at: i) isBlank
			ifFalse: [^i]].
	^0
	! !

"December 28, 2009 -> 16:26:21"!

! (Delta mirrorFor: #ReadString) methodsFor: 'copying' !
lastNonBlank

	self size to: 1 by: -1 do: [:i|
		(self at: i) isSeparator
			ifFalse: [^i]].
	^0
	! !

"December 28, 2009 -> 16:28:57"!

"System saved" !
"December 28, 2009 -> 16:36:1"!

(Delta mirrorFor: #ClassVMMirror) removeMethod: #supermixins ifAbsent: [] !


"December 28, 2009 -> 16:44:3"!

! (Delta mirrorFor: #Mirror) methodsFor: 'Unclassified' !
isMixin ^ <Boolean>

	^false! !

"December 28, 2009 -> 16:44:23"!

! (Delta mirrorFor: #MixinMirror) methodsFor: 'Unclassified' !
isMixin

	^true! !

"December 28, 2009 -> 16:44:27"!

! (Delta mirrorFor: #InstanceVariableOutliner) methodsFor: 'control' !
referencesToInstVar: instVar <Symbol>

	| references |
	references := Smalltalk 
							referencesToInstVarName: instVar
							for: self mixin reflectee.
	self
		launchSelectorListWithPainter: Painter default
		title: 'References to instance variable "', instVar, '"'
		contents: references! !

"December 28, 2009 -> 16:44:28"!

! (Delta mirrorFor: #InstanceVariableOutliner) methodsFor: 'private' !
mixin

	^self mirror isMixin
		ifTrue: [self mirror]
		ifFalse: [self mirror mixin]! !

"December 28, 2009 -> 16:53:24"!

! (Delta mirrorFor: #ClassMirror) methodsFor: 'Unclassified' !
inheritsFrom: aMixin <Mixin> ^ <Boolean>

	self mixin reflectee == aMixin ifTrue: [^true].
	^(ClassVMMirror on: self reflectee)
			inheritsFrom: aMixin! !

"December 28, 2009 -> 16:54:5"!

! (Delta mirrorFor: #AbstractClassMirror) methodsFor: 'Unclassified' !
inheritsFrom: aMixin <Mixin> ^ <Boolean>

	self mixin reflectee == aMixin ifTrue: [^true].
	^(ClassVMMirror on: self reflectee)
			inheritsFrom: aMixin! !

"December 28, 2009 -> 16:54:10"!

(Delta mirrorFor: #ClassMirror) removeMethod: #inheritsFrom: ifAbsent: [] !


"December 28, 2009 -> 16:54:56"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'utility' !
referencesToInstVarName: name <Symbol> for: holder <Mixin> ^ <SeqCltn[Tuple[Mirror, Symbol]]>

	| result <OrderedCollection[Tuple[Mirror, Symbol]]> |
	result := OrderedCollection[Tuple[Mirror, Symbol]] new.
	self classesAndMixinsReflectiveDo: [ :m <ClassMirror|MixinMirror> |
		(m inheritsFrom: holder)
			ifTrue: [m compiledMethodsDo: [ :method <Method> | 		"We use compiled methods here since otherwise type info will have to be loaded"
							(method referencesInstVarName: name for: m mixin reflectee)
								ifTrue: [	result add: m,,method selector ]]]].
	^result asSortedCollection: [ :t1 <Tuple[Mirror, Symbol]> :t2 <Tuple[Mirror, Symbol]> |
												t1 at1 name < t2 at1 name
													or: [ t1 at1 name = t2 at1 name and: [ t1 at2 <= t2 at2 ] ] ].! !

"December 28, 2009 -> 17:5:38"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
inheritsFrom: aMixin <Mixin> ^ <Boolean>

	^self reflectee == aMixin! !

"December 28, 2009 -> 17:7:0"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
mixin ^ <MixinMirror>

	^self! !

"December 28, 2009 -> 17:11:11"!

"System saved" !
"December 28, 2009 -> 17:18:10"!

! (Delta mirrorFor: #TextModel) methodsFor: 'notification' !
update: anAspect

	anAspect == aspect
		ifTrue: [
			| newText |
			newText := (model perform: aspect).
			
			view model: newText;
				displayNowIfInvalid]! !

"December 28, 2009 -> 17:19:0"!

! (Delta mirrorFor: #TextModel) methodsFor: 'notification' !
update: anAspect

	anAspect == aspect
		ifTrue: [
			| newText |
			newText := (model perform: aspect).
			
			view model: newText.
			view hasVisual ifTrue: [view displayNowIfInvalid]]! !

"December 28, 2009 -> 17:20:15"!

! (Delta mirrorFor: #TextModel) methodsFor: 'notification' !
update: anAspect

	anAspect == aspect
		ifTrue: [
			| newText |
			newText := (model perform: aspect).
			
			view model: newText.
			self session updateLayoutsIfNeeded.
			view displayNowIfInvalid]! !

"December 28, 2009 -> 17:20:22"!

! (Delta mirrorFor: #TextModel) methodsFor: 'notification' !
update: anAspect

	anAspect == aspect
		ifTrue: [
			| newText |
			newText := (model perform: aspect).
			
			view model: newText.
			view session updateLayoutsIfNeeded.
			view displayNowIfInvalid]! !

"December 28, 2009 -> 17:29:37"!

! (Delta mirrorFor: #TextModel) methodsFor: 'notification' !
update: anAspect

	anAspect == aspect
		ifTrue: [
			| newText |
			newText := (model perform: aspect).
			
			view model: newText.
			view hasMedium
				ifTrue:[
			"view session updateLayoutsIfNeeded."
			view displayNowIfInvalid]]! !

"December 28, 2009 -> 17:29:54"!

! (Delta mirrorFor: #TextModel) methodsFor: 'notification' !
update: anAspect

	anAspect == aspect
		ifTrue: [
			| newText |
			newText := (model perform: aspect).
			
			view model: newText.
			view visual hasMedium
				ifTrue:[
			"view session updateLayoutsIfNeeded."
			view displayNowIfInvalid]]! !

"December 28, 2009 -> 17:30:17"!

Delta define: #ClassTestIvars123 as: (
(Class subclassOf: 'Object' instanceVariables: 'one' classInstanceVariables: 'two three')) !


"December 28, 2009 -> 17:30:17"!

(Delta mirrorFor: #ClassTestIvars123) removeDefinitionIfFail: [] !


"December 28, 2009 -> 17:30:46"!

! (Delta mirrorFor: #TextModel) methodsFor: 'notification' !
update: anAspect

	anAspect == aspect
		ifTrue: [
			| newText |
			newText := (model perform: aspect).
			
			view model: newText.
			view visual hasMedium
				ifTrue:[view displayNowIfInvalid]]! !

"December 28, 2009 -> 17:30:55"!

Delta define: #ClassTestIvars123 as: (
(Class subclassOf: 'Object' instanceVariables: 'one' classInstanceVariables: 'two three')) !


"December 28, 2009 -> 17:30:55"!

(Delta mirrorFor: #ClassTestIvars123) removeDefinitionIfFail: [] !


"December 28, 2009 -> 17:32:9"!

! (Delta mirrorFor: #TextModel) methodsFor: 'notification' !
update: anAspect

	anAspect == aspect
		ifTrue: [
			| newText |
			newText := (model perform: aspect).
			newText = 'N/A'
				ifTrue: [self halt].
			view model: newText.
			view visual hasMedium
				ifTrue:[view displayNowIfInvalid]]! !

"December 28, 2009 -> 17:32:15"!

Delta define: #ClassTestIvars123 as: (
(Class subclassOf: 'Object' instanceVariables: 'one' classInstanceVariables: 'two three')) !


"December 28, 2009 -> 17:32:15"!

(Delta mirrorFor: #ClassTestIvars123) removeDefinitionIfFail: [] !


"December 28, 2009 -> 17:34:6"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'notificaition' !
visualAllocated

	self refreshWindow! !

"December 28, 2009 -> 17:34:37"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
update: aspect with: value
"notification from Delta of update to classes in system"
	self refreshTests! !

"December 28, 2009 -> 17:34:51"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshTests

        tests := self buildTests.
        self changed: #tests.
        testSuite := nil.
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.
        self changed: #selectedFailureTest.             "added rew"
        self changed: #selectedErrorTest.               "added rew"
        self changed: #selectedSuite.
        "self refreshWindow"! !

"December 28, 2009 -> 17:35:5"!

! (Delta mirrorFor: #TextModel) methodsFor: 'notification' !
update: anAspect

	anAspect == aspect
		ifTrue: [
			| newText |
			newText := (model perform: aspect).
			"newText = 'N/A'
				ifTrue: [self halt]."
			view model: newText.
			view visual hasMedium
				ifTrue:[view displayNowIfInvalid]]! !

"December 28, 2009 -> 17:35:14"!

Delta define: #ClassTestIvars123 as: (
(Class subclassOf: 'Object' instanceVariables: 'one' classInstanceVariables: 'two three')) !


"December 28, 2009 -> 17:35:14"!

(Delta mirrorFor: #ClassTestIvars123) removeDefinitionIfFail: [] !


"December 28, 2009 -> 17:35:56"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn errorsList failuresList |
	Smalltalk addDependent: self.
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testsList := (ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:)
								withPopUpMenuSource: [self listBoxPopUpMenu].
	failuresList := ListModel
									on: self
									items: #failuresList
									selected: #selectedFailureTest
									select: #debugFailureTest:.
	errorsList := ListModel
									on: self
									items: #errorsList
									selected: #selectedErrorTest
									select: #debugErrorTest:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: testsList with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self
																																							refreshTests;
																																							refreshWindow]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: failuresList with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: errorsList with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: passFailText imbeddedVisual))
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: detailsText imbeddedVisual))
																			with: (textEqualizer for: resultsRow)).
	self updateAll.
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"December 28, 2009 -> 17:36:6"!

Delta define: #ClassTestIvars123 as: (
(Class subclassOf: 'Object' instanceVariables: 'one' classInstanceVariables: 'two three')) !


"December 28, 2009 -> 17:36:6"!

(Delta mirrorFor: #ClassTestIvars123) removeDefinitionIfFail: [] !


"December 28, 2009 -> 17:36:24"!

Delta define: #ClassTestIvars123 as: (
(Class subclassOf: 'Object' instanceVariables: 'one' classInstanceVariables: 'two three')) !


"December 28, 2009 -> 17:36:24"!

(Delta mirrorFor: #ClassTestIvars123) removeDefinitionIfFail: [] !


"December 28, 2009 -> 17:36:38"!

! (Delta mirrorFor: #TextModel) methodsFor: 'notification' !
update: anAspect

	anAspect == aspect
		ifTrue: [
			| newText |
			newText := (model perform: aspect).
			view model: newText.
			view visual hasMedium
				ifTrue:[view displayNowIfInvalid]]! !

"December 28, 2009 -> 17:37:23"!

"System saved" !
"December 30, 2009 -> 14:39:34"!

! (Delta mirrorFor: #UnixFilePath) classSide methodsFor: 'instance creation' !
libcName

	^'libc.6.so'! !

"December 30, 2009 -> 14:44:26"!

! (Delta mirrorFor: #UnixFilePath) classSide methodsFor: 'instance creation' !
currentDirectory ^<FilePath>

    | buf <CString> buflen <Int> getcwd <Alien> |
    buflen := 1000.
    buf := Alien newC: buflen.
    getcwd := Alien lookup: 'getcwd' inLibrary: self libcName.
    ^[|result|
    	getcwd
    		primFFICallResult: (result := Alien new: 4)
    		with: buf pointer
    		with: buflen.
    	result asUnsignedLong = 0
    		ifTrue: [self error: 'Unable to get current directory']
            ifFalse: [self new pattern: buf asString ]
      ] ensure: [ buf free ]! !

"December 30, 2009 -> 14:45:9"!

! (Delta mirrorFor: #MacOSXFilePath) classSide methodsFor: 'private' !
libcName

	^'libc.dylib'! !

"December 30, 2009 -> 14:45:27"!

! (Delta mirrorFor: #UnixFilePath) classSide methodsFor: 'instance creation' !
libcName

	^'libc.so.6'! !

"December 30, 2009 -> 14:45:42"!

! (Delta mirrorFor: #UnixFilePath) classSide methodsFor: 'instance creation' !
currentDirectory: file <FilePath>

    	| result <Alien> name <Alien> chdir <Alien> |
    	chdir := Alien lookup: 'chdir' inLibrary: self libcName.
    	result := Alien new: 4.
    	name := file name asString asAlien.
    	[chdir
    		primFFICallResult: result
    		with: name pointer.
    	result asSignedLong = 0 ifFalse: [self error: 'Unable to cd to directory ', file name]]
    		ensure: [name free]
	! !

"December 30, 2009 -> 14:48:22"!

"System saved" !
"December 30, 2009 -> 15:49:48"!

! (Delta mirrorFor: #TextTestRunner) classSide methodsFor: 'instance creation' !
run: suite

	| runner result |
	runner := self new.
	suite addDependentToHierarchy: runner.
	[Transcript cr.
	result := suite run.
	Transcript cr;
		print: result; cr;
		print: result failures; cr;
		print: result errors]
			ensure: [suite removeDependentFromHierarchy: runner]! !

"December 30, 2009 -> 15:50:7"!

Delta define: #ClassTestIvars123 as: (
(Class subclassOf: 'Object' instanceVariables: 'one' classInstanceVariables: 'two three')) !


"December 30, 2009 -> 15:50:7"!

(Delta mirrorFor: #ClassTestIvars123) removeDefinitionIfFail: [] !


"December 30, 2009 -> 15:50:39"!

"System saved" !
"December 30, 2009 -> 22:30:11"!

! (Delta mirrorFor: #UnixFilePath) classSide methodsFor: 'instance creation' !
currentDirectory ^<FilePath>

    | buf <CString> buflen <Int> getcwd <Alien> |
    buflen := 1000.
    buf := Alien newC: buflen.
    getcwd := Alien lookup: 'getcwd' inLibrary: self libcName.
    ^[|result|
    	getcwd
    		primFFICallResult: (result := Alien new: 4)
    		with: buf pointer
    		with: buflen.
    	result asUnsignedLong = 0
    		ifTrue: [self error: 'Unable to get current directory']
            ifFalse: [self new pattern: buf strcpy ]
      ] ensure: [ buf free ]! !

"December 30, 2009 -> 22:31:10"!

! (Delta mirrorFor: #UnixFilePath) classSide methodsFor: 'instance creation' !
currentDirectory ^<FilePath>

    | buf <CString> buflen <Int> getcwd <Alien> |
    buflen := 1000.
    buf := Alien newC: buflen.
    getcwd := Alien lookup: 'getcwd' inLibrary: self libcName.
    ^[|result|
    	getcwd
    		primFFICallResult: (result := Alien new: 4)
    		with: buf pointer
    		with: buflen.
    	result asUnsignedLong = 0
    		ifTrue: [self error: 'Unable to get current directory']
            ifFalse: [self for: buf strcpy ]
      ] ensure: [ buf free ]! !

"December 30, 2009 -> 22:31:35"!

"System saved" !
"January 1, 2010 -> 13:54:24"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
canCollect

	^self canScavenge! !

"January 1, 2010 -> 13:54:32"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !
collectIfPossible

	self canCollect
		ifTrue: [self collectGarbage]! !

"January 1, 2010 -> 13:55:20"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore ScavengeCount AllocFailureCount Expansions LastCollection') !


"January 1, 2010 -> 13:59:3"!

(Delta mirrorFor: #Object) classSide removeMethod: #oldnew ifAbsent: [] !


"January 1, 2010 -> 14:12:44"!

"System saved" !
"January 3, 2010 -> 13:16:47"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'accessing' !
stat: block ifFail: failBlock

    | statBuffer <StatBuffer> 
    	status <ExternalProxy> |
    statBuffer := self StatBuffer new.
    statBuffer allocate.
    [ status := {{<libc ExternalProxy fstat>
            			name: self handle
            			buffer: statBuffer    }}.
	^status asSmallInteger == -1
		ifTrue: [failBlock value]
		ifFalse: [ block value: statBuffer ]]
			ensure: [ statBuffer free]

	! !

"January 3, 2010 -> 13:16:56"!

(Delta mirrorFor: #MacOSXFilePath) removeMethod: #statBufferClass ifAbsent: [] !


"January 3, 2010 -> 13:17:25"!

! (Delta mirrorFor: #MacOSXFileDescriptor) methodsFor: 'private' !
StatBuffer

	^MacOSXStatBuffer! !

"January 3, 2010 -> 13:17:33"!

(Delta mirrorFor: #MacOSXFileDescriptor) removeMethod: #statBufferClass ifAbsent: [] !


"January 3, 2010 -> 13:47:54"!

"System saved" !
"January 6, 2010 -> 22:42:25"!

Delta define: #ObjectiveCAlien as: (
(Class subclassOf: 'Alien' instanceVariables: '')) !


"January 6, 2010 -> 22:42:34"!

Delta define: #ObjectiveCClassAlien as: (
(Class subclassOf: 'ObjectiveCAlien' instanceVariables: '')) !


"January 6, 2010 -> 22:42:57"!

Delta define: #ObjectiveCAlien as: (
(Class subclassOf: 'Alien' instanceVariables: '')) !


"January 6, 2010 -> 22:42:57"!

Delta define: #ObjectiveCAlien as: (
(Class subclassOf: 'Alien' instanceVariables: '')) !


"January 6, 2010 -> 22:42:57"!

Delta define: #ObjectiveCAlien as: (
(Class subclassOf: 'Alien' instanceVariables: '')) !


"January 6, 2010 -> 22:42:57"!

Delta define: #ObjectiveCAlien as: (
(Class subclassOf: 'Alien' instanceVariables: '')) !


"January 6, 2010 -> 22:42:57"!

Delta define: #ObjectiveCAlien as: (
(Class subclassOf: 'Alien' instanceVariables: '')) !


"January 6, 2010 -> 22:42:57"!

Delta define: #ObjectiveCAlien as: (
(Class subclassOf: 'Alien' instanceVariables: '')) !


"January 6, 2010 -> 22:42:57"!

Delta define: #ObjectiveCAlien as: (
(Class subclassOf: 'Alien' instanceVariables: '') classVariables: 'ClassGetInstanceMethodAlien
EightByteParameterTypes
FourByteParameterTypes
ObjCMsgSendAlien
MethodTypeMap
MethodTypeResultMap
SelGetNameAlien
TypeQualifiers
TypeQualifierCodes') !


"January 6, 2010 -> 22:42:57"!

Delta define: #ObjectiveCAlien as: (
(Class subclassOf: 'Alien' instanceVariables: '') classVariables: 'ClassGetInstanceMethodAlien
EightByteParameterTypes
FourByteParameterTypes
ObjCMsgSendAlien
MethodTypeMap
MethodTypeResultMap
SelGetNameAlien
TypeQualifiers
TypeQualifierCodes') !


"January 6, 2010 -> 22:42:57"!

Delta define: #ObjectiveCAlien as: (
(Class subclassOf: 'Alien' instanceVariables: '') classVariables: 'ClassGetInstanceMethodAlien
EightByteParameterTypes
FourByteParameterTypes
ObjCMsgSendAlien
MethodTypeMap
MethodTypeResultMap
SelGetNameAlien
TypeQualifiers
TypeQualifierCodes') !


"January 6, 2010 -> 22:42:57"!

Delta define: #ObjectiveCAlien as: (
(Class subclassOf: 'Alien' instanceVariables: '') classVariables: 'ClassGetInstanceMethodAlien
EightByteParameterTypes
FourByteParameterTypes
ObjCMsgSendAlien
MethodTypeMap
MethodTypeResultMap
SelGetNameAlien
TypeQualifiers
TypeQualifierCodes') !


"January 6, 2010 -> 22:42:57"!

Delta define: #ObjectiveCAlien as: (
(Class subclassOf: 'Alien' instanceVariables: '') classVariables: 'ClassGetInstanceMethodAlien
EightByteParameterTypes
FourByteParameterTypes
ObjCMsgSendAlien
MethodTypeMap
MethodTypeResultMap
SelGetNameAlien
TypeQualifiers
TypeQualifierCodes') !


"January 6, 2010 -> 22:43:26"!

Delta define: #ObjectiveCMethod as: (
(Class subclassOf: 'Alien' instanceVariables: '')) !


"January 6, 2010 -> 22:43:35"!

! (Delta mirrorFor: #ObjectiveCAlien) methodsFor: 'accessing' !
isa
	| address |
	^(address := self unsignedLongAt: 1) ~= 0 ifTrue:
		[ObjectiveCClassAlien forPointer: ((Alien forPointer: address) unsignedLongAt: 1)]! !

"January 6, 2010 -> 22:43:35"!

! (Delta mirrorFor: #ObjectiveCAlien) methodsFor: 'coercing' !
asSmalltalkSelector
	"Assume the receiver is an Alien for a SEL.  Answer its correspondng Smaltalk selector, or raise an error."
	^(self SelGetNameAlien
			primFFICallResult: (Alien forPointer: 0)
			with: self) strcpy asSymbol! !

"January 6, 2010 -> 22:43:35"!

! (Delta mirrorFor: #ObjectiveCAlien) methodsFor: 'coercing' !
id
	"Answer the receiver's id. This coerces direct, pointer and indirect ObjectiveC objects correctly."
	^self addressField! !

"January 6, 2010 -> 22:44:10"!

! (Delta mirrorFor: #ObjectiveCAlien) methodsFor: 'coercing' !
asSmalltalkSelector
	"Assume the receiver is an Alien for a SEL.  Answer its correspondng Smaltalk selector, or raise an error."
	^(SelGetNameAlien
			primFFICallResult: (Alien forPointer: 0)
			with: self) strcpy asSymbol! !

"January 6, 2010 -> 22:44:10"!

! (Delta mirrorFor: #ObjectiveCAlien) methodsFor: 'objective-c runtime' !
objectiveCMethodForSelectorAlien: selectorAlien
	| pointer |
	pointer := ClassGetInstanceMethodAlien
						primFFICallResult: (Alien new: 4)
						with: self isa
						with: selectorAlien.
	^(pointer := pointer unsignedLongAt: 1) ~= 0 ifTrue:
		[ObjectiveCMethod atAddress: pointer]! !

"January 6, 2010 -> 22:44:10"!

! (Delta mirrorFor: #ObjectiveCAlien) methodsFor: 'message forwarding' !
doesNotUnderstand: aMessage
	| method returnTypeCharacter result |
	method := self objectiveCMethodForSelectorAlien: (self class asObjectiveCSelector: aMessage selector).
	method isNil ifTrue:
		["Might also check if selector is not already forward: and if
		  so try sending forward: of the selector and arguments?"
		 ^super doesNotUnderstand: aMessage].
	returnTypeCharacter := self class returnTypeCharacterForMethodTypes: method methodTypes.
	"If MethodTypeMap doesn't include returnTypeCharacter then we haven't
	implemented handling that return type yet."
	result := method implementation
				primFFICallResult: (MethodTypeMap at: returnTypeCharacter) value
				withArguments: {self. method rawSelector}, aMessage arguments.
	^(MethodTypeResultMap
			at: returnTypeCharacter
			ifAbsent: [^result])
		value: result! !

"January 6, 2010 -> 22:44:10"!

! (Delta mirrorFor: #ObjectiveCAlien) classSide methodsFor: 'instance creation' !
dataSize

	^4! !

"January 6, 2010 -> 22:44:26"!

! (Delta mirrorFor: #ObjectiveCAlien) classSide methodsFor: 'class initialization' !
initializeMethodTypeMap
	"self initializeMethodTypeMap"
	"ObjectiveCAlien initializeMethodTypeMap"
	"See /usr/include/objc/objc_class.h and
	 The Objective-C 2.0 Programming Language, Ch 12: The Runtime System, sec: Type Encodings."
	MethodTypeMap := IdentityDictionary new: 32.
	MethodTypeMap
		at: $@ "_C_ID"			put: [ObjectiveCAlien new];
		at: $# "_C_CLASS"		put: [ObjectiveCClassAlien new];
		at: $: "_C_SEL"			put: [Alien new: 4];
		at: $c "_CHR"			put: [Alien new: 1];
		at: $C "_C_UCHR"		put: [Alien new: 1];
		at: $s "_C_SHT"		put: [Alien new: 2];
		at: $S "_C_USHT"		put: [Alien new: 2];
		at: $i "_C_INT"			put: [Alien new: 4];
		at: $I "_C_UINT"		put: [Alien new: 4];
		at: $l "_C_LNG"			put: [Alien new: 4];
		at: $L "_C_ULNG"		put: [Alien new: 4];
		at: $f "_C_FLT"			put: [Alien new: 4];
		at: $d "_C_DBL"		put: [Alien new: 8];
		"at: $b" "_C_BFLD"		"put: [];"
		at: $v "_C_VOID"		put: nil;
		"at: $?" "_C_UNDEF"	"put: [];"
		at: $^ "_C_PTR"		put: [Alien forPointer: 0];
		at: $* "_CHARPTR"		put: [Alien forPointer: 0].
		"at: $[" "_C_ARY_B"	"put: [];"
		"at: $]" "_C_ARY_E"	"put: [];"
		"at: $(" "_C_UNION_B"	"put: [];"
		"at: $)" "_C_UNION_E"	"put: [];"
		"at: ${" "_C_STRUCT_B""put: [];"
		"at: $}" "_C_STRUCT_E""put: []."

	FourByteParameterTypes := '@#:cCsSiIlLf^*'.
	EightByteParameterTypes := 'd'.

"#define _C_CONST			'r'
#define _C_IN				'n'
#define _C_INOUT			'N'
#define _C_OUT			'o'
#define _C_BYCOPY		'O'
#define _C_BYREF			'R'
#define _C_ONEWAY		'V'
#define _C_GCINVISIBLE	'!!'
"
	TypeQualifiers := 'nNoOrRV!!'.
	TypeQualifierCodes := TypeQualifiers asByteArray.
					
	MethodTypeResultMap := IdentityDictionary new: 32.
	MethodTypeResultMap
		at: $c "_CHR"			put: [:alien| alien unsignedByteAt: 1];
		at: $C "_C_UCHR"		put: [:alien| alien unsignedByteAt: 1];
		at: $s "_C_SHT"		put: [:alien| alien signedShortAt: 1];
		at: $S "_C_USHT"		put: [:alien| alien unsignedShortAt: 1];
		at: $i "_C_INT"			put: [:alien| alien signedLongAt: 1];
		at: $I "_C_UINT"		put: [:alien| alien unsignedLongAt: 1];
		at: $l "_C_LNG"			put: [:alien| alien signedLongAt: 1];
		at: $L "_C_ULNG"		put: [:alien| alien unsignedLongAt: 1];
		at: $f "_C_FLT"			put: [:alien| alien floatAt: 1];
		at: $d "_C_DBL"		put: [:alien| alien doubleAt: 1].
! !

"January 6, 2010 -> 22:48:55"!

"System saved" !
"January 6, 2010 -> 22:53:26"!

! (Delta mirrorFor: #CompressedSymbol) methodsFor: 'coercing' !
asByteArray

	^ByteArray withAll: self! !

"January 6, 2010 -> 22:55:8"!

! (Delta mirrorFor: #CompressedSymbol) methodsFor: 'coercing' !
asByteArray

	^ByteArray withAll: (self copyWithSize: self size)! !

"January 6, 2010 -> 22:56:49"!

! (Delta mirrorFor: #CompressedSymbol) methodsFor: 'coercing' !
asByteArray

	^ByteArray withAll: self! !

"January 6, 2010 -> 22:58:28"!

! (Delta mirrorFor: #CompressedSymbol) methodsFor: 'coercing' !
asByteArray

	^self collect: [:ch| ch asciiValue]! !

"January 6, 2010 -> 22:58:47"!

! (Delta mirrorFor: #CompressedSymbol) methodsFor: 'coercing' !
asByteArray

	^ByteArray withAll: (self collect: [:ch| ch asciiValue])! !

"January 6, 2010 -> 23:7:16"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '' classInstanceVariables: 'initializers')) !


"January 6, 2010 -> 23:9:48"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'library class initialization' !
initializers

	initializers isNil ifTrue: [initializers := OrderedCollection new].
	^initializers! !

"January 6, 2010 -> 23:9:52"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'library class initialization' !
addInitializer: aClass after: predecessor

	self initializers add: aClass after: predecessor! !

"January 6, 2010 -> 23:10:17"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'library class initialization' !
runNonCriticalClassInitializers
	"This is the root class initializer that is called when the system starts up.
		Any class initializers that must be called should be called from
		this method."

	Session initialize.

	Rectangle initialize.
	Paint initialize.
	Painter initialize.
	HPEN initialize.
	GeometricHPEN initialize.
	HBRUSH initialize.
	InfiniteRegion initialize.

	Smalltalk initialize.

	CodeEditor initialize.
	Workspace initialize.

	HTMLElement initialize.
	HTMLParser initialize.
	self initializers do: [:each | each initialize]! !

"January 6, 2010 -> 23:11:32"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'library class initialization' !
addInitializer: aClass after: predecessor

	(self initializers includes: aClass) ifTrue: [^self].
	self initializers add: aClass after: predecessor! !

"January 6, 2010 -> 23:12:42"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'library class initialization' !
addInitializer: aClass after: predecessor

	(self initializers includes: aClass) ifTrue: [^self].
	predecessor isNil
		ifTrue: [self initializers add: aClass]
		ifFalse: [self initializers add: aClass after: predecessor]! !

"January 6, 2010 -> 23:14:4"!

! (Delta mirrorFor: #ObjectiveCAlien) classSide methodsFor: 'class initialization' !
initialize

	SystemInitializer addInitializer: self after: nil.
	ObjectiveCAlien initializeMethodTypeMap! !

"January 6, 2010 -> 23:14:29"!

! (Delta mirrorFor: #ObjectiveCAlien) classSide methodsFor: 'class initialization' !
initialize
"ObjectiveCAlien initialize"
	SystemInitializer addInitializer: self after: nil.
	ObjectiveCAlien initializeMethodTypeMap! !

"January 6, 2010 -> 23:14:38"!

! (Delta mirrorFor: #ObjectiveCAlien) classSide methodsFor: 'class initialization' !
initialize
"
ObjectiveCAlien initialize
"
	SystemInitializer addInitializer: self after: nil.
	ObjectiveCAlien initializeMethodTypeMap! !

"January 6, 2010 -> 23:16:30"!

! (Delta mirrorFor: #ObjectiveCAlien) classSide methodsFor: 'class initialization' !
initialize
"
ObjectiveCAlien initialize
"
	SystemInitializer addInitializer: self after: nil.
	Platform == MacOSXPlatform ifFalse: [^self].
	self initializeMethodTypeMap.
	self initializeSelectors! !

"January 6, 2010 -> 23:16:36"!

! (Delta mirrorFor: #ObjectiveCAlien) classSide methodsFor: 'class initialization' !
initializeSelectors

	SelectorTable := Dictionary new.
	ClassGetClassMethodAlien := self lookup: 'class_getClassMethod' inLibrary: '/usr/lib/libobjc.dylib'.
	ClassGetInstanceMethodAlien := self lookup: 'class_getInstanceMethod' inLibrary: '/usr/lib/libobjc.dylib'.
	ObjCLookUpClassAlien := self lookup: 'objc_lookUpClass' inLibrary: '/usr/lib/libobjc.dylib'.
	ObjCMsgSendAlien := self lookup: 'objc_msgSend' inLibrary: '/usr/lib/libobjc.dylib'.
	SelRegisterNameAlien := self lookup: 'sel_registerName' inLibrary: '/usr/lib/libobjc.dylib'.
	SelGetNameAlien := self lookup: 'sel_getName' inLibrary: '/usr/lib/libobjc.dylib'.
	ClassSelectorAlien := self asObjectiveCSelector: #objectiveCclass! !

"January 6, 2010 -> 23:17:47"!

Delta define: #ObjectiveCAlien as: (
(Class subclassOf: 'Alien' instanceVariables: '') classVariables: 'ClassGetClassMethodAlien
ClassGetInstanceMethodAlien
ClassSelectorAlien
EightByteParameterTypes
FourByteParameterTypes
ObjCLookUpClassAlien
ObjCMsgSendAlien
MethodTypeMap
MethodTypeResultMap
SelGetNameAlien
SelRegisterNameAlien
TypeQualifiers
TypeQualifierCodes') !


"January 6, 2010 -> 23:17:55"!

! (Delta mirrorFor: #ObjectiveCAlien) classSide methodsFor: 'class initialization' !
initializeSelectors

	SelectorTable := Dictionary new.
	ClassGetClassMethodAlien := self lookup: 'class_getClassMethod' inLibrary: '/usr/lib/libobjc.dylib'.
	ClassGetInstanceMethodAlien := self lookup: 'class_getInstanceMethod' inLibrary: '/usr/lib/libobjc.dylib'.
	ObjCLookUpClassAlien := self lookup: 'objc_lookUpClass' inLibrary: '/usr/lib/libobjc.dylib'.
	ObjCMsgSendAlien := self lookup: 'objc_msgSend' inLibrary: '/usr/lib/libobjc.dylib'.
	SelRegisterNameAlien := self lookup: 'sel_registerName' inLibrary: '/usr/lib/libobjc.dylib'.
	SelGetNameAlien := self lookup: 'sel_getName' inLibrary: '/usr/lib/libobjc.dylib'.
	ClassSelectorAlien := self asObjectiveCSelector: #objectiveCclass! !

"January 6, 2010 -> 23:18:9"!

(Delta mirrorFor: #ClassGetClassMethodAlien) removeDefinitionIfFail: [] !


"January 6, 2010 -> 23:18:22"!

(Delta mirrorFor: #ObjCLookUpClassAlien) removeDefinitionIfFail: [] !


"January 6, 2010 -> 23:18:37"!

(Delta mirrorFor: #SelRegisterNameAlien) removeDefinitionIfFail: [] !


"January 6, 2010 -> 23:18:52"!

(Delta mirrorFor: #ClassSelectorAlien) removeDefinitionIfFail: [] !


"January 6, 2010 -> 23:19:4"!

Delta define: #ObjectiveCAlien as: (
(Class subclassOf: 'Alien' instanceVariables: '') classVariables: 'ClassGetClassMethodAlien
ClassGetInstanceMethodAlien
ClassSelectorAlien
EightByteParameterTypes
FourByteParameterTypes
ObjCLookUpClassAlien
ObjCMsgSendAlien
MethodTypeMap
MethodTypeResultMap
SelectorTable
SelGetNameAlien
SelRegisterNameAlien
TypeQualifiers
TypeQualifierCodes') !


"January 6, 2010 -> 23:19:17"!

! (Delta mirrorFor: #ObjectiveCAlien) classSide methodsFor: 'class initialization' !
initializeSelectors

	SelectorTable := Dictionary new.
	ClassGetClassMethodAlien := self lookup: 'class_getClassMethod' inLibrary: '/usr/lib/libobjc.dylib'.
	ClassGetInstanceMethodAlien := self lookup: 'class_getInstanceMethod' inLibrary: '/usr/lib/libobjc.dylib'.
	ObjCLookUpClassAlien := self lookup: 'objc_lookUpClass' inLibrary: '/usr/lib/libobjc.dylib'.
	ObjCMsgSendAlien := self lookup: 'objc_msgSend' inLibrary: '/usr/lib/libobjc.dylib'.
	SelRegisterNameAlien := self lookup: 'sel_registerName' inLibrary: '/usr/lib/libobjc.dylib'.
	SelGetNameAlien := self lookup: 'sel_getName' inLibrary: '/usr/lib/libobjc.dylib'.
	ClassSelectorAlien := self asObjectiveCSelector: #objectiveCclass! !

"January 6, 2010 -> 23:19:39"!

(Delta mirrorFor: #SelectorTable) removeDefinitionIfFail: [] !


"January 6, 2010 -> 23:33:7"!

"System saved" !
"January 7, 2010 -> 1:55:3"!

! (Delta mirrorFor: #ObjectiveCAlien) classSide methodsFor: 'objective-c runtime' !
asObjectiveCSelector: aSelector
	"Answer an Alien for the Objective-C selector corresponding to aSelector.
	 Support selectors that clash with Smalltalk selectors and varargs methods.

	 Selectors that clash with Smalltalk (e.g. class), if sent would be understood
	 as regular Smalltalk selectors, and hence not forwarded to Objective-C by the
	 doesNotUnderstand: method.  Support thesde by allowing selectors to begin
	 with ``objectiveC'', and stripping this prefix when finding the corresponding
	 Objective-C selector. 

	Smalltalk has no support for varargs, and as of 10.4 the Mac OS X frameworks
	contain no occurrences of the keywork ``va:''.  So support varargs by stripping
	all trailing occurrences of ``va:''"
	^SelectorTable
		at: aSelector
		ifAbsentPut:
			[| selectorString stringAlien objectiveCSelector |
			selectorString := (aSelector beginsWith: 'objectiveC')
								ifTrue: [aSelector copyFrom: 11 to: aSelector size]
								ifFalse: [aSelector asString].
			[selectorString endsWith: 'va:'] whileTrue:
				[selectorString := selectorString copyFrom: 1 to: selectorString size - 3].
			stringAlien := selectorString asAlien.
			SelRegisterNameAlien
				primFFICallResult: (objectiveCSelector := Alien new: 4)
				with:  stringAlien pointer.
			stringAlien free.
			objectiveCSelector]! !

"January 7, 2010 -> 1:58:30"!

Delta define: #ObjectiveCMArgs as: (
(Class subclassOf: 'Alien' instanceVariables: '')) !


"January 7, 2010 -> 2:0:31"!

Delta define: #ObjectiveCObject as: (
(Class subclassOf: 'Alien' instanceVariables: '')) !


"January 7, 2010 -> 2:0:36"!

Delta define: #ObjectiveCSmalltalkObjectProxy as: (
(Class subclassOf: 'ObjectiveCObject' instanceVariables: '')) !


"January 7, 2010 -> 2:0:49"!

! (Delta mirrorFor: #ObjectiveCAlien) classSide methodsFor: 'objective-c runtime' !
argumentListFromMArgs: margs <ObjectiveCMArgs> numArgs: numArgs <Integer> withSignature: signature <String> ^<Array>
	| sigStream offset |
	sigStream := signature readStream.
	offset := 9. "Skip self and selector"
	^(1 to: numArgs) collect:
		[:ign| | code arg |
		 [TypeQualifiers includes: (code := sigStream next)] whileTrue.
		 code == $S
			ifTrue:
				[arg := ObjectiveCSmalltalkObjectProxy smalltalkObjectForAddress: (margs unsignedLongAt: offset)]
			ifFalse:
				[arg := (MethodTypeMap at: code ifAbsent: [self error: 'unknown code in Objective-C signature']) value.
				 arg replaceFrom: 1 to: arg dataSize with: margs startingAt: offset].
		 offset := offset + ((EightByteParameterTypes includes: code) ifTrue: [8] ifFalse: [4]).
		 code == $^ ifTrue: [sigStream next].
		 (MethodTypeResultMap at: code ifAbsent: [[:thing| thing]]) value: arg]! !

"January 7, 2010 -> 2:1:32"!

! (Delta mirrorFor: #ObjectiveCAlien) classSide methodsFor: 'objective-c runtime' !
encodeSimpleSignature: aString
	"Take a string encoding an Objective-C method signature without argument size or offsets
	 and decorate it with sizes and offsets."
	"ObjectiveCAlien encodeSimpleSignature: '@@::^v'"

	| size offset decoration index prefix ch |
	size := offset := 0.
	decoration := String new writeStream.
	index := 1.
	[TypeQualifiers includes: (ch := aString at: index)] whileTrue: [index := index + 1].
	"Special hack for pointer types."
	ch = $^ ifTrue: [index := index + 1]. "For now handle only a single character following ^"
	prefix := index.
	index := index + 1.
	[index <= aString size] whileTrue:
		[[ch := aString at: index.
		  TypeQualifiers includes: ch] whileTrue: [decoration nextPut: ch. index := index + 1].
		 size := (FourByteParameterTypes includes: ch)
					ifTrue: [4]
					ifFalse:
						[(EightByteParameterTypes includes: ch)
							ifTrue: [8]
							ifFalse: [self error: 'unrecognized or unhandled type character']].
		 index := index + 1.
		 (decoration nextPut: ch) = $^ ifTrue: "Special hack for pointer types."
			[decoration nextPut: (aString at: index). "For now handle only a single character following ^"
			 index := index + 1].
		 decoration print: offset.
		 offset := offset + size].
	^(aString copyFrom: 1 to: prefix), offset printString, (decoration contents)! !

"January 7, 2010 -> 2:2:1"!

! (Delta mirrorFor: #ObjectiveCAlien) classSide methodsFor: 'objective-c runtime' !
frameworkLibraryNameFor: frameworkName
	^'/System/Library/Frameworks/', frameworkName,
			'.framework/Versions/C/', frameworkName! !

"January 7, 2010 -> 2:3:39"!

! (Delta mirrorFor: #ObjectiveCAlien) classSide methodsFor: 'objective-c runtime' !
frameworkLibraryNameFor: frameworkName
"this is wrong not all frameworks are version C. Use current?"
	^'/System/Library/Frameworks/', frameworkName,
			'.framework/Versions/C/', frameworkName! !

"January 7, 2010 -> 2:3:45"!

! (Delta mirrorFor: #ObjectiveCAlien) classSide methodsFor: 'objective-c runtime' !
frameworkLibraryNameFor: frameworkName
"this is wrong not all frameworks are version C. Use Current?"
	^'/System/Library/Frameworks/', frameworkName,
			'.framework/Versions/C/', frameworkName! !

"January 7, 2010 -> 2:4:46"!

! (Delta mirrorFor: #ObjectiveCAlien) classSide methodsFor: 'objective-c runtime' !
lookup: globalOrClassName <String> inFramework: frameworkName <String> ^<ObjectiveCClassAlien | nil>
	"Looks up a global or a class and answers a suitable Alien.
	 If receiver is ObjectiveCAlien result is an ObjectiveCAlien for some global variable (e.g. NSApp).
	 If receiver is ObjectiveCClassAlien result is an ObjectiveCClassAlien for some class (e.g. NSApplication).
	 i.e. the client must know whether they're asking for a global or a class."
	^self
		lookup: globalOrClassName
		inLibrary: (self frameworkLibraryNameFor: frameworkName)! !

"January 7, 2010 -> 2:5:50"!

! (Delta mirrorFor: #ObjectiveCAlien) classSide methodsFor: 'objective-c runtime' !
returnTypeCharacterForMethodTypes: methodTypes <Alien> ^<Character>
	"Answer the return type of an Objective-C method given an Alien for its method_types."
	| index code |
	index := 1.
	[TypeQualifierCodes includes: (code := methodTypes unsignedByteAt: index)] whileTrue:
		[index := index + 1].
	^Character value: code! !

"January 7, 2010 -> 2:6:40"!

! (Delta mirrorFor: #ObjectiveCAlien) classSide methodsFor: 'objective-c runtime' !
valueOfDatum: global <String> inFramework: frameworkName <String> ^<ObjectiveCClassAlien | nil>
	"Fetches the value of a global and answers an ObjectiveCAlien."
	^self forPointer: ((self
									lookup: global
									inLibrary: (self frameworkLibraryNameFor: frameworkName))
										unsignedLongAt: 1)! !

"January 7, 2010 -> 2:11:31"!

Delta define: #ObjectiveCClass as: (
(Class subclassOf: 'ObjectiveCObject' instanceVariables: '')) !


"January 7, 2010 -> 2:11:55"!

! (Delta mirrorFor: #ObjectiveCClassAlien) methodsFor: 'coercing' !
asObjectiveCClass
	"Answer a struct objc_class object (ObjectiveCClass) for the receivers class."
	^ObjectiveCClass atAddress: (self unsignedLongAt: 1)! !

"January 7, 2010 -> 2:12:13"!

! (Delta mirrorFor: #ObjectiveCClassAlien) methodsFor: 'coercing' !
asObjectiveCClass ^<ObjectiveCClass>
	"Answer a struct objc_class object (ObjectiveCClass) for the receivers class."
	^ObjectiveCClass atAddress: (self unsignedLongAt: 1)! !

"January 7, 2010 -> 2:13:9"!

! (Delta mirrorFor: #ObjectiveCClassAlien) methodsFor: 'objective-c runtime' !
objectiveCMethodForSelector: selectorAlien
	| pointer |
	pointer := ClassGetClassMethodAlien
						primFFICallResult: (Alien new: 4)
						with: self
						with: selectorAlien.
	^(pointer := pointer unsignedLongAt: 1) ~= 0 ifTrue:
		[ObjectiveCMethod atAddress: pointer]! !

"January 7, 2010 -> 2:14:43"!

! (Delta mirrorFor: #ObjectiveCClassAlien) classSide methodsFor: 'coercing' !
makeNSStringFrom: string <String>
	| NSString |
	NSString := self lookup: 'NSString' inFramework: 'Foundation'.
	^string isEmpty
		ifTrue: [NSString string]
		ifFalse: [NSString alloc initWithUTF8String: string isoToUtf8 asAlien pointer]! !

"January 7, 2010 -> 2:15:25"!

! (Delta mirrorFor: #ObjectiveCClassAlien) classSide methodsFor: 'objective-c runtime' !
lookup: className <String> ^<ObjectiveCClassAlien | nil>
	| classAlien stringAlien |
	ObjCLookUpClassAlien
		primFFICallResult: (classAlien := self new)
		with: (stringAlien := className asAlien) pointer.
	stringAlien free.
	^(classAlien unsignedLongAt: 1) ~= 0 ifTrue: [classAlien]! !

"January 7, 2010 -> 2:15:53"!

! (Delta mirrorFor: #ObjectiveCClassAlien) classSide methodsFor: 'objective-c runtime' !
lookup: className <String> inLibrary: aLibraryName <String> ^<ObjectiveCClassAlien | nil>
	self ensureLoaded: aLibraryName.
	^self lookup: className! !

"January 7, 2010 -> 2:19:49"!

(Delta mirrorFor: #NSString) removeDefinitionIfFail: [] !


"January 7, 2010 -> 2:20:32"!

Delta define: #AlienDemo as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"January 7, 2010 -> 2:22:9"!

! (Delta mirrorFor: #AlienDemo) methodsFor: 'MacOS examples' !
exampleNSOpenPanel
	"AlienDemo new exampleNSOpenPanel"
	| panel files |
	(ObjectiveCClassAlien lookup: 'NSApplication' inFramework: 'AppKit') sharedApplication.
	panel:= (ObjectiveCClassAlien lookup: 'NSOpenPanel' inFramework: 'AppKit') openPanel.
	panel
		setAllowsOtherFileTypes: true asAlien;
		setAllowsMultipleSelection: true asAlien;
		setCanChooseDirectories: false asAlien;
		setCanChooseFiles: true asAlien.
	(panel runModalForDirectory: nil asAlien file: nil asAlien types: nil asAlien) = 0 ifTrue:
		[^self].
	files:= panel filenames.
	0 to: files count - 1 do:
		[:i|
		Transcript
			cr;
			nextPutAll: (files objectAtIndex: i) UTF8String strcpyUTF8;
			flush]! !

"January 7, 2010 -> 2:23:1"!

"System saved" !
"January 7, 2010 -> 23:14:17"!

! (Delta mirrorFor: #ReadString) methodsFor: 'comparing-case sensitive' !
endsWith: chars <SequenceableCollection[Character]>

	^('*', chars) match: self ignoreCase: false! !

"January 7, 2010 -> 23:15:32"!

! (Delta mirrorFor: #StringTest) methodsFor: 'testing' !
testBeginsWith

	| source |
	source := 'Elvis' asString.
	self assert: (source beginsWith: 'El').
	self assert: ('Elvis' beginsWith: 'El').
	self deny: (source beginsWith: 'vis').
	self deny: (source beginsWith: 'the').! !

"January 7, 2010 -> 23:15:51"!

! (Delta mirrorFor: #ReadString) methodsFor: 'comparing-case sensitive' !
beginsWith: chars <SequenceableCollection[Character]>

	^(chars, '*') match: self ignoreCase: false! !

"January 7, 2010 -> 23:16:13"!

Delta define: #ClassTestIvars123 as: (
(Class subclassOf: 'Object' instanceVariables: 'one' classInstanceVariables: 'two three')) !


"January 7, 2010 -> 23:16:13"!

(Delta mirrorFor: #ClassTestIvars123) removeDefinitionIfFail: [] !


"January 7, 2010 -> 23:16:52"!

"System saved" !
"January 8, 2010 -> 1:41:13"!

! (Delta mirrorFor: #Process) methodsFor: 'restricted' !
traceStack

	{{self primitiveProcessTraceStack: 40 ifFail: [ :err <Symbol> | self error: err]}}
! !

"January 8, 2010 -> 1:41:40"!

"System saved" !
"April 25, 2010 -> 17:50:0"!

Delta define: #MainProcess as: (
(Class subclassOf: 'Process' instanceVariables: '')) !


"April 25, 2010 -> 17:53:57"!

(Delta mirrorFor: #MainProcess)
comment: 
'I represent a process running on the main thread of the OS process.
There should only ever be one active instance of me.

Actions may be scheduled to run on this thread by sending the message
#schedule: and passing a zero arg block as argument. Actions are
scheduled in FIFO order. Each runs to completion before the next is
scheduled.'!


"April 25, 2010 -> 17:54:39"!

Delta define: #MainProcess as: (
(Class subclassOf: 'Process' instanceVariables: '' classInstanceVariables: 'soleInstance')) !


"April 25, 2010 -> 17:55:16"!

(Delta mirrorFor: #MainProcess)
comment: 
'I represent a process running on the main thread of the OS process.
There should only ever be one active instance of me and it should be
created by the VM.

Actions may be scheduled to run on this thread by sending the message
#schedule: and passing a zero arg block as argument. Actions are
scheduled in FIFO order. Each runs to completion before the next is
scheduled.'!


"April 25, 2010 -> 17:56:49"!

! (Delta mirrorFor: #MainProcess) classSide methodsFor: 'restricted' !
soleInstance: instance <MainProcess>

	soleInstance := instance! !

"April 25, 2010 -> 17:57:25"!

Delta define: #MainProcess as: (
(Class subclassOf: 'Process' instanceVariables: 'actions' classInstanceVariables: 'soleInstance')) !


"April 25, 2010 -> 17:57:35"!

! (Delta mirrorFor: #MainProcess) methodsFor: 'restricted' !
start

	MainProcess soleInstance: self.
	actions := SharedQueue new! !

"April 25, 2010 -> 17:58:14"!

! (Delta mirrorFor: #MainProcess) methodsFor: 'scheduling' !
schedule: block <[]>

	actions add: block! !

"April 25, 2010 -> 17:58:26"!

! (Delta mirrorFor: #MainProcess) methodsFor: 'restricted' !
start

	MainProcess soleInstance: self.
	actions := SharedQueue new.
	self run! !

"April 25, 2010 -> 18:0:31"!

! (Delta mirrorFor: #MainProcess) methodsFor: 'restricted' !
start

	MainProcess soleInstance: self.
	actions := SharedQueue[[]] new.
	self run! !

"April 25, 2010 -> 18:0:53"!

Delta define: #MainProcess as: (
(Class subclassOf: 'Process' instanceVariables: 'actions <SharedQueue[[]]>' classInstanceVariables: 'soleInstance')) !


"April 25, 2010 -> 18:1:2"!

Delta define: #MainProcess as: (
(Class subclassOf: 'Process' instanceVariables: 'actions <SharedQueue[[]]>' classInstanceVariables: 'soleInstance <MainProcess>')) !


"April 25, 2010 -> 18:2:36"!

! (Delta mirrorFor: #MainProcess) methodsFor: 'private' !
run

	[self runNext] whileTrue! !

"April 25, 2010 -> 18:3:1"!

! (Delta mirrorFor: #MainProcess) methodsFor: 'private' !
runNext

	actions next value.
	true! !

"April 25, 2010 -> 18:4:29"!

! (Delta mirrorFor: #MainProcess) methodsFor: 'private' !
runNext

	actions next value.
	^true! !

"April 25, 2010 -> 18:5:33"!

! (Delta mirrorFor: #MainProcess) methodsFor: 'private' !
runNext

	actions next
		on: Error
		do: [:ex| [self error: ex messageText] fork].
	^true! !

"April 25, 2010 -> 18:8:59"!

! (Delta mirrorFor: #MainProcess) classSide methodsFor: 'accessing' !
soleInstance

	^soleInstance! !

"April 25, 2010 -> 18:22:35"!

! (Delta mirrorFor: #MainProcess) methodsFor: 'restricted' !
start

	actions := SharedQueue[[]] new.
	self run! !

"April 25, 2010 -> 18:22:42"!

(Delta mirrorFor: #MainProcess) classSide removeMethod: #soleInstance: ifAbsent: [] !


"April 25, 2010 -> 18:23:3"!

! (Delta mirrorFor: #MainProcess) classSide methodsFor: 'restricted' !
initialize

	soleInstance := self new! !

"April 25, 2010 -> 18:25:0"!

! (Delta mirrorFor: #MainProcess) classSide methodsFor: 'restricted' !
initialize

	soleInstance := (self new)
										initialize;
										yourself! !

"April 25, 2010 -> 18:27:12"!

! (Delta mirrorFor: #MainProcess) methodsFor: 'private' !
recordMainProcess

	{{ self primitiveRecordMainProcess: self ifFail: [:ex | self error: 'Only one allowed'] }}! !

"April 25, 2010 -> 18:27:53"!

! (Delta mirrorFor: #MainProcess) methodsFor: 'restricted' !
initialize

	actions := SharedQueue[[]] new.
	self recordMainProcess.
	self recordId.
	self register! !

"April 25, 2010 -> 18:36:24"!

! (Delta mirrorFor: #MainProcess) methodsFor: 'restricted' !
initialize

	actions := SharedQueue[[]] new.
	self recordMainProcess.
	self recordId.
	self register.
	self resume! !

"April 25, 2010 -> 18:38:7"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'library class initialization' !
addInitializer: aClass

	self addInitializer: aClass after: nil! !

"April 25, 2010 -> 18:38:59"!

! (Delta mirrorFor: #MainProcess) classSide methodsFor: 'restricted' !
initialize

	SystemInitializer addInitializer: self.
	soleInstance := (self new)
										initialize;
										yourself! !

"April 25, 2010 -> 18:40:24"!

! (Delta mirrorFor: #MainProcess) classSide methodsFor: 'restricted' !
start

	soleInstance start! !

"April 25, 2010 -> 18:43:0"!

! (Delta mirrorFor: #MainProcess) methodsFor: 'private' !
recordMainProcess

	{{ self primitiveRecordMainProcessIfFail: [:ex | self error: 'Only one allowed'] }}! !

"April 25, 2010 -> 18:53:32"!

"System saved" !
"April 29, 2010 -> 0:28:13"!

! (Delta mirrorFor: #MainProcess) methodsFor: 'restricted' !
start

	self recordId.
	actions := SharedQueue[[]] new.
	self run! !

"April 29, 2010 -> 0:28:13"!

! (Delta mirrorFor: #MainProcess) methodsFor: 'restricted' !
initialize

	actions := SharedQueue[[]] new.
	self recordMainProcess.
	self register.
	self resume! !

"April 29, 2010 -> 0:33:9"!

"System saved" !
"May 1, 2010 -> 22:57:17"!

! (Delta mirrorFor: #MainProcess) methodsFor: 'scheduling' !
schedule: block <[]>

	actions nextPut: block! !

"May 1, 2010 -> 23:15:24"!

! (Delta mirrorFor: #MainProcess) methodsFor: 'private' !
fileOutOn: d <Dumper>

	nil fileOutOn: d! !

"May 1, 2010 -> 23:16:19"!

"System saved" !
"May 1, 2010 -> 23:38:29"!

Delta define: #CocoaEventLoop as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 1, 2010 -> 23:41:57"!

! (Delta mirrorFor: #CocoaEventLoop) classSide methodsFor: 'restricted' !
initialize

	SystemInitializer addInitializer: self after: MainProcess.
	(Platform == MacOSXPlatform)
		ifFalse: [^self].
	MainProcess soleInstance schedule: [self runEventLoop]! !

"May 2, 2010 -> 0:2:10"!

! (Delta mirrorFor: #CocoaEventLoop) classSide methodsFor: 'restricted' !
runEventLoop

	|main|
	! !

"May 2, 2010 -> 0:2:56"!

"System saved" !
"May 3, 2010 -> 13:21:37"!

! (Delta mirrorFor: #ObjectiveCAlien) classSide methodsFor: 'objective-c runtime' !
frameworkLibraryNameFor: frameworkName
"this is wrong not all frameworks are version C. Use Current?"
	^'/System/Library/Frameworks/', frameworkName,
			'.framework/Versions/Current/', frameworkName! !

"May 3, 2010 -> 14:2:33"!

"System saved" !
"May 3, 2010 -> 14:34:44"!

! (Delta mirrorFor: #MainProcess) methodsFor: 'private' !
runNext

	actions next
		on: Error
		do: [:ex| [ex signal] fork].
	^true! !

"May 3, 2010 -> 14:34:53"!

"System saved" !
"May 3, 2010 -> 15:34:7"!

Delta define: #MacOSXPlatform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"May 3, 2010 -> 15:34:7"!

Delta define: #MacOSXPlatform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"May 3, 2010 -> 15:34:7"!

Delta define: #MacOSXPlatform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"May 3, 2010 -> 15:34:7"!

Delta define: #MacOSXPlatform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"May 3, 2010 -> 15:34:7"!

Delta define: #MacOSXPlatform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"May 3, 2010 -> 15:34:7"!

Delta define: #MacOSXPlatform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"May 3, 2010 -> 15:34:7"!

Delta define: #MacOSXPlatform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"May 3, 2010 -> 15:34:7"!

Delta define: #MacOSXPlatform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"May 3, 2010 -> 15:34:7"!

Delta define: #MacOSXPlatform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"May 3, 2010 -> 15:34:7"!

Delta define: #MacOSXPlatform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"May 3, 2010 -> 15:34:7"!

Delta define: #MacOSXPlatform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"May 3, 2010 -> 15:34:7"!

(Delta mirrorFor: #MacOSXPlatform)
comment: 
'The class side holds platform dependent constants and utilities.  Is also used
to get command line args, and other things like that.

Keywords: %machdep  %User

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.4 $
'!


"May 3, 2010 -> 15:34:7"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLInitialize
    DLLDict := Dictionary new.
    {{primitiveDLLSetupLookup: self selector: #DLLLookup:in: ifFail: [:err | self error: err]}}! !

"May 3, 2010 -> 15:34:7"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLLibrary: name
    ^DLLDict at: name ifAbsent: [
        DLLDict at: name put: (self DLLLoad: name)
    ]! !

"May 3, 2010 -> 15:34:7"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLLoad2: name

	|block|
	block := [:lib| ^lib].
    self tryDLLLoad: name ifSuccess: block.
    self tryDLLLoad: (name, '.dylib') asSymbol ifSuccess: block.
    self error: 'Cannot find library ', name! !

"May 3, 2010 -> 15:34:7"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLLoad: name
    | r n |
    r := ExternalProxy new.
    n := (self DLLMapName: name) asSymbol.
    ^{{primitiveDLLLoad: n result: r ifFail: [ :err | self error: err]}}! !

"May 3, 2010 -> 15:34:7"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLLookup: name <Str> in: library <Str>
    "Convert library into proxy"
    | p r |
    p := self DLLLibrary: library.
    r := ExternalProxy new.
    {{primitiveDLLLookup: name asSymbol in: p result: r ifFail: [:err | self error: err]}}.
    ^r! !

"May 3, 2010 -> 15:34:7"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLMapName: name <Str> ^<Str>
	(name endsWith: '.dylib') ifTrue: [^name].
    name = 'libc' ifTrue: [^'libc.dylib'].
    ^name, '.dylib'! !

"May 3, 2010 -> 15:34:7"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
tryDLLLoad: name <Str> ifFail: block <[X]> ^ <ExternalProxy>

	| r |
    r := ExternalProxy new.
    ^{{primitiveDLLLoad: name
    		result: r 
    		ifFail: [:err | block value: err]}}! !

"May 3, 2010 -> 15:34:7"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
tryDLLLoad: name <Str> ifSuccess: block <[X]>

	| r |
    r := self tryDLLLoad: name ifFail: [:err| ^self].
    block value: r! !

"May 3, 2010 -> 15:34:7"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'clipboard access' !
clipboardText: str <Str>

    self openClipboard.
    [   | glob <HGLOBAL> strm <ReadWriteStream[Character]> xstr <Str> |
        self emptyClipboard.

        "transform string into a form with lfs inserted"
        strm := (String new: str size) readWriteStream.
        str do:
            [ :c <Character> |
                strm put: c.
                c = Character cr
                    ifTrue: [ strm put: Character lf ].
            ].
        xstr := String withAll: strm contentsWritten.

        glob := HGLOBAL new
                        allocate: xstr size + 1
                        attributes: (Win32 GMEM_MOVEABLE
                                            externalBitOr: Win32 GMEM_DDESHARE).
        glob withPointer: CString new
                do: [ :cs <CString> |
                            cs value: xstr   ].

        {{<user ExternalProxy SetClipboardData>
                format: Win32 CF_TEXT
                data: glob
        }} isNull
            ifTrue: [ Win32 handleError ].
    ] ensure:
        [ self closeClipboard ]! !

"May 3, 2010 -> 15:34:7"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'clipboard access' !
clipboardTextIfAbsent: blk <[^X def]> ^<Str | X>

    self openClipboard.
    [   | glob <HGLOBAL> strm <CharWriteStream> |

        {{<user ExternalProxy IsClipboardFormatAvailable> format: Win32 CF_TEXT}} asBoolean
            ifFalse: [ ^blk value ].
        glob := {{<user HGLOBAL GetClipboardData> format: Win32 CF_TEXT}}.
        glob isNull
            ifTrue: [ Win32 handleError ].
        strm := (String new: 100) writeStream.
        glob withPointer: CString new
                do: [ :cs <CString> |
                            cs asString do:
                                [ :c <Character> |
                                    c = Character lf
                                        ifFalse: [ strm put: c ]
                                ].
                            ^strm contentsWritten
                      ].
    ] ensure:
        [ self closeClipboard ]! !

"May 3, 2010 -> 15:34:7"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'command line' !
commandLine ^<Str>
   ^self getCommandLine! !

"May 3, 2010 -> 15:34:7"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'command line' !
commandLineTokens ^<InputStream[Str]>
    "a stream of the input line tokens.  Tokens are sequences separated by whitespace; whitespace can be 
        included in a token by double quoting the arg.  (quotes can be imbedded by doubling, as with Smalltalk strings;
        the returned token has delimiting quotes removed and internal quotes undoubled. "

    | cstrm <CharInputStream> |
    cstrm := self commandLine readStream.
    self skipSpacesIn: cstrm.
    ^CustomInputStream[Str] new
            nextBlock: [    self parseArgFrom: cstrm ];
            atEndBlock: [ cstrm atEnd ].! !

"May 3, 2010 -> 15:34:7"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'command line' !
getArguments ^<OrdCltn[Str]>

    ^ {{ primitiveCommandLineArgs }} asOrderedCollection
    	collect: [:bytes| bytes asString]! !

"May 3, 2010 -> 15:34:7"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'command line' !
getCommandLine
    | stream |
    stream := CharacterReadWriteStream on: ''.
    self getArguments do: [:arg| stream nextPutAll: arg; space].
    stream isEmpty ifTrue: [^''].
    ^stream copyFrom: 1 to: stream size - 1! !

"May 3, 2010 -> 15:34:7"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'constants' !
multipleMatchWildcardCharacter ^<Character>

    ^$*! !

"May 3, 2010 -> 15:34:7"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'constants' !
singleMatchWildcardCharacter ^<Character>

    ^$?! !

"May 3, 2010 -> 15:34:7"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'constants' !
wordSize ^<Int>
    ^4! !

"May 3, 2010 -> 15:34:7"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'environment' !
environmentVariableAt: key <Str> ifAbsent: blk <[^X def]> ^ <Str | X>

    | cKey <CString> cValue <CString> |
    cKey := CString for: key.
    [cValue := {{<libc CString getenv> key: cKey}}.
    ^cValue isNull
    	ifTrue: [blk value]
    	ifFalse: [cValue asString]]
    	ensure: [cKey free]! !

"May 3, 2010 -> 15:34:7"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'initialization' !
initialize

    self DLLInitialize! !

"May 3, 2010 -> 15:34:7"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'os specific' !
currentThreadId
	"^ 0"
	^ {{ primitiveCurrentThreadId }}! !

"May 3, 2010 -> 15:34:7"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'os streams' !
errorStream ^<CharOutputStream>

    ErrorStream isNil
        ifTrue: [   ErrorStream := TempTranscript new ].
    ^ErrorStream! !

"May 3, 2010 -> 15:34:7"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'platform classes' !
pathClass ^<FilePath class>

    ^MacOSXFilePath! !

"May 3, 2010 -> 15:34:7"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'platform classes' !
patternClass ^<FilePattern class>

    ^UnixFilePattern! !

"May 3, 2010 -> 15:34:7"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'private' !
parseArgFrom: strm <CharInputStream>  ^<Str>

    ^strm peek = $"
        ifTrue: [       strm next.
                        strm upTo: $"   ]
        ifFalse: [  strm upTo: Character space ]! !

"May 3, 2010 -> 15:34:7"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'private' !
skipSpacesIn: strm <CharInputStream>

    [ strm atEnd not and: [ strm peekFor: Character space] ] whileTrue.
! !

"May 3, 2010 -> 15:34:7"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'private-clipboard access' !
closeClipboard

    {{<user ExternalProxy CloseClipboard> call}}! !

"May 3, 2010 -> 15:34:7"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'private-clipboard access' !
emptyClipboard

    {{<user ExternalProxy EmptyClipboard> call}} asBoolean
        ifFalse: [ Win32 handleError ].
! !

"May 3, 2010 -> 15:34:8"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'private-clipboard access' !
openClipboard

    {{<user ExternalProxy OpenClipboard> hnd: Win32 NULL}} asBoolean
        ifFalse: [ Win32 handleError ].
! !

"May 3, 2010 -> 15:34:8"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'testing' !
usesCrLfConvention ^<Boolean>

    ^false! !

"May 3, 2010 -> 15:34:8"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t tm |
	t := TimeT new allocate.
	[{{<libc ExternalProxy time> struct: t}} isAllOnes
		ifTrue: [self error: 'Invalid time'].
	tm := {{<libc TM gmtime>
					struct: t}}.
	^tm asSYSTEMTIME] ensure: [t free]
! !

"May 3, 2010 -> 15:34:18"!

Delta define: #UnixPlatform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"May 3, 2010 -> 15:34:18"!

Delta define: #UnixPlatform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"May 3, 2010 -> 15:34:18"!

Delta define: #UnixPlatform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"May 3, 2010 -> 15:34:18"!

Delta define: #UnixPlatform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"May 3, 2010 -> 15:34:18"!

Delta define: #UnixPlatform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"May 3, 2010 -> 15:34:18"!

Delta define: #UnixPlatform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"May 3, 2010 -> 15:34:18"!

Delta define: #UnixPlatform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"May 3, 2010 -> 15:34:18"!

Delta define: #UnixPlatform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"May 3, 2010 -> 15:34:18"!

Delta define: #UnixPlatform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"May 3, 2010 -> 15:34:18"!

Delta define: #UnixPlatform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"May 3, 2010 -> 15:34:18"!

Delta define: #UnixPlatform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"May 3, 2010 -> 15:34:18"!

(Delta mirrorFor: #UnixPlatform)
comment: 
'The class side holds platform dependent constants and utilities.  Is also used
to get command line args, and other things like that.

Keywords: %machdep  %User

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.4 $
'!


"May 3, 2010 -> 15:34:18"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLInitialize
    DLLDict := Dictionary new.
    {{primitiveDLLSetupLookup: self selector: #DLLLookup:in: ifFail: [:err | self error: err]}}! !

"May 3, 2010 -> 15:34:18"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLLibrary: name
    ^DLLDict at: name ifAbsent: [
        DLLDict at: name put: (self DLLLoad: name)
    ]! !

"May 3, 2010 -> 15:34:18"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLLoad2: name

	|block|
	block := [:lib| ^lib].
    self tryDLLLoad: name ifSuccess: block.
    self tryDLLLoad: (name, '.so') asSymbol ifSuccess: block.
    self tryDLLLoad: (name, '.so.6') asSymbol ifSuccess: block.
    self error: 'Cannot find library ', name! !

"May 3, 2010 -> 15:34:18"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLLoad: name
    | r n |
    r := ExternalProxy new.
    n := (self DLLMapName: name) asSymbol.
    ^{{primitiveDLLLoad: n result: r ifFail: [ :err | self error: err]}}! !

"May 3, 2010 -> 15:34:18"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLLookup: name <Str> in: library <Str>
    "Convert library into proxy"
    | p r |
    p := self DLLLibrary: library.
    r := ExternalProxy new.
    {{primitiveDLLLookup: name asSymbol in: p result: r ifFail: [:err | self error: err]}}.
    ^r! !

"May 3, 2010 -> 15:34:18"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLMapName: name <Str> ^<Str>
	name indexOfSubCollection: '.so'
			startingAt: 1
			ifAbsent: [name = 'libc' ifTrue: [^'libc.so.6'].
    						^name, '.so'].
    ^name    ! !

"May 3, 2010 -> 15:34:18"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
tryDLLLoad: name <Str> ifFail: block <[X]> ^ <ExternalProxy>

	| r |
    r := ExternalProxy new.
    ^{{primitiveDLLLoad: name
    		result: r 
    		ifFail: [:err | block value: err]}}! !

"May 3, 2010 -> 15:34:18"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
tryDLLLoad: name <Str> ifSuccess: block <[X]>

	| r |
    r := self tryDLLLoad: name ifFail: [:err| ^self].
    block value: r! !

"May 3, 2010 -> 15:34:18"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'clipboard access' !
clipboardText: str <Str>

    self openClipboard.
    [   | glob <HGLOBAL> strm <ReadWriteStream[Character]> xstr <Str> |
        self emptyClipboard.

        "transform string into a form with lfs inserted"
        strm := (String new: str size) readWriteStream.
        str do:
            [ :c <Character> |
                strm put: c.
                c = Character cr
                    ifTrue: [ strm put: Character lf ].
            ].
        xstr := String withAll: strm contentsWritten.

        glob := HGLOBAL new
                        allocate: xstr size + 1
                        attributes: (Win32 GMEM_MOVEABLE
                                            externalBitOr: Win32 GMEM_DDESHARE).
        glob withPointer: CString new
                do: [ :cs <CString> |
                            cs value: xstr   ].

        {{<user ExternalProxy SetClipboardData>
                format: Win32 CF_TEXT
                data: glob
        }} isNull
            ifTrue: [ Win32 handleError ].
    ] ensure:
        [ self closeClipboard ]! !

"May 3, 2010 -> 15:34:18"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'clipboard access' !
clipboardTextIfAbsent: blk <[^X def]> ^<Str | X>

    self openClipboard.
    [   | glob <HGLOBAL> strm <CharWriteStream> |

        {{<user ExternalProxy IsClipboardFormatAvailable> format: Win32 CF_TEXT}} asBoolean
            ifFalse: [ ^blk value ].
        glob := {{<user HGLOBAL GetClipboardData> format: Win32 CF_TEXT}}.
        glob isNull
            ifTrue: [ Win32 handleError ].
        strm := (String new: 100) writeStream.
        glob withPointer: CString new
                do: [ :cs <CString> |
                            cs asString do:
                                [ :c <Character> |
                                    c = Character lf
                                        ifFalse: [ strm put: c ]
                                ].
                            ^strm contentsWritten
                      ].
    ] ensure:
        [ self closeClipboard ]! !

"May 3, 2010 -> 15:34:18"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'command line' !
commandLine ^<Str>
   ^self getCommandLine! !

"May 3, 2010 -> 15:34:18"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'command line' !
commandLineTokens ^<InputStream[Str]>
    "a stream of the input line tokens.  Tokens are sequences separated by whitespace; whitespace can be 
        included in a token by double quoting the arg.  (quotes can be imbedded by doubling, as with Smalltalk strings;
        the returned token has delimiting quotes removed and internal quotes undoubled. "

    | cstrm <CharInputStream> |
    cstrm := self commandLine readStream.
    self skipSpacesIn: cstrm.
    ^CustomInputStream[Str] new
            nextBlock: [    self parseArgFrom: cstrm ];
            atEndBlock: [ cstrm atEnd ].! !

"May 3, 2010 -> 15:34:18"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'command line' !
getArguments ^<OrdCltn[Str]>

    ^ {{ primitiveCommandLineArgs }} asOrderedCollection
    	collect: [:bytes| bytes asString]! !

"May 3, 2010 -> 15:34:18"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'command line' !
getCommandLine
    | stream |
    stream := CharacterReadWriteStream on: ''.
    self getArguments do: [:arg| stream nextPutAll: arg; space].
    stream isEmpty ifTrue: [^''].
    ^stream copyFrom: 1 to: stream size - 1! !

"May 3, 2010 -> 15:34:18"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'constants' !
multipleMatchWildcardCharacter ^<Character>

    ^$*! !

"May 3, 2010 -> 15:34:19"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'constants' !
singleMatchWildcardCharacter ^<Character>

    ^$?! !

"May 3, 2010 -> 15:34:19"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'constants' !
wordSize ^<Int>
    ^4! !

"May 3, 2010 -> 15:34:19"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'environment' !
environmentVariableAt: key <Str> ifAbsent: blk <[^X def]> ^ <Str | X>

    | cKey <CString> cValue <CString> |
    cKey := CString for: key.
    [cValue := {{<libc CString getenv> key: cKey}}.
    ^cValue isNull
    	ifTrue: [blk value]
    	ifFalse: [cValue asString]]
    	ensure: [cKey free]! !

"May 3, 2010 -> 15:34:19"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'initialization' !
initialize

    self DLLInitialize! !

"May 3, 2010 -> 15:34:19"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'os specific' !
currentThreadId
	"^ 0"
	^ {{ primitiveCurrentThreadId }}! !

"May 3, 2010 -> 15:34:19"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'os streams' !
errorStream ^<CharOutputStream>

    ErrorStream isNil
        ifTrue: [   ErrorStream := TempTranscript new ].
    ^ErrorStream! !

"May 3, 2010 -> 15:34:19"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'platform classes' !
pathClass ^<FilePath class>

    ^UnixFilePath! !

"May 3, 2010 -> 15:34:19"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'platform classes' !
patternClass ^<FilePattern class>

    ^UnixFilePattern! !

"May 3, 2010 -> 15:34:19"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'private' !
parseArgFrom: strm <CharInputStream>  ^<Str>

    ^strm peek = $"
        ifTrue: [       strm next.
                        strm upTo: $"   ]
        ifFalse: [  strm upTo: Character space ]! !

"May 3, 2010 -> 15:34:19"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'private' !
skipSpacesIn: strm <CharInputStream>

    [ strm atEnd not and: [ strm peekFor: Character space] ] whileTrue.
! !

"May 3, 2010 -> 15:34:19"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'private-clipboard access' !
closeClipboard

    {{<user ExternalProxy CloseClipboard> call}}! !

"May 3, 2010 -> 15:34:19"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'private-clipboard access' !
emptyClipboard

    {{<user ExternalProxy EmptyClipboard> call}} asBoolean
        ifFalse: [ Win32 handleError ].
! !

"May 3, 2010 -> 15:34:19"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'private-clipboard access' !
openClipboard

    {{<user ExternalProxy OpenClipboard> hnd: Win32 NULL}} asBoolean
        ifFalse: [ Win32 handleError ].
! !

"May 3, 2010 -> 15:34:19"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'testing' !
usesCrLfConvention ^<Boolean>

    ^false! !

"May 3, 2010 -> 15:34:19"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t tm |
	t := TimeT new allocate.
	[{{<libc ExternalProxy time> struct: t}} isAllOnes
		ifTrue: [self error: 'Invalid time'].
	tm := {{<libc TM gmtime>
					struct: t}}.
	^tm asSYSTEMTIME] ensure: [t free]
! !

"May 3, 2010 -> 15:34:29"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"May 3, 2010 -> 15:34:29"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"May 3, 2010 -> 15:34:29"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"May 3, 2010 -> 15:34:30"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"May 3, 2010 -> 15:34:30"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"May 3, 2010 -> 15:34:30"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"May 3, 2010 -> 15:34:30"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"May 3, 2010 -> 15:34:30"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"May 3, 2010 -> 15:34:30"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"May 3, 2010 -> 15:34:30"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"May 3, 2010 -> 15:34:30"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"May 3, 2010 -> 15:34:30"!

(Delta mirrorFor: #Win32Platform)
comment: 
'The class side holds platform dependent constants and utilities.  Is also used
to get command line args, and other things like that.

Keywords: %machdep  %User

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.4 $
'!


"May 3, 2010 -> 15:34:30"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLInitialize
    DLLDict := Dictionary new.
    {{primitiveDLLSetupLookup: self selector: #DLLLookup:in: ifFail: [:err | self error: err]}}! !

"May 3, 2010 -> 15:34:30"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLLibrary: name
    ^DLLDict at: name ifAbsent: [
        DLLDict at: name put: (self DLLLoad: name)
    ]! !

"May 3, 2010 -> 15:34:30"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLLoad2: name

	|block|
	block := [:lib| ^lib].
    self tryDLLLoad: name ifSuccess: block.
    self tryDLLLoad: (name, '.dll') asSymbol ifSuccess: block.
    self tryDLLLoad: (name, '32.dll') asSymbol ifSuccess: block.
    self error: 'Cannot find library ', name! !

"May 3, 2010 -> 15:34:30"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLLoad: name
    | n |
    n := (self DLLMapName: name) asSymbol.
    ^self tryDLLLoad: n ifFail: [ :err | self error: err]! !

"May 3, 2010 -> 15:34:30"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLLookup: name <Str> in: library <Str>
    "Convert library into proxy"
    | p r |
    p := self DLLLibrary: library.
    r := ExternalProxy new.
    {{primitiveDLLLookup: name asSymbol in: p result: r ifFail: [:err | self error: err]}}.
    ^r! !

"May 3, 2010 -> 15:34:30"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLMapName: name <Str> ^<Str>
    name asLowercase = 'user'       ifTrue: [^'USER32.DLL'].
    name asLowercase = 'gdi'            ifTrue: [^'GDI32.DLL'].
    name asLowercase = 'kernel'    ifTrue: [^'KERNEL32.DLL'].
    name asLowercase = 'comdlg'     ifTrue: [^'COMDLG32.DLL'].
    "self error: 'Mapping ', name, ' not found'"
    ^name! !

"May 3, 2010 -> 15:34:30"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'Dynamic Linked Libraries' !
tryDLLLoad: name <Str> ifFail: block <[X]> ^ <ExternalProxy>

	| r |
    r := ExternalProxy new.
    ^{{primitiveDLLLoad: name
    		result: r 
    		ifFail: [:err | block value: err]}}! !

"May 3, 2010 -> 15:34:30"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'Dynamic Linked Libraries' !
tryDLLLoad: name <Str> ifSuccess: block <[X]>

	| r |
    r := self tryDLLLoad: name ifFail: [:err| ^self].
    block value: r! !

"May 3, 2010 -> 15:34:30"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'clipboard access' !
clipboardText: str <Str>

    self openClipboard.
    [   | glob <HGLOBAL> strm <ReadWriteStream[Character]> xstr <Str> |
        self emptyClipboard.

        "transform string into a form with lfs inserted"
        strm := (String new: str size) readWriteStream.
        str do:
            [ :c <Character> |
                strm put: c.
                c = Character cr
                    ifTrue: [ strm put: Character lf ].
            ].
        xstr := String withAll: strm contentsWritten.

        glob := HGLOBAL new
                        allocate: xstr size + 1
                        attributes: (Win32 GMEM_MOVEABLE
                                            externalBitOr: Win32 GMEM_DDESHARE).
        glob withPointer: CString new
                do: [ :cs <CString> |
                            cs value: xstr   ].

        {{<user ExternalProxy SetClipboardData>
                format: Win32 CF_TEXT
                data: glob
        }} isNull
            ifTrue: [ Win32 handleError ].
    ] ensure:
        [ self closeClipboard ]! !

"May 3, 2010 -> 15:34:30"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'clipboard access' !
clipboardTextIfAbsent: blk <[^X def]> ^<Str | X>

    self openClipboard.
    [   | glob <HGLOBAL> strm <CharWriteStream> |

        {{<user ExternalProxy IsClipboardFormatAvailable> format: Win32 CF_TEXT}} asBoolean
            ifFalse: [ ^blk value ].
        glob := {{<user HGLOBAL GetClipboardData> format: Win32 CF_TEXT}}.
        glob isNull
            ifTrue: [ Win32 handleError ].
        strm := (String new: 100) writeStream.
        glob withPointer: CString new
                do: [ :cs <CString> |
                            cs asString do:
                                [ :c <Character> |
                                    c = Character lf
                                        ifFalse: [ strm put: c ]
                                ].
                            ^strm contentsWritten
                      ].
    ] ensure:
        [ self closeClipboard ]! !

"May 3, 2010 -> 15:34:30"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'command line' !
commandLine ^<Str>
    | p size result |
    p := {{<kernel ExternalProxy GetCommandLineA>getCommandLine}}.
    size := 0.
    [(p byteAt: size) == 0] whileFalse: [ size := size + 1 ].
    result := String new: size.
    1 to: size do: [:index |
       result at: index put: (Character value: (p byteAt: index - 1))
    ].
    ^result! !

"May 3, 2010 -> 15:34:30"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'command line' !
commandLineTokens ^<InputStream[Str]>
    "a stream of the input line tokens.  Tokens are sequences separated by whitespace; whitespace can be 
        included in a token by double quoting the arg.  (quotes can be imbedded by doubling, as with Smalltalk strings;
        the returned token has delimiting quotes removed and internal quotes undoubled. "

    | cstrm <CharInputStream> |
    cstrm := self commandLine readStream.
    self skipSpacesIn: cstrm.
    ^CustomInputStream[Str] new
            nextBlock: [    self parseArgFrom: cstrm ];
            atEndBlock: [ cstrm atEnd ].! !

"May 3, 2010 -> 15:34:30"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'command line' !
getArguments ^<OrdCltn[Str]>

    | line <Str> args <VarOrdCltn[Str]> strm <CharInputStream> |
    line := self getCommandLine.
    args := OrderedCollection[Str] new.
    strm := line readStream.

    [   "skip whitespace"
        [ strm atEnd not and: [ strm peekFor: Character space] ] whileTrue.
        strm atEnd ] whileFalse: [
            args addLast: (self parseArgFrom: strm).        ].
    ^args! !

"May 3, 2010 -> 15:34:30"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'command line' !
getCommandLine
    | p size result |
    p := {{<kernel ExternalProxy GetCommandLineA>getCommandLine}}.
    size := 0.
    [(p byteAt: size) == 0] whileFalse: [ size := size + 1 ].
    result := String new: size.
    1 to: size do: [:index |
       result at: index put: (Character value: (p byteAt: index - 1))
    ].
    ^result! !

"May 3, 2010 -> 15:34:30"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'constants' !
multipleMatchWildcardCharacter ^<Character>

    ^$*! !

"May 3, 2010 -> 15:34:30"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'constants' !
singleMatchWildcardCharacter ^<Character>

    ^$?! !

"May 3, 2010 -> 15:34:30"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'constants' !
wordSize ^<Int>
    ^4! !

"May 3, 2010 -> 15:34:30"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'environment' !
environmentVariableAt: key <Str> ifAbsent: blk <[^X def]> ^ <Str | X>

    | cKey <CString> cValue <CString> size <Int> cSize <ExternalProxy> result <Str> done <Boolean> found <Boolean> |
    size := 1024.
    cKey := CString for: key.
    done := false.
    [ done ] whileFalse: [
        cValue := CString for: (String new: size).
        cSize := {{<kernel ExternalProxy GetEnvironmentVariableA> key: cKey buffer: cValue bufSize: size}}.
        cSize asSmallInteger > size
            ifTrue: [   cValue free.                                                    "Buffer size too small for value of variable"
                            size := cSize asSmallInteger ]
            ifFalse: [  done := true.                                                   "Buffer size ok, check if variable was found"
                            (found := cSize asSmallInteger ~= 0)
                                ifTrue: [ result := cValue asString ] ] ].
    cKey free. 
    cValue free.
    ^found
        ifTrue: [ result ]
        ifFalse: blk ! !

"May 3, 2010 -> 15:34:30"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'initialization' !
initialize

    self DLLInitialize! !

"May 3, 2010 -> 15:34:30"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'os specific' !
currentThreadId

	^ {{ primitiveCurrentThreadId }}! !

"May 3, 2010 -> 15:34:30"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'os streams' !
errorStream ^<CharOutputStream>

    ErrorStream isNil
        ifTrue: [   ErrorStream := TempTranscript new ].
    ^ErrorStream! !

"May 3, 2010 -> 15:34:30"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'platform classes' !
pathClass ^<FilePath class>

    ^Win32FilePath! !

"May 3, 2010 -> 15:34:30"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'platform classes' !
patternClass ^<FilePattern class>

    ^Win32FilePattern! !

"May 3, 2010 -> 15:34:30"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'private' !
parseArgFrom: strm <CharInputStream>  ^<Str>
    "Parse an argument token from the strm.  Leading whitespace is assumed to have been removed already.
      Any whitespace following the token is consumed."

    | arg <Str> |
    (strm peekFor: $")
        ifTrue: [       | c <Character> buf <CharWriteStream> |
                        buf := String new writeStream.
                        [   c := strm next.
                            c ~= $" or: [ (strm peekIfAbsent: [ self skipSpacesIn: strm.  ^buf contentsWritten ]) = $" ]
                        ] whileTrue: 
                            [   c = $" ifTrue: [ strm next ].
                                buf put: c ].
                        arg := buf contentsWritten  ]
        ifFalse: [  arg := strm upTo: Character space ].
    self skipSpacesIn: strm.
    ^arg! !

"May 3, 2010 -> 15:34:30"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'private' !
skipSpacesIn: strm <CharInputStream>

    [ strm atEnd not and: [ strm peekFor: Character space] ] whileTrue.
! !

"May 3, 2010 -> 15:34:30"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'private-clipboard access' !
closeClipboard

    {{<user ExternalProxy CloseClipboard> call}}! !

"May 3, 2010 -> 15:34:30"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'private-clipboard access' !
emptyClipboard

    {{<user ExternalProxy EmptyClipboard> call}} asBoolean
        ifFalse: [ Win32 handleError ].
! !

"May 3, 2010 -> 15:34:30"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'private-clipboard access' !
openClipboard

    {{<user ExternalProxy OpenClipboard> hnd: Win32 NULL}} asBoolean
        ifFalse: [ Win32 handleError ].
! !

"May 3, 2010 -> 15:34:30"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'testing' !
usesCrLfConvention ^<Boolean>

    ^true! !

"May 3, 2010 -> 15:34:30"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t <SYSTEMTIME> |
	t := SYSTEMTIME new allocate.
	{{<kernel ExternalProxy GetLocalTime> struct: t}}.
	^t! !

"May 3, 2010 -> 15:34:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: '') classVariables: 'GCMallocedAliens LoadedLibraries') !


"May 3, 2010 -> 15:34:38"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: '') classVariables: 'GCMallocedAliens LoadedLibraries') !


"May 3, 2010 -> 15:34:39"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: '') classVariables: 'GCMallocedAliens LoadedLibraries') !


"May 3, 2010 -> 15:34:39"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: '') classVariables: 'GCMallocedAliens LoadedLibraries') !


"May 3, 2010 -> 15:34:39"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: '') classVariables: 'GCMallocedAliens LoadedLibraries') !


"May 3, 2010 -> 15:34:39"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: '') classVariables: 'GCMallocedAliens LoadedLibraries') !


"May 3, 2010 -> 15:34:39"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: '') classVariables: 'GCMallocedAliens LoadedLibraries') !


"May 3, 2010 -> 15:34:39"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: '') classVariables: 'GCMallocedAliens LoadedLibraries') !


"May 3, 2010 -> 15:34:39"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: '') classVariables: 'GCMallocedAliens LoadedLibraries') !


"May 3, 2010 -> 15:34:39"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: '') classVariables: 'GCMallocedAliens LoadedLibraries') !


"May 3, 2010 -> 15:34:39"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: '') classVariables: 'GCMallocedAliens LoadedLibraries') !


"May 3, 2010 -> 15:34:39"!

(Delta mirrorFor: #Alien)
comment: 
''!


"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'class initialization' !
initialize

	LoadedLibraries isNil ifTrue: 
		[LoadedLibraries := Dictionary new].
	GCMallocedAliens isNil ifTrue:
		[GCMallocedAliens := AlienWeakTable newForOwner: self]! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
atAddress: pointer <Integer> ^<X>

	^(self primitiveNew: 8)
		size: self dataSize negated;
		addressField: pointer;
		yourself! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
atAddress: pointer <Integer> dataSize: dataSize <Integer> ^<X>

	^(self primitiveNew: 8)
		size: dataSize negated;
		addressField: pointer;
		yourself! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
autoFreeAfter: action <[X, ^ Y]>
	"Evaluate the action, which must be a 1-argument block.
	 The argument passed to the action is a block the action
	 can use to register Aliens created inside the action.
	 Such aliens will be freed as soon as the action completes.
	 Return the value returned from the action. See usage
	 example at the bottom of the method. "
	
	| toFree |
	toFree := OrderedCollection new.
	^[action value: [:alien | toFree add: alien]]
		ensure: [toFree do: [:each | each free]]
		
"
	Alien autoFreeAfter:
		[:autoFree | | foo bar |
		foo := autoFree value: (Alien newCString: 'foo').
		bar := autoFree value: (Alien newCString: 'bar').
		...]
"! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
dataSize

	^self subclassResponsibility! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
ensureLoaded: libraryName

	^self loadedLibraries
		at: libraryName
		ifAbsentPut: [(Alien new: 4)
								unsignedLongAt: 1 put: (self primLoadLibrary: libraryName);
								yourself]! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
forPointer: pointer <Integer> ^<X>

	^(self primitiveNew: 8)
		size: 0;
		addressField: pointer;
		yourself! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
new

	^self new: self dataSize! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
new: size <Integer> ^ <X>

	^(self primitiveNew: size + 4)
		size: size;
		initialize! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
newC

	^self newC: self dataSize! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
newC: size <Integer> ^ <X>

	^(self primitiveNew: 8)
		size: size negated;
		addressField: (self Ccalloc: size);
		initialize! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
newCString: string <String> ^ <Alien>

	^(Alien rawNewC: string size + 1)
		replaceFrom: 1
		to: string size
		with: string
		startingAt: 1;
		unsignedByteAt: string size + 1 put: 0;
		yourself! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
newForCallbackArgs

	^(self new: 8)
		size: self dataSize negated;
		yourself! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
newGC

	^self newGC: self dataSize! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
newGC: size <Integer> ^<X>

	| alien address |
	alien := self primitiveNew: 8.
	alien size: size negated.
	address := self Ccalloc: size.
	self gcMallocedAliens add: alien.
	^alien
		addressField: address;
		initialize
		! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
rawNewC: size <Integer> ^ <X>

	^(self primitiveNew: 8)
		size: size negated;
		addressField: (self Cmalloc: size);
		initialize! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'libraries' !
lookup: symbolName <String> inLibrary: libraryName <String> ^ <Alien>

	^self forPointer: ((Alien ensureLoaded: libraryName)
										primFindSymbol: symbolName)! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'libraries' !
lookupOrNil: symbolName <String> inLibrary: libraryName <String> ^ <Alien>

	^[self lookup: symbolName inLibrary: libraryName]
			on: NotFoundError
			do: [:err| nil]! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'libraries' !
primLoadLibrary: libraryName

	^(Platform DLLLoad2: libraryName) asInteger! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'private - accessing' !
gcMallocedAliens ^<WeakSet>

	GCMallocedAliens isNil
		ifTrue: [GCMallocedAliens := WeakSet new.
					GCMallocedAliens addWeakDependent: (
						BlockDependent updateBlock: [:aspect :alien | alien free])].
	^GCMallocedAliens! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'private - accessing' !
loadedLibraries

	LoadedLibraries isNil ifTrue: 
		[LoadedLibraries := Dictionary new].
	^LoadedLibraries! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'private - memory allocation' !
Ccalloc: size <Integer> ^ <Integer>

	^{{self primitiveAlienCalloc: size
			ifFail: [:err| self error: 'Failed to calloc alien: ', err]}}! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'private - memory allocation' !
Cmalloc: size <Integer> ^ <Integer>

	^{{self primitiveAlienMalloc: size
			ifFail: [:err| self error: 'Failed to malloc alien: ', err]}}! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
address ^<Integer>

	^self size <= 0
		ifTrue: [self addressField]
		ifFalse: [self error: 'One cannot take the address of direct Alien instances; they may move']! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
boolAt: index <Integer> ^<Boolean>

	^(self at: 1) ~~ 0! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
boolAt: index <Integer> put: value <Boolean> ^<Boolean>

	self at: 1 put: (value ifTrue: [1] ifFalse: [0]).
	^value! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
dataSize ^<Integer>

	^self size abs! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
doubleAt: index <Integer> ^<Float>

	^{{self primitiveAlienDoubleAt: index
				ifFail: [:err| self error: 'Unable to get double ', err] }}! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
doubleAt: index <Integer> put: double <Float> ^<Float>

	^{{self primitiveAlienDoubleAt: index
				put: double
				ifFail: [:err| self error: 'Unable to set double ', err] }}! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
floatAt: index <Integer> ^<Double>

	^{{self primitiveAlienFloatAt: index
				ifFail: [:err| self error: 'Unable to get float ', err] }}! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
floatAt: index <Integer> put: double <Float> ^<Float>

	^{{self primitiveAlienFloatAt: index
				put: double
				ifFail: [:err| self error: 'Unable to set float ', err] }}! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
pointer

	self isPointer ifTrue: [self error:  'One cannot take the address of pointer Alien instances; they may move, and are already pointers'].
	^self class forPointer: self address! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedByteAt: index <Integer> ^<Integer>

	^{{self primitiveAlienSignedByteAt: index
				ifFail: [:err| self error: 'Unable to get signed byte ', err] }}! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedByteAt: index <Integer> put: byte <Integer> ^<Integer>

	^{{self primitiveAlienSignedByteAt: index
				put: byte
				ifFail: [:err| self error: 'Unable to set signed byte ', err] }}! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedLongAt: index <Integer> ^<Integer>

	^{{self primitiveAlienSignedLongAt: index
				ifFail: [:err| self error: 'Unable to get signed long ', err] }}! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedLongAt: index <Integer> put: long <Integer>^<Integer>

	^{{self primitiveAlienSignedLongAt: index
				put: long
				ifFail: [:err| self error: 'Unable to get signed long ', err] }}! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> ^<Integer>

	^{{self primitiveAlienSignedShortAt: index
				ifFail: [:err| self error: 'Unable to get signed short ', err] }}! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> put: short <Integer> ^<Integer>

	^{{self primitiveAlienSignedShortAt: index
				put: short
				ifFail: [:err| self error: 'Unable to set signed short ', err] }}! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strcpy

	^self strcpyFrom: 1! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strcpyFrom: startIndex

	|string length offset|
	length := self strlenStartingAt: startIndex.
	string := String new: length.
	offset := startIndex - 1.
	1 to: length do: [:i|
		string at: i put: (Character value: (self unsignedByteAt: i + offset))].
	^string! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strcpyUTF8

	^self strcpyUTF8From: 1! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strcpyUTF8From: startIndex

	^self unimplemented! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strlen

	^self strlenStartingAt: 1! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strlenStartingAt: startIndex

	self dataSize == 0
		ifTrue: [^self rawStrlenStartingAt: startIndex].
	startIndex to: self dataSize do: [:i| (self unsignedByteAt: i) == 0
																ifTrue: [^ i - startIndex]].
	^self dataSize - startIndex + 1! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedByteAt: index <Integer> ^<Integer>

	^{{self primitiveAlienUnsignedByteAt: index
				ifFail: [:err| self error: 'Unable to get unsigned byte ', err] }}! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedByteAt: index <Integer> put: byte <Integer|Character> ^<Integer>

	|c|
	c := byte isCharacter
				ifTrue: [byte asciiValue]
				ifFalse: [byte].
	^{{self primitiveAlienUnsignedByteAt: index
				put: c
				ifFail: [:err| self error: 'Unable to set unsigned byte ', err] }}! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedLongAt: index <Integer> ^<Integer>

	^{{self primitiveAlienUnsignedLongAt: index
				ifFail: [:err| self error: 'Unable to get unsigned long ', err] }}! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedLongAt: index <Integer> put: long <Integer>^<Integer>

	^{{self primitiveAlienUnsignedLongAt: index
				put: long
				ifFail: [:err| self error: 'Unable to set unsigned long ', err] }}! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> ^<Integer>

	^{{self primitiveAlienUnsignedShortAt: index
				ifFail: [:err| self error: 'Unable to get unsigned short ', err] }}! !

"May 3, 2010 -> 15:34:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> put: short <Integer>^<Integer>

	^{{self primitiveAlienUnsignedShortAt: index
				put: short
				ifFail: [:err| self error: 'Unable to set unsigned short ', err] }}! !

"May 3, 2010 -> 15:34:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien>

	{{self primitiveAlienCallResult: result ifFail: [:err| self error: err]}}! !

"May 3, 2010 -> 15:34:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject> with: arg1 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			ifFail: [:err| self error: err]}}! !

"May 3, 2010 -> 15:34:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject> with: arg1 <Alien|SmallInteger> with: arg2 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			ifFail: [:err| self error: err]}}! !

"May 3, 2010 -> 15:34:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			with: arg3
			ifFail: [:err| self error: err]}}! !

"May 3, 2010 -> 15:34:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			with: arg3
			with: arg4
			ifFail: [:err| self error: err]}}! !

"May 3, 2010 -> 15:34:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			with: arg3
			with: arg4
			with: arg5
			ifFail: [:err| self error: err]}}! !

"May 3, 2010 -> 15:34:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			with: arg3
			with: arg4
			with: arg5
			with: arg6
			ifFail: [:err| self error: err]}}! !

"May 3, 2010 -> 15:34:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			with: arg3
			with: arg4
			with: arg5
			with: arg6
			with: arg7
			ifFail: [:err| self error: err]}}! !

"May 3, 2010 -> 15:34:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger>
with: arg8 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: { arg1. arg2. arg3. arg4. arg5. arg6. arg7. arg8 }
			ifFail: [:err| self error: err]}}! !

"May 3, 2010 -> 15:34:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger>
with: arg8 <Alien|SmallInteger>
with: arg9 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: { arg1. arg2. arg3. arg4. arg5. arg6. arg7. arg8. arg9 }
			ifFail: [:err| self error: err]}}! !

"May 3, 2010 -> 15:34:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger>
with: arg8 <Alien|SmallInteger>
with: arg9 <Alien|SmallInteger>
with: arg10 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: { arg1. arg2. arg3. arg4. arg5. arg6. arg7. arg8. arg9. arg10 }
			ifFail: [:err| self error: err]}}! !

"May 3, 2010 -> 15:34:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger>
with: arg8 <Alien|SmallInteger>
with: arg9 <Alien|SmallInteger>
with: arg10 <Alien|SmallInteger>
with: arg11 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: { arg1. arg2. arg3. arg4. arg5. arg6. arg7. arg8. arg9. arg10. arg11 }
			ifFail: [:err| self error: err]}}! !

"May 3, 2010 -> 15:34:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger>
with: arg8 <Alien|SmallInteger>
with: arg9 <Alien|SmallInteger>
with: arg10 <Alien|SmallInteger>
with: arg11 <Alien|SmallInteger>
with: arg12 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: { arg1. arg2. arg3. arg4. arg5. arg6. arg7. arg8. arg9. arg10. arg11. arg12 }
			ifFail: [:err| self error: err]}}! !

"May 3, 2010 -> 15:34:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
withArguments: arguments <Array[Alien|SmallInteger]> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: arguments
			ifFail: [:err| self error: err]}}! !

"May 3, 2010 -> 15:34:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'converting' !
asAlien

	^self! !

"May 3, 2010 -> 15:34:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'converting' !
asExternalProxy ^<ExternalProxy>

	^ExternalProxy
		forHigh: (self unsignedShortAt: 3)
		low: (self unsignedShortAt: 1)! !

"May 3, 2010 -> 15:34:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'converting' !
asSignedByte

	^self signedByteAt: 1! !

"May 3, 2010 -> 15:34:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'converting' !
asSignedLong

	^self signedLongAt: 1! !

"May 3, 2010 -> 15:34:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'converting' !
asSignedShort

	^self signedShortAt: 1! !

"May 3, 2010 -> 15:34:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'converting' !
asUnsignedByte

	^self unsignedByteAt: 1! !

"May 3, 2010 -> 15:34:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'converting' !
asUnsignedLong

	^self unsignedLongAt: 1! !

"May 3, 2010 -> 15:34:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'converting' !
asUnsignedShort

	^self unsignedShortAt: 1! !

"May 3, 2010 -> 15:34:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'instance initialization' !
initialize
	"Subclasses may override to perform specific initialization"! !

"May 3, 2010 -> 15:34:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'memory management' !
free

	{{primitiveAlienFree: self addressField
		ifFail: [:err| self error: 'Could not free alien: ', err]}}.
	self addressField: 0! !

"May 3, 2010 -> 15:34:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'memory management' !
freeAfter: aBlock <[Alien]>

	[aBlock value: self]
		ensure: [self free]! !

"May 3, 2010 -> 15:34:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
addressField ^<Integer>

	^{{ self primitiveAlienAddressIfFail: [:err| self error: 'failed to get address of alien ', err] }}! !

"May 3, 2010 -> 15:34:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
addressField: anInteger <Integer>

	^{{ self primitiveAlienAddress: anInteger
					ifFail: [:err| self error: 'failed to set address of alien ', err] }}! !

"May 3, 2010 -> 15:34:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
at: index <Integer> ^ <SmallInteger>

	^self unsignedByteAt: index! !

"May 3, 2010 -> 15:34:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
at: index <Integer> put: byte <SmallInteger> ^ <SmallInteger>

	^self unsignedByteAt: index put: byte! !

"May 3, 2010 -> 15:34:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
primFindSymbol: symbolName <String> ^ <Integer>

	|result library|
	result := ExternalProxy new.
	library := self asExternalProxy.
	{{primitiveDLLLookup: symbolName asSymbol
			in: library
			result: result
			ifFail: [:err | err == #NotFound
									ifTrue: [NotFoundError signal]
									ifFalse: [self error: err]]}}.
	^result asInteger	! !

"May 3, 2010 -> 15:34:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
rawStrlenStartingAt: startIndex

	|index|
	index := startIndex.
	[(self unsignedByteAt: index) == 0]
		whileFalse: [index := index + 1].
	^index - startIndex! !

"May 3, 2010 -> 15:34:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
signedFourByteLimit

	^self smallIntLimit * 4! !

"May 3, 2010 -> 15:34:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
size ^<Integer>

	^{{self primitiveAlienSizeIfFail: [:err| self error: 'failed to get alien size: ', err] }}! !

"May 3, 2010 -> 15:34:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
size: anInteger <Integer>

	{{self primitiveAlienSize: anInteger
				ifFail: [:err| self error: 'failed to set alien size: ', err] }}! !

"May 3, 2010 -> 15:34:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
smallIntLimit

	^SmallInteger maxVal + 1! !

"May 3, 2010 -> 15:34:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
strlenThroughPointerAt: index

	^(Alien forPointer: (self unsignedLongAt: index))
		rawStrlenStartingAt: 1! !

"May 3, 2010 -> 15:34:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
unsignedFourByteLimit

	^self smallIntLimit * 8! !

"May 3, 2010 -> 15:34:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'testing' !
isPointer

	^self size == 0! !

"May 3, 2010 -> 15:34:48"!

"System saved" !
"May 3, 2010 -> 15:52:45"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
tryDLLLoad: name <Str> ifSuccess: block <[X]>

	| r |
    r := self tryDLLLoad: name ifFail: [:err| Transcript show: err; cr. ^self].
    block value: r! !

"May 3, 2010 -> 15:52:53"!

"System saved" !
"May 3, 2010 -> 16:1:53"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
tryDLLLoad: name <Str> ifSuccess: block <[X]>

	| r |
    r := self tryDLLLoad: name ifFail: [:err| ^self].
    block value: r! !

"May 3, 2010 -> 16:2:5"!

"System saved" !
"May 3, 2010 -> 16:14:50"!

! (Delta mirrorFor: #MacOSXPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLLoad2: name

	|block|
	block := [:lib| ^lib].
    self tryDLLLoad: name asSymbol ifSuccess: block.
    self tryDLLLoad: (name, '.dylib') asSymbol ifSuccess: block.
    self error: 'Cannot find library ', name! !

"May 3, 2010 -> 16:15:1"!

"System saved" !
"May 3, 2010 -> 17:0:47"!

! (Delta mirrorFor: #MainProcess) methodsFor: 'private' !
runNext

	actions next
		"on: Error
		do: [:ex| [ex signal] fork]".
	^true! !

"May 3, 2010 -> 17:0:55"!

"System saved" !
"May 3, 2010 -> 19:2:24"!

! (Delta mirrorFor: #MainProcess) methodsFor: 'private' !
runNext

	actions next value
		"on: Error
		do: [:ex| [ex signal] fork]".
	^true! !

"May 3, 2010 -> 19:2:31"!

"System saved" !
"May 3, 2010 -> 19:19:4"!

! (Delta mirrorFor: #ObjectiveCMethod) methodsFor: 'accessing' !
implementation
	^Alien forPointer: (self unsignedLongAt: 9)! !

"May 3, 2010 -> 19:19:4"!

! (Delta mirrorFor: #ObjectiveCMethod) methodsFor: 'accessing' !
methodTypes
	^Alien forPointer: (self unsignedLongAt: 5)! !

"May 3, 2010 -> 19:19:4"!

! (Delta mirrorFor: #ObjectiveCMethod) methodsFor: 'accessing' !
methodTypesString
	^(Alien forPointer: (self unsignedLongAt: 5)) strcpy! !

"May 3, 2010 -> 19:19:4"!

! (Delta mirrorFor: #ObjectiveCMethod) methodsFor: 'accessing' !
rawSelector
	^self unsignedLongAt: 1! !

"May 3, 2010 -> 19:19:4"!

! (Delta mirrorFor: #ObjectiveCMethod) methodsFor: 'accessing' !
selector
	^ObjectiveCAlien forPointer: (self unsignedLongAt: 1)! !

"May 3, 2010 -> 19:19:4"!

! (Delta mirrorFor: #ObjectiveCMethod) methodsFor: 'instance initalization' !
selector: selector "<ObjectiveCAlien>" methodTypes: string "<char * Alien>" implementation: functionPointer "<id (*IMP)(id, SEL, ...) Alien> ^<self>"
	self unsignedLongAt: 1 put: (selector unsignedLongAt: 1).
	self unsignedLongAt: 5 put: string address.
	self unsignedLongAt: 9 put: (functionPointer unsignedLongAt: 1)! !

"May 3, 2010 -> 19:19:4"!

! (Delta mirrorFor: #ObjectiveCMethod) classSide methodsFor: 'instance creation' !
dataSize
	"typedef struct objc_method *Method;

	struct objc_method {
	    SEL method_name;
	    char *method_types;
	    IMP method_imp;
	};"

	^12! !

"May 3, 2010 -> 19:19:33"!

"System saved" !
"May 3, 2010 -> 21:1:21"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien>

	{{self primitiveAlienCallResult: result ifFail: [:err| self error: err]}}.
	^result! !

"May 3, 2010 -> 21:1:27"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject> with: arg1 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			ifFail: [:err| self error: err]}}.
	^result! !

"May 3, 2010 -> 21:1:32"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject> with: arg1 <Alien|SmallInteger> with: arg2 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			ifFail: [:err| self error: err]}}.
	^result! !

"May 3, 2010 -> 21:1:39"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			with: arg3
			ifFail: [:err| self error: err]}}.
	^result! !

"May 3, 2010 -> 21:1:49"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			with: arg3
			with: arg4
			ifFail: [:err| self error: err]}}.
	^result! !

"May 3, 2010 -> 21:1:58"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			with: arg3
			with: arg4
			with: arg5
			ifFail: [:err| self error: err]}}.
	^result! !

"May 3, 2010 -> 21:2:4"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			with: arg3
			with: arg4
			with: arg5
			with: arg6
			ifFail: [:err| self error: err]}}.
	^result! !

"May 3, 2010 -> 21:2:15"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1
			with: arg2
			with: arg3
			with: arg4
			with: arg5
			with: arg6
			with: arg7
			ifFail: [:err| self error: err]}}.
	^result! !

"May 3, 2010 -> 21:2:25"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger>
with: arg8 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: { arg1. arg2. arg3. arg4. arg5. arg6. arg7. arg8 }
			ifFail: [:err| self error: err]}}.
	^result! !

"May 3, 2010 -> 21:2:32"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger>
with: arg8 <Alien|SmallInteger>
with: arg9 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: { arg1. arg2. arg3. arg4. arg5. arg6. arg7. arg8. arg9 }
			ifFail: [:err| self error: err]}}.
	^result! !

"May 3, 2010 -> 21:2:40"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger>
with: arg8 <Alien|SmallInteger>
with: arg9 <Alien|SmallInteger>
with: arg10 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: { arg1. arg2. arg3. arg4. arg5. arg6. arg7. arg8. arg9. arg10 }
			ifFail: [:err| self error: err]}}.
	^result! !

"May 3, 2010 -> 21:2:47"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger>
with: arg8 <Alien|SmallInteger>
with: arg9 <Alien|SmallInteger>
with: arg10 <Alien|SmallInteger>
with: arg11 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: { arg1. arg2. arg3. arg4. arg5. arg6. arg7. arg8. arg9. arg10. arg11 }
			ifFail: [:err| self error: err]}}.
	^result! !

"May 3, 2010 -> 21:2:55"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger>
with: arg8 <Alien|SmallInteger>
with: arg9 <Alien|SmallInteger>
with: arg10 <Alien|SmallInteger>
with: arg11 <Alien|SmallInteger>
with: arg12 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: { arg1. arg2. arg3. arg4. arg5. arg6. arg7. arg8. arg9. arg10. arg11. arg12 }
			ifFail: [:err| self error: err]}}.
	^result! !

"May 3, 2010 -> 21:3:2"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
withArguments: arguments <Array[Alien|SmallInteger]> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: arguments
			ifFail: [:err| self error: err]}}.
	^result! !

"May 3, 2010 -> 21:3:19"!

"System saved" !
"May 3, 2010 -> 21:26:30"!

! (Delta mirrorFor: #ObjectiveCClassAlien) methodsFor: 'objective-c runtime' !
objectiveCMethodForSelectorAlien: selectorAlien
	| pointer |
	pointer := ClassGetClassMethodAlien
						primFFICallResult: (Alien new: 4)
						with: self
						with: selectorAlien.
	^(pointer := pointer unsignedLongAt: 1) ~= 0 ifTrue:
		[ObjectiveCMethod atAddress: pointer]! !

"May 3, 2010 -> 21:26:44"!

"System saved" !
"May 4, 2010 -> 1:52:36"!

! (Delta mirrorFor: #Array) methodsFor: 'copying' !
, collection

	^self withAll: collection! !

"May 4, 2010 -> 1:53:3"!

! (Delta mirrorFor: #Array) methodsFor: 'copying' !
, collection <Collection>

	^self withAll: collection! !

"May 4, 2010 -> 1:53:28"!

"System saved" !
"May 4, 2010 -> 21:6:38"!

! (Delta mirrorFor: #ObjectiveCMethod) methodsFor: 'accessing' !
rawSelector
	^Alien forPointer: (self unsignedLongAt: 1)! !

"May 4, 2010 -> 21:6:50"!

"System saved" !
"May 9, 2010 -> 14:16:24"!

Delta define: #ObjectiveCAlien as: (
(Class subclassOf: 'Alien' instanceVariables: '') classVariables: 'ClassGetClassMethodAlien
ClassGetInstanceMethodAlien
ClassSelectorAlien
EightByteParameterTypes
FourByteParameterTypes
ObjCLookUpClassAlien
ObjCMsgSendAlien
MethodTypeMap
MethodTypeResultMap
MethodGetReturnType
SelectorTable
SelGetNameAlien
SelRegisterNameAlien
TypeQualifiers
TypeQualifierCodes') !


"May 9, 2010 -> 14:17:21"!

! (Delta mirrorFor: #ObjectiveCAlien) classSide methodsFor: 'class initialization' !
initializeSelectors

	SelectorTable := Dictionary new.
	ClassGetClassMethodAlien := self lookup: 'class_getClassMethod' inLibrary: '/usr/lib/libobjc.dylib'.
	ClassGetInstanceMethodAlien := self lookup: 'class_getInstanceMethod' inLibrary: '/usr/lib/libobjc.dylib'.
	ObjCLookUpClassAlien := self lookup: 'objc_lookUpClass' inLibrary: '/usr/lib/libobjc.dylib'.
	ObjCMsgSendAlien := self lookup: 'objc_msgSend' inLibrary: '/usr/lib/libobjc.dylib'.
	MethodGetReturnType := self lookup: 'method_getReturnType' inLibrary: '/usr/lib/libobjc.dylib'.
	SelRegisterNameAlien := self lookup: 'sel_registerName' inLibrary: '/usr/lib/libobjc.dylib'.
	SelGetNameAlien := self lookup: 'sel_getName' inLibrary: '/usr/lib/libobjc.dylib'.
	ClassSelectorAlien := self asObjectiveCSelector: #objectiveCclass! !

"May 9, 2010 -> 14:19:39"!

! (Delta mirrorFor: #ObjectiveCMethod) classSide methodsFor: 'initialization' !
initialize

	SystemInitializers addInitializer: self.
	! !

"May 9, 2010 -> 14:20:4"!

Delta define: #ObjectiveCMethod as: (
(Class subclassOf: 'Alien' instanceVariables: '') classVariables: 'MethodGetReturnType') !


"May 9, 2010 -> 14:20:23"!

! (Delta mirrorFor: #ObjectiveCMethod) classSide methodsFor: 'initialization' !
initialize

	SystemInitializers addInitializer: self.
	MethodGetReturnType := self lookup: 'method_getReturnType' inLibrary: '/usr/lib/libobjc.dylib'! !

"May 9, 2010 -> 14:23:15"!

! (Delta mirrorFor: #ObjectiveCMethod) methodsFor: 'accessing' !
returnType

	| returnType |
	returnType := Alien newC: 256.
	MethodGetReturnType
		primFFICallResult: nil
				with: self
				with: returnType pointer
				with: 256.
	^returnType! !

"May 9, 2010 -> 14:25:14"!

! (Delta mirrorFor: #ObjectiveCMethod) classSide methodsFor: 'initialization' !
initialize

	SystemInitializer addInitializer: self.
	MethodGetReturnType := self lookup: 'method_getReturnType' inLibrary: '/usr/lib/libobjc.dylib'! !

"May 9, 2010 -> 14:25:30"!

(Delta mirrorFor: #MethodGetReturnType) removeDefinitionIfFail: [] !


"May 9, 2010 -> 14:25:36"!

! (Delta mirrorFor: #ObjectiveCMethod) classSide methodsFor: 'initialization' !
initialize

	SystemInitializer addInitializer: self.
	MethodGetReturnType := self lookup: 'method_getReturnType' inLibrary: '/usr/lib/libobjc.dylib'! !

"May 9, 2010 -> 14:25:45"!

! (Delta mirrorFor: #ObjectiveCMethod) methodsFor: 'accessing' !
returnType

	| returnType |
	returnType := Alien newC: 256.
	MethodGetReturnType
		primFFICallResult: nil
				with: self
				with: returnType pointer
				with: 256.
	^returnType! !

"May 9, 2010 -> 14:26:6"!

(Delta mirrorFor: #SystemInitializers) removeDefinitionIfFail: [] !


"May 9, 2010 -> 14:26:39"!

(Delta mirrorFor: #ObjectCMethod) removeDefinitionIfFail: [] !


"May 9, 2010 -> 14:27:8"!

! (Delta mirrorFor: #ObjectiveCMethod) classSide methodsFor: 'initialization' !
initialize

	SystemInitializer addInitializer: self.
	Platform == MacOSXPlatform ifFalse: [^self].
	MethodGetReturnType := self lookup: 'method_getReturnType' inLibrary: '/usr/lib/libobjc.dylib'! !

"May 9, 2010 -> 14:28:4"!

! (Delta mirrorFor: #ObjectiveCAlien) classSide methodsFor: 'class initialization' !
initializeSelectors

	SelectorTable := Dictionary new.
	ClassGetClassMethodAlien := self lookup: 'class_getClassMethod' inLibrary: '/usr/lib/libobjc.dylib'.
	ClassGetInstanceMethodAlien := self lookup: 'class_getInstanceMethod' inLibrary: '/usr/lib/libobjc.dylib'.
	ObjCLookUpClassAlien := self lookup: 'objc_lookUpClass' inLibrary: '/usr/lib/libobjc.dylib'.
	ObjCMsgSendAlien := self lookup: 'objc_msgSend' inLibrary: '/usr/lib/libobjc.dylib'.
	SelRegisterNameAlien := self lookup: 'sel_registerName' inLibrary: '/usr/lib/libobjc.dylib'.
	SelGetNameAlien := self lookup: 'sel_getName' inLibrary: '/usr/lib/libobjc.dylib'.
	ClassSelectorAlien := self asObjectiveCSelector: #objectiveCclass! !

"May 9, 2010 -> 14:28:14"!

Delta define: #ObjectiveCAlien as: (
(Class subclassOf: 'Alien' instanceVariables: '') classVariables: 'ClassGetClassMethodAlien
ClassGetInstanceMethodAlien
ClassSelectorAlien
EightByteParameterTypes
FourByteParameterTypes
ObjCLookUpClassAlien
ObjCMsgSendAlien
MethodTypeMap
MethodTypeResultMap
SelectorTable
SelGetNameAlien
SelRegisterNameAlien
TypeQualifiers
TypeQualifierCodes') !


"May 9, 2010 -> 14:29:42"!

"System saved" !
"May 9, 2010 -> 14:58:21"!

! (Delta mirrorFor: #ObjectiveCMethod) methodsFor: 'accessing' !
returnType

	| returnType |
	returnType := Alien newC: 256.
	MethodGetReturnType
		primFFICallResult: nil
				with: self pointer
				with: returnType pointer
				with: 256.
	^returnType! !

"May 9, 2010 -> 14:58:35"!

"System saved" !
"May 9, 2010 -> 17:44:25"!

Delta define: #ObjectiveCMethod as: (
(Class subclassOf: 'Alien' instanceVariables: '') classVariables: 'MethodGetReturnType
NSMethodSignature') !


"May 9, 2010 -> 17:52:13"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'library class initialization' !
addInitializer: aClass after: predecessor

	|initializers|
	initializers := self initializers.
	(initializers includes: aClass)
		ifTrue: [(predecessor isNil or: [(initializers includes: predecessor) not])
							ifTrue: [^self].
						(initializers indexOf: predecessor) < (initializers indexOf: aClass)
							ifTrue: [^self]].
	initializers remove: aClass.
	predecessor isNil
		ifTrue: [initializers add: aClass]
		ifFalse: [initializers add: aClass after: predecessor]! !

"May 9, 2010 -> 17:56:0"!

! (Delta mirrorFor: #ObjectiveCMethod) classSide methodsFor: 'initialization' !
initialize

	SystemInitializer
		addInitializer: self
		after: ObjectiveCAlien.
	Platform == MacOSXPlatform ifFalse: [^self].
	MethodGetReturnType := self lookup: 'method_getReturnType' inLibrary: '/usr/lib/libobjc.dylib'.
	NSMethodSignature := ObjectiveCClassAlien
          											lookup: 'NSMethodSignature'
            										inFramework: 'Foundation'! !

"May 9, 2010 -> 17:57:6"!

"System saved" !
"May 9, 2010 -> 19:13:12"!

! (Delta mirrorFor: #ObjectiveCMethod) methodsFor: 'accessing' !
signature ^<Alien>

	^NSMethodSignature signatureWithObjCTypes: self methodTypes pointer! !

"May 9, 2010 -> 19:14:5"!

! (Delta mirrorFor: #ObjectiveCMethod) methodsFor: 'accessing' !
returnType

	^self signature methodReturnType! !

"May 9, 2010 -> 19:14:12"!

"System saved" !
"May 9, 2010 -> 19:15:50"!

! (Delta mirrorFor: #ObjectiveCMethod) methodsFor: 'accessing' !
signature ^<Alien>

	^NSMethodSignature signatureWithObjCTypes: self methodTypes! !

"May 9, 2010 -> 19:15:58"!

"System saved" !
"May 9, 2010 -> 19:16:52"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
pointer

	self isPointer ifTrue: [^self].
	^self class forPointer: self address! !

"May 9, 2010 -> 19:17:2"!

"System saved" !
"May 11, 2010 -> 22:46:28"!

Delta define: #SimpleTypeHandler as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 11, 2010 -> 22:47:43"!

Delta define: #FixedSizeTypeHandler as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 11, 2010 -> 22:48:7"!

Delta define: #StructTypeHandler as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 11, 2010 -> 22:48:21"!

Delta define: #SimpleTypeHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'alienClass')) !


"May 11, 2010 -> 22:48:38"!

Delta define: #FixedSizeTypeHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'size')) !


"May 11, 2010 -> 22:49:22"!

! (Delta mirrorFor: #FixedSizeTypeHandler) classSide methodsFor: 'instance creation' !
size: size

	^(self new)
		initSize: size;
		yourself! !

"May 11, 2010 -> 22:49:59"!

! (Delta mirrorFor: #FixedSizeTypeHandler) methodsFor: 'initialization' !
initSize: newSize

	size := newSize! !

"May 11, 2010 -> 22:55:15"!

! (Delta mirrorFor: #FixedSizeTypeHandler) methodsFor: 'forwarding' !
send: method receiver: receiver arguments: arguments

	|result|
	result := Alien new: size.
	receiver
		primFFICallResult: result
		withArguments: {receiver. method rawSelector}, arguments.
	^result! !

"May 11, 2010 -> 22:56:58"!

Delta define: #FixedSizeTypeHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'size')) !


"May 11, 2010 -> 22:57:9"!

Delta define: #FixedSizeTypeHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'size
resultBlock')) !


"May 11, 2010 -> 22:57:31"!

! (Delta mirrorFor: #FixedSizeTypeHandler) methodsFor: 'initialization' !
initSize: newSize

	size := newSize.
	resultBlock := [:alien| alien]! !

"May 11, 2010 -> 22:57:55"!

! (Delta mirrorFor: #FixedSizeTypeHandler) methodsFor: 'initialization' !
initSize: newSize resultBlock: block

	size := newSize.
	resultBlock := block! !

"May 11, 2010 -> 22:58:18"!

! (Delta mirrorFor: #FixedSizeTypeHandler) methodsFor: 'initialization' !
initSize: newSize

	self initSize: newSize resultBlock: [:alien| alien]! !

"May 11, 2010 -> 22:58:39"!

! (Delta mirrorFor: #FixedSizeTypeHandler) methodsFor: 'forwarding' !
send: method receiver: receiver arguments: arguments

	|result|
	result := Alien new: size.
	receiver
		primFFICallResult: result
		withArguments: {receiver. method rawSelector}, arguments.
	^resultBlock value: result! !

"May 11, 2010 -> 22:59:45"!

! (Delta mirrorFor: #FixedSizeTypeHandler) classSide methodsFor: 'instance creation' !
forByte

	^(self new)
		initSize: 1
		resultBlock: [:alien| alien byteAt: 1]! !

"May 11, 2010 -> 23:1:15"!

! (Delta mirrorFor: #FixedSizeTypeHandler) classSide methodsFor: 'instance creation' !
forUnsignedByte

	^(self new)
		initSize: 1
		resultBlock: [:alien| alien unsignedByteAt: 1]! !

"May 11, 2010 -> 23:1:25"!

! (Delta mirrorFor: #FixedSizeTypeHandler) classSide methodsFor: 'instance creation' !
forByte

	^(self new)
		initSize: 1
		resultBlock: [:alien| alien signedByteAt: 1]! !

"May 11, 2010 -> 23:1:52"!

! (Delta mirrorFor: #FixedSizeTypeHandler) classSide methodsFor: 'instance creation' !
forShort

	^(self new)
		initSize: 2
		resultBlock: [:alien| alien signedShortAt: 1]! !

"May 11, 2010 -> 23:2:6"!

! (Delta mirrorFor: #FixedSizeTypeHandler) classSide methodsFor: 'instance creation' !
forUnsignedShort

	^(self new)
		initSize: 2
		resultBlock: [:alien| alien unsignedSignedShortAt: 1]! !

"May 11, 2010 -> 23:2:57"!

! (Delta mirrorFor: #FixedSizeTypeHandler) classSide methodsFor: 'instance creation' !
forUnsignedShort

	^(self new)
		initSize: 2
		resultBlock: [:alien| alien unsignedShortAt: 1]! !

"May 11, 2010 -> 23:3:12"!

! (Delta mirrorFor: #FixedSizeTypeHandler) classSide methodsFor: 'instance creation' !
forUnsignedLong

	^(self new)
		initSize: 4
		resultBlock: [:alien| alien unsignedLongAt: 1]! !

"May 11, 2010 -> 23:3:25"!

! (Delta mirrorFor: #FixedSizeTypeHandler) classSide methodsFor: 'instance creation' !
forLong

	^(self new)
		initSize: 4
		resultBlock: [:alien| alien signedLongAt: 1]! !

"May 11, 2010 -> 23:5:7"!

! (Delta mirrorFor: #FixedSizeTypeHandler) classSide methodsFor: 'instance creation' !
forFloat

	^(self new)
		initSize: 4
		resultBlock: [:alien| alien floatAt: 1]! !

"May 11, 2010 -> 23:5:32"!

! (Delta mirrorFor: #FixedSizeTypeHandler) classSide methodsFor: 'instance creation' !
forDoubl

	^(self new)
		initSize: 8
		resultBlock: [:alien| alien doubleAt: 1]! !

"May 11, 2010 -> 23:5:38"!

! (Delta mirrorFor: #FixedSizeTypeHandler) classSide methodsFor: 'instance creation' !
forDouble

	^(self new)
		initSize: 8
		resultBlock: [:alien| alien doubleAt: 1]! !

"May 11, 2010 -> 23:5:42"!

(Delta mirrorFor: #FixedSizeTypeHandler) classSide removeMethod: #forDoubl ifAbsent: [] !


"May 11, 2010 -> 23:9:41"!

Delta define: #FixedSizeTypeHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'size
resultBlock
allocBlock')) !


"May 11, 2010 -> 23:10:6"!

! (Delta mirrorFor: #FixedSizeTypeHandler) methodsFor: 'initialization' !
initSize: newSize resultBlock: block

	size := newSize.
	allocBlock := [Alien new: newSize].
	resultBlock := block! !

"May 11, 2010 -> 23:10:33"!

! (Delta mirrorFor: #FixedSizeTypeHandler) methodsFor: 'forwarding' !
send: method receiver: receiver arguments: arguments

	|result|
	result := allocBlock new.
	receiver
		primFFICallResult: result
		withArguments: {receiver. method rawSelector}, arguments.
	^resultBlock value: result! !

"May 11, 2010 -> 23:11:15"!

! (Delta mirrorFor: #FixedSizeTypeHandler) methodsFor: 'initialization' !
initSize: newSize resultBlock: block

	allocBlock := [Alien new: newSize].
	resultBlock := block! !

"May 11, 2010 -> 23:11:51"!

Delta define: #FixedSizeTypeHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'resultBlock
allocBlock')) !


"May 11, 2010 -> 23:14:13"!

! (Delta mirrorFor: #FixedSizeTypeHandler) methodsFor: 'initialization' !
initAllocBlock: alloc resultBlock: block

	allocBlock := alloc.
	resultBlock := block! !

"May 11, 2010 -> 23:15:27"!

! (Delta mirrorFor: #FixedSizeTypeHandler) classSide methodsFor: 'instance creation' !
forClass: alienClass

	^(self new)
		initAllocBlock: [alienClass new] resultBlock: [:alien| alien];
		yourself! !

"May 11, 2010 -> 23:16:39"!

! (Delta mirrorFor: #FixedSizeTypeHandler) methodsFor: 'forwarding' !
send: method receiver: receiver arguments: arguments

	|result|
	result := allocBlock value.
	receiver
		primFFICallResult: result
		withArguments: {receiver. method rawSelector}, arguments.
	^resultBlock value: result! !

"May 11, 2010 -> 23:17:51"!

! (Delta mirrorFor: #StructTypeHandler) methodsFor: 'forwarding' !
send: method receiver: receiver arguments: arguments

	! !

"May 11, 2010 -> 23:20:45"!

! (Delta mirrorFor: #ObjectiveCMethod) methodsFor: 'accessing' !
returnLength

	^self signature methodReturnLength! !

"May 11, 2010 -> 23:22:43"!

! (Delta mirrorFor: #StructTypeHandler) methodsFor: 'forwarding' !
send: method receiver: receiver arguments: arguments

	^method returnLength <=8
		ifTrue: [self normalSend: method receiver: receiver arguments: arguments]
		ifFalse: [self structSend: method receiver: receiver arguments: arguments]! !

"May 11, 2010 -> 23:24:2"!

! (Delta mirrorFor: #StructTypeHandler) methodsFor: 'forwarding' !
normalSend: method receiver: receiver arguments: arguments

	|result|
	result := Alien new: method returnLength.
	receiver
		primFFICallResult: result
		withArguments: {receiver. method rawSelector}, arguments.
	^result! !

"May 11, 2010 -> 23:24:57"!

! (Delta mirrorFor: #StructTypeHandler) methodsFor: 'forwarding' !
structSend: method receiver: receiver arguments: arguments

	|result|
	result := Alien newC: method returnLength.
	receiver
		primFFICallResult: nil
		withArguments: {result pointer. receiver. method rawSelector}, arguments.
	^result! !

"May 11, 2010 -> 23:27:16"!

(Delta mirrorFor: #SimpleTypeHandler) removeDefinitionIfFail: [] !


"May 11, 2010 -> 23:29:57"!

Delta define: #ObjectiveCAlien as: (
(Class subclassOf: 'Alien' instanceVariables: '') classVariables: 'ClassGetClassMethodAlien
ClassGetInstanceMethodAlien
ClassSelectorAlien
EightByteParameterTypes
FourByteParameterTypes
ObjCLookUpClassAlien
ObjCMsgSendAlien
MethodTypeMap
MethodTypeResultMap
SelectorTable
SelGetNameAlien
SelRegisterNameAlien
TypeQualifiers
TypeQualifierCodes
ReturnTypeHandlers') !


"May 11, 2010 -> 23:31:29"!

! (Delta mirrorFor: #ObjectiveCAlien) classSide methodsFor: 'class initialization' !
initializeMethodTypeMap
	"self initializeMethodTypeMap"
	"ObjectiveCAlien initializeMethodTypeMap"
	"See /usr/include/objc/objc_class.h and
	 The Objective-C 2.0 Programming Language, Ch 12: The Runtime System, sec: Type Encodings."
	ReturnTypeHandlers := IdentityDictionary new: 32.
	ReturnTypeHandlers
		at: $@ "_C_ID"			put: [ObjectiveCAlien new];
		at: $# "_C_CLASS"		put: [ObjectiveCClassAlien new];
		at: $: "_C_SEL"			put: [Alien new: 4];
		at: $c "_CHR"			put: [Alien new: 1];
		at: $C "_C_UCHR"		put: [Alien new: 1];
		at: $s "_C_SHT"		put: [Alien new: 2];
		at: $S "_C_USHT"		put: [Alien new: 2];
		at: $i "_C_INT"			put: [Alien new: 4];
		at: $I "_C_UINT"		put: [Alien new: 4];
		at: $l "_C_LNG"			put: [Alien new: 4];
		at: $L "_C_ULNG"		put: [Alien new: 4];
		at: $f "_C_FLT"			put: [Alien new: 4];
		at: $d "_C_DBL"		put: [Alien new: 8];
		"at: $b" "_C_BFLD"		"put: [];"
		at: $v "_C_VOID"		put: nil;
		"at: $?" "_C_UNDEF"	"put: [];"
		at: $^ "_C_PTR"		put: [Alien forPointer: 0];
		at: $* "_CHARPTR"		put: [Alien forPointer: 0].
		"at: $[" "_C_ARY_B"	"put: [];"
		"at: $]" "_C_ARY_E"	"put: [];"
		"at: $(" "_C_UNION_B"	"put: [];"
		"at: $)" "_C_UNION_E"	"put: [];"
		"at: ${" "_C_STRUCT_B""put: [];"
		"at: $}" "_C_STRUCT_E""put: []."

	MethodTypeMap := IdentityDictionary new: 32.
	MethodTypeMap
		at: $@ "_C_ID"			put: [ObjectiveCAlien new];
		at: $# "_C_CLASS"		put: [ObjectiveCClassAlien new];
		at: $: "_C_SEL"			put: [Alien new: 4];
		at: $c "_CHR"			put: [Alien new: 1];
		at: $C "_C_UCHR"		put: [Alien new: 1];
		at: $s "_C_SHT"		put: [Alien new: 2];
		at: $S "_C_USHT"		put: [Alien new: 2];
		at: $i "_C_INT"			put: [Alien new: 4];
		at: $I "_C_UINT"		put: [Alien new: 4];
		at: $l "_C_LNG"			put: [Alien new: 4];
		at: $L "_C_ULNG"		put: [Alien new: 4];
		at: $f "_C_FLT"			put: [Alien new: 4];
		at: $d "_C_DBL"		put: [Alien new: 8];
		"at: $b" "_C_BFLD"		"put: [];"
		at: $v "_C_VOID"		put: nil;
		"at: $?" "_C_UNDEF"	"put: [];"
		at: $^ "_C_PTR"		put: [Alien forPointer: 0];
		at: $* "_CHARPTR"		put: [Alien forPointer: 0].
		"at: $[" "_C_ARY_B"	"put: [];"
		"at: $]" "_C_ARY_E"	"put: [];"
		"at: $(" "_C_UNION_B"	"put: [];"
		"at: $)" "_C_UNION_E"	"put: [];"
		"at: ${" "_C_STRUCT_B""put: [];"
		"at: $}" "_C_STRUCT_E""put: []."

	FourByteParameterTypes := '@#:cCsSiIlLf^*'.
	EightByteParameterTypes := 'd'.

"#define _C_CONST			'r'
#define _C_IN				'n'
#define _C_INOUT			'N'
#define _C_OUT			'o'
#define _C_BYCOPY		'O'
#define _C_BYREF			'R'
#define _C_ONEWAY		'V'
#define _C_GCINVISIBLE	'!!'
"
	TypeQualifiers := 'nNoOrRV!!'.
	TypeQualifierCodes := TypeQualifiers asByteArray.
					
	MethodTypeResultMap := IdentityDictionary new: 32.
	MethodTypeResultMap
		at: $c "_CHR"			put: [:alien| alien unsignedByteAt: 1];
		at: $C "_C_UCHR"		put: [:alien| alien unsignedByteAt: 1];
		at: $s "_C_SHT"		put: [:alien| alien signedShortAt: 1];
		at: $S "_C_USHT"		put: [:alien| alien unsignedShortAt: 1];
		at: $i "_C_INT"			put: [:alien| alien signedLongAt: 1];
		at: $I "_C_UINT"		put: [:alien| alien unsignedLongAt: 1];
		at: $l "_C_LNG"			put: [:alien| alien signedLongAt: 1];
		at: $L "_C_ULNG"		put: [:alien| alien unsignedLongAt: 1];
		at: $f "_C_FLT"			put: [:alien| alien floatAt: 1];
		at: $d "_C_DBL"		put: [:alien| alien doubleAt: 1].
! !

"May 11, 2010 -> 23:40:37"!

! (Delta mirrorFor: #FixedSizeTypeHandler) classSide methodsFor: 'instance creation' !
forVoid

	^(self new)
		initAllocBlock: [nil] resultBlock: [:alien| nil];
		yourself! !

"May 11, 2010 -> 23:43:28"!

! (Delta mirrorFor: #FixedSizeTypeHandler) classSide methodsFor: 'instance creation' !
forPointer

	^(self new)
		initAllocBlock: [Alien forPointer: 0] resultBlock: [:alien| alien];
		yourself! !

"May 11, 2010 -> 23:46:52"!

! (Delta mirrorFor: #ObjectiveCAlien) classSide methodsFor: 'class initialization' !
initializeMethodTypeMap
	"self initializeMethodTypeMap"
	"ObjectiveCAlien initializeMethodTypeMap"
	"See /usr/include/objc/objc_class.h and
	 The Objective-C 2.0 Programming Language, Ch 12: The Runtime System, sec: Type Encodings."
	ReturnTypeHandlers := IdentityDictionary new: 32.
	ReturnTypeHandlers
		at: $@ "_C_ID"			put: (FixedSizeTypeHandler forClass: ObjectiveCAlien);
		at: $# "_C_CLASS"		put: (FixedSizeTypeHandler forClass: ObjectiveCClassAlien);
		at: $: "_C_SEL"			put: (FixedSizeTypeHandler size: 4);
		at: $c "_CHR"			put: FixedSizeTypeHandler forByte;
		at: $C "_C_UCHR"		put: FixedSizeTypeHandler forUnsignedByte;
		at: $s "_C_SHT"		put: FixedSizeTypeHandler forShort;
		at: $S "_C_USHT"		put: FixedSizeTypeHandler forUnsignedShort;
		at: $i "_C_INT"			put: FixedSizeTypeHandler forLong;
		at: $I "_C_UINT"		put: FixedSizeTypeHandler forUnsignedLong;
		at: $l "_C_LNG"			put: FixedSizeTypeHandler forLong;
		at: $L "_C_ULNG"		put: FixedSizeTypeHandler forUnsignedLong;
		at: $f "_C_FLT"			put: FixedSizeTypeHandler forFloat;
		at: $d "_C_DBL"		put: FixedSizeTypeHandler forDouble;
		"at: $b" "_C_BFLD"		"put: [];"
		at: $v "_C_VOID"		put: FixedSizeTypeHandler forVoid;
		"at: $?" "_C_UNDEF"	"put: [];"
		at: $^ "_C_PTR"		put: FixedSizeTypeHandler forPointer;
		at: $* "_CHARPTR"		put: FixedSizeTypeHandler forPointer;
		"at: $[" "_C_ARY_B"	"put: [];"
		"at: $]" "_C_ARY_E"	"put: [];"
		at: $( "_C_UNION_B"	put: StructTypeHandler new;
		"at: $)" "_C_UNION_E"	"put: [];"
		at: ${ "_C_STRUCT_B" put: StructTypeHandler new.
		"at: $}" "_C_STRUCT_E""put: []."

	MethodTypeMap := IdentityDictionary new: 32.
	MethodTypeMap
		at: $@ "_C_ID"			put: [ObjectiveCAlien new];
		at: $# "_C_CLASS"		put: [ObjectiveCClassAlien new];
		at: $: "_C_SEL"			put: [Alien new: 4];
		at: $c "_CHR"			put: [Alien new: 1];
		at: $C "_C_UCHR"		put: [Alien new: 1];
		at: $s "_C_SHT"		put: [Alien new: 2];
		at: $S "_C_USHT"		put: [Alien new: 2];
		at: $i "_C_INT"			put: [Alien new: 4];
		at: $I "_C_UINT"		put: [Alien new: 4];
		at: $l "_C_LNG"			put: [Alien new: 4];
		at: $L "_C_ULNG"		put: [Alien new: 4];
		at: $f "_C_FLT"			put: [Alien new: 4];
		at: $d "_C_DBL"		put: [Alien new: 8];
		"at: $b" "_C_BFLD"		"put: [];"
		at: $v "_C_VOID"		put: nil;
		"at: $?" "_C_UNDEF"	"put: [];"
		at: $^ "_C_PTR"		put: [Alien forPointer: 0];
		at: $* "_CHARPTR"		put: [Alien forPointer: 0].
		"at: $[" "_C_ARY_B"	"put: [];"
		"at: $]" "_C_ARY_E"	"put: [];"
		"at: $(" "_C_UNION_B"	"put: [];"
		"at: $)" "_C_UNION_E"	"put: [];"
		"at: ${" "_C_STRUCT_B""put: [];"
		"at: $}" "_C_STRUCT_E""put: []."

	FourByteParameterTypes := '@#:cCsSiIlLf^*'.
	EightByteParameterTypes := 'd'.

"#define _C_CONST			'r'
#define _C_IN				'n'
#define _C_INOUT			'N'
#define _C_OUT			'o'
#define _C_BYCOPY		'O'
#define _C_BYREF			'R'
#define _C_ONEWAY		'V'
#define _C_GCINVISIBLE	'!!'
"
	TypeQualifiers := 'nNoOrRV!!'.
	TypeQualifierCodes := TypeQualifiers asByteArray.
					
	MethodTypeResultMap := IdentityDictionary new: 32.
	MethodTypeResultMap
		at: $c "_CHR"			put: [:alien| alien unsignedByteAt: 1];
		at: $C "_C_UCHR"		put: [:alien| alien unsignedByteAt: 1];
		at: $s "_C_SHT"		put: [:alien| alien signedShortAt: 1];
		at: $S "_C_USHT"		put: [:alien| alien unsignedShortAt: 1];
		at: $i "_C_INT"			put: [:alien| alien signedLongAt: 1];
		at: $I "_C_UINT"		put: [:alien| alien unsignedLongAt: 1];
		at: $l "_C_LNG"			put: [:alien| alien signedLongAt: 1];
		at: $L "_C_ULNG"		put: [:alien| alien unsignedLongAt: 1];
		at: $f "_C_FLT"			put: [:alien| alien floatAt: 1];
		at: $d "_C_DBL"		put: [:alien| alien doubleAt: 1].
! !

"May 11, 2010 -> 23:47:38"!

! (Delta mirrorFor: #ObjectiveCAlien) classSide methodsFor: 'class initialization' !
initializeMethodTypeMap
	"self initializeMethodTypeMap"
	"ObjectiveCAlien initializeMethodTypeMap"
	"See /usr/include/objc/objc_class.h and
	 The Objective-C 2.0 Programming Language, Ch 12: The Runtime System, sec: Type Encodings."
	ReturnTypeHandlers := IdentityDictionary new: 32.
	ReturnTypeHandlers
		at: $@ "_C_ID"			put: (FixedSizeTypeHandler forClass: ObjectiveCAlien);
		at: $# "_C_CLASS"		put: (FixedSizeTypeHandler forClass: ObjectiveCClassAlien);
		at: $: "_C_SEL"			put: (FixedSizeTypeHandler size: 4);
		at: $c "_CHR"			put: FixedSizeTypeHandler forByte;
		at: $C "_C_UCHR"		put: FixedSizeTypeHandler forUnsignedByte;
		at: $s "_C_SHT"		put: FixedSizeTypeHandler forShort;
		at: $S "_C_USHT"		put: FixedSizeTypeHandler forUnsignedShort;
		at: $i "_C_INT"			put: FixedSizeTypeHandler forLong;
		at: $I "_C_UINT"		put: FixedSizeTypeHandler forUnsignedLong;
		at: $l "_C_LNG"			put: FixedSizeTypeHandler forLong;
		at: $L "_C_ULNG"		put: FixedSizeTypeHandler forUnsignedLong;
		at: $f "_C_FLT"			put: FixedSizeTypeHandler forFloat;
		at: $d "_C_DBL"		put: FixedSizeTypeHandler forDouble;
		"at: $b" "_C_BFLD"		"put: [];"
		at: $v "_C_VOID"		put: FixedSizeTypeHandler forVoid;
		"at: $?" "_C_UNDEF"	"put: [];"
		at: $^ "_C_PTR"		put: FixedSizeTypeHandler forPointer;
		at: $* "_CHARPTR"		put: FixedSizeTypeHandler forPointer;
		at: $[ "_C_ARY_B"	put: FixedSizeTypeHandler forPointer;
		"at: $]" "_C_ARY_E"	"put: [];"
		at: $( "_C_UNION_B"	put: StructTypeHandler new;
		"at: $)" "_C_UNION_E"	"put: [];"
		at: ${ "_C_STRUCT_B" put: StructTypeHandler new.
		"at: $}" "_C_STRUCT_E""put: []."

	MethodTypeMap := IdentityDictionary new: 32.
	MethodTypeMap
		at: $@ "_C_ID"			put: [ObjectiveCAlien new];
		at: $# "_C_CLASS"		put: [ObjectiveCClassAlien new];
		at: $: "_C_SEL"			put: [Alien new: 4];
		at: $c "_CHR"			put: [Alien new: 1];
		at: $C "_C_UCHR"		put: [Alien new: 1];
		at: $s "_C_SHT"		put: [Alien new: 2];
		at: $S "_C_USHT"		put: [Alien new: 2];
		at: $i "_C_INT"			put: [Alien new: 4];
		at: $I "_C_UINT"		put: [Alien new: 4];
		at: $l "_C_LNG"			put: [Alien new: 4];
		at: $L "_C_ULNG"		put: [Alien new: 4];
		at: $f "_C_FLT"			put: [Alien new: 4];
		at: $d "_C_DBL"		put: [Alien new: 8];
		"at: $b" "_C_BFLD"		"put: [];"
		at: $v "_C_VOID"		put: nil;
		"at: $?" "_C_UNDEF"	"put: [];"
		at: $^ "_C_PTR"		put: [Alien forPointer: 0];
		at: $* "_CHARPTR"		put: [Alien forPointer: 0].
		"at: $[" "_C_ARY_B"	"put: [];"
		"at: $]" "_C_ARY_E"	"put: [];"
		"at: $(" "_C_UNION_B"	"put: [];"
		"at: $)" "_C_UNION_E"	"put: [];"
		"at: ${" "_C_STRUCT_B""put: [];"
		"at: $}" "_C_STRUCT_E""put: []."

	FourByteParameterTypes := '@#:cCsSiIlLf^*'.
	EightByteParameterTypes := 'd'.

"#define _C_CONST			'r'
#define _C_IN				'n'
#define _C_INOUT			'N'
#define _C_OUT			'o'
#define _C_BYCOPY		'O'
#define _C_BYREF			'R'
#define _C_ONEWAY		'V'
#define _C_GCINVISIBLE	'!!'
"
	TypeQualifiers := 'nNoOrRV!!'.
	TypeQualifierCodes := TypeQualifiers asByteArray.
					
	MethodTypeResultMap := IdentityDictionary new: 32.
	MethodTypeResultMap
		at: $c "_CHR"			put: [:alien| alien unsignedByteAt: 1];
		at: $C "_C_UCHR"		put: [:alien| alien unsignedByteAt: 1];
		at: $s "_C_SHT"		put: [:alien| alien signedShortAt: 1];
		at: $S "_C_USHT"		put: [:alien| alien unsignedShortAt: 1];
		at: $i "_C_INT"			put: [:alien| alien signedLongAt: 1];
		at: $I "_C_UINT"		put: [:alien| alien unsignedLongAt: 1];
		at: $l "_C_LNG"			put: [:alien| alien signedLongAt: 1];
		at: $L "_C_ULNG"		put: [:alien| alien unsignedLongAt: 1];
		at: $f "_C_FLT"			put: [:alien| alien floatAt: 1];
		at: $d "_C_DBL"		put: [:alien| alien doubleAt: 1].
! !

"May 11, 2010 -> 23:49:7"!

! (Delta mirrorFor: #ObjectiveCAlien) classSide methodsFor: 'class initialization' !
initializeMethodTypeMap
	"self initializeMethodTypeMap"
	"ObjectiveCAlien initializeMethodTypeMap"
	"See /usr/include/objc/objc_class.h and
	 The Objective-C 2.0 Programming Language, Ch 12: The Runtime System, sec: Type Encodings."
	ReturnTypeHandlers := IdentityDictionary new: 32.
	ReturnTypeHandlers
		at: $@ "_C_ID"					put: (FixedSizeTypeHandler forClass: ObjectiveCAlien);
		at: $# "_C_CLASS"			put: (FixedSizeTypeHandler forClass: ObjectiveCClassAlien);
		at: $: "_C_SEL"					put: (FixedSizeTypeHandler size: 4);
		at: $c "_CHR"						put: FixedSizeTypeHandler forByte;
		at: $C "_C_UCHR"			put: FixedSizeTypeHandler forUnsignedByte;
		at: $s "_C_SHT"					put: FixedSizeTypeHandler forShort;
		at: $S "_C_USHT"				put: FixedSizeTypeHandler forUnsignedShort;
		at: $i "_C_INT"					put: FixedSizeTypeHandler forLong;
		at: $I "_C_UINT"					put: FixedSizeTypeHandler forUnsignedLong;
		at: $l "_C_LNG"					put: FixedSizeTypeHandler forLong;
		at: $L "_C_ULNG"				put: FixedSizeTypeHandler forUnsignedLong;
		at: $f "_C_FLT"					put: FixedSizeTypeHandler forFloat;
		at: $d "_C_DBL"					put: FixedSizeTypeHandler forDouble;
		"at: $b" "_C_BFLD"		"put: [];"
		at: $v "_C_VOID"				put: FixedSizeTypeHandler forVoid;
		"at: $?" "_C_UNDEF"	"put: [];"
		at: $^ "_C_PTR"					put: FixedSizeTypeHandler forPointer;
		at: $* "_CHARPTR"			put: FixedSizeTypeHandler forPointer;
		at: $[ "_C_ARY_B"			put: FixedSizeTypeHandler forPointer;
		"at: $]" "_C_ARY_E"	"put: [];"
		at: $( "_C_UNION_B"		put: StructTypeHandler new;
		"at: $)" "_C_UNION_E"	"put: [];"
		at: ${ "_C_STRUCT_B"	put: StructTypeHandler new.
		"at: $}" "_C_STRUCT_E""put: []."

	MethodTypeMap := IdentityDictionary new: 32.
	MethodTypeMap
		at: $@ "_C_ID"			put: [ObjectiveCAlien new];
		at: $# "_C_CLASS"		put: [ObjectiveCClassAlien new];
		at: $: "_C_SEL"			put: [Alien new: 4];
		at: $c "_CHR"			put: [Alien new: 1];
		at: $C "_C_UCHR"		put: [Alien new: 1];
		at: $s "_C_SHT"		put: [Alien new: 2];
		at: $S "_C_USHT"		put: [Alien new: 2];
		at: $i "_C_INT"			put: [Alien new: 4];
		at: $I "_C_UINT"		put: [Alien new: 4];
		at: $l "_C_LNG"			put: [Alien new: 4];
		at: $L "_C_ULNG"		put: [Alien new: 4];
		at: $f "_C_FLT"			put: [Alien new: 4];
		at: $d "_C_DBL"		put: [Alien new: 8];
		"at: $b" "_C_BFLD"		"put: [];"
		at: $v "_C_VOID"		put: nil;
		"at: $?" "_C_UNDEF"	"put: [];"
		at: $^ "_C_PTR"		put: [Alien forPointer: 0];
		at: $* "_CHARPTR"		put: [Alien forPointer: 0].
		"at: $[" "_C_ARY_B"	"put: [];"
		"at: $]" "_C_ARY_E"	"put: [];"
		"at: $(" "_C_UNION_B"	"put: [];"
		"at: $)" "_C_UNION_E"	"put: [];"
		"at: ${" "_C_STRUCT_B""put: [];"
		"at: $}" "_C_STRUCT_E""put: []."

	FourByteParameterTypes := '@#:cCsSiIlLf^*'.
	EightByteParameterTypes := 'd'.

"#define _C_CONST			'r'
#define _C_IN				'n'
#define _C_INOUT			'N'
#define _C_OUT			'o'
#define _C_BYCOPY		'O'
#define _C_BYREF			'R'
#define _C_ONEWAY		'V'
#define _C_GCINVISIBLE	'!!'
"
	TypeQualifiers := 'nNoOrRV!!'.
	TypeQualifierCodes := TypeQualifiers asByteArray.
					
	MethodTypeResultMap := IdentityDictionary new: 32.
	MethodTypeResultMap
		at: $c "_CHR"			put: [:alien| alien unsignedByteAt: 1];
		at: $C "_C_UCHR"		put: [:alien| alien unsignedByteAt: 1];
		at: $s "_C_SHT"		put: [:alien| alien signedShortAt: 1];
		at: $S "_C_USHT"		put: [:alien| alien unsignedShortAt: 1];
		at: $i "_C_INT"			put: [:alien| alien signedLongAt: 1];
		at: $I "_C_UINT"		put: [:alien| alien unsignedLongAt: 1];
		at: $l "_C_LNG"			put: [:alien| alien signedLongAt: 1];
		at: $L "_C_ULNG"		put: [:alien| alien unsignedLongAt: 1];
		at: $f "_C_FLT"			put: [:alien| alien floatAt: 1];
		at: $d "_C_DBL"		put: [:alien| alien doubleAt: 1].
! !

"May 11, 2010 -> 23:52:49"!

! (Delta mirrorFor: #ObjectiveCAlien) methodsFor: 'message forwarding' !
doesNotUnderstand: aMessage
	| method returnTypeCharacter result |
	method := self objectiveCMethodForSelectorAlien: (self class asObjectiveCSelector: aMessage selector).
	method isNil ifTrue:
		["Might also check if selector is not already forward: and if
		  so try sending forward: of the selector and arguments?"
		 ^super doesNotUnderstand: aMessage].
	returnTypeCharacter := self class returnTypeCharacterForMethodTypes: method methodTypes.
	"If MethodTypeMap doesn't include returnTypeCharacter then we haven't
	implemented handling that return type yet."
	^(ReturnTypeHandlers at: returnTypeCharacter)
		send: method receiver: self arguments: aMessage arguments
	"result := method implementation
				primFFICallResult: (MethodTypeMap at: returnTypeCharacter) value
				withArguments: {self. method rawSelector}, aMessage arguments.
	^(MethodTypeResultMap
			at: returnTypeCharacter
			ifAbsent: [^result])
		value: result"! !

"May 11, 2010 -> 23:53:8"!

"System saved" !
"May 11, 2010 -> 23:55:23"!

! (Delta mirrorFor: #FixedSizeTypeHandler) methodsFor: 'forwarding' !
send: method receiver: receiver arguments: arguments

	|result|
	result := allocBlock value.
	method implementation
		primFFICallResult: result
		withArguments: {receiver. method rawSelector}, arguments.
	^resultBlock value: result! !

"May 11, 2010 -> 23:55:45"!

! (Delta mirrorFor: #StructTypeHandler) methodsFor: 'private-forwarding' !
structSend: method receiver: receiver arguments: arguments

	|result|
	result := Alien newC: method returnLength.
	method implementation
		primFFICallResult: nil
		withArguments: {result pointer. receiver. method rawSelector}, arguments.
	^result! !

"May 11, 2010 -> 23:56:4"!

! (Delta mirrorFor: #StructTypeHandler) methodsFor: 'private-forwarding' !
normalSend: method receiver: receiver arguments: arguments

	|result|
	result := Alien new: method returnLength.
	method implementation
		primFFICallResult: result
		withArguments: {receiver. method rawSelector}, arguments.
	^result! !

"May 11, 2010 -> 23:56:30"!

"System saved" !
"May 15, 2010 -> 19:38:14"!

Delta define: #AlienDemo as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 15, 2010 -> 19:38:14"!

Delta define: #AlienDemo as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 15, 2010 -> 19:38:14"!

Delta define: #AlienDemo as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 15, 2010 -> 19:38:14"!

Delta define: #AlienDemo as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 15, 2010 -> 19:38:14"!

Delta define: #AlienDemo as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 15, 2010 -> 19:38:14"!

Delta define: #AlienDemo as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 15, 2010 -> 19:38:14"!

Delta define: #AlienDemo as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 15, 2010 -> 19:38:14"!

Delta define: #AlienDemo as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 15, 2010 -> 19:38:14"!

Delta define: #AlienDemo as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 15, 2010 -> 19:38:14"!

Delta define: #AlienDemo as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 15, 2010 -> 19:38:14"!

Delta define: #AlienDemo as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 15, 2010 -> 19:44:58"!

! (Delta mirrorFor: #AlienDemo) methodsFor: 'MacOS examples' !
exampleCqsort
	"Call the libc qsort function (which requires a callback)."
	"AlienDemo new exampleCqsort"
	"(Time millisecondsToRun: [100 timesRepeat: [Alien exampleCqsort]]) / 100.0"
	"| cb rand nElements sizeofDouble values orig sort |
	rand:: Random new.
	values:: Alien newC: (nElements:: 100) * (sizeofDouble:: 8).
	1 to: values dataSize by: sizeofDouble do:
		[:i| values doubleAt: i put: rand next].
	orig:: (1 to: values dataSize by: sizeofDouble) collect: [:i| values doubleAt: i].
	cb:: Callback
			block: [:args :result|
					result returnInteger: ((args first doubleAt: 1) - (args second doubleAt: 1)) sign]
			argsClass: QsortCompare.
	(Alien lookup: 'qsort' inLibrary: libcName)
		primFFICallResult: nil
		with: values pointer
		with: nElements
		with: sizeofDouble
		with: cb thunk.
	sort:: (1 to: values dataSize by: sizeofDouble) collect: [:i| values doubleAt: i].
	values free.
	^orig -> sort"! !

"May 15, 2010 -> 19:48:18"!

! (Delta mirrorFor: #AlienDemo) methodsFor: 'MacOS examples' !
exampleCqsort
	"Call the libc qsort function (which requires a callback)."
	"AlienDemo new exampleCqsort"
	"(Time millisecondsToRun: [100 timesRepeat: [Alien exampleCqsort]]) / 100.0"
	"| cb rand nElements sizeofDouble values orig sort |
	rand:= Random new.
	values:= Alien newC: (nElements:= 100) * (sizeofDouble:= 8).
	1 to: values dataSize by: sizeofDouble do:
		[:i| values doubleAt: i put: rand next].
	orig:= (1 to: values dataSize by: sizeofDouble) collect: [:i| values doubleAt: i].
	cb:= Callback
			block: [:args :result|
					result returnInteger: ((args first doubleAt: 1) - (args second doubleAt: 1)) sign]
			argsClass: QsortCompare.
	(Alien lookup: 'qsort' inLibrary: libcName)
		primFFICallResult: nil
		with: values pointer
		with: nElements
		with: sizeofDouble
		with: cb thunk.
	sort:= (1 to: values dataSize by: sizeofDouble) collect: [:i| values doubleAt: i].
	values free.
	^orig -> sort"! !

"May 15, 2010 -> 19:48:30"!

! (Delta mirrorFor: #AlienDemo) methodsFor: 'MacOS examples' !
exampleCqsort
	"Call the libc qsort function (which requires a callback)."
	"AlienDemo new exampleCqsort"
	"(Time millisecondsToRun: [100 timesRepeat: [Alien exampleCqsort]]) / 100.0"
	| cb rand nElements sizeofDouble values orig sort |
	rand:= Random new.
	"values:= Alien newC: (nElements:= 100) * (sizeofDouble:= 8).
	1 to: values dataSize by: sizeofDouble do:
		[:i| values doubleAt: i put: rand next].
	orig:= (1 to: values dataSize by: sizeofDouble) collect: [:i| values doubleAt: i].
	cb:= Callback
			block: [:args :result|
					result returnInteger: ((args first doubleAt: 1) - (args second doubleAt: 1)) sign]
			argsClass: QsortCompare.
	(Alien lookup: 'qsort' inLibrary: libcName)
		primFFICallResult: nil
		with: values pointer
		with: nElements
		with: sizeofDouble
		with: cb thunk.
	sort:= (1 to: values dataSize by: sizeofDouble) collect: [:i| values doubleAt: i].
	values free.
	^orig -> sort"! !

"May 15, 2010 -> 19:48:38"!

! (Delta mirrorFor: #AlienDemo) methodsFor: 'MacOS examples' !
exampleCqsort
	"Call the libc qsort function (which requires a callback)."
	"AlienDemo new exampleCqsort"
	"(Time millisecondsToRun: [100 timesRepeat: [Alien exampleCqsort]]) / 100.0"
	| cb rand nElements sizeofDouble values orig sort |
	rand:= Random new.
	values:= Alien newC: (nElements:= 100) * (sizeofDouble:= 8).
	"1 to: values dataSize by: sizeofDouble do:
		[:i| values doubleAt: i put: rand next].
	orig:= (1 to: values dataSize by: sizeofDouble) collect: [:i| values doubleAt: i].
	cb:= Callback
			block: [:args :result|
					result returnInteger: ((args first doubleAt: 1) - (args second doubleAt: 1)) sign]
			argsClass: QsortCompare.
	(Alien lookup: 'qsort' inLibrary: libcName)
		primFFICallResult: nil
		with: values pointer
		with: nElements
		with: sizeofDouble
		with: cb thunk.
	sort:= (1 to: values dataSize by: sizeofDouble) collect: [:i| values doubleAt: i].
	values free.
	^orig -> sort"! !

"May 15, 2010 -> 19:53:13"!

! (Delta mirrorFor: #AlienDemo) methodsFor: 'MacOS examples' !
exampleCqsort
	"Call the libc qsort function (which requires a callback)."
	"AlienDemo new exampleCqsort"
	"(Time millisecondsToRun: [100 timesRepeat: [Alien exampleCqsort]]) / 100.0"
	| cb rand nElements sizeofDouble values orig sort |
	rand:= Random new.
	values:= Alien newC: (nElements:= 100) * (sizeofDouble:= 8).
	"1 to: values dataSize by: sizeofDouble do:
		[:i| values doubleAt: i put: rand next]."
	orig:= (1 to: values dataSize by: sizeofDouble) collect: [:i| values doubleAt: i].
	cb:= Callback
			block: [:args :result|
					result returnInteger: ((args first doubleAt: 1) - (args second doubleAt: 1)) sign]
			argsClass: QsortCompare.
	(Alien lookup: 'qsort' inLibrary: 'libc')
		primFFICallResult: nil
		with: values pointer
		with: nElements
		with: sizeofDouble
		with: cb thunk.
	sort:= (1 to: values dataSize by: sizeofDouble) collect: [:i| values doubleAt: i].
	values free.
	^orig -> sort! !

"May 16, 2010 -> 1:25:7"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
xxxnormalSendNode: node
	| recv msg sel arg1 arg2 arg3 |
	self assert: [ node isNormalSendNode ].
	recv := self rewrite: node recv.

	recv isFloatValue ifTrue: [
		result := self rewrite: node asFloatOperationOn: recv.
		result notNil ifTrue: [ ^ self ].
		"no FloatValue operation found"
		AutoFloatConversion
			ifTrue: [ recv := DeltaFloatUnaryOpToOop new f: #asFloat x: recv ]
			ifFalse: [ self at: node error: 'not a supported FloatValue operation' ]
	].

	"Prepare arguments for normal message sends"
	msg := self rewriteAsOop: node msg.
	sel := msg selector.
	msg nofArgs >= 1 ifTrue: [ arg1 := msg args at: 1 ].
	msg nofArgs >= 2 ifTrue: [ arg2 := msg args at: 2 ].
	msg nofArgs >= 3 ifTrue: [ arg3 := msg args at: 3 ].

	"Self & Super sends"
	(sel ~= #== and: [ sel ~= #~~ ]) ifTrue: [
		(recv isRefNode and: [ recv decl isReceiverNode ])	ifTrue: [ result := DeltaSelfSend new send: msg.						^ self ]
	].
	(recv isRefNode and: [ recv decl isSuperVarNode ])		ifTrue: [ result := DeltaSuperSend new send: msg.					^ self ].

	"Hardwired asFloatValue message"
	sel = #asFloatValue ifTrue: [
		result :=
			EnableFloatValues
				ifTrue: [ DeltaFloatify new obj: recv ]
				ifFalse: [ recv "simply ignore conversion" ].
		^ self
	].

	"Hardwired ifTrue: / ifFalse: messages"
	self if: [ sel = #ifTrue:				] with: arg1 nofArgs: 0	do: [ result := DeltaIf new if: recv is: true then: arg1.						^ self ].
	self if: [ sel = #ifFalse:			] with: arg1 nofArgs: 0	do: [ result := DeltaIf new if: recv is: false then: arg1.					^ self ].
	self if: [ sel = #ifTrue:ifFalse:	] with: arg1 and: arg2	do: [ result := DeltaIf new if: recv is: true then: arg1 else: arg2.	^ self ].
	self if: [ sel = #ifFalse:ifTrue:	] with: arg1 and: arg2	do: [ result := DeltaIf new if: recv is: false then: arg1 else: arg2.	^ self ].

	"Hardwired and: / or: messages"
	self if: [ sel = #and:					] with: arg1 nofArgs: 0	do: [ result := DeltaAndOr new if: recv and: arg1.							^ self ].
	self if: [ sel = #or:					] with: arg1 nofArgs: 0	do: [ result := DeltaAndOr new if: recv or: arg1.								^ self ].

	"Hardwired whileTrue: / whileFalse: messages"
	self if: [ sel = #whileTrue			] with: recv nofArgs: 0	do: [ result := DeltaLoop new while: true do: recv.							^ self ].
	self if: [ sel = #whileFalse		] with: recv nofArgs: 0	do: [ result := DeltaLoop new while: false do: recv.						^ self ].
	self if: [ sel = #whileTrue:		] with: recv and: arg1	do: [ result := DeltaLoop new while: recv is: true do: arg1.			^ self ].
	self if: [ sel = #whileFalse:		] with: recv and: arg1	do: [ result := DeltaLoop new while: recv is: false do: arg1.			^ self ].

	"Hardwired repeat: / timesRepeat: / to:do: / to:by:do: messages"
	self if: [ sel = #repeat				] with: recv nofArgs: 0	do: [ result := DeltaLoop new repeat: recv.										^ self ].
	self if: [ sel = #timesRepeat:	] with: arg1 nofArgs: 0	do: [ result := DeltaLoop new do: recv timesRepeat: arg1.			^ self ].
	self if: [ sel = #to:do:				] with: arg2 nofArgs: 1	do: [ result := DeltaLoop new from: recv to: arg1 do: arg2.			^ self ].
	self if: [ sel = #to:by:do:			] with: arg3 nofArgs: 1 do: [
		arg2 isIntNode ifTrue: [
			"inline only if step is a constant"
			result := DeltaLoop new from: recv to: arg1 by: arg2 do: arg3.
			^ self
		]
	].

	"Hardwired value message"
"
	self if: [ sel = #value				] with: recv nofArgs: 0 do: [ result := DeltaInlinedBlock new block: recv.							^ self ].
"

	"No rewriting"
	result := DeltaNormalSend new to: recv send: msg! !

"May 16, 2010 -> 1:27:38"!

! (Delta mirrorFor: #DeltaRewriter) methodsFor: 'Unclassified' !
normalSendNode: node
	| recv msg sel arg1 arg2 arg3 |
	self assert: [ node isNormalSendNode ].
	recv := self rewrite: node recv.

	recv isFloatValue ifTrue: [
		result := self rewrite: node asFloatOperationOn: recv.
		result notNil ifTrue: [ ^ self ].
		"no FloatValue operation found"
		AutoFloatConversion
			ifTrue: [ recv := DeltaFloatUnaryOpToOop new f: #asFloat x: recv ]
			ifFalse: [ self at: node error: 'not a supported FloatValue operation' ]
	].

	"Prepare arguments for normal message sends"
	msg := self rewriteAsOop: node msg.
	sel := msg selector.
	msg nofArgs >= 1 ifTrue: [ arg1 := msg args at: 1 ].
	msg nofArgs >= 2 ifTrue: [ arg2 := msg args at: 2 ].
	msg nofArgs >= 3 ifTrue: [ arg3 := msg args at: 3 ].

	"Self & Super sends"
	(sel ~= #== and: [ sel ~= #~~ ]) ifTrue: [
		(recv isRefNode and: [ recv decl isReceiverNode ])	ifTrue: [ result := DeltaSelfSend new send: msg.						^ self ]
	].
	(recv isRefNode and: [ recv decl isSuperVarNode ])		ifTrue: [ result := DeltaSuperSend new send: msg.					^ self ].

	"Hardwired asFloatValue message"
	sel = #asFloatValue ifTrue: [
		result :=
			EnableFloatValues
				ifTrue: [ DeltaFloatify new obj: recv ]
				ifFalse: [ recv "simply ignore conversion" ].
		^ self
	].

	"Hardwired ifTrue: / ifFalse: messages"
	self if: [ sel = #ifTrue:				] with: arg1 nofArgs: 0	do: [ result := DeltaIf new if: recv is: true then: arg1.						^ self ].
	self if: [ sel = #ifFalse:			] with: arg1 nofArgs: 0	do: [ result := DeltaIf new if: recv is: false then: arg1.					^ self ].
	self if: [ sel = #ifTrue:ifFalse:	] with: arg1 and: arg2	do: [ result := DeltaIf new if: recv is: true then: arg1 else: arg2.	^ self ].
	self if: [ sel = #ifFalse:ifTrue:	] with: arg1 and: arg2	do: [ result := DeltaIf new if: recv is: false then: arg1 else: arg2.	^ self ].

	"Hardwired and: / or: messages"
	self if: [ sel = #and:					] with: arg1 nofArgs: 0	do: [ result := DeltaAndOr new if: recv and: arg1.							^ self ].
	self if: [ sel = #or:					] with: arg1 nofArgs: 0	do: [ result := DeltaAndOr new if: recv or: arg1.								^ self ].

	"Hardwired whileTrue: / whileFalse: messages"
	self if: [ sel = #whileTrue			] with: recv nofArgs: 0	do: [ result := DeltaLoop new while: true do: recv.							^ self ].
	self if: [ sel = #whileFalse		] with: recv nofArgs: 0	do: [ result := DeltaLoop new while: false do: recv.						^ self ].
	self if: [ sel = #whileTrue:		] with: recv and: arg1	do: [ result := DeltaLoop new while: recv is: true do: arg1.			^ self ].
	self if: [ sel = #whileFalse:		] with: recv and: arg1	do: [ result := DeltaLoop new while: recv is: false do: arg1.			^ self ].

	"Hardwired repeat: / timesRepeat: / to:do: / to:by:do: messages"
	self if: [ sel = #repeat				] with: recv nofArgs: 0	do: [ result := DeltaLoop new repeat: recv.										^ self ].
	self if: [ sel = #timesRepeat:	] with: arg1 nofArgs: 0	do: [ result := DeltaLoop new do: recv timesRepeat: arg1.			^ self ].
	self if: [ sel = #to:do:				] with: arg2 nofArgs: 1	do: [ result := DeltaLoop new from: recv to: arg1 do: arg2.			^ self ].
	self if: [ sel = #to:by:do: and: [arg2 isIntNode]] with: arg3 nofArgs: 1 do: [
			"inline only if step is a constant"
			result := DeltaLoop new from: recv to: arg1 by: arg2 do: arg3.
			^ self
	].

	"Hardwired value message"
"
	self if: [ sel = #value				] with: recv nofArgs: 0 do: [ result := DeltaInlinedBlock new block: recv.							^ self ].
"

	"No rewriting"
	result := DeltaNormalSend new to: recv send: msg! !

"May 16, 2010 -> 1:29:55"!

! (Delta mirrorFor: #AlienDemo) methodsFor: 'MacOS examples' !
exampleCqsort
	"Call the libc qsort function (which requires a callback)."
	"AlienDemo new exampleCqsort"
	"(Time millisecondsToRun: [100 timesRepeat: [Alien exampleCqsort]]) / 100.0"
	| cb rand nElements sizeofDouble values orig sort |
	rand:= Random new.
	values:= Alien newC: (nElements:= 100) * (sizeofDouble:= 8).
	1 to: values dataSize by: sizeofDouble do:
		[:i| values doubleAt: i put: rand next].
	orig:= (1 to: values dataSize by: sizeofDouble) collect: [:i| values doubleAt: i].
	cb:= Callback
			block: [:args :result|
					result returnInteger: ((args first doubleAt: 1) - (args second doubleAt: 1)) sign]
			argsClass: QsortCompare.
	(Alien lookup: 'qsort' inLibrary: 'libc')
		primFFICallResult: nil
		with: values pointer
		with: nElements
		with: sizeofDouble
		with: cb thunk.
	sort:= (1 to: values dataSize by: sizeofDouble) collect: [:i| values doubleAt: i].
	values free.
	^orig -> sort! !

"May 16, 2010 -> 1:34:50"!

! (Delta mirrorFor: #AlienDemo) methodsFor: 'MacOS examples' !
exampleSprintf
	"Call the libc sprintf function."
	"AlienDemo new exampleSprintf"
	| r s |
	(Alien lookup: 'sprintf' inLibrary:  'libc')
		primFFICallResult: (r:= Alien new: 4)
		withArguments: {UnsafeAlien forPointerTo: (s:= ByteString new: 1024).
						 UnsafeAlien forPointerTo: 'Hello World %d %x !!!!!!!!', (String with: Character lf).
						 123.
						 48879}.
	^s copyFrom: 1 to: (r signedLongAt: 1) - 1 "trim the null byte"! !

"May 16, 2010 -> 1:37:51"!

! (Delta mirrorFor: #AlienDemo) methodsFor: 'MacOS examples' !
exampleSprintf
	"Call the libc sprintf function."
	"AlienDemo new exampleSprintf"
	| r s |
	(Alien lookup: 'sprintf' inLibrary:  'libc')
		primFFICallResult: (r:= Alien new: 4)
		withArguments: {UnsafeAlien forPointerTo: (s:= ByteString new: 1024).
						 "UnsafeAlien forPointerTo: "('Hello World %d %x !!!!!!!!', (String with: Character lf)) asAlien.
						 123.
						 48879}.
	^s copyFrom: 1 to: (r signedLongAt: 1) - 1 "trim the null byte"! !

"May 16, 2010 -> 1:38:32"!

! (Delta mirrorFor: #AlienDemo) methodsFor: 'MacOS examples' !
makeNSStringFrom: string <String> ^<Alien>
	^ObjectiveCClassAlien makeNSStringFrom: string! !

"May 16, 2010 -> 1:39:48"!

! (Delta mirrorFor: #AlienDemo) methodsFor: 'MacOS examples' !
examplePrintf
	"Call the libc printf function."
	"AlienDemo new  examplePrintf"
	| r s |
	(Alien lookup: 'printf' inLibrary: 'libc')
		primFFICallResult: (r:= Alien new: 4)
		withArguments: {(s:= ('Hello World %d %x !!!!!!!!', (String with: Character lf)) asAlien) pointer.
						 123.
						 48879}.
	s free.
	^r signedLongAt: 1! !

"May 16, 2010 -> 1:40:44"!

! (Delta mirrorFor: #AlienDemo) methodsFor: 'MacOS examples' !
exampleSprintf
	"Call the libc sprintf function."
	"AlienDemo new exampleSprintf"
	| r s |
	(Alien lookup: 'sprintf' inLibrary:  'libc')
		primFFICallResult: (r:= Alien new: 4)
		withArguments: {UnsafeAlien forPointerTo: (s:= ByteString new: 1024).
						 "UnsafeAlien forPointerTo: "('Hello World %d %x !!!!!!!!', (String with: Character lf)) asAlien pointer.
						 123.
						 48879}.
	^s copyFrom: 1 to: (r signedLongAt: 1) - 1 "trim the null byte"! !

"May 16, 2010 -> 1:44:2"!

! (Delta mirrorFor: #AlienDemo) methodsFor: 'MacOS examples' !
exampleSprintf
	"Call the libc sprintf function."
	"AlienDemo new exampleSprintf"
	| r s |
	(Alien lookup: 'sprintf' inLibrary:  'libc')
		primFFICallResult: (r:= Alien new: 4)
		withArguments: {"UnsafeAlien forPointerTo:" (s:= Alien newGC: 1024) pointer.
						 "UnsafeAlien forPointerTo: "('Hello World %d %x !!!!!!!!', (String with: Character lf)) asAlien pointer.
						 123.
						 48879}.
	^s copyFrom: 1 to: (r signedLongAt: 1) - 1 "trim the null byte"! !

"May 16, 2010 -> 1:47:37"!

! (Delta mirrorFor: #AlienDemo) methodsFor: 'MacOS examples' !
exampleSprintf
	"Call the libc sprintf function."
	"AlienDemo new exampleSprintf"
	| r s |
	(Alien lookup: 'sprintf' inLibrary:  'libc')
		primFFICallResult: (r:= Alien new: 4)
		withArguments: {"UnsafeAlien forPointerTo:" (s:= Alien newGC: 1024) pointer.
						 "UnsafeAlien forPointerTo: "('Hello World %d %x !!!!!!!!', (String with: Character lf)) asAlien pointer.
						 123.
						 48879}.
	^s strcpy
	"^s copyFrom: 1 to: (r signedLongAt: 1) - 1" "trim the null byte"! !

"May 16, 2010 -> 1:48:43"!

(Delta mirrorFor: #ByteString) removeDefinitionIfFail: [] !


"May 16, 2010 -> 1:54:45"!

Delta define: #MacOSXExampleModalDelegate as: (
(Class subclassOf: 'Object' instanceVariables: 'application')) !


"May 16, 2010 -> 1:54:45"!

(Delta mirrorFor: #MacOSXExampleModalDelegate)
comment: 
'Copyright 2008 Cadence Design Systems, Inc.
   
   Licensed under the Apache License, Version 2.0 (the ''''License''''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0
'!


"May 16, 2010 -> 1:54:45"!

! (Delta mirrorFor: #MacOSXExampleModalDelegate) methodsFor: 'initialize-release' !
forApplication: app
	application := app! !

"May 16, 2010 -> 1:57:51"!

! (Delta mirrorFor: #MacOSXExampleModalDelegate) methodsFor: 'initialize-release' !
alertDidEnd: alertAlien  returnCode: returnCode  contextInfo: contextInfo 
	
	application stopModalWithCode: returnCode

	"(self compiledMethodAt: #alertDidEnd:returnCode:contextInfo:) pragmas anyOne arguments first"! !

"May 16, 2010 -> 2:1:43"!

(Delta mirrorFor: #NSRect) removeDefinitionIfFail: [] !


"May 16, 2010 -> 2:7:14"!

(Delta mirrorFor: #NSPoint) removeDefinitionIfFail: [] !


"May 16, 2010 -> 2:7:49"!

Delta define: #NSPoint as: (
(Class subclassOf: 'Alien' instanceVariables: '')) !


"May 16, 2010 -> 2:8:20"!

! (Delta mirrorFor: #NSPoint) methodsFor: 'accessing' !
height
	^self floatAt: 5! !

"May 16, 2010 -> 2:8:20"!

! (Delta mirrorFor: #NSPoint) methodsFor: 'accessing' !
height: aFloat
	self floatAt: 5 put: aFloat asFloat! !

"May 16, 2010 -> 2:8:20"!

! (Delta mirrorFor: #NSPoint) methodsFor: 'accessing' !
width
	^self floatAt: 1! !

"May 16, 2010 -> 2:8:20"!

! (Delta mirrorFor: #NSPoint) methodsFor: 'accessing' !
width: aFloat
	self floatAt: 1 put: aFloat asFloat! !

"May 16, 2010 -> 2:8:20"!

! (Delta mirrorFor: #NSPoint) methodsFor: 'accessing' !
x
	^self floatAt: 1! !

"May 16, 2010 -> 2:8:50"!

Delta define: #NSRect as: (
(Class subclassOf: 'Alien' instanceVariables: '')) !


"May 16, 2010 -> 2:9:34"!

! (Delta mirrorFor: #NSRect) methodsFor: 'accessing' !
height
	^self floatAt: 13! !

"May 16, 2010 -> 2:9:34"!

! (Delta mirrorFor: #NSRect) methodsFor: 'accessing' !
height: aFloat
	self floatAt: 13 put: aFloat asFloat! !

"May 16, 2010 -> 2:9:34"!

! (Delta mirrorFor: #NSRect) methodsFor: 'accessing' !
width
		^self floatAt: 9! !

"May 16, 2010 -> 2:9:34"!

! (Delta mirrorFor: #NSRect) methodsFor: 'accessing' !
width: aFloat
	self floatAt: 9 put: aFloat asFloat! !

"May 16, 2010 -> 2:9:34"!

! (Delta mirrorFor: #NSRect) classSide methodsFor: 'instance creation' !
dataSize
"typedef struct _NSRect {
   NSPoint origin;
   NSSize size;
} NSRect;

typedef struct _NSPoint {
   float x;
   float y;
} NSPoint;

typedef struct _NSSize {
   float width;
   float height;
} NSSize;"

	^16! !

"May 16, 2010 -> 2:9:34"!

! (Delta mirrorFor: #NSRect) classSide methodsFor: 'instance creation' !
x: x y: y width: width height: height
	^self new x: x; y: y; width: width; height: height; yourself! !

"May 16, 2010 -> 2:9:49"!

! (Delta mirrorFor: #AlienDemo) methodsFor: 'MacOS examples' !
exampleOpenWindowWithModalAlert
	"AlienDemo new  exampleOpenWindowWithModalAlert" 
	"doesn't work anymore - modal stuff is unstable"
	| NSTitledWindowMask NSClosableWindowMask
	  NSMiniaturizableWindowMask NSResizableWindowMask
	  NSTexturedBackgroundWindowMask
	  NSBackingStoreBuffered
	  app win pool lert rc |
	NSTitledWindowMask:= 1 "<< 0".
	NSClosableWindowMask:= 1 "<<" bitShift: 1.
	NSMiniaturizableWindowMask:= 1 "<<" bitShift: 2.
	NSResizableWindowMask:= 1 "<<" bitShift: 3.
	NSTexturedBackgroundWindowMask:= 1 "<<" bitShift: 8.
	NSBackingStoreBuffered:= 2.

	app:= (ObjectiveCClassAlien lookup: 'NSApplication' inFramework: 'AppKit') sharedApplication.
	pool:= (ObjectiveCClassAlien lookup: 'NSAutoreleasePool' inFramework: 'Foundation') alloc init.

	win:= (ObjectiveCClassAlien lookup: 'NSWindow' inFramework: 'AppKit') alloc
			initWithContentRect: (NSRect x: 250 y: 150 width: 300 height: 200)
			styleMask: NSTitledWindowMask | NSClosableWindowMask | NSMiniaturizableWindowMask
					   | NSResizableWindowMask | NSTexturedBackgroundWindowMask
			backing: NSBackingStoreBuffered
			defer: false asAlien.
	win setTitle: (self makeNSStringFrom: 'Hello!!!!').
	lert:= (ObjectiveCClassAlien lookup: 'NSAlert' inFramework: 'AppKit')
				alertWithMessageText: (self makeNSStringFrom: 'Be Alert!!!!')
				defaultButton: (self makeNSStringFrom: 'Lerts')
				alternateButton: (self makeNSStringFrom: 'We')
				otherButton: (self makeNSStringFrom: 'Need')
				informativeTextWithFormat: (self makeNSStringFrom: 'some %s & %@')
				va: 'text' asAlien pointer
				va: (self makeNSStringFrom: 'string').

	lert beginSheetModalForWindow: win
		modalDelegate: (ObjectiveCSmalltalkObjectProxy for: (MacOSXExampleModalDelegate new forApplication: app))
		didEndSelector: (ObjectiveCAlien asObjectiveCSelector: #alertDidEnd:returnCode:contextInfo:)
		contextInfo: nil asAlien.
	rc:= app runModalForWindow: win.
	win close.
	pool release.
	^rc! !

"May 16, 2010 -> 2:12:30"!

"System saved" !
"May 16, 2010 -> 2:18:27"!

! (Delta mirrorFor: #NSRect) methodsFor: 'accessing' !
x: aFloat
	^self floatAt: 1 put: aFloat! !

"May 16, 2010 -> 2:18:45"!

! (Delta mirrorFor: #NSRect) methodsFor: 'accessing' !
y: aFloat
	^self floatAt: 5 put: aFloat! !

"May 16, 2010 -> 2:19:7"!

! (Delta mirrorFor: #NSRect) methodsFor: 'accessing' !
x
	^self floatAt: 1! !

"May 16, 2010 -> 2:19:10"!

! (Delta mirrorFor: #NSRect) methodsFor: 'accessing' !
y
	^self floatAt: 5! !

"May 16, 2010 -> 2:19:21"!

"System saved" !
"May 16, 2010 -> 2:20:57"!

! (Delta mirrorFor: #AlienDemo) methodsFor: 'MacOS examples' !
exampleOpenWindowWithModalAlert
	"AlienDemo new  exampleOpenWindowWithModalAlert" 
	"doesn't work anymore - modal stuff is unstable"
	| NSTitledWindowMask NSClosableWindowMask
	  NSMiniaturizableWindowMask NSResizableWindowMask
	  NSTexturedBackgroundWindowMask
	  NSBackingStoreBuffered
	  app win pool lert rc |
	NSTitledWindowMask:= 1 "<< 0".
	NSClosableWindowMask:= 1 "<<" bitShift: 1.
	NSMiniaturizableWindowMask:= 1 "<<" bitShift: 2.
	NSResizableWindowMask:= 1 "<<" bitShift: 3.
	NSTexturedBackgroundWindowMask:= 1 "<<" bitShift: 8.
	NSBackingStoreBuffered:= 2.

	app:= (ObjectiveCClassAlien lookup: 'NSApplication' inFramework: 'AppKit') sharedApplication.
	pool:= (ObjectiveCClassAlien lookup: 'NSAutoreleasePool' inFramework: 'Foundation') alloc init.

	win:= (ObjectiveCClassAlien lookup: 'NSWindow' inFramework: 'AppKit') alloc
			initWithContentRect: (NSRect x: 250f y: 150f width: 300f height: 200f)
			styleMask: NSTitledWindowMask | NSClosableWindowMask | NSMiniaturizableWindowMask
					   | NSResizableWindowMask | NSTexturedBackgroundWindowMask
			backing: NSBackingStoreBuffered
			defer: false asAlien.
	win setTitle: (self makeNSStringFrom: 'Hello!!!!').
	lert:= (ObjectiveCClassAlien lookup: 'NSAlert' inFramework: 'AppKit')
				alertWithMessageText: (self makeNSStringFrom: 'Be Alert!!!!')
				defaultButton: (self makeNSStringFrom: 'Lerts')
				alternateButton: (self makeNSStringFrom: 'We')
				otherButton: (self makeNSStringFrom: 'Need')
				informativeTextWithFormat: (self makeNSStringFrom: 'some %s & %@')
				va: 'text' asAlien pointer
				va: (self makeNSStringFrom: 'string').

	lert beginSheetModalForWindow: win
		modalDelegate: (ObjectiveCSmalltalkObjectProxy for: (MacOSXExampleModalDelegate new forApplication: app))
		didEndSelector: (ObjectiveCAlien asObjectiveCSelector: #alertDidEnd:returnCode:contextInfo:)
		contextInfo: nil asAlien.
	rc:= app runModalForWindow: win.
	win close.
	pool release.
	^rc! !

"May 16, 2010 -> 2:21:9"!

"System saved" !
"May 16, 2010 -> 2:21:55"!

! (Delta mirrorFor: #AlienDemo) methodsFor: 'MacOS examples' !
exampleOpenWindowWithModalAlert
	"AlienDemo new  exampleOpenWindowWithModalAlert" 
	"doesn't work anymore - modal stuff is unstable"
	| NSTitledWindowMask NSClosableWindowMask
	  NSMiniaturizableWindowMask NSResizableWindowMask
	  NSTexturedBackgroundWindowMask
	  NSBackingStoreBuffered
	  app win pool lert rc |
	NSTitledWindowMask:= 1 "<< 0".
	NSClosableWindowMask:= 1 "<<" bitShift: 1.
	NSMiniaturizableWindowMask:= 1 "<<" bitShift: 2.
	NSResizableWindowMask:= 1 "<<" bitShift: 3.
	NSTexturedBackgroundWindowMask:= 1 "<<" bitShift: 8.
	NSBackingStoreBuffered:= 2.

	app:= (ObjectiveCClassAlien lookup: 'NSApplication' inFramework: 'AppKit') sharedApplication.
	pool:= (ObjectiveCClassAlien lookup: 'NSAutoreleasePool' inFramework: 'Foundation') alloc init.

	win:= (ObjectiveCClassAlien lookup: 'NSWindow' inFramework: 'AppKit') alloc
			initWithContentRect: (NSRect x: 250.0 y: 150.0 width: 300.0 height: 200.0)
			styleMask: NSTitledWindowMask | NSClosableWindowMask | NSMiniaturizableWindowMask
					   | NSResizableWindowMask | NSTexturedBackgroundWindowMask
			backing: NSBackingStoreBuffered
			defer: false asAlien.
	win setTitle: (self makeNSStringFrom: 'Hello!!!!').
	lert:= (ObjectiveCClassAlien lookup: 'NSAlert' inFramework: 'AppKit')
				alertWithMessageText: (self makeNSStringFrom: 'Be Alert!!!!')
				defaultButton: (self makeNSStringFrom: 'Lerts')
				alternateButton: (self makeNSStringFrom: 'We')
				otherButton: (self makeNSStringFrom: 'Need')
				informativeTextWithFormat: (self makeNSStringFrom: 'some %s & %@')
				va: 'text' asAlien pointer
				va: (self makeNSStringFrom: 'string').

	lert beginSheetModalForWindow: win
		modalDelegate: (ObjectiveCSmalltalkObjectProxy for: (MacOSXExampleModalDelegate new forApplication: app))
		didEndSelector: (ObjectiveCAlien asObjectiveCSelector: #alertDidEnd:returnCode:contextInfo:)
		contextInfo: nil asAlien.
	rc:= app runModalForWindow: win.
	win close.
	pool release.
	^rc! !

"May 16, 2010 -> 2:22:2"!

"System saved" !
"May 16, 2010 -> 2:24:12"!

! (Delta mirrorFor: #AlienDemo) methodsFor: 'MacOS examples' !
exampleOpenWindowWithModalAlert
	"AlienDemo new  exampleOpenWindowWithModalAlert" 
	"doesn't work anymore - modal stuff is unstable"
	| NSTitledWindowMask NSClosableWindowMask
	  NSMiniaturizableWindowMask NSResizableWindowMask
	  NSTexturedBackgroundWindowMask
	  NSBackingStoreBuffered
	  app win pool lert rc |
	NSTitledWindowMask:= 1 "<< 0".
	NSClosableWindowMask:= 1 "<<" bitShift: 1.
	NSMiniaturizableWindowMask:= 1 "<<" bitShift: 2.
	NSResizableWindowMask:= 1 "<<" bitShift: 3.
	NSTexturedBackgroundWindowMask:= 1 "<<" bitShift: 8.
	NSBackingStoreBuffered:= 2.

	app:= (ObjectiveCClassAlien lookup: 'NSApplication' inFramework: 'AppKit') sharedApplication.
	pool:= (ObjectiveCClassAlien lookup: 'NSAutoreleasePool' inFramework: 'Foundation') alloc init.

	win:= (ObjectiveCClassAlien lookup: 'NSWindow' inFramework: 'AppKit') alloc
			initWithContentRect: (NSRect x: 250.0 y: 150.0 width: 300.0 height: 200.0)
			styleMask: NSTitledWindowMask "|" + NSClosableWindowMask "|"+ NSMiniaturizableWindowMask
					   "|" + NSResizableWindowMask "|" + NSTexturedBackgroundWindowMask
			backing: NSBackingStoreBuffered
			defer: false asAlien.
	win setTitle: (self makeNSStringFrom: 'Hello!!!!').
	lert:= (ObjectiveCClassAlien lookup: 'NSAlert' inFramework: 'AppKit')
				alertWithMessageText: (self makeNSStringFrom: 'Be Alert!!!!')
				defaultButton: (self makeNSStringFrom: 'Lerts')
				alternateButton: (self makeNSStringFrom: 'We')
				otherButton: (self makeNSStringFrom: 'Need')
				informativeTextWithFormat: (self makeNSStringFrom: 'some %s & %@')
				va: 'text' asAlien pointer
				va: (self makeNSStringFrom: 'string').

	lert beginSheetModalForWindow: win
		modalDelegate: (ObjectiveCSmalltalkObjectProxy for: (MacOSXExampleModalDelegate new forApplication: app))
		didEndSelector: (ObjectiveCAlien asObjectiveCSelector: #alertDidEnd:returnCode:contextInfo:)
		contextInfo: nil asAlien.
	rc:= app runModalForWindow: win.
	win close.
	pool release.
	^rc! !

"May 16, 2010 -> 2:24:30"!

"System saved" !
"May 16, 2010 -> 2:26:36"!

! (Delta mirrorFor: #ObjectiveCClassAlien) classSide methodsFor: 'coercing' !
makeNSStringFrom: string <String>
	| NSString |
	NSString := self lookup: 'NSString' inFramework: 'Foundation'.
	^string isEmpty
		ifTrue: [NSString string]
		ifFalse: ["NSString alloc initWithUTF8String: string isoToUtf8 asAlien pointer"
			NSString alloc initWithCString: string asAlien pointer encoding: 1]! !

"May 16, 2010 -> 2:26:50"!

"System saved" !
"May 16, 2010 -> 2:28:29"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) methodsFor: 'message forwarding' !
forward: anObjectiveCSelectorAlien to: aSmalltalkObject with: anObjectiveCMArgs "^<Object>"
	| smalltalkSelector args method pragmas |
	smalltalkSelector := anObjectiveCSelectorAlien asSmalltalkSelector.
	args :=  ObjectiveCAlien
				argumentListFromMArgs: anObjectiveCMArgs
				numArgs: smalltalkSelector numArgs
				withSignature: (((method := aSmalltalkObject class lookupSelector: smalltalkSelector) notNil
								and: [(pragmas := method pragmas select: [:p| p keyword == #objectiveCSignature:]) notEmpty])
									ifTrue: [pragmas anyOne arguments first]
									ifFalse: [String new: smalltalkSelector numArgs withAll: $S]).
	^aSmalltalkObject
		perform: smalltalkSelector
		withArguments: args! !

"May 16, 2010 -> 2:28:29"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) methodsFor: 'instance initalization' !
initialize
	ObjectiveCSmalltalkProxyClassAlien ifNil: "acts as initialization flag."
		[self class installSmalltalkProxyClass].
	self isa: ObjectiveCSmalltalkProxyClassAlien! !

"May 16, 2010 -> 2:28:30"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) methodsFor: 'memory management' !
release
	| pair |
	pair := AddressToBothInstancesMap removeKey: self addressField ifAbsent: [].
	SmalltalkToObjectiveCInstanceMap removeKey: pair last ifAbsent: []
	self free! !

"May 16, 2010 -> 2:28:30"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'instance creation' !
dataSize
"/*
   *  Class Template
   */
struct ObjectiveCSmalltalkProxy {
    struct objc_class *isa;
};"
	^4! !

"May 16, 2010 -> 2:28:30"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'instance creation' !
for: anObject "<Object> ^<ObjectiveCSmalltalkObjectProxy>"
	^SmalltalkToObjectiveCInstanceMap
		at: anObject
		ifAbsentPut:
			[| proxy |
			AddressToBothInstancesMap
				at: (proxy := self new) addressField
				put: {proxy. anObject}.
			proxy]! !

"May 16, 2010 -> 2:28:30"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'instance creation' !
new "^<ObjectiveCSmalltalkObjectProxy>"
	^(self forPointer: (self Cmalloc: self dataSize)) initialize! !

"May 16, 2010 -> 2:28:30"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'instance creation' !
new: dataSize "<Integer>"
	"Use for: instead"
	self shouldNotImplement! !

"May 16, 2010 -> 2:28:30"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'instance creation' !
newC: dataSize "<Integer>"
	"Use for: instead"
	self shouldNotImplement! !

"May 16, 2010 -> 2:28:30"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'class initialization' !
ensureNotifiedAtStartup
	"ObjectiveCSmalltalkProxy needs to be notified at system startup to initialize elements of the Objective-C ABI."
	self ~~ ObjectiveCSmalltalkObjectProxy ifTrue: [^self].
	self ensureNotifiedAtStartupAfter: ObjectiveCClass! !

"May 16, 2010 -> 2:28:30"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'class initialization' !
initialize
	"self initialize"
	self ensureNotifiedAtStartup.
	self startUp: true! !

"May 16, 2010 -> 2:28:30"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'Object'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :resultAlien| | pair result |
											pair := AddressToBothInstancesMap at: args receiverAddress.
											result := pair first forward: args selector to: pair last with: args args.
											resultAlien returnInteger: (self for: result) addressField]
									argsClass: ObjectiveCForwardSignature.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forward::')
				implementation: SendbackCallback thunk
				signature: '@@::^v'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"May 16, 2010 -> 2:28:30"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
startUp: resuming
	"Partially initialize, clearing the mapping tables.
	Leave installing the proxy class to the instance side's intialize
	method, hence making initialization as lazy as possible."

	"ObjectiveCSmalltalkObjectProxy startUp: true"
	resuming ifFalse: [^self].
	AddressToBothInstancesMap := Dictionary new.
	SmalltalkToObjectiveCInstanceMap := IdentityDictionary new.
	ObjectiveCSmalltalkProxyClassAlien := nil. "acts as initialization flag."
	"This code now moved to ObjectiveCSmalltalkObjectProxy>>initialize."
	"SmalltalkImage current platformName = 'Mac OS' ifFalse: [^self].
	self installSmalltalkProxyClass"! !

"May 16, 2010 -> 14:46:38"!

(Delta mirrorFor: #ObjectiveCSmalltalkProxyClassAlien) removeDefinitionIfFail: [] !


"May 16, 2010 -> 14:46:48"!

(Delta mirrorFor: #AddressToBothInstancesMap) removeDefinitionIfFail: [] !


"May 16, 2010 -> 14:46:56"!

(Delta mirrorFor: #SmalltalkToObjectiveCInstanceMap) removeDefinitionIfFail: [] !


"May 16, 2010 -> 14:47:4"!

(Delta mirrorFor: #SendbackCallback) removeDefinitionIfFail: [] !


"May 16, 2010 -> 14:47:12"!

(Delta mirrorFor: #ObjectiveCForwardSignature) removeDefinitionIfFail: [] !


"May 16, 2010 -> 14:48:36"!

Delta define: #ObjectiveCForwardSignature as: (
(Class subclassOf: 'Alien' instanceVariables: '')) !


"May 16, 2010 -> 14:49:35"!

Delta define: #ObjectiveCMethodList as: (
(Class subclassOf: 'Alien' instanceVariables: '')) !


"May 16, 2010 -> 14:52:10"!

! (Delta mirrorFor: #ObjectiveCForwardSignature) methodsFor: 'accessing' !
args
	^ObjectiveCMArgs forPointer: (self unsignedLongAt: 13)! !

"May 16, 2010 -> 14:52:10"!

! (Delta mirrorFor: #ObjectiveCForwardSignature) methodsFor: 'accessing' !
receiverAddress
	^self unsignedLongAt: 1! !

"May 16, 2010 -> 14:52:10"!

! (Delta mirrorFor: #ObjectiveCForwardSignature) methodsFor: 'accessing' !
selector
	^ObjectiveCAlien new
		unsignedLongAt: 1 put: (self unsignedLongAt: 9);
		yourself! !

"May 16, 2010 -> 14:52:18"!

! (Delta mirrorFor: #ObjectiveCForwardSignature) classSide methodsFor: 'instance creation' !
dataSize
	"- forward: (SEL)sel : (marg_list)args
	 == forward(id receiver, SEL forwardSel, SEL selectorToForward, marg_list args)"
	^16! !

"May 16, 2010 -> 14:53:54"!

! (Delta mirrorFor: #ObjectiveCMethodList) methodsFor: 'accessing' !
method: oneRelativeIndex "<Integer>" put: method "<ObjectiveCMethod>"
	| methodsBaseIndex |
	methodsBaseIndex := 9 + (oneRelativeIndex - 1 * ObjectiveCMethod dataSize).
	self
		unsignedLongAt: methodsBaseIndex put: (method unsignedLongAt: 1);
		unsignedLongAt: methodsBaseIndex + 4 put: (method unsignedLongAt: 5);
		unsignedLongAt: methodsBaseIndex + 8 put: (method unsignedLongAt: 9).! !

"May 16, 2010 -> 14:53:54"!

! (Delta mirrorFor: #ObjectiveCMethodList) methodsFor: 'accessing' !
methodCount
	^self signedLongAt: 5! !

"May 16, 2010 -> 14:53:54"!

! (Delta mirrorFor: #ObjectiveCMethodList) methodsFor: 'accessing' !
methodCount: anInteger
	self signedLongAt: 5 put: anInteger! !

"May 16, 2010 -> 14:54:11"!

! (Delta mirrorFor: #ObjectiveCMethodList) classSide methodsFor: 'instance creation' !
dataSize
	^20
	
"struct objc_method_list {
    struct objc_method_list *obsolete;

    int method_count;
#ifdef __alpha__
    int space;
#endif
    struct objc_method method_list[1];  /* variable length structure */
};
"! !

"May 16, 2010 -> 14:54:52"!

(Delta mirrorFor: #ObjectiveCObject)
comment: 
'Access to the raw structure of an ObjectiveC object.  Do not confuse this with ObjectiveCAlien, wich is a Smalltalk proxy for an ObjectiveC object.  This is an indirect object (a struct, if you like); ObjectiveCAlien is a direct pointer to an object (a reference to an Objective-C object).

@interface Object
{
    Class isa;  /* A pointer to the instance''s class structure */
}

Effectively:
struct objc_object {
    struct objc_class *isa;
};


   Copyright 2008 Cadence Design Systems, Inc.
   
   Licensed under the Apache License, Version 2.0 (the ''''License''''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0
'!


"May 16, 2010 -> 14:54:52"!

! (Delta mirrorFor: #ObjectiveCObject) methodsFor: 'accessing' !
isa
	| address |
	^(address := self unsignedLongAt: 1) = 0 ifFalse:
		[ObjectiveCClass atAddress: address]! !

"May 16, 2010 -> 14:54:52"!

! (Delta mirrorFor: #ObjectiveCObject) methodsFor: 'accessing' !
isa: anObjectiveCClassAlienOrNil
	self unsignedLongAt: 1 put: anObjectiveCClassAlienOrNil id! !

"May 16, 2010 -> 14:54:52"!

! (Delta mirrorFor: #ObjectiveCObject) methodsFor: 'coercing' !
id
	"Answer the receiver's id. This coerces direct, pointer and indirect ObjectiveC objects correctly."
	^self addressField! !

"May 16, 2010 -> 14:55:8"!

! (Delta mirrorFor: #ObjectiveCObject) classSide methodsFor: 'instance creation' !
dataSize
	^4! !

"May 16, 2010 -> 14:55:27"!

(Delta mirrorFor: #ObjectiveCClass)
comment: 
'/*
 *  Class Template
 */
struct objc_class {
    struct objc_class *isa;
    struct objc_class *super_class;
    const char *name;
    long version;
    long info;
    long instance_size;
    struct objc_ivar_list *ivars;

    struct objc_method_list **methodLists;

    struct objc_cache *cache;
    struct objc_protocol_list *protocols;
};


   Copyright 2008 Cadence Design Systems, Inc.
   
   Licensed under the Apache License, Version 2.0 (the ''''License''''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0
'!


"May 16, 2010 -> 14:55:27"!

! (Delta mirrorFor: #ObjectiveCClass) methodsFor: 'accessing' !
info: anInteger 
	self signedLongAt: 17 put: anInteger! !

"May 16, 2010 -> 14:55:27"!

! (Delta mirrorFor: #ObjectiveCClass) methodsFor: 'accessing' !
instanceSize
	^self signedLongAt: 21! !

"May 16, 2010 -> 14:55:27"!

! (Delta mirrorFor: #ObjectiveCClass) methodsFor: 'accessing' !
instanceSize: anInteger 
	self signedLongAt: 21 put: anInteger! !

"May 16, 2010 -> 14:55:27"!

! (Delta mirrorFor: #ObjectiveCClass) methodsFor: 'accessing' !
methodLists: anAlien "<ObjectiveCMethodLists>" 
	self unsignedLongAt: 29 put: anAlien address! !

"May 16, 2010 -> 14:55:27"!

! (Delta mirrorFor: #ObjectiveCClass) methodsFor: 'accessing' !
objectiveCname "^<Alien char *>"
	^Alien
		atAddress: (self unsignedLongAt: 9)
		dataSize: (self strlenThroughPointerAt: 9) + 1! !

"May 16, 2010 -> 14:55:27"!

! (Delta mirrorFor: #ObjectiveCClass) methodsFor: 'accessing' !
objectiveCname: anAlienOrString
	self unsignedLongAt: 9 put: anAlienOrString asAlien address! !

"May 16, 2010 -> 14:55:27"!

! (Delta mirrorFor: #ObjectiveCClass) methodsFor: 'accessing' !
superclass
	| address |
	^(address := self unsignedLongAt: 5) = 0 ifFalse:
		[ObjectiveCClass atAddress: address]! !

"May 16, 2010 -> 14:55:27"!

! (Delta mirrorFor: #ObjectiveCClass) methodsFor: 'accessing' !
superclass: anAlienOrNil
	self unsignedLongAt: 5 put: (anAlienOrNil isNil ifTrue: [0] ifFalse: [anAlienOrNil address])! !

"May 16, 2010 -> 14:55:27"!

! (Delta mirrorFor: #ObjectiveCClass) methodsFor: 'method dictionary' !
addMethod: selector "<Alien>" implementation: functionPointer "<FFICallbackThunk|Alien>"  signature: signature "<String>" 
	ObjcAddMethodAlien notNil
		ifTrue: [self rt2addMethod: selector "<Alien>" implementation: functionPointer  signature: signature]
		ifFalse: [self rt1addMethod: selector "<Alien>" implementation: functionPointer  signature: signature]! !

"May 16, 2010 -> 14:55:27"!

! (Delta mirrorFor: #ObjectiveCClass) methodsFor: 'method dictionary' !
rt1addMethod: selector "<Alien>" implementation: functionPointer "<FFICallbackThunk|Alien>" signature: signature "<String>" 
	| methodList |
	methodList := ObjectiveCMethodList newC
						methodCount: 1;
						method: 1 put: (ObjectiveCMethod new
											selector: selector
											methodTypes: (ObjectiveCAlien encodeSimpleSignature: signature) asAlien
											implementation: functionPointer).
	ObjcAddMethodsAlien
		primFFICallResult: nil
		with: self address
		with: methodList address! !

"May 16, 2010 -> 14:55:27"!

! (Delta mirrorFor: #ObjectiveCClass) methodsFor: 'method dictionary' !
rt2addMethod: selector "<Alien>" implementation: functionPointer "<FFICallbackThunk|Alien>" signature: signature "<String>" 
	| boolAlien |
	ObjcAddMethodAlien
		primFFICallResult: (boolAlien := Alien new: 4)
		with: self
		with: selector
		with: signature asAlien.
	(boolAlien unsignedLongAt: 1) = 0 ifTrue:
		[self error: 'class_addMethod failed']! !

"May 16, 2010 -> 14:55:27"!

! (Delta mirrorFor: #ObjectiveCClass) methodsFor: 'coercing' !
asObjectiveCClassAlien
	"Answer an ObjectiveC object for the receiver's struct objc_class."
	^ObjectiveCClassAlien atAddress: self address! !

"May 16, 2010 -> 14:56:23"!

! (Delta mirrorFor: #ObjectiveCClass) classSide methodsFor: 'system startup' !
startUp: resuming
	(resuming
	and: [OSProcess isUnixMac]) ifFalse: [^self].

	"info flags"
	CLSCLASS := 16r1.
	CLSMETA := 16r2.
	"CLSINITIALIZED := 16r4.
	CLSPOSING  := 16r8.
	CLSMAPPED  := 16r10.
	CLSFLUSHCACHE := 16r20.
	CLSGROWCACHE  := 16r40.
	CLSNEEDBIND   := 16r80.
	CLSMETHODARRAY    := 16r100."


	"Objective-C 2.0 runtime (Leopard)"
	ObjcAllocateClassPairAlien := self lookupOrNil: 'objc_allocateClassPair' inLibrary: '/usr/lib/libobjc.dylib'.
	ObjcRegisterClassPairAlien := self lookupOrNil: 'objc_registerClassPair' inLibrary: '/usr/lib/libobjc.dylib'.
	ObjcAddMethodAlien := self lookupOrNil: 'class_addMethod' inLibrary: '/usr/lib/libobjc.dylib'.
	"Objective-C 1.0 runtime (Tiger)"
	ObjcAddClassAlien := self lookupOrNil: 'objc_addClass' inLibrary: '/usr/lib/libobjc.dylib'.
	ObjcAddMethodsAlien := self lookupOrNil: 'class_addMethods' inLibrary: '/usr/lib/libobjc.dylib'.! !

"May 16, 2010 -> 14:56:23"!

! (Delta mirrorFor: #ObjectiveCClass) classSide methodsFor: 'instance creation' !
dataSize
	^40

"/*
 *  Class Template
 */
struct objc_class {
    struct objc_class *isa;
    struct objc_class *super_class;
    const char *name;
    long version;
    long info;
    long instance_size;
    struct objc_ivar_list *ivars;

    struct objc_method_list **methodLists;

    struct objc_cache *cache;
    struct objc_protocol_list *protocols;
};"! !

"May 16, 2010 -> 14:56:23"!

! (Delta mirrorFor: #ObjectiveCClass) classSide methodsFor: 'class creation' !
createClassDefinitionOnRuntimeOneNamed: className "<String>" superclassName: superclassName "<String> ^<nil | Array of: ObjectiveCClass>"
	"Objective-C 1.0 version of creating a class (10.4 and prior).
	 See CreateClassDefinition in`Objective-C 1 Runtime Reference'.
	 In Leopard, which has the Objective-C 2.0 run-time, we can simply use objc_allocateClassPair."
	| supercls newClass newMetaclass rootClass |

	(supercls := ObjectiveCClassAlien lookup: superclassName) ifNil: [^nil].
	supercls := supercls asObjectiveCClass.
	(ObjectiveCClassAlien lookup: className) ifNotNil: [^nil].

	rootClass := supercls.
	[rootClass superclass notNil] whileTrue:
		[rootClass := rootClass superclass].

	newClass := self newC.
	newMetaclass := self newC.
	newClass isa: newMetaclass.
	newMetaclass isa: rootClass isa.
	newClass info: CLSCLASS.
	newMetaclass info: CLSMETA.
	newClass objectiveCname: className.
	newMetaclass  objectiveCname: newClass objectiveCname.
	newClass methodLists: ((Alien newC: 4) signedLongAt: 1 put: -1; yourself).
	newMetaclass methodLists: ((Alien newC: 4) signedLongAt: 1 put: -1; yourself).
	newClass superclass: supercls.
	newMetaclass superclass: supercls isa.
	newClass instanceSize: supercls instanceSize.
	newMetaclass instanceSize: newMetaclass superclass instanceSize.

	ObjcAddClassAlien
		primFFICallResult: nil
		with: newClass address.

	^Array with: newClass with: newMetaclass! !

"May 16, 2010 -> 14:56:23"!

! (Delta mirrorFor: #ObjectiveCClass) classSide methodsFor: 'class creation' !
createClassNamed: className "<String>" superclass: superclassName "<String>" into: binaryBlock "<[:class <ObjectiveCClass> :metaclass <ObjectiveCClass>| <^Type>]> ^<Type>"
	| classPairOrNil classAlien classStruct |
	ObjcAllocateClassPairAlien isNil ifTrue:
		["objc_allocateClasPair unavailable.  use the 1.0 run-time"
		  classPairOrNil := self createClassDefinitionOnRuntimeOneNamed: className "<String>" superclassName: superclassName.
		 ^classPairOrNil isNil
			ifTrue: [self error: 'Could not create class']
			ifFalse: [binaryBlock valueWithArguments: classPairOrNil]].

	"Use the 2.0 run-time."
	classAlien := ObjcAllocateClassPairAlien
						primFFICallResult: ObjectiveCClassAlien new
						with: className asAlien
						with: superclassName asAlien.
	^classAlien addressField = 0
		ifTrue: [self error: 'Could not create class']
		ifFalse:
			[classStruct := classAlien asObjectiveCClass.
			 binaryBlock value: classStruct with: classAlien isa asObjectiveCClass]! !

"May 16, 2010 -> 14:56:23"!

! (Delta mirrorFor: #ObjectiveCClass) classSide methodsFor: 'class initialization' !
ensureNotifiedAtStartup
	"ObjectiveCClass needs to be notified at system startup to initialize elements of the Objective-C ABI."
	self ~~ ObjectiveCClass ifTrue: [^self].
	self ensureNotifiedAtStartupAfter: ObjectiveCAlien! !

"May 16, 2010 -> 14:56:23"!

! (Delta mirrorFor: #ObjectiveCClass) classSide methodsFor: 'class initialization' !
initialize
	"self initialize"
	self ensureNotifiedAtStartup.
	self startUp: true! !

"May 16, 2010 -> 14:57:26"!

Delta define: #ObjectiveCClass as: (
(Class subclassOf: 'ObjectiveCObject' instanceVariables: '') classVariables: 'CLSCLASS CLSMETA ObjcAddClassAlien ObjcAddMethodAlien ObjcAddMethodsAlien ObjcAllocateClassPairAlien ObjcRegisterClassPairAlien') !


"May 16, 2010 -> 14:57:35"!

(Delta mirrorFor: #ObjcAddMethodAlien) removeDefinitionIfFail: [] !


"May 16, 2010 -> 14:57:42"!

(Delta mirrorFor: #ObjcAddMethodsAlien) removeDefinitionIfFail: [] !


"May 16, 2010 -> 14:57:59"!

(Delta mirrorFor: #CLSCLASS) removeDefinitionIfFail: [] !


"May 16, 2010 -> 14:58:9"!

(Delta mirrorFor: #CLSMETA) removeDefinitionIfFail: [] !


"May 16, 2010 -> 14:58:29"!

(Delta mirrorFor: #ObjcAllocateClassPairAlien) removeDefinitionIfFail: [] !


"May 16, 2010 -> 14:58:38"!

(Delta mirrorFor: #ObjcRegisterClassPairAlien) removeDefinitionIfFail: [] !


"May 16, 2010 -> 14:58:50"!

(Delta mirrorFor: #ObjcAddClassAlien) removeDefinitionIfFail: [] !


"May 16, 2010 -> 14:59:29"!

! (Delta mirrorFor: #ObjectiveCClass) classSide methodsFor: 'system startup' !
startUp: resuming
	"(resuming
	and: [OSProcess isUnixMac]) ifFalse: [^self]."

	"info flags"
	CLSCLASS := 16r1.
	CLSMETA := 16r2.
	"CLSINITIALIZED := 16r4.
	CLSPOSING  := 16r8.
	CLSMAPPED  := 16r10.
	CLSFLUSHCACHE := 16r20.
	CLSGROWCACHE  := 16r40.
	CLSNEEDBIND   := 16r80.
	CLSMETHODARRAY    := 16r100."


	"Objective-C 2.0 runtime (Leopard)"
	ObjcAllocateClassPairAlien := self lookupOrNil: 'objc_allocateClassPair' inLibrary: '/usr/lib/libobjc.dylib'.
	ObjcRegisterClassPairAlien := self lookupOrNil: 'objc_registerClassPair' inLibrary: '/usr/lib/libobjc.dylib'.
	ObjcAddMethodAlien := self lookupOrNil: 'class_addMethod' inLibrary: '/usr/lib/libobjc.dylib'.
	"Objective-C 1.0 runtime (Tiger)"
	ObjcAddClassAlien := self lookupOrNil: 'objc_addClass' inLibrary: '/usr/lib/libobjc.dylib'.
	ObjcAddMethodsAlien := self lookupOrNil: 'class_addMethods' inLibrary: '/usr/lib/libobjc.dylib'.! !

"May 16, 2010 -> 15:1:15"!

! (Delta mirrorFor: #ObjectiveCClass) methodsFor: 'accessing' !
info: anInteger 
	self signedLongAt: 17 put: anInteger! !

"May 16, 2010 -> 15:1:15"!

! (Delta mirrorFor: #ObjectiveCClass) methodsFor: 'accessing' !
instanceSize
	^self signedLongAt: 21! !

"May 16, 2010 -> 15:1:15"!

! (Delta mirrorFor: #ObjectiveCClass) methodsFor: 'accessing' !
instanceSize: anInteger 
	self signedLongAt: 21 put: anInteger! !

"May 16, 2010 -> 15:1:15"!

! (Delta mirrorFor: #ObjectiveCClass) methodsFor: 'accessing' !
methodLists: anAlien "<ObjectiveCMethodLists>" 
	self unsignedLongAt: 29 put: anAlien address! !

"May 16, 2010 -> 15:1:15"!

! (Delta mirrorFor: #ObjectiveCClass) methodsFor: 'accessing' !
objectiveCname "^<Alien char *>"
	^Alien
		atAddress: (self unsignedLongAt: 9)
		dataSize: (self strlenThroughPointerAt: 9) + 1! !

"May 16, 2010 -> 15:1:15"!

! (Delta mirrorFor: #ObjectiveCClass) methodsFor: 'accessing' !
objectiveCname: anAlienOrString
	self unsignedLongAt: 9 put: anAlienOrString asAlien address! !

"May 16, 2010 -> 15:1:15"!

! (Delta mirrorFor: #ObjectiveCClass) methodsFor: 'accessing' !
superclass
	| address |
	^(address := self unsignedLongAt: 5) = 0 ifFalse:
		[ObjectiveCClass atAddress: address]! !

"May 16, 2010 -> 15:1:15"!

! (Delta mirrorFor: #ObjectiveCClass) methodsFor: 'accessing' !
superclass: anAlienOrNil
	self unsignedLongAt: 5 put: (anAlienOrNil isNil ifTrue: [0] ifFalse: [anAlienOrNil address])! !

"May 16, 2010 -> 15:1:15"!

! (Delta mirrorFor: #ObjectiveCClass) methodsFor: 'method dictionary' !
addMethod: selector "<Alien>" implementation: functionPointer "<FFICallbackThunk|Alien>"  signature: signature "<String>" 
	ObjcAddMethodAlien notNil
		ifTrue: [self rt2addMethod: selector "<Alien>" implementation: functionPointer  signature: signature]
		ifFalse: [self rt1addMethod: selector "<Alien>" implementation: functionPointer  signature: signature]! !

"May 16, 2010 -> 15:1:15"!

! (Delta mirrorFor: #ObjectiveCClass) methodsFor: 'method dictionary' !
rt1addMethod: selector "<Alien>" implementation: functionPointer "<FFICallbackThunk|Alien>" signature: signature "<String>" 
	| methodList |
	methodList := ObjectiveCMethodList newC
						methodCount: 1;
						method: 1 put: (ObjectiveCMethod new
											selector: selector
											methodTypes: (ObjectiveCAlien encodeSimpleSignature: signature) asAlien
											implementation: functionPointer).
	ObjcAddMethodsAlien
		primFFICallResult: nil
		with: self address
		with: methodList address! !

"May 16, 2010 -> 15:1:15"!

! (Delta mirrorFor: #ObjectiveCClass) methodsFor: 'method dictionary' !
rt2addMethod: selector "<Alien>" implementation: functionPointer "<FFICallbackThunk|Alien>" signature: signature "<String>" 
	| boolAlien |
	ObjcAddMethodAlien
		primFFICallResult: (boolAlien := Alien new: 4)
		with: self
		with: selector
		with: signature asAlien.
	(boolAlien unsignedLongAt: 1) = 0 ifTrue:
		[self error: 'class_addMethod failed']! !

"May 16, 2010 -> 15:1:15"!

! (Delta mirrorFor: #ObjectiveCClass) methodsFor: 'coercing' !
asObjectiveCClassAlien
	"Answer an ObjectiveC object for the receiver's struct objc_class."
	^ObjectiveCClassAlien atAddress: self address! !

"May 16, 2010 -> 15:2:0"!

! (Delta mirrorFor: #ObjectiveCClass) classSide methodsFor: 'instance creation' !
dataSize
	^40

"/*
 *  Class Template
 */
struct objc_class {
    struct objc_class *isa;
    struct objc_class *super_class;
    const char *name;
    long version;
    long info;
    long instance_size;
    struct objc_ivar_list *ivars;

    struct objc_method_list **methodLists;

    struct objc_cache *cache;
    struct objc_protocol_list *protocols;
};"! !

"May 16, 2010 -> 15:2:0"!

! (Delta mirrorFor: #ObjectiveCClass) classSide methodsFor: 'class creation' !
createClassDefinitionOnRuntimeOneNamed: className "<String>" superclassName: superclassName "<String> ^<nil | Array of: ObjectiveCClass>"
	"Objective-C 1.0 version of creating a class (10.4 and prior).
	 See CreateClassDefinition in`Objective-C 1 Runtime Reference'.
	 In Leopard, which has the Objective-C 2.0 run-time, we can simply use objc_allocateClassPair."
	| supercls newClass newMetaclass rootClass |

	(supercls := ObjectiveCClassAlien lookup: superclassName) ifNil: [^nil].
	supercls := supercls asObjectiveCClass.
	(ObjectiveCClassAlien lookup: className) ifNotNil: [^nil].

	rootClass := supercls.
	[rootClass superclass notNil] whileTrue:
		[rootClass := rootClass superclass].

	newClass := self newC.
	newMetaclass := self newC.
	newClass isa: newMetaclass.
	newMetaclass isa: rootClass isa.
	newClass info: CLSCLASS.
	newMetaclass info: CLSMETA.
	newClass objectiveCname: className.
	newMetaclass  objectiveCname: newClass objectiveCname.
	newClass methodLists: ((Alien newC: 4) signedLongAt: 1 put: -1; yourself).
	newMetaclass methodLists: ((Alien newC: 4) signedLongAt: 1 put: -1; yourself).
	newClass superclass: supercls.
	newMetaclass superclass: supercls isa.
	newClass instanceSize: supercls instanceSize.
	newMetaclass instanceSize: newMetaclass superclass instanceSize.

	ObjcAddClassAlien
		primFFICallResult: nil
		with: newClass address.

	^Array with: newClass with: newMetaclass! !

"May 16, 2010 -> 15:2:0"!

! (Delta mirrorFor: #ObjectiveCClass) classSide methodsFor: 'class creation' !
createClassNamed: className "<String>" superclass: superclassName "<String>" into: binaryBlock "<[:class <ObjectiveCClass> :metaclass <ObjectiveCClass>| <^Type>]> ^<Type>"
	| classPairOrNil classAlien classStruct |
	ObjcAllocateClassPairAlien isNil ifTrue:
		["objc_allocateClasPair unavailable.  use the 1.0 run-time"
		  classPairOrNil := self createClassDefinitionOnRuntimeOneNamed: className "<String>" superclassName: superclassName.
		 ^classPairOrNil isNil
			ifTrue: [self error: 'Could not create class']
			ifFalse: [binaryBlock valueWithArguments: classPairOrNil]].

	"Use the 2.0 run-time."
	classAlien := ObjcAllocateClassPairAlien
						primFFICallResult: ObjectiveCClassAlien new
						with: className asAlien
						with: superclassName asAlien.
	^classAlien addressField = 0
		ifTrue: [self error: 'Could not create class']
		ifFalse:
			[classStruct := classAlien asObjectiveCClass.
			 binaryBlock value: classStruct with: classAlien isa asObjectiveCClass]! !

"May 16, 2010 -> 15:2:0"!

! (Delta mirrorFor: #ObjectiveCClass) classSide methodsFor: 'class initialization' !
ensureNotifiedAtStartup
	"ObjectiveCClass needs to be notified at system startup to initialize elements of the Objective-C ABI."
	self ~~ ObjectiveCClass ifTrue: [^self].
	self ensureNotifiedAtStartupAfter: ObjectiveCAlien! !

"May 16, 2010 -> 15:2:0"!

! (Delta mirrorFor: #ObjectiveCClass) classSide methodsFor: 'class initialization' !
initialize
	"self initialize"
	self ensureNotifiedAtStartup.
	self startUp: true! !

"May 16, 2010 -> 15:2:30"!

Delta define: #ObjectiveCSmalltalkObjectProxy as: (
(Class subclassOf: 'ObjectiveCObject' instanceVariables: '') classVariables: 'AddressToBothInstancesMap ObjectiveCSmalltalkProxyClassAlien SendbackCallback SmalltalkToObjectiveCInstanceMap') !


"May 16, 2010 -> 15:2:53"!

(Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy)
comment: 
'This class handles forwarding messages from Objective-C back into Smalltalk.  It creates a class in Objective-C that has a forward: instance method. Its instances exist only in Objective-C.  The class variable AddressToBothInstancesMap is keyed by Objective-C instance address and has pairs of {ObjectiveCSmalltalkObjectProxy, Smalltalk object} as instances.  The Objective-C methods (forward: and ...) of ObjectiveCSmalltalkProxy are FFI callbacks.

/*
 *  Class Template
 */
struct ObjectiveCSmalltalkProxy {
    struct objc_class *isa;
};


   Copyright 2008 Cadence Design Systems, Inc.
   
   Licensed under the Apache License, Version 2.0 (the ''''License''''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0
'!


"May 16, 2010 -> 15:2:53"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) methodsFor: 'message forwarding' !
forward: anObjectiveCSelectorAlien to: aSmalltalkObject with: anObjectiveCMArgs "^<Object>"
	| smalltalkSelector args method pragmas |
	smalltalkSelector := anObjectiveCSelectorAlien asSmalltalkSelector.
	args :=  ObjectiveCAlien
				argumentListFromMArgs: anObjectiveCMArgs
				numArgs: smalltalkSelector numArgs
				withSignature: (((method := aSmalltalkObject class lookupSelector: smalltalkSelector) notNil
								and: [(pragmas := method pragmas select: [:p| p keyword == #objectiveCSignature:]) notEmpty])
									ifTrue: [pragmas anyOne arguments first]
									ifFalse: [String new: smalltalkSelector numArgs withAll: $S]).
	^aSmalltalkObject
		perform: smalltalkSelector
		withArguments: args! !

"May 16, 2010 -> 15:2:53"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) methodsFor: 'instance initalization' !
initialize
	ObjectiveCSmalltalkProxyClassAlien ifNil: "acts as initialization flag."
		[self class installSmalltalkProxyClass].
	self isa: ObjectiveCSmalltalkProxyClassAlien! !

"May 16, 2010 -> 15:2:53"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) methodsFor: 'memory management' !
release
	| pair |
	pair := AddressToBothInstancesMap removeKey: self addressField ifAbsent: [].
	SmalltalkToObjectiveCInstanceMap removeKey: pair last ifAbsent: []
	self free! !

"May 16, 2010 -> 15:3:21"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'instance creation' !
dataSize
"/*
   *  Class Template
   */
struct ObjectiveCSmalltalkProxy {
    struct objc_class *isa;
};"
	^4! !

"May 16, 2010 -> 15:3:21"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'instance creation' !
for: anObject "<Object> ^<ObjectiveCSmalltalkObjectProxy>"
	^SmalltalkToObjectiveCInstanceMap
		at: anObject
		ifAbsentPut:
			[| proxy |
			AddressToBothInstancesMap
				at: (proxy := self new) addressField
				put: {proxy. anObject}.
			proxy]! !

"May 16, 2010 -> 15:3:21"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'instance creation' !
new "^<ObjectiveCSmalltalkObjectProxy>"
	^(self forPointer: (self Cmalloc: self dataSize)) initialize! !

"May 16, 2010 -> 15:3:21"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'instance creation' !
new: dataSize "<Integer>"
	"Use for: instead"
	self shouldNotImplement! !

"May 16, 2010 -> 15:3:21"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'instance creation' !
newC: dataSize "<Integer>"
	"Use for: instead"
	self shouldNotImplement! !

"May 16, 2010 -> 15:3:21"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'class initialization' !
ensureNotifiedAtStartup
	"ObjectiveCSmalltalkProxy needs to be notified at system startup to initialize elements of the Objective-C ABI."
	self ~~ ObjectiveCSmalltalkObjectProxy ifTrue: [^self].
	self ensureNotifiedAtStartupAfter: ObjectiveCClass! !

"May 16, 2010 -> 15:3:21"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'class initialization' !
initialize
	"self initialize"
	self ensureNotifiedAtStartup.
	self startUp: true! !

"May 16, 2010 -> 15:3:21"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'Object'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :resultAlien| | pair result |
											pair := AddressToBothInstancesMap at: args receiverAddress.
											result := pair first forward: args selector to: pair last with: args args.
											resultAlien returnInteger: (self for: result) addressField]
									argsClass: ObjectiveCForwardSignature.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forward::')
				implementation: SendbackCallback thunk
				signature: '@@::^v'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"May 16, 2010 -> 15:3:21"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
startUp: resuming
	"Partially initialize, clearing the mapping tables.
	Leave installing the proxy class to the instance side's intialize
	method, hence making initialization as lazy as possible."

	"ObjectiveCSmalltalkObjectProxy startUp: true"
	resuming ifFalse: [^self].
	AddressToBothInstancesMap := Dictionary new.
	SmalltalkToObjectiveCInstanceMap := IdentityDictionary new.
	ObjectiveCSmalltalkProxyClassAlien := nil. "acts as initialization flag."
	"This code now moved to ObjectiveCSmalltalkObjectProxy>>initialize."
	"SmalltalkImage current platformName = 'Mac OS' ifFalse: [^self].
	self installSmalltalkProxyClass"! !

"May 16, 2010 -> 15:9:43"!

(Delta mirrorFor: #ObjectiveCMArgs)
comment: 
'This class''s instances are wrappers around Objective-C margs parameters of the forward:: method.

   Copyright 2008 Cadence Design Systems, Inc.
   
   Licensed under the Apache License, Version 2.0 (the ''''License''''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0
'!


"May 16, 2010 -> 15:10:0"!

(Delta mirrorFor: #ObjectiveCMArgs)
comment: 
'This class''s instances are wrappers around Objective-C margs parameters of the forward:: method.

   Copyright 2008 Cadence Design Systems, Inc.
   
   Licensed under the Apache License, Version 2.0 (the ''''License''''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0
'!


"May 16, 2010 -> 15:11:6"!

(Delta mirrorFor: #ObjectiveCMethod)
comment: 
'/*
 *  Method Template
 */
typedef struct objc_method *Method;

struct objc_method {
    SEL method_name;
    char *method_types;
    IMP method_imp;
};


   Copyright 2008 Cadence Design Systems, Inc.
   
   Licensed under the Apache License, Version 2.0 (the ''''License''''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0
'!


"May 16, 2010 -> 15:11:49"!

(Delta mirrorFor: #ObjectiveCMethodList)
comment: 
'struct objc_method_list {
    struct objc_method_list *obsolete;

    int method_count;
#ifdef __alpha__
    int space;
#endif
    struct objc_method method_list[1];  /* variable length structure */
};


   Copyright 2008 Cadence Design Systems, Inc.
   
   Licensed under the Apache License, Version 2.0 (the ''''License''''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0
'!


"May 16, 2010 -> 15:15:51"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'squeak support' !
ensureNotifiedAtStartupAfter: aClass

	SystemInitializer addInitializer: self after: aClass! !

"May 16, 2010 -> 15:28:34"!

! (Delta mirrorFor: #ObjectiveCClass) classSide methodsFor: 'system startup' !
startUp: resuming
	(resuming and: [Platform == MacOSXPlatform]) ifFalse: [^self].

	"info flags"
	CLSCLASS := 16r1.
	CLSMETA := 16r2.
	"CLSINITIALIZED := 16r4.
	CLSPOSING  := 16r8.
	CLSMAPPED  := 16r10.
	CLSFLUSHCACHE := 16r20.
	CLSGROWCACHE  := 16r40.
	CLSNEEDBIND   := 16r80.
	CLSMETHODARRAY    := 16r100."


	"Objective-C 2.0 runtime (Leopard)"
	ObjcAllocateClassPairAlien := self lookupOrNil: 'objc_allocateClassPair' inLibrary: '/usr/lib/libobjc.dylib'.
	ObjcRegisterClassPairAlien := self lookupOrNil: 'objc_registerClassPair' inLibrary: '/usr/lib/libobjc.dylib'.
	ObjcAddMethodAlien := self lookupOrNil: 'class_addMethod' inLibrary: '/usr/lib/libobjc.dylib'.
	"Objective-C 1.0 runtime (Tiger)"
	ObjcAddClassAlien := self lookupOrNil: 'objc_addClass' inLibrary: '/usr/lib/libobjc.dylib'.
	ObjcAddMethodsAlien := self lookupOrNil: 'class_addMethods' inLibrary: '/usr/lib/libobjc.dylib'.! !

"May 16, 2010 -> 15:30:4"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'library class initialization' !
addInitializer: aClass after: predecessor

	|initializers|
	initializers := self initializers.
	(initializers includes: aClass)
		ifTrue: [(predecessor isNil or: [(initializers includes: predecessor) not])
							ifTrue: [^self].
						(initializers indexOf: predecessor) < (initializers indexOf: aClass)
							ifTrue: [^self]].
	initializers remove: aClass ifAbsent: [].
	predecessor isNil
		ifTrue: [initializers add: aClass]
		ifFalse: [initializers add: aClass after: predecessor]! !

"May 16, 2010 -> 15:31:58"!

! (Delta mirrorFor: #AlienDemo) methodsFor: 'MacOS examples' !
exampleNSOpenPanel
	"AlienDemo new exampleNSOpenPanel"
	| panel files |
	(ObjectiveCClassAlien lookup: 'NSApplication' inFramework: 'AppKit') sharedApplication.
	panel:= (ObjectiveCClassAlien lookup: 'NSOpenPanel' inFramework: 'AppKit') openPanel.
	panel
		setAllowsOtherFileTypes: true asAlien;
		setAllowsMultipleSelection: true asAlien;
		setCanChooseDirectories: false asAlien;
		setCanChooseFiles: true asAlien.
	(panel runModalForDirectory: nil asAlien file: nil asAlien types: nil asAlien) = 0 ifTrue:
		[^self].
	files:= panel filenames.
	0 to: files count - 1 do:
		[:i|
		Transcript
			cr;
			nextPutAll: (files objectAtIndex: i) "UTF8String" strcpy"UTF8";
			flush]! !

"May 16, 2010 -> 15:32:5"!

"System saved" !
"May 16, 2010 -> 17:14:45"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) methodsFor: 'instance initalization' !
initialize
	ObjectiveCSmalltalkProxyClassAlien isNil ifTrue: "acts as initialization flag."
		[self class installSmalltalkProxyClass].
	self isa: ObjectiveCSmalltalkProxyClassAlien! !

"May 16, 2010 -> 17:14:52"!

"System saved" !
"May 16, 2010 -> 18:13:7"!

! (Delta mirrorFor: #ObjectiveCClass) classSide methodsFor: 'class creation' !
createClassNamed: className "<String>" superclass: superclassName "<String>" into: binaryBlock "<[:class <ObjectiveCClass> :metaclass <ObjectiveCClass>| <^Type>]> ^<Type>"
	| classPairOrNil classAlien classStruct |
	ObjcAllocateClassPairAlien isNil ifTrue:
		["objc_allocateClasPair unavailable.  use the 1.0 run-time"
		  classPairOrNil := self createClassDefinitionOnRuntimeOneNamed: className "<String>" superclassName: superclassName.
		 ^classPairOrNil isNil
			ifTrue: [self error: 'Could not create class']
			ifFalse: [binaryBlock valueWithArguments: classPairOrNil]].

	"Use the 2.0 run-time."
	classAlien := ObjcAllocateClassPairAlien
						primFFICallResult: ObjectiveCClassAlien new
						with: (ObjectiveCClassAlien lookup: superclassName)
						with: className asAlien
						with: 0.
	^classAlien addressField = 0
		ifTrue: [self error: 'Could not create class']
		ifFalse:
			[classStruct := classAlien asObjectiveCClass.
			 binaryBlock value: classStruct with: classAlien isa asObjectiveCClass]! !

"May 16, 2010 -> 18:13:46"!

"System saved" !
"May 16, 2010 -> 18:17:6"!

! (Delta mirrorFor: #ObjectiveCClass) classSide methodsFor: 'class creation' !
createClassNamed: className "<String>" superclass: superclassName "<String>" into: binaryBlock "<[:class <ObjectiveCClass> :metaclass <ObjectiveCClass>| <^Type>]> ^<Type>"
	| classPairOrNil classAlien classStruct |
	ObjcAllocateClassPairAlien isNil ifTrue:
		["objc_allocateClasPair unavailable.  use the 1.0 run-time"
		  classPairOrNil := self createClassDefinitionOnRuntimeOneNamed: className "<String>" superclassName: superclassName.
		 ^classPairOrNil isNil
			ifTrue: [self error: 'Could not create class']
			ifFalse: [binaryBlock valueWithArguments: classPairOrNil]].

	"Use the 2.0 run-time."
	classAlien := ObjcAllocateClassPairAlien
						primFFICallResult: ObjectiveCClassAlien new
						with: (ObjectiveCClassAlien lookup: superclassName) asObjectiveCClass
						with: className asAlien
						with: 0.
	^classAlien addressField = 0
		ifTrue: [self error: 'Could not create class']
		ifFalse:
			[classStruct := classAlien asObjectiveCClass.
			 binaryBlock value: classStruct with: classAlien isa asObjectiveCClass]! !

"May 16, 2010 -> 18:17:17"!

"System saved" !
"May 16, 2010 -> 18:45:48"!

! (Delta mirrorFor: #ObjectiveCClass) classSide methodsFor: 'class creation' !
createClassNamed: className "<String>" superclass: superclassName "<String>" into: binaryBlock "<[:class <ObjectiveCClass> :metaclass <ObjectiveCClass>| <^Type>]> ^<Type>"
	| classPairOrNil classAlien classStruct |
	ObjcAllocateClassPairAlien isNil ifTrue:
		["objc_allocateClasPair unavailable.  use the 1.0 run-time"
		  classPairOrNil := self createClassDefinitionOnRuntimeOneNamed: className "<String>" superclassName: superclassName.
		 ^classPairOrNil isNil
			ifTrue: [self error: 'Could not create class']
			ifFalse: [binaryBlock valueWithArguments: classPairOrNil]].

	"Use the 2.0 run-time."
	classAlien := ObjcAllocateClassPairAlien
						primFFICallResult: ObjectiveCClassAlien new
						with: (ObjectiveCClassAlien lookup: superclassName) asObjectiveCClass pointer
						with: className asAlien pointer
						with: 0.
	^classAlien addressField = 0
		ifTrue: [self error: 'Could not create class']
		ifFalse:
			[classStruct := classAlien asObjectiveCClass.
			 binaryBlock value: classStruct with: classAlien isa asObjectiveCClass]! !

"May 16, 2010 -> 18:45:55"!

"System saved" !
"May 16, 2010 -> 19:18:37"!

! (Delta mirrorFor: #ObjectiveCClass) classSide methodsFor: 'class creation' !
createClassNamed: className "<String>" superclass: superclassName "<String>" into: binaryBlock "<[:class <ObjectiveCClass> :metaclass <ObjectiveCClass>| <^Type>]> ^<Type>"
	| classPairOrNil classAlien classStruct |
	ObjcAllocateClassPairAlien isNil ifTrue:
		["objc_allocateClasPair unavailable.  use the 1.0 run-time"
		  classPairOrNil := self createClassDefinitionOnRuntimeOneNamed: className "<String>" superclassName: superclassName.
		 ^classPairOrNil isNil
			ifTrue: [self error: 'Could not create class']
			ifFalse: [binaryBlock valueWithArguments: classPairOrNil]].

	"Use the 2.0 run-time."
	classAlien := ObjcAllocateClassPairAlien
						primFFICallResult: ObjectiveCClassAlien newGC
						with: (ObjectiveCClassAlien lookup: superclassName) asObjectiveCClass pointer
						with: className asAlien pointer
						with: 0.
	^classAlien addressField = 0
		ifTrue: [self error: 'Could not create class']
		ifFalse:
			[classStruct := classAlien asObjectiveCClass.
			 binaryBlock value: classStruct with: classAlien isa asObjectiveCClass]! !

"May 16, 2010 -> 19:18:43"!

"System saved" !
"May 16, 2010 -> 19:20:50"!

! (Delta mirrorFor: #ObjectiveCClass) classSide methodsFor: 'class creation' !
createClassNamed: className "<String>" superclass: superclassName "<String>" into: binaryBlock "<[:class <ObjectiveCClass> :metaclass <ObjectiveCClass>| <^Type>]> ^<Type>"
	| classPairOrNil classAlien classStruct |
	ObjcAllocateClassPairAlien isNil ifTrue:
		["objc_allocateClasPair unavailable.  use the 1.0 run-time"
		  classPairOrNil := self createClassDefinitionOnRuntimeOneNamed: className "<String>" superclassName: superclassName.
		 ^classPairOrNil isNil
			ifTrue: [self error: 'Could not create class']
			ifFalse: [binaryBlock valueWithArguments: classPairOrNil]].

	"Use the 2.0 run-time."
	classAlien := ObjcAllocateClassPairAlien
						primFFICallResult: ObjectiveCClassAlien newGC
						with: (ObjectiveCClassAlien lookup: superclassName) asObjectiveCClass pointer
						with: className asAlien pointer
						with: 0.
	^classAlien addressField = 0
		ifTrue: [self error: 'Could not create class']
		ifFalse:
			[classStruct := classAlien asObjectiveCClass.
			 binaryBlock value: classStruct value: classAlien isa asObjectiveCClass]! !

"May 16, 2010 -> 19:21:0"!

"System saved" !
"May 16, 2010 -> 20:24:54"!

! (Delta mirrorFor: #ObjectiveCClass) classSide methodsFor: 'class creation' !
createClassNamed: className "<String>" superclass: superclassName "<String>" into: binaryBlock "<[:class <ObjectiveCClass> :metaclass <ObjectiveCClass>| <^Type>]> ^<Type>"
	| classPairOrNil classAlien classStruct |
	ObjcAllocateClassPairAlien isNil ifTrue:
		["objc_allocateClasPair unavailable.  use the 1.0 run-time"
		  classPairOrNil := self createClassDefinitionOnRuntimeOneNamed: className "<String>" superclassName: superclassName.
		 ^classPairOrNil isNil
			ifTrue: [self error: 'Could not create class']
			ifFalse: [binaryBlock valueWithArguments: classPairOrNil]].

	"Use the 2.0 run-time."
	classAlien := ObjcAllocateClassPairAlien
						primFFICallResult: ObjectiveCClassAlien newGC
						with: (ObjectiveCClassAlien lookup: superclassName) asObjectiveCClass pointer
						with: className asAlien pointer
						with: 0.
	^classAlien addressField = 0
		ifTrue: [self error: 'Could not create class']
		ifFalse:
			[classStruct := classAlien asObjectiveCClass.
			ObjcRegisterClassPairAlien
				primFFICallResult: nil
				with: classStruct.
			 binaryBlock value: classStruct value: classAlien isa asObjectiveCClass]! !

"May 16, 2010 -> 20:25:6"!

"System saved" !
"May 16, 2010 -> 20:26:34"!

! (Delta mirrorFor: #ObjectiveCClass) classSide methodsFor: 'class creation' !
createClassNamed: className "<String>" superclass: superclassName "<String>" into: binaryBlock "<[:class <ObjectiveCClass> :metaclass <ObjectiveCClass>| <^Type>]> ^<Type>"
	| classPairOrNil classAlien classStruct |
	ObjcAllocateClassPairAlien isNil ifTrue:
		["objc_allocateClasPair unavailable.  use the 1.0 run-time"
		  classPairOrNil := self createClassDefinitionOnRuntimeOneNamed: className "<String>" superclassName: superclassName.
		 ^classPairOrNil isNil
			ifTrue: [self error: 'Could not create class']
			ifFalse: [binaryBlock valueWithArguments: classPairOrNil]].

	"Use the 2.0 run-time."
	classAlien := ObjcAllocateClassPairAlien
						primFFICallResult: ObjectiveCClassAlien newGC
						with: (ObjectiveCClassAlien lookup: superclassName) asObjectiveCClass pointer
						with: className asAlien pointer
						with: 0.
	^classAlien addressField = 0
		ifTrue: [self error: 'Could not create class']
		ifFalse:
			[classStruct := classAlien asObjectiveCClass.
			ObjcRegisterClassPairAlien
				primFFICallResult: nil
				with: classStruct vmHalt.
			 binaryBlock value: classStruct value: classAlien isa asObjectiveCClass]! !

"May 16, 2010 -> 20:26:40"!

"System saved" !
"May 16, 2010 -> 20:43:9"!

! (Delta mirrorFor: #ObjectiveCClass) classSide methodsFor: 'class creation' !
createClassNamed: className "<String>" superclass: superclassName "<String>" into: binaryBlock "<[:class <ObjectiveCClass> :metaclass <ObjectiveCClass>| <^Type>]> ^<Type>"
	| classPairOrNil classAlien classStruct |
	ObjcAllocateClassPairAlien isNil ifTrue:
		["objc_allocateClasPair unavailable.  use the 1.0 run-time"
		  classPairOrNil := self createClassDefinitionOnRuntimeOneNamed: className "<String>" superclassName: superclassName.
		 ^classPairOrNil isNil
			ifTrue: [self error: 'Could not create class']
			ifFalse: [binaryBlock valueWithArguments: classPairOrNil]].

	"Use the 2.0 run-time."
	classAlien := ObjcAllocateClassPairAlien
						primFFICallResult: (ObjectiveCClassAlien forPointer: 0)
						with: (ObjectiveCClassAlien lookup: superclassName) asObjectiveCClass pointer
						with: className asAlien pointer
						with: 0.
	^classAlien addressField = 0
		ifTrue: [self error: 'Could not create class']
		ifFalse:
			[classStruct := classAlien asObjectiveCClass.
			ObjcRegisterClassPairAlien
				primFFICallResult: nil
				with: classStruct vmHalt.
			 binaryBlock value: classStruct value: classAlien isa asObjectiveCClass]! !

"May 16, 2010 -> 21:11:41"!

! (Delta mirrorFor: #ObjectiveCClass) classSide methodsFor: 'class creation' !
createClassNamed: className "<String>" superclass: superclassName "<String>" into: binaryBlock "<[:class <ObjectiveCClass> :metaclass <ObjectiveCClass>| <^Type>]> ^<Type>"
	| classPairOrNil classAlien classStruct |
	ObjcAllocateClassPairAlien isNil ifTrue:
		["objc_allocateClasPair unavailable.  use the 1.0 run-time"
		  classPairOrNil := self createClassDefinitionOnRuntimeOneNamed: className "<String>" superclassName: superclassName.
		 ^classPairOrNil isNil
			ifTrue: [self error: 'Could not create class']
			ifFalse: [binaryBlock valueWithArguments: classPairOrNil]].

	"Use the 2.0 run-time."
	classAlien := ObjcAllocateClassPairAlien
						primFFICallResult: ObjectiveCClassAlien new
						with: (ObjectiveCClassAlien lookup: superclassName) asObjectiveCClass pointer
						with: className asAlien pointer
						with: 0.
	^classAlien asUnsignedLong = 0
		ifTrue: [self error: 'Could not create class']
		ifFalse:
			[classStruct := classAlien asObjectiveCClass.
			ObjcRegisterClassPairAlien
				primFFICallResult: nil
				with: classStruct vmHalt.
			 binaryBlock value: classStruct value: classAlien isa asObjectiveCClass]! !

"May 16, 2010 -> 21:11:50"!

"System saved" !
"May 16, 2010 -> 21:14:35"!

! (Delta mirrorFor: #ObjectiveCClass) classSide methodsFor: 'class creation' !
createClassNamed: className "<String>" superclass: superclassName "<String>" into: binaryBlock "<[:class <ObjectiveCClass> :metaclass <ObjectiveCClass>| <^Type>]> ^<Type>"
	| classPairOrNil classAlien classStruct |
	ObjcAllocateClassPairAlien isNil ifTrue:
		["objc_allocateClasPair unavailable.  use the 1.0 run-time"
		  classPairOrNil := self createClassDefinitionOnRuntimeOneNamed: className "<String>" superclassName: superclassName.
		 ^classPairOrNil isNil
			ifTrue: [self error: 'Could not create class']
			ifFalse: [binaryBlock valueWithArguments: classPairOrNil]].

	"Use the 2.0 run-time."
	classAlien := ObjcAllocateClassPairAlien
						primFFICallResult: ObjectiveCClassAlien new
						with: (ObjectiveCClassAlien lookup: superclassName) asObjectiveCClass pointer
						with: className asAlien pointer
						with: 0.
	^classAlien asUnsignedLong = 0
		ifTrue: [self error: 'Could not create class']
		ifFalse:
			[classStruct := classAlien asObjectiveCClass.
			ObjcRegisterClassPairAlien
				primFFICallResult: nil
				with: classStruct pointer vmHalt.
			 binaryBlock value: classStruct value: classAlien isa asObjectiveCClass]! !

"May 16, 2010 -> 21:14:44"!

"System saved" !
"May 16, 2010 -> 21:28:19"!

! (Delta mirrorFor: #ObjectiveCClass) classSide methodsFor: 'class creation' !
createClassNamed: className "<String>" superclass: superclassName "<String>" into: binaryBlock "<[:class <ObjectiveCClass> :metaclass <ObjectiveCClass>| <^Type>]> ^<Type>"
	| classPairOrNil classAlien classStruct |
	ObjcAllocateClassPairAlien isNil ifTrue:
		["objc_allocateClasPair unavailable.  use the 1.0 run-time"
		  classPairOrNil := self createClassDefinitionOnRuntimeOneNamed: className "<String>" superclassName: superclassName.
		 ^classPairOrNil isNil
			ifTrue: [self error: 'Could not create class']
			ifFalse: [binaryBlock valueWithArguments: classPairOrNil]].

	"Use the 2.0 run-time."
	classAlien := ObjcAllocateClassPairAlien
						primFFICallResult: ObjectiveCClassAlien new
						with: (ObjectiveCClassAlien lookup: superclassName) asObjectiveCClass pointer
						with: className asAlien pointer
						with: 0.
	^classAlien asUnsignedLong = 0
		ifTrue: [self error: 'Could not create class']
		ifFalse:
			[classStruct := classAlien asObjectiveCClass.
			ObjcRegisterClassPairAlien
				primFFICallResult: nil
				with: classStruct.
			 binaryBlock value: classStruct value: classAlien isa asObjectiveCClass]! !

"May 16, 2010 -> 21:28:32"!

"System saved" !
"May 16, 2010 -> 21:29:46"!

! (Delta mirrorFor: #ObjectiveCClass) classSide methodsFor: 'class creation' !
createClassNamed: className "<String>" superclass: superclassName "<String>" into: binaryBlock "<[:class <ObjectiveCClass> :metaclass <ObjectiveCClass>| <^Type>]> ^<Type>"
	| classPairOrNil classAlien classStruct |
	ObjcAllocateClassPairAlien isNil ifTrue:
		["objc_allocateClasPair unavailable.  use the 1.0 run-time"
		  classPairOrNil := self createClassDefinitionOnRuntimeOneNamed: className "<String>" superclassName: superclassName.
		 ^classPairOrNil isNil
			ifTrue: [self error: 'Could not create class']
			ifFalse: [binaryBlock valueWithArguments: classPairOrNil]].

	"Use the 2.0 run-time."
	classAlien := ObjcAllocateClassPairAlien
						primFFICallResult: ObjectiveCClassAlien new
						with: (ObjectiveCClassAlien lookup: superclassName) asObjectiveCClass
						with: className asAlien pointer
						with: 0.
	^classAlien asUnsignedLong = 0
		ifTrue: [self error: 'Could not create class']
		ifFalse:
			[classStruct := classAlien asObjectiveCClass.
			ObjcRegisterClassPairAlien
				primFFICallResult: nil
				with: classStruct.
			 binaryBlock value: classStruct value: classAlien isa asObjectiveCClass]! !

"May 16, 2010 -> 21:29:58"!

"System saved" !
"May 16, 2010 -> 23:34:18"!

! (Delta mirrorFor: #ObjectiveCClass) classSide methodsFor: 'class creation' !
createClassNamed: className "<String>" superclass: superclassName "<String>" into: binaryBlock "<[:class <ObjectiveCClass> :metaclass <ObjectiveCClass>| <^Type>]> ^<Type>"
	| classPairOrNil classAlien classStruct |
	ObjcAllocateClassPairAlien isNil ifTrue:
		["objc_allocateClasPair unavailable.  use the 1.0 run-time"
		  classPairOrNil := self createClassDefinitionOnRuntimeOneNamed: className "<String>" superclassName: superclassName.
		 ^classPairOrNil isNil
			ifTrue: [self error: 'Could not create class']
			ifFalse: [binaryBlock valueWithArguments: classPairOrNil]].

	"Use the 2.0 run-time."
	classAlien := ObjcAllocateClassPairAlien
						primFFICallResult: ObjectiveCClassAlien new
						with: (ObjectiveCClassAlien lookup: superclassName) asObjectiveCClass pointer
						with: className asAlien pointer
						with: 0.
	^classAlien asUnsignedLong = 0
		ifTrue: [self error: 'Could not create class']
		ifFalse:
			[classStruct := classAlien asObjectiveCClass.
			ObjcRegisterClassPairAlien
				primFFICallResult: nil
				with: classStruct pointer.
			 binaryBlock value: classStruct value: classAlien isa asObjectiveCClass]! !

"May 16, 2010 -> 23:34:36"!

"System saved" !
"May 16, 2010 -> 23:50:4"!

! (Delta mirrorFor: #ObjectiveCClass) classSide methodsFor: 'class creation' !
createClassNamed: className "<String>" superclass: superclassName "<String>" into: binaryBlock "<[:class <ObjectiveCClass> :metaclass <ObjectiveCClass>| <^Type>]> ^<Type>"
	| classPairOrNil classAlien classStruct |
	ObjcAllocateClassPairAlien isNil ifTrue:
		["objc_allocateClasPair unavailable.  use the 1.0 run-time"
		  classPairOrNil := self createClassDefinitionOnRuntimeOneNamed: className "<String>" superclassName: superclassName.
		 ^classPairOrNil isNil
			ifTrue: [self error: 'Could not create class']
			ifFalse: [binaryBlock valueWithArguments: classPairOrNil]].

	"Use the 2.0 run-time."
	classAlien := ObjcAllocateClassPairAlien
						primFFICallResult: (ObjectiveCClassAlien forPointer: 0)
						with: (ObjectiveCClassAlien lookup: superclassName) asObjectiveCClass pointer
						with: className asAlien pointer
						with: 0.
	^classAlien address = 0
		ifTrue: [self error: 'Could not create class']
		ifFalse:
			[classStruct := classAlien asObjectiveCClass.
			ObjcRegisterClassPairAlien
				primFFICallResult: nil
				with: classStruct pointer.
			 binaryBlock value: classStruct value: classAlien isa asObjectiveCClass]! !

"May 16, 2010 -> 23:50:16"!

"System saved" !
"May 17, 2010 -> 0:18:59"!

! (Delta mirrorFor: #ObjectiveCClass) classSide methodsFor: 'class creation' !
createClassNamed: className "<String>" superclass: superclassName "<String>" into: binaryBlock "<[:class <ObjectiveCClass> :metaclass <ObjectiveCClass>| <^Type>]> ^<Type>"
	| classPairOrNil classAlien classStruct |
	ObjcAllocateClassPairAlien isNil ifTrue:
		["objc_allocateClasPair unavailable.  use the 1.0 run-time"
		  classPairOrNil := self createClassDefinitionOnRuntimeOneNamed: className "<String>" superclassName: superclassName.
		 ^classPairOrNil isNil
			ifTrue: [self error: 'Could not create class']
			ifFalse: [binaryBlock valueWithArguments: classPairOrNil]].

	"Use the 2.0 run-time."
	classAlien := ObjcAllocateClassPairAlien
						primFFICallResult: (ObjectiveCClassAlien forPointer: 0)
						with: (ObjectiveCClassAlien lookup: superclassName) pointer
						with: className asAlien pointer
						with: 0.
	^classAlien address = 0
		ifTrue: [self error: 'Could not create class']
		ifFalse:
			[classStruct := classAlien asObjectiveCClass.
			ObjcRegisterClassPairAlien
				primFFICallResult: nil
				with: classStruct pointer.
			 binaryBlock value: classStruct value: classAlien isa asObjectiveCClass]! !

"May 17, 2010 -> 0:19:14"!

"System saved" !
"May 17, 2010 -> 0:20:46"!

! (Delta mirrorFor: #ObjectiveCClass) classSide methodsFor: 'class creation' !
createClassNamed: className "<String>" superclass: superclassName "<String>" into: binaryBlock "<[:class <ObjectiveCClass> :metaclass <ObjectiveCClass>| <^Type>]> ^<Type>"
	| classPairOrNil classAlien classStruct |
	ObjcAllocateClassPairAlien isNil ifTrue:
		["objc_allocateClasPair unavailable.  use the 1.0 run-time"
		  classPairOrNil := self createClassDefinitionOnRuntimeOneNamed: className "<String>" superclassName: superclassName.
		 ^classPairOrNil isNil
			ifTrue: [self error: 'Could not create class']
			ifFalse: [binaryBlock valueWithArguments: classPairOrNil]].

	"Use the 2.0 run-time."
	classAlien := ObjcAllocateClassPairAlien
						primFFICallResult: (ObjectiveCClassAlien forPointer: 0)
						with: (ObjectiveCClassAlien lookup: superclassName) asObjectiveCClass pointer
						with: className asAlien pointer
						with: 0.
	^classAlien address = 0
		ifTrue: [self error: 'Could not create class']
		ifFalse:
			[classStruct := classAlien asObjectiveCClass.
			ObjcRegisterClassPairAlien
				primFFICallResult: nil
				with: classStruct pointer.
			 binaryBlock value: classStruct value: classAlien isa asObjectiveCClass]! !

"May 17, 2010 -> 0:22:58"!

"System saved" !
"May 17, 2010 -> 0:48:2"!

! (Delta mirrorFor: #ObjectiveCClass) methodsFor: 'method dictionary' !
rt2addMethod: selector "<Alien>" implementation: functionPointer "<FFICallbackThunk|Alien>" signature: signature "<String>" 
	| boolAlien |
	ObjcAddMethodAlien
		primFFICallResult: (boolAlien := Alien new: 4)
		with: self
		with: selector
		with: signature asAlien pointer.
	(boolAlien unsignedLongAt: 1) = 0 ifTrue:
		[self error: 'class_addMethod failed']! !

"May 17, 2010 -> 0:50:15"!

! (Delta mirrorFor: #ObjectiveCClass) methodsFor: 'method dictionary' !
rt2addMethod: selector "<Alien>" implementation: functionPointer "<FFICallbackThunk|Alien>" signature: signature "<String>" 
	| boolAlien |
	ObjcAddMethodAlien
		primFFICallResult: (boolAlien := Alien new: 4)
		with: self
		with: selector
		with: functionPointer
		with: signature asAlien pointer.
	(boolAlien unsignedLongAt: 1) = 0 ifTrue:
		[self error: 'class_addMethod failed']! !

"May 17, 2010 -> 0:50:30"!

"System saved" !
"May 17, 2010 -> 0:52:24"!

! (Delta mirrorFor: #ObjectiveCClass) methodsFor: 'method dictionary' !
rt2addMethod: selector "<Alien>" implementation: functionPointer "<FFICallbackThunk|Alien>" signature: signature "<String>" 
	| boolAlien |
	ObjcAddMethodAlien
		primFFICallResult: (boolAlien := Alien new: 4)
		with: self pointer
		with: selector
		with: functionPointer
		with: signature asAlien pointer.
	(boolAlien unsignedLongAt: 1) = 0 ifTrue:
		[self error: 'class_addMethod failed']! !

"May 17, 2010 -> 0:52:36"!

"System saved" !
"May 17, 2010 -> 1:13:21"!

! (Delta mirrorFor: #ObjectiveCClass) classSide methodsFor: 'class creation' !
createClassNamed: className "<String>" superclass: superclassName "<String>" into: binaryBlock "<[:class <ObjectiveCClass> :metaclass <ObjectiveCClass>| <^Type>]> ^<Type>"
	| classPairOrNil classAlien classStruct |
	ObjcAllocateClassPairAlien isNil ifTrue:
		["objc_allocateClasPair unavailable.  use the 1.0 run-time"
		  classPairOrNil := self createClassDefinitionOnRuntimeOneNamed: className "<String>" superclassName: superclassName.
		 ^classPairOrNil isNil
			ifTrue: [self error: 'Could not create class']
			ifFalse: [binaryBlock valueWithArguments: classPairOrNil]].

	"Use the 2.0 run-time."
	classAlien := ObjcAllocateClassPairAlien
						primFFICallResult: (ObjectiveCClassAlien forPointer: 0)
						with: (ObjectiveCClassAlien lookup: superclassName) asObjectiveCClass pointer
						with: className asAlien pointer
						with: 0.
	classAlien retain.
	^classAlien address = 0
		ifTrue: [self error: 'Could not create class']
		ifFalse:
			[classStruct := classAlien asObjectiveCClass.
			ObjcRegisterClassPairAlien
				primFFICallResult: nil
				with: classStruct pointer.
			 binaryBlock value: classStruct value: classAlien isa asObjectiveCClass]! !

"May 17, 2010 -> 1:13:27"!

"System saved" !
"May 17, 2010 -> 1:29:26"!

! (Delta mirrorFor: #ObjectiveCClass) classSide methodsFor: 'class creation' !
createClassNamed: className "<String>" superclass: superclassName "<String>" into: binaryBlock "<[:class <ObjectiveCClass> :metaclass <ObjectiveCClass>| <^Type>]> ^<Type>"
	| classPairOrNil classAlien classStruct |
	ObjcAllocateClassPairAlien isNil ifTrue:
		["objc_allocateClasPair unavailable.  use the 1.0 run-time"
		  classPairOrNil := self createClassDefinitionOnRuntimeOneNamed: className "<String>" superclassName: superclassName.
		 ^classPairOrNil isNil
			ifTrue: [self error: 'Could not create class']
			ifFalse: [binaryBlock valueWithArguments: classPairOrNil]].

	"Use the 2.0 run-time."
	classAlien := ObjcAllocateClassPairAlien
						primFFICallResult: (ObjectiveCClassAlien forPointer: 0)
						with: (ObjectiveCClassAlien lookup: superclassName) asObjectiveCClass pointer
						with: className asAlien pointer
						with: 0.
	^classAlien address = 0
		ifTrue: [self error: 'Could not create class']
		ifFalse:
			[classStruct := classAlien asObjectiveCClass.
			ObjcRegisterClassPairAlien
				primFFICallResult: nil
				with: classStruct pointer.
			 binaryBlock value: classStruct value: classAlien isa asObjectiveCClass]! !

"May 17, 2010 -> 1:30:35"!

"System saved" !
"May 17, 2010 -> 1:35:43"!

! (Delta mirrorFor: #ObjectiveCClass) classSide methodsFor: 'class creation' !
createClassNamed: className "<String>" superclass: superclassName "<String>" into: binaryBlock "<[:class <ObjectiveCClass> :metaclass <ObjectiveCClass>| <^Type>]> ^<Type>"
	| classPairOrNil classAlien classStruct |
	ObjcAllocateClassPairAlien isNil ifTrue:
		["objc_allocateClasPair unavailable.  use the 1.0 run-time"
		  classPairOrNil := self createClassDefinitionOnRuntimeOneNamed: className "<String>" superclassName: superclassName.
		 ^classPairOrNil isNil
			ifTrue: [self error: 'Could not create class']
			ifFalse: [binaryBlock valueWithArguments: classPairOrNil]].

	"Use the 2.0 run-time."
	classAlien := ObjcAllocateClassPairAlien
						primFFICallResult: (ObjectiveCClassAlien forPointer: 0)
						with: (ObjectiveCClassAlien lookup: superclassName) asObjectiveCClass pointer
						with: className asAlien pointer
						with: 0.
	^classAlien address = 0
		ifTrue: [self error: 'Could not create class']
		ifFalse:
			[classStruct := classAlien asObjectiveCClass.
			ObjcRegisterClassPairAlien
				primFFICallResult: nil
				with: classStruct pointer vmHalt.
			 binaryBlock value: classStruct value: classAlien isa asObjectiveCClass]! !

"May 17, 2010 -> 1:35:51"!

"System saved" !
"May 21, 2010 -> 0:4:25"!

! (Delta mirrorFor: #ObjectiveCClass) classSide methodsFor: 'class creation' !
createClassNamed: className "<String>" superclass: superclassName "<String>" into: binaryBlock "<[:class <ObjectiveCClass> :metaclass <ObjectiveCClass>| <^Type>]> ^<Type>"
	| classPairOrNil classAlien classStruct |
	ObjcAllocateClassPairAlien isNil ifTrue:
		["objc_allocateClasPair unavailable.  use the 1.0 run-time"
		  classPairOrNil := self createClassDefinitionOnRuntimeOneNamed: className "<String>" superclassName: superclassName.
		 ^classPairOrNil isNil
			ifTrue: [self error: 'Could not create class']
			ifFalse: [binaryBlock valueWithArguments: classPairOrNil]].

	"Use the 2.0 run-time."
	classAlien := ObjcAllocateClassPairAlien
						primFFICallResult: (ObjectiveCClassAlien forPointer: 0)
						with: (ObjectiveCClassAlien lookup: superclassName)
						with: className asAlien pointer
						with: 0.
	^classAlien address = 0
		ifTrue: [self error: 'Could not create class']
		ifFalse:
			[classStruct := classAlien asObjectiveCClass.
			ObjcRegisterClassPairAlien
				primFFICallResult: nil
				with: classAlien.
			 binaryBlock value: classStruct value: classAlien isa asObjectiveCClass]! !

"May 21, 2010 -> 0:4:37"!

"System saved" !
"May 21, 2010 -> 19:59:46"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'NSObject'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :resultAlien| | pair result |
											pair := AddressToBothInstancesMap at: args receiverAddress.
											result := pair first forward: args selector to: pair last with: args args.
											resultAlien returnInteger: (self for: result) addressField]
									argsClass: ObjectiveCForwardSignature.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forward::')
				implementation: SendbackCallback thunk
				signature: '@@::^v'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"May 21, 2010 -> 19:59:53"!

"System saved" !
"May 21, 2010 -> 20:38:18"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'Object'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :resultAlien| | pair result |
											pair := AddressToBothInstancesMap at: args receiverAddress.
											result := pair first forward: args selector to: pair last with: args args.
											resultAlien returnInteger: (self for: result) addressField]
									argsClass: ObjectiveCForwardSignature.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forward::')
				implementation: SendbackCallback thunk
				signature: '@@::^v'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"May 21, 2010 -> 20:38:23"!

"System saved" !
"May 22, 2010 -> 0:27:14"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) methodsFor: 'message forwarding' !
forward: anObjectiveCSelectorAlien to: aSmalltalkObject
	"| smalltalkSelector args method pragmas |
	smalltalkSelector := anObjectiveCSelectorAlien asSmalltalkSelector.
	args :=  ObjectiveCAlien
				argumentListFromMArgs: anObjectiveCMArgs
				numArgs: smalltalkSelector numArgs
				withSignature: (((method := aSmalltalkObject class lookupSelector: smalltalkSelector) notNil
								and: [(pragmas := method pragmas select: [:p| p keyword == #objectiveCSignature:]) notEmpty])
									ifTrue: [pragmas anyOne arguments first]
									ifFalse: [String new: smalltalkSelector numArgs withAll: $S]).
	^aSmalltalkObject
		perform: smalltalkSelector
		withArguments: args"! !

"May 22, 2010 -> 15:27:5"!

Delta define: #ObjectiveCMethodSignature as: (
(Class subclassOf: 'Alien' instanceVariables: '')) !


"May 22, 2010 -> 15:28:17"!

! (Delta mirrorFor: #ObjectiveCMethod) methodsFor: 'accessing' !
signature ^<Alien>

	^ObjectiveCMethodSignature forPointer: (NSMethodSignature signatureWithObjCTypes: self methodTypes) address! !

"May 22, 2010 -> 15:28:43"!

Delta define: #ObjectiveCMethodSignature as: (
(Class subclassOf: 'ObjectiveCAlien' instanceVariables: '')) !


"May 22, 2010 -> 15:28:43"!

Delta define: #ObjectiveCMethodSignature as: (
(Class subclassOf: 'ObjectiveCAlien' instanceVariables: '')) !


"May 22, 2010 -> 15:28:43"!

Delta define: #ObjectiveCMethodSignature as: (
(Class subclassOf: 'ObjectiveCAlien' instanceVariables: '')) !


"May 22, 2010 -> 15:28:43"!

Delta define: #ObjectiveCMethodSignature as: (
(Class subclassOf: 'ObjectiveCAlien' instanceVariables: '')) !


"May 22, 2010 -> 15:28:43"!

Delta define: #ObjectiveCMethodSignature as: (
(Class subclassOf: 'ObjectiveCAlien' instanceVariables: '')) !


"May 22, 2010 -> 15:28:43"!

Delta define: #ObjectiveCMethodSignature as: (
(Class subclassOf: 'ObjectiveCAlien' instanceVariables: '')) !


"May 22, 2010 -> 15:28:43"!

Delta define: #ObjectiveCMethodSignature as: (
(Class subclassOf: 'ObjectiveCAlien' instanceVariables: '')) !


"May 22, 2010 -> 15:28:43"!

Delta define: #ObjectiveCMethodSignature as: (
(Class subclassOf: 'ObjectiveCAlien' instanceVariables: '')) !


"May 22, 2010 -> 15:28:43"!

Delta define: #ObjectiveCMethodSignature as: (
(Class subclassOf: 'ObjectiveCAlien' instanceVariables: '')) !


"May 22, 2010 -> 15:28:43"!

Delta define: #ObjectiveCMethodSignature as: (
(Class subclassOf: 'ObjectiveCAlien' instanceVariables: '')) !


"May 22, 2010 -> 15:28:43"!

Delta define: #ObjectiveCMethodSignature as: (
(Class subclassOf: 'ObjectiveCAlien' instanceVariables: '')) !


"May 22, 2010 -> 15:45:32"!

! (Delta mirrorFor: #ObjectiveCMethodSignature) methodsFor: 'accessing' !
argSize: index <SmallInteger>

	|type|
	type := (self getArgumentTypeAtIndex: index) strcpy.
	! !

"May 22, 2010 -> 15:47:54"!

! (Delta mirrorFor: #ObjectiveCMethodSignature) methodsFor: 'accessing' !
lengthFor: type <String>

	^((self class lookup: 'NSMethodSignature')
			signatureWithObjCTypes: (type, '8@0:4') asAlien pointer)
				methodReturnLength! !

"May 22, 2010 -> 15:48:19"!

! (Delta mirrorFor: #ObjectiveCMethodSignature) methodsFor: 'accessing' !
argSize: index <SmallInteger>

	|type|
	type := (self getArgumentTypeAtIndex: index) strcpy.
	^self lengthFor: type! !

"May 22, 2010 -> 18:17:31"!

"System saved" !
"May 22, 2010 -> 20:23:30"!

! (Delta mirrorFor: #FixedSizeTypeHandler) classSide methodsFor: 'instance creation' !
forClass: alienClass

	^(self new)
		initAllocBlock: [alienClass forPointer: 0] resultBlock: [:alien| alien];
		yourself! !

"May 22, 2010 -> 20:23:37"!

"System saved" !
"May 22, 2010 -> 20:28:0"!

Delta define: #ObjectiveCMethodSignature as: (
(Class subclassOf: 'ObjectiveCAlien' instanceVariables: '')) !


"May 22, 2010 -> 20:29:2"!

"System saved" !
"May 22, 2010 -> 22:3:44"!

! (Delta mirrorFor: #FixedSizeTypeHandler) classSide methodsFor: 'instance creation' !
forClass: alienClass

	^(self new)
		initAllocBlock: [alienClass new] resultBlock: [:alien| alien];
		yourself! !

"May 22, 2010 -> 22:4:6"!

! (Delta mirrorFor: #ObjectiveCMethod) methodsFor: 'accessing' !
signature ^<Alien>

	^ObjectiveCMethodSignature forPointer: (NSMethodSignature signatureWithObjCTypes: self methodTypes) addressField! !

"May 22, 2010 -> 22:4:22"!

"System saved" !
"May 22, 2010 -> 22:34:58"!

! (Delta mirrorFor: #ObjectiveCMethod) methodsFor: 'accessing' !
signature ^<Alien>

	^(ObjectiveCMethodSignature new)
		unsignedLongAt: 1 put: ((NSMethodSignature signatureWithObjCTypes: self methodTypes) asUnsignedLong);
		yourself! !

"May 22, 2010 -> 22:35:8"!

"System saved" !
"May 22, 2010 -> 22:38:3"!

! (Delta mirrorFor: #ObjectiveCMethodSignature) methodsFor: 'accessing' !
lengthFor: type <String>

	^((ObjectiveCClassAlien lookup: 'NSMethodSignature')
			signatureWithObjCTypes: (type, '8@0:4') asAlien pointer)
				methodReturnLength! !

"May 22, 2010 -> 22:38:12"!

"System saved" !
"May 23, 2010 -> 1:10:25"!

Delta define: #ObjectiveCForwardInvocation as: (
(Class subclassOf: 'Alien' instanceVariables: '')) !


"May 23, 2010 -> 1:10:42"!

(Delta mirrorFor: #ObjectiveCForwardInvocation) removeDefinitionIfFail: [] !


"May 23, 2010 -> 1:13:25"!

Delta define: #ObjectiveCForwardInvocation as: (
(Class subclassOf: 'ObjectiveCAlien' instanceVariables: '')) !


"May 23, 2010 -> 1:16:58"!

! (Delta mirrorFor: #ObjectiveCMethodSignature) classSide methodsFor: 'instance creation' !
fromAlien: alien

	^(self new)
			unsignedLongAt: 1 put: (alien unsignedLongAt: 1);
			yourself! !

"May 23, 2010 -> 1:17:53"!

! (Delta mirrorFor: #ObjectiveCForwardInvocation) methodsFor: 'accessing' !
methodSignature

	^ObjectiveCMethodSignature fromAlien: super methodSignature! !

"May 23, 2010 -> 1:24:23"!

! (Delta mirrorFor: #ObjectiveCForwardInvocation) methodsFor: 'accessing' !
args

	| argCount args signature |
	signature := self methodSignature.
	argCount := signature numberOfArguments.
	args := Array new: argCount - 2.
	2 to: argCount do: [:i| | arg |
		arg := ObjectiveCAlien newC: (signature argSize: i).
		self getArgument: arg pointer atIndex: i.
		args at: i put: arg].
	^args! !

"May 23, 2010 -> 1:27:57"!

(Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) removeMethod: #forward:to: ifAbsent: [] !


"May 23, 2010 -> 1:28:3"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) methodsFor: 'message forwarding' !
xxxforward: anObjectiveCSelectorAlien to: aSmalltalkObject with: anObjectiveCMArgs "^<Object>"
	| smalltalkSelector args method pragmas |
	smalltalkSelector := anObjectiveCSelectorAlien asSmalltalkSelector.
	args :=  ObjectiveCAlien
				argumentListFromMArgs: anObjectiveCMArgs
				numArgs: smalltalkSelector numArgs
				withSignature: (((method := aSmalltalkObject class lookupSelector: smalltalkSelector) notNil
								and: [(pragmas := method pragmas select: [:p| p keyword == #objectiveCSignature:]) notEmpty])
									ifTrue: [pragmas anyOne arguments first]
									ifFalse: [String new: smalltalkSelector numArgs withAll: $S]).
	^aSmalltalkObject
		perform: smalltalkSelector
		withArguments: args! !

"May 23, 2010 -> 15:51:48"!

! (Delta mirrorFor: #ObjectiveCForwardInvocation) methodsFor: 'accessing' !
args

	| argCount args signature |
	signature := self methodSignature.
	argCount := signature numberOfArguments.
	args := Array new: argCount - 2.
	2 to: argCount do: [:i| | arg |
		arg := ObjectiveCAlien newGC: (signature argSize: i).
		self getArgument: arg pointer atIndex: i.
		args at: i put: arg].
	^args! !

"May 23, 2010 -> 17:30:3"!

! (Delta mirrorFor: #ObjectiveCMethodSignature) methodsFor: 'accessing' !
argType: index <SmallInteger> ^<String>

	^(self getArgumentTypeAtIndex: index) strcpy! !

"May 23, 2010 -> 17:30:18"!

! (Delta mirrorFor: #ObjectiveCMethodSignature) methodsFor: 'accessing' !
argSize: index <SmallInteger> ^<Integer>

	|type|
	type := (self getArgumentTypeAtIndex: index) strcpy.
	^self lengthFor: type! !

"May 23, 2010 -> 17:30:30"!

! (Delta mirrorFor: #ObjectiveCMethodSignature) methodsFor: 'accessing' !
lengthFor: type <String> ^<Integer>

	^((ObjectiveCClassAlien lookup: 'NSMethodSignature')
			signatureWithObjCTypes: (type, '8@0:4') asAlien pointer)
				methodReturnLength! !

"May 23, 2010 -> 17:30:53"!

! (Delta mirrorFor: #ObjectiveCMethodSignature) methodsFor: 'accessing' !
argSize: index <SmallInteger> ^<Integer>

	^self lengthFor: (self argType: index)! !

"May 23, 2010 -> 17:32:8"!

Delta define: #ObjectiveCMethodSignature as: (
(Class subclassOf: 'ObjectiveCAlien' instanceVariables: '') classVariables: 'NSMethodSignature') !


"May 23, 2010 -> 17:33:48"!

! (Delta mirrorFor: #ObjectiveCMethodSignature) methodsFor: 'private' !
NSMethodSignature ^<ObjectiveCClassAlien>

	NSMethodSignature isNil
		ifTrue: [NSMethodSignature := ObjectiveCClassAlien lookup: 'NSMethodSignature'].
	^NSMethodSignature! !

"May 23, 2010 -> 17:34:40"!

! (Delta mirrorFor: #ObjectiveCMethodSignature) methodsFor: 'private' !
lengthFor: type <String> ^<Integer>

	^(self NSMethodSignature signatureWithObjCTypes: (type, '8@0:4') asAlien pointer)
				methodReturnLength! !

"May 24, 2010 -> 18:26:41"!

! (Delta mirrorFor: #ObjectiveCForwardInvocation) methodsFor: 'accessing' !
args: args <Array[ObjectiveCAlien]>

	1 to: args size do: [:i| | arg |
		self setArgument: (args at: i) atIndex: i + 1]! !

"May 24, 2010 -> 18:27:57"!

! (Delta mirrorFor: #ObjectiveCForwardInvocation) methodsFor: 'accessing' !
args: args <Array[ObjectiveCAlien]>

	1 to: args size do: [:i| | arg |
		self setArgument: (args at: i) pointer atIndex: i + 1]! !

"May 24, 2010 -> 18:28:5"!

! (Delta mirrorFor: #ObjectiveCForwardInvocation) methodsFor: 'accessing' !
args

	| argCount args signature |
	signature := self methodSignature.
	argCount := signature numberOfArguments.
	args := OrderedCollection new.
	2 to: argCount - 1 do: [:i| | arg |
		arg := ObjectiveCAlien newGC: (signature argSize: i).
		self getArgument: arg pointer atIndex: i.
		args add: arg].
	^args asArray! !

"May 24, 2010 -> 18:29:1"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) methodsFor: 'message forwarding' !
forward: invocation <ObjectiveCForwardInvocation> to: aSmalltalkObject <Object> ^<Object>
	| smalltalkSelector args |
	smalltalkSelector := invocation selector asSmalltalkSelector.
	args :=  invocation args.
	^[aSmalltalkObject
		perform: smalltalkSelector
		withArguments: args]
			ensure: [invocation args: args]! !

"May 24, 2010 -> 18:38:48"!

! (Delta mirrorFor: #ObjectiveCMethodSignature) classSide methodsFor: 'instance creation' !
NSMethodSignature ^<ObjectiveCClassAlien>

	NSMethodSignature isNil
		ifTrue: [NSMethodSignature := ObjectiveCClassAlien lookup: 'NSMethodSignature'].
	^NSMethodSignature! !

"May 24, 2010 -> 18:39:5"!

! (Delta mirrorFor: #ObjectiveCMethodSignature) methodsFor: 'private' !
NSMethodSignature ^<ObjectiveCClassAlien>

	^self class NSMethodSignature! !

"May 24, 2010 -> 18:40:55"!

! (Delta mirrorFor: #ObjectiveCMethodSignature) classSide methodsFor: 'instance creation' !
fromTypes: typeString <String>

	^(self fromAlien: (self NSMethodSignature signatureWithObjCTypes: typeString))! !

"May 24, 2010 -> 18:55:57"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'Object'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien |
												pair := AddressToBothInstancesMap at: args receiverAddress.
												result := pair first forward: args to: pair last.
												callbackResult returnInteger: (resultAlien := self for: result) addressField.
												args setReturnValue: resultAlien pointer]
									argsClass: ObjectiveCForwardSignature.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v@:@'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"May 24, 2010 -> 18:56:54"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'Object'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien |
												pair := AddressToBothInstancesMap at: args target addressField.
												result := pair first forward: args to: pair last.
												callbackResult returnInteger: (resultAlien := self for: result) addressField.
												args setReturnValue: resultAlien pointer]
									argsClass: ObjectiveCForwardSignature.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v@:@'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"May 24, 2010 -> 19:0:16"!

"System saved" !
"May 24, 2010 -> 19:2:6"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'Object'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien |
												pair := AddressToBothInstancesMap at: args target addressField.
												result := pair first forward: args to: pair last.
												callbackResult returnInteger: (resultAlien := self for: result) addressField.
												args setReturnValue: resultAlien pointer]
									argsClass: ObjectiveCMethodSignature.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v@:@'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"May 24, 2010 -> 19:2:15"!

"System saved" !
"May 24, 2010 -> 19:48:22"!

! (Delta mirrorFor: #ObjectiveCMethodSignature) classSide methodsFor: 'instance creation' !
fromTypes: typeString <String>

	^(self fromAlien: (self NSMethodSignature signatureWithObjCTypes: typeString asAlien pointer))! !

"May 24, 2010 -> 19:48:32"!

"System saved" !
"May 24, 2010 -> 19:51:19"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'NSObject'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien |
												pair := AddressToBothInstancesMap at: args target addressField.
												result := pair first forward: args to: pair last.
												callbackResult returnInteger: (resultAlien := self for: result) addressField.
												args setReturnValue: resultAlien pointer]
									argsClass: ObjectiveCMethodSignature.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v@:@'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"May 24, 2010 -> 19:51:24"!

"System saved" !
"May 24, 2010 -> 19:55:42"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'NSObject'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien |
												self vmHalt.
												pair := AddressToBothInstancesMap at: args target addressField.
												result := pair first forward: args to: pair last.
												callbackResult returnInteger: (resultAlien := self for: result) addressField.
												args setReturnValue: resultAlien pointer]
									argsClass: ObjectiveCMethodSignature.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v@:@'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"May 24, 2010 -> 19:55:48"!

"System saved" !
"May 28, 2010 -> 2:1:5"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'NSObject'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien |
												self vmHalt.
												pair := AddressToBothInstancesMap at: args target addressField.
												result := pair first forward: args to: pair last.
												callbackResult returnInteger: (resultAlien := self for: result) addressField.
												args setReturnValue: resultAlien pointer]
									argsClass: ObjectiveCMethodSignature.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v12@0:4@8'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"May 28, 2010 -> 2:1:31"!

"System saved" !
"May 30, 2010 -> 10:47:27"!

Delta define: #ObjectiveCSmalltalkObjectProxy as: (
(Class subclassOf: 'ObjectiveCObject' instanceVariables: '') classVariables: 'AddressToBothInstancesMap
ObjectiveCSmalltalkProxyClassAlien
SendbackCallback
SignatureCallback
SmalltalkToObjectiveCInstanceMap') !


"May 30, 2010 -> 11:5:23"!

(Delta mirrorFor: #CharacterWriteStream) removeDefinitionIfFail: [] !


"May 30, 2010 -> 11:12:40"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'NSObject'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien |
												self vmHalt.
												pair := AddressToBothInstancesMap at: args target addressField.
												result := pair first forward: args to: pair last.
												callbackResult returnInteger: (resultAlien := self for: result) addressField.
												args setReturnValue: resultAlien pointer]
									argsClass: ObjectiveCMethodSignature.
			SignatureCallback := Callback
									block: [:args :callbackResult|
													|selector stream|
													selector := (ObjectiveCAlien atAddress: (args unsignedLongAt: 5)) asSmalltalkSelector.
													stream := CharacterReadWriteStream on: (String new: selector numberOfArguments + 3).
													stream nextPutAll: 'v@:'.
													selector numberOfArguments timesRepeat: [stream nextPut: $@].
													callbackResult returnInteger: stream contentsWritten asAlien pointer]
									argsClass: Alien.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v12@0:4@8'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"May 30, 2010 -> 11:19:42"!

Delta define: #ObjectiveCMethodSignatureForSelectorArguments as: (
(Class subclassOf: 'Alien' instanceVariables: '')) !


"May 30, 2010 -> 11:21:3"!

! (Delta mirrorFor: #ObjectiveCMethodSignatureForSelectorArguments) classSide methodsFor: 'instance creation' !
dataSize
	"- (NSMethodSignature *) methodSignatureForSelector: (SEL)aSelector"
	^12! !

"May 30, 2010 -> 11:22:31"!

! (Delta mirrorFor: #ObjectiveCMethodSignatureForSelectorArguments) methodsFor: 'accessing' !
receiver

	^ObjectiveCAlien new
		unsignedLongAt: (self unsignedLongAt: 1);
		yourself! !

"May 30, 2010 -> 11:22:43"!

! (Delta mirrorFor: #ObjectiveCMethodSignatureForSelectorArguments) methodsFor: 'accessing' !
selector

	^ObjectiveCAlien new
		unsignedLongAt: (self unsignedLongAt: 5);
		yourself! !

"May 30, 2010 -> 11:23:2"!

! (Delta mirrorFor: #ObjectiveCMethodSignatureForSelectorArguments) methodsFor: 'accessing' !
selector

	^ObjectiveCAlien new
		unsignedLongAt: (self unsignedLongAt: 9);
		yourself! !

"May 30, 2010 -> 11:24:23"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'NSObject'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien |
												self vmHalt.
												pair := AddressToBothInstancesMap at: args target addressField.
												result := pair first forward: args to: pair last.
												callbackResult returnInteger: (resultAlien := self for: result) addressField.
												args setReturnValue: resultAlien pointer]
									argsClass: ObjectiveCMethodSignature.
			SignatureCallback := Callback
									block: [:args :callbackResult|
													|selector stream|
													selector := (ObjectiveCAlien atAddress: (args unsignedLongAt: 5)) asSmalltalkSelector.
													stream := CharacterReadWriteStream on: (String new: selector numberOfArguments + 3).
													stream nextPutAll: 'v@:'.
													selector numberOfArguments timesRepeat: [stream nextPut: $@].
													callbackResult returnInteger: stream contentsWritten asAlien pointer]
									argsClass: ObjectiveCMethodSignatureForSelectorArguments.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v12@0:4@8'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"May 30, 2010 -> 11:26:26"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'NSObject'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien |
												self vmHalt.
												pair := AddressToBothInstancesMap at: args target addressField.
												result := pair first forward: args to: pair last.
												callbackResult returnInteger: (resultAlien := self for: result) addressField.
												args setReturnValue: resultAlien pointer]
									argsClass: ObjectiveCMethodSignature.
			SignatureCallback := Callback
									block: [:args :callbackResult|
													|selector stream|
													self vmHalt.
													selector := (ObjectiveCAlien atAddress: (args unsignedLongAt: 5)) asSmalltalkSelector.
													stream := CharacterReadWriteStream on: (String new: selector numberOfArguments + 3).
													stream nextPutAll: 'v@:'.
													selector numberOfArguments timesRepeat: [stream nextPut: $@].
													callbackResult returnInteger: stream contentsWritten asAlien pointer]
									argsClass: ObjectiveCMethodSignatureForSelectorArguments.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'methodSignatureForSelector:')
				implementation: SignatureCallback thunk
				signature: 'v12@0:4:8'.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v12@0:4@8'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"May 30, 2010 -> 11:26:39"!

"System saved" !
"May 30, 2010 -> 11:28:24"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'NSObject'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien |
												self vmHalt.
												pair := AddressToBothInstancesMap at: args target addressField.
												result := pair first forward: args to: pair last.
												callbackResult returnInteger: (resultAlien := self for: result) addressField.
												args setReturnValue: resultAlien pointer]
									argsClass: ObjectiveCMethodSignature.
			SignatureCallback := Callback
									block: [:args :callbackResult|
													|selector stream|
													self vmHalt.
													selector := (ObjectiveCAlien atAddress: (args unsignedLongAt: 5)) asSmalltalkSelector.
													stream := CharacterReadWriteStream on: (String new: selector numberOfArguments + 3).
													stream nextPutAll: 'v@:'.
													selector numberOfArguments timesRepeat: [stream nextPut: $@].
													callbackResult returnInteger: stream contentsWritten asAlien pointer]
									argsClass: ObjectiveCMethodSignatureForSelectorArguments.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'methodSignatureForSelector:')
				implementation: SignatureCallback thunk
				signature: '@12@0:4:8'.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v12@0:4@8'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"May 30, 2010 -> 11:28:36"!

"System saved" !
"May 30, 2010 -> 11:29:34"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'NSObject'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien |
												self vmHalt.
												pair := AddressToBothInstancesMap at: args target addressField.
												result := pair first forward: args to: pair last.
												callbackResult returnInteger: (resultAlien := self for: result) addressField.
												args setReturnValue: resultAlien pointer]
									argsClass: ObjectiveCMethodSignature.
			SignatureCallback := Callback
									block: [:args :callbackResult|
													|selector stream|
													self vmHalt.
													selector := (ObjectiveCAlien atAddress: (args unsignedLongAt: 5)) asSmalltalkSelector.
													stream := CharacterReadWriteStream on: (String new: selector numberOfArguments + 3).
													stream nextPutAll: 'v@:'.
													selector numberOfArguments timesRepeat: [stream nextPut: $@].
													callbackResult returnInteger: stream contentsWritten asAlien pointer]
									argsClass: ObjectiveCMethodSignatureForSelectorArguments.
			"class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'methodSignatureForSelector:')
				implementation: SignatureCallback thunk
				signature: '@12@0:4:8'."
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v12@0:4@8'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"May 30, 2010 -> 11:29:39"!

"System saved" !
"May 30, 2010 -> 12:15:40"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'NSObject'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien |
												self vmHalt.
												pair := AddressToBothInstancesMap at: args target addressField.
												result := pair first forward: args to: pair last.
												callbackResult returnInteger: (resultAlien := self for: result) addressField.
												args setReturnValue: resultAlien pointer]
									argsClass: ObjectiveCMethodSignature.
			SignatureCallback := Callback
									block: [:args :callbackResult|
													|selector stream|
													self vmHalt.
													selector := (ObjectiveCAlien atAddress: (args unsignedLongAt: 5)) asSmalltalkSelector.
													stream := CharacterReadWriteStream on: (String new: selector numberOfArguments + 3).
													stream nextPutAll: 'v@:'.
													selector numberOfArguments timesRepeat: [stream nextPut: $@].
													callbackResult returnInteger: stream contentsWritten asAlien pointer]
									argsClass: ObjectiveCMethodSignatureForSelectorArguments.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'methodSignatureForSelector:')
				implementation: SignatureCallback thunk
				signature: '@12@0:4:8'.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v12@0:4@8'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"May 30, 2010 -> 12:15:47"!

"System saved" !
"May 30, 2010 -> 21:6:51"!

(Delta mirrorFor: #ObjectiveCObject)
comment: 
'Access to the raw structure of an ObjectiveC object.  Do not confuse this with ObjectiveCAlien, wich is a Smalltalk proxy for an ObjectiveC object.  
This is an indirect object (a struct, if you like); ObjectiveCAlien is a direct pointer to an object (a reference to an Objective-C object).

@interface Object
{
    Class isa;  /* A pointer to the instance''s class structure */
}

Effectively:
struct objc_object {
    struct objc_class *isa;
};


   Copyright 2008 Cadence Design Systems, Inc.
   
   Licensed under the Apache License, Version 2.0 (the ''''License''''); you may not use this file except in compliance with the License.  
   You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0
'!


"May 30, 2010 -> 21:16:24"!

(Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy)
comment: 
'This class handles forwarding messages from Objective-C back into Smalltalk.  It creates a class in Objective-C that has a forward: instance 
method. Its instances exist only in Objective-C.  The class variable AddressToBothInstancesMap is keyed by Objective-C instance address 
and has pairs of {ObjectiveCSmalltalkObjectProxy, Smalltalk object} as instances.  The Objective-C methods (forward: and ...) of 
ObjectiveCSmalltalkProxy are FFI callbacks.

/*
 *  Class Template
 */
struct ObjectiveCSmalltalkProxy {
    struct objc_class *isa;
};


   Copyright 2008 Cadence Design Systems, Inc.
   
   Licensed under the Apache License, Version 2.0 (the ''''License''''); you may not use this file except in compliance with the License.  
   You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0
'!


"May 30, 2010 -> 21:37:46"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'private-instance creation' !
ObjectiveCSmalltalkProxyClass

	ObjectiveCSmalltalkProxyClassAlien
		isNil ifTrue:  [self class installSmalltalkProxyClass].
	^ObjectiveCSmalltalkProxyClassAlien! !

"May 30, 2010 -> 21:41:23"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'instance creation' !
xxxnew "^<ObjectiveCSmalltalkObjectProxy>"

	|instance|
	(instance := self ObjectiveCSmalltalkProxyClass alloc) init.
	^(self forPointer: instance id)! !

"May 30, 2010 -> 21:41:32"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'instance creation' !
xnew "^<ObjectiveCSmalltalkObjectProxy>"
	^(self forPointer: (self Cmalloc: self dataSize)) initialize! !

"May 30, 2010 -> 21:41:37"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'instance creation' !
new "^<ObjectiveCSmalltalkObjectProxy>"

	|instance|
	(instance := self ObjectiveCSmalltalkProxyClass alloc) init.
	^(self forPointer: instance id)! !

"May 30, 2010 -> 21:41:56"!

"System saved" !
"May 30, 2010 -> 21:43:10"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'private-instance creation' !
ObjectiveCSmalltalkProxyClass

	ObjectiveCSmalltalkProxyClassAlien
		isNil ifTrue:  [self installSmalltalkProxyClass].
	^ObjectiveCSmalltalkProxyClassAlien! !

"May 30, 2010 -> 21:43:15"!

"System saved" !
"June 1, 2010 -> 0:46:37"!

! (Delta mirrorFor: #ObjectiveCAlien) methodsFor: 'accessing' !
xxxisa
	| address |
	^(address := self unsignedLongAt: 1) ~= 0 ifTrue:
		[ObjectiveCClassAlien forPointer: ((Alien forPointer: address) unsignedLongAt: 1)]! !

"June 1, 2010 -> 0:47:7"!

! (Delta mirrorFor: #ObjectiveCAlien) methodsFor: 'accessing' !
isa
	| address |
	^(address := self unsignedLongAt: 1) ~= 0 ifTrue:
		[ObjectiveCClassAlien forPointer: address]! !

"June 1, 2010 -> 0:47:17"!

"System saved" !
"June 1, 2010 -> 23:40:39"!

! (Delta mirrorFor: #ObjectiveCAlien) methodsFor: 'accessing' !
isa
	| address |
	^(address := self addressField) ~= 0 ifTrue:
		[ObjectiveCClassAlien forPointer: ((Alien forPointer: address) unsignedLongAt: 1)]! !

"June 1, 2010 -> 23:40:59"!

"System saved" !
"June 1, 2010 -> 23:51:1"!

! (Delta mirrorFor: #ObjectiveCClassAlien) methodsFor: 'coercing' !
asObjectiveCClass ^<ObjectiveCClass>
	"Answer a struct objc_class object (ObjectiveCClass) for the receivers class."
	^ObjectiveCClass atAddress: (self addressField)! !

"June 1, 2010 -> 23:51:7"!

"System saved" !
"June 1, 2010 -> 23:57:16"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'NSObject'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien |
												self vmHalt.
												pair := AddressToBothInstancesMap at: args target addressField.
												result := pair first forward: args to: pair last.
												callbackResult returnInteger: (resultAlien := self for: result) addressField.
												args setReturnValue: resultAlien pointer]
									argsClass: ObjectiveCMethodSignature.
			SignatureCallback := Callback
									block: [:args :callbackResult|
													|selector stream|
													self vmHalt.
													selector := (ObjectiveCAlien atAddress: args selector) asSmalltalkSelector.
													stream := CharacterReadWriteStream on: (String new: selector numberOfArguments + 3).
													stream nextPutAll: 'v@:'.
													selector numberOfArguments timesRepeat: [stream nextPut: $@].
													callbackResult returnInteger: stream contentsWritten asAlien pointer]
									argsClass: ObjectiveCMethodSignatureForSelectorArguments.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'methodSignatureForSelector:')
				implementation: SignatureCallback thunk
				signature: '@12@0:4:8'.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v12@0:4@8'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"June 1, 2010 -> 23:57:38"!

"System saved" !
"June 2, 2010 -> 0:1:17"!

! (Delta mirrorFor: #ObjectiveCMethodSignatureForSelectorArguments) methodsFor: 'accessing' !
selector

	^ObjectiveCAlien atAddress: (self unsignedLongAt: 9);
		yourself! !

"June 2, 2010 -> 0:1:20"!

! (Delta mirrorFor: #ObjectiveCMethodSignatureForSelectorArguments) methodsFor: 'accessing' !
receiver

	^ObjectiveCAlien atAddress: (self unsignedLongAt: 1);
		yourself! !

"June 2, 2010 -> 0:1:30"!

! (Delta mirrorFor: #ObjectiveCMethodSignatureForSelectorArguments) methodsFor: 'accessing' !
selector

	^ObjectiveCAlien atAddress: (self unsignedLongAt: 9)! !

"June 2, 2010 -> 0:1:33"!

! (Delta mirrorFor: #ObjectiveCMethodSignatureForSelectorArguments) methodsFor: 'accessing' !
receiver

	^ObjectiveCAlien atAddress: (self unsignedLongAt: 1)! !

"June 2, 2010 -> 0:1:37"!

"System saved" !
"June 2, 2010 -> 0:22:58"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'NSObject'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien |
												self vmHalt.
												pair := AddressToBothInstancesMap at: args target addressField.
												result := pair first forward: args to: pair last.
												callbackResult returnInteger: (resultAlien := self for: result) addressField.
												args setReturnValue: resultAlien pointer]
									argsClass: ObjectiveCMethodSignature.
			SignatureCallback := Callback
									block: [:args :callbackResult|
													|selector stream|
													self vmHalt.
													selector := args selector asSmalltalkSelector.
													stream := CharacterReadWriteStream on: (String new: selector numberOfArguments + 3).
													stream nextPutAll: 'v@:'.
													selector numberOfArguments timesRepeat: [stream nextPut: $@].
													callbackResult returnInteger: stream contentsWritten asAlien pointer]
									argsClass: ObjectiveCMethodSignatureForSelectorArguments.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'methodSignatureForSelector:')
				implementation: SignatureCallback thunk
				signature: '@12@0:4:8'.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v12@0:4@8'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"June 2, 2010 -> 0:23:10"!

"System saved" !
"June 2, 2010 -> 0:34:44"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'NSObject'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien |
												self vmHalt.
												pair := AddressToBothInstancesMap at: args target addressField.
												result := pair first forward: args to: pair last.
												callbackResult returnInteger: (resultAlien := self for: result) addressField.
												args setReturnValue: resultAlien pointer]
									argsClass: ObjectiveCMethodSignature.
			SignatureCallback := Callback
									block: [:args :callbackResult|
													|selector stream|
													"self vmHalt."
													selector := args selector asSmalltalkSelector.
													stream := CharacterReadWriteStream on: (String new: selector numberOfArguments + 3).
													stream nextPutAll: 'v@:'.
													selector numberOfArguments timesRepeat: [stream nextPut: $@].
													callbackResult returnInteger: stream contentsWritten asAlien pointer]
									argsClass: ObjectiveCMethodSignatureForSelectorArguments.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'methodSignatureForSelector:')
				implementation: SignatureCallback thunk
				signature: '@12@0:4:8'.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v12@0:4@8'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"June 2, 2010 -> 0:34:50"!

"System saved" !
"June 2, 2010 -> 0:35:58"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'NSObject'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien |
												self vmHalt.
												pair := AddressToBothInstancesMap at: args target addressField.
												result := pair first forward: args to: pair last.
												callbackResult returnInteger: (resultAlien := self for: result) addressField.
												args setReturnValue: resultAlien pointer]
									argsClass: ObjectiveCMethodSignature.
			SignatureCallback := Callback
									block: [:args :callbackResult|
													|selector stream|
													selector := args selector asSmalltalkSelector.
													stream := CharacterReadWriteStream on: (String new: selector numberOfArguments + 3).
													stream nextPutAll: 'v@:'.
													selector numberOfArguments timesRepeat: [stream nextPut: $@].
													self vmHalt.
													callbackResult returnInteger: stream contentsWritten asAlien pointer]
									argsClass: ObjectiveCMethodSignatureForSelectorArguments.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'methodSignatureForSelector:')
				implementation: SignatureCallback thunk
				signature: '@12@0:4:8'.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v12@0:4@8'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"June 2, 2010 -> 0:36:5"!

"System saved" !
"June 2, 2010 -> 0:36:52"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'NSObject'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien |
												self vmHalt.
												pair := AddressToBothInstancesMap at: args target addressField.
												result := pair first forward: args to: pair last.
												callbackResult returnInteger: (resultAlien := self for: result) addressField.
												args setReturnValue: resultAlien pointer]
									argsClass: ObjectiveCMethodSignature.
			SignatureCallback := Callback
									block: [:args :callbackResult|
													|selector stream|
													selector := args selector asSmalltalkSelector.
													self vmHalt.
													stream := CharacterReadWriteStream on: (String new: selector numberOfArguments + 3).
													stream nextPutAll: 'v@:'.
													selector numberOfArguments timesRepeat: [stream nextPut: $@].
													callbackResult returnInteger: stream contentsWritten asAlien pointer]
									argsClass: ObjectiveCMethodSignatureForSelectorArguments.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'methodSignatureForSelector:')
				implementation: SignatureCallback thunk
				signature: '@12@0:4:8'.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v12@0:4@8'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"June 2, 2010 -> 0:36:58"!

"System saved" !
"June 2, 2010 -> 0:37:35"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'NSObject'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien |
												self vmHalt.
												pair := AddressToBothInstancesMap at: args target addressField.
												result := pair first forward: args to: pair last.
												callbackResult returnInteger: (resultAlien := self for: result) addressField.
												args setReturnValue: resultAlien pointer]
									argsClass: ObjectiveCMethodSignature.
			SignatureCallback := Callback
									block: [:args :callbackResult|
													|selector stream|
													selector := args selector vmHalt asSmalltalkSelector.
													self vmHalt.
													stream := CharacterReadWriteStream on: (String new: selector numberOfArguments + 3).
													stream nextPutAll: 'v@:'.
													selector numberOfArguments timesRepeat: [stream nextPut: $@].
													callbackResult returnInteger: stream contentsWritten asAlien pointer]
									argsClass: ObjectiveCMethodSignatureForSelectorArguments.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'methodSignatureForSelector:')
				implementation: SignatureCallback thunk
				signature: '@12@0:4:8'.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v12@0:4@8'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"June 2, 2010 -> 0:37:41"!

"System saved" !
"June 2, 2010 -> 0:45:13"!

! (Delta mirrorFor: #ObjectiveCMethodSignatureForSelectorArguments) methodsFor: 'accessing' !
receiver

	^ObjectiveCAlien forPointer: (self unsignedLongAt: 1)! !

"June 2, 2010 -> 0:45:15"!

! (Delta mirrorFor: #ObjectiveCMethodSignatureForSelectorArguments) methodsFor: 'accessing' !
selector

	^ObjectiveCAlien forPointer: (self unsignedLongAt: 9)! !

"June 2, 2010 -> 0:45:37"!

"System saved" !
"June 2, 2010 -> 1:49:39"!

! (Delta mirrorFor: #CompressedSymbol) methodsFor: 'accessing' !
numberOfArguments ^<SmallInteger>
  ^{{self primitiveSymbolNumberOfArguments}}
! !

"June 2, 2010 -> 1:50:36"!

"System saved" !
"June 2, 2010 -> 20:21:35"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'NSObject'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien |
												"self vmHalt."
												pair := AddressToBothInstancesMap at: args target addressField.
												result := pair first forward: args to: pair last.
												callbackResult returnInteger: (resultAlien := self for: result) addressField.
												args setReturnValue: resultAlien pointer]
									argsClass: ObjectiveCMethodSignature.
			SignatureCallback := Callback
									block: [:args :callbackResult|
													|selector stream|
													selector := args selector vmHalt asSmalltalkSelector.
													self vmHalt.
													stream := CharacterReadWriteStream on: (String new: selector numberOfArguments + 3).
													stream nextPutAll: 'v@:'.
													selector numberOfArguments timesRepeat: [stream nextPut: $@].
													callbackResult returnInteger: stream contentsWritten asAlien pointer]
									argsClass: ObjectiveCMethodSignatureForSelectorArguments.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'methodSignatureForSelector:')
				implementation: SignatureCallback thunk
				signature: '@12@0:4:8'.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v12@0:4@8'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"June 2, 2010 -> 20:21:46"!

"System saved" !
"June 2, 2010 -> 20:24:25"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'NSObject'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien |
												self vmHalt.
												pair := AddressToBothInstancesMap at: args target addressField.
												result := pair first forward: args to: pair last.
												callbackResult returnInteger: (resultAlien := self for: result) addressField.
												args setReturnValue: resultAlien pointer]
									argsClass: ObjectiveCMethodSignature.
			SignatureCallback := Callback
									block: [:args :callbackResult|
													|selector stream|
													selector := args selector vmHalt asSmalltalkSelector.
													"self vmHalt."
													stream := CharacterReadWriteStream on: (String new: selector numberOfArguments + 3).
													stream nextPutAll: 'v@:'.
													selector numberOfArguments timesRepeat: [stream nextPut: $@].
													callbackResult returnInteger: stream contentsWritten asAlien pointer]
									argsClass: ObjectiveCMethodSignatureForSelectorArguments.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'methodSignatureForSelector:')
				implementation: SignatureCallback thunk
				signature: '@12@0:4:8'.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v12@0:4@8'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"June 2, 2010 -> 20:24:31"!

"System saved" !
"June 2, 2010 -> 21:5:2"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'NSObject'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien |
												self vmHalt.
												pair := AddressToBothInstancesMap at: args target addressField.
												result := pair first forward: args to: pair last.
												callbackResult returnInteger: (resultAlien := self for: result) addressField.
												args setReturnValue: resultAlien pointer]
									argsClass: ObjectiveCMethodSignature.
			SignatureCallback := Callback
									block: [:args :callbackResult|
													|selector stream|
													selector := args selector "vmHalt" asSmalltalkSelector.
													"self vmHalt."
													stream := CharacterReadWriteStream on: (String new: selector numberOfArguments + 3).
													stream nextPutAll: 'v@:'.
													selector numberOfArguments timesRepeat: [stream nextPut: $@].
													callbackResult returnInteger: stream contentsWritten asAlien pointer]
									argsClass: ObjectiveCMethodSignatureForSelectorArguments.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'methodSignatureForSelector:')
				implementation: SignatureCallback thunk
				signature: '@12@0:4:8'.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v12@0:4@8'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"June 2, 2010 -> 21:5:9"!

"System saved" !
"June 2, 2010 -> 21:48:11"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'NSObject'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien |
												self vmHalt.
												pair := AddressToBothInstancesMap at: args target addressField.
												result := pair first forward: args to: pair last.
												callbackResult returnInteger: (resultAlien := self for: result) addressField.
												args setReturnValue: resultAlien pointer]
									argsClass: ObjectiveCMethodSignature.
			SignatureCallback := Callback
									block: [:args :callbackResult|
													|selector stream|
													selector := args selector "vmHalt" asSmalltalkSelector.
													"self vmHalt."
													stream := CharacterReadWriteStream on: (String new: selector numberOfArguments + 3).
													stream nextPutAll: 'v@:'.
													selector numberOfArguments timesRepeat: [stream nextPut: $@].
													callbackResult returnInteger: stream contentsWritten asAlien pointer vmHalt]
									argsClass: ObjectiveCMethodSignatureForSelectorArguments.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'methodSignatureForSelector:')
				implementation: SignatureCallback thunk
				signature: '@12@0:4:8'.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v12@0:4@8'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"June 2, 2010 -> 21:48:18"!

"System saved" !
"June 2, 2010 -> 23:30:52"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'NSObject'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien |
												self vmHalt.
												pair := AddressToBothInstancesMap at: args target addressField.
												result := pair first forward: args to: pair last.
												callbackResult returnInteger: (resultAlien := self for: result) addressField.
												args setReturnValue: resultAlien pointer]
									argsClass: ObjectiveCMethodSignature.
			SignatureCallback := Callback
									block: [:args :callbackResult|
													|selector stream|
													selector := args selector "vmHalt" asSmalltalkSelector.
													"self vmHalt."
													stream := CharacterReadWriteStream on: (String new: selector numberOfArguments + 3).
													stream nextPutAll: 'v@:'.
													selector numberOfArguments timesRepeat: [stream nextPut: $@].
													callbackResult returnInteger: stream contentsWritten asAlien pointer. self vmHalt]
									argsClass: ObjectiveCMethodSignatureForSelectorArguments.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'methodSignatureForSelector:')
				implementation: SignatureCallback thunk
				signature: '@12@0:4:8'.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v12@0:4@8'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"June 2, 2010 -> 23:31:8"!

"System saved" !
"June 3, 2010 -> 0:56:46"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'NSObject'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien |
												self vmHalt.
												pair := AddressToBothInstancesMap at: args target addressField.
												result := pair first forward: args to: pair last.
												callbackResult returnInteger: (resultAlien := self for: result) addressField.
												args setReturnValue: resultAlien pointer]
									argsClass: ObjectiveCMethodSignature.
			SignatureCallback := Callback
									block: [:args :callbackResult|
													|selector stream|
													selector := args selector "vmHalt" asSmalltalkSelector.
													"self vmHalt."
													stream := CharacterReadWriteStream on: (String new: selector numberOfArguments + 3).
													stream nextPutAll: 'v@:'.
													selector numberOfArguments timesRepeat: [stream nextPut: $@].
													callbackResult returnInteger: (ObjectiveCMethodSignature fromTypes: stream contentsWritten) id]
									argsClass: ObjectiveCMethodSignatureForSelectorArguments.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'methodSignatureForSelector:')
				implementation: SignatureCallback thunk
				signature: '@12@0:4:8'.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v12@0:4@8'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"June 3, 2010 -> 0:56:56"!

"System saved" !
"June 4, 2010 -> 0:51:12"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'NSObject'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien |
												self vmHalt.
												pair := AddressToBothInstancesMap at: args target addressField.
												result := pair first forward: args to: pair last.
												callbackResult returnInteger: (resultAlien := self for: result) addressField.
												args setReturnValue: resultAlien pointer]
									argsClass: ObjectiveCMethodSignature.
			SignatureCallback := Callback
									block: [:args :callbackResult|
													|selector stream|
													selector := args selector asSmalltalkSelector.
													stream := CharacterReadWriteStream on: (String new: selector numberOfArguments + 3).
													stream nextPutAll: 'v@:'.
													selector numberOfArguments timesRepeat: [stream nextPut: $@].
													callbackResult returnInteger: (ObjectiveCMethodSignature fromTypes: stream contentsWritten) id]
									argsClass: ObjectiveCMethodSignatureForSelectorArguments.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'methodSignatureForSelector:')
				implementation: SignatureCallback thunk
				signature: '@12@0:4:8'.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v12@0:4@8'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"June 4, 2010 -> 0:51:44"!

"System saved" !
"June 4, 2010 -> 23:3:51"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'NSObject'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien |
												pair := AddressToBothInstancesMap at: args target addressField.
												self vmHalt.
												result := pair first forward: args to: pair last.
												callbackResult returnInteger: (resultAlien := self for: result) addressField.
												args setReturnValue: resultAlien pointer]
									argsClass: ObjectiveCMethodSignature.
			SignatureCallback := Callback
									block: [:args :callbackResult|
													|selector stream|
													selector := args selector asSmalltalkSelector.
													stream := CharacterReadWriteStream on: (String new: selector numberOfArguments + 3).
													stream nextPutAll: 'v@:'.
													selector numberOfArguments timesRepeat: [stream nextPut: $@].
													callbackResult returnInteger: (ObjectiveCMethodSignature fromTypes: stream contentsWritten) id]
									argsClass: ObjectiveCMethodSignatureForSelectorArguments.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'methodSignatureForSelector:')
				implementation: SignatureCallback thunk
				signature: '@12@0:4:8'.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v12@0:4@8'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"June 4, 2010 -> 23:3:56"!

"System saved" !
"June 5, 2010 -> 9:57:34"!

Delta define: #NSForwardInvocation as: (
(Class subclassOf: 'ObjectiveCAlien' instanceVariables: '')) !


"June 5, 2010 -> 9:57:54"!

! (Delta mirrorFor: #NSForwardInvocation) methodsFor: 'accessing' !
args

	| argCount args signature |
	signature := self methodSignature.
	argCount := signature numberOfArguments.
	args := OrderedCollection new.
	2 to: argCount - 1 do: [:i| | arg |
		arg := ObjectiveCAlien newGC: (signature argSize: i).
		self getArgument: arg pointer atIndex: i.
		args add: arg].
	^args asArray! !

"June 5, 2010 -> 9:58:2"!

! (Delta mirrorFor: #NSForwardInvocation) methodsFor: 'accessing' !
args: args <Array[ObjectiveCAlien]>

	1 to: args size do: [:i| | arg |
		self setArgument: (args at: i) pointer atIndex: i + 1]! !

"June 5, 2010 -> 9:58:10"!

! (Delta mirrorFor: #NSForwardInvocation) methodsFor: 'accessing' !
methodSignature

	^ObjectiveCMethodSignature fromAlien: super methodSignature! !

"June 5, 2010 -> 10:4:52"!

Delta define: #ObjectiveCNSForwardInvocation as: (
(Class subclassOf: 'ObjectiveCAlien' instanceVariables: '')) !


"June 5, 2010 -> 10:18:51"!

! (Delta mirrorFor: #ObjectiveCNSForwardInvocation) methodsFor: 'accessing' !
methodSignature

	^ObjectiveCMethodSignature fromAlien: super methodSignature! !

"June 5, 2010 -> 10:18:59"!

! (Delta mirrorFor: #ObjectiveCNSForwardInvocation) methodsFor: 'accessing' !
args: args <Array[ObjectiveCAlien]>

	1 to: args size do: [:i| | arg |
		self setArgument: (args at: i) pointer atIndex: i + 1]! !

"June 5, 2010 -> 10:19:9"!

! (Delta mirrorFor: #ObjectiveCNSForwardInvocation) methodsFor: 'accessing' !
args

	| argCount args signature |
	signature := self methodSignature.
	argCount := signature numberOfArguments.
	args := OrderedCollection new.
	2 to: argCount - 1 do: [:i| | arg |
		arg := ObjectiveCAlien newGC: (signature argSize: i).
		self getArgument: arg pointer atIndex: i.
		args add: arg].
	^args asArray! !

"June 5, 2010 -> 10:19:42"!

(Delta mirrorFor: #NSForwardInvocation) removeDefinitionIfFail: [] !


"June 5, 2010 -> 10:21:6"!

Delta define: #ObjectiveCNSInvocation as: (
(Class subclassOf: 'ObjectiveCAlien' instanceVariables: '')) !


"June 5, 2010 -> 10:21:45"!

! (Delta mirrorFor: #ObjectiveCNSInvocation) methodsFor: 'accessing' !
methodSignature

	^ObjectiveCMethodSignature fromAlien: super methodSignature! !

"June 5, 2010 -> 10:21:52"!

! (Delta mirrorFor: #ObjectiveCNSInvocation) methodsFor: 'accessing' !
args: args <Array[ObjectiveCAlien]>

	1 to: args size do: [:i| | arg |
		self setArgument: (args at: i) pointer atIndex: i + 1]! !

"June 5, 2010 -> 10:21:59"!

! (Delta mirrorFor: #ObjectiveCNSInvocation) methodsFor: 'accessing' !
args

	| argCount args signature |
	signature := self methodSignature.
	argCount := signature numberOfArguments.
	args := OrderedCollection new.
	2 to: argCount - 1 do: [:i| | arg |
		arg := ObjectiveCAlien newGC: (signature argSize: i).
		self getArgument: arg pointer atIndex: i.
		args add: arg].
	^args asArray! !

"June 5, 2010 -> 10:22:28"!

(Delta mirrorFor: #ObjectiveCForwardInvocation) removeDefinitionIfFail: [] !


"June 5, 2010 -> 10:24:3"!

Delta define: #ObjectiveCForwardInvocationArguments as: (
(Class subclassOf: 'Alien' instanceVariables: '')) !


"June 5, 2010 -> 10:27:25"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
newForCallbackArgs

	^(self primitiveNew: 8)
		size: self dataSize negated;
		yourself! !

"June 5, 2010 -> 10:28:3"!

! (Delta mirrorFor: #ObjectiveCForwardInvocationArguments) classSide methodsFor: 'instance creation' !
dataSize

	^4! !

"June 5, 2010 -> 10:29:31"!

! (Delta mirrorFor: #ObjectiveCForwardInvocationArguments) methodsFor: 'accessing' !
invocation

	^ObjectiveCForwardInvocation atAddress: (self unsignedLongAt: 1)! !

"June 5, 2010 -> 10:29:51"!

! (Delta mirrorFor: #ObjectiveCForwardInvocationArguments) methodsFor: 'accessing' !
invocation

	^ObjectiveCNSInvocation atAddress: (self unsignedLongAt: 1)! !

"June 5, 2010 -> 10:30:7"!

(Delta mirrorFor: #ObjectiveCForwardInvocation) removeDefinitionIfFail: [] !


"June 5, 2010 -> 10:30:44"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'NSObject'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien |
												pair := AddressToBothInstancesMap at: args target addressField.
												self vmHalt.
												result := pair first forward: args to: pair last.
												callbackResult returnInteger: (resultAlien := self for: result) addressField.
												args setReturnValue: resultAlien pointer]
									argsClass: ObjectiveCForwardInvocationArguments.
			SignatureCallback := Callback
									block: [:args :callbackResult|
													|selector stream|
													selector := args selector asSmalltalkSelector.
													stream := CharacterReadWriteStream on: (String new: selector numberOfArguments + 3).
													stream nextPutAll: 'v@:'.
													selector numberOfArguments timesRepeat: [stream nextPut: $@].
													callbackResult returnInteger: (ObjectiveCMethodSignature fromTypes: stream contentsWritten) id]
									argsClass: ObjectiveCMethodSignatureForSelectorArguments.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'methodSignatureForSelector:')
				implementation: SignatureCallback thunk
				signature: '@12@0:4:8'.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v12@0:4@8'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"June 5, 2010 -> 10:30:54"!

"System saved" !
"June 5, 2010 -> 10:37:0"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'NSObject'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien invocation |
												invocation := args invocation.
												pair := AddressToBothInstancesMap at: invocation target addressField.
												self vmHalt.
												result := pair first forward: invocation to: pair last.
												callbackResult returnInteger: (resultAlien := self for: result) addressField.
												invocation setReturnValue: resultAlien pointer]
									argsClass: ObjectiveCForwardInvocationArguments.
			SignatureCallback := Callback
									block: [:args :callbackResult|
													|selector stream|
													selector := args selector asSmalltalkSelector.
													stream := CharacterReadWriteStream on: (String new: selector numberOfArguments + 3).
													stream nextPutAll: 'v@:'.
													selector numberOfArguments timesRepeat: [stream nextPut: $@].
													callbackResult returnInteger: (ObjectiveCMethodSignature fromTypes: stream contentsWritten) id]
									argsClass: ObjectiveCMethodSignatureForSelectorArguments.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'methodSignatureForSelector:')
				implementation: SignatureCallback thunk
				signature: '@12@0:4:8'.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v12@0:4@8'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"June 5, 2010 -> 10:37:4"!

"System saved" !
"June 5, 2010 -> 11:8:50"!

! (Delta mirrorFor: #ObjectiveCForwardInvocationArguments) methodsFor: 'accessing' !
invocation
Transcript cr; print: self addressField.
Transcript cr; print: (self unsignedLongAt: 1); cr.
	^ObjectiveCNSInvocation atAddress: (self unsignedLongAt: 1)! !

"June 5, 2010 -> 11:8:55"!

"System saved" !
"June 5, 2010 -> 11:11:38"!

! (Delta mirrorFor: #ObjectiveCForwardInvocationArguments) methodsFor: 'accessing' !
invocation
Transcript cr.
self addressField printBareHexOn: Transcript.
Transcript cr.
(self unsignedLongAt: 1) printBareHexOn: Transcript.
Transcript cr.
	^ObjectiveCNSInvocation atAddress: (self unsignedLongAt: 1)! !

"June 5, 2010 -> 11:11:43"!

"System saved" !
"June 5, 2010 -> 11:17:8"!

! (Delta mirrorFor: #ObjectiveCForwardInvocationArguments) methodsFor: 'accessing' !
invocation

	^ObjectiveCNSInvocation atAddress: (self unsignedLongAt: 1)! !

"June 5, 2010 -> 11:17:26"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'NSObject'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien invocation |
												invocation := args invocation.
												pair := AddressToBothInstancesMap at: invocation vmHalt target addressField.
												self vmHalt.
												result := pair first forward: invocation to: pair last.
												callbackResult returnInteger: (resultAlien := self for: result) addressField.
												invocation setReturnValue: resultAlien pointer]
									argsClass: ObjectiveCForwardInvocationArguments.
			SignatureCallback := Callback
									block: [:args :callbackResult|
													|selector stream|
													selector := args selector asSmalltalkSelector.
													stream := CharacterReadWriteStream on: (String new: selector numberOfArguments + 3).
													stream nextPutAll: 'v@:'.
													selector numberOfArguments timesRepeat: [stream nextPut: $@].
													callbackResult returnInteger: (ObjectiveCMethodSignature fromTypes: stream contentsWritten) id]
									argsClass: ObjectiveCMethodSignatureForSelectorArguments.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'methodSignatureForSelector:')
				implementation: SignatureCallback thunk
				signature: '@12@0:4:8'.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v12@0:4@8'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"June 5, 2010 -> 11:17:34"!

"System saved" !
"June 5, 2010 -> 11:22:9"!

! (Delta mirrorFor: #ObjectiveCForwardInvocationArguments) methodsFor: 'accessing' !
invocation

	^ObjectiveCNSInvocation atAddress: (self unsignedLongAt: 9)! !

"June 5, 2010 -> 11:22:21"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'NSObject'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien invocation |
												invocation := args invocation.
												pair := AddressToBothInstancesMap at: invocation "vmHalt" target addressField.
												self vmHalt.
												result := pair first forward: invocation to: pair last.
												callbackResult returnInteger: (resultAlien := self for: result) addressField.
												invocation setReturnValue: resultAlien pointer]
									argsClass: ObjectiveCForwardInvocationArguments.
			SignatureCallback := Callback
									block: [:args :callbackResult|
													|selector stream|
													selector := args selector asSmalltalkSelector.
													stream := CharacterReadWriteStream on: (String new: selector numberOfArguments + 3).
													stream nextPutAll: 'v@:'.
													selector numberOfArguments timesRepeat: [stream nextPut: $@].
													callbackResult returnInteger: (ObjectiveCMethodSignature fromTypes: stream contentsWritten) id]
									argsClass: ObjectiveCMethodSignatureForSelectorArguments.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'methodSignatureForSelector:')
				implementation: SignatureCallback thunk
				signature: '@12@0:4:8'.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v12@0:4@8'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"June 5, 2010 -> 11:22:25"!

"System saved" !
"June 5, 2010 -> 11:22:59"!

! (Delta mirrorFor: #ObjectiveCForwardInvocationArguments) classSide methodsFor: 'instance creation' !
dataSize

	^12! !

"June 5, 2010 -> 11:23:4"!

"System saved" !
"June 5, 2010 -> 11:57:36"!

! (Delta mirrorFor: #ObjectiveCForwardInvocationArguments) methodsFor: 'accessing' !
invocation

	^ObjectiveCNSInvocation forPointer: (self unsignedLongAt: 9)! !

"June 5, 2010 -> 11:57:46"!

"System saved" !
"June 5, 2010 -> 12:16:10"!

! (Delta mirrorFor: #ObjectiveCNSInvocation) methodsFor: 'accessing' !
selector

	| selectorAlien |
	selectorAlien := ObjectiveCAlien forPointer: (super selector addressField).
	^selectorAlien asSmalltalkSelector! !

"June 5, 2010 -> 12:16:26"!

! (Delta mirrorFor: #ObjectiveCNSInvocation) methodsFor: 'accessing' !
selector ^<Symbol>

	| selectorAlien |
	selectorAlien := ObjectiveCAlien forPointer: (super selector addressField).
	^selectorAlien asSmalltalkSelector! !

"June 5, 2010 -> 12:18:2"!

! (Delta mirrorFor: #ObjectiveCNSInvocation) methodsFor: 'accessing' !
selector ^<Symbol>

	^ObjectiveCAlien forPointer: (super selector addressField)! !

"June 5, 2010 -> 12:19:3"!

(Delta mirrorFor: #ObjectiveCNSInvocation) removeMethod: #selector ifAbsent: [] !


"June 5, 2010 -> 12:20:59"!

! (Delta mirrorFor: #FixedSizeTypeHandler) classSide methodsFor: 'instance creation' !
forSelector

	^(self new)
		initAllocBlock: [ObjectiveCAlien new: 4]
		resultBlock: [:alien| alien];
		yourself! !

"June 5, 2010 -> 12:22:17"!

! (Delta mirrorFor: #FixedSizeTypeHandler) methodsFor: 'initialization' !
initAllocBlock: alloc

	self initAllocBlock: alloc resultBlock: [:alien| alien]! !

"June 5, 2010 -> 12:24:34"!

(Delta mirrorFor: #FixedSizeTypeHandler) classSide removeMethod: #forSelector ifAbsent: [] !


"June 5, 2010 -> 12:24:48"!

! (Delta mirrorFor: #ObjectiveCAlien) classSide methodsFor: 'class initialization' !
initializeMethodTypeMap
	"self initializeMethodTypeMap"
	"ObjectiveCAlien initializeMethodTypeMap"
	"See /usr/include/objc/objc_class.h and
	 The Objective-C 2.0 Programming Language, Ch 12: The Runtime System, sec: Type Encodings."
	ReturnTypeHandlers := IdentityDictionary new: 32.
	ReturnTypeHandlers
		at: $@ "_C_ID"					put: (FixedSizeTypeHandler forClass: ObjectiveCAlien);
		at: $# "_C_CLASS"			put: (FixedSizeTypeHandler forClass: ObjectiveCClassAlien);
		at: $: "_C_SEL"					put: (FixedSizeTypeHandler forClass: ObjectiveCAlien);
		at: $c "_CHR"						put: FixedSizeTypeHandler forByte;
		at: $C "_C_UCHR"			put: FixedSizeTypeHandler forUnsignedByte;
		at: $s "_C_SHT"					put: FixedSizeTypeHandler forShort;
		at: $S "_C_USHT"				put: FixedSizeTypeHandler forUnsignedShort;
		at: $i "_C_INT"					put: FixedSizeTypeHandler forLong;
		at: $I "_C_UINT"					put: FixedSizeTypeHandler forUnsignedLong;
		at: $l "_C_LNG"					put: FixedSizeTypeHandler forLong;
		at: $L "_C_ULNG"				put: FixedSizeTypeHandler forUnsignedLong;
		at: $f "_C_FLT"					put: FixedSizeTypeHandler forFloat;
		at: $d "_C_DBL"					put: FixedSizeTypeHandler forDouble;
		"at: $b" "_C_BFLD"		"put: [];"
		at: $v "_C_VOID"				put: FixedSizeTypeHandler forVoid;
		"at: $?" "_C_UNDEF"	"put: [];"
		at: $^ "_C_PTR"					put: FixedSizeTypeHandler forPointer;
		at: $* "_CHARPTR"			put: FixedSizeTypeHandler forPointer;
		at: $[ "_C_ARY_B"			put: FixedSizeTypeHandler forPointer;
		"at: $]" "_C_ARY_E"	"put: [];"
		at: $( "_C_UNION_B"		put: StructTypeHandler new;
		"at: $)" "_C_UNION_E"	"put: [];"
		at: ${ "_C_STRUCT_B"	put: StructTypeHandler new.
		"at: $}" "_C_STRUCT_E""put: []."

	MethodTypeMap := IdentityDictionary new: 32.
	MethodTypeMap
		at: $@ "_C_ID"			put: [ObjectiveCAlien new];
		at: $# "_C_CLASS"		put: [ObjectiveCClassAlien new];
		at: $: "_C_SEL"			put: [Alien new: 4];
		at: $c "_CHR"			put: [Alien new: 1];
		at: $C "_C_UCHR"		put: [Alien new: 1];
		at: $s "_C_SHT"		put: [Alien new: 2];
		at: $S "_C_USHT"		put: [Alien new: 2];
		at: $i "_C_INT"			put: [Alien new: 4];
		at: $I "_C_UINT"		put: [Alien new: 4];
		at: $l "_C_LNG"			put: [Alien new: 4];
		at: $L "_C_ULNG"		put: [Alien new: 4];
		at: $f "_C_FLT"			put: [Alien new: 4];
		at: $d "_C_DBL"		put: [Alien new: 8];
		"at: $b" "_C_BFLD"		"put: [];"
		at: $v "_C_VOID"		put: nil;
		"at: $?" "_C_UNDEF"	"put: [];"
		at: $^ "_C_PTR"		put: [Alien forPointer: 0];
		at: $* "_CHARPTR"		put: [Alien forPointer: 0].
		"at: $[" "_C_ARY_B"	"put: [];"
		"at: $]" "_C_ARY_E"	"put: [];"
		"at: $(" "_C_UNION_B"	"put: [];"
		"at: $)" "_C_UNION_E"	"put: [];"
		"at: ${" "_C_STRUCT_B""put: [];"
		"at: $}" "_C_STRUCT_E""put: []."

	FourByteParameterTypes := '@#:cCsSiIlLf^*'.
	EightByteParameterTypes := 'd'.

"#define _C_CONST			'r'
#define _C_IN				'n'
#define _C_INOUT			'N'
#define _C_OUT			'o'
#define _C_BYCOPY		'O'
#define _C_BYREF			'R'
#define _C_ONEWAY		'V'
#define _C_GCINVISIBLE	'!!'
"
	TypeQualifiers := 'nNoOrRV!!'.
	TypeQualifierCodes := TypeQualifiers asByteArray.
					
	MethodTypeResultMap := IdentityDictionary new: 32.
	MethodTypeResultMap
		at: $c "_CHR"			put: [:alien| alien unsignedByteAt: 1];
		at: $C "_C_UCHR"		put: [:alien| alien unsignedByteAt: 1];
		at: $s "_C_SHT"		put: [:alien| alien signedShortAt: 1];
		at: $S "_C_USHT"		put: [:alien| alien unsignedShortAt: 1];
		at: $i "_C_INT"			put: [:alien| alien signedLongAt: 1];
		at: $I "_C_UINT"		put: [:alien| alien unsignedLongAt: 1];
		at: $l "_C_LNG"			put: [:alien| alien signedLongAt: 1];
		at: $L "_C_ULNG"		put: [:alien| alien unsignedLongAt: 1];
		at: $f "_C_FLT"			put: [:alien| alien floatAt: 1];
		at: $d "_C_DBL"		put: [:alien| alien doubleAt: 1].
! !

"June 5, 2010 -> 12:25:24"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'NSObject'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien invocation |
												invocation := args invocation.
												pair := AddressToBothInstancesMap at: invocation target addressField.
												self vmHalt.
												result := pair first forward: invocation to: pair last.
												callbackResult returnInteger: (resultAlien := self for: result) addressField.
												invocation setReturnValue: resultAlien pointer]
									argsClass: ObjectiveCForwardInvocationArguments.
			SignatureCallback := Callback
									block: [:args :callbackResult|
													|selector stream|
													selector := args selector asSmalltalkSelector.
													stream := CharacterReadWriteStream on: (String new: selector numberOfArguments + 3).
													stream nextPutAll: 'v@:'.
													selector numberOfArguments timesRepeat: [stream nextPut: $@].
													callbackResult returnInteger: (ObjectiveCMethodSignature fromTypes: stream contentsWritten) id]
									argsClass: ObjectiveCMethodSignatureForSelectorArguments.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'methodSignatureForSelector:')
				implementation: SignatureCallback thunk
				signature: '@12@0:4:8'.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v12@0:4@8'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"June 5, 2010 -> 12:25:42"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'NSObject'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien invocation |
												invocation := args invocation.
												pair := AddressToBothInstancesMap at: invocation target id.
												self vmHalt.
												result := pair first forward: invocation to: pair last.
												callbackResult returnInteger: (resultAlien := self for: result) addressField.
												invocation setReturnValue: resultAlien pointer]
									argsClass: ObjectiveCForwardInvocationArguments.
			SignatureCallback := Callback
									block: [:args :callbackResult|
													|selector stream|
													selector := args selector asSmalltalkSelector.
													stream := CharacterReadWriteStream on: (String new: selector numberOfArguments + 3).
													stream nextPutAll: 'v@:'.
													selector numberOfArguments timesRepeat: [stream nextPut: $@].
													callbackResult returnInteger: (ObjectiveCMethodSignature fromTypes: stream contentsWritten) id]
									argsClass: ObjectiveCMethodSignatureForSelectorArguments.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'methodSignatureForSelector:')
				implementation: SignatureCallback thunk
				signature: '@12@0:4:8'.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v12@0:4@8'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"June 5, 2010 -> 12:26:23"!

"System saved" !
"June 5, 2010 -> 13:4:14"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'NSObject'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien invocation |
												invocation := args invocation.
												pair := AddressToBothInstancesMap at: invocation target id.
												result := pair first forward: invocation to: pair last.
												callbackResult returnInteger: (resultAlien := self for: result) addressField.
												invocation setReturnValue: resultAlien pointer]
									argsClass: ObjectiveCForwardInvocationArguments.
			SignatureCallback := Callback
									block: [:args :callbackResult|
													|selector stream|
													selector := args selector asSmalltalkSelector.
													stream := CharacterReadWriteStream on: (String new: selector numberOfArguments + 3).
													stream nextPutAll: 'v@:'.
													selector numberOfArguments timesRepeat: [stream nextPut: $@].
													callbackResult returnInteger: (ObjectiveCMethodSignature fromTypes: stream contentsWritten) id]
									argsClass: ObjectiveCMethodSignatureForSelectorArguments.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'methodSignatureForSelector:')
				implementation: SignatureCallback thunk
				signature: '@12@0:4:8'.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v12@0:4@8'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"June 5, 2010 -> 13:7:58"!

Delta define: #ObjectiveCSmalltalkObjectProxy as: (
(Class subclassOf: 'ObjectiveCObject' instanceVariables: '') classVariables: 'AddressToBothInstancesMap
ObjectiveCSmalltalkProxyClassAlien
SendbackCallback
ForwardCallback
SignatureCallback
SmalltalkToObjectiveCInstanceMap') !


"June 5, 2010 -> 13:11:28"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'NSObject'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			ForwardCallback := Callback
									block: [:args :resultAlien|
												| pair result |
												pair := AddressToBothInstancesMap at: args receiverAddress.
												result := pair first forward: args selector to: pair last with: args args.
												resultAlien returnInteger: (self for: result) addressField]
									argsClass: ObjectiveCForwardSignature.
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien invocation |
												invocation := args invocation.
												pair := AddressToBothInstancesMap at: invocation target id.
												result := pair first forward: invocation to: pair last.
												callbackResult returnInteger: (resultAlien := self for: result) addressField.
												invocation setReturnValue: resultAlien pointer]
									argsClass: ObjectiveCForwardInvocationArguments.
			SignatureCallback := Callback
									block: [:args :callbackResult|
													|selector stream|
													selector := args selector asSmalltalkSelector.
													stream := CharacterReadWriteStream on: (String new: selector numberOfArguments + 3).
													stream nextPutAll: 'v@:'.
													selector numberOfArguments timesRepeat: [stream nextPut: $@].
													callbackResult returnInteger: (ObjectiveCMethodSignature fromTypes: stream contentsWritten) id]
									argsClass: ObjectiveCMethodSignatureForSelectorArguments.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'methodSignatureForSelector:')
				implementation: SignatureCallback thunk
				signature: '@12@0:4:8'.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v12@0:4@8'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"June 5, 2010 -> 13:12:37"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'NSObject'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			ForwardCallback := Callback
									block: [:args :resultAlien|
												| pair result |
												pair := AddressToBothInstancesMap at: args receiverAddress.
												result := pair first forward: args selector to: pair last with: args args.
												resultAlien returnInteger: (self for: result) addressField]
									argsClass: ObjectiveCForwardSignature.
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien invocation |
												invocation := args invocation.
												pair := AddressToBothInstancesMap at: invocation target id.
												result := pair first forward: invocation to: pair last.
												callbackResult returnInteger: (resultAlien := self for: result) addressField.
												invocation setReturnValue: resultAlien pointer]
									argsClass: ObjectiveCForwardInvocationArguments.
			SignatureCallback := Callback
									block: [:args :callbackResult|
													|selector stream|
													selector := args selector asSmalltalkSelector.
													stream := CharacterReadWriteStream on: (String new: selector numberOfArguments + 3).
													stream nextPutAll: 'v@:'.
													selector numberOfArguments timesRepeat: [stream nextPut: $@].
													callbackResult returnInteger: (ObjectiveCMethodSignature fromTypes: stream contentsWritten) id]
									argsClass: ObjectiveCMethodSignatureForSelectorArguments.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forward::')
				implementation: ForwardCallback thunk
				signature: '@16@0:4:8^v12'.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'methodSignatureForSelector:')
				implementation: SignatureCallback thunk
				signature: '@12@0:4:8'.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v12@0:4@8'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"June 5, 2010 -> 13:13:6"!

"System saved" !
"June 5, 2010 -> 13:13:36"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'NSObject'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			ForwardCallback := Callback
									block: [:args :resultAlien|
												| pair result |
												self vmHalt.
												pair := AddressToBothInstancesMap at: args receiverAddress.
												result := pair first forward: args selector to: pair last with: args args.
												resultAlien returnInteger: (self for: result) addressField]
									argsClass: ObjectiveCForwardSignature.
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien invocation |
												invocation := args invocation.
												pair := AddressToBothInstancesMap at: invocation target id.
												result := pair first forward: invocation to: pair last.
												callbackResult returnInteger: (resultAlien := self for: result) addressField.
												invocation setReturnValue: resultAlien pointer]
									argsClass: ObjectiveCForwardInvocationArguments.
			SignatureCallback := Callback
									block: [:args :callbackResult|
													|selector stream|
													selector := args selector asSmalltalkSelector.
													stream := CharacterReadWriteStream on: (String new: selector numberOfArguments + 3).
													stream nextPutAll: 'v@:'.
													selector numberOfArguments timesRepeat: [stream nextPut: $@].
													callbackResult returnInteger: (ObjectiveCMethodSignature fromTypes: stream contentsWritten) id]
									argsClass: ObjectiveCMethodSignatureForSelectorArguments.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forward::')
				implementation: ForwardCallback thunk
				signature: '@16@0:4:8^v12'.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'methodSignatureForSelector:')
				implementation: SignatureCallback thunk
				signature: '@12@0:4:8'.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v12@0:4@8'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"June 5, 2010 -> 13:13:41"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'Object'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			ForwardCallback := Callback
									block: [:args :resultAlien|
												| pair result |
												self vmHalt.
												pair := AddressToBothInstancesMap at: args receiverAddress.
												result := pair first forward: args selector to: pair last with: args args.
												resultAlien returnInteger: (self for: result) addressField]
									argsClass: ObjectiveCForwardSignature.
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien invocation |
												invocation := args invocation.
												pair := AddressToBothInstancesMap at: invocation target id.
												result := pair first forward: invocation to: pair last.
												callbackResult returnInteger: (resultAlien := self for: result) addressField.
												invocation setReturnValue: resultAlien pointer]
									argsClass: ObjectiveCForwardInvocationArguments.
			SignatureCallback := Callback
									block: [:args :callbackResult|
													|selector stream|
													selector := args selector asSmalltalkSelector.
													stream := CharacterReadWriteStream on: (String new: selector numberOfArguments + 3).
													stream nextPutAll: 'v@:'.
													selector numberOfArguments timesRepeat: [stream nextPut: $@].
													callbackResult returnInteger: (ObjectiveCMethodSignature fromTypes: stream contentsWritten) id]
									argsClass: ObjectiveCMethodSignatureForSelectorArguments.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forward::')
				implementation: ForwardCallback thunk
				signature: '@16@0:4:8^v12'.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'methodSignatureForSelector:')
				implementation: SignatureCallback thunk
				signature: '@12@0:4:8'.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v12@0:4@8'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"June 5, 2010 -> 13:13:51"!

"System saved" !
"June 5, 2010 -> 13:22:53"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'Object'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			ForwardCallback := Callback
									block: [:args :resultAlien|
												| pair result |
												self vmHalt.
												pair := AddressToBothInstancesMap at: args receiverAddress.
												result := pair first forward: args selector to: pair last with: args args.
												resultAlien returnInteger: (self for: result) addressField]
									argsClass: ObjectiveCForwardSignature.
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien invocation |
												invocation := args invocation.
												pair := AddressToBothInstancesMap at: invocation target id.
												result := pair first forward: invocation to: pair last.
												callbackResult returnInteger: (resultAlien := self for: result) addressField.
												invocation setReturnValue: resultAlien pointer]
									argsClass: ObjectiveCForwardInvocationArguments.
			SignatureCallback := Callback
									block: [:args :callbackResult|
													|selector stream|
													selector := args selector asSmalltalkSelector.
													stream := CharacterReadWriteStream on: (String new: selector numberOfArguments + 3).
													stream nextPutAll: 'v@:'.
													selector numberOfArguments timesRepeat: [stream nextPut: $@].
													callbackResult returnInteger: (ObjectiveCMethodSignature fromTypes: stream contentsWritten) id]
									argsClass: ObjectiveCMethodSignatureForSelectorArguments.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forward::')
				implementation: ForwardCallback thunk
				signature: '@16@0:4:8^v12'.
			"class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'methodSignatureForSelector:')
				implementation: SignatureCallback thunk
				signature: '@12@0:4:8'.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v12@0:4@8'"].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"June 5, 2010 -> 13:23:3"!

"System saved" !
"June 5, 2010 -> 13:24:9"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'NSObject'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien invocation |
												invocation := args invocation.
												pair := AddressToBothInstancesMap at: invocation target id.
												result := pair first forward: invocation to: pair last.
												callbackResult returnInteger: (resultAlien := self for: result) addressField.
												invocation setReturnValue: resultAlien pointer]
									argsClass: ObjectiveCForwardInvocationArguments.
			SignatureCallback := Callback
									block: [:args :callbackResult|
													|selector stream|
													selector := args selector asSmalltalkSelector.
													stream := CharacterReadWriteStream on: (String new: selector numberOfArguments + 3).
													stream nextPutAll: 'v@:'.
													selector numberOfArguments timesRepeat: [stream nextPut: $@].
													callbackResult returnInteger: (ObjectiveCMethodSignature fromTypes: stream contentsWritten) id]
									argsClass: ObjectiveCMethodSignatureForSelectorArguments.
			"class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forward::')
				implementation: ForwardCallback thunk
				signature: '@16@0:4:8^v12'."
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'methodSignatureForSelector:')
				implementation: SignatureCallback thunk
				signature: '@12@0:4:8'.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v12@0:4@8'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"June 5, 2010 -> 13:24:35"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'NSObject'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien invocation |
												invocation := args invocation.
												pair := AddressToBothInstancesMap at: invocation target id.
												result := pair first forward: invocation to: pair last.
												"callbackResult returnInteger: (resultAlien := self for: result) addressField.
												invocation setReturnValue: resultAlien pointer"]
									argsClass: ObjectiveCForwardInvocationArguments.
			SignatureCallback := Callback
									block: [:args :callbackResult|
													|selector stream|
													selector := args selector asSmalltalkSelector.
													stream := CharacterReadWriteStream on: (String new: selector numberOfArguments + 3).
													stream nextPutAll: 'v@:'.
													selector numberOfArguments timesRepeat: [stream nextPut: $@].
													callbackResult returnInteger: (ObjectiveCMethodSignature fromTypes: stream contentsWritten) id]
									argsClass: ObjectiveCMethodSignatureForSelectorArguments.
			"class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forward::')
				implementation: ForwardCallback thunk
				signature: '@16@0:4:8^v12'."
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'methodSignatureForSelector:')
				implementation: SignatureCallback thunk
				signature: '@12@0:4:8'.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v12@0:4@8'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"June 5, 2010 -> 13:24:41"!

"System saved" !
"June 5, 2010 -> 13:35:47"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
defaultSignatureFor: selector

	|stream|
	stream := CharacterReadWriteStream on: (String new: selector numberOfArguments + 3).
	stream nextPutAll: 'v@:'.
	selector numberOfArguments timesRepeat: [stream nextPut: $@].
	^stream contentsWritten! !

"June 5, 2010 -> 13:37:57"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'NSObject'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien invocation |
												invocation := args invocation.
												pair := AddressToBothInstancesMap at: invocation target id.
												result := pair first forward: invocation to: pair last.
												"callbackResult returnInteger: (resultAlien := self for: result) addressField.
												invocation setReturnValue: resultAlien pointer"]
									argsClass: ObjectiveCForwardInvocationArguments.
			SignatureCallback := Callback
									block: [:args :callbackResult|
													|signatureTypes stream|
													signatureTypes := self defaultSignatureFor: args selector asSmalltalkSelector.
													callbackResult returnInteger: (ObjectiveCMethodSignature fromTypes: signatureTypes) id]
									argsClass: ObjectiveCMethodSignatureForSelectorArguments.
			"class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forward::')
				implementation: ForwardCallback thunk
				signature: '@16@0:4:8^v12'."
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'methodSignatureForSelector:')
				implementation: SignatureCallback thunk
				signature: '@12@0:4:8'.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v12@0:4@8'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"June 5, 2010 -> 13:38:11"!

"System saved" !
"June 5, 2010 -> 13:41:48"!

! (Delta mirrorFor: #MacOSXExampleModalDelegate) classSide methodsFor: 'accessing' !
signatures

	^Dictionary new
		at: #'alertDidEnd:returnCode:contextInfo:' put: 'v@:@i^v';
		yourself! !

"June 5, 2010 -> 13:50:51"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'NSObject'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien invocation |
												invocation := args invocation.
												pair := AddressToBothInstancesMap at: invocation target id.
												result := pair first forward: invocation to: pair last.
												"callbackResult returnInteger: (resultAlien := self for: result) addressField.
												invocation setReturnValue: resultAlien pointer"]
									argsClass: ObjectiveCForwardInvocationArguments.
			SignatureCallback := Callback
									block: [:args :callbackResult|
													|signatureTypes stream|
													signatureTypes := ([(AddressToBothInstancesMap at: args receiver id) last
																							signatures at: args selector asSmalltalkSelector ifAbsent: []]
																							on: MessageNotUnderstood
																							do: [:err|]) ifNil: [self defaultSignatureFor: args selector asSmalltalkSelector].
													callbackResult returnInteger: (ObjectiveCMethodSignature fromTypes: signatureTypes) id]
									argsClass: ObjectiveCMethodSignatureForSelectorArguments.
			"class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forward::')
				implementation: ForwardCallback thunk
				signature: '@16@0:4:8^v12'."
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'methodSignatureForSelector:')
				implementation: SignatureCallback thunk
				signature: '@12@0:4:8'.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v12@0:4@8'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"June 5, 2010 -> 13:52:55"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'NSObject'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien invocation |
												invocation := args invocation.
												pair := AddressToBothInstancesMap at: invocation target id.
												result := pair first forward: invocation to: pair last.
												"callbackResult returnInteger: (resultAlien := self for: result) addressField.
												invocation setReturnValue: resultAlien pointer"]
									argsClass: ObjectiveCForwardInvocationArguments.
			SignatureCallback := Callback
									block: [:args :callbackResult|
													| signatureTypes target |
													target := (AddressToBothInstancesMap at: args receiver id) last.
													signatureTypes := ([target class signatures
																								at: args selector asSmalltalkSelector
																								ifAbsent: []]
																							on: MessageNotUnderstood
																							do: [:err|]) ifNil: [self defaultSignatureFor: args selector asSmalltalkSelector].
													callbackResult returnInteger: (ObjectiveCMethodSignature fromTypes: signatureTypes) id]
									argsClass: ObjectiveCMethodSignatureForSelectorArguments.
			"class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forward::')
				implementation: ForwardCallback thunk
				signature: '@16@0:4:8^v12'."
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'methodSignatureForSelector:')
				implementation: SignatureCallback thunk
				signature: '@12@0:4:8'.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v12@0:4@8'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"June 5, 2010 -> 13:53:30"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'NSObject'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien invocation |
												invocation := args invocation.
												pair := AddressToBothInstancesMap at: invocation target id.
												result := pair first forward: invocation to: pair last.
												"callbackResult returnInteger: (resultAlien := self for: result) addressField.
												invocation setReturnValue: resultAlien pointer"]
									argsClass: ObjectiveCForwardInvocationArguments.
			SignatureCallback := Callback
									block: [:args :callbackResult|
													| signatureTypes target |
													target := (AddressToBothInstancesMap at: args receiver id) last.
													signatureTypes := ([target class signatures
																								at: args selector asSmalltalkSelector
																								ifAbsent: []]
																							on: MessageNotUnderstood
																							do: [:err|]) ifNil: [self defaultSignatureFor: args selector asSmalltalkSelector].
													callbackResult returnInteger: (ObjectiveCMethodSignature fromTypes: signatureTypes) id]
									argsClass: ObjectiveCMethodSignatureForSelectorArguments.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'methodSignatureForSelector:')
				implementation: SignatureCallback thunk
				signature: '@12@0:4:8'.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v12@0:4@8'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"June 5, 2010 -> 13:54:5"!

"System saved" !
"June 5, 2010 -> 13:56:36"!

! (Delta mirrorFor: #Object) methodsFor: 'utility' !
ifNil: block <[]>

	^self! !

"June 5, 2010 -> 13:57:40"!

! (Delta mirrorFor: #UndefinedObject) methodsFor: 'testing' !
ifNil: block <[]>

	^block value! !

"June 5, 2010 -> 13:58:14"!

"System saved" !
"June 5, 2010 -> 14:1:14"!

! (Delta mirrorFor: #ObjectiveCMethodSignature) methodsFor: 'testing' !
isVoidReturn

	^(super methodReturnType byteAt: 1) == $v asciiValue! !

"June 5, 2010 -> 14:2:53"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'NSObject'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien invocation |
												invocation := args invocation.
												pair := AddressToBothInstancesMap at: invocation target id.
												result := pair first forward: invocation to: pair last.
												invocation signature isVoidReturn
													ifFalse: ["callbackResult returnInteger: (resultAlien := self for: result) addressField."
																	invocation setReturnValue: resultAlien pointer]]
									argsClass: ObjectiveCForwardInvocationArguments.
			SignatureCallback := Callback
									block: [:args :callbackResult|
													| signatureTypes target |
													target := (AddressToBothInstancesMap at: args receiver id) last.
													signatureTypes := ([target class signatures
																								at: args selector asSmalltalkSelector
																								ifAbsent: []]
																							on: MessageNotUnderstood
																							do: [:err|]) ifNil: [self defaultSignatureFor: args selector asSmalltalkSelector].
													callbackResult returnInteger: (ObjectiveCMethodSignature fromTypes: signatureTypes) id]
									argsClass: ObjectiveCMethodSignatureForSelectorArguments.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'methodSignatureForSelector:')
				implementation: SignatureCallback thunk
				signature: '@12@0:4:8'.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v12@0:4@8'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"June 5, 2010 -> 14:3:11"!

"System saved" !
"June 5, 2010 -> 14:4:50"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'NSObject'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien invocation |
												invocation := args invocation.
												pair := AddressToBothInstancesMap at: invocation target id.
												result := pair first forward: invocation to: pair last.
												invocation methodSignature isVoidReturn
													ifFalse: ["callbackResult returnInteger: (resultAlien := self for: result) addressField."
																	invocation setReturnValue: resultAlien pointer]]
									argsClass: ObjectiveCForwardInvocationArguments.
			SignatureCallback := Callback
									block: [:args :callbackResult|
													| signatureTypes target |
													target := (AddressToBothInstancesMap at: args receiver id) last.
													signatureTypes := ([target class signatures
																								at: args selector asSmalltalkSelector
																								ifAbsent: []]
																							on: MessageNotUnderstood
																							do: [:err|]) ifNil: [self defaultSignatureFor: args selector asSmalltalkSelector].
													callbackResult returnInteger: (ObjectiveCMethodSignature fromTypes: signatureTypes) id]
									argsClass: ObjectiveCMethodSignatureForSelectorArguments.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'methodSignatureForSelector:')
				implementation: SignatureCallback thunk
				signature: '@12@0:4:8'.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v12@0:4@8'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"June 5, 2010 -> 14:4:54"!

"System saved" !
"June 5, 2010 -> 14:5:45"!

! (Delta mirrorFor: #ObjectiveCMethodSignature) methodsFor: 'testing' !
isVoidReturn

	^(super methodReturnType unsignedByteAt: 1) == $v asciiValue! !

"June 5, 2010 -> 14:5:53"!

"System saved" !
"June 5, 2010 -> 14:8:15"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'Object'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien invocation |
												invocation := args invocation.
												pair := AddressToBothInstancesMap at: invocation target id.
												result := pair first forward: invocation to: pair last.
												invocation methodSignature isVoidReturn
													ifFalse: ["callbackResult returnInteger: (resultAlien := self for: result) addressField."
																	invocation setReturnValue: resultAlien pointer]]
									argsClass: ObjectiveCForwardInvocationArguments.
			SignatureCallback := Callback
									block: [:args :callbackResult|
													| signatureTypes target |
													target := (AddressToBothInstancesMap at: args receiver id) last.
													signatureTypes := ([target class signatures
																								at: args selector asSmalltalkSelector
																								ifAbsent: []]
																							on: MessageNotUnderstood
																							do: [:err|]) ifNil: [self defaultSignatureFor: args selector asSmalltalkSelector].
													callbackResult returnInteger: (ObjectiveCMethodSignature fromTypes: signatureTypes) id]
									argsClass: ObjectiveCMethodSignatureForSelectorArguments.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'methodSignatureForSelector:')
				implementation: SignatureCallback thunk
				signature: '@12@0:4:8'.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v12@0:4@8'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"June 5, 2010 -> 14:8:20"!

"System saved" !
"June 5, 2010 -> 14:9:53"!

! (Delta mirrorFor: #MacOSXExampleModalDelegate) methodsFor: 'initialize-release' !
retain
! !

"June 5, 2010 -> 14:11:53"!

! (Delta mirrorFor: #MacOSXExampleModalDelegate) classSide methodsFor: 'accessing' !
signatures

	^Dictionary new
		at: #'alertDidEnd:returnCode:contextInfo:' put: 'v@:@i^v';
		at: #retain put: '@@:';
		yourself! !

"June 5, 2010 -> 14:12:8"!

"System saved" !
"June 5, 2010 -> 14:16:32"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) methodsFor: 'message forwarding' !
forward: invocation <ObjectiveCNSInvocation> to: aSmalltalkObject <Object> ^<Object>
	| smalltalkSelector args |
	smalltalkSelector := invocation selector asSmalltalkSelector.
	args :=  invocation args.
	^[aSmalltalkObject
		perform: smalltalkSelector
		withArguments: args]
			ensure: [invocation args: args]! !

"June 5, 2010 -> 14:19:50"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) classSide methodsFor: 'system startup' !
installSmalltalkProxyClass
	"ObjectiveCSmalltalkObjectProxy installSmalltalkProxyClass"
	ObjectiveCClass
		createClassNamed: 'SmalltalkProxy'
		superclass: 'Object'
		into: [:class :metaclass|
			"SendbackCallback is here simply to prevent the Callback being
			 garbage collected and the thunk being finalizewd as a result."
			SendbackCallback := Callback
									block: [:args :callbackResult |
												| pair result resultAlien invocation |
												invocation := args invocation.
												pair := AddressToBothInstancesMap at: invocation target id.
												result := pair first forward: invocation to: pair last.
												invocation methodSignature isVoidReturn
													ifFalse: ["callbackResult returnInteger: (resultAlien := self for: result) addressField."
																	invocation setReturnValue: (self for: result) pointer]]
									argsClass: ObjectiveCForwardInvocationArguments.
			SignatureCallback := Callback
									block: [:args :callbackResult|
													| signatureTypes target |
													target := (AddressToBothInstancesMap at: args receiver id) last.
													signatureTypes := ([target class signatures
																								at: args selector asSmalltalkSelector
																								ifAbsent: []]
																							on: MessageNotUnderstood
																							do: [:err|]) ifNil: [self defaultSignatureFor: args selector asSmalltalkSelector].
													callbackResult returnInteger: (ObjectiveCMethodSignature fromTypes: signatureTypes) id]
									argsClass: ObjectiveCMethodSignatureForSelectorArguments.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'methodSignatureForSelector:')
				implementation: SignatureCallback thunk
				signature: '@12@0:4:8'.
			class
				addMethod: (ObjectiveCAlien asObjectiveCSelector: #'forwardInvocation:')
				implementation: SendbackCallback thunk
				signature: 'v12@0:4@8'].
	ObjectiveCSmalltalkProxyClassAlien := ObjectiveCClassAlien lookup: 'SmalltalkProxy'! !

"June 5, 2010 -> 14:19:57"!

"System saved" !
"June 5, 2010 -> 14:24:20"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) methodsFor: 'message forwarding' !
forward: invocation <ObjectiveCNSInvocation> to: aSmalltalkObject <Object> ^<Object>
	| selector args |
	selector := invocation selector asSmalltalkSelector.
	args :=  invocation args.
	^[selector == #release
			ifTrue: [self release]
			ifFalse: [aSmalltalkObject
								perform: selector
								withArguments: args]]
		ensure: [invocation args: args]! !

"June 5, 2010 -> 14:24:28"!

"System saved" !
"June 5, 2010 -> 14:26:11"!

! (Delta mirrorFor: #ObjectiveCSmalltalkObjectProxy) methodsFor: 'memory management' !
release
	| pair |
	pair := AddressToBothInstancesMap removeKey: self addressField ifAbsent: [].
	SmalltalkToObjectiveCInstanceMap removeKey: pair last ifAbsent: [].
	self free! !

"June 5, 2010 -> 14:26:21"!

"System saved" !
"June 5, 2010 -> 17:58:46"!

! (Delta mirrorFor: #ObjectiveCNSInvocation) methodsFor: 'accessing' !
args: args <Array[ObjectiveCAlien]>

	1 to: args size do: [:i| self setArgument: (args at: i) pointer
													atIndex: i + 1]! !

"June 5, 2010 -> 18:18:30"!

"System saved" !
"June 5, 2010 -> 18:25:1"!

(Delta mirrorFor: #NSMethodSignature) removeDefinitionIfFail: [] !


"June 5, 2010 -> 18:26:41"!

"System saved" !
"June 27, 2010 -> 18:23:5"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildActions ^ <Visual>

	| row <Row[Visual]> |

	row := Row[Button] new.
	row add: (self buttonLabeled: 'Step into'
						action: [:b <Button> | debugger singleStep: self activation]).
	row add: (self buttonLabeled: 'Step over'
						action: [:b <Button> | debugger stepNext: self activation]).
	row add: (self buttonLabeled: 'Step out'
						action: [:b <Button> | debugger stepReturn: self activation]).
	row add: Glue xStretchy.
	^row! !

"June 27, 2010 -> 18:23:5"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buttonLabeled: string action: block
	^(Button
			labeled: string
			action: block)
			stretchy: false;
			yourself! !

"June 27, 2010 -> 18:23:5"!

! (Delta mirrorFor: #Behavior) methodsFor: 'bootstrap-temporary' !
includesBehavior: aClass	^self == aClass or: [(VMMirror on: self) superclasses includes: aClass]! !

"June 27, 2010 -> 18:23:5"!

! (Delta mirrorFor: #BlockWithOneArgument) methodsFor: 'evaluating' !
valueWithPossibleArgument: a <A1> ^ <R>	^self value: a! !

"June 27, 2010 -> 18:23:5"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
valueWithPossibleArgument: a <Object> ^ <R>	^self value! !

"June 27, 2010 -> 18:23:5"!

! (Delta mirrorFor: #Callback) methodsFor: 'accessing' !
thunk ^<Alien>	^Alien thunk: self asInteger! !

"June 27, 2010 -> 18:23:5"!

! (Delta mirrorFor: #ClassVMMirror) methodsFor: 'accessing' !
superclass: class <Class> 
	
{{primitiveSetSuperclassOf: self reflectee
	toClass: class
	ifFail: [:err| |name|
				class isNil
					ifTrue: [name := nil]
					ifFalse: [name := class name].
				self error: 'Unable to change superclass of ', self name, ' to ', name , '.' , err]}}
! !

"June 27, 2010 -> 18:23:6"!

! (Delta mirrorFor: #Integer) methodsFor: 'bit operations' !
bitClear: o <X> ^<Self|X>

	^(self bitOr: o) - o! !

"June 27, 2010 -> 18:23:6"!

! (Delta mirrorFor: #Integer) methodsFor: 'bit operations' !
| o

	^self bitOr: o! !

"June 27, 2010 -> 18:23:6"!

! (Delta mirrorFor: #LargeInteger) methodsFor: 'converting' !
asAlien ^<Alien|SmallInt>

	^self < 0
		ifTrue: [Alien forLong: self]
		ifFalse: [Alien forULong: self]
! !

"June 27, 2010 -> 18:23:6"!

! (Delta mirrorFor: #LargeInteger) methodsFor: 'restricted-double dispatching' !
bitAndFromInteger: o <Integer> ^<Integer>

	^{{self primitiveIndexedByteLargeIntegerAnd: o asLargeInteger
					ifFail: [ :err <Symbol> | self error: err ]
		}}! !

"June 27, 2010 -> 18:23:6"!

! (Delta mirrorFor: #LargeInteger) methodsFor: 'restricted-double dispatching' !
bitOrFromInteger: o <Integer> ^<Integer>

	^{{self primitiveIndexedByteLargeIntegerOr: o asLargeInteger
					ifFail: [ :err <Symbol> | self error: err ]
		}}! !

"June 27, 2010 -> 18:23:6"!

! (Delta mirrorFor: #Message) methodsFor: 'control' !
sendTo: anObject

	^anObject perform: self selector withArguments: self arguments! !

"June 27, 2010 -> 18:23:6"!

! (Delta mirrorFor: #Object) methodsFor: 'testing' !
ifNil: action <[] | [Self]> 	^self! !

"June 27, 2010 -> 18:23:6"!

! (Delta mirrorFor: #Object) methodsFor: 'testing' !
ifNil: nilBlock ifNotNil: ifNotNilBlock	^ifNotNilBlock valueWithPossibleArgument: self! !

"June 27, 2010 -> 18:23:6"!

! (Delta mirrorFor: #Object) methodsFor: 'testing' !
ifNotNil: action <[] | [Self]> 	^action valueWithPossibleArgument: self! !

"June 27, 2010 -> 18:23:6"!

! (Delta mirrorFor: #Object) methodsFor: 'testing' !
ifNotNil: ifNotNilBlock ifNil: nilBlock	^ifNotNilBlock valueWithPossibleArgument: self! !

"June 27, 2010 -> 18:23:6"!

! (Delta mirrorFor: #OrderedCollection) methodsFor: 'converting' !
asSortedList: block

	^self asSortedCollection: block! !

"June 27, 2010 -> 18:23:6"!

! (Delta mirrorFor: #Process) methodsFor: 'testing' !
dead	^self status == #Killed || self status == #Completed || self status == #Dead! !

"June 27, 2010 -> 18:23:6"!

! (Delta mirrorFor: #Process) methodsFor: 'testing' !
isActiveProcess        ^Processor activeProcess == self! !

"June 27, 2010 -> 18:23:6"!

! (Delta mirrorFor: #ReadString) methodsFor: 'copying' !
copyWith: el

	^self concatenate: (String with: el)! !

"June 27, 2010 -> 18:23:6"!

! (Delta mirrorFor: #ReadString) methodsFor: 'copying' !
withBlanksTrimmed

	^self trimBlanks
	! !

"June 27, 2010 -> 18:23:7"!

! (Delta mirrorFor: #Rectangle) methodsFor: 'testing' !
hasPositiveExtent
	^ (self corner x > self origin x)
			and: [self corner y > self origin y]! !

"June 27, 2010 -> 18:23:7"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'bit operations' !
bitShift: numBits <Int> ^<Int>

	^{{self primitiveBitShift: numBits
		ifFail: [ :err <Symbol> | self asLargeInteger bitShift: numBits ]}}! !

"June 27, 2010 -> 18:23:7"!

! (Delta mirrorFor: #SmallInteger) methodsFor: 'converting' !
asAlien ^<Alien|SmallInt>

	^self! !

"June 27, 2010 -> 18:23:7"!

! (Delta mirrorFor: #Smalltalk) classSide methodsFor: 'file in - temporary' !
fileIn: fileName <String>

self fileInFromFile: (FilePath for: fileName)! !

"June 27, 2010 -> 18:23:7"!

! (Delta mirrorFor: #UndefinedObject) methodsFor: 'testing' !
ifNil: action <[] | [Self]> 
	^action valueWithPossibleArgument: self! !

"June 27, 2010 -> 18:23:7"!

! (Delta mirrorFor: #UndefinedObject) methodsFor: 'testing' !
ifNil: nilBlock ifNotNil: ifNotNilBlock
	^nilBlock valueWithPossibleArgument: self! !

"June 27, 2010 -> 18:23:7"!

! (Delta mirrorFor: #UndefinedObject) methodsFor: 'testing' !
ifNotNil: action <[] | [Self]> 
	^self! !

"June 27, 2010 -> 18:23:7"!

! (Delta mirrorFor: #UndefinedObject) methodsFor: 'testing' !
ifNotNil: ifNotNilBlock ifNil: nilBlock
	^nilBlock valueWithPossibleArgument: self! !

"June 27, 2010 -> 18:23:7"!

! (Delta mirrorFor: #Win32FilePath) methodsFor: 'accessing' !
localName

	^self elements last name! !

"June 27, 2010 -> 18:23:7"!

! (Delta mirrorFor: #Win32FilePath) methodsFor: 'accessing' !
pathNameDelimiter

	^$\! !

"June 27, 2010 -> 18:25:1"!

"System saved" !
"August 15, 2010 -> 13:16:38"!

Delta define: #Integer as: (
(Class subclassOf: 'RationalNumber' instanceVariables: '') abstract) !


"August 15, 2010 -> 13:16:38"!

Delta define: #Integer as: (
(Class subclassOf: 'RationalNumber' instanceVariables: '') abstract) !


"August 15, 2010 -> 13:16:38"!

Delta define: #Integer as: (
(Class subclassOf: 'RationalNumber' instanceVariables: '') abstract) !


"August 15, 2010 -> 13:16:38"!

Delta define: #Integer as: (
(Class subclassOf: 'RationalNumber' instanceVariables: '') abstract) !


"August 15, 2010 -> 13:16:38"!

Delta define: #Integer as: (
(Class subclassOf: 'RationalNumber' instanceVariables: '') abstract) !


"August 15, 2010 -> 13:16:38"!

Delta define: #Integer as: (
(Class subclassOf: 'RationalNumber' instanceVariables: '') abstract) !


"August 15, 2010 -> 13:16:38"!

Delta define: #Integer as: (
(Class subclassOf: 'RationalNumber' instanceVariables: '') abstract) !


"August 15, 2010 -> 13:16:38"!

Delta define: #Integer as: (
(Class subclassOf: 'RationalNumber' instanceVariables: '') abstract) !


"August 15, 2010 -> 13:16:38"!

Delta define: #Integer as: (
(Class subclassOf: 'RationalNumber' instanceVariables: '') abstract) !


"August 15, 2010 -> 13:16:38"!

Delta define: #Integer as: (
(Class subclassOf: 'RationalNumber' instanceVariables: '') abstract) !


"August 15, 2010 -> 13:16:38"!

Delta define: #Integer as: (
(Class subclassOf: 'RationalNumber' instanceVariables: '') abstract) !


"August 15, 2010 -> 13:16:38"!

(Delta mirrorFor: #Integer)
comment: 
'%notes:
    - This class implements generalized algorithms that handle both large and small integers.
    -  >,>=,<= are not implemented here for generalized integers; the Magnitude versions
          are fine.  SmallInteger implements its own for efficiency.
    * When the generalized algorithms are written, they should be designed to coerce either or
          both of receiver and argument to largeinteger format if they are smallintegers, because
         the overflow/underflow code in SmallInteger depends on that.

Tags: %BlueBook %User

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.
'!


"August 15, 2010 -> 13:16:38"!

! (Delta mirrorFor: #Integer) classSide methodsFor: 'utility' !
readFrom: s <CharInputStream> ^<Int>

	| negative <Boolean> i <Int> |
	s atEnd
		ifTrue: [ ^ 0 ].
	negative := s peek = $-.
	negative
		ifTrue: [ s next ].
	i := 0.
	[ s atEnd not and: [ s peek isDigit ] ]
		whileTrue: [	i := (i*10) + s next digitValue
	].
	negative
		ifTrue: [ i := i negated ].
	^i! !

"August 15, 2010 -> 13:16:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'accessing' !
denominator ^<Integer>
	^1! !

"August 15, 2010 -> 13:16:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'accessing' !
hash ^<Int>

	^self! !

"August 15, 2010 -> 13:16:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'accessing' !
hexDigitAt: nybble <Int> ^<Character>
	"Return the hex character for the ith nybble (4 bits, index of lowest sig. = 1)"

	^'0123456789ABCDEF'
		at: ((self bitShift: (nybble - 1 * 4) negated) bitAnd: 16rF) + 1! !

"August 15, 2010 -> 13:16:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'accessing' !
identityHash ^<Int>

	^self! !

"August 15, 2010 -> 13:16:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'accessing' !
negated ^<Int>

	^self zero - self! !

"August 15, 2010 -> 13:16:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'accessing' !
numerator ^<Integer>
	^self! !

"August 15, 2010 -> 13:16:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'benchmarking' !
benchFib  "Handy send-heavy benchmark"
	"(result // seconds to run) = approx calls per second"
	" | r t |
	  t _ Time millisecondsToRun: [r _ 26 benchFib].
	  (r * 1000) // t"
	"138000 on a Mac 8100/100"
	^ self < 2
		ifTrue: [1] 
		ifFalse: [(self-1) benchFib + (self-2) benchFib + 1]! !

"August 15, 2010 -> 13:16:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'benchmarking' !
recurse
	self > 0 ifTrue: [
		(self - 1) recurse.
		(self - 1) recurse.
	]! !

"August 15, 2010 -> 13:16:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'benchmarking' !
sumTo: end <Int>  ^<Int>
	| sum <Int> | 
	sum := 0.
	self to: end do: [ :i <Int> | sum := sum + i ].
	^sum! !

"August 15, 2010 -> 13:16:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'bit operations' !
allMask: mask <Integer> ^<Boolean>

	^(self bitAnd: mask) = mask! !

"August 15, 2010 -> 13:16:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'bit operations' !
anyMask: mask <Integer> ^<Boolean>

	^(self bitAnd: mask) ~= 0! !

"August 15, 2010 -> 13:16:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'bit operations' !
bitAnd: o <X> ^<Self|X>
		{where X <Integer> is arg 1}

	^o bitAndFromInteger: self! !

"August 15, 2010 -> 13:16:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'bit operations' !
bitAt: index <Int> ^<Int>
	"Return the bit at the specified bit index, with the low bit being index 1"

	^1 bitAnd: (self bitShift: (1 - index))! !

"August 15, 2010 -> 13:16:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'bit operations' !
bitClear: o <X> ^<Self|X>

	^(self bitOr: o) - o! !

"August 15, 2010 -> 13:16:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'bit operations' !
bitInvert ^<Int>

	^-1 - self! !

"August 15, 2010 -> 13:16:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'bit operations' !
bitOr: o <X> ^<Self|X>
		{where X <Integer> is arg 1}

	^o bitOrFromInteger: self! !

"August 15, 2010 -> 13:16:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'bit operations' !
bitShift: shift <Int> ^<Int>

	self unimplemented! !

"August 15, 2010 -> 13:16:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'bit operations' !
bitXor: o <X> ^<Self|X>
		{where X <Integer> is arg 1}

	^o bitXorFromInteger: self! !

"August 15, 2010 -> 13:16:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'bit operations' !
highBit ^<SmallInt>

	self unimplemented! !

"August 15, 2010 -> 13:16:38"!

! (Delta mirrorFor: #Integer) methodsFor: 'bit operations' !
noMask: mask <Integer> ^<Boolean>

	^(self bitAnd: mask) = 0! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'bit operations' !
rawBitShift: numBits <Int> ^<Int>
	"This is like bit shift, except that the result is truncated to a smallinteger, rather than
		overflowing to a largeinteger.  The receiver cannot be a largeinteger."

	self error: 'this message only works for small integers'! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'bit operations' !
| o

	^self bitOr: o! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'comparison' !
< a <Number> ^<Boolean>

	^a lessFromInteger: self! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'comparison' !
= a <Object> ^<Boolean>

"%todo: use this typesafe version when coerce: is fast
	^(Number coerce: a else: [ ^false ]) equalFromInteger: self
"
	^a Number
		ifTrue: [ (guaranteed <Number> a) equalFromInteger: self ]
		ifFalse: [ false ]
! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'comparison' !
@= other <ExternalData> ^<Boolean>
	"Compares two ExternalData objects to each other.  This will coerce between integers and proxies
	  as needed"
	"%opt- this builds two proxies when comparing two integers; use double dispatching instead"

	^other = self asExternalProxy! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'comparison' !
@~= other <ExternalData> ^<Boolean>
	"Compares two ExternalData objects to each other.  This will coerce between integers and proxies
	  as needed"

	^(self @= other) not! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'constants' !
unit ^<Integer>

	^1! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'constants' !
zero ^<Integer>

	^0! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'converting' !
asExternalProxy ^<ExternalProxy>

	^ExternalProxy forInt: self! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'converting' !
asFloat ^<Float>
	self unimplemented! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'converting' !
asInteger ^<Integer>

	^self! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'iteration' !
timesRepeat: f <[]> ^<Object>

	1 to: self do: [ :i <Int> |
		f value  ].
	^nil! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'iteration' !
to: stop <Int> by: step <Int> do: f <[Int]> ^<Object>

	| v <Int> |
	v := self.
	step < 0
		ifFalse: [ [ v <= stop ]
					whileTrue: [	f value: v.
								v := v + step  ]]
		ifTrue: [ [ v >= stop ]
					whileTrue: [ f value: v.
								v := v + step  ]].
	^nil! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'iteration' !
to: stop <Int> do: f <[Int]> ^<Object>

	| v <Int> |
	v := self.
	[ v <= stop ]
		whileTrue: [	f value: v.
					v := v + 1  ].
	^nil! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'iteration' !
to: stop <Int> intervals: n <Int> do: f <[Int]> ^<Object>
	"Evaluate f with n + 1 values as evenly spaced 
	 as possible between the
	 receiver and stop, inclusive."

	| interval <RationalNumber> current <RationalNumber> |
	interval := (stop - self) / n.
	current := self.
	n + 1 timesRepeat:
		[	f value: current asInteger.
			current := current + interval.	].! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'mathematical functions' !
factorial ^<Int>

	self assert: [ self >= self zero ].
	^self <= 1
		ifTrue: [ 1 ]
		ifFalse: [ self * (self - 1) factorial ]! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'mathematical functions' !
nfib ^<Int>
	^self <= 1
			ifTrue: [1]
			ifFalse: [(self - 1) nfib +
							(self - 2) nfib +
							1]! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'operations' !
* a <Number> ^<X>
			{where X <Number> is returnType of #multiplyFromInteger: message of arg 1}
	"%generated code- do not modify"
	^guaranteed <X> (a multiplyFromInteger: self)! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'operations' !
+ a <Number> ^<X>
			{where X <Number> is returnType of #addFromInteger: message of arg 1}
	"%generated code- do not modify"
	^guaranteed <X> (a addFromInteger: self)! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'operations' !
- a <Number> ^<X>
			{where X <Number> is returnType of #subtractFromInteger: message of arg 1}
	"%generated code- do not modify"
	^guaranteed <X> (a subtractFromInteger: self)! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'operations' !
/ a <Number> ^<X>
			{where X <Number> is returnType of #divideFromInteger: message of arg 1}
	"%generated code- do not modify"
	^guaranteed <X> (a divideFromInteger: self)! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'operations' !
// arg <Number> ^<Int>

	"%todo: fix when coerce is fast"
	| cl <Class> |
	cl := arg class.
	^cl == LargeInteger
		ifTrue: [ self asLargeInteger // arg ]
		ifFalse: [ cl == SmallInteger
							ifTrue: [ self asLargeInteger // (guaranteed <SmallInteger> arg) asLargeInteger ]
							ifFalse: [ super // arg ]
					 ]! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'operations' !
\\ a <Number> ^<X>
			{where X <Number> is returnType of #moduloFromInteger: message of arg 1}
	"%generated code- do not modify"
	^guaranteed <X> (a moduloFromInteger: self)! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'operations' !
abs ^<Integer>

	^self < self zero
		ifTrue: [ self negated ]
		ifFalse: [ self ]! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'operations' !
ceiling ^<Int>

	^self! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'operations' !
floor ^<Int>

	^self! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'operations' !
gcd: other <Integer> ^<Integer>
	"greatest common divisor"

	| myabs <Int> otherabs <Int> lower <Int> higher <Int> |
	myabs := self abs.
	otherabs := other abs.

	myabs < otherabs
		ifTrue: [	lower := myabs.
						higher := otherabs.	]
		ifFalse: [	lower := otherabs.
						higher := myabs.		].
	[ lower == 0 ]
		whileFalse:
			[	| oldHigher <Int> |
				oldHigher := higher.
				higher := lower.
				lower := oldHigher \\ lower.	].
	^higher! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'operations' !
rem: a <Number> ^<X>
			{where X <Number> is returnType of #remFromInteger: message of arg 1}
	^guaranteed <X> (a remFromInteger: self)! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'operations' !
truncated ^<Int>

	^self! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'printing' !
printBareHexDigits: nDigits <Int> on: strm <CharOutputStream>

	nDigits to: 1 by: -1
		do: [ :i <Int> |
					strm put: (self hexDigitAt: i) ]! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'printing' !
printBareHexOn: strm <CharOutputStream>

	(self = (self bitAnd: 16rF))
		ifFalse: [ (self bitShift: -4) printBareHexOn: strm ].
	strm put: (self hexDigitAt: 1).! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'printing' !
printHexOn: strm <CharOutputStream>

	strm putAll: '16r'.
	self printBareHexOn: strm.! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'printing' !
printOn: strm <CharOutputStream>

	self printOn: strm radix: 10! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'printing' !
printOn: strm <CharOutputStream> radix: radix <Int>

	| abs <Int> |
	self negative
		ifTrue: [	strm nextPut: $-.
						abs := self negated. ]
		ifFalse: [	abs := self. ].
	abs printNonNegativeOn: strm radix: radix! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'private-proxy double dispatching' !
bitAndFromSmallInteger: other <SmallInteger> ^<ExternalData>

	^self bitAnd: other! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'private-proxy double dispatching' !
bitOrFromSmallInteger: other <SmallInteger> ^<Int>

	^self bitOr: other! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'proxy operations' !
externalBitAnd: other <ExternalData> ^<ExternalData>

	"this happens only if receiver is a largeinteger, since
		these messages are overridden in SmallInteger"
	self error: 'Attempt to do external data operations on a LargeInteger'! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'proxy operations' !
externalBitOr: other <ExternalData> ^<ExternalData>

		"this happens only if receiver is a largeinteger, since
		these messages are overridden in SmallInteger"
	self error: 'Attempt to do external data operations on a LargeInteger'! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'proxy operations' !
hasBitsSet: mask <ExternalData> ^<Boolean>

	"this happens only if receiver is a largeinteger, since
		these messages are overridden in SmallInteger"
	self error: 'Attempt to do external data operations on a LargeInteger'! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'restricted-double dispatching' !
addFromInteger: o <Integer> ^<Integer>

	^o + self asLargeInteger! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'restricted-double dispatching' !
addFromSmallInteger: o <SmallInteger> ^<Integer>
	"%generated code- do not modify"
	^self addFromInteger: o! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'restricted-double dispatching' !
bitAndFromInteger: arg <Integer>

	self unimplemented! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'restricted-double dispatching' !
bitOrFromInteger: arg <Integer>

	self unimplemented! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'restricted-double dispatching' !
divideFromFloat: o <Float> ^<Number>

	^self isZero
			ifTrue: [(ZeroDivide dividend: o) signal]
			ifFalse: [o / self asFloat]! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'restricted-double dispatching' !
equalFromInteger: o <Integer> ^<Boolean>

	^o = self asLargeInteger! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'restricted-double dispatching' !
equalFromSmallInteger: o <SmallInteger> ^<Boolean>
	"%generated code- do not modify"
	^self equalFromInteger: o! !

"August 15, 2010 -> 13:16:39"!

! (Delta mirrorFor: #Integer) methodsFor: 'restricted-double dispatching' !
lessFromInteger: o <Integer> ^<Boolean>

	^o < self asLargeInteger! !

"August 15, 2010 -> 13:16:40"!

! (Delta mirrorFor: #Integer) methodsFor: 'restricted-double dispatching' !
lessFromSmallInteger: o <SmallInteger> ^<Boolean>
	"%generated code- do not modify"
	^self lessFromInteger: o! !

"August 15, 2010 -> 13:16:40"!

! (Delta mirrorFor: #Integer) methodsFor: 'restricted-double dispatching' !
moduloFromInteger: o <Integer> ^<Integer>

	| tmp <Int> |
	tmp :=  self asLargeInteger.
	^o - ((o // tmp) * tmp)! !

"August 15, 2010 -> 13:16:40"!

! (Delta mirrorFor: #Integer) methodsFor: 'restricted-double dispatching' !
moduloFromSmallInteger: o <SmallInteger> ^<Integer>
	"%generated code- do not modify"
	^o \\ self! !

"August 15, 2010 -> 13:16:40"!

! (Delta mirrorFor: #Integer) methodsFor: 'restricted-double dispatching' !
multiplyFromInteger: o <Integer> ^<Integer>

	^o * self asLargeInteger! !

"August 15, 2010 -> 13:16:40"!

! (Delta mirrorFor: #Integer) methodsFor: 'restricted-double dispatching' !
multiplyFromSmallInteger: o <SmallInteger> ^<Integer>
	"%generated code- do not modify"
	^self multiplyFromInteger: o! !

"August 15, 2010 -> 13:16:40"!

! (Delta mirrorFor: #Integer) methodsFor: 'restricted-double dispatching' !
remFromInteger: o <Integer> ^<Integer>

	self unimplemented! !

"August 15, 2010 -> 13:16:40"!

! (Delta mirrorFor: #Integer) methodsFor: 'restricted-double dispatching' !
subtractFromInteger: o <Integer> ^<Integer>

	^o - self asLargeInteger! !

"August 15, 2010 -> 13:16:40"!

! (Delta mirrorFor: #Integer) methodsFor: 'restricted-double dispatching' !
subtractFromSmallInteger: o <SmallInteger> ^<Integer>
	"%generated code- do not modify"
	^self subtractFromInteger: o! !

"August 15, 2010 -> 13:16:40"!

! (Delta mirrorFor: #Integer) methodsFor: 'restricted-to integers' !
printNonNegativeOn: strm <CharOutputStream> radix: radix <Int>
	"Like printOn:radix:, but assumes the receiver is nonnegative"

	| digit <Int> |
	self >= radix
		ifTrue: [	(self // radix) printNonNegativeOn: strm radix: radix.
						digit := self \\ radix. ]
		ifFalse: [ digit := self ].
	strm put: (Character digitValue: digit).! !

"August 15, 2010 -> 13:16:40"!

! (Delta mirrorFor: #Integer) methodsFor: 'restricted-to large integers' !
asLargeInteger ^<LargeInteger>
	"This message must ONLY be sent by large integers to construct a temporary large integer
		during mixed-mode integer operations.  The result of this message must NEVER be
		used by other code, since large integers that can be encoded as SmallIntegers
		are never supposed to exist outside the large integer class"

	self subclassResponsibility! !

"August 15, 2010 -> 13:16:40"!

! (Delta mirrorFor: #Integer) methodsFor: 'truncation and rounding' !
rounded ^<Int>

	^self! !

"August 15, 2010 -> 13:16:56"!

Delta define: #Number as: (
(Class subclassOf: 'Magnitude[Number] mixin |> Object' instanceVariables: '') abstract) !


"August 15, 2010 -> 13:16:56"!

Delta define: #Number as: (
(Class subclassOf: 'Magnitude[Number] mixin |> Object' instanceVariables: '') abstract) !


"August 15, 2010 -> 13:16:56"!

Delta define: #Number as: (
(Class subclassOf: 'Magnitude[Number] mixin |> Object' instanceVariables: '') abstract) !


"August 15, 2010 -> 13:16:56"!

Delta define: #Number as: (
(Class subclassOf: 'Magnitude[Number] mixin |> Object' instanceVariables: '') abstract) !


"August 15, 2010 -> 13:16:56"!

Delta define: #Number as: (
(Class subclassOf: 'Magnitude[Number] mixin |> Object' instanceVariables: '') abstract) !


"August 15, 2010 -> 13:16:56"!

Delta define: #Number as: (
(Class subclassOf: 'Magnitude[Number] mixin |> Object' instanceVariables: '') abstract) !


"August 15, 2010 -> 13:16:56"!

Delta define: #Number as: (
(Class subclassOf: 'Magnitude[Number] mixin |> Object' instanceVariables: '') abstract) !


"August 15, 2010 -> 13:16:56"!

Delta define: #Number as: (
(Class subclassOf: 'Magnitude[Number] mixin |> Object' instanceVariables: '') abstract) !


"August 15, 2010 -> 13:16:56"!

Delta define: #Number as: (
(Class subclassOf: 'Magnitude[Number] mixin |> Object' instanceVariables: '') abstract) !


"August 15, 2010 -> 13:16:56"!

Delta define: #Number as: (
(Class subclassOf: 'Magnitude[Number] mixin |> Object' instanceVariables: '') abstract) !


"August 15, 2010 -> 13:16:56"!

Delta define: #Number as: (
(Class subclassOf: 'Magnitude[Number] mixin |> Object' instanceVariables: '') abstract) !


"August 15, 2010 -> 13:16:56"!

(Delta mirrorFor: #Number)
comment: 
'Tags: %BlueBook %User

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.3 $
'!


"August 15, 2010 -> 13:16:56"!

! (Delta mirrorFor: #Number) classSide methodsFor: 'instance creation' !
new ^<Instance>

	self shouldNotImplement! !

"August 15, 2010 -> 13:16:56"!

! (Delta mirrorFor: #Number) classSide methodsFor: 'testing' !
test
	"self test"

	self	testEquals;
		testRelationals;
		testArithmetic.! !

"August 15, 2010 -> 13:16:57"!

! (Delta mirrorFor: #Number) classSide methodsFor: 'testing' !
testArithmetic
	"self testArithmetic"
	| eps <Float> |
	eps := 0.00000001.
	
		"+"
		[ 3+3 = 6 ] verify. [ 1+(2/3) = (5/3) ] verify. [ 1 + 2.0 isWithin: eps of: 3.0 ] verify.
		[ 3.0 + 3.0 isWithin: eps of:  6.0 ] verify. [ 1.0 + (2/3) isWithin: eps of: 5/3 ] verify. [ 1.0 + 2 isWithin: eps of: 3.0] verify.
		[ (1/3 + 1/6) = (2/9) ] verify. [ 2/3 + (1 asFloat/ 3 asFloat) isWithin: eps of: 1 ] verify.

		"-"
		[ 3-1 = 2 ] verify. [ 1-(2/3) = (1/3) ] verify. [ 1 - 2.0 isWithin: eps of: -1.0 ] verify.
		[ 3.0 - 2.0 isWithin: eps of:  1.0 ] verify. [ 1.0 - (2/3) isWithin: eps of: 1/3 ] verify. [ 1.0 - 2 isWithin: eps of: -1.0] verify.
		[ (1/3 - 1/6) = (-1/9) ] verify. [ 4/3 - (1 asFloat/ 3 asFloat) isWithin: eps of: 1 ] verify.

		"*"
		[ 2*3 = 6 ] verify. [ 2*3.0 isWithin: eps of: 6.0 ] verify. [ 3*(1/3) = 1 ] verify.
		[ 2.0 *3.0 isWithin: eps of: 6.0 ] verify. [ 2.0*(1/2) isWithin: eps of: 1 ] verify. [ 2.0 * 3 isWithin: eps of: 6 ] verify.
		[ 2/3 * (1/3) = (2/9) ] verify. [ 2/3 * (1 asFloat / 3 asFloat) isWithin: eps of: 2/9 ] verify. [ 2/3 * 2 = (4/3) ] verify.

		"/"
		[ 6/3 = 2 ] verify. [ 6/3.0 isWithin: eps of: 2 ] verify. [ 3/(1/3) = 9 ] verify.
		[ 6.0 / 2 isWithin: eps of: 3 ] verify. [ 6.0 / 2.0 isWithin: eps of: 3 ] verify. [ 6.0 / (1/3) isWithin: eps of: 18 ] verify. 
		[ 2/3/(1/2) = (4/3) ] verify. [ 2/3/0.5 isWithin: eps of: 4/3 ] verify. [ 2/3/2 = (1/3) ] verify.

		"//"
		[ 7 // 2 = 3 ] verify. [ 7 // 2.0 isWithin: eps of: 3 ] verify. [ 7 // (1/2) = 14 ] verify. [ -7 // 2 = -4 ] verify.
		[ 7.0 // 2.0 = 3 ] verify. [ 7.0 // 2 isWithin: eps of: 3 ] verify. [ 7.0 // (1/2) = 14 ] verify. [ -7.0 // 2 = -4 ] verify.
		[ 7/3 // (2/3) = 3 ] verify. [  -7/3 // (2/3) = -4 ] verify.

		"\\"
		[ 7 \\ 2 = 1 ] verify. [ 7 \\ 2.0 isWithin: eps of: 1 ] verify. [ (7+ 1/3) \\ (1/2) = (1/6) ] verify. [ -7 \\ 2 = 1 ] verify.
		[ 7.0 \\ 2.0 isWithin: eps of: 1.0 ] verify.
		[ 7.0 \\ 2 isWithin: eps of: 1 ] verify.
		[ (7.0 + (1/3) asFloat) \\ (1/2) isWithin: eps of: 1/3 ] verify.
		[ -7.0 \\ 2 isWithin: eps of: 1 ] verify.
		[ 7/3 \\ (2/3) = (1/3) ] verify. [  -7/3 \\ (2/3) = (1/3) ] verify.
! !

"August 15, 2010 -> 13:16:57"!

! (Delta mirrorFor: #Number) classSide methodsFor: 'testing' !
testEquals
	"self testEquals"

	"=, ~="
	[ 123 == 123 ] verify. [ (-2 == -3) not ] verify.
	[ 123 = 123 ] verify. [ 123 ~= -123 ] verify.
	[ 123 = (246/2) ] verify. [ 123 ~= (246/3) ] verify.
	[ 123 = 123.0 ] verify. [ 123 ~= 123.1 ] verify.

	[ 123.0 = 123.0 ] verify. [ 123.0 ~= 123.4 ] verify.
	[ 123.0 = 123 ] verify. [ 123.0 ~= 124 ] verify.
	[ 0.5 = (1/2) ] verify. [ -0.5 = (1/-2) ] verify. [ 0.5 ~= (1/3) ] verify.

	[ (3/4) = (6/8) ] verify. [ (3/4) ~= (1/4) ] verify.
	[ (1/3) = (1.0 / 3.0) ] verify. [ (1/3) ~= 0.33333 ] verify.
	[ (2/3) * 3 = 2 ] verify.
	[ (-10/-5) = 2 ] verify. [ (-10/5) = -2 ] verify. [ (10/-5) = -2 ] verify.

! !

"August 15, 2010 -> 13:16:57"!

! (Delta mirrorFor: #Number) classSide methodsFor: 'testing' !
testRelationals
	"self testRelationals"

	"<"
	[ 123 < 125 ] verify. [ (123 < 122) not ] verify.
	[ 123 < 124.0 ] verify. [ (123 < 122.0) not ] verify.
	[ 2 < (11/5) ] verify. [ (2 < (9/5)) not ] verify.

	[ 123.0 < 124.0 ] verify. 
	[ 123.0 < 124 ] verify.
	[ 2.0 < (11/5) ] verify.

	[ (11/5) < (12/5) ] verify. [ ((11/5) < (9/5)) not ] verify. [ (9/5) < (10/5) ] verify.
	[ ((11/5) < (11/5)) not ] verify.
	[ (-4/5) < 0 ] verify. [ (4/-5) < (-3/5) ] verify. [ (2/3) < (-4/-3) ] verify.
	[ 2/3 < 1 ] verify. [ (4/3 < 1) not ] verify.
	[ 2/3 < 1.0 ] verify. [ (4/3 < 1.0) not ] verify.

	">"
	[ 123 > 122 ] verify. [ (121 > 122) not ] verify.
	[ 123 > 122.0 ] verify. [ (123 > 124.0) not ] verify.
	[ 2 > (9/5) ] verify. [ (2 > (11/5)) not ] verify.

	[ 124.0 > 123.0 ] verify. 
	[ 124.0 > 123 ] verify.
	[ 2.0 > (9/5) ] verify.

	[ (12/5) > (11/5) ] verify. [ ((9/5) > (11/5)) not ] verify. [ (10/5) > (9/5) ] verify.
	[ ((11/5) > (11/5)) not ] verify.
	[ (-4/5) > -1 ] verify. [ (3/-5) > (-4/5) ] verify. [ (4/3) > (-2/-3) ] verify.
	[ 2/3 > 0 ] verify. [ (4/3 > 2) not ] verify.
	[ 2/3 > 0.0 ] verify. [ (4/3 > 2.0) not ] verify.

	"<="
	[ 1 <= 2 ] verify. [ 2 <= 2 ] verify. [ (2 <= 1)not ] verify.
	[ 1.0 <= 2.0 ] verify. [ 2.0 <= 2.0 ] verify. [ (2.0 <= 1.0)not ] verify.
	[ 0.666 <= (2/3) ] verify. [ (0.666 <= (1/3) ) not ] verify.

	">="
	[ 1 >= 0 ] verify. [ (1 >= 2) not ] verify. [ 1 >= 1 ] verify.
	[ 1.0 >= 0.0 ] verify. [ (1.0 >= 2.0) not ] verify. [ 1.0 >= 1.0 ] verify.
	[ 0.66 >= (1/3)  ] verify. [ (0.66 >= (2/3)) not ] verify.
	[ (1/3) >= (1/3) ] verify. [ (2/3) >= (1/3) ] verify.

	">"
	[ 1 > 0 ] verify. [ (1 > 2) not ] verify. [ (1 > 1) not ] verify.
	[ 1.0 > 0.0 ] verify. [ (1.0 > 2.0) not ] verify. [ (1.0 > 1.0) not ] verify.
	[ 0.66 > (1/3)  ] verify. [ (0.66 > (2/3)) not ] verify.
	[ ((1/3) > (1/3)) not ] verify. [ (2/3) > (1/3) ] verify.

	"min:"
	[ (4 min: 5) = 4 ] verify. [ (5 min: 4) = 4 ] verify. [  (5 min: 4.0) = 4.0 ] verify. [ (1 min: 2/3)  = (2/3) ] verify.

	"max:"
	[ (5 max: 4) = 5 ] verify. [ (5 max: 4) = 5 ] verify. [  (5 max: 4.0) = 5 ] verify. [ (1 max: 4/3)  = (4/3) ] verify.

	"between:and:"
	[ 2 between: 1 and: 3 ] verify. [ 3 between: 3 and: 4 ] verify. [ (2 between: 3 and: 4) not ] verify.

! !

"August 15, 2010 -> 13:16:57"!

! (Delta mirrorFor: #Number) methodsFor: 'benchmarking' !
higherOf: aNumber <Number> ^<Number>
    ^(self min: aNumber)! !

"August 15, 2010 -> 13:16:57"!

! (Delta mirrorFor: #Number) methodsFor: 'benchmarking' !
isAbove: aNumber <Number> ^<Boolean>
    ^self < aNumber! !

"August 15, 2010 -> 13:16:57"!

! (Delta mirrorFor: #Number) methodsFor: 'benchmarking' !
isLeftOf: aNumber <Number> ^<Boolean>
    ^self < aNumber! !

"August 15, 2010 -> 13:16:57"!

! (Delta mirrorFor: #Number) methodsFor: 'benchmarking' !
leftMost: aNumber <Number> ^<Number>
    ^(self min: aNumber)! !

"August 15, 2010 -> 13:16:57"!

! (Delta mirrorFor: #Number) methodsFor: 'benchmarking' !
lowerOf: aNumber <Number> ^<Number>
    ^(self max: aNumber)! !

"August 15, 2010 -> 13:16:57"!

! (Delta mirrorFor: #Number) methodsFor: 'benchmarking' !
rightMost: aNumber <Number> ^<Number>
    ^(self max: aNumber)! !

"August 15, 2010 -> 13:16:57"!

! (Delta mirrorFor: #Number) methodsFor: 'constants' !
unit ^<Number>
	"The unit value, in whatever representation is appropriate for each subclass"

	self subclassResponsibility! !

"August 15, 2010 -> 13:16:57"!

! (Delta mirrorFor: #Number) methodsFor: 'constants' !
zero ^<Number>
	"zero, in whatever representation is appropriate for each subclass"

	self subclassResponsibility! !

"August 15, 2010 -> 13:16:57"!

! (Delta mirrorFor: #Number) methodsFor: 'converting' !
@ yval <Number>  ^<Point>
	"return a point with the receiver as x, and yval as y"

	^Point x: self y: yval! !

"August 15, 2010 -> 13:16:57"!

! (Delta mirrorFor: #Number) methodsFor: 'converting' !
asFloat ^<Float>

	self subclassResponsibility! !

"August 15, 2010 -> 13:16:57"!

! (Delta mirrorFor: #Number) methodsFor: 'converting' !
asInteger ^<Integer>

	self subclassResponsibility! !

"August 15, 2010 -> 13:16:57"!

! (Delta mirrorFor: #Number) methodsFor: 'converting' !
degreesToRadians ^<Number>

	self unimplemented! !

"August 15, 2010 -> 13:16:57"!

! (Delta mirrorFor: #Number) methodsFor: 'converting' !
radiansToDegrees ^<Number>

	self unimplemented! !

"August 15, 2010 -> 13:16:57"!

! (Delta mirrorFor: #Number) methodsFor: 'copying' !
copy ^<Instance>
	^self! !

"August 15, 2010 -> 13:16:57"!

! (Delta mirrorFor: #Number) methodsFor: 'fake brands' !
Number ^<Boolean>

	^true! !

"August 15, 2010 -> 13:16:57"!

! (Delta mirrorFor: #Number) methodsFor: 'iteration' !
to: stop <Number> ^<Interval>

	^Interval from: self to: stop! !

"August 15, 2010 -> 13:16:57"!

! (Delta mirrorFor: #Number) methodsFor: 'iteration' !
to: stop <Number> by: step <Number> ^<Interval>

	^Interval from: self to: stop by: step! !

"August 15, 2010 -> 13:16:57"!

! (Delta mirrorFor: #Number) methodsFor: 'mathematical functions' !
arcCos ^<Number>

	self unimplemented! !

"August 15, 2010 -> 13:16:57"!

! (Delta mirrorFor: #Number) methodsFor: 'mathematical functions' !
arcSin ^<Number>

	self unimplemented! !

"August 15, 2010 -> 13:16:57"!

! (Delta mirrorFor: #Number) methodsFor: 'mathematical functions' !
arcTan ^<Number>

	self unimplemented! !

"August 15, 2010 -> 13:16:57"!

! (Delta mirrorFor: #Number) methodsFor: 'mathematical functions' !
cos ^<Number>

	self unimplemented! !

"August 15, 2010 -> 13:16:57"!

! (Delta mirrorFor: #Number) methodsFor: 'mathematical functions' !
exp ^<Number>
	self unimplemented! !

"August 15, 2010 -> 13:16:57"!

! (Delta mirrorFor: #Number) methodsFor: 'mathematical functions' !
floorLog: radix <Number> ^<Int>
	self unimplemented! !

"August 15, 2010 -> 13:16:57"!

! (Delta mirrorFor: #Number) methodsFor: 'mathematical functions' !
ln ^<Number>
	self unimplemented! !

"August 15, 2010 -> 13:16:57"!

! (Delta mirrorFor: #Number) methodsFor: 'mathematical functions' !
log: o <Number> ^<Number>
	self unimplemented! !

"August 15, 2010 -> 13:16:57"!

! (Delta mirrorFor: #Number) methodsFor: 'mathematical functions' !
raisedTo: power <Number> ^<Number>
	self unimplemented! !

"August 15, 2010 -> 13:16:57"!

! (Delta mirrorFor: #Number) methodsFor: 'mathematical functions' !
raisedToInteger: power <Int> ^<Number>
	self unimplemented! !

"August 15, 2010 -> 13:16:57"!

! (Delta mirrorFor: #Number) methodsFor: 'mathematical functions' !
sin ^<Number>

	self unimplemented! !

"August 15, 2010 -> 13:16:57"!

! (Delta mirrorFor: #Number) methodsFor: 'mathematical functions' !
sqrt ^<Number>
	
	^self asFloat sqrt! !

"August 15, 2010 -> 13:16:57"!

! (Delta mirrorFor: #Number) methodsFor: 'mathematical functions' !
tan ^<Number>

	self unimplemented! !

"August 15, 2010 -> 13:16:57"!

! (Delta mirrorFor: #Number) methodsFor: 'operations' !
* a <Number> ^<Number>
			{where X <Number> is arg 1}

	self subclassResponsibility! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'operations' !
+ a <Number> ^<Number>
			{where X <Number> is arg 1}

	self subclassResponsibility! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'operations' !
- a <Number> ^<Number>
			{where X <Number> is arg 1}

	self subclassResponsibility! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'operations' !
/ a <Number> ^<Number>
			{where X <Number> is arg 1}

	self subclassResponsibility! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'operations' !
// arg <Number> ^<Int>
	"Integer quotient with truncation towards negative infinity"

	^(self / arg) floor! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'operations' !
\\ a <Number> ^<Number>
			{where X <Number> is arg 1}
	"Modulo, implemented with truncation towards negative infinity"

	self subclassResponsibility! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'operations' !
abs ^<Number>

	^self < self zero
		ifTrue: [ self negated ]
		ifFalse: [ self ]! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'operations' !
isWithin: epsilon <Number> of: other <Number> ^<Boolean>
	"Test whether the 'distance' from the receiver to other is less than or equal to
	  epsilon. This is the right way to compare floating point numbers, or numbers in different
	  representations, for equality"

	^(self - other) abs <= epsilon! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'operations' !
negated ^<Number>

	^self zero - self! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'operations' !
quo: n <Number> ^<Int>
	"Integer quotient with truncation towards zero"

	^(self / n) truncated ! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'operations' !
reciprocol ^<Number>

	^self unit/self! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'operations' !
rem: n <Number> ^<Number>

	self unimplemented! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'operations' !
squared ^<Number>

	^self * self! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
addFromFloat: o <Float> ^<Number>
	"%generated code- do not modify"
	^self asFloat + o! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
addFromInteger: o <Integer> ^<Number>
	"%generated code- do not modify"
	^self + o asFloat! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
addFromRationalNumber: o <RationalNumber> ^<Number>
	"%generated code- do not modify"
	^self + o asFloat! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
addFromSmallInteger: o <SmallInteger> ^<Number>
	"%generated code- do not modify"
	^self + o asFloat! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
bitAndFromInteger: arg <Integer> ^ <Integer>

	^arg bitAnd: self asInteger! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
bitOrFromInteger: arg <Integer> ^ <Integer>

	^arg bitOr: self asInteger! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
bitXorFromInteger: arg <Integer> ^ <Integer>

	^arg bitXor: self asInteger! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
divideFromFloat: o <Float> ^<Number>
	"%generated code- do not modify"
	^o / self asFloat! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
divideFromInteger: o <Integer> ^<Number>
	"%generated code- do not modify"
	^o asFloat / self! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
divideFromRationalNumber: o <RationalNumber> ^<Number>
	"%generated code- do not modify"
	^o asFloat / self! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
divideFromSmallInteger: o <SmallInteger> ^<Number>

	^self isZero
		ifTrue: [(ZeroDivide dividend: o) signal]
		ifFalse: [o asFloat / self]! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
equalFromFloat: o <Float> ^<Boolean>
	"%generated code- do not modify"
	^o = self asFloat! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
equalFromInteger: o <Integer> ^<Boolean>
	"%generated code- do not modify"
	^self = o asFloat! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
equalFromRationalNumber: o <RationalNumber> ^<Boolean>
	"%generated code- do not modify"
	^self = o asFloat! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
equalFromSmallInteger: o <SmallInteger> ^<Boolean>
	"%generated code- do not modify"
	^self = o asFloat! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
expandRect: r <Rect> ^<Rect>

	^Rectangle
		left: r left - self
		right: r right + self
		top: r top - self
		bottom: r bottom + self! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
insetRect: r <Rect> ^<Rect>

	^Rectangle
		left: r left + self
		right: r right - self
		top: r top + self
		bottom: r bottom - self! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
lessFromFloat: o <Float> ^<Boolean>
	"%generated code- do not modify"
	^o < self asFloat! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
lessFromInteger: o <Integer> ^<Boolean>
	"%generated code- do not modify"
	^o asFloat < self! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
lessFromRationalNumber: o <RationalNumber> ^<Boolean>
	"%generated code- do not modify"
	^o asFloat < self! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
lessFromSmallInteger: o <SmallInteger> ^<Boolean>
	"%generated code- do not modify"
	^o asFloat < self! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
moduloFromFloat: o <Float> ^<Number>
	"%generated code- do not modify"
	^o \\ self asFloat! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
moduloFromInteger: o <Integer> ^<Number>
	"%generated code- do not modify"
	^o asFloat \\ self! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
moduloFromRationalNumber: o <RationalNumber> ^<Number>
	"%generated code- do not modify"
	^o asFloat \\ self! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
moduloFromSmallInteger: o <SmallInteger> ^<Number>
	"%generated code- do not modify"
	^o asFloat \\ self! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
multiplyFromFloat: o <Float> ^<Number>
	"%generated code- do not modify"
	^self asFloat * o! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
multiplyFromInteger: o <Integer> ^<Number>
	"%generated code- do not modify"
	^self * o asFloat! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
multiplyFromRationalNumber: o <RationalNumber> ^<Number>
	"%generated code- do not modify"
	^self * o asFloat! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
multiplyFromSmallInteger: o <SmallInteger> ^<Number>
	"%generated code- do not modify"
	^self * o asFloat! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
subtractFromFloat: o <Float> ^<Number>
	"%generated code- do not modify"
	^o - self asFloat! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
subtractFromInteger: o <Integer> ^<Number>
	"%generated code- do not modify"
	^o asFloat - self! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
subtractFromRationalNumber: o <RationalNumber> ^<Number>
	"%generated code- do not modify"
	^o asFloat - self! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'restricted-double dispatching' !
subtractFromSmallInteger: o <SmallInteger> ^<Number>
	"%generated code- do not modify"
	^o asFloat - self! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'testing' !
even ^<Boolean>

	^(self \\ 2) = 0! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'testing' !
isZero

	^self = self zero! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'testing' !
negative ^<Boolean>

	^self < self zero! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'testing' !
odd ^<Boolean>

	^(self \\ 2) ~= 0! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'testing' !
positive ^<Boolean>

	^self >= self zero! !

"August 15, 2010 -> 13:16:58"!

! (Delta mirrorFor: #Number) methodsFor: 'testing' !
sign ^<Number>

	^self > self zero
		ifTrue: [ self unit ]
		ifFalse: [ self < self zero ifTrue: [ self unit negated ] ifFalse: [ self zero ] ]! !

"August 15, 2010 -> 13:16:59"!

! (Delta mirrorFor: #Number) methodsFor: 'testing' !
strictlyPositive ^<Boolean>

	^self > self zero! !

"August 15, 2010 -> 13:16:59"!

! (Delta mirrorFor: #Number) methodsFor: 'truncation and rounding' !
ceiling ^<Int>
	"Return the receiver truncated to the nearest integer towards positive infinity"

	self unimplemented! !

"August 15, 2010 -> 13:16:59"!

! (Delta mirrorFor: #Number) methodsFor: 'truncation and rounding' !
floor ^<Int>
	"Return the receiver truncated to the nearest integral value towards negative infinity"

	| t <Int> |
	^self < self zero
		ifFalse: [ self truncated ]
		ifTrue: [	
				t := self truncated.
				t = self
					ifTrue: [ t ]
					ifFalse: [ t - 1 ]	]! !

"August 15, 2010 -> 13:16:59"!

! (Delta mirrorFor: #Number) methodsFor: 'truncation and rounding' !
roundTo: n <Number> ^<Number>

	self unimplemented! !

"August 15, 2010 -> 13:16:59"!

! (Delta mirrorFor: #Number) methodsFor: 'truncation and rounding' !
rounded ^<Int>
	"The nearest integral value to the receiver.  When this is ambiguous (e.g. -1.5), choose the
		integral value farthest away from 0 (in the above example, -2)."

"%todo: use the version below when quo: is implemented for doubles
	^((self + self + self sign) quo: (self unit + self unit)) asInteger
"

	^self negative
		ifFalse: [ (self + 0.5d) truncated ]
		ifTrue: [ (self - 0.5d) truncated ]! !

"August 15, 2010 -> 13:16:59"!

! (Delta mirrorFor: #Number) methodsFor: 'truncation and rounding' !
truncateTo: grid <Number> ^<Number>

	^(self quo: grid) * grid! !

"August 15, 2010 -> 13:16:59"!

! (Delta mirrorFor: #Number) methodsFor: 'truncation and rounding' !
truncated ^<Int>
	"Return the receiver truncated to the nearest integral value towards 0."

	self subclassResponsibility! !

"August 15, 2010 -> 13:17:9"!

Delta define: #IntegerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 15, 2010 -> 13:17:9"!

(Delta mirrorFor: #IntegerTest)
comment: 
''!


"August 15, 2010 -> 13:17:9"!

! (Delta mirrorFor: #IntegerTest) methodsFor: 'initialize-release' !
setUp
! !

"August 15, 2010 -> 13:17:9"!

! (Delta mirrorFor: #IntegerTest) methodsFor: 'initialize-release' !
tearDown
! !

"August 15, 2010 -> 13:17:9"!

! (Delta mirrorFor: #IntegerTest) methodsFor: 'tests' !
testDivideByFloatZero

	self should: [1 / 0.0] raise: ZeroDivide! !

"August 15, 2010 -> 13:17:9"!

! (Delta mirrorFor: #IntegerTest) methodsFor: 'tests' !
testDivideByIntegerZero

	self should: [1 / 0] raise: ZeroDivide! !

"August 15, 2010 -> 13:17:19"!

Delta define: #FloatTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"August 15, 2010 -> 13:17:19"!

(Delta mirrorFor: #FloatTest)
comment: 
''!


"August 15, 2010 -> 13:17:19"!

! (Delta mirrorFor: #FloatTest) methodsFor: 'tests' !
testDivideByIntegerZero

	self should: [1.0 / 0] raise: ZeroDivide! !

"August 15, 2010 -> 13:18:5"!

Delta define: #ClassTestIvars123 as: (
(Class subclassOf: 'Object' instanceVariables: 'one' classInstanceVariables: 'two three')) !


"August 15, 2010 -> 13:18:5"!

(Delta mirrorFor: #ClassTestIvars123) removeDefinitionIfFail: [] !


"August 15, 2010 -> 13:18:42"!

Delta define: #UnsafeAlien as: (
(Class subclassOf: 'Object' instanceVariables: 'nonPointerObject <IndexedByteInstanceVariables>')) !


"August 15, 2010 -> 13:18:42"!

Delta define: #UnsafeAlien as: (
(Class subclassOf: 'Object' instanceVariables: 'nonPointerObject <IndexedByteInstanceVariables>')) !


"August 15, 2010 -> 13:18:42"!

Delta define: #UnsafeAlien as: (
(Class subclassOf: 'Object' instanceVariables: 'nonPointerObject <IndexedByteInstanceVariables>')) !


"August 15, 2010 -> 13:18:42"!

Delta define: #UnsafeAlien as: (
(Class subclassOf: 'Object' instanceVariables: 'nonPointerObject <IndexedByteInstanceVariables>')) !


"August 15, 2010 -> 13:18:42"!

Delta define: #UnsafeAlien as: (
(Class subclassOf: 'Object' instanceVariables: 'nonPointerObject <IndexedByteInstanceVariables>')) !


"August 15, 2010 -> 13:18:42"!

Delta define: #UnsafeAlien as: (
(Class subclassOf: 'Object' instanceVariables: 'nonPointerObject <IndexedByteInstanceVariables>')) !


"August 15, 2010 -> 13:18:42"!

Delta define: #UnsafeAlien as: (
(Class subclassOf: 'Object' instanceVariables: 'nonPointerObject <IndexedByteInstanceVariables>')) !


"August 15, 2010 -> 13:18:42"!

Delta define: #UnsafeAlien as: (
(Class subclassOf: 'Object' instanceVariables: 'nonPointerObject <IndexedByteInstanceVariables>')) !


"August 15, 2010 -> 13:18:42"!

Delta define: #UnsafeAlien as: (
(Class subclassOf: 'Object' instanceVariables: 'nonPointerObject <IndexedByteInstanceVariables>')) !


"August 15, 2010 -> 13:18:42"!

Delta define: #UnsafeAlien as: (
(Class subclassOf: 'Object' instanceVariables: 'nonPointerObject <IndexedByteInstanceVariables>')) !


"August 15, 2010 -> 13:18:42"!

Delta define: #UnsafeAlien as: (
(Class subclassOf: 'Object' instanceVariables: 'nonPointerObject <IndexedByteInstanceVariables>')) !


"August 15, 2010 -> 13:18:43"!

(Delta mirrorFor: #UnsafeAlien)
comment: 
''!


"August 15, 2010 -> 13:18:43"!

! (Delta mirrorFor: #UnsafeAlien) classSide methodsFor: 'instance creation' !
forPointerTo: bytes <IndexedByteInstanceVariables> ^ <UnsafeAlien>

	^self new
		nonPointerObject: bytes;
		yourself
		! !

"August 15, 2010 -> 13:18:43"!

! (Delta mirrorFor: #UnsafeAlien) methodsFor: 'accessing' !
object

	^nonPointerObject! !

"August 15, 2010 -> 13:18:43"!

! (Delta mirrorFor: #UnsafeAlien) methodsFor: 'conversion' !
asAlien

	^self! !

"August 15, 2010 -> 13:18:43"!

! (Delta mirrorFor: #UnsafeAlien) methodsFor: 'initialization' !
nonPointerObject: bytes <IndexedByteInstanceVariables>

	nonPointerObject := bytes! !

"August 15, 2010 -> 13:19:1"!

Delta define: #ClassTestIvars123 as: (
(Class subclassOf: 'Object' instanceVariables: 'one' classInstanceVariables: 'two three')) !


"August 15, 2010 -> 13:19:1"!

(Delta mirrorFor: #ClassTestIvars123) removeDefinitionIfFail: [] !


"August 15, 2010 -> 13:43:2"!

! (Delta mirrorFor: #PointerAlienTest) methodsFor: 'testing' !
testPointer

	self assert: alien pointer == alien! !

"August 15, 2010 -> 13:43:33"!

Delta define: #ClassTestIvars123 as: (
(Class subclassOf: 'Object' instanceVariables: 'one' classInstanceVariables: 'two three')) !


"August 15, 2010 -> 13:43:33"!

(Delta mirrorFor: #ClassTestIvars123) removeDefinitionIfFail: [] !


"August 15, 2010 -> 13:45:42"!

Delta define: #ClassTestIvars123 as: (
(Class subclassOf: 'Object' instanceVariables: 'one' classInstanceVariables: 'two three')) !


"August 15, 2010 -> 13:45:42"!

(Delta mirrorFor: #ClassTestIvars123) removeDefinitionIfFail: [] !


"August 15, 2010 -> 13:50:38"!

"System saved" !
"August 15, 2010 -> 14:5:8"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: '') classVariables: 'GCMallocedAliens LoadedLibraries') !


"August 15, 2010 -> 14:5:8"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: '') classVariables: 'GCMallocedAliens LoadedLibraries') !


"August 15, 2010 -> 14:5:8"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: '') classVariables: 'GCMallocedAliens LoadedLibraries') !


"August 15, 2010 -> 14:5:8"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: '') classVariables: 'GCMallocedAliens LoadedLibraries') !


"August 15, 2010 -> 14:5:8"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: '') classVariables: 'GCMallocedAliens LoadedLibraries') !


"August 15, 2010 -> 14:5:8"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: '') classVariables: 'GCMallocedAliens LoadedLibraries') !


"August 15, 2010 -> 14:5:8"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: '') classVariables: 'GCMallocedAliens LoadedLibraries') !


"August 15, 2010 -> 14:5:8"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: '') classVariables: 'GCMallocedAliens LoadedLibraries') !


"August 15, 2010 -> 14:5:8"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: '') classVariables: 'GCMallocedAliens LoadedLibraries') !


"August 15, 2010 -> 14:5:8"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: '') classVariables: 'GCMallocedAliens LoadedLibraries') !


"August 15, 2010 -> 14:5:8"!

Delta define: #Alien as: (
(Class subclassOf: 'ByteArray' instanceVariables: '') classVariables: 'GCMallocedAliens LoadedLibraries') !


"August 15, 2010 -> 14:5:8"!

(Delta mirrorFor: #Alien)
comment: 
''!


"August 15, 2010 -> 14:5:8"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'class initialization' !
initialize

	LoadedLibraries isNil ifTrue: 
		[LoadedLibraries := Dictionary new].
	GCMallocedAliens isNil ifTrue:
		[GCMallocedAliens := AlienWeakTable newForOwner: self]! !

"August 15, 2010 -> 14:5:8"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
atAddress: pointer <Integer> ^<X>

	^(self primitiveNew: 8)
		size: self dataSize negated;
		addressField: pointer;
		yourself! !

"August 15, 2010 -> 14:5:8"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
atAddress: pointer <Integer> dataSize: dataSize <Integer> ^<X>

	^(self primitiveNew: 8)
		size: dataSize negated;
		addressField: pointer;
		yourself! !

"August 15, 2010 -> 14:5:8"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
autoFreeAfter: action <[X, ^ Y]>
	"Evaluate the action, which must be a 1-argument block.
	 The argument passed to the action is a block the action
	 can use to register Aliens created inside the action.
	 Such aliens will be freed as soon as the action completes.
	 Return the value returned from the action. See usage
	 example at the bottom of the method. "
	
	| toFree |
	toFree := OrderedCollection new.
	^[action value: [:alien | toFree add: alien]]
		ensure: [toFree do: [:each | each free]]
		
"
	Alien autoFreeAfter:
		[:autoFree | | foo bar |
		foo := autoFree value: (Alien newCString: 'foo').
		bar := autoFree value: (Alien newCString: 'bar').
		...]
"! !

"August 15, 2010 -> 14:5:8"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
dataSize

	^self subclassResponsibility! !

"August 15, 2010 -> 14:5:8"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
ensureLoaded: libraryName

	^self loadedLibraries
		at: libraryName
		ifAbsentPut: [(Alien new: 4)
								unsignedLongAt: 1 put: (self primLoadLibrary: libraryName);
								yourself]! !

"August 15, 2010 -> 14:5:8"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
forLong: long

	((long > 16r7FFFFFFF) or: [long < -16r80000000])
		ifTrue: [self error: 'Out of range'].
	^(self new: 4)
		signedLongAt: 1 put: long;
		yourself! !

"August 15, 2010 -> 14:5:8"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
forPointer: pointer <Integer> ^<X>

	^(self primitiveNew: 8)
		size: 0;
		addressField: pointer;
		yourself! !

"August 15, 2010 -> 14:5:8"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
forULong: ulong

	((ulong > 16rFFFFFFFF) or: [ulong < 0])
		ifTrue: [self error: 'Out of range'].
	^(self new: 4)
		unsignedLongAt: 1 put: ulong;
		yourself! !

"August 15, 2010 -> 14:5:8"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
new

	^self new: self dataSize! !

"August 15, 2010 -> 14:5:8"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
new: size <Integer> ^ <X>

	^(self primitiveNew: size + 4)
		size: size;
		initialize! !

"August 15, 2010 -> 14:5:8"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
newC

	^self newC: self dataSize! !

"August 15, 2010 -> 14:5:8"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
newC: size <Integer> ^ <X>

	^(self primitiveNew: 8)
		size: size negated;
		addressField: (self Ccalloc: size);
		initialize! !

"August 15, 2010 -> 14:5:8"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
newCString: string <String> ^ <Alien>

	^(Alien rawNewC: string size + 1)
		replaceFrom: 1
		to: string size
		with: string
		startingAt: 1;
		unsignedByteAt: string size + 1 put: 0;
		yourself! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
newForCallbackArgs

	^(self new: 8)
		size: self dataSize negated;
		yourself! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
newGC

	^self newGC: self dataSize! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
newGC: size <Integer> ^<X>

	| alien address |
	alien := self primitiveNew: 8.
	alien size: size negated.
	address := self Ccalloc: size.
	self gcMallocedAliens add: alien.
	^alien
		addressField: address;
		initialize
		! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
rawNewC: size <Integer> ^ <X>

	^(self primitiveNew: 8)
		size: size negated;
		addressField: (self Cmalloc: size);
		initialize! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
thunk: address <Integer> ^ <Alien>

	^(self forPointer: address)
			size: 4;
			yourself! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'libraries' !
lookup: symbolName <String> inLibrary: libraryName <String> ^ <Alien>

	^self forPointer: ((Alien ensureLoaded: libraryName)
										primFindSymbol: symbolName)! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'libraries' !
lookupOrNil: symbolName <String> inLibrary: libraryName <String> ^ <Alien>

	^[self lookup: symbolName inLibrary: libraryName]
			on: NotFoundError
			do: [:err| nil]! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'libraries' !
primLoadLibrary: libraryName

	^(Platform DLLLoad2: libraryName) asInteger! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'private - accessing' !
gcMallocedAliens ^<WeakSet>

	GCMallocedAliens isNil
		ifTrue: [GCMallocedAliens := WeakSet new.
					GCMallocedAliens addWeakDependent: (
						BlockDependent updateBlock: [:aspect :alien | alien free])].
	^GCMallocedAliens! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'private - accessing' !
loadedLibraries

	LoadedLibraries isNil ifTrue: 
		[LoadedLibraries := Dictionary new].
	^LoadedLibraries! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'private - memory allocation' !
Ccalloc: size <Integer> ^ <Integer>

	^{{self primitiveAlienCalloc: size
			ifFail: [:err| self error: 'Failed to calloc alien: ', err]}}! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'private - memory allocation' !
Cmalloc: size <Integer> ^ <Integer>

	^{{self primitiveAlienMalloc: size
			ifFail: [:err| self error: 'Failed to malloc alien: ', err]}}! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
address ^<Integer>

	^self size <= 0
		ifTrue: [self addressField]
		ifFalse: [self error: 'One cannot take the address of direct Alien instances; they may move']! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
boolAt: index <Integer> ^<Boolean>

	^(self at: 1) ~~ 0! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
boolAt: index <Integer> put: value <Boolean> ^<Boolean>

	self at: 1 put: (value ifTrue: [1] ifFalse: [0]).
	^value! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
dataSize ^<Integer>

	^self size abs! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
doubleAt: index <Integer> ^<Float>

	^{{self primitiveAlienDoubleAt: index
				ifFail: [:err| self error: 'Unable to get double ', err] }}! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
doubleAt: index <Integer> put: double <Float> ^<Float>

	^{{self primitiveAlienDoubleAt: index
				put: double
				ifFail: [:err| self error: 'Unable to set double ', err] }}! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
floatAt: index <Integer> ^<Double>

	^{{self primitiveAlienFloatAt: index
				ifFail: [:err| self error: 'Unable to get float ', err] }}! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
floatAt: index <Integer> put: double <Float> ^<Float>

	^{{self primitiveAlienFloatAt: index
				put: double
				ifFail: [:err| self error: 'Unable to set float ', err] }}! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
pointer

	self isPointer ifTrue: [self error:  'One cannot take the address of pointer Alien instances; they may move, and are already pointers'].
	^self class forPointer: self address! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedByteAt: index <Integer> ^<Integer>

	^{{self primitiveAlienSignedByteAt: index
				ifFail: [:err| self error: 'Unable to get signed byte ', err] }}! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedByteAt: index <Integer> put: byte <Integer> ^<Integer>

	^{{self primitiveAlienSignedByteAt: index
				put: byte
				ifFail: [:err| self error: 'Unable to set signed byte ', err] }}! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedLongAt: index <Integer> ^<Integer>

	^{{self primitiveAlienSignedLongAt: index
				ifFail: [:err| self error: 'Unable to get signed long ', err] }}! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedLongAt: index <Integer> put: long <Integer>^<Integer>

	^{{self primitiveAlienSignedLongAt: index
				put: long
				ifFail: [:err| self error: 'Unable to get signed long ', err] }}! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> ^<Integer>

	^{{self primitiveAlienSignedShortAt: index
				ifFail: [:err| self error: 'Unable to get signed short ', err] }}! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
signedShortAt: index <Integer> put: short <Integer> ^<Integer>

	^{{self primitiveAlienSignedShortAt: index
				put: short
				ifFail: [:err| self error: 'Unable to set signed short ', err] }}! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strcpy

	^self strcpyFrom: 1! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strcpyFrom: startIndex

	|string length offset|
	length := self strlenStartingAt: startIndex.
	string := String new: length.
	offset := startIndex - 1.
	1 to: length do: [:i|
		string at: i put: (Character value: (self unsignedByteAt: i + offset))].
	^string! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strcpyUTF8

	^self strcpyUTF8From: 1! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strcpyUTF8From: startIndex

	^self unimplemented! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strlen

	^self strlenStartingAt: 1! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
strlenStartingAt: startIndex

	self dataSize == 0
		ifTrue: [^self rawStrlenStartingAt: startIndex].
	startIndex to: self dataSize do: [:i| (self unsignedByteAt: i) == 0
																ifTrue: [^ i - startIndex]].
	^self dataSize - startIndex + 1! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedByteAt: index <Integer> ^<Integer>

	^{{self primitiveAlienUnsignedByteAt: index
				ifFail: [:err| self error: 'Unable to get unsigned byte ', err] }}! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedByteAt: index <Integer> put: byte <Integer|Character> ^<Integer>

	|c|
	c := byte isCharacter
				ifTrue: [byte asciiValue]
				ifFalse: [byte].
	^{{self primitiveAlienUnsignedByteAt: index
				put: c
				ifFail: [:err| self error: 'Unable to set unsigned byte ', err] }}! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedLongAt: index <Integer> ^<Integer>

	^{{self primitiveAlienUnsignedLongAt: index
				ifFail: [:err| self error: 'Unable to get unsigned long ', err] }}! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedLongAt: index <Integer> put: long <Integer>^<Integer>

	^{{self primitiveAlienUnsignedLongAt: index
				put: long
				ifFail: [:err| self error: 'Unable to set unsigned long ', err] }}! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> ^<Integer>

	^{{self primitiveAlienUnsignedShortAt: index
				ifFail: [:err| self error: 'Unable to get unsigned short ', err] }}! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
unsignedShortAt: index <Integer> put: short <Integer>^<Integer>

	^{{self primitiveAlienUnsignedShortAt: index
				put: short
				ifFail: [:err| self error: 'Unable to set unsigned short ', err] }}! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
asAliens: array <Array> ^ <Array[Alien]>

	^array collect: [:el| el asAlien]! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien>

	{{self primitiveAlienCallResult: result ifFail: [:err| self error: err]}}.
	^result! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject> with: arg1 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1 asAlien
			ifFail: [:err| self error: err]}}.
	^result! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject> with: arg1 <Alien|SmallInteger> with: arg2 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1 asAlien
			with: arg2 asAlien
			ifFail: [:err| self error: err]}}.
	^result! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1 asAlien
			with: arg2 asAlien
			with: arg3 asAlien
			ifFail: [:err| self error: err]}}.
	^result! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1 asAlien
			with: arg2 asAlien
			with: arg3 asAlien
			with: arg4 asAlien
			ifFail: [:err| self error: err]}}.
	^result! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1 asAlien
			with: arg2 asAlien
			with: arg3 asAlien
			with: arg4 asAlien
			with: arg5 asAlien
			ifFail: [:err| self error: err]}}.
	^result! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1 asAlien
			with: arg2 asAlien
			with: arg3 asAlien
			with: arg4 asAlien
			with: arg5 asAlien
			with: arg6 asAlien
			ifFail: [:err| self error: err]}}.
	^result! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			with: arg1 asAlien
			with: arg2 asAlien
			with: arg3 asAlien
			with: arg4 asAlien
			with: arg5 asAlien
			with: arg6 asAlien
			with: arg7 asAlien
			ifFail: [:err| self error: err]}}.
	^result! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger>
with: arg8 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: (self asAliens: { arg1. arg2. arg3. arg4. arg5. arg6. arg7. arg8 })
			ifFail: [:err| self error: err]}}.
	^result! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger>
with: arg8 <Alien|SmallInteger>
with: arg9 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: (self asAliens: { arg1. arg2. arg3. arg4. arg5. arg6. arg7. arg8. arg9 })
			ifFail: [:err| self error: err]}}.
	^result! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger>
with: arg8 <Alien|SmallInteger>
with: arg9 <Alien|SmallInteger>
with: arg10 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: (self asAliens: { arg1. arg2. arg3. arg4. arg5. arg6. arg7. arg8. arg9. arg10 })
			ifFail: [:err| self error: err]}}.
	^result! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger>
with: arg8 <Alien|SmallInteger>
with: arg9 <Alien|SmallInteger>
with: arg10 <Alien|SmallInteger>
with: arg11 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: (self asAliens: { arg1. arg2. arg3. arg4. arg5. arg6. arg7. arg8. arg9. arg10. arg11 })
			ifFail: [:err| self error: err]}}.
	^result! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
with: arg1 <Alien|SmallInteger>
with: arg2 <Alien|SmallInteger>
with: arg3 <Alien|SmallInteger>
with: arg4 <Alien|SmallInteger>
with: arg5 <Alien|SmallInteger>
with: arg6 <Alien|SmallInteger>
with: arg7 <Alien|SmallInteger>
with: arg8 <Alien|SmallInteger>
with: arg9 <Alien|SmallInteger>
with: arg10 <Alien|SmallInteger>
with: arg11 <Alien|SmallInteger>
with: arg12 <Alien|SmallInteger> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: (self asAliens: { arg1. arg2. arg3. arg4. arg5. arg6. arg7. arg8. arg9. arg10. arg11. arg12 })
			ifFail: [:err| self error: err]}}.
	^result! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'callouts' !
primFFICallResult: result <Alien|UndefinedObject>
withArguments: arguments <Array[Alien|SmallInteger]> ^ <Alien>

	{{self primitiveAlienCallResult: result
			withArguments: (self asAliens: arguments)
			ifFail: [:err| self error: err]}}.
	^result! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'converting' !
asAlien

	^self! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'converting' !
asExternalProxy ^<ExternalProxy>

	^ExternalProxy
		forHigh: (self unsignedShortAt: 3)
		low: (self unsignedShortAt: 1)! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'converting' !
asSignedByte

	^self signedByteAt: 1! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'converting' !
asSignedLong

	^self signedLongAt: 1! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'converting' !
asSignedShort

	^self signedShortAt: 1! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'converting' !
asUnsignedByte

	^self unsignedByteAt: 1! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'converting' !
asUnsignedLong

	^self unsignedLongAt: 1! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'converting' !
asUnsignedShort

	^self unsignedShortAt: 1! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'instance initialization' !
initialize
	"Subclasses may override to perform specific initialization"! !

"August 15, 2010 -> 14:5:9"!

! (Delta mirrorFor: #Alien) methodsFor: 'memory management' !
free

	{{primitiveAlienFree: self addressField
		ifFail: [:err| self error: 'Could not free alien: ', err]}}.
	self addressField: 0! !

"August 15, 2010 -> 14:5:10"!

! (Delta mirrorFor: #Alien) methodsFor: 'memory management' !
freeAfter: aBlock <[Alien]>

	^[aBlock value: self]
		ensure: [self free]! !

"August 15, 2010 -> 14:5:10"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
addressField ^<Integer>

	^{{ self primitiveAlienAddressIfFail: [:err| self error: 'failed to get address of alien ', err] }}! !

"August 15, 2010 -> 14:5:10"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
addressField: anInteger <Integer>

	^{{ self primitiveAlienAddress: anInteger
					ifFail: [:err| self error: 'failed to set address of alien ', err] }}! !

"August 15, 2010 -> 14:5:10"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
at: index <Integer> ^ <SmallInteger>

	^self unsignedByteAt: index! !

"August 15, 2010 -> 14:5:10"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
at: index <Integer> put: byte <SmallInteger> ^ <SmallInteger>

	^self unsignedByteAt: index put: byte! !

"August 15, 2010 -> 14:5:10"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
primFindSymbol: symbolName <String> ^ <Integer>

	|result library|
	result := ExternalProxy new.
	library := self asExternalProxy.
	{{primitiveDLLLookup: symbolName asSymbol
			in: library
			result: result
			ifFail: [:err | err == #NotFound
									ifTrue: [NotFoundError signal]
									ifFalse: [self error: err]]}}.
	^result asInteger	! !

"August 15, 2010 -> 14:5:10"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
rawStrlenStartingAt: startIndex

	|index|
	index := startIndex.
	[(self unsignedByteAt: index) == 0]
		whileFalse: [index := index + 1].
	^index - startIndex! !

"August 15, 2010 -> 14:5:10"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
signedFourByteLimit

	^self smallIntLimit * 4! !

"August 15, 2010 -> 14:5:10"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
size ^<Integer>

	^{{self primitiveAlienSizeIfFail: [:err| self error: 'failed to get alien size: ', err] }}! !

"August 15, 2010 -> 14:5:10"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
size: anInteger <Integer>

	{{self primitiveAlienSize: anInteger
				ifFail: [:err| self error: 'failed to set alien size: ', err] }}! !

"August 15, 2010 -> 14:5:10"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
smallIntLimit

	^SmallInteger maxVal + 1! !

"August 15, 2010 -> 14:5:10"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
strlenThroughPointerAt: index

	^(Alien forPointer: (self unsignedLongAt: index))
		rawStrlenStartingAt: 1! !

"August 15, 2010 -> 14:5:10"!

! (Delta mirrorFor: #Alien) methodsFor: 'private - accessing' !
unsignedFourByteLimit

	^self smallIntLimit * 8! !

"August 15, 2010 -> 14:5:10"!

! (Delta mirrorFor: #Alien) methodsFor: 'testing' !
isPointer

	^self size == 0! !

"August 15, 2010 -> 14:5:33"!

Delta define: #ClassTestIvars123 as: (
(Class subclassOf: 'Object' instanceVariables: 'one' classInstanceVariables: 'two three')) !


"August 15, 2010 -> 14:5:33"!

(Delta mirrorFor: #ClassTestIvars123) removeDefinitionIfFail: [] !


"August 15, 2010 -> 14:8:25"!

! (Delta mirrorFor: #Alien) methodsFor: 'accessing' !
pointer

	self isPointer ifTrue: [^self].
	^self class forPointer: self address! !

"August 15, 2010 -> 14:8:33"!

Delta define: #ClassTestIvars123 as: (
(Class subclassOf: 'Object' instanceVariables: 'one' classInstanceVariables: 'two three')) !


"August 15, 2010 -> 14:8:33"!

(Delta mirrorFor: #ClassTestIvars123) removeDefinitionIfFail: [] !


"August 15, 2010 -> 15:24:34"!

! (Delta mirrorFor: #Alien) classSide methodsFor: 'instance creation' !
thunk: address <Integer> ^ <Alien>

	^self forPointer: address! !

"August 15, 2010 -> 15:24:44"!

Delta define: #ClassTestIvars123 as: (
(Class subclassOf: 'Object' instanceVariables: 'one' classInstanceVariables: 'two three')) !


"August 15, 2010 -> 15:24:44"!

(Delta mirrorFor: #ClassTestIvars123) removeDefinitionIfFail: [] !


"August 15, 2010 -> 15:26:19"!

"System saved" !
"September 2, 2010 -> 0:17:1"!

(Delta mirrorFor: #NS1) removeDefinitionIfFail: [] !


"September 2, 2010 -> 0:17:6"!

(Delta mirrorFor: #NS2) removeDefinitionIfFail: [] !


"September 2, 2010 -> 0:17:10"!

(Delta mirrorFor: #NewspeakObject) removeDefinitionIfFail: [] !


"September 2, 2010 -> 0:17:20"!

"System saved" !
"September 12, 2010 -> 11:22:22"!

Delta define: #OrderedCollectionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"September 12, 2010 -> 11:23:4"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing' !
testAdd

	! !

"September 12, 2010 -> 11:23:44"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'fixture' !
setUp

! !

"September 12, 2010 -> 11:24:5"!

Delta define: #OrderedCollectionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'fixture')) !


"September 12, 2010 -> 11:24:22"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'fixture' !
setUp

	fixture := OrderedCollection new! !

"September 12, 2010 -> 11:24:34"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing' !
testAdd

	fixture add: 1! !

"September 12, 2010 -> 11:24:53"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing' !
testAdd

	fixture add: 1.
	self assert: fixture size = 1! !

"September 12, 2010 -> 11:25:20"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing' !
testAdd

	fixture add: 1.
	self assert: fixture size = 1.
	self assert: (fixture at: 1) = 1! !

"September 12, 2010 -> 11:26:38"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing' !
testRepeatedAdd

	fixture add: 1.
	fixture add: 3.
	self assert: fixture size = 2.
	self assert: (fixture at: 1) = 1.
	self assert: (fixture at: 2) = 3! !

"September 12, 2010 -> 11:27:7"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing' !
testAddFirst

	fixture add: 1.
	fixture addFirst: 3.
	self assert: fixture size = 2.
	self assert: (fixture at: 1) = 3.
	self assert: (fixture at: 2) = 1! !

"September 12, 2010 -> 11:27:31"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing' !
testAddLast

	fixture add: 3.
	fixture addLast: 1.
	self assert: fixture size = 2.
	self assert: (fixture at: 1) = 3.
	self assert: (fixture at: 2) = 1! !

"September 12, 2010 -> 11:28:8"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing' !
testAddAfter

	fixture add: 3.
	fixture add: 1 after: 3.
	self assert: fixture size = 2.
	self assert: (fixture at: 1) = 3.
	self assert: (fixture at: 2) = 1! !

"September 12, 2010 -> 11:33:29"!

! (Delta mirrorFor: #OrderedCollection) methodsFor: 'accessing' !
add: el <E> after: existing <E> ^<E>

	| index <Int> |
	index := self indexOf: existing.
	index = self size
		ifFalse: [ index := self makeSpace: 1
											beforeIndex: index + self startGap + 1 ]
		ifTrue: [	self needSpaceAtEnd: 1.
						index := index + self startGap + 1.	
						self lastIndex: index].
	^self contents at: index put: el.! !

"September 12, 2010 -> 11:34:46"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing' !
testAddBefore

	fixture add: 1.
	fixture add: 3 before: 1.
	self assert: fixture size = 2.
	self assert: (fixture at: 1) = 3.
	self assert: (fixture at: 2) = 1! !

"September 12, 2010 -> 11:35:48"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing' !
testAddBeforeIndex

	fixture add: 1.
	fixture add: 3 beforeIndex: 1.
	self assert: fixture size = 2.
	self assert: (fixture at: 1) = 3.
	self assert: (fixture at: 2) = 1! !

"September 12, 2010 -> 11:36:25"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing' !
testAddAfterIndex

	fixture add: 3.
	fixture add: 1 afterIndex: 1.
	self assert: fixture size = 2.
	self assert: (fixture at: 1) = 3.
	self assert: (fixture at: 2) = 1! !

"September 12, 2010 -> 11:39:14"!

! (Delta mirrorFor: #OrderedCollection) methodsFor: 'accessing' !
add: el <E> beforeIndex: i <Int> ^<E>

	| index <Int> |
	i > self size
		ifFalse: [	index := self makeSpace: 1 beforeIndex: i + self startGap.	]
		ifTrue: [	self needSpaceAtEnd: 1.
						index := i + self startGap.
						self lastIndex: index ].
	^self contents at: index put: el.! !

"September 12, 2010 -> 11:39:27"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing' !
testAddBeforeIndexAtEnd

	fixture add: 1.
	fixture add: 3 beforeIndex: 1.
	self assert: fixture size = 2.
	self assert: (fixture at: 1) = 3.
	self assert: (fixture at: 2) = 1! !

"September 12, 2010 -> 11:39:44"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing' !
testAddBeforeIndexAtStart

	fixture add: 1.
	fixture add: 3 beforeIndex: 1.
	self assert: fixture size = 2.
	self assert: (fixture at: 1) = 3.
	self assert: (fixture at: 2) = 1! !

"September 12, 2010 -> 11:40:44"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing' !
testAddBeforeIndexAtEnd

	fixture add: 1.
	fixture add: 2.
	fixture add: 3 beforeIndex: 2.
	self assert: fixture size = 2.
	self assert: (fixture at: 1) = 1.
	self assert: (fixture at: 2) = 3.
	self assert: (fixture at: 3) = 2! !

"September 12, 2010 -> 11:41:54"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing' !
testAddBeforeIndexAtEnd

	fixture add: 1.
	fixture add: 2.
	fixture add: 3 beforeIndex: 2.
	self assert: fixture size = 3.
	self assert: (fixture at: 1) = 1.
	self assert: (fixture at: 2) = 3.
	self assert: (fixture at: 3) = 2! !

"September 12, 2010 -> 11:42:54"!

Delta define: #OrderedCollectionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'fixture
empty
full')) !


"September 12, 2010 -> 11:44:1"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'fixture' !
setUp

	fixture := OrderedCollection new.
	empty := OrderedCollection new.
	full := OrderedCollection new.
	full add: 5; add: 2; add: 4; add:3! !

"September 12, 2010 -> 11:45:47"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing' !
testAddBeforeIndexAtEnd

	fixture add: 1 beforeIndex: full size.
	self assert: full size = 5.
	self assert: (full at: 1) = 5.
	self assert: (full at: 2) = 2.
	self assert: (full at: 3) = 4.
	self assert: (full at: 4) = 1.
	self assert: (full at: 5) = 3! !

"September 12, 2010 -> 11:46:43"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing' !
testAddBeforeIndexAtEnd

	full add: 1 beforeIndex: full size.
	self assert: full size = 5.
	self assert: (full at: 1) = 5.
	self assert: (full at: 2) = 2.
	self assert: (full at: 3) = 4.
	self assert: (full at: 4) = 1.
	self assert: (full at: 5) = 3! !

"September 12, 2010 -> 11:48:17"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing' !
testAddAfterIndexInMiddle

	full add: 1 afterIndex: 2.
	self assert: full size = 5.
	self assert: (full at: 3) = 1! !

"September 12, 2010 -> 11:48:43"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing' !
testAddBeforeIndexAtEnd

	full add: 1 beforeIndex: full size.
	self assert: (full at: 4) = 1.
	self assert: (full at: 5) = 3! !

"September 12, 2010 -> 11:49:43"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing' !
testAddBeforeIndexAtEnd

	full add: 1 beforeIndex: full size.
	self assert: full size = 5.
	self assert: (full at: 4) = 1.
	self assert: (full at: 5) = 3! !

"September 12, 2010 -> 11:51:26"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing' !
testAddBeforeIndexAtStart

	full add:1 beforeIndex: 1.
	self assert: full size = 5.
	self assert: (full at: 1) = 1.
	self assert: (full at: 2) = 5! !

"September 12, 2010 -> 11:53:3"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing' !
testAddBeforeIndexInMiddle

	fixture add: 1 beforeIndex: 3.
	self assert: full size = 5.
	self assert: (full at: 2) = 2.
	self assert: (full at: 3) = 1.
	self assert: (full at: 4) = 4! !

"September 12, 2010 -> 11:53:23"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing' !
testAddBeforeIndexInMiddle

	full add: 1 beforeIndex: 3.
	self assert: full size = 5.
	self assert: (full at: 2) = 2.
	self assert: (full at: 3) = 1.
	self assert: (full at: 4) = 4! !

"September 12, 2010 -> 11:53:58"!

(Delta mirrorFor: #OrderedCollectionTest) removeMethod: #testAddBeforeIndex ifAbsent: [] !


"September 12, 2010 -> 11:55:14"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing' !
testAddAfterIndexInMiddle

	full add: 1 afterIndex: 2.
	self assert: full size = 5.
	self assert: (full at: 2) = 2.
	self assert: (full at: 3) = 1.
	self assert: (full at: 4) = 4! !

"September 12, 2010 -> 11:56:24"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing' !
testAddAfterIndexAtStart

	full add: 1 afterIndex: 1.
	self assert: full size = 5.
	self assert: (full at: 1) = 5.
	self assert: (full at: 2) = 1.
	self assert: (full at: 3) = 2! !

"September 12, 2010 -> 11:57:5"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing' !
testAddAfterIndexAtEnd

	full add: 1 afterIndex: full size.
	self assert: full size = 5.
	self assert: (full at: 4) = 3.
	self assert: (full at: 5) = 1! !

"September 12, 2010 -> 11:59:1"!

(Delta mirrorFor: #OrderedCollectionTest) removeMethod: #testAddAfterIndex ifAbsent: [] !


"September 12, 2010 -> 12:0:4"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing' !
testAddAfterLast

	full add: 1 after: 3.
	self assert: full size = 5.
	self assert: (full at: 4) = 3.
	self assert: (full at: 5) = 1! !

"September 12, 2010 -> 12:0:56"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing' !
testAddAfterFirst

	full add: 1 after: 5.
	self assert: full size = 5.
	self assert: (full at: 1) = 5.
	self assert: (full at: 2) = 1.
	self assert: (full at: 3) = 2! !

"September 12, 2010 -> 12:3:7"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing' !
testAddAfterMiddle

	full add: 1 after: 2.
	self assert: full size = 5.
	self assert: (full at: 2) = 2.
	self assert: (full at: 3) = 1.
	self assert: (full at: 4) = 4! !

"September 12, 2010 -> 12:3:16"!

(Delta mirrorFor: #OrderedCollectionTest) removeMethod: #testAddAfter ifAbsent: [] !


"September 12, 2010 -> 12:4:45"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing' !
testAddAfterMissing

	self should: [full add: 1 after: -1] raise: Error! !

"September 12, 2010 -> 12:18:26"!

! (Delta mirrorFor: #OrderedCollection) methodsFor: 'accessing' !
add: el <E> after: existing <E> ^<E>

	| index <Int> |
	index := self indexOf: existing.
	index = 0
		ifTrue: [self error: '', existing, ' not found in collection'].
	index = self size
		ifFalse: [ index := self makeSpace: 1
											beforeIndex: index + self startGap + 1 ]
		ifTrue: [	self needSpaceAtEnd: 1.
						index := index + self startGap + 1.	
						self lastIndex: index].
	^self contents at: index put: el.! !

"September 12, 2010 -> 12:18:52"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing' !
testAddBeforeMissing

	self should: [full add: 1 before: -1] raise: Error! !

"September 12, 2010 -> 12:20:22"!

! (Delta mirrorFor: #OrderedCollection) methodsFor: 'accessing' !
notFound: missing

	^self error: '', missing, ' not found in collection'! !

"September 12, 2010 -> 12:20:56"!

! (Delta mirrorFor: #OrderedCollection) methodsFor: 'accessing' !
add: el <E> after: existing <E> ^<E>

	| index <Int> |
	index := self indexOf: existing.
	index = 0
		ifTrue: [self notFound: existing].
	index = self size
		ifFalse: [ index := self makeSpace: 1
											beforeIndex: index + self startGap + 1 ]
		ifTrue: [	self needSpaceAtEnd: 1.
						index := index + self startGap + 1.	
						self lastIndex: index].
	^self contents at: index put: el.! !

"September 12, 2010 -> 12:21:0"!

! (Delta mirrorFor: #OrderedCollection) methodsFor: 'accessing' !
add: el <E> before: existing <E> ^<E>

	| index <Int> |
	index := self indexOf: existing.
	index = 0
		ifTrue: [self notFound: existing].
	index := self makeSpace: 1 beforeIndex: index + self startGap.
	^self contents at: index put: el.! !

"September 12, 2010 -> 12:25:31"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing add:' !
testAddLast

	full add: 1.
	self assert: full size = 5.
	self assert: (full at: 5) = 1! !

"September 12, 2010 -> 12:25:40"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing add:' !
testAdd

	full add: 1.
	self assert: full size = 5.
	self assert: (full at: 5) = 1! !

"September 12, 2010 -> 12:26:24"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing addLast:' !
testAddLast

	full addLast: 1.
	self assert: full size = 5.
	self assert: (full at: 5) = 1! !

"September 12, 2010 -> 12:27:5"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing add:' !
testRepeatedAddLast

	fixture add: 1.
	fixture add: 3.
	self assert: fixture size = 2.
	self assert: (fixture at: 1) = 1.
	self assert: (fixture at: 2) = 3! !

"September 12, 2010 -> 12:28:46"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing addLast:' !
testRepeatedAddLast

	full add: 1.
	full add: 3.
	self assert: full size = 6.
	self assert: (full at: 5) = 1.
	self assert: (full at: 6) = 3! !

"September 12, 2010 -> 14:37:1"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing addLast:' !
testAddFirst

	full addFirst: 1.
	self assert: full size = 5.
	self assert: (full at: 1) = 1.
	self assert: (full at: 2) = 5! !

"September 12, 2010 -> 14:38:15"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing addFirst:' !
testRepeatedAddFirst

	full addFirst: 1.
	full addFirst: 6.
	self assert: full size = 6.
	self assert: (full at: 1) = 6.
	self assert: (full at: 2) = 1.
	self assert: (full at: 3) = 5! !

"September 12, 2010 -> 14:40:39"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing addFirst:' !
testAtPut

	full at: 1 put: 1.
	self assert: full size = 4.
	self assert: (full at: 1) = 1! !

"September 12, 2010 -> 14:41:29"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing at:put:' !
testAtPutMissing

	self should: [empty at: 1 put: 1]
		raise: Error! !

"September 12, 2010 -> 14:42:15"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing at:put:' !
testWith

	empty with: 1.
	self assert: empty size = 1! !

"September 12, 2010 -> 14:42:57"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing with:' !
testWithAddsToEnd

	full with: 1.
	self assert: full size = 5! !

"September 12, 2010 -> 14:43:18"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing with:' !
testWithAddsToEnd

	full with: 1.
	self assert: full size = 5.
	self assert: (full at: 5) = 1! !

"September 12, 2010 -> 15:13:26"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing addFirst:' !
testAddAllFirst

	full addAllFirst: (Array with: 6 with: 2).
	self assert: full size = 6.
	self assert: (full at: 1) = 6.
	self assert: (full at: 2) = 1.
	self assert: (full at: 3) = 5! !

"September 12, 2010 -> 15:13:38"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing addFirst:' !
testAddAllFirst

	full addAllFirst: (Array with: 6 with: 1).
	self assert: full size = 6.
	self assert: (full at: 1) = 6.
	self assert: (full at: 2) = 1.
	self assert: (full at: 3) = 5! !

"September 12, 2010 -> 15:16:7"!

! (Delta mirrorFor: #OrderedCollection) methodsFor: 'accessing' !
addAllFirst: c <Cltn[E]> ^<Cltn[E]>

	c reversedo: [ :el <E> | 	self addFirst: el ].
	^c! !

"September 12, 2010 -> 15:16:18"!

! (Delta mirrorFor: #OrderedCollection) methodsFor: 'accessing' !
addAllFirst: c <Cltn[E]> ^<Cltn[E]>

	c reverseDo: [ :el <E> | 	self addFirst: el ].
	^c! !

"September 12, 2010 -> 15:17:13"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing addLast:' !
testAddAllLast

	full addAllFirst: (Array with: 1 with: 3).
	self assert: full size = 6.
	self assert: (full at: 5) = 1.
	self assert: (full at: 6) = 3! !

"September 12, 2010 -> 15:19:32"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing addLast:' !
testAddAllLast

	full addAllLast: (Array with: 1 with: 3).
	self assert: full size = 6.
	self assert: (full at: 5) = 1.
	self assert: (full at: 6) = 3! !

"September 12, 2010 -> 15:20:21"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing addLast:' !
testAddAll

	full addAll: (Array with: 1 with: 3).
	self assert: full size = 6.
	self assert: (full at: 5) = 1.
	self assert: (full at: 6) = 3! !

"September 12, 2010 -> 15:21:19"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing with:' !
testWithAllAddsToEnd

	full withAll: (Array with: 1 with: 3).
	self assert: full size = 6.
	self assert: (full at: 5) = 1.
	self assert: (full at: 6) = 3! !

"September 12, 2010 -> 15:22:54"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing with:' !
testAsArray

	fixture add: 1.
	self assert: fixture asArray = (Array with: 1)! !

"September 12, 2010 -> 15:23:36"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing conversions' !
testAsOrderedCollection

	fixture add: 1.
	self assert: fixture asOrderedCollection = fixture! !

"September 12, 2010 -> 15:24:57"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing conversions' !
testAsSortedCollection

	self assert: full asSortedCollection = (SortedCollection
																				with: 2
																				with: 3
																				with: 4
																				with: 5)! !

"September 12, 2010 -> 15:25:44"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing conversions' !
testRemoveWhenEmpty

	self should: [empty remove: 1] raise: Error! !

"September 12, 2010 -> 15:27:26"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing remove:' !
testRemoveIfAbsentWhenEmpty

	|wasAbsent|
	wasAbsent := false.
	empty remove: 1 ifAbsent: [wasAbsent := true].
	self assert: wasAbsent! !

"September 12, 2010 -> 15:28:25"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing remove:' !
testRemove

	fixture add: 1.
	fixture remove: 1.
	self assert: fixture isEmpty! !

"September 12, 2010 -> 15:29:42"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing remove:' !
testRemoveFromFull

	full remove: 5.
	self assert: full = (OrderedCollection with: 2 with: 4 with: 3)! !

"September 12, 2010 -> 15:30:49"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing remove:' !
testEquals

	self assert: full = (OrderedCollection with: 5 with: 2 with: 4 with: 3)! !

"September 12, 2010 -> 15:31:15"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing remove:' !
testEquals

	self assert: full = (OrderedCollection with: 5 with: 2 with: 4 with: 3).
	self deny: full = (OrderedCollection with: 2 with: 4 with: 3)! !

"September 12, 2010 -> 15:31:33"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing remove:' !
testEquals

	self assert: full = (OrderedCollection with: 5 with: 2 with: 4 with: 3).
	self deny: full = (OrderedCollection with: 2 with: 4 with: 3).
	self deny: full = nil! !

"September 12, 2010 -> 15:31:53"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing remove:' !
testEquals

	self assert: full = (OrderedCollection with: 5 with: 2 with: 4 with: 3).
	self deny: full = (OrderedCollection with: 2 with: 4 with: 3).
	self deny: full = nil.
	self deny: full = full asArray! !

"September 12, 2010 -> 15:32:51"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing equality' !
testDoubleEquals

	self deny: full == (OrderedCollection with: 5 with: 2 with: 4 with: 3).
	self assert: full == full! !

"September 12, 2010 -> 15:33:29"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing remove:' !
testRemoveAt

	fixture add: 1.
	fixture removeAt: 1.
	self assert: fixture isEmpty! !

"September 12, 2010 -> 15:34:18"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing removeAt:' !
testRemoveAt

	full removeAt: 1.
	self assert: full size = 3! !

"September 12, 2010 -> 15:35:14"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing removeAt:' !
testRemoveAt

	full removeAt: 1.
	self assert: full size = 3.
	self assert: full = (OrderedCollection with: 2 with: 4 with: 3)! !

"September 12, 2010 -> 15:35:51"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing removeAt:' !
testRemoveAtWhenEmpty

	self should: [empty removeAt: 1] raise: Error! !

"September 12, 2010 -> 15:36:48"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing removeAt:' !
testRemoveAtIfAbsentWhenEmpty

	|wasAbsent|
	wasAbsent := false.
	empty
		removeAt: 1
		ifAbsent: [wasAbsent := true].
	self assert: wasAbsent! !

"September 12, 2010 -> 16:6:48"!

(Delta mirrorFor: #OrderedCollectionTest) removeMethod: #testRemoveAtIfAbsentWhenEmpty ifAbsent: [] !


"September 12, 2010 -> 16:9:6"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing removeAt:' !
testRemoveAtIfAbsentWhenEmpty

	|wasAbsent|
	wasAbsent := false.
	empty
		removeAt: 1
		ifAbsent: [wasAbsent := true].
	self assert: wasAbsent! !

"September 12, 2010 -> 16:12:47"!

! (Delta mirrorFor: #AddableSequenceableCollection) methodsFor: 'accessing' !
removeAt: index <Int>  ifAbsent: f <[^X def]> ^<E|X>

	| el <E> |
	el := self at: index ifAbsent: [^f value].
	self remove: 1 at: index.
	^el! !

"September 12, 2010 -> 16:19:39"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing removeAt:' !
testAt

	self assert: (full at: 1) = 5! !

"September 12, 2010 -> 16:20:34"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing at:' !
testAtWhenEmpty

	self should: [empty at: 1] raise: Error! !

"September 12, 2010 -> 16:21:56"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing at:' !
testAtIfAbsentWhenEmpty

	|wasAbsent|
	wasAbsent := false.
	empty at: 1 ifAbsent: [wasAbsent := true].
	self assert: wasAbsent! !

"September 12, 2010 -> 16:22:11"!

Delta define: #OrderedCollectionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'fixture
empty
full
wasAbsent')) !


"September 12, 2010 -> 16:22:24"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'fixture' !
setUp

	fixture := OrderedCollection new.
	empty := OrderedCollection new.
	full := OrderedCollection new.
	full add: 5; add: 2; add: 4; add:3.
	wasAbsent := false! !

"September 12, 2010 -> 16:22:34"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing at:' !
testAtIfAbsentWhenEmpty

	empty at: 1 ifAbsent: [wasAbsent := true].
	self assert: wasAbsent! !

"September 12, 2010 -> 16:22:47"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing removeAt:' !
testRemoveAtIfAbsentWhenEmpty

	empty
		removeAt: 1
		ifAbsent: [wasAbsent := true].
	self assert: wasAbsent! !

"September 12, 2010 -> 16:32:33"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing removeAt:' !
testRemoveAt2

	full remove: 1 at: 1.
	self assert: full size = 3.
	self assert: full = (OrderedCollection with: 2 with: 4 with: 3)! !

"September 12, 2010 -> 16:36:53"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing remove:at:' !
testRemoveAtShouldRemoveTwo

	full remove: 2 at: 1.
	self assert: full size = 2.
	self assert: full = (OrderedCollection with: 4 with: 3)! !

"September 12, 2010 -> 16:37:38"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing remove:at:' !
testRemoveAt2WhenEmpty

	self should: [empty remove: 1 at: 1] raise: Error! !

"September 12, 2010 -> 16:38:31"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing removeAt:' !
testRemoveAtIfAbsentWhenNotEmpty

	full
		removeAt: 1
		ifAbsent: [wasAbsent := true].
	self deny: wasAbsent! !

"September 12, 2010 -> 16:39:9"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing removeAt:' !
testRemoveAtIfAbsentWhenNotEmpty

	full
		removeAt: 1
		ifAbsent: [wasAbsent := true].
	self deny: wasAbsent.
	self assert: full = (OrderedCollection with: 2 with: 4 with: 3)! !

"September 12, 2010 -> 16:57:4"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing at:' !
testIndexOfWhenEmpty

	self assert: (empty indexOf: 1) = 0! !

"September 12, 2010 -> 16:57:27"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing at:' !
testIndexOfMissing

	self assert: (empty indexOf: 1) = 0! !

"September 12, 2010 -> 16:57:30"!

(Delta mirrorFor: #OrderedCollectionTest) removeMethod: #testIndexOfWhenEmpty ifAbsent: [] !


"September 12, 2010 -> 16:58:35"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing indexOf:' !
testIndexOf

	self assert: (full indexOf: 5) = 1! !

"September 12, 2010 -> 17:1:58"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing indexOf:' !
testIndexOfIfAbsent

	empty indexOf: 5 ifAbsent: [wasAbsent := true].
	self assert: wasAbsent! !

"September 12, 2010 -> 17:2:17"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing indexOf:' !
testIndexOfIfAbsentWhenPresent

	full indexOf: 5 ifAbsent: [wasAbsent := true].
	self deny: wasAbsent! !

"September 12, 2010 -> 17:2:41"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing indexOf:' !
testIndexOfIfAbsentWhenPresent

	self assert: (full indexOf: 5 ifAbsent: [wasAbsent := true]) = 1.
	self deny: wasAbsent! !

"September 12, 2010 -> 18:43:29"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing add:' !
testIncludeAll

	full includeAll: (Array with: 1 with: 3).
	self assert: full size = 6.
	self assert: (full at: 5) = 1.
	self assert: (full at: 6) = 3! !

"September 12, 2010 -> 18:44:58"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing add:' !
testInclude

	full include: 1.
	self assert: full size = 5.
	self assert: (full at: 5) = 1! !

"September 12, 2010 -> 18:51:55"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing add:' !
testIncludeAll

	full includeAll: (Array with: 1 with: 6).
	self assert: full size = 6.
	self assert: (full at: 5) = 1.
	self assert: (full at: 6) = 6! !

"September 12, 2010 -> 18:53:51"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing removeAll' !
testRemoveAll

	full removeAll.
	self assert: full = empty! !

"September 12, 2010 -> 18:54:39"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing removeAll' !
testRemoveAllElements

	full removeAll: (Array with: 5 with: 4 with: 2 with: 3).
	self assert: full = empty! !

"September 12, 2010 -> 18:56:56"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing removeFirst' !
testRemoveFirst

	self assert: full removeFirst = 5.
	self assert: full size = 3.
	self assert: full = (OrderedCollection with: 4 with: 2 with: 3)! !

"September 12, 2010 -> 18:57:12"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing removeFirst' !
testRemoveFirst

	self assert: full removeFirst = 5.
	self assert: full size = 3.
	self assert: full = (OrderedCollection with: 2 with: 4 with: 3)! !

"September 12, 2010 -> 18:57:52"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing removeFirst' !
testRemoveFirstWhenEmpty

	self should: [empty removeFirst] raise: Error! !

"September 12, 2010 -> 18:58:24"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing removeFirst' !
testRemoveLastWhenEmpty

	self should: [empty removeLast] raise: Error! !

"September 12, 2010 -> 18:59:9"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing removeLast' !
testRemoveLast

	self assert: full removeLast = 3! !

"September 12, 2010 -> 18:59:27"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing removeLast' !
testRemoveLast

	self assert: full removeLast = 3.
	self deny: (full includes: 3)! !

"September 12, 2010 -> 18:59:56"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing removeLast' !
testRemoveLast

	self assert: full removeLast = 3.
	self deny: (full includes: 3).
	self assert: full = (OrderedCollection with: 5 with: 4 with: 2)! !

"September 12, 2010 -> 19:0:18"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing removeLast' !
testRemoveLast

	self assert: full removeLast = 3.
	self deny: (full includes: 3).
	self assert: full = (OrderedCollection with: 5 with: 2 with: 4)! !

"September 13, 2010 -> 1:58:50"!

! (Delta mirrorFor: #AddableSequenceableCollection) methodsFor: 'accessing' !
remove: nElements <Int> at: i <Int>

	| el <E> internal <Int> |
	el := self at: i.
	internal := self startGap + i.
	self internalRangeCheck: internal.
	self internalRangeCheck: (internal + nElements) - 1.
	nElements = self size
		ifTrue: [self startGap: self lastIndex.
						^self].
	internal  to: lastIndex - nElements
		 do: [ :index <Int> |
			  self contents at: index put: (self contents at: index + nElements).	].
	self contents putNilAt: self lastIndex.
	self lastIndex: self lastIndex - nElements.! !

"September 13, 2010 -> 2:2:20"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing add:' !
testAddResizing

	|size|
	empty add: 1.
	size := empty contents size.
	empty remove: 1.
	empty add: 1.
	self assert: size = empty contents size
	! !

"September 13, 2010 -> 2:2:46"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing add:' !
testAddResizing

	|size|
	empty add: 1.
	size := empty contents size.
	empty remove: 1.
	empty add: 1.
	empty remove: 1.
	empty add: 1.
	self assert: size = empty contents size
	! !

"September 13, 2010 -> 2:3:19"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing add:' !
testAddResizing

	|size|
	empty add: 1.
	size := empty contents size.
	1000 timesRepeat: [
		empty remove: 1.
		empty add: 1].
	self assert: size = empty contents size! !

"September 13, 2010 -> 2:5:58"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing add:' !
testAddResizing

	|size|
	empty add: 1.
	size := empty contents size.
	1000 timesRepeat: [
		empty remove: 1.
		empty add: 1].
	self assert: size = empty contents size
		description: empty contents size printString! !

"September 13, 2010 -> 2:7:38"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing add:' !
testAddResizing

	|size|
	empty add: 1.
	size := empty contents size.
	5 timesRepeat: [
		empty remove: 1.
		empty add: 1].
	self assert: size = empty contents size
		description: empty contents size printString! !

"September 13, 2010 -> 2:20:18"!

! (Delta mirrorFor: #AddableSequenceableCollection) methodsFor: 'private' !
makeSpaceAtStart: nslots <Int> ^<Int>
	"Make sure that there are at least nslots of unused capacity at the low
	 end of contents.  The # of slots added at the beginning is returned."

	|	newGap <Int>
		diff <Int>
		newContents <AbsoluteArray[E]>
		sz <Int>
		newLastIndex <Int> |
	sz := self size.
	newGap := nslots max: sz.
	diff := newGap - self startGap.
	newLastIndex := newGap + sz.
	newContents := AbsoluteArray[E] new:
	self contents size + diff.
	newContents
		replaceFrom: newGap + 1
		to: newLastIndex
		with: self contents
		startingAt: self firstIndex.
	self	startGap: newGap;
		contents: newContents;
		lastIndex: newLastIndex.
	^diff! !

"September 13, 2010 -> 2:20:56"!

! (Delta mirrorFor: #AddableSequenceableCollection) methodsFor: 'private' !
needSpaceAtStart: nslots <Int> ^<Int>
	"Make sure that there are at least nslots of unused capacity at the low
	 end of contents.  The # of slots added at the beginning is returned."

	^nslots > self startGap
		ifTrue: [	self makeSpaceAtStart: nslots]
		ifFalse: [ 0 ]! !

"September 13, 2010 -> 2:25:5"!

! (Delta mirrorFor: #AddableSequenceableCollection) methodsFor: 'private' !
makeSpaceAtStart: nslots <Int> ^<Int>
	"Make sure that there are at least nslots of unused capacity at the low
	 end of contents.  The # of slots added at the beginning is returned."

	|	newGap <Int>
		diff <Int>
		newContents <AbsoluteArray[E]>
		sz <Int>
		newLastIndex <Int> |
	(self isEmpty and: [nslots < self contents size])
		ifTrue: [self startGap: nslots.
						self lastIndex: nslots.
						^0].
	sz := self size.
	newGap := nslots max: sz.
	diff := newGap - self startGap.
	newLastIndex := newGap + sz.
	newContents := AbsoluteArray[E] new:
	self contents size + diff.
	newContents
		replaceFrom: newGap + 1
		to: newLastIndex
		with: self contents
		startingAt: self firstIndex.
	self	startGap: newGap;
		contents: newContents;
		lastIndex: newLastIndex.
	^diff! !

"September 13, 2010 -> 2:27:2"!

! (Delta mirrorFor: #AddableSequenceableCollection) methodsFor: 'private' !
makeSpaceAtStart: nslots <Int> ^<Int>
	"Make sure that there are at least nslots of unused capacity at the low
	 end of contents.  The # of slots added at the beginning is returned."

	|	newGap <Int>
		diff <Int>
		newContents <AbsoluteArray[E]>
		sz <Int>
		newLastIndex <Int> |
	(self isEmpty and: [nslots <= self contents size])
		ifTrue: [self startGap: nslots.
						self lastIndex: nslots.
						^0].
	sz := self size.
	newGap := nslots max: sz.
	diff := newGap - self startGap.
	newLastIndex := newGap + sz.
	newContents := AbsoluteArray[E] new:
	self contents size + diff.
	newContents
		replaceFrom: newGap + 1
		to: newLastIndex
		with: self contents
		startingAt: self firstIndex.
	self	startGap: newGap;
		contents: newContents;
		lastIndex: newLastIndex.
	^diff! !

"September 13, 2010 -> 23:10:53"!

! (Delta mirrorFor: #AddableSequenceableCollection) methodsFor: 'private' !
makeSpaceAtStart: nslots <Int> ^<Int>
	"Make sure that there are at least nslots of unused capacity at the low
	 end of contents.  The # of slots added at the beginning is returned."

	|	newGap <Int>
		diff <Int>
		newContents <AbsoluteArray[E]>
		sz <Int>
		newLastIndex <Int> |
	(self isEmpty and: [nslots <= self contents size])
		ifTrue: [	self startGap: nslots.
						self lastIndex: nslots.
						^nslots].
	sz := self size.
	newGap := nslots max: sz.
	diff := newGap - self startGap.
	newLastIndex := newGap + sz.
	newContents := AbsoluteArray[E] new:
	self contents size + diff.
	newContents
		replaceFrom: newGap + 1
		to: newLastIndex
		with: self contents
		startingAt: self firstIndex.
	self	startGap: newGap;
		contents: newContents;
		lastIndex: newLastIndex.
	^diff! !

"September 13, 2010 -> 23:12:53"!

! (Delta mirrorFor: #AddableSequenceableCollection) methodsFor: 'accessing' !
remove: nElements <Int> at: i <Int>

	| el <E> internal <Int> |
	el := self at: i.
	internal := self startGap + i.
	self internalRangeCheck: internal.
	self internalRangeCheck: (internal + nElements) - 1.
	"nElements = self size
		ifTrue: [self startGap: self lastIndex.
						^self]."
	internal  to: lastIndex - nElements
		 do: [ :index <Int> |
			  self contents at: index put: (self contents at: index + nElements).	].
	self contents putNilAt: self lastIndex.
	self lastIndex: self lastIndex - nElements.! !

"September 13, 2010 -> 23:13:10"!

! (Delta mirrorFor: #OrderedCollectionTest) methodsFor: 'testing add:' !
testAddResizing

	|size|
	empty add: 1.
	size := empty contents size.
	100 timesRepeat: [
		empty remove: 1.
		empty add: 1].
	self assert: size = empty contents size
		description: empty contents size printString! !

"September 13, 2010 -> 23:13:43"!

! (Delta mirrorFor: #AddableSequenceableCollection) methodsFor: 'accessing' !
remove: nElements <Int> at: i <Int>

	| el <E> internal <Int> |
	el := self at: i.
	internal := self startGap + i.
	self internalRangeCheck: internal.
	self internalRangeCheck: (internal + nElements) - 1.
	internal  to: lastIndex - nElements
		 do: [ :index <Int> |
			  self contents at: index put: (self contents at: index + nElements).	].
	self contents putNilAt: self lastIndex.
	self lastIndex: self lastIndex - nElements.! !

"September 13, 2010 -> 23:14:3"!

Delta define: #ClassTestIvars123 as: (
(Class subclassOf: 'Object' instanceVariables: 'one' classInstanceVariables: 'two three')) !


"September 13, 2010 -> 23:14:3"!

(Delta mirrorFor: #ClassTestIvars123) removeDefinitionIfFail: [] !


"September 13, 2010 -> 23:17:8"!

"System saved" !
"September 22, 2010 -> 23:50:45"!

(Delta mirrorFor: #OSProcess) removeDefinitionIfFail: [] !


"September 22, 2010 -> 23:50:54"!

"System saved" !
"September 26, 2010 -> 18:16:35"!

! (Delta mirrorFor: #SortedCollectionTest) methodsFor: 'testing' !
testSortOneElement
	
	|array expected|
	array := Array with: 1.
	expected := Array with: 1.
	
	array sortUsing: [:a :b| a < b].
	self assert: array = expected! !

"September 26, 2010 -> 18:17:6"!

"System saved" !
"September 28, 2010 -> 1:10:14"!

! (Delta mirrorFor: #SortedCollectionTest) methodsFor: 'testing' !
testSortTwoElements
	
	|array expected|
	array := Array with: 1 with: 2.
	expected := Array with: 1 with: 2.
	
	array sortUsing: [:a :b| a < b].
	self assert: array = expected! !

"September 28, 2010 -> 1:10:14"!

! (Delta mirrorFor: #SortedCollectionTest) methodsFor: 'testing' !
testSortTwoElementsReversed
	
	|array expected|
	array := Array with: 2 with: 1.
	expected := Array with: 1 with: 2.
	
	array sortUsing: [:a :b| a < b].
	self assert: array = expected! !

"September 28, 2010 -> 1:10:14"!

! (Delta mirrorFor: #SortedCollectionTest) methodsFor: 'testing' !
testSortThreeElementsReversed
	
	|array expected|
	array := Array with: 3 with: 2 with: 1.
	expected := Array with: 1 with: 2 with: 3.
	
	array sortUsing: [:a :b| a < b].
	self assert: array = expected! !

"September 28, 2010 -> 1:10:14"!

! (Delta mirrorFor: #SortedCollectionTest) methodsFor: 'testing' !
testSortThreeElementsRandom
	
	|array expected|
	array := Array with: 3 with: 1 with: 2.
	expected := Array with: 1 with: 2 with: 3.
	
	array sortUsing: [:a :b| a < b].
	self assert: array = expected! !

"September 28, 2010 -> 1:11:5"!

"System saved" !
"September 28, 2010 -> 1:14:48"!

Delta define: #ArraySortTest as: (
(Class subclassOf: 'SortedCollectionTest' instanceVariables: '')) !


"September 28, 2010 -> 1:14:57"!

Delta define: #ArraySortTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"September 28, 2010 -> 1:14:57"!

Delta define: #ArraySortTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"September 28, 2010 -> 1:14:57"!

Delta define: #ArraySortTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"September 28, 2010 -> 1:14:57"!

Delta define: #ArraySortTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"September 28, 2010 -> 1:14:57"!

Delta define: #ArraySortTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"September 28, 2010 -> 1:14:57"!

Delta define: #ArraySortTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"September 28, 2010 -> 1:14:57"!

Delta define: #ArraySortTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"September 28, 2010 -> 1:14:57"!

Delta define: #ArraySortTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"September 28, 2010 -> 1:14:57"!

Delta define: #ArraySortTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"September 28, 2010 -> 1:14:57"!

Delta define: #ArraySortTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"September 28, 2010 -> 1:14:57"!

Delta define: #ArraySortTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"September 28, 2010 -> 1:15:42"!

! (Delta mirrorFor: #ArraySortTest) methodsFor: 'tests' !
testSortOneElement
	
	|array expected|
	array := Array with: 1.
	expected := Array with: 1.
	
	array newSortUsing: [:a :b| a < b].
	self assert: array = expected! !

"September 28, 2010 -> 1:16:21"!

! (Delta mirrorFor: #VarSequenceableCollection) methodsFor: 'utility' !
newSortUsing: compare <[E,E,^Boolean]>
	"Sort the elements of the collection using the specified comparison test, which must return true if
	  its first argument should not appear after its second argument (e.g. <=).   This is handy when you
	  want to sort an existing collection, rather than create a new SortedCollection, or if you need to
	  perform a number of changes without sorting, and then resort explicitly.  Note that this does NOT
	  cause the receiver to stay sorted after later changes, unlike a SortedCollection."

	self newSort: 1 to: self size using: compare! !

"September 28, 2010 -> 1:16:31"!

! (Delta mirrorFor: #VarSequenceableCollection) methodsFor: 'utility' !
newSort: l <Int> to: r <Int> using: compare <[E,E,^Boolean]>

	| i <Int> j <Int> x <E> m <Int> n <Int> |
	i := l.
	j := r.
	n := ((r - l) + 1).
	n == 0
		ifTrue: [ ^self ].

	"Pick the partition value.  For <=7 elements, use the middle element.
		For more than 7 but <= 40, use a median of three elements.  For > 40,
		use a median of three medians of three"
	m := (l + r) // 2.
	n > 7
		ifTrue: [	| pl <Int> pn <Int> s <Int> |
						pl := l.
						pn := r.
						n > 40
							ifTrue: [	s :=  n // 8.
											pl := self medianOf: pl and: pl+s and: pl+s+s using: compare.
											m := self medianOf: m-s and: m and: m+s using: compare.
											pn := self medianOf: (pn-s)-s and: pn-s and: pn using: compare.	].
						m := self medianOf: pl and: m and: pn using: compare.		].
	x := self at: m.

	[i <= j]
		whileTrue: 
			[	| ati <E> atj <E> |
			 	[compare value: x value: (ati := self at: i)]
					whileFalse: [i := i + 1].
				[compare value: (atj := self at: j) value: x]
					whileFalse: [j := j - 1].
				i <= j
					ifTrue: [	self at: i put: atj.
									self at: j put: ati.
									i := i + 1.
									j := j - 1.	]
			].
	l < j ifTrue: [self sort: l to: j using: compare].
	i < r ifTrue: [self sort: i to: r using: compare].! !

"September 28, 2010 -> 1:18:46"!

! (Delta mirrorFor: #VarSequenceableCollection) methodsFor: 'utility' !
newSort: l <Int> to: r <Int> using: compare <[E,E,^Boolean]>

	| i <Int> j <Int> x <E> m <Int> n <Int> |
	i := l.
	j := r.
	n := ((r - l) + 1).
	n == 0
		ifTrue: [ ^self ].

	"Pick the partition value.  For <=7 elements, use the middle element.
		For more than 7 but <= 40, use a median of three elements.  For > 40,
		use a median of three medians of three"
	m := (l + r) // 2.
	n > 7
		ifTrue: [	| pl <Int> pn <Int> s <Int> |
						pl := l.
						pn := r.
						n > 40
							ifTrue: [	s :=  n // 8.
											pl := self medianOf: pl and: pl+s and: pl+s+s using: compare.
											m := self medianOf: m-s and: m and: m+s using: compare.
											pn := self medianOf: (pn-s)-s and: pn-s and: pn using: compare.	].
						m := self medianOf: pl and: m and: pn using: compare.		].
	x := self at: m.

	[i <= j]
		whileTrue: 
			[	| ati <E> atj <E> |
			 	[ati := self at: i.
			 	 (compare value: x value: ati)
			 	 	and: [(compare value: ati value: x) not]]
					whileFalse: [i := i + 1].
				[compare value: (atj := self at: j) value: x]
					whileFalse: [j := j - 1].
				i <= j
					ifTrue: [	self at: i put: atj.
									self at: j put: ati.
									i := i + 1.
									j := j - 1.	]
			].
	l < j ifTrue: [self sort: l to: j using: compare].
	i < r ifTrue: [self sort: i to: r using: compare].! !

"September 28, 2010 -> 1:19:53"!

! (Delta mirrorFor: #VarSequenceableCollection) methodsFor: 'utility' !
newSort: l <Int> to: r <Int> using: compare <[E,E,^Boolean]>

	| i <Int> j <Int> x <E> m <Int> n <Int> |
	i := l.
	j := r.
	n := ((r - l) + 1).
	n == 0
		ifTrue: [ ^self ].

	"Pick the partition value.  For <=7 elements, use the middle element.
		For more than 7 but <= 40, use a median of three elements.  For > 40,
		use a median of three medians of three"
	m := (l + r) // 2.
	n > 7
		ifTrue: [	| pl <Int> pn <Int> s <Int> |
						pl := l.
						pn := r.
						n > 40
							ifTrue: [	s :=  n // 8.
											pl := self medianOf: pl and: pl+s and: pl+s+s using: compare.
											m := self medianOf: m-s and: m and: m+s using: compare.
											pn := self medianOf: (pn-s)-s and: pn-s and: pn using: compare.	].
						m := self medianOf: pl and: m and: pn using: compare.		].
	x := self at: m.

	[i <= j]
		whileTrue: 
			[	| ati <E> atj <E> |
			 	[ati := self at: i.
			 	 (compare value: x value: ati)
			 	 	and: [(compare value: ati value: x) not]]
					whileFalse: [i := i + 1].
				[atj := self at: j.
				 (compare value: atj value: x)
				 	and: [(compare value: x value: atj) noy]]
					whileFalse: [j := j - 1].
				i <= j
					ifTrue: [	self at: i put: atj.
									self at: j put: ati.
									i := i + 1.
									j := j - 1.	]
			].
	l < j ifTrue: [self sort: l to: j using: compare].
	i < r ifTrue: [self sort: i to: r using: compare].! !

"September 28, 2010 -> 1:22:58"!

! (Delta mirrorFor: #SortedCollectionTest) methodsFor: 'testing' !
testSortOneElement
	
	|array expected|
	array := Array with: 1.
	expected := Array with: 1.
	
	array sortUsing: [:a :b| a < b] halt.
	self assert: array = expected! !

"September 28, 2010 -> 1:23:23"!

! (Delta mirrorFor: #SortedCollectionTest) methodsFor: 'testing' !
testSortOneElement
	
	|array expected|
	array := Array with: 1.
	expected := Array with: 1.
	
	array sortUsing: [:a :b| a < b].
	self assert: array = expected! !

"September 28, 2010 -> 1:23:30"!

! (Delta mirrorFor: #ArraySortTest) methodsFor: 'tests' !
testSortOneElement
	
	|array expected|
	array := Array with: 1.
	expected := Array with: 1.
	
	array newSortUsing: [:a :b| a < b] halt.
	self assert: array = expected! !

"September 28, 2010 -> 1:53:47"!

"System saved" !
"September 28, 2010 -> 21:3:29"!

! (Delta mirrorFor: #VarSequenceableCollection) methodsFor: 'utility' !
newSort: l <Int> to: r <Int> using: compare <[E,E,^Boolean]>

	| i <Int> j <Int> x <E> m <Int> n <Int> |
	i := l.
	j := r.
	n := ((r - l) + 1).
	n == 0
		ifTrue: [ ^self ].

	"Pick the partition value.  For <=7 elements, use the middle element.
		For more than 7 but <= 40, use a median of three elements.  For > 40,
		use a median of three medians of three"
	m := (l + r) // 2.
	n > 7
		ifTrue: [	| pl <Int> pn <Int> s <Int> |
						pl := l.
						pn := r.
						n > 40
							ifTrue: [	s :=  n // 8.
											pl := self medianOf: pl and: pl+s and: pl+s+s using: compare.
											m := self medianOf: m-s and: m and: m+s using: compare.
											pn := self medianOf: (pn-s)-s and: pn-s and: pn using: compare.	].
						m := self medianOf: pl and: m and: pn using: compare.		].
	x := self at: m.

	[i <= j]
		whileTrue: 
			[	| ati <E> atj <E> |
			 	[ati := self at: i.
			 	 (compare value: x value: ati)
			 	 	or: [(compare value: ati value: x) not]]
					whileFalse: [i := i + 1].
				[atj := self at: j.
				 (compare value: atj value: x)
				 	and: [(compare value: x value: atj) noy]]
					whileFalse: [j := j - 1].
				i <= j
					ifTrue: [	self at: i put: atj.
									self at: j put: ati.
									i := i + 1.
									j := j - 1.	]
			].
	l < j ifTrue: [self sort: l to: j using: compare].
	i < r ifTrue: [self sort: i to: r using: compare].! !

"September 28, 2010 -> 21:7:48"!

! (Delta mirrorFor: #VarSequenceableCollection) methodsFor: 'utility' !
newSort: l <Int> to: r <Int> using: compare <[E,E,^Boolean]>

	| i <Int> j <Int> x <E> m <Int> n <Int> |
	i := l.
	j := r.
	n := ((r - l) + 1).
	n == 0
		ifTrue: [ ^self ].

	"Pick the partition value.  For <=7 elements, use the middle element.
		For more than 7 but <= 40, use a median of three elements.  For > 40,
		use a median of three medians of three"
	m := (l + r) // 2.
	n > 7
		ifTrue: [	| pl <Int> pn <Int> s <Int> |
						pl := l.
						pn := r.
						n > 40
							ifTrue: [	s :=  n // 8.
											pl := self medianOf: pl and: pl+s and: pl+s+s using: compare.
											m := self medianOf: m-s and: m and: m+s using: compare.
											pn := self medianOf: (pn-s)-s and: pn-s and: pn using: compare.	].
						m := self medianOf: pl and: m and: pn using: compare.		].
	x := self at: m.

	[i <= j]
		whileTrue: 
			[	| ati <E> atj <E> |
			 	[ati := self at: i.
			 	 (compare value: x value: ati)
			 	 	or: [(compare value: ati value: x) not]]
					whileFalse: [i := i + 1].
				[atj := self at: j.
				 (compare value: atj value: x)
				 	or: [(compare value: x value: atj) not]]
					whileFalse: [j := j - 1].
				i <= j
					ifTrue: [	self at: i put: atj.
									self at: j put: ati.
									i := i + 1.
									j := j - 1.	]
			].
	l < j ifTrue: [self sort: l to: j using: compare].
	i < r ifTrue: [self sort: i to: r using: compare].! !

"September 28, 2010 -> 21:8:26"!

! (Delta mirrorFor: #ArraySortTest) methodsFor: 'tests' !
testSortOneElement
	
	|array expected|
	array := Array with: 1.
	expected := Array with: 1.
	
	array newSortUsing: [:a :b| a < b] "halt".
	self assert: array = expected! !

"September 28, 2010 -> 21:8:46"!

! (Delta mirrorFor: #ArraySortTest) methodsFor: 'tests' !
testSortOneElement
	
	|array expected|
	array := Array with: 1.
	expected := Array with: 1.
	
	array newSortUsing: [:a :b| a < b].
	self assert: array = expected! !

"September 28, 2010 -> 21:9:24"!

! (Delta mirrorFor: #ArraySortTest) methodsFor: 'tests' !
testSortSimpleCollection

	self should: [#(5 3 1) asSortedCollection asArray = #(1 3 5)].
	self should: [#(1 3 5) asSortedCollection asArray = #(1 3 5)].
	self should: [#(1 5 3) asSortedCollection asArray = #(1 3 5)].
	self should: [#(1 2 1)asSortedCollection asArray = #(1 1 2)].
	self should: [#(1 2 1 2)asSortedCollection asArray = #(1 1 2 2)].! !

"September 28, 2010 -> 21:10:1"!

! (Delta mirrorFor: #ArraySortTest) methodsFor: 'tests' !
testSortThreeElementsRandom
	
	|array expected|
	array := Array with: 3 with: 1 with: 2.
	expected := Array with: 1 with: 2 with: 3.
	
	array newSortUsing: [:a :b| a < b].
	self assert: array = expected! !

"September 28, 2010 -> 21:10:38"!

! (Delta mirrorFor: #VarSequenceableCollection) methodsFor: 'utility' !
newSort: l <Int> to: r <Int> using: compare <[E,E,^Boolean]>

	| i <Int> j <Int> x <E> m <Int> n <Int> |
	i := l.
	j := r.
	n := ((r - l) + 1).
	n == 0
		ifTrue: [ ^self ].

	"Pick the partition value.  For <=7 elements, use the middle element.
		For more than 7 but <= 40, use a median of three elements.  For > 40,
		use a median of three medians of three"
	m := (l + r) // 2.
	n > 7
		ifTrue: [	| pl <Int> pn <Int> s <Int> |
						pl := l.
						pn := r.
						n > 40
							ifTrue: [	s :=  n // 8.
											pl := self medianOf: pl and: pl+s and: pl+s+s using: compare.
											m := self medianOf: m-s and: m and: m+s using: compare.
											pn := self medianOf: (pn-s)-s and: pn-s and: pn using: compare.	].
						m := self medianOf: pl and: m and: pn using: compare.		].
	x := self at: m.

	[i <= j]
		whileTrue: 
			[	| ati <E> atj <E> |
			 	[ati := self at: i.
			 	 (compare value: x value: ati)
			 	 	or: [(compare value: ati value: x) not]]
					whileFalse: [i := i + 1].
				[atj := self at: j.
				 (compare value: atj value: x)
				 	or: [(compare value: x value: atj) not]]
					whileFalse: [j := j - 1].
				i <= j
					ifTrue: [	self at: i put: atj.
									self at: j put: ati.
									i := i + 1.
									j := j - 1.	]
			].
	l < j ifTrue: [self newSort: l to: j using: compare].
	i < r ifTrue: [self newSort: i to: r using: compare].! !

"September 28, 2010 -> 21:11:2"!

! (Delta mirrorFor: #ArraySortTest) methodsFor: 'tests' !
testSortThreeElementsReversed
	
	|array expected|
	array := Array with: 3 with: 2 with: 1.
	expected := Array with: 1 with: 2 with: 3.
	
	array sortUsing: [:a :b| a < b].
	self assert: array = expected! !

"September 28, 2010 -> 21:11:14"!

! (Delta mirrorFor: #ArraySortTest) methodsFor: 'tests' !
testSortTwoElements
	
	|array expected|
	array := Array with: 1 with: 2.
	expected := Array with: 1 with: 2.
	
	array sortUsing: [:a :b| a < b].
	self assert: array = expected! !

"September 28, 2010 -> 21:11:27"!

! (Delta mirrorFor: #ArraySortTest) methodsFor: 'tests' !
testSortTwoElementsReversed
	
	|array expected|
	array := Array with: 2 with: 1.
	expected := Array with: 1 with: 2.
	
	array sortUsing: [:a :b| a < b].
	self assert: array = expected! !

"September 28, 2010 -> 21:12:28"!

! (Delta mirrorFor: #ArraySortTest) methodsFor: 'tests' !
testSortedCollection
	|r c s index|
	r := Random new.
	1 to: 500 do:
		[:j|	c := Array[Int] new: j.
			1 to: j do:
				[ :i <Int> |
					c at: i put: (r next * (SmallInteger maxVal - 1)) asInteger	].
			"Transcript show: 'c size = '; print: c size; cr."
			self should: [ (c newSortUsing: [ :i1 <Int> :i2 <Int> | i1 < i2 ]) isSorted ]
				description: 'collection should be sorted'].! !

"September 28, 2010 -> 21:14:27"!

! (Delta mirrorFor: #ArraySortTest) methodsFor: 'tests' !
testSortTwoElementsReversed
	
	|array expected|
	array := Array with: 2 with: 1.
	expected := Array with: 1 with: 2.
	
	array newSortUsing: [:a :b| a < b].
	self assert: array = expected! !

"September 28, 2010 -> 21:14:38"!

! (Delta mirrorFor: #ArraySortTest) methodsFor: 'tests' !
testSortTwoElements
	
	|array expected|
	array := Array with: 1 with: 2.
	expected := Array with: 1 with: 2.
	
	array newSortUsing: [:a :b| a < b].
	self assert: array = expected! !

"September 28, 2010 -> 21:18:53"!

! (Delta mirrorFor: #ArraySortTest) methodsFor: 'tests' !
testSortedCollection
	|r c s index|
	r := Random new.
	1 to: 500 do:
		[:j|	c := Array[Int] new: j.
			1 to: j do:
				[ :i <Int> |
					c at: i put: (r next * (SmallInteger maxVal - 1)) asInteger	].
			"Transcript show: 'c size = '; print: c size; cr."
			self should: [ |blk|
									blk := [ :i1 <Int> :i2 <Int> | i1 < i2 ].
									(c newSortUsing: blk) isSortedBy: blk ]
				description: 'collection should be sorted'].! !

"September 28, 2010 -> 21:22:15"!

! (Delta mirrorFor: #ArraySortTest) methodsFor: 'tests' !
testSortedCollection
	|r c s index|
	r := Random new.
	1 to: 500 do:
		[:j|	c := Array[Int] new: j.
			1 to: j do:
				[ :i <Int> |
					c at: i put: (r next * (SmallInteger maxVal - 1)) asInteger	].
			"Transcript show: 'c size = '; print: c size; cr."
			self should: [ |blk|
									blk := [ :i1 <Int> :i2 <Int> | i1 < i2 ].
									(c sortUsing: blk) isSortedBy: blk ]
				description: 'collection should be sorted'].! !

"September 28, 2010 -> 21:22:35"!

! (Delta mirrorFor: #VarSequenceableCollection) methodsFor: 'utility' !
sort: l <Int> to: r <Int> using: compare <[E,E,^Boolean]>

	| i <Int> j <Int> x <E> m <Int> n <Int> |
	i := l.
	j := r.
	n := ((r - l) + 1).
	n == 0
		ifTrue: [ ^self ].

	"Pick the partition value.  For <=7 elements, use the middle element.
		For more than 7 but <= 40, use a median of three elements.  For > 40,
		use a median of three medians of three"
	m := (l + r) // 2.
	n > 7
		ifTrue: [	| pl <Int> pn <Int> s <Int> |
						pl := l.
						pn := r.
						n > 40
							ifTrue: [	s :=  n // 8.
											pl := self medianOf: pl and: pl+s and: pl+s+s using: compare.
											m := self medianOf: m-s and: m and: m+s using: compare.
											pn := self medianOf: (pn-s)-s and: pn-s and: pn using: compare.	].
						m := self medianOf: pl and: m and: pn using: compare.		].
	x := self at: m.

	[i <= j]
		whileTrue: 
			[	| ati <E> atj <E> |
			 	[ati := self at: i.
			 	 (compare value: x value: ati)
			 	 	or: [(compare value: ati value: x) not]]
					whileFalse: [i := i + 1].
				[atj := self at: j.
				 (compare value: atj value: x)
				 	or: [(compare value: x value: atj) not]]
					whileFalse: [j := j - 1].
				i <= j
					ifTrue: [	self at: i put: atj.
									self at: j put: ati.
									i := i + 1.
									j := j - 1.	]
			].
	l < j ifTrue: [self newSort: l to: j using: compare].
	i < r ifTrue: [self newSort: i to: r using: compare].! !

"September 28, 2010 -> 21:22:50"!

! (Delta mirrorFor: #VarSequenceableCollection) methodsFor: 'utility' !
sort: l <Int> to: r <Int> using: compare <[E,E,^Boolean]>

	| i <Int> j <Int> x <E> m <Int> n <Int> |
	i := l.
	j := r.
	n := ((r - l) + 1).
	n == 0
		ifTrue: [ ^self ].

	"Pick the partition value.  For <=7 elements, use the middle element.
		For more than 7 but <= 40, use a median of three elements.  For > 40,
		use a median of three medians of three"
	m := (l + r) // 2.
	n > 7
		ifTrue: [	| pl <Int> pn <Int> s <Int> |
						pl := l.
						pn := r.
						n > 40
							ifTrue: [	s :=  n // 8.
											pl := self medianOf: pl and: pl+s and: pl+s+s using: compare.
											m := self medianOf: m-s and: m and: m+s using: compare.
											pn := self medianOf: (pn-s)-s and: pn-s and: pn using: compare.	].
						m := self medianOf: pl and: m and: pn using: compare.		].
	x := self at: m.

	[i <= j]
		whileTrue: 
			[	| ati <E> atj <E> |
			 	[ati := self at: i.
			 	 (compare value: x value: ati)
			 	 	or: [(compare value: ati value: x) not]]
					whileFalse: [i := i + 1].
				[atj := self at: j.
				 (compare value: atj value: x)
				 	or: [(compare value: x value: atj) not]]
					whileFalse: [j := j - 1].
				i <= j
					ifTrue: [	self at: i put: atj.
									self at: j put: ati.
									i := i + 1.
									j := j - 1.	]
			].
	l < j ifTrue: [self sort: l to: j using: compare].
	i < r ifTrue: [self sort: i to: r using: compare].! !

"September 28, 2010 -> 21:23:27"!

Delta define: #ClassTestIvars123 as: (
(Class subclassOf: 'Object' instanceVariables: 'one' classInstanceVariables: 'two three')) !


"September 28, 2010 -> 21:23:27"!

(Delta mirrorFor: #ClassTestIvars123) removeDefinitionIfFail: [] !


"September 28, 2010 -> 21:25:4"!

"System saved" !
"September 29, 2010 -> 19:27:33"!

"System saved" !
"October 23, 2010 -> 21:49:15"!

Delta define: #ObjectiveCMethod as: (
(Class subclassOf: 'Alien' instanceVariables: '') classVariables: 'MethodGetReturnType
NSMethodSignature') !


"October 23, 2010 -> 21:49:15"!

Delta define: #ObjectiveCMethod as: (
(Class subclassOf: 'Alien' instanceVariables: '') classVariables: 'MethodGetReturnType
NSMethodSignature') !


"October 23, 2010 -> 21:49:15"!

Delta define: #ObjectiveCMethod as: (
(Class subclassOf: 'Alien' instanceVariables: '') classVariables: 'MethodGetReturnType
NSMethodSignature') !


"October 23, 2010 -> 21:49:15"!

Delta define: #ObjectiveCMethod as: (
(Class subclassOf: 'Alien' instanceVariables: '') classVariables: 'MethodGetReturnType
NSMethodSignature') !


"October 23, 2010 -> 21:49:15"!

Delta define: #ObjectiveCMethod as: (
(Class subclassOf: 'Alien' instanceVariables: '') classVariables: 'MethodGetReturnType
NSMethodSignature') !


"October 23, 2010 -> 21:49:15"!

Delta define: #ObjectiveCMethod as: (
(Class subclassOf: 'Alien' instanceVariables: '') classVariables: 'MethodGetReturnType
NSMethodSignature') !


"October 23, 2010 -> 21:49:15"!

Delta define: #ObjectiveCMethod as: (
(Class subclassOf: 'Alien' instanceVariables: '') classVariables: 'MethodGetReturnType
NSMethodSignature') !


"October 23, 2010 -> 21:49:15"!

Delta define: #ObjectiveCMethod as: (
(Class subclassOf: 'Alien' instanceVariables: '') classVariables: 'MethodGetReturnType
NSMethodSignature') !


"October 23, 2010 -> 21:49:15"!

Delta define: #ObjectiveCMethod as: (
(Class subclassOf: 'Alien' instanceVariables: '') classVariables: 'MethodGetReturnType
NSMethodSignature') !


"October 23, 2010 -> 21:49:15"!

Delta define: #ObjectiveCMethod as: (
(Class subclassOf: 'Alien' instanceVariables: '') classVariables: 'MethodGetReturnType
NSMethodSignature') !


"October 23, 2010 -> 21:49:15"!

Delta define: #ObjectiveCMethod as: (
(Class subclassOf: 'Alien' instanceVariables: '') classVariables: 'MethodGetReturnType
NSMethodSignature') !


"October 23, 2010 -> 21:49:15"!

(Delta mirrorFor: #ObjectiveCMethod)
comment: 
'/*
 *  Method Template
 */
typedef struct objc_method *Method;

struct objc_method {
    SEL method_name;
    char *method_types;
    IMP method_imp;
};


   Copyright 2008 Cadence Design Systems, Inc.
   
   Licensed under the Apache License, Version 2.0 (the ''''License''''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0
'!


"October 23, 2010 -> 21:49:15"!

! (Delta mirrorFor: #ObjectiveCMethod) classSide methodsFor: 'initialization' !
initialize

	SystemInitializer
		addInitializer: self
		after: ObjectiveCAlien.
	Platform == MacOSXPlatform ifFalse: [^self].
	MethodGetReturnType := self lookup: 'method_getReturnType' inLibrary: '/usr/lib/libobjc.dylib'.
	"Following moved to lazy initializer - must run on main thread after Processor initialized"
	"NSMethodSignature := ObjectiveCClassAlien
          											lookup: 'NSMethodSignature'
            										inFramework: 'Foundation'"! !

"October 23, 2010 -> 21:49:15"!

! (Delta mirrorFor: #ObjectiveCMethod) classSide methodsFor: 'initialization' !
initializeNSMethodSignature

	| sem |
	sem := Semaphore new.
	MainProcess soleInstance schedule: [
		NSMethodSignature := ObjectiveCClassAlien
    		      											lookup: 'NSMethodSignature'
            												inFramework: 'Foundation'.
		sem signal].
	sem wait! !

"October 23, 2010 -> 21:49:15"!

! (Delta mirrorFor: #ObjectiveCMethod) classSide methodsFor: 'instance creation' !
dataSize
	"typedef struct objc_method *Method;

	struct objc_method {
	    SEL method_name;
	    char *method_types;
	    IMP method_imp;
	};"

	^12! !

"October 23, 2010 -> 21:49:15"!

! (Delta mirrorFor: #ObjectiveCMethod) classSide methodsFor: 'restricted' !
NSMethodSignature

	NSMethodSignature isNil
		ifTrue: [self initializeNSMethodSignature].
	^NSMethodSignature! !

"October 23, 2010 -> 21:49:15"!

! (Delta mirrorFor: #ObjectiveCMethod) methodsFor: 'accessing' !
implementation
	^Alien forPointer: (self unsignedLongAt: 9)! !

"October 23, 2010 -> 21:49:15"!

! (Delta mirrorFor: #ObjectiveCMethod) methodsFor: 'accessing' !
methodTypes
	^Alien forPointer: (self unsignedLongAt: 5)! !

"October 23, 2010 -> 21:49:15"!

! (Delta mirrorFor: #ObjectiveCMethod) methodsFor: 'accessing' !
methodTypesString
	^(Alien forPointer: (self unsignedLongAt: 5)) strcpy! !

"October 23, 2010 -> 21:49:15"!

! (Delta mirrorFor: #ObjectiveCMethod) methodsFor: 'accessing' !
rawSelector
	^Alien forPointer: (self unsignedLongAt: 1)! !

"October 23, 2010 -> 21:49:15"!

! (Delta mirrorFor: #ObjectiveCMethod) methodsFor: 'accessing' !
returnLength

	^self signature methodReturnLength! !

"October 23, 2010 -> 21:49:15"!

! (Delta mirrorFor: #ObjectiveCMethod) methodsFor: 'accessing' !
returnType

	^self signature methodReturnType! !

"October 23, 2010 -> 21:49:15"!

! (Delta mirrorFor: #ObjectiveCMethod) methodsFor: 'accessing' !
selector
	^ObjectiveCAlien forPointer: (self unsignedLongAt: 1)! !

"October 23, 2010 -> 21:49:15"!

! (Delta mirrorFor: #ObjectiveCMethod) methodsFor: 'accessing' !
signature ^<Alien>

	^(ObjectiveCMethodSignature new)
		unsignedLongAt: 1 put: ((self NSMethodSignature signatureWithObjCTypes: self methodTypes) asUnsignedLong);
		yourself! !

"October 23, 2010 -> 21:49:15"!

! (Delta mirrorFor: #ObjectiveCMethod) methodsFor: 'instance initalization' !
selector: selector "<ObjectiveCAlien>" methodTypes: string "<char * Alien>" implementation: functionPointer "<id (*IMP)(id, SEL, ...) Alien> ^<self>"
	self unsignedLongAt: 1 put: (selector unsignedLongAt: 1).
	self unsignedLongAt: 5 put: string address.
	self unsignedLongAt: 9 put: (functionPointer unsignedLongAt: 1)! !

"October 23, 2010 -> 21:49:15"!

! (Delta mirrorFor: #ObjectiveCMethod) methodsFor: 'private ' !
NSMethodSignature

	^self class NSMethodSignature! !

"October 23, 2010 -> 21:49:41"!

"System saved" !
"December 12, 2010 -> 16:41:59"!

! (Delta mirrorFor: #MacOSXFilePath) methodsFor: 'private' !
modeFor: mode <Symbol> ^<SmallInt>

    mode = #read
        ifTrue: [ ^self O_RDONLY ].
    mode = #write
        ifTrue: [ ^(self O_WRONLY bitOr: self O_CREAT) bitOr: self O_TRUNC ].
    mode = #readWrite
        ifTrue: [ ^self O_RDWR bitOr: self O_CREAT ].
    self error: 'Unrecognised mode: ' , mode! !

"December 12, 2010 -> 16:42:43"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
modeFor: mode <Symbol> ^<SmallInt>

    mode = #read
        ifTrue: [ ^self O_RDONLY ].
    mode = #write
        ifTrue: [ ^(self O_RDWR bitOr: self O_CREAT) bitOr: self O_TRUNC ].
    mode = #readWrite
        ifTrue: [ ^self O_RDWR bitOr: self O_CREAT ].
    self error: 'Unrecognised mode: ' , mode! !

"December 12, 2010 -> 16:43:44"!

"System saved" !
"December 12, 2010 -> 17:35:29"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
W_OK

	^2! !

"December 12, 2010 -> 17:40:31"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
access: mode ifFail: block

	| name result |
	name := CString for: self name.
	[result := {{<libc ExternalProxy access>
						name: name
						mode: mode}}.
	^result isAllOnes not]
		ensure: [name free]! !

"December 12, 2010 -> 17:42:12"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
isWriteable

    "^self stat: [:stat| 
    				(stat uid == self geteuid and: [(stat mode bitAnd: self S_IWUSR) == self S_IWUSR])
    					or: [(stat gid == self getegid and: [(stat mode bitAnd: self S_IWGRP) == self S_IWGRP])
    					or: [(stat mode bitAnd: self S_IWOTH) == self S_IWOTH]]]
    	ifFail: [ self statFailed ]"
    ^self access: self W_OK ifFail: []! !

"December 12, 2010 -> 17:43:8"!

"System saved" !