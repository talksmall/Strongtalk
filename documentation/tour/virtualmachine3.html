<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<title>The Virtual Machine</title>
</head>

<body bgcolor="#FFFFFF">
<h3 align="right"><a href="virtualmachine2.html">&lt;== Previous</a> |	
 <a href="toc.html">Contents</a> |
 <a href="virtualmachine4.html"><strong>Next ==&gt;</strong></a></h3>
<h2 align="left">The Virtual Machine (cont.)</h2>

<h3 align="left">The Consequences of Adaptive Optimization for
Coding Style</h3>

<p align="left">The previous example dramatically illustrates the
<em>change in the Smalltalk execution cost model</em> that occurs
in the Strongtalk system. This change in the cost model
encourages programmers to write in a much more factored,
high-level coding style. The Strongtalk class libraries take
extensive advantage of this effect. They use instance variable
accessor methods almost universally, and create extensive custom
control structures through use of Blocks, even in the most
performance critical spots in the system. </p>

<p align="left">Here are two examples of this that will surprise
people familiar with other Smalltalk implementations. In
Strongtalk, the implementations of Array&gt;&gt;at: and
Array&gt;&gt;at:put:, two of the most performance critical
methods in the system, actually send another internal message
that then invokes a primitive, rather than invoking the primitive
directly. The extra send imposes <em>no </em>cost.</p>

<p align="left">Dictionary&gt;&gt;at: is an even more extreme
example. It is implemented in a highly factored, abstract way in
the HashedCollection superclass of Dictionary, and sends over 20 <em>real</em>
messages in the common case, not counting integer arithmetic and
boolean control structures, and uses 3 <em>copying</em> blocks,
one <em>full</em> block, and uses many other <em>clean</em>
blocks (not counting blocks used with hard-wired boolean control
structures). This would be wildly inefficient in other Smalltalk
systems, yet running on the Strongtalk VM it is actually much <em>faster</em>
than the hand-optimized implementations in other Smalltalk
systems. As an experiment, I ported my Dictionary implementation
to the VisualWorks VM to compare its performance, and it ran
about 35 times slower than on the Strongtalk VM. This illustrates
clearly the infeasibility of writing performance-critical code in
this style without adaptive inlining.</p>

<h3 align="left">Examining the Inlining Structure</h3>

<p align="left">On the previous page, we ran a benchmark, and I
claimed that the VM was doing extensive inlining on the benchmark
code. Now let's verify that by looking at the actual inlining
structure generated by the adaptive compiler. Here is what the VM
reports as the inlining structure for #notSoSimpleTest:</p>

<blockquote>
    <div align="left"><pre>Test class::notSoSimpleTest:
  11 Array class::new:
    2 Array class::primitiveNew:
  27 uncommon
  31 Test class::fancyStoreIntoArray:
    9 Test class::evaluateBlock:
      2 BlockWithoutArguments::value
        2 Test class-&gt;fancyStoreIntoArray: 4
          6 Array::at:put:
            3 Array::primitiveAt:put:
              4 uncommon
          6 uncommon
  44 SmallInteger::+
  56 SmallInteger::&gt;=</pre>
    </div>
</blockquote>

<p align="left">This text, while somewhat cryptic, lays out
clearly the inlining structure. It is in <em>inlining-database</em>
format, which I will give you a link to more information on
below. You can ignore the numbers, which just indicate the
bytecode offset in the method of the send that was inlined. The
structure of each inlined method is recursively displayed in
indented form. Thus, you can see on the second line that the
(Array class::new:) method is inlined, and it in turn has an
inlined send of (Array class::primitiveNew:). Note also that the
Array::at:put: method actually contains an inlined send of
primitiveAt:put:, as we mentioned previously.</p>

<p align="left">You can see clearly that <em>all</em> the
important sends in the benchmark are being inlined, all the way
down to SmallInteger operations and primitives. You can also see
that the block that we used is inlined (it is indented below the
line with BlockWithoutArguments::value), so that no block closure
needs to be allocated.</p>

<p align="left">If you are interested in the inlining database
(which is not turned on by default) or examining and controlling
compilation, you can read some more details <a
href="compilationcontrol.html">here</a> before proceeding.</p>

<h3 align="right"><a href="virtualmachine4.html"><strong>The
Virtual Machine (cont.) ==&gt;</strong></a></h3>
</body>
</html>
