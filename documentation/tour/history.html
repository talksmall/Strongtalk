<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<title>The Strongtalk System</title>
</head>

<body bgcolor="#FFFFFF">

<h2>More on the History of the Strongtalk System</h2>

<p>There were really two different threads to the prehistory of
the Strongtalk system, starting with two separate research
efforts on different sides of the country.</p>

<p><strong>On the West Coast</strong>, the Self group at Sun
Microsystems Labs, headed by David Ungar and Randall Smith, spent
years working on some really radical virtual machine technology,
originally with the goal of getting their prototype-based object
language, Self, to perform well. They had a very advanced VM
architecture, with excellent garbage collection, but the real
challenge was in the compilation technology, because Self, like
Smalltalk, was a pure object language, meaning that all the basic
data-types in the system were real objects, unlike C++, Java, or
C#. That, combined with the fact that Self (also like Smalltalk)
is a dynamically-typed language, imposes a significant cost when
manipulating really fundamental things like booleans and
integers, because when the compiler sees a+b, or (flag ifTrue:
[...]), it can't assume that they are integers or booleans,
because they might be something else, each and every time they
get executed, and you have to handle those other cases somehow.
Also, both Self and Smalltalk depend on Blocks (function objects
with closures) for all control structures, which also imposes a
lot of overhead.</p>

<p>Making the problem even worse for Self was the fact that they
didn't have any direct variable access- ALL variable access had
to go through accessor methods (the apparent variable access
syntax was just sugar for accessor messages). So they put a
tremendous amount of effort into better compilation technology.</p>

<p>The real breakthrough on the VM side came with Urs Hoelzle's
type-feedback compiler, which for the first time allowed the vast
majority of message sends in general purpose code to be inlined.
Once things are inlined (often many levels deep), the compiler
can do a much better job of optimizing the code, and this is
necessary to produce big performance gains. This requires a lot
of really exotic technology, like optimistic inlining with the
ability to deoptimize and back out on-the-fly if something
happens that violates the optimistic inlining assumptions.</p>

<p>The Self system was a real research tour-de-force, but Self
has quite a few fundamental differences from Smalltalk, and the
system was not designed for commercial or production use, since
it was not very stable and used an enormous amount of memory. But
it showed for the first time that pure, dynamically-typed
languages like Self and Smalltalk in principle could be gotten
much closer to the performance of C.</p>

<p><font color="#000000"><strong>On the East Coast,</strong> I
(D.G.) was frustrated with the fact that there were still a lot
of obstacles to using Smalltalk in most kinds of production
applications. ParcPlace and Digitalk had made a lot of progress,
especially with Deutsch/Schiffman dynamic translation technology,
which sped up Smalltalk by a factor of 1.6 or so at the time. But
it was still way too slow for any kind of compute intensive
application (which I was doing), and I felt there were several
other obstacles to widespread use as well. One of the biggest
among these in my mind was the lack of any kind of type system,
which although it makes the language extremely flexible, also
means that organizing and understanding large-scale software
systems is a lot harder. Another was poor support for native user
interfaces, in the interest of portability. Although this was a
nice idea for people who were ideologically dedicated to
portability, in practice at the time (and to a large extent even
now) people needed to write UIs that weren't out of place on
Windows machines (emulated widgets just don't cut it).</font></p>

<p>Several people had tried to build type systems for Smalltalk
(Borning&amp;Ingalls, Palsberg&amp;Schwartzbach, Graver&amp;Johnson), but it
was clearly an enormously difficult task, because of the vastly
more flexible nature of the way Smalltalk is used compared to any
existing statically-typed language, not to mention the
unprecedented problem of having to retrofit a type system onto
existing untyped code. In addition to the fact that none of the
few existing type-system efforts worked on anything other than
tiny bodies of code, it was obvious that none of the previous
efforts were even close to being the right kind of technology for
the real world.</p>

<p>However, I was convinced that it was possible to do something
about it, and so I hired Gilad Bracha, who knew a lot about this
stuff, as well as about mixins and things, and we set about
building a type system for Smalltalk that would actually work.
The first generation of the type system, which we wrote about in
the '93 OOPSLA proceedings, worked but was pretty ungainly
because it was grafted on top of the ParcPlace libraries. This
makes things a lot harder, because to really do a typed Smalltalk
right, you need to structure your basic libraries differently so
you can typecheck the inheritance relationships. The existing
Smalltalk libraries are full of inheritance relationships that
just aren't subtype compatible (e.g. Dictionary and Set), and so
we had to use a declared hierarchy that differed from actual
underlying hierarchy.</p>

<p>At the same time, I was exploring various paths to speeding up
Smalltalk (since the type system was not used for optimization),
but without the kind of exotic optimistic-inlining technology the
Self group used, the obstacle seemed insurmountable. The best I
could figure out how to do without it was to use one simpler
technique the Self group used, customization (copying methods
down through inheritance so that self sends can be inlined), but
I computed that for the ParcPlace library the best that would do
would be to inline about 25% of sends, statically.</p>

<p>I suspect other people trying to make Smalltalk faster were
running into basically the same problem, and we all thought the
Self system had the kind of technology that would eventually
solve the problem, but it looked so advanced and complicated that
it looked at least 10 years away from commercialization. I think
that incredible apparent difficulty was what stopped everyone
else from adopting the Self technology. It was just too daunting.</p>

<p><strong>The two technologies came together</strong> when I
started talking to Urs Hoelzle, who had finished the
second-generation Self compiler (and his Stanford thesis), and
was looking for something interesting to do. After reading his
thesis on type-feedback, I realized that the type-feedback
technology was actually not as conceptually difficult as most
people had thought: people had read all the Self papers and been
impressed but terrified of it. No one else seemed to pick up on
the fact that the type-feedback technology was actually nicely
suited for a good, production-quality compiler, although a lot of
changes and adaptations were needed compared to the way it was
used in Self.</p>

<p>So this was a perfect opportunity- with Urs' technology (as
well as Lars Bak, who had done a tremendous amount of work on the
Self VM and knew its architecture inside and out), we had a type
system and a compilation technology, which together were
perfectly suited for a great production Smalltalk system, since
they were independent of each other. This independence was
critical, since the system would need to accept untyped as well
as typed code, so that people could use the type system as much
or as little as they wanted to, without impacting performance.</p>

<p>So then we found some other really talented people, and put
together a great team (in alphabetical order):</p>

<ul>
    <li><strong>Lars Bak</strong> was the VM wizard.</li>
    <li><strong>Gilad Bracha</strong> wrote the typechecker, the
        reflective interface support, and mixins at the Smalltalk
        level.</li>
    <li><strong>Steffen Grarup</strong> wrote the programming
        environment, as well as the source code manager and other
        things.</li>
    <li><strong>Robert Griesemer</strong> wrote the interpreter,
        the interpreter generator, most of the compiler, and
        other VM stuff. (He also wrote an even better compiler
        than the one running in this version, but it wasn't quite
        finished enough for us to use for this release- it would
        have been considerably faster).</li>
    <li>I<strong> </strong>(David Griswold) wrote the typed
        &quot;Blue Book&quot; libraries, and the glyph-based
        user-interface framework, the widgets and the HTML
        browser, and also managed the group.</li>
    <li><strong>Urs Hoelzle</strong> of course worked on the
        compiler and the tricky inlining infrastructure that it
        used, and other VM stuff.</li>
    <li>Later, <strong>Srdjan Mitrovic</strong> joined and did
        most of the adaptation of the technology to Java.</li>
</ul>

<p>As mentioned in the introduction, work started on the system
in the fall of 1994, and by 1996 the system was working nicely,
but then the Java phenomenon happened and we eventually had to
switch to Java before ever releasing it. The only public display
of the technology was in late 1996, when we had a booth at OOPSLA
and got quite a bit of attention. A few people got to evaluate it
privately, and got terrific benchmark results (one well-known guy
even got a speedup of 12 on some real Smalltalk code), but after
that it disappeared from view, as we focused on Java.</p>
</body>
</html>
